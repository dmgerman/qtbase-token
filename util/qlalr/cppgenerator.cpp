begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QLALR module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"cppgenerator.h"
end_include
begin_include
include|#
directive|include
file|"lalr.h"
end_include
begin_include
include|#
directive|include
file|"recognizer.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qbitarray.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qtextstream.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qfile.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmap.h>
end_include
begin_function
DECL|function|copyrightHeader
name|QString
name|CppGenerator
operator|::
name|copyrightHeader
parameter_list|()
specifier|const
block|{
return|return
name|QLatin1String
argument_list|(
literal|"/****************************************************************************\n"
literal|"**\n"
literal|"** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).\n"
literal|"** Contact: http://www.qt-project.org/legal\n"
literal|"**\n"
literal|"** This file is part of the Qt Toolkit.\n"
literal|"**\n"
literal|"** $QT_BEGIN_LICENSE:LGPL$\n"
literal|"** Commercial License Usage\n"
literal|"** Licensees holding valid commercial Qt licenses may use this file in\n"
literal|"** accordance with the commercial license agreement provided with the\n"
literal|"** Software or, alternatively, in accordance with the terms contained in\n"
literal|"** a written agreement between you and Digia.  For licensing terms and\n"
literal|"** conditions see http://qt.digia.com/licensing.  For further information\n"
literal|"** use the contact form at http://qt.digia.com/contact-us.\n"
literal|"**\n"
literal|"** GNU Lesser General Public License Usage\n"
literal|"** Alternatively, this file may be used under the terms of the GNU Lesser\n"
literal|"** General Public License version 2.1 as published by the Free Software\n"
literal|"** Foundation and appearing in the file LICENSE.LGPL included in the\n"
literal|"** packaging of this file.  Please review the following information to\n"
literal|"** ensure the GNU Lesser General Public License version 2.1 requirements\n"
literal|"** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.\n"
literal|"**\n"
literal|"** In addition, as a special exception, Digia gives you certain additional\n"
literal|"** rights.  These rights are described in the Digia Qt LGPL Exception\n"
literal|"** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.\n"
literal|"**\n"
literal|"** GNU General Public License Usage\n"
literal|"** Alternatively, this file may be used under the terms of the GNU\n"
literal|"** General Public License version 3.0 as published by the Free Software\n"
literal|"** Foundation and appearing in the file LICENSE.GPL included in the\n"
literal|"** packaging of this file.  Please review the following information to\n"
literal|"** ensure the GNU General Public License version 3.0 requirements will be\n"
literal|"** met: http://www.gnu.org/copyleft/gpl.html.\n"
literal|"**\n"
literal|"**\n"
literal|"** $QT_END_LICENSE$\n"
literal|"**\n"
literal|"****************************************************************************/\n"
literal|"\n"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|privateCopyrightHeader
name|QString
name|CppGenerator
operator|::
name|privateCopyrightHeader
parameter_list|()
specifier|const
block|{
return|return
name|QLatin1String
argument_list|(
literal|"//\n"
literal|"//  W A R N I N G\n"
literal|"//  -------------\n"
literal|"//\n"
literal|"// This file is not part of the Qt API.  It exists for the convenience\n"
literal|"// of other Qt classes.  This header file may change from version to\n"
literal|"// version without notice, or even be removed.\n"
literal|"//\n"
literal|"// We mean it.\n"
literal|"//\n"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|startIncludeGuard
name|QString
name|CppGenerator
operator|::
name|startIncludeGuard
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
specifier|const
name|QString
name|normalized
argument_list|(
name|QString
argument_list|(
name|fileName
argument_list|)
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
argument_list|)
operator|.
name|toUpper
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"#ifndef %1\n"
literal|"#define %2\n"
argument_list|)
operator|.
name|arg
argument_list|(
name|normalized
argument_list|,
name|normalized
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|endIncludeGuard
name|QString
name|CppGenerator
operator|::
name|endIncludeGuard
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
specifier|const
name|QString
name|normalized
argument_list|(
name|QString
argument_list|(
name|fileName
argument_list|)
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
argument_list|)
operator|.
name|toUpper
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"#endif // %1\n"
argument_list|)
operator|.
name|arg
argument_list|(
name|normalized
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|operator ()
name|void
name|CppGenerator
operator|::
name|operator
name|()
parameter_list|()
block|{
comment|// action table...
name|state_count
operator|=
name|aut
operator|.
name|states
operator|.
name|size
argument_list|()
expr_stmt|;
name|terminal_count
operator|=
name|grammar
operator|.
name|terminals
operator|.
name|size
argument_list|()
expr_stmt|;
name|non_terminal_count
operator|=
name|grammar
operator|.
name|non_terminals
operator|.
name|size
argument_list|()
expr_stmt|;
DECL|macro|ACTION
define|#
directive|define
name|ACTION
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
value|table [(i) * terminal_count + (j)]
DECL|macro|GOTO
define|#
directive|define
name|GOTO
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
value|pgoto [(i) * non_terminal_count + (j)]
name|int
modifier|*
name|table
init|=
operator|new
name|int
index|[
name|state_count
operator|*
name|terminal_count
index|]
decl_stmt|;
operator|::
name|memset
argument_list|(
name|table
argument_list|,
literal|0
argument_list|,
name|state_count
operator|*
name|terminal_count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|int
modifier|*
name|pgoto
init|=
operator|new
name|int
index|[
name|state_count
operator|*
name|non_terminal_count
index|]
decl_stmt|;
operator|::
name|memset
argument_list|(
name|pgoto
argument_list|,
literal|0
argument_list|,
name|state_count
operator|*
name|non_terminal_count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|accept_state
operator|=
operator|-
literal|1
expr_stmt|;
name|int
name|shift_reduce_conflict_count
init|=
literal|0
decl_stmt|;
name|int
name|reduce_reduce_conflict_count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|StatePointer
name|state
init|=
name|aut
operator|.
name|states
operator|.
name|begin
argument_list|()
init|;
name|state
operator|!=
name|aut
operator|.
name|states
operator|.
name|end
argument_list|()
condition|;
operator|++
name|state
control|)
block|{
name|int
name|q
init|=
name|aut
operator|.
name|id
argument_list|(
name|state
argument_list|)
decl_stmt|;
for|for
control|(
name|Bundle
operator|::
name|iterator
name|a
init|=
name|state
operator|->
name|bundle
operator|.
name|begin
argument_list|()
init|;
name|a
operator|!=
name|state
operator|->
name|bundle
operator|.
name|end
argument_list|()
condition|;
operator|++
name|a
control|)
block|{
name|int
name|symbol
init|=
name|aut
operator|.
name|id
argument_list|(
name|a
operator|.
name|key
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|aut
operator|.
name|id
argument_list|(
name|a
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|r
operator|<
name|state_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|grammar
operator|.
name|isNonTerminal
argument_list|(
name|a
operator|.
name|key
argument_list|()
argument_list|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|symbol
operator|>=
name|terminal_count
operator|&&
name|symbol
operator|<
name|grammar
operator|.
name|names
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|GOTO
argument_list|(
name|q
argument_list|,
name|symbol
operator|-
name|terminal_count
argument_list|)
operator|=
name|r
expr_stmt|;
block|}
else|else
name|ACTION
argument_list|(
name|q
argument_list|,
name|symbol
argument_list|)
operator|=
name|r
expr_stmt|;
block|}
for|for
control|(
name|ItemPointer
name|item
init|=
name|state
operator|->
name|closure
operator|.
name|begin
argument_list|()
init|;
name|item
operator|!=
name|state
operator|->
name|closure
operator|.
name|end
argument_list|()
condition|;
operator|++
name|item
control|)
block|{
if|if
condition|(
name|item
operator|->
name|dot
operator|!=
name|item
operator|->
name|end_rhs
argument_list|()
condition|)
continue|continue;
name|int
name|r
init|=
name|aut
operator|.
name|id
argument_list|(
name|item
operator|->
name|rule
argument_list|)
decl_stmt|;
name|NameSet
name|lookaheads
init|=
name|aut
operator|.
name|lookaheads
operator|.
name|value
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|rule
operator|==
name|grammar
operator|.
name|goal
condition|)
name|accept_state
operator|=
name|q
expr_stmt|;
foreach|foreach
control|(
name|Name
name|s
decl|,
name|lookaheads
control|)
block|{
name|int
modifier|&
name|u
init|=
name|ACTION
argument_list|(
name|q
argument_list|,
name|aut
operator|.
name|id
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|==
literal|0
condition|)
name|u
operator|=
operator|-
name|r
expr_stmt|;
elseif|else
if|if
condition|(
name|u
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|qout
operator|<<
literal|"*** Warning. Found a reduce/reduce conflict in state "
operator|<<
name|q
operator|<<
literal|" on token ``"
operator|<<
name|s
operator|<<
literal|"'' between rule "
operator|<<
name|r
operator|<<
literal|" and "
operator|<<
operator|-
name|u
operator|<<
name|endl
expr_stmt|;
operator|++
name|reduce_reduce_conflict_count
expr_stmt|;
name|u
operator|=
name|qMax
argument_list|(
name|u
argument_list|,
operator|-
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|qout
operator|<<
literal|"\tresolved using rule "
operator|<<
operator|-
name|u
operator|<<
name|endl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|rule
operator|->
name|prec
operator|!=
name|grammar
operator|.
name|names
operator|.
name|end
argument_list|()
operator|&&
name|grammar
operator|.
name|token_info
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|Grammar
operator|::
name|TokenInfo
name|info_r
init|=
name|grammar
operator|.
name|token_info
operator|.
name|value
argument_list|(
name|item
operator|->
name|rule
operator|->
name|prec
argument_list|)
decl_stmt|;
name|Grammar
operator|::
name|TokenInfo
name|info_s
init|=
name|grammar
operator|.
name|token_info
operator|.
name|value
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|info_r
operator|.
name|prec
operator|>
name|info_s
operator|.
name|prec
condition|)
name|u
operator|=
operator|-
name|r
expr_stmt|;
elseif|else
if|if
condition|(
name|info_r
operator|.
name|prec
operator|==
name|info_s
operator|.
name|prec
condition|)
block|{
switch|switch
condition|(
name|info_r
operator|.
name|assoc
condition|)
block|{
case|case
name|Grammar
operator|::
name|Left
case|:
name|u
operator|=
operator|-
name|r
expr_stmt|;
break|break;
case|case
name|Grammar
operator|::
name|Right
case|:
comment|// shift... nothing to do
break|break;
case|case
name|Grammar
operator|::
name|NonAssoc
case|:
name|u
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|// switch
block|}
block|}
else|else
block|{
operator|++
name|shift_reduce_conflict_count
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|qout
operator|<<
literal|"*** Warning. Found a shift/reduce conflict in state "
operator|<<
name|q
operator|<<
literal|" on token ``"
operator|<<
name|s
operator|<<
literal|"'' with rule "
operator|<<
name|r
operator|<<
name|endl
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|shift_reduce_conflict_count
operator|||
name|reduce_reduce_conflict_count
condition|)
block|{
if|if
condition|(
name|shift_reduce_conflict_count
operator|!=
name|grammar
operator|.
name|expected_shift_reduce
operator|||
name|reduce_reduce_conflict_count
operator|!=
name|grammar
operator|.
name|expected_reduce_reduce
condition|)
name|qerr
operator|<<
literal|"*** Conflicts: "
operator|<<
name|shift_reduce_conflict_count
operator|<<
literal|" shift/reduce, "
operator|<<
name|reduce_reduce_conflict_count
operator|<<
literal|" reduce/reduce"
operator|<<
name|endl
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|qout
operator|<<
name|endl
operator|<<
literal|"*** Conflicts: "
operator|<<
name|shift_reduce_conflict_count
operator|<<
literal|" shift/reduce, "
operator|<<
name|reduce_reduce_conflict_count
operator|<<
literal|" reduce/reduce"
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
block|}
name|QBitArray
name|used_rules
argument_list|(
name|grammar
operator|.
name|rules
operator|.
name|count
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|q
init|=
literal|0
decl_stmt|;
for|for
control|(
name|StatePointer
name|state
init|=
name|aut
operator|.
name|states
operator|.
name|begin
argument_list|()
init|;
name|state
operator|!=
name|aut
operator|.
name|states
operator|.
name|end
argument_list|()
condition|;
operator|++
name|state
operator|,
operator|++
name|q
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|terminal_count
condition|;
operator|++
name|j
control|)
block|{
name|int
modifier|&
name|u
init|=
name|ACTION
argument_list|(
name|q
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|<
literal|0
condition|)
name|used_rules
operator|.
name|setBit
argument_list|(
operator|-
name|u
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|used_rules
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|used_rules
operator|.
name|testBit
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|RulePointer
name|rule
init|=
name|grammar
operator|.
name|rules
operator|.
name|begin
argument_list|()
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|rule
operator|!=
name|grammar
operator|.
name|goal
condition|)
name|qerr
operator|<<
literal|"*** Warning: Rule ``"
operator|<<
operator|*
name|rule
operator|<<
literal|"'' is useless!"
operator|<<
name|endl
expr_stmt|;
block|}
block|}
name|q
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|StatePointer
name|state
init|=
name|aut
operator|.
name|states
operator|.
name|begin
argument_list|()
init|;
name|state
operator|!=
name|aut
operator|.
name|states
operator|.
name|end
argument_list|()
condition|;
operator|++
name|state
operator|,
operator|++
name|q
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|terminal_count
condition|;
operator|++
name|j
control|)
block|{
name|int
modifier|&
name|u
init|=
name|ACTION
argument_list|(
name|q
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|>=
literal|0
condition|)
continue|continue;
name|RulePointer
name|rule
init|=
name|grammar
operator|.
name|rules
operator|.
name|begin
argument_list|()
operator|+
operator|(
operator|-
name|u
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|defaultReduce
operator|==
name|rule
condition|)
name|u
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// ... compress the goto table
name|defgoto
operator|.
name|resize
argument_list|(
name|non_terminal_count
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|non_terminal_count
condition|;
operator|++
name|j
control|)
block|{
name|count
operator|.
name|fill
argument_list|(
literal|0
argument_list|,
name|state_count
argument_list|)
expr_stmt|;
name|int
modifier|&
name|mx
init|=
name|defgoto
index|[
name|j
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|state_count
condition|;
operator|++
name|i
control|)
block|{
name|int
name|r
init|=
name|GOTO
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
continue|continue;
operator|++
name|count
index|[
name|r
index|]
expr_stmt|;
if|if
condition|(
name|count
index|[
name|r
index|]
operator|>
name|count
index|[
name|mx
index|]
condition|)
name|mx
operator|=
name|r
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|state_count
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|non_terminal_count
condition|;
operator|++
name|j
control|)
block|{
name|int
modifier|&
name|r
init|=
name|GOTO
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|defgoto
index|[
name|j
index|]
condition|)
name|r
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|compressed_action
argument_list|(
name|table
argument_list|,
name|state_count
argument_list|,
name|terminal_count
argument_list|)
expr_stmt|;
name|compressed_goto
argument_list|(
name|pgoto
argument_list|,
name|state_count
argument_list|,
name|non_terminal_count
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|table
expr_stmt|;
name|table
operator|=
literal|0
expr_stmt|;
operator|delete
index|[]
name|pgoto
expr_stmt|;
name|pgoto
operator|=
literal|0
expr_stmt|;
DECL|macro|ACTION
undef|#
directive|undef
name|ACTION
DECL|macro|GOTO
undef|#
directive|undef
name|GOTO
if|if
condition|(
operator|!
name|grammar
operator|.
name|merged_output
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QFile
name|f
argument_list|(
name|grammar
operator|.
name|merged_output
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** cannot create %s\n"
argument_list|,
name|qPrintable
argument_list|(
name|grammar
operator|.
name|merged_output
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|QTextStream
name|out
argument_list|(
operator|&
name|f
argument_list|)
decl_stmt|;
comment|// copyright headers must come first, otherwise the headers tests will fail
if|if
condition|(
name|copyright
condition|)
block|{
name|out
operator|<<
name|copyrightHeader
argument_list|()
operator|<<
name|privateCopyrightHeader
argument_list|()
operator|<<
name|endl
expr_stmt|;
block|}
name|out
operator|<<
literal|"// This file was generated by qlalr - DO NOT EDIT!\n"
expr_stmt|;
name|out
operator|<<
name|startIncludeGuard
argument_list|(
name|grammar
operator|.
name|merged_output
argument_list|)
operator|<<
name|endl
expr_stmt|;
if|if
condition|(
name|copyright
condition|)
block|{
name|out
operator|<<
literal|"#if defined(ERROR)"
operator|<<
name|endl
operator|<<
literal|"#  undef ERROR"
operator|<<
name|endl
operator|<<
literal|"#endif"
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
block|}
name|generateDecl
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|generateImpl
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|<<
name|p
operator|.
name|decls
argument_list|()
expr_stmt|;
name|out
operator|<<
name|p
operator|.
name|impls
argument_list|()
expr_stmt|;
name|out
operator|<<
name|endl
expr_stmt|;
name|out
operator|<<
name|endIncludeGuard
argument_list|(
name|grammar
operator|.
name|merged_output
argument_list|)
operator|<<
name|endl
expr_stmt|;
return|return;
block|}
comment|// default behaviour
name|QString
name|declFileName
init|=
name|grammar
operator|.
name|table_name
operator|.
name|toLower
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|"_p.h"
argument_list|)
decl_stmt|;
name|QString
name|bitsFileName
init|=
name|grammar
operator|.
name|table_name
operator|.
name|toLower
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|".cpp"
argument_list|)
decl_stmt|;
block|{
comment|// decls...
name|QFile
name|f
argument_list|(
name|declFileName
argument_list|)
decl_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
argument_list|)
expr_stmt|;
name|QTextStream
name|out
argument_list|(
operator|&
name|f
argument_list|)
decl_stmt|;
name|QString
name|prot
init|=
name|declFileName
operator|.
name|toUpper
argument_list|()
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
argument_list|)
decl_stmt|;
comment|// copyright headers must come first, otherwise the headers tests will fail
if|if
condition|(
name|copyright
condition|)
block|{
name|out
operator|<<
name|copyrightHeader
argument_list|()
operator|<<
name|privateCopyrightHeader
argument_list|()
operator|<<
name|endl
expr_stmt|;
block|}
name|out
operator|<<
literal|"// This file was generated by qlalr - DO NOT EDIT!\n"
expr_stmt|;
name|out
operator|<<
literal|"#ifndef "
operator|<<
name|prot
operator|<<
name|endl
operator|<<
literal|"#define "
operator|<<
name|prot
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
if|if
condition|(
name|copyright
condition|)
block|{
name|out
operator|<<
literal|"#include<QtCore/qglobal.h>"
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
name|out
operator|<<
literal|"QT_BEGIN_NAMESPACE"
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
block|}
name|generateDecl
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyright
condition|)
name|out
operator|<<
literal|"QT_END_NAMESPACE"
operator|<<
name|endl
expr_stmt|;
name|out
operator|<<
literal|"#endif // "
operator|<<
name|prot
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
block|}
comment|// end decls
block|{
comment|// bits...
name|QFile
name|f
argument_list|(
name|bitsFileName
argument_list|)
decl_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
argument_list|)
expr_stmt|;
name|QTextStream
name|out
argument_list|(
operator|&
name|f
argument_list|)
decl_stmt|;
comment|// copyright headers must come first, otherwise the headers tests will fail
if|if
condition|(
name|copyright
condition|)
name|out
operator|<<
name|copyrightHeader
argument_list|()
expr_stmt|;
name|out
operator|<<
literal|"// This file was generated by qlalr - DO NOT EDIT!\n"
expr_stmt|;
name|out
operator|<<
literal|"#include \""
operator|<<
name|declFileName
operator|<<
literal|"\""
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
if|if
condition|(
name|copyright
condition|)
name|out
operator|<<
literal|"QT_BEGIN_NAMESPACE"
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
name|generateImpl
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyright
condition|)
name|out
operator|<<
literal|"QT_END_NAMESPACE"
operator|<<
name|endl
expr_stmt|;
block|}
comment|// end bits
if|if
condition|(
operator|!
name|grammar
operator|.
name|decl_file_name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QFile
name|f
argument_list|(
name|grammar
operator|.
name|decl_file_name
argument_list|)
decl_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
argument_list|)
expr_stmt|;
name|QTextStream
name|out
argument_list|(
operator|&
name|f
argument_list|)
decl_stmt|;
name|out
operator|<<
name|p
operator|.
name|decls
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|grammar
operator|.
name|impl_file_name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QFile
name|f
argument_list|(
name|grammar
operator|.
name|impl_file_name
argument_list|)
decl_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
argument_list|)
expr_stmt|;
name|QTextStream
name|out
argument_list|(
operator|&
name|f
argument_list|)
decl_stmt|;
name|out
operator|<<
name|p
operator|.
name|impls
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|debugInfoProt
name|QString
name|CppGenerator
operator|::
name|debugInfoProt
parameter_list|()
specifier|const
block|{
name|QString
name|prot
init|=
name|QLatin1String
argument_list|(
literal|"QLALR_NO_"
argument_list|)
decl_stmt|;
name|prot
operator|+=
name|grammar
operator|.
name|table_name
operator|.
name|toUpper
argument_list|()
expr_stmt|;
name|prot
operator|+=
name|QLatin1String
argument_list|(
literal|"_DEBUG_INFO"
argument_list|)
expr_stmt|;
return|return
name|prot
return|;
block|}
end_function
begin_function
DECL|function|generateDecl
name|void
name|CppGenerator
operator|::
name|generateDecl
parameter_list|(
name|QTextStream
modifier|&
name|out
parameter_list|)
block|{
name|out
operator|<<
literal|"class "
operator|<<
name|grammar
operator|.
name|table_name
operator|<<
name|endl
operator|<<
literal|"{"
operator|<<
name|endl
operator|<<
literal|"public:"
operator|<<
name|endl
operator|<<
literal|"  enum VariousConstants {"
operator|<<
name|endl
expr_stmt|;
foreach|foreach
control|(
name|Name
name|t
decl|,
name|grammar
operator|.
name|terminals
control|)
block|{
name|QString
name|name
init|=
operator|*
name|t
decl_stmt|;
name|int
name|value
init|=
name|std
operator|::
name|distance
argument_list|(
name|grammar
operator|.
name|names
operator|.
name|begin
argument_list|()
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"$end"
argument_list|)
condition|)
name|name
operator|=
name|QLatin1String
argument_list|(
literal|"EOF_SYMBOL"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"$accept"
argument_list|)
condition|)
name|name
operator|=
name|QLatin1String
argument_list|(
literal|"ACCEPT_SYMBOL"
argument_list|)
expr_stmt|;
else|else
name|name
operator|.
name|prepend
argument_list|(
name|grammar
operator|.
name|token_prefix
argument_list|)
expr_stmt|;
name|out
operator|<<
literal|"    "
operator|<<
name|name
operator|<<
literal|" = "
operator|<<
name|value
operator|<<
literal|","
operator|<<
name|endl
expr_stmt|;
block|}
name|out
operator|<<
name|endl
operator|<<
literal|"    ACCEPT_STATE = "
operator|<<
name|accept_state
operator|<<
literal|","
operator|<<
name|endl
operator|<<
literal|"    RULE_COUNT = "
operator|<<
name|grammar
operator|.
name|rules
operator|.
name|size
argument_list|()
operator|<<
literal|","
operator|<<
name|endl
operator|<<
literal|"    STATE_COUNT = "
operator|<<
name|state_count
operator|<<
literal|","
operator|<<
name|endl
operator|<<
literal|"    TERMINAL_COUNT = "
operator|<<
name|terminal_count
operator|<<
literal|","
operator|<<
name|endl
operator|<<
literal|"    NON_TERMINAL_COUNT = "
operator|<<
name|non_terminal_count
operator|<<
literal|","
operator|<<
name|endl
operator|<<
name|endl
operator|<<
literal|"    GOTO_INDEX_OFFSET = "
operator|<<
name|compressed_action
operator|.
name|index
operator|.
name|size
argument_list|()
operator|<<
literal|","
operator|<<
name|endl
operator|<<
literal|"    GOTO_INFO_OFFSET = "
operator|<<
name|compressed_action
operator|.
name|info
operator|.
name|size
argument_list|()
operator|<<
literal|","
operator|<<
name|endl
operator|<<
literal|"    GOTO_CHECK_OFFSET = "
operator|<<
name|compressed_action
operator|.
name|check
operator|.
name|size
argument_list|()
operator|<<
name|endl
operator|<<
literal|"  };"
operator|<<
name|endl
operator|<<
name|endl
operator|<<
literal|"  static const char  *const    spell [];"
operator|<<
name|endl
operator|<<
literal|"  static const short             lhs [];"
operator|<<
name|endl
operator|<<
literal|"  static const short             rhs [];"
operator|<<
name|endl
expr_stmt|;
if|if
condition|(
name|debug_info
condition|)
block|{
name|QString
name|prot
init|=
name|debugInfoProt
argument_list|()
decl_stmt|;
name|out
operator|<<
name|endl
operator|<<
literal|"#ifndef "
operator|<<
name|prot
operator|<<
name|endl
operator|<<
literal|"  static const int     rule_index [];"
operator|<<
name|endl
operator|<<
literal|"  static const int      rule_info [];"
operator|<<
name|endl
operator|<<
literal|"#endif // "
operator|<<
name|prot
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
block|}
name|out
operator|<<
literal|"  static const short    goto_default [];"
operator|<<
name|endl
operator|<<
literal|"  static const short  action_default [];"
operator|<<
name|endl
operator|<<
literal|"  static const short    action_index [];"
operator|<<
name|endl
operator|<<
literal|"  static const short     action_info [];"
operator|<<
name|endl
operator|<<
literal|"  static const short    action_check [];"
operator|<<
name|endl
operator|<<
name|endl
operator|<<
literal|"  static inline int nt_action (int state, int nt)"
operator|<<
name|endl
operator|<<
literal|"  {"
operator|<<
name|endl
operator|<<
literal|"    const int yyn = action_index [GOTO_INDEX_OFFSET + state] + nt;"
operator|<<
name|endl
operator|<<
literal|"    if (yyn< 0 || action_check [GOTO_CHECK_OFFSET + yyn] != nt)"
operator|<<
name|endl
operator|<<
literal|"      return goto_default [nt];"
operator|<<
name|endl
operator|<<
name|endl
operator|<<
literal|"    return action_info [GOTO_INFO_OFFSET + yyn];"
operator|<<
name|endl
operator|<<
literal|"  }"
operator|<<
name|endl
operator|<<
name|endl
operator|<<
literal|"  static inline int t_action (int state, int token)"
operator|<<
name|endl
operator|<<
literal|"  {"
operator|<<
name|endl
operator|<<
literal|"    const int yyn = action_index [state] + token;"
operator|<<
name|endl
operator|<<
name|endl
operator|<<
literal|"    if (yyn< 0 || action_check [yyn] != token)"
operator|<<
name|endl
operator|<<
literal|"      return - action_default [state];"
operator|<<
name|endl
operator|<<
name|endl
operator|<<
literal|"    return action_info [yyn];"
operator|<<
name|endl
operator|<<
literal|"  }"
operator|<<
name|endl
operator|<<
literal|"};"
operator|<<
name|endl
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
block|}
end_function
begin_function
DECL|function|generateImpl
name|void
name|CppGenerator
operator|::
name|generateImpl
parameter_list|(
name|QTextStream
modifier|&
name|out
parameter_list|)
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|out
operator|<<
literal|"const char *const "
operator|<<
name|grammar
operator|.
name|table_name
operator|<<
literal|"::spell [] = {"
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
name|QMap
argument_list|<
name|Name
argument_list|,
name|int
argument_list|>
name|name_ids
decl_stmt|;
name|bool
name|first_nt
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Name
name|t
init|=
name|grammar
operator|.
name|names
operator|.
name|begin
argument_list|()
init|;
name|t
operator|!=
name|grammar
operator|.
name|names
operator|.
name|end
argument_list|()
condition|;
operator|++
name|t
operator|,
operator|++
name|idx
control|)
block|{
name|bool
name|terminal
init|=
name|grammar
operator|.
name|isTerminal
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|debug_info
operator|||
name|terminal
operator|)
condition|)
break|break;
name|name_ids
operator|.
name|insert
argument_list|(
name|t
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|idx
operator|%
literal|10
operator|)
condition|)
name|out
operator|<<
name|endl
operator|<<
literal|"  "
expr_stmt|;
if|if
condition|(
name|terminal
condition|)
block|{
name|QString
name|spell
init|=
name|grammar
operator|.
name|spells
operator|.
name|value
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|spell
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
operator|<<
literal|"0"
expr_stmt|;
else|else
name|out
operator|<<
literal|"\""
operator|<<
name|spell
operator|<<
literal|"\""
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|first_nt
condition|)
block|{
name|first_nt
operator|=
literal|false
expr_stmt|;
name|QString
name|prot
init|=
name|debugInfoProt
argument_list|()
decl_stmt|;
name|out
operator|<<
name|endl
operator|<<
literal|"#ifndef "
operator|<<
name|prot
operator|<<
name|endl
expr_stmt|;
block|}
name|out
operator|<<
literal|"\""
operator|<<
operator|*
name|t
operator|<<
literal|"\""
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug_info
condition|)
name|out
operator|<<
name|endl
operator|<<
literal|"#endif // "
operator|<<
name|debugInfoProt
argument_list|()
operator|<<
name|endl
expr_stmt|;
name|out
operator|<<
literal|"};"
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
name|out
operator|<<
literal|"const short "
operator|<<
name|grammar
operator|.
name|table_name
operator|<<
literal|"::lhs [] = {"
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|RulePointer
name|rule
init|=
name|grammar
operator|.
name|rules
operator|.
name|begin
argument_list|()
init|;
name|rule
operator|!=
name|grammar
operator|.
name|rules
operator|.
name|end
argument_list|()
condition|;
operator|++
name|rule
operator|,
operator|++
name|idx
control|)
block|{
if|if
condition|(
name|idx
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|idx
operator|%
literal|10
operator|)
condition|)
name|out
operator|<<
name|endl
operator|<<
literal|"  "
expr_stmt|;
name|out
operator|<<
name|aut
operator|.
name|id
argument_list|(
name|rule
operator|->
name|lhs
argument_list|)
expr_stmt|;
block|}
name|out
operator|<<
literal|"};"
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
name|out
operator|<<
literal|"const short "
operator|<<
name|grammar
operator|.
name|table_name
operator|<<
literal|"::rhs [] = {"
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|RulePointer
name|rule
init|=
name|grammar
operator|.
name|rules
operator|.
name|begin
argument_list|()
init|;
name|rule
operator|!=
name|grammar
operator|.
name|rules
operator|.
name|end
argument_list|()
condition|;
operator|++
name|rule
operator|,
operator|++
name|idx
control|)
block|{
if|if
condition|(
name|idx
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|idx
operator|%
literal|10
operator|)
condition|)
name|out
operator|<<
name|endl
operator|<<
literal|"  "
expr_stmt|;
name|out
operator|<<
name|rule
operator|->
name|rhs
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|out
operator|<<
literal|"};"
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
if|if
condition|(
name|debug_info
condition|)
block|{
name|QString
name|prot
init|=
name|debugInfoProt
argument_list|()
decl_stmt|;
name|out
operator|<<
name|endl
operator|<<
literal|"#ifndef "
operator|<<
name|prot
operator|<<
name|endl
expr_stmt|;
name|out
operator|<<
literal|"const int "
operator|<<
name|grammar
operator|.
name|table_name
operator|<<
literal|"::rule_info [] = {"
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|RulePointer
name|rule
init|=
name|grammar
operator|.
name|rules
operator|.
name|begin
argument_list|()
init|;
name|rule
operator|!=
name|grammar
operator|.
name|rules
operator|.
name|end
argument_list|()
condition|;
operator|++
name|rule
operator|,
operator|++
name|idx
control|)
block|{
name|out
operator|<<
name|endl
operator|<<
literal|"  "
expr_stmt|;
if|if
condition|(
name|idx
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
else|else
name|out
operator|<<
literal|"  "
expr_stmt|;
name|out
operator|<<
name|name_ids
operator|.
name|value
argument_list|(
name|rule
operator|->
name|lhs
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|Name
name|n
decl|,
name|rule
operator|->
name|rhs
control|)
name|out
operator|<<
literal|", "
operator|<<
name|name_ids
operator|.
name|value
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|out
operator|<<
literal|"};"
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
name|out
operator|<<
literal|"const int "
operator|<<
name|grammar
operator|.
name|table_name
operator|<<
literal|"::rule_index [] = {"
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RulePointer
name|rule
init|=
name|grammar
operator|.
name|rules
operator|.
name|begin
argument_list|()
init|;
name|rule
operator|!=
name|grammar
operator|.
name|rules
operator|.
name|end
argument_list|()
condition|;
operator|++
name|rule
operator|,
operator|++
name|idx
control|)
block|{
if|if
condition|(
name|idx
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|idx
operator|%
literal|10
operator|)
condition|)
name|out
operator|<<
name|endl
operator|<<
literal|"  "
expr_stmt|;
name|out
operator|<<
name|offset
expr_stmt|;
name|offset
operator|+=
name|rule
operator|->
name|rhs
operator|.
name|size
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
name|out
operator|<<
literal|"};"
operator|<<
name|endl
operator|<<
literal|"#endif // "
operator|<<
name|prot
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
block|}
name|out
operator|<<
literal|"const short "
operator|<<
name|grammar
operator|.
name|table_name
operator|<<
literal|"::action_default [] = {"
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|StatePointer
name|state
init|=
name|aut
operator|.
name|states
operator|.
name|begin
argument_list|()
init|;
name|state
operator|!=
name|aut
operator|.
name|states
operator|.
name|end
argument_list|()
condition|;
operator|++
name|state
operator|,
operator|++
name|idx
control|)
block|{
if|if
condition|(
name|state
operator|!=
name|aut
operator|.
name|states
operator|.
name|begin
argument_list|()
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|idx
operator|%
literal|10
operator|)
condition|)
name|out
operator|<<
name|endl
operator|<<
literal|"  "
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|defaultReduce
operator|!=
name|grammar
operator|.
name|rules
operator|.
name|end
argument_list|()
condition|)
name|out
operator|<<
name|aut
operator|.
name|id
argument_list|(
name|state
operator|->
name|defaultReduce
argument_list|)
expr_stmt|;
else|else
name|out
operator|<<
literal|"0"
expr_stmt|;
block|}
name|out
operator|<<
literal|"};"
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
name|out
operator|<<
literal|"const short "
operator|<<
name|grammar
operator|.
name|table_name
operator|<<
literal|"::goto_default [] = {"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|defgoto
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|10
operator|)
condition|)
name|out
operator|<<
name|endl
operator|<<
literal|"  "
expr_stmt|;
name|out
operator|<<
name|defgoto
index|[
name|i
index|]
expr_stmt|;
block|}
name|out
operator|<<
literal|"};"
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
name|out
operator|<<
literal|"const short "
operator|<<
name|grammar
operator|.
name|table_name
operator|<<
literal|"::action_index [] = {"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|compressed_action
operator|.
name|index
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|10
operator|)
condition|)
name|out
operator|<<
name|endl
operator|<<
literal|"  "
expr_stmt|;
name|out
operator|<<
name|compressed_action
operator|.
name|index
index|[
name|i
index|]
operator|<<
literal|", "
expr_stmt|;
block|}
name|out
operator|<<
name|endl
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|compressed_goto
operator|.
name|index
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|10
operator|)
condition|)
name|out
operator|<<
name|endl
operator|<<
literal|"  "
expr_stmt|;
name|out
operator|<<
name|compressed_goto
operator|.
name|index
index|[
name|i
index|]
expr_stmt|;
block|}
name|out
operator|<<
literal|"};"
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
name|out
operator|<<
literal|"const short "
operator|<<
name|grammar
operator|.
name|table_name
operator|<<
literal|"::action_info [] = {"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|compressed_action
operator|.
name|info
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|10
operator|)
condition|)
name|out
operator|<<
name|endl
operator|<<
literal|"  "
expr_stmt|;
name|out
operator|<<
name|compressed_action
operator|.
name|info
index|[
name|i
index|]
operator|<<
literal|", "
expr_stmt|;
block|}
name|out
operator|<<
name|endl
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|compressed_goto
operator|.
name|info
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|10
operator|)
condition|)
name|out
operator|<<
name|endl
operator|<<
literal|"  "
expr_stmt|;
name|out
operator|<<
name|compressed_goto
operator|.
name|info
index|[
name|i
index|]
expr_stmt|;
block|}
name|out
operator|<<
literal|"};"
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
name|out
operator|<<
literal|"const short "
operator|<<
name|grammar
operator|.
name|table_name
operator|<<
literal|"::action_check [] = {"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|compressed_action
operator|.
name|check
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|10
operator|)
condition|)
name|out
operator|<<
name|endl
operator|<<
literal|"  "
expr_stmt|;
name|out
operator|<<
name|compressed_action
operator|.
name|check
index|[
name|i
index|]
operator|<<
literal|", "
expr_stmt|;
block|}
name|out
operator|<<
name|endl
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|compressed_goto
operator|.
name|check
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
name|out
operator|<<
literal|", "
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|10
operator|)
condition|)
name|out
operator|<<
name|endl
operator|<<
literal|"  "
expr_stmt|;
name|out
operator|<<
name|compressed_goto
operator|.
name|check
index|[
name|i
index|]
expr_stmt|;
block|}
name|out
operator|<<
literal|"};"
operator|<<
name|endl
operator|<<
name|endl
expr_stmt|;
block|}
end_function
end_unit
