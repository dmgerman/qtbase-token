begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the utils of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qlist.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qbytearray.h>
end_include
begin_include
include|#
directive|include
file|<qstring.h>
end_include
begin_include
include|#
directive|include
file|<qchar.h>
end_include
begin_include
include|#
directive|include
file|<qvector.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_if
if|#
directive|if
literal|0
end_if
begin_include
include|#
directive|include
file|<private/qunicodetables_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|DATA_VERSION_S
define|#
directive|define
name|DATA_VERSION_S
value|"6.2"
end_define
begin_define
DECL|macro|DATA_VERSION_STR
define|#
directive|define
name|DATA_VERSION_STR
value|"QChar::Unicode_6_2"
end_define
begin_decl_stmt
DECL|variable|age_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QChar
operator|::
name|UnicodeVersion
argument_list|>
name|age_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initAgeMap
specifier|static
name|void
name|initAgeMap
parameter_list|()
block|{
struct|struct
name|AgeMap
block|{
specifier|const
name|QChar
operator|::
name|UnicodeVersion
name|version
decl_stmt|;
specifier|const
name|char
modifier|*
name|age
decl_stmt|;
block|}
name|ageMap
index|[]
init|=
block|{
block|{
name|QChar
operator|::
name|Unicode_1_1
block|,
literal|"1.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_2_0
block|,
literal|"2.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_2_1_2
block|,
literal|"2.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_3_0
block|,
literal|"3.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_3_1
block|,
literal|"3.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_3_2
block|,
literal|"3.2"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_4_0
block|,
literal|"4.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_4_1
block|,
literal|"4.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_5_0
block|,
literal|"5.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_5_1
block|,
literal|"5.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_5_2
block|,
literal|"5.2"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_6_0
block|,
literal|"6.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_6_1
block|,
literal|"6.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_6_2
block|,
literal|"6.2"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|AgeMap
modifier|*
name|d
init|=
name|ageMap
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|age
condition|)
block|{
name|age_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|age
argument_list|,
name|d
operator|->
name|version
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|categoryMap
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QChar
operator|::
name|Category
argument_list|>
name|categoryMap
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initCategoryMap
specifier|static
name|void
name|initCategoryMap
parameter_list|()
block|{
struct|struct
name|Cat
block|{
name|QChar
operator|::
name|Category
name|cat
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|categories
index|[]
init|=
block|{
block|{
name|QChar
operator|::
name|Mark_NonSpacing
block|,
literal|"Mn"
block|}
block|,
block|{
name|QChar
operator|::
name|Mark_SpacingCombining
block|,
literal|"Mc"
block|}
block|,
block|{
name|QChar
operator|::
name|Mark_Enclosing
block|,
literal|"Me"
block|}
block|,
block|{
name|QChar
operator|::
name|Number_DecimalDigit
block|,
literal|"Nd"
block|}
block|,
block|{
name|QChar
operator|::
name|Number_Letter
block|,
literal|"Nl"
block|}
block|,
block|{
name|QChar
operator|::
name|Number_Other
block|,
literal|"No"
block|}
block|,
block|{
name|QChar
operator|::
name|Separator_Space
block|,
literal|"Zs"
block|}
block|,
block|{
name|QChar
operator|::
name|Separator_Line
block|,
literal|"Zl"
block|}
block|,
block|{
name|QChar
operator|::
name|Separator_Paragraph
block|,
literal|"Zp"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_Control
block|,
literal|"Cc"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_Format
block|,
literal|"Cf"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_Surrogate
block|,
literal|"Cs"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_PrivateUse
block|,
literal|"Co"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_NotAssigned
block|,
literal|"Cn"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Uppercase
block|,
literal|"Lu"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Lowercase
block|,
literal|"Ll"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Titlecase
block|,
literal|"Lt"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Modifier
block|,
literal|"Lm"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Other
block|,
literal|"Lo"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Connector
block|,
literal|"Pc"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Dash
block|,
literal|"Pd"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Open
block|,
literal|"Ps"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Close
block|,
literal|"Pe"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_InitialQuote
block|,
literal|"Pi"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_FinalQuote
block|,
literal|"Pf"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Other
block|,
literal|"Po"
block|}
block|,
block|{
name|QChar
operator|::
name|Symbol_Math
block|,
literal|"Sm"
block|}
block|,
block|{
name|QChar
operator|::
name|Symbol_Currency
block|,
literal|"Sc"
block|}
block|,
block|{
name|QChar
operator|::
name|Symbol_Modifier
block|,
literal|"Sk"
block|}
block|,
block|{
name|QChar
operator|::
name|Symbol_Other
block|,
literal|"So"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_NotAssigned
block|,
literal|0
block|}
block|}
struct|;
name|Cat
modifier|*
name|c
init|=
name|categories
decl_stmt|;
while|while
condition|(
name|c
operator|->
name|name
condition|)
block|{
name|categoryMap
operator|.
name|insert
argument_list|(
name|c
operator|->
name|name
argument_list|,
name|c
operator|->
name|cat
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|decompositionMap
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QChar
operator|::
name|Decomposition
argument_list|>
name|decompositionMap
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initDecompositionMap
specifier|static
name|void
name|initDecompositionMap
parameter_list|()
block|{
struct|struct
name|Dec
block|{
name|QChar
operator|::
name|Decomposition
name|dec
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|decompositions
index|[]
init|=
block|{
block|{
name|QChar
operator|::
name|Canonical
block|,
literal|"<canonical>"
block|}
block|,
block|{
name|QChar
operator|::
name|Font
block|,
literal|"<font>"
block|}
block|,
block|{
name|QChar
operator|::
name|NoBreak
block|,
literal|"<noBreak>"
block|}
block|,
block|{
name|QChar
operator|::
name|Initial
block|,
literal|"<initial>"
block|}
block|,
block|{
name|QChar
operator|::
name|Medial
block|,
literal|"<medial>"
block|}
block|,
block|{
name|QChar
operator|::
name|Final
block|,
literal|"<final>"
block|}
block|,
block|{
name|QChar
operator|::
name|Isolated
block|,
literal|"<isolated>"
block|}
block|,
block|{
name|QChar
operator|::
name|Circle
block|,
literal|"<circle>"
block|}
block|,
block|{
name|QChar
operator|::
name|Super
block|,
literal|"<super>"
block|}
block|,
block|{
name|QChar
operator|::
name|Sub
block|,
literal|"<sub>"
block|}
block|,
block|{
name|QChar
operator|::
name|Vertical
block|,
literal|"<vertical>"
block|}
block|,
block|{
name|QChar
operator|::
name|Wide
block|,
literal|"<wide>"
block|}
block|,
block|{
name|QChar
operator|::
name|Narrow
block|,
literal|"<narrow>"
block|}
block|,
block|{
name|QChar
operator|::
name|Small
block|,
literal|"<small>"
block|}
block|,
block|{
name|QChar
operator|::
name|Square
block|,
literal|"<square>"
block|}
block|,
block|{
name|QChar
operator|::
name|Compat
block|,
literal|"<compat>"
block|}
block|,
block|{
name|QChar
operator|::
name|Fraction
block|,
literal|"<fraction>"
block|}
block|,
block|{
name|QChar
operator|::
name|NoDecomposition
block|,
literal|0
block|}
block|}
struct|;
name|Dec
modifier|*
name|d
init|=
name|decompositions
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|decompositionMap
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|dec
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|directionMap
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QChar
operator|::
name|Direction
argument_list|>
name|directionMap
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initDirectionMap
specifier|static
name|void
name|initDirectionMap
parameter_list|()
block|{
struct|struct
name|Dir
block|{
name|QChar
operator|::
name|Direction
name|dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|directions
index|[]
init|=
block|{
block|{
name|QChar
operator|::
name|DirL
block|,
literal|"L"
block|}
block|,
block|{
name|QChar
operator|::
name|DirR
block|,
literal|"R"
block|}
block|,
block|{
name|QChar
operator|::
name|DirEN
block|,
literal|"EN"
block|}
block|,
block|{
name|QChar
operator|::
name|DirES
block|,
literal|"ES"
block|}
block|,
block|{
name|QChar
operator|::
name|DirET
block|,
literal|"ET"
block|}
block|,
block|{
name|QChar
operator|::
name|DirAN
block|,
literal|"AN"
block|}
block|,
block|{
name|QChar
operator|::
name|DirCS
block|,
literal|"CS"
block|}
block|,
block|{
name|QChar
operator|::
name|DirB
block|,
literal|"B"
block|}
block|,
block|{
name|QChar
operator|::
name|DirS
block|,
literal|"S"
block|}
block|,
block|{
name|QChar
operator|::
name|DirWS
block|,
literal|"WS"
block|}
block|,
block|{
name|QChar
operator|::
name|DirON
block|,
literal|"ON"
block|}
block|,
block|{
name|QChar
operator|::
name|DirLRE
block|,
literal|"LRE"
block|}
block|,
block|{
name|QChar
operator|::
name|DirLRO
block|,
literal|"LRO"
block|}
block|,
block|{
name|QChar
operator|::
name|DirAL
block|,
literal|"AL"
block|}
block|,
block|{
name|QChar
operator|::
name|DirRLE
block|,
literal|"RLE"
block|}
block|,
block|{
name|QChar
operator|::
name|DirRLO
block|,
literal|"RLO"
block|}
block|,
block|{
name|QChar
operator|::
name|DirPDF
block|,
literal|"PDF"
block|}
block|,
block|{
name|QChar
operator|::
name|DirNSM
block|,
literal|"NSM"
block|}
block|,
block|{
name|QChar
operator|::
name|DirBN
block|,
literal|"BN"
block|}
block|,
block|{
name|QChar
operator|::
name|DirL
block|,
literal|0
block|}
block|}
struct|;
name|Dir
modifier|*
name|d
init|=
name|directions
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|directionMap
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|dir
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_enum
DECL|enum|Joining
enum|enum
name|Joining
block|{
DECL|enumerator|Joining_None
name|Joining_None
block|,
DECL|enumerator|Joining_Left
name|Joining_Left
block|,
DECL|enumerator|Joining_Causing
name|Joining_Causing
block|,
DECL|enumerator|Joining_Dual
name|Joining_Dual
block|,
DECL|enumerator|Joining_Right
name|Joining_Right
block|,
DECL|enumerator|Joining_Transparent
name|Joining_Transparent
block|,
DECL|enumerator|Joining_Unassigned
name|Joining_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|joining_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|Joining
argument_list|>
name|joining_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initJoiningMap
specifier|static
name|void
name|initJoiningMap
parameter_list|()
block|{
struct|struct
name|JoiningList
block|{
name|Joining
name|joining
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|joinings
index|[]
init|=
block|{
block|{
name|Joining_None
block|,
literal|"U"
block|}
block|,
block|{
name|Joining_Left
block|,
literal|"L"
block|}
block|,
block|{
name|Joining_Causing
block|,
literal|"C"
block|}
block|,
block|{
name|Joining_Dual
block|,
literal|"D"
block|}
block|,
block|{
name|Joining_Right
block|,
literal|"R"
block|}
block|,
block|{
name|Joining_Transparent
block|,
literal|"T"
block|}
block|,
block|{
name|Joining_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|JoiningList
modifier|*
name|d
init|=
name|joinings
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|joining_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|joining
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|grapheme_break_class_string
specifier|static
specifier|const
name|char
modifier|*
name|grapheme_break_class_string
init|=
literal|"enum GraphemeBreakClass {\n"
literal|"    GraphemeBreak_Other,\n"
literal|"    GraphemeBreak_CR,\n"
literal|"    GraphemeBreak_LF,\n"
literal|"    GraphemeBreak_Control,\n"
literal|"    GraphemeBreak_Extend,\n"
literal|"    GraphemeBreak_RegionalIndicator,\n"
literal|"    GraphemeBreak_Prepend,\n"
literal|"    GraphemeBreak_SpacingMark,\n"
literal|"    GraphemeBreak_L,\n"
literal|"    GraphemeBreak_V,\n"
literal|"    GraphemeBreak_T,\n"
literal|"    GraphemeBreak_LV,\n"
literal|"    GraphemeBreak_LVT\n"
literal|"};\n\n"
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|GraphemeBreakClass
enum|enum
name|GraphemeBreakClass
block|{
DECL|enumerator|GraphemeBreak_Other
name|GraphemeBreak_Other
block|,
DECL|enumerator|GraphemeBreak_CR
name|GraphemeBreak_CR
block|,
DECL|enumerator|GraphemeBreak_LF
name|GraphemeBreak_LF
block|,
DECL|enumerator|GraphemeBreak_Control
name|GraphemeBreak_Control
block|,
DECL|enumerator|GraphemeBreak_Extend
name|GraphemeBreak_Extend
block|,
DECL|enumerator|GraphemeBreak_RegionalIndicator
name|GraphemeBreak_RegionalIndicator
block|,
DECL|enumerator|GraphemeBreak_Prepend
name|GraphemeBreak_Prepend
block|,
DECL|enumerator|GraphemeBreak_SpacingMark
name|GraphemeBreak_SpacingMark
block|,
DECL|enumerator|GraphemeBreak_L
name|GraphemeBreak_L
block|,
DECL|enumerator|GraphemeBreak_V
name|GraphemeBreak_V
block|,
DECL|enumerator|GraphemeBreak_T
name|GraphemeBreak_T
block|,
DECL|enumerator|GraphemeBreak_LV
name|GraphemeBreak_LV
block|,
DECL|enumerator|GraphemeBreak_LVT
name|GraphemeBreak_LVT
block|,
DECL|enumerator|GraphemeBreak_Unassigned
name|GraphemeBreak_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|grapheme_break_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|GraphemeBreakClass
argument_list|>
name|grapheme_break_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initGraphemeBreak
specifier|static
name|void
name|initGraphemeBreak
parameter_list|()
block|{
struct|struct
name|GraphemeBreakList
block|{
name|GraphemeBreakClass
name|brk
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|breaks
index|[]
init|=
block|{
block|{
name|GraphemeBreak_Other
block|,
literal|"Other"
block|}
block|,
block|{
name|GraphemeBreak_CR
block|,
literal|"CR"
block|}
block|,
block|{
name|GraphemeBreak_LF
block|,
literal|"LF"
block|}
block|,
block|{
name|GraphemeBreak_Control
block|,
literal|"Control"
block|}
block|,
block|{
name|GraphemeBreak_Extend
block|,
literal|"Extend"
block|}
block|,
block|{
name|GraphemeBreak_RegionalIndicator
block|,
literal|"Regional_Indicator"
block|}
block|,
block|{
name|GraphemeBreak_Prepend
block|,
literal|"Prepend"
block|}
block|,
block|{
name|GraphemeBreak_SpacingMark
block|,
literal|"SpacingMark"
block|}
block|,
block|{
name|GraphemeBreak_L
block|,
literal|"L"
block|}
block|,
block|{
name|GraphemeBreak_V
block|,
literal|"V"
block|}
block|,
block|{
name|GraphemeBreak_T
block|,
literal|"T"
block|}
block|,
block|{
name|GraphemeBreak_LV
block|,
literal|"LV"
block|}
block|,
block|{
name|GraphemeBreak_LVT
block|,
literal|"LVT"
block|}
block|,
block|{
name|GraphemeBreak_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|GraphemeBreakList
modifier|*
name|d
init|=
name|breaks
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|grapheme_break_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|brk
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|word_break_class_string
specifier|static
specifier|const
name|char
modifier|*
name|word_break_class_string
init|=
literal|"enum WordBreakClass {\n"
literal|"    WordBreak_Other,\n"
literal|"    WordBreak_CR,\n"
literal|"    WordBreak_LF,\n"
literal|"    WordBreak_Newline,\n"
literal|"    WordBreak_Extend,\n"
literal|"    WordBreak_RegionalIndicator,\n"
literal|"    WordBreak_Katakana,\n"
literal|"    WordBreak_ALetter,\n"
literal|"    WordBreak_MidNumLet,\n"
literal|"    WordBreak_MidLetter,\n"
literal|"    WordBreak_MidNum,\n"
literal|"    WordBreak_Numeric,\n"
literal|"    WordBreak_ExtendNumLet\n"
literal|"};\n\n"
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|WordBreakClass
enum|enum
name|WordBreakClass
block|{
DECL|enumerator|WordBreak_Other
name|WordBreak_Other
block|,
DECL|enumerator|WordBreak_CR
name|WordBreak_CR
block|,
DECL|enumerator|WordBreak_LF
name|WordBreak_LF
block|,
DECL|enumerator|WordBreak_Newline
name|WordBreak_Newline
block|,
DECL|enumerator|WordBreak_Extend
name|WordBreak_Extend
block|,
DECL|enumerator|WordBreak_RegionalIndicator
name|WordBreak_RegionalIndicator
block|,
DECL|enumerator|WordBreak_Katakana
name|WordBreak_Katakana
block|,
DECL|enumerator|WordBreak_ALetter
name|WordBreak_ALetter
block|,
DECL|enumerator|WordBreak_MidNumLet
name|WordBreak_MidNumLet
block|,
DECL|enumerator|WordBreak_MidLetter
name|WordBreak_MidLetter
block|,
DECL|enumerator|WordBreak_MidNum
name|WordBreak_MidNum
block|,
DECL|enumerator|WordBreak_Numeric
name|WordBreak_Numeric
block|,
DECL|enumerator|WordBreak_ExtendNumLet
name|WordBreak_ExtendNumLet
block|,
DECL|enumerator|WordBreak_Unassigned
name|WordBreak_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|word_break_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|WordBreakClass
argument_list|>
name|word_break_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initWordBreak
specifier|static
name|void
name|initWordBreak
parameter_list|()
block|{
struct|struct
name|WordBreakList
block|{
name|WordBreakClass
name|brk
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|breaks
index|[]
init|=
block|{
block|{
name|WordBreak_Other
block|,
literal|"Other"
block|}
block|,
block|{
name|WordBreak_CR
block|,
literal|"CR"
block|}
block|,
block|{
name|WordBreak_LF
block|,
literal|"LF"
block|}
block|,
block|{
name|WordBreak_Newline
block|,
literal|"Newline"
block|}
block|,
block|{
name|WordBreak_Extend
block|,
literal|"Extend"
block|}
block|,
block|{
name|WordBreak_Extend
block|,
literal|"Format"
block|}
block|,
block|{
name|WordBreak_RegionalIndicator
block|,
literal|"Regional_Indicator"
block|}
block|,
block|{
name|WordBreak_Katakana
block|,
literal|"Katakana"
block|}
block|,
block|{
name|WordBreak_ALetter
block|,
literal|"ALetter"
block|}
block|,
block|{
name|WordBreak_MidNumLet
block|,
literal|"MidNumLet"
block|}
block|,
block|{
name|WordBreak_MidLetter
block|,
literal|"MidLetter"
block|}
block|,
block|{
name|WordBreak_MidNum
block|,
literal|"MidNum"
block|}
block|,
block|{
name|WordBreak_Numeric
block|,
literal|"Numeric"
block|}
block|,
block|{
name|WordBreak_ExtendNumLet
block|,
literal|"ExtendNumLet"
block|}
block|,
block|{
name|WordBreak_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|WordBreakList
modifier|*
name|d
init|=
name|breaks
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|word_break_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|brk
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|sentence_break_class_string
specifier|static
specifier|const
name|char
modifier|*
name|sentence_break_class_string
init|=
literal|"enum SentenceBreakClass {\n"
literal|"    SentenceBreak_Other,\n"
literal|"    SentenceBreak_CR,\n"
literal|"    SentenceBreak_LF,\n"
literal|"    SentenceBreak_Sep,\n"
literal|"    SentenceBreak_Extend,\n"
literal|"    SentenceBreak_Sp,\n"
literal|"    SentenceBreak_Lower,\n"
literal|"    SentenceBreak_Upper,\n"
literal|"    SentenceBreak_OLetter,\n"
literal|"    SentenceBreak_Numeric,\n"
literal|"    SentenceBreak_ATerm,\n"
literal|"    SentenceBreak_SContinue,\n"
literal|"    SentenceBreak_STerm,\n"
literal|"    SentenceBreak_Close\n"
literal|"};\n\n"
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|SentenceBreakClass
enum|enum
name|SentenceBreakClass
block|{
DECL|enumerator|SentenceBreak_Other
name|SentenceBreak_Other
block|,
DECL|enumerator|SentenceBreak_CR
name|SentenceBreak_CR
block|,
DECL|enumerator|SentenceBreak_LF
name|SentenceBreak_LF
block|,
DECL|enumerator|SentenceBreak_Sep
name|SentenceBreak_Sep
block|,
DECL|enumerator|SentenceBreak_Extend
name|SentenceBreak_Extend
block|,
DECL|enumerator|SentenceBreak_Sp
name|SentenceBreak_Sp
block|,
DECL|enumerator|SentenceBreak_Lower
name|SentenceBreak_Lower
block|,
DECL|enumerator|SentenceBreak_Upper
name|SentenceBreak_Upper
block|,
DECL|enumerator|SentenceBreak_OLetter
name|SentenceBreak_OLetter
block|,
DECL|enumerator|SentenceBreak_Numeric
name|SentenceBreak_Numeric
block|,
DECL|enumerator|SentenceBreak_ATerm
name|SentenceBreak_ATerm
block|,
DECL|enumerator|SentenceBreak_SContinue
name|SentenceBreak_SContinue
block|,
DECL|enumerator|SentenceBreak_STerm
name|SentenceBreak_STerm
block|,
DECL|enumerator|SentenceBreak_Close
name|SentenceBreak_Close
block|,
DECL|enumerator|SentenceBreak_Unassigned
name|SentenceBreak_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|sentence_break_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|SentenceBreakClass
argument_list|>
name|sentence_break_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initSentenceBreak
specifier|static
name|void
name|initSentenceBreak
parameter_list|()
block|{
struct|struct
name|SentenceBreakList
block|{
name|SentenceBreakClass
name|brk
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|breaks
index|[]
init|=
block|{
block|{
name|SentenceBreak_Other
block|,
literal|"Other"
block|}
block|,
block|{
name|SentenceBreak_CR
block|,
literal|"CR"
block|}
block|,
block|{
name|SentenceBreak_LF
block|,
literal|"LF"
block|}
block|,
block|{
name|SentenceBreak_Sep
block|,
literal|"Sep"
block|}
block|,
block|{
name|SentenceBreak_Extend
block|,
literal|"Extend"
block|}
block|,
block|{
name|SentenceBreak_Extend
block|,
literal|"Format"
block|}
block|,
block|{
name|SentenceBreak_Sp
block|,
literal|"Sp"
block|}
block|,
block|{
name|SentenceBreak_Lower
block|,
literal|"Lower"
block|}
block|,
block|{
name|SentenceBreak_Upper
block|,
literal|"Upper"
block|}
block|,
block|{
name|SentenceBreak_OLetter
block|,
literal|"OLetter"
block|}
block|,
block|{
name|SentenceBreak_Numeric
block|,
literal|"Numeric"
block|}
block|,
block|{
name|SentenceBreak_ATerm
block|,
literal|"ATerm"
block|}
block|,
block|{
name|SentenceBreak_SContinue
block|,
literal|"SContinue"
block|}
block|,
block|{
name|SentenceBreak_STerm
block|,
literal|"STerm"
block|}
block|,
block|{
name|SentenceBreak_Close
block|,
literal|"Close"
block|}
block|,
block|{
name|SentenceBreak_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|SentenceBreakList
modifier|*
name|d
init|=
name|breaks
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|sentence_break_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|brk
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|line_break_class_string
specifier|static
specifier|const
name|char
modifier|*
name|line_break_class_string
init|=
literal|"// see http://www.unicode.org/reports/tr14/tr14-30.html\n"
literal|"// we don't use the XX and AI classes and map them to AL instead.\n"
literal|"enum LineBreakClass {\n"
literal|"    LineBreak_OP, LineBreak_CL, LineBreak_CP, LineBreak_QU, LineBreak_GL,\n"
literal|"    LineBreak_NS, LineBreak_EX, LineBreak_SY, LineBreak_IS, LineBreak_PR,\n"
literal|"    LineBreak_PO, LineBreak_NU, LineBreak_AL, LineBreak_HL, LineBreak_ID,\n"
literal|"    LineBreak_IN, LineBreak_HY, LineBreak_BA, LineBreak_BB, LineBreak_B2,\n"
literal|"    LineBreak_ZW, LineBreak_CM, LineBreak_WJ, LineBreak_H2, LineBreak_H3,\n"
literal|"    LineBreak_JL, LineBreak_JV, LineBreak_JT, LineBreak_RI, LineBreak_CB,\n"
literal|"    LineBreak_SA, LineBreak_SG, LineBreak_SP, LineBreak_CR, LineBreak_LF,\n"
literal|"    LineBreak_BK\n"
literal|"};\n\n"
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|LineBreakClass
enum|enum
name|LineBreakClass
block|{
DECL|enumerator|LineBreak_OP
DECL|enumerator|LineBreak_CL
DECL|enumerator|LineBreak_CP
DECL|enumerator|LineBreak_QU
DECL|enumerator|LineBreak_GL
name|LineBreak_OP
block|,
name|LineBreak_CL
block|,
name|LineBreak_CP
block|,
name|LineBreak_QU
block|,
name|LineBreak_GL
block|,
DECL|enumerator|LineBreak_NS
DECL|enumerator|LineBreak_EX
DECL|enumerator|LineBreak_SY
DECL|enumerator|LineBreak_IS
DECL|enumerator|LineBreak_PR
name|LineBreak_NS
block|,
name|LineBreak_EX
block|,
name|LineBreak_SY
block|,
name|LineBreak_IS
block|,
name|LineBreak_PR
block|,
DECL|enumerator|LineBreak_PO
DECL|enumerator|LineBreak_NU
DECL|enumerator|LineBreak_AL
DECL|enumerator|LineBreak_HL
DECL|enumerator|LineBreak_ID
name|LineBreak_PO
block|,
name|LineBreak_NU
block|,
name|LineBreak_AL
block|,
name|LineBreak_HL
block|,
name|LineBreak_ID
block|,
DECL|enumerator|LineBreak_IN
DECL|enumerator|LineBreak_HY
DECL|enumerator|LineBreak_BA
DECL|enumerator|LineBreak_BB
DECL|enumerator|LineBreak_B2
name|LineBreak_IN
block|,
name|LineBreak_HY
block|,
name|LineBreak_BA
block|,
name|LineBreak_BB
block|,
name|LineBreak_B2
block|,
DECL|enumerator|LineBreak_ZW
DECL|enumerator|LineBreak_CM
DECL|enumerator|LineBreak_WJ
DECL|enumerator|LineBreak_H2
DECL|enumerator|LineBreak_H3
name|LineBreak_ZW
block|,
name|LineBreak_CM
block|,
name|LineBreak_WJ
block|,
name|LineBreak_H2
block|,
name|LineBreak_H3
block|,
DECL|enumerator|LineBreak_JL
DECL|enumerator|LineBreak_JV
DECL|enumerator|LineBreak_JT
DECL|enumerator|LineBreak_RI
DECL|enumerator|LineBreak_CB
name|LineBreak_JL
block|,
name|LineBreak_JV
block|,
name|LineBreak_JT
block|,
name|LineBreak_RI
block|,
name|LineBreak_CB
block|,
DECL|enumerator|LineBreak_SA
DECL|enumerator|LineBreak_SG
DECL|enumerator|LineBreak_SP
DECL|enumerator|LineBreak_CR
DECL|enumerator|LineBreak_LF
name|LineBreak_SA
block|,
name|LineBreak_SG
block|,
name|LineBreak_SP
block|,
name|LineBreak_CR
block|,
name|LineBreak_LF
block|,
DECL|enumerator|LineBreak_BK
name|LineBreak_BK
block|,
DECL|enumerator|LineBreak_Unassigned
name|LineBreak_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|line_break_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|LineBreakClass
argument_list|>
name|line_break_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initLineBreak
specifier|static
name|void
name|initLineBreak
parameter_list|()
block|{
comment|// ### Classes XX and AI are left out and mapped to AL for now.
comment|// ### Class NL is mapped to BK.
comment|// ### Treating characters of class CJ as class NS will give CSS strict line breaking;
comment|//     treating them as class ID will give CSS normal breaking.
struct|struct
name|LineBreakList
block|{
name|LineBreakClass
name|brk
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|breaks
index|[]
init|=
block|{
block|{
name|LineBreak_BK
block|,
literal|"BK"
block|}
block|,
block|{
name|LineBreak_CR
block|,
literal|"CR"
block|}
block|,
block|{
name|LineBreak_LF
block|,
literal|"LF"
block|}
block|,
block|{
name|LineBreak_CM
block|,
literal|"CM"
block|}
block|,
block|{
name|LineBreak_BK
block|,
literal|"NL"
block|}
block|,
block|{
name|LineBreak_SG
block|,
literal|"SG"
block|}
block|,
block|{
name|LineBreak_WJ
block|,
literal|"WJ"
block|}
block|,
block|{
name|LineBreak_ZW
block|,
literal|"ZW"
block|}
block|,
block|{
name|LineBreak_GL
block|,
literal|"GL"
block|}
block|,
block|{
name|LineBreak_SP
block|,
literal|"SP"
block|}
block|,
block|{
name|LineBreak_B2
block|,
literal|"B2"
block|}
block|,
block|{
name|LineBreak_BA
block|,
literal|"BA"
block|}
block|,
block|{
name|LineBreak_BB
block|,
literal|"BB"
block|}
block|,
block|{
name|LineBreak_HY
block|,
literal|"HY"
block|}
block|,
block|{
name|LineBreak_CB
block|,
literal|"CB"
block|}
block|,
block|{
name|LineBreak_NS
block|,
literal|"CJ"
block|}
block|,
block|{
name|LineBreak_CL
block|,
literal|"CL"
block|}
block|,
block|{
name|LineBreak_CP
block|,
literal|"CP"
block|}
block|,
block|{
name|LineBreak_EX
block|,
literal|"EX"
block|}
block|,
block|{
name|LineBreak_IN
block|,
literal|"IN"
block|}
block|,
block|{
name|LineBreak_NS
block|,
literal|"NS"
block|}
block|,
block|{
name|LineBreak_OP
block|,
literal|"OP"
block|}
block|,
block|{
name|LineBreak_QU
block|,
literal|"QU"
block|}
block|,
block|{
name|LineBreak_IS
block|,
literal|"IS"
block|}
block|,
block|{
name|LineBreak_NU
block|,
literal|"NU"
block|}
block|,
block|{
name|LineBreak_PO
block|,
literal|"PO"
block|}
block|,
block|{
name|LineBreak_PR
block|,
literal|"PR"
block|}
block|,
block|{
name|LineBreak_SY
block|,
literal|"SY"
block|}
block|,
block|{
name|LineBreak_AL
block|,
literal|"AI"
block|}
block|,
block|{
name|LineBreak_AL
block|,
literal|"AL"
block|}
block|,
block|{
name|LineBreak_HL
block|,
literal|"HL"
block|}
block|,
block|{
name|LineBreak_H2
block|,
literal|"H2"
block|}
block|,
block|{
name|LineBreak_H3
block|,
literal|"H3"
block|}
block|,
block|{
name|LineBreak_ID
block|,
literal|"ID"
block|}
block|,
block|{
name|LineBreak_JL
block|,
literal|"JL"
block|}
block|,
block|{
name|LineBreak_JV
block|,
literal|"JV"
block|}
block|,
block|{
name|LineBreak_JT
block|,
literal|"JT"
block|}
block|,
block|{
name|LineBreak_RI
block|,
literal|"RI"
block|}
block|,
block|{
name|LineBreak_SA
block|,
literal|"SA"
block|}
block|,
block|{
name|LineBreak_AL
block|,
literal|"XX"
block|}
block|,
block|{
name|LineBreak_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|LineBreakList
modifier|*
name|d
init|=
name|breaks
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|line_break_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|brk
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|scriptMap
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QChar
operator|::
name|Script
argument_list|>
name|scriptMap
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initScriptMap
specifier|static
name|void
name|initScriptMap
parameter_list|()
block|{
struct|struct
name|Scrpt
block|{
name|QChar
operator|::
name|Script
name|script
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|scripts
index|[]
init|=
block|{
comment|// general
block|{
name|QChar
operator|::
name|Script_Unknown
block|,
literal|"Unknown"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Inherited
block|,
literal|"Inherited"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Common
block|,
literal|"Common"
block|}
block|,
comment|// pre-4.0
block|{
name|QChar
operator|::
name|Script_Latin
block|,
literal|"Latin"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Greek
block|,
literal|"Greek"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Cyrillic
block|,
literal|"Cyrillic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Armenian
block|,
literal|"Armenian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Hebrew
block|,
literal|"Hebrew"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Arabic
block|,
literal|"Arabic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Syriac
block|,
literal|"Syriac"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Thaana
block|,
literal|"Thaana"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Devanagari
block|,
literal|"Devanagari"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Bengali
block|,
literal|"Bengali"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Gurmukhi
block|,
literal|"Gurmukhi"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Gujarati
block|,
literal|"Gujarati"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Oriya
block|,
literal|"Oriya"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Tamil
block|,
literal|"Tamil"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Telugu
block|,
literal|"Telugu"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Kannada
block|,
literal|"Kannada"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Malayalam
block|,
literal|"Malayalam"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Sinhala
block|,
literal|"Sinhala"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Thai
block|,
literal|"Thai"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Lao
block|,
literal|"Lao"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Tibetan
block|,
literal|"Tibetan"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Myanmar
block|,
literal|"Myanmar"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Georgian
block|,
literal|"Georgian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Hangul
block|,
literal|"Hangul"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Ethiopic
block|,
literal|"Ethiopic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Cherokee
block|,
literal|"Cherokee"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_CanadianAboriginal
block|,
literal|"CanadianAboriginal"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Ogham
block|,
literal|"Ogham"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Runic
block|,
literal|"Runic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Khmer
block|,
literal|"Khmer"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Mongolian
block|,
literal|"Mongolian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Hiragana
block|,
literal|"Hiragana"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Katakana
block|,
literal|"Katakana"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Bopomofo
block|,
literal|"Bopomofo"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Han
block|,
literal|"Han"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Yi
block|,
literal|"Yi"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_OldItalic
block|,
literal|"OldItalic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Gothic
block|,
literal|"Gothic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Deseret
block|,
literal|"Deseret"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Tagalog
block|,
literal|"Tagalog"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Hanunoo
block|,
literal|"Hanunoo"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Buhid
block|,
literal|"Buhid"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Tagbanwa
block|,
literal|"Tagbanwa"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Coptic
block|,
literal|"Coptic"
block|}
block|,
comment|// 4.0
block|{
name|QChar
operator|::
name|Script_Limbu
block|,
literal|"Limbu"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_TaiLe
block|,
literal|"TaiLe"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_LinearB
block|,
literal|"LinearB"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Ugaritic
block|,
literal|"Ugaritic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Shavian
block|,
literal|"Shavian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Osmanya
block|,
literal|"Osmanya"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Cypriot
block|,
literal|"Cypriot"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Braille
block|,
literal|"Braille"
block|}
block|,
comment|// 4.1
block|{
name|QChar
operator|::
name|Script_Buginese
block|,
literal|"Buginese"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_NewTaiLue
block|,
literal|"NewTaiLue"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Glagolitic
block|,
literal|"Glagolitic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Tifinagh
block|,
literal|"Tifinagh"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_SylotiNagri
block|,
literal|"SylotiNagri"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_OldPersian
block|,
literal|"OldPersian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Kharoshthi
block|,
literal|"Kharoshthi"
block|}
block|,
comment|// 5.0
block|{
name|QChar
operator|::
name|Script_Balinese
block|,
literal|"Balinese"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Cuneiform
block|,
literal|"Cuneiform"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Phoenician
block|,
literal|"Phoenician"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_PhagsPa
block|,
literal|"PhagsPa"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Nko
block|,
literal|"Nko"
block|}
block|,
comment|// 5.1
block|{
name|QChar
operator|::
name|Script_Sundanese
block|,
literal|"Sundanese"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Lepcha
block|,
literal|"Lepcha"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_OlChiki
block|,
literal|"OlChiki"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Vai
block|,
literal|"Vai"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Saurashtra
block|,
literal|"Saurashtra"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_KayahLi
block|,
literal|"KayahLi"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Rejang
block|,
literal|"Rejang"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Lycian
block|,
literal|"Lycian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Carian
block|,
literal|"Carian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Lydian
block|,
literal|"Lydian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Cham
block|,
literal|"Cham"
block|}
block|,
comment|// 5.2
block|{
name|QChar
operator|::
name|Script_TaiTham
block|,
literal|"TaiTham"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_TaiViet
block|,
literal|"TaiViet"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Avestan
block|,
literal|"Avestan"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_EgyptianHieroglyphs
block|,
literal|"EgyptianHieroglyphs"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Samaritan
block|,
literal|"Samaritan"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Lisu
block|,
literal|"Lisu"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Bamum
block|,
literal|"Bamum"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Javanese
block|,
literal|"Javanese"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_MeeteiMayek
block|,
literal|"MeeteiMayek"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_ImperialAramaic
block|,
literal|"ImperialAramaic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_OldSouthArabian
block|,
literal|"OldSouthArabian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_InscriptionalParthian
block|,
literal|"InscriptionalParthian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_InscriptionalPahlavi
block|,
literal|"InscriptionalPahlavi"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_OldTurkic
block|,
literal|"OldTurkic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Kaithi
block|,
literal|"Kaithi"
block|}
block|,
comment|// 6.0
block|{
name|QChar
operator|::
name|Script_Batak
block|,
literal|"Batak"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Brahmi
block|,
literal|"Brahmi"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Mandaic
block|,
literal|"Mandaic"
block|}
block|,
comment|// 6.1
block|{
name|QChar
operator|::
name|Script_Chakma
block|,
literal|"Chakma"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_MeroiticCursive
block|,
literal|"MeroiticCursive"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_MeroiticHieroglyphs
block|,
literal|"MeroiticHieroglyphs"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Miao
block|,
literal|"Miao"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Sharada
block|,
literal|"Sharada"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_SoraSompeng
block|,
literal|"SoraSompeng"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Takri
block|,
literal|"Takri"
block|}
block|,
comment|// unhandled
block|{
name|QChar
operator|::
name|Script_Unknown
block|,
literal|0
block|}
block|}
struct|;
name|Scrpt
modifier|*
name|p
init|=
name|scripts
decl_stmt|;
while|while
condition|(
name|p
operator|->
name|name
condition|)
block|{
name|scriptMap
operator|.
name|insert
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|script
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Keep this one in sync with the code in createPropertyInfo
end_comment
begin_decl_stmt
DECL|variable|property_string
specifier|static
specifier|const
name|char
modifier|*
name|property_string
init|=
literal|"struct Properties {\n"
literal|"    ushort category            : 8; /* 5 used */\n"
literal|"    ushort direction           : 8; /* 5 used */\n"
literal|"    ushort combiningClass      : 8;\n"
literal|"    ushort joining             : 2;\n"
literal|"    signed short digitValue    : 6; /* 5 used */\n"
literal|"    signed short mirrorDiff    : 16;\n"
literal|"    signed short lowerCaseDiff : 16;\n"
literal|"    signed short upperCaseDiff : 16;\n"
literal|"    signed short titleCaseDiff : 16;\n"
literal|"    signed short caseFoldDiff  : 16;\n"
literal|"    ushort lowerCaseSpecial    : 1;\n"
literal|"    ushort upperCaseSpecial    : 1;\n"
literal|"    ushort titleCaseSpecial    : 1;\n"
literal|"    ushort caseFoldSpecial     : 1;\n"
literal|"    ushort unicodeVersion      : 4;\n"
literal|"    ushort graphemeBreakClass  : 8; /* 4 used */\n"
literal|"    ushort wordBreakClass      : 8; /* 4 used */\n"
literal|"    ushort sentenceBreakClass  : 8; /* 4 used */\n"
literal|"    ushort lineBreakClass      : 8; /* 6 used */\n"
literal|"    ushort script              : 8; /* 7 used */\n"
literal|"};\n\n"
literal|"Q_CORE_EXPORT const Properties * QT_FASTCALL properties(uint ucs4);\n"
literal|"Q_CORE_EXPORT const Properties * QT_FASTCALL properties(ushort ucs2);\n"
literal|"\n"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|methods
specifier|static
specifier|const
name|char
modifier|*
name|methods
init|=
literal|"Q_CORE_EXPORT GraphemeBreakClass QT_FASTCALL graphemeBreakClass(uint ucs4);\n"
literal|"inline GraphemeBreakClass graphemeBreakClass(QChar ch)\n"
literal|"{ return graphemeBreakClass(ch.unicode()); }\n"
literal|"\n"
literal|"Q_CORE_EXPORT WordBreakClass QT_FASTCALL wordBreakClass(uint ucs4);\n"
literal|"inline WordBreakClass wordBreakClass(QChar ch)\n"
literal|"{ return wordBreakClass(ch.unicode()); }\n"
literal|"\n"
literal|"Q_CORE_EXPORT SentenceBreakClass QT_FASTCALL sentenceBreakClass(uint ucs4);\n"
literal|"inline SentenceBreakClass sentenceBreakClass(QChar ch)\n"
literal|"{ return sentenceBreakClass(ch.unicode()); }\n"
literal|"\n"
literal|"Q_CORE_EXPORT LineBreakClass QT_FASTCALL lineBreakClass(uint ucs4);\n"
literal|"inline LineBreakClass lineBreakClass(QChar ch)\n"
literal|"{ return lineBreakClass(ch.unicode()); }\n"
literal|"\n"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|SizeOfPropertiesStruct
specifier|static
specifier|const
name|int
name|SizeOfPropertiesStruct
init|=
literal|20
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|PropertyFlags
struct|struct
name|PropertyFlags
block|{
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|PropertyFlags
modifier|&
name|o
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|combiningClass
operator|==
name|o
operator|.
name|combiningClass
operator|&&
name|category
operator|==
name|o
operator|.
name|category
operator|&&
name|direction
operator|==
name|o
operator|.
name|direction
operator|&&
name|joining
operator|==
name|o
operator|.
name|joining
operator|&&
name|age
operator|==
name|o
operator|.
name|age
operator|&&
name|digitValue
operator|==
name|o
operator|.
name|digitValue
operator|&&
name|mirrorDiff
operator|==
name|o
operator|.
name|mirrorDiff
operator|&&
name|lowerCaseDiff
operator|==
name|o
operator|.
name|lowerCaseDiff
operator|&&
name|upperCaseDiff
operator|==
name|o
operator|.
name|upperCaseDiff
operator|&&
name|titleCaseDiff
operator|==
name|o
operator|.
name|titleCaseDiff
operator|&&
name|caseFoldDiff
operator|==
name|o
operator|.
name|caseFoldDiff
operator|&&
name|lowerCaseSpecial
operator|==
name|o
operator|.
name|lowerCaseSpecial
operator|&&
name|upperCaseSpecial
operator|==
name|o
operator|.
name|upperCaseSpecial
operator|&&
name|titleCaseSpecial
operator|==
name|o
operator|.
name|titleCaseSpecial
operator|&&
name|caseFoldSpecial
operator|==
name|o
operator|.
name|caseFoldSpecial
operator|&&
name|graphemeBreakClass
operator|==
name|o
operator|.
name|graphemeBreakClass
operator|&&
name|wordBreakClass
operator|==
name|o
operator|.
name|wordBreakClass
operator|&&
name|sentenceBreakClass
operator|==
name|o
operator|.
name|sentenceBreakClass
operator|&&
name|lineBreakClass
operator|==
name|o
operator|.
name|lineBreakClass
operator|&&
name|script
operator|==
name|o
operator|.
name|script
operator|)
return|;
block|}
comment|// from UnicodeData.txt
DECL|member|combiningClass
name|uchar
name|combiningClass
range|:
literal|8
decl_stmt|;
DECL|member|category
name|QChar
operator|::
name|Category
name|category
range|:
literal|5
decl_stmt|;
DECL|member|direction
name|QChar
operator|::
name|Direction
name|direction
range|:
literal|5
decl_stmt|;
comment|// from ArabicShaping.txt
DECL|member|joining
name|QChar
operator|::
name|Joining
name|joining
range|:
literal|2
decl_stmt|;
comment|// from DerivedAge.txt
DECL|member|age
name|QChar
operator|::
name|UnicodeVersion
name|age
range|:
literal|4
decl_stmt|;
DECL|member|digitValue
name|int
name|digitValue
decl_stmt|;
DECL|member|mirrorDiff
name|int
name|mirrorDiff
range|:
literal|16
decl_stmt|;
DECL|member|lowerCaseDiff
name|int
name|lowerCaseDiff
decl_stmt|;
DECL|member|upperCaseDiff
name|int
name|upperCaseDiff
decl_stmt|;
DECL|member|titleCaseDiff
name|int
name|titleCaseDiff
decl_stmt|;
DECL|member|caseFoldDiff
name|int
name|caseFoldDiff
decl_stmt|;
DECL|member|lowerCaseSpecial
name|bool
name|lowerCaseSpecial
decl_stmt|;
DECL|member|upperCaseSpecial
name|bool
name|upperCaseSpecial
decl_stmt|;
DECL|member|titleCaseSpecial
name|bool
name|titleCaseSpecial
decl_stmt|;
DECL|member|caseFoldSpecial
name|bool
name|caseFoldSpecial
decl_stmt|;
DECL|member|graphemeBreakClass
name|GraphemeBreakClass
name|graphemeBreakClass
decl_stmt|;
DECL|member|wordBreakClass
name|WordBreakClass
name|wordBreakClass
decl_stmt|;
DECL|member|sentenceBreakClass
name|SentenceBreakClass
name|sentenceBreakClass
decl_stmt|;
DECL|member|lineBreakClass
name|LineBreakClass
name|lineBreakClass
decl_stmt|;
DECL|member|script
name|int
name|script
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|specialCaseMap
specifier|static
name|QList
argument_list|<
name|int
argument_list|>
name|specialCaseMap
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|appendToSpecialCaseMap
specifier|static
name|int
name|appendToSpecialCaseMap
parameter_list|(
specifier|const
name|QList
argument_list|<
name|int
argument_list|>
modifier|&
name|map
parameter_list|)
block|{
name|QList
argument_list|<
name|int
argument_list|>
name|utf16map
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|map
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|val
init|=
name|map
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|utf16map
operator|<<
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|utf16map
operator|<<
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf16map
operator|<<
name|val
expr_stmt|;
block|}
block|}
name|int
name|length
init|=
name|utf16map
operator|.
name|size
argument_list|()
decl_stmt|;
name|utf16map
operator|.
name|prepend
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|specialCaseMap
operator|.
name|isEmpty
argument_list|()
condition|)
name|specialCaseMap
operator|<<
literal|0
expr_stmt|;
comment|// placeholder
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|specialCaseMap
operator|.
name|size
argument_list|()
condition|)
block|{
name|int
name|n
init|=
name|specialCaseMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|length
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|specialCaseMap
operator|.
name|at
argument_list|(
name|i
operator|+
name|j
argument_list|)
operator|!=
name|utf16map
operator|.
name|at
argument_list|(
name|j
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>
name|n
condition|)
return|return
name|i
return|;
block|}
name|i
operator|+=
name|n
operator|+
literal|1
expr_stmt|;
block|}
name|int
name|pos
init|=
name|specialCaseMap
operator|.
name|size
argument_list|()
decl_stmt|;
name|specialCaseMap
operator|<<
name|utf16map
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function
begin_struct
DECL|struct|UnicodeData
struct|struct
name|UnicodeData
block|{
DECL|function|UnicodeData
name|UnicodeData
parameter_list|(
name|int
name|codepoint
init|=
literal|0
parameter_list|)
block|{
name|p
operator|.
name|category
operator|=
name|QChar
operator|::
name|Other_NotAssigned
expr_stmt|;
comment|// Cn
name|p
operator|.
name|combiningClass
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|direction
operator|=
name|QChar
operator|::
name|DirL
expr_stmt|;
comment|// DerivedBidiClass.txt
comment|// The unassigned code points that default to AL are in the ranges:
comment|//     [U+0600..U+07BF, U+08A0..U+08FF, U+FB50..U+FDCF, U+FDF0..U+FDFF, U+FE70..U+FEFF, U+1EE00..U+1EEFF]
if|if
condition|(
operator|(
name|codepoint
operator|>=
literal|0x0600
operator|&&
name|codepoint
operator|<=
literal|0x07BF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x08A0
operator|&&
name|codepoint
operator|<=
literal|0x08FF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0xFB50
operator|&&
name|codepoint
operator|<=
literal|0xFDCF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0xFDF0
operator|&&
name|codepoint
operator|<=
literal|0xFDFF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0xFE70
operator|&&
name|codepoint
operator|<=
literal|0xFEFF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x1EE00
operator|&&
name|codepoint
operator|<=
literal|0x1EEFF
operator|)
condition|)
block|{
name|p
operator|.
name|direction
operator|=
name|QChar
operator|::
name|DirAL
expr_stmt|;
block|}
comment|// The unassigned code points that default to R are in the ranges:
comment|//     [U+0590..U+05FF, U+07C0..U+089F, U+FB1D..U+FB4F, U+10800..U+10FFF, U+1E800..U+1EDFF, U+1EF00..U+1EFFF]
elseif|else
if|if
condition|(
operator|(
name|codepoint
operator|>=
literal|0x0590
operator|&&
name|codepoint
operator|<=
literal|0x05FF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x07C0
operator|&&
name|codepoint
operator|<=
literal|0x089F
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0xFB1D
operator|&&
name|codepoint
operator|<=
literal|0xFB4F
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x10800
operator|&&
name|codepoint
operator|<=
literal|0x10FFF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x1E800
operator|&&
name|codepoint
operator|<=
literal|0x1EDFF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x1EF00
operator|&&
name|codepoint
operator|<=
literal|0x1EFFF
operator|)
condition|)
block|{
name|p
operator|.
name|direction
operator|=
name|QChar
operator|::
name|DirR
expr_stmt|;
block|}
name|p
operator|.
name|lineBreakClass
operator|=
name|LineBreak_AL
expr_stmt|;
comment|// XX -> AL
comment|// LineBreak.txt
comment|// The unassigned code points that default to "ID" include ranges in the following blocks:
comment|//     [U+3400..U+4DBF, U+4E00..U+9FFF, U+F900..U+FAFF, U+20000..U+2A6DF, U+2A700..U+2B73F, U+2B740..U+2B81F, U+2F800..U+2FA1F, U+20000..U+2FFFD, U+30000..U+3FFFD]
if|if
condition|(
operator|(
name|codepoint
operator|>=
literal|0x3400
operator|&&
name|codepoint
operator|<=
literal|0x4DBF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x4E00
operator|&&
name|codepoint
operator|<=
literal|0x9FFF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0xF900
operator|&&
name|codepoint
operator|<=
literal|0xFAFF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x20000
operator|&&
name|codepoint
operator|<=
literal|0x2A6DF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x2A700
operator|&&
name|codepoint
operator|<=
literal|0x2B73F
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x2B740
operator|&&
name|codepoint
operator|<=
literal|0x2B81F
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x2F800
operator|&&
name|codepoint
operator|<=
literal|0x2FA1F
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x20000
operator|&&
name|codepoint
operator|<=
literal|0x2FFFD
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x30000
operator|&&
name|codepoint
operator|<=
literal|0x3FFFD
operator|)
condition|)
block|{
name|p
operator|.
name|lineBreakClass
operator|=
name|LineBreak_ID
expr_stmt|;
block|}
name|mirroredChar
operator|=
literal|0
expr_stmt|;
name|decompositionType
operator|=
name|QChar
operator|::
name|NoDecomposition
expr_stmt|;
name|p
operator|.
name|joining
operator|=
name|QChar
operator|::
name|OtherJoining
expr_stmt|;
name|p
operator|.
name|age
operator|=
name|QChar
operator|::
name|Unicode_Unassigned
expr_stmt|;
name|p
operator|.
name|mirrorDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|digitValue
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|.
name|lowerCaseDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|upperCaseDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|titleCaseDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|caseFoldDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|lowerCaseSpecial
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|upperCaseSpecial
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|titleCaseSpecial
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|caseFoldSpecial
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|graphemeBreakClass
operator|=
name|GraphemeBreak_Other
expr_stmt|;
name|p
operator|.
name|wordBreakClass
operator|=
name|WordBreak_Other
expr_stmt|;
name|p
operator|.
name|sentenceBreakClass
operator|=
name|SentenceBreak_Other
expr_stmt|;
name|p
operator|.
name|script
operator|=
name|QChar
operator|::
name|Script_Unknown
expr_stmt|;
name|propertyIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|excludedComposition
operator|=
literal|false
expr_stmt|;
block|}
specifier|static
name|UnicodeData
modifier|&
name|valueRef
parameter_list|(
name|int
name|codepoint
parameter_list|)
function_decl|;
DECL|member|p
name|PropertyFlags
name|p
decl_stmt|;
comment|// from UnicodeData.txt
DECL|member|decompositionType
name|QChar
operator|::
name|Decomposition
name|decompositionType
decl_stmt|;
DECL|member|decomposition
name|QList
argument_list|<
name|int
argument_list|>
name|decomposition
decl_stmt|;
DECL|member|specialFolding
name|QList
argument_list|<
name|int
argument_list|>
name|specialFolding
decl_stmt|;
comment|// from BidiMirroring.txt
DECL|member|mirroredChar
name|int
name|mirroredChar
decl_stmt|;
comment|// DerivedNormalizationProps.txt
DECL|member|excludedComposition
name|bool
name|excludedComposition
decl_stmt|;
comment|// computed position of unicode property set
DECL|member|propertyIndex
name|int
name|propertyIndex
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|unicodeData
specifier|static
name|QList
argument_list|<
name|UnicodeData
argument_list|>
name|unicodeData
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|valueRef
name|UnicodeData
modifier|&
name|UnicodeData
operator|::
name|valueRef
parameter_list|(
name|int
name|codepoint
parameter_list|)
block|{
specifier|static
name|bool
name|initialized
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|unicodeData
operator|.
name|reserve
argument_list|(
name|QChar
operator|::
name|LastValidCodePoint
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|uc
init|=
literal|0
init|;
name|uc
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
condition|;
operator|++
name|uc
control|)
name|unicodeData
operator|.
name|append
argument_list|(
name|UnicodeData
argument_list|(
name|uc
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|true
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|codepoint
operator|<=
literal|0x10ffff
argument_list|)
expr_stmt|;
return|return
name|unicodeData
index|[
name|codepoint
index|]
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|decompositionLength
specifier|static
name|QHash
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|decompositionLength
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|highestComposedCharacter
specifier|static
name|int
name|highestComposedCharacter
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|numLigatures
specifier|static
name|int
name|numLigatures
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|highestLigature
specifier|static
name|int
name|highestLigature
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|Ligature
struct|struct
name|Ligature
block|{
DECL|member|u1
name|int
name|u1
decl_stmt|;
DECL|member|u2
name|int
name|u2
decl_stmt|;
DECL|member|ligature
name|int
name|ligature
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|// we need them sorted after the first component for fast lookup
end_comment
begin_function
DECL|function|operator <
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|Ligature
modifier|&
name|l1
parameter_list|,
specifier|const
name|Ligature
modifier|&
name|l2
parameter_list|)
block|{
return|return
name|l1
operator|.
name|u1
operator|<
name|l2
operator|.
name|u1
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|ligatureHashes
specifier|static
name|QHash
argument_list|<
name|int
argument_list|,
name|QList
argument_list|<
name|Ligature
argument_list|>
argument_list|>
name|ligatureHashes
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|combiningClassUsage
specifier|static
name|QHash
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|combiningClassUsage
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|maxLowerCaseDiff
specifier|static
name|int
name|maxLowerCaseDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|maxUpperCaseDiff
specifier|static
name|int
name|maxUpperCaseDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|maxTitleCaseDiff
specifier|static
name|int
name|maxTitleCaseDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|readUnicodeData
specifier|static
name|void
name|readUnicodeData
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading UnicodeData.txt"
argument_list|)
expr_stmt|;
enum|enum
name|UniDataFields
block|{
name|UD_Value
block|,
name|UD_Name
block|,
name|UD_Category
block|,
name|UD_CombiningClass
block|,
name|UD_BidiCategory
block|,
name|UD_Decomposition
block|,
name|UD_DecimalDigitValue
block|,
name|UD_DigitValue
block|,
name|UD_NumericValue
block|,
name|UD_Mirrored
block|,
name|UD_OldName
block|,
name|UD_Comment
block|,
name|UD_UpperCase
block|,
name|UD_LowerCase
block|,
name|UD_TitleCase
block|}
enum|;
name|QFile
name|f
argument_list|(
literal|"data/UnicodeData.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find UnicodeData.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|truncate
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|properties
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|properties
index|[
name|UD_Value
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|codepoint
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
argument_list|)
expr_stmt|;
name|int
name|lastCodepoint
init|=
name|codepoint
decl_stmt|;
name|QByteArray
name|name
init|=
name|properties
index|[
name|UD_Name
index|]
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|'<'
argument_list|)
operator|&&
name|name
operator|.
name|contains
argument_list|(
literal|"First"
argument_list|)
condition|)
block|{
name|QByteArray
name|nextLine
decl_stmt|;
name|nextLine
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|f
operator|.
name|readLine
argument_list|(
name|nextLine
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|properties
init|=
name|nextLine
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|properties
index|[
name|UD_Name
index|]
operator|.
name|startsWith
argument_list|(
literal|'<'
argument_list|)
operator|&&
name|properties
index|[
name|UD_Name
index|]
operator|.
name|contains
argument_list|(
literal|"Last"
argument_list|)
argument_list|)
expr_stmt|;
name|lastCodepoint
operator|=
name|properties
index|[
name|UD_Value
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|lastCodepoint
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
argument_list|)
expr_stmt|;
block|}
name|UnicodeData
modifier|&
name|data
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|data
operator|.
name|p
operator|.
name|category
operator|=
name|categoryMap
operator|.
name|value
argument_list|(
name|properties
index|[
name|UD_Category
index|]
argument_list|,
name|QChar
operator|::
name|Other_NotAssigned
argument_list|)
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|combiningClass
operator|=
name|properties
index|[
name|UD_CombiningClass
index|]
operator|.
name|toInt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|combiningClassUsage
operator|.
name|contains
argument_list|(
name|data
operator|.
name|p
operator|.
name|combiningClass
argument_list|)
condition|)
name|combiningClassUsage
index|[
name|data
operator|.
name|p
operator|.
name|combiningClass
index|]
operator|=
literal|1
expr_stmt|;
else|else
operator|++
name|combiningClassUsage
index|[
name|data
operator|.
name|p
operator|.
name|combiningClass
index|]
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|direction
operator|=
name|directionMap
operator|.
name|value
argument_list|(
name|properties
index|[
name|UD_BidiCategory
index|]
argument_list|,
name|data
operator|.
name|p
operator|.
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|properties
index|[
name|UD_UpperCase
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|upperCase
init|=
name|properties
index|[
name|UD_UpperCase
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|diff
init|=
name|upperCase
operator|-
name|codepoint
decl_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|diff
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|14
operator|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"upperCaseDiff exceeded ("
operator|<<
name|hex
operator|<<
name|codepoint
operator|<<
literal|"->"
operator|<<
name|upperCase
operator|<<
literal|"); map it for special case"
expr_stmt|;
comment|// if the condition below doesn't hold anymore we need to modify our special upper casing code in qchar.cpp
name|Q_ASSERT
argument_list|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
operator|&&
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|upperCase
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|upperCaseSpecial
operator|=
literal|true
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|upperCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|QList
argument_list|<
name|int
argument_list|>
argument_list|()
operator|<<
name|upperCase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|.
name|p
operator|.
name|upperCaseDiff
operator|=
name|diff
expr_stmt|;
name|maxUpperCaseDiff
operator|=
name|qMax
argument_list|(
name|maxUpperCaseDiff
argument_list|,
name|qAbs
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
operator|||
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|upperCase
argument_list|)
condition|)
block|{
comment|// if the conditions below doesn't hold anymore we need to modify our upper casing code
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|upperCase
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|+
name|diff
operator|==
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|upperCase
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|properties
index|[
name|UD_LowerCase
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|lowerCase
init|=
name|properties
index|[
name|UD_LowerCase
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|diff
init|=
name|lowerCase
operator|-
name|codepoint
decl_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|diff
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|14
operator|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"lowerCaseDiff exceeded ("
operator|<<
name|hex
operator|<<
name|codepoint
operator|<<
literal|"->"
operator|<<
name|lowerCase
operator|<<
literal|"); map it for special case"
expr_stmt|;
comment|// if the condition below doesn't hold anymore we need to modify our special lower casing code in qchar.cpp
name|Q_ASSERT
argument_list|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
operator|&&
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|lowerCase
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|lowerCaseSpecial
operator|=
literal|true
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|lowerCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|QList
argument_list|<
name|int
argument_list|>
argument_list|()
operator|<<
name|lowerCase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|.
name|p
operator|.
name|lowerCaseDiff
operator|=
name|diff
expr_stmt|;
name|maxLowerCaseDiff
operator|=
name|qMax
argument_list|(
name|maxLowerCaseDiff
argument_list|,
name|qAbs
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
operator|||
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|lowerCase
argument_list|)
condition|)
block|{
comment|// if the conditions below doesn't hold anymore we need to modify our lower casing code
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|lowerCase
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|+
name|diff
operator|==
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|lowerCase
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// we want toTitleCase to map to ToUpper in case we don't have any titlecase.
if|if
condition|(
name|properties
index|[
name|UD_TitleCase
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
name|properties
index|[
name|UD_TitleCase
index|]
operator|=
name|properties
index|[
name|UD_UpperCase
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|properties
index|[
name|UD_TitleCase
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|titleCase
init|=
name|properties
index|[
name|UD_TitleCase
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|diff
init|=
name|titleCase
operator|-
name|codepoint
decl_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|diff
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|14
operator|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"titleCaseDiff exceeded ("
operator|<<
name|hex
operator|<<
name|codepoint
operator|<<
literal|"->"
operator|<<
name|titleCase
operator|<<
literal|"); map it for special case"
expr_stmt|;
comment|// if the condition below doesn't hold anymore we need to modify our special title casing code in qchar.cpp
name|Q_ASSERT
argument_list|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
operator|&&
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|titleCase
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|titleCaseSpecial
operator|=
literal|true
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|titleCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|QList
argument_list|<
name|int
argument_list|>
argument_list|()
operator|<<
name|titleCase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|.
name|p
operator|.
name|titleCaseDiff
operator|=
name|diff
expr_stmt|;
name|maxTitleCaseDiff
operator|=
name|qMax
argument_list|(
name|maxTitleCaseDiff
argument_list|,
name|qAbs
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
operator|||
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|titleCase
argument_list|)
condition|)
block|{
comment|// if the conditions below doesn't hold anymore we need to modify our title casing code
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|titleCase
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|+
name|diff
operator|==
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|titleCase
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|properties
index|[
name|UD_DigitValue
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
name|data
operator|.
name|p
operator|.
name|digitValue
operator|=
name|properties
index|[
name|UD_DigitValue
index|]
operator|.
name|toInt
argument_list|()
expr_stmt|;
comment|// decompositition
name|QByteArray
name|decomposition
init|=
name|properties
index|[
name|UD_Decomposition
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|decomposition
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|highestComposedCharacter
operator|=
name|qMax
argument_list|(
name|highestComposedCharacter
argument_list|,
name|codepoint
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|d
init|=
name|decomposition
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
index|[
literal|0
index|]
operator|.
name|contains
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|data
operator|.
name|decompositionType
operator|=
name|decompositionMap
operator|.
name|value
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|QChar
operator|::
name|NoDecomposition
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|decompositionType
operator|==
name|QChar
operator|::
name|NoDecomposition
condition|)
name|qFatal
argument_list|(
literal|"unassigned decomposition type: %s"
argument_list|,
name|d
index|[
literal|0
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|data
operator|.
name|decompositionType
operator|=
name|QChar
operator|::
name|Canonical
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|data
operator|.
name|decomposition
operator|.
name|append
argument_list|(
name|d
index|[
name|i
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
operator|++
name|decompositionLength
index|[
name|data
operator|.
name|decomposition
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|codepoint
init|;
name|i
operator|<=
name|lastCodepoint
condition|;
operator|++
name|i
control|)
name|unicodeData
index|[
name|i
index|]
operator|=
name|data
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|maxMirroredDiff
specifier|static
name|int
name|maxMirroredDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|readBidiMirroring
specifier|static
name|void
name|readBidiMirroring
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading BidiMirroring.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/BidiMirroring.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find BidiMirroring.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|line
operator|=
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|pair
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|pair
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|pair
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|mirror
init|=
name|pair
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|d
operator|.
name|mirroredChar
operator|=
name|mirror
expr_stmt|;
name|d
operator|.
name|p
operator|.
name|mirrorDiff
operator|=
name|d
operator|.
name|mirroredChar
operator|-
name|codepoint
expr_stmt|;
name|maxMirroredDiff
operator|=
name|qMax
argument_list|(
name|maxMirroredDiff
argument_list|,
name|qAbs
argument_list|(
name|d
operator|.
name|p
operator|.
name|mirrorDiff
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|readArabicShaping
specifier|static
name|void
name|readArabicShaping
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading ArabicShaping.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/ArabicShaping.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find ArabicShaping.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|=
name|line
operator|.
name|trimmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|4
argument_list|)
expr_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|l
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|Joining
name|joining
init|=
name|joining_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|2
index|]
operator|.
name|trimmed
argument_list|()
argument_list|,
name|Joining_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|joining
operator|==
name|Joining_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned or unhandled joining value: %s"
argument_list|,
name|l
index|[
literal|2
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|joining
operator|==
name|Joining_Left
condition|)
block|{
comment|// There are currently no characters of joining type Left_Joining defined in Unicode.
name|qFatal
argument_list|(
literal|"%x: joining type '%s' was met; the current implementation needs to be revised!"
argument_list|,
name|codepoint
argument_list|,
name|l
index|[
literal|2
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
if|if
condition|(
name|joining
operator|==
name|Joining_Right
condition|)
name|d
operator|.
name|p
operator|.
name|joining
operator|=
name|QChar
operator|::
name|Right
expr_stmt|;
elseif|else
if|if
condition|(
name|joining
operator|==
name|Joining_Dual
condition|)
name|d
operator|.
name|p
operator|.
name|joining
operator|=
name|QChar
operator|::
name|Dual
expr_stmt|;
elseif|else
if|if
condition|(
name|joining
operator|==
name|Joining_Causing
condition|)
name|d
operator|.
name|p
operator|.
name|joining
operator|=
name|QChar
operator|::
name|Center
expr_stmt|;
else|else
name|d
operator|.
name|p
operator|.
name|joining
operator|=
name|QChar
operator|::
name|OtherJoining
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|readDerivedAge
specifier|static
name|void
name|readDerivedAge
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading DerivedAge.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/DerivedAge.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find DerivedAge.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|QChar
operator|::
name|UnicodeVersion
name|age
init|=
name|age_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
operator|.
name|trimmed
argument_list|()
argument_list|,
name|QChar
operator|::
name|Unicode_Unassigned
argument_list|)
decl_stmt|;
comment|//qDebug()<< hex<< from<< ".."<< to<< ba<< age;
if|if
condition|(
name|age
operator|==
name|QChar
operator|::
name|Unicode_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned or unhandled age value: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|d
operator|.
name|p
operator|.
name|age
operator|=
name|age
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readDerivedNormalizationProps
specifier|static
name|void
name|readDerivedNormalizationProps
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading DerivedNormalizationProps.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/DerivedNormalizationProps.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find DerivedNormalizationProps.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|trimmed
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|propName
init|=
name|l
index|[
literal|1
index|]
operator|.
name|trimmed
argument_list|()
decl_stmt|;
if|if
condition|(
name|propName
operator|!=
literal|"Full_Composition_Exclusion"
condition|)
comment|// ###
continue|continue;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|d
operator|.
name|excludedComposition
operator|=
literal|true
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|codepoint
init|=
literal|0
init|;
name|codepoint
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|excludedComposition
operator|&&
name|d
operator|.
name|decompositionType
operator|==
name|QChar
operator|::
name|Canonical
operator|&&
name|d
operator|.
name|decomposition
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|d
operator|.
name|decomposition
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|int
name|part1
init|=
name|d
operator|.
name|decomposition
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|part2
init|=
name|d
operator|.
name|decomposition
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// all non-starters are listed in DerivedNormalizationProps.txt
comment|// and already excluded from composition
name|Q_ASSERT
argument_list|(
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|part1
argument_list|)
operator|.
name|p
operator|.
name|combiningClass
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|++
name|numLigatures
expr_stmt|;
name|highestLigature
operator|=
name|qMax
argument_list|(
name|highestLigature
argument_list|,
name|part1
argument_list|)
expr_stmt|;
name|Ligature
name|l
init|=
block|{
name|part1
block|,
name|part2
block|,
name|codepoint
block|}
decl_stmt|;
name|ligatureHashes
index|[
name|part2
index|]
operator|.
name|append
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_struct
DECL|struct|NormalizationCorrection
struct|struct
name|NormalizationCorrection
block|{
DECL|member|codepoint
name|uint
name|codepoint
decl_stmt|;
DECL|member|mapped
name|uint
name|mapped
decl_stmt|;
DECL|member|version
name|int
name|version
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|createNormalizationCorrections
specifier|static
name|QByteArray
name|createNormalizationCorrections
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading NormalizationCorrections.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/NormalizationCorrections.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find NormalizationCorrections.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"struct NormalizationCorrection {\n"
literal|"    uint ucs4;\n"
literal|"    uint old_mapping;\n"
literal|"    int version;\n"
literal|"};\n\n"
literal|"static const NormalizationCorrection uc_normalization_corrections[] = {\n"
expr_stmt|;
name|int
name|maxVersion
init|=
literal|0
decl_stmt|;
name|int
name|numCorrections
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|Q_ASSERT
argument_list|(
operator|!
name|line
operator|.
name|contains
argument_list|(
literal|".."
argument_list|)
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|fields
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|fields
operator|.
name|size
argument_list|()
operator|==
literal|4
argument_list|)
expr_stmt|;
name|NormalizationCorrection
name|c
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|c
operator|.
name|codepoint
operator|=
name|fields
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|c
operator|.
name|mapped
operator|=
name|fields
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|==
literal|"3.2.0"
condition|)
name|c
operator|.
name|version
operator|=
name|QChar
operator|::
name|Unicode_3_2
expr_stmt|;
elseif|else
if|if
condition|(
name|fields
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|==
literal|"4.0.0"
condition|)
name|c
operator|.
name|version
operator|=
name|QChar
operator|::
name|Unicode_4_0
expr_stmt|;
else|else
name|qFatal
argument_list|(
literal|"unknown unicode version in NormalizationCorrection.txt"
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"    { 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|c
operator|.
name|codepoint
argument_list|,
literal|16
argument_list|)
operator|+
literal|", 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|c
operator|.
name|mapped
argument_list|,
literal|16
argument_list|)
operator|+
literal|", "
operator|+
name|QString
operator|::
name|number
argument_list|(
name|c
operator|.
name|version
argument_list|)
operator|+
literal|" },\n"
expr_stmt|;
operator|++
name|numCorrections
expr_stmt|;
name|maxVersion
operator|=
name|qMax
argument_list|(
name|c
operator|.
name|version
argument_list|,
name|maxVersion
argument_list|)
expr_stmt|;
block|}
name|out
operator|+=
literal|"};\n\n"
literal|"enum { NumNormalizationCorrections = "
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|numCorrections
argument_list|)
operator|+
literal|" };\n"
literal|"enum { NormalizationCorrectionsVersionMax = "
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|maxVersion
argument_list|)
operator|+
literal|" };\n\n"
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|readLineBreak
specifier|static
name|void
name|readLineBreak
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading LineBreak.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/LineBreak.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find LineBreak.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|LineBreakClass
name|lb
init|=
name|line_break_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|LineBreak_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|lb
operator|==
name|LineBreak_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned line break class: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|d
operator|.
name|p
operator|.
name|lineBreakClass
operator|=
name|lb
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readSpecialCasing
specifier|static
name|void
name|readSpecialCasing
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading SpecialCasing.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/SpecialCasing.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find SpecialCasing.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|QByteArray
name|condition
init|=
name|l
operator|.
name|size
argument_list|()
operator|<
literal|5
condition|?
name|QByteArray
argument_list|()
else|:
name|l
index|[
literal|4
index|]
operator|.
name|trimmed
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|condition
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// #####
continue|continue;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|l
index|[
literal|0
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
comment|// if the condition below doesn't hold anymore we need to modify our
comment|// lower/upper/title casing code and case folding code
name|Q_ASSERT
argument_list|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
argument_list|)
expr_stmt|;
comment|//         qDebug()<< "codepoint"<< hex<< codepoint;
comment|//         qDebug()<< line;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|lower
init|=
name|l
index|[
literal|1
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|lowerMap
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lower
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|ok
decl_stmt|;
name|lowerMap
operator|.
name|append
argument_list|(
name|lower
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|title
init|=
name|l
index|[
literal|2
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|titleMap
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|title
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|ok
decl_stmt|;
name|titleMap
operator|.
name|append
argument_list|(
name|title
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|upper
init|=
name|l
index|[
literal|3
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|upperMap
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|upper
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|ok
decl_stmt|;
name|upperMap
operator|.
name|append
argument_list|(
name|upper
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|UnicodeData
modifier|&
name|ud
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|lowerMap
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|lowerMap
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|codepoint
operator|+
name|ud
operator|.
name|p
operator|.
name|lowerCaseDiff
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|titleMap
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|titleMap
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|codepoint
operator|+
name|ud
operator|.
name|p
operator|.
name|titleCaseDiff
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|upperMap
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|upperMap
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|codepoint
operator|+
name|ud
operator|.
name|p
operator|.
name|upperCaseDiff
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowerMap
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ud
operator|.
name|p
operator|.
name|lowerCaseSpecial
operator|=
literal|true
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|lowerCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|lowerMap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|titleMap
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ud
operator|.
name|p
operator|.
name|titleCaseSpecial
operator|=
literal|true
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|titleCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|titleMap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|upperMap
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ud
operator|.
name|p
operator|.
name|upperCaseSpecial
operator|=
literal|true
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|upperCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|upperMap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|maxCaseFoldDiff
specifier|static
name|int
name|maxCaseFoldDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|readCaseFolding
specifier|static
name|void
name|readCaseFolding
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading CaseFolding.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/CaseFolding.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find CaseFolding.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|l
index|[
literal|0
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|l
index|[
literal|1
index|]
operator|=
name|l
index|[
literal|1
index|]
operator|.
name|trimmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|l
index|[
literal|1
index|]
operator|==
literal|"F"
operator|||
name|l
index|[
literal|1
index|]
operator|==
literal|"T"
condition|)
continue|continue;
comment|//         qDebug()<< "codepoint"<< hex<< codepoint;
comment|//         qDebug()<< line;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|fold
init|=
name|l
index|[
literal|2
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|foldMap
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fold
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|ok
decl_stmt|;
name|foldMap
operator|.
name|append
argument_list|(
name|fold
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|UnicodeData
modifier|&
name|ud
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
if|if
condition|(
name|foldMap
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|int
name|caseFolded
init|=
name|foldMap
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|diff
init|=
name|caseFolded
operator|-
name|codepoint
decl_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|diff
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|14
operator|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"caseFoldDiff exceeded ("
operator|<<
name|hex
operator|<<
name|codepoint
operator|<<
literal|"->"
operator|<<
name|caseFolded
operator|<<
literal|"); map it for special case"
expr_stmt|;
comment|// if the condition below doesn't hold anymore we need to modify our special case folding code in qchar.cpp
name|Q_ASSERT
argument_list|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
operator|&&
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|caseFolded
argument_list|)
argument_list|)
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|caseFoldSpecial
operator|=
literal|true
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|caseFoldDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|foldMap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ud
operator|.
name|p
operator|.
name|caseFoldDiff
operator|=
name|diff
expr_stmt|;
name|maxCaseFoldDiff
operator|=
name|qMax
argument_list|(
name|maxCaseFoldDiff
argument_list|,
name|qAbs
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
operator|||
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|caseFolded
argument_list|)
condition|)
block|{
comment|// if the conditions below doesn't hold anymore we need to modify our case folding code
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|caseFolded
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|+
name|diff
operator|==
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|caseFolded
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//            if (caseFolded != codepoint + ud.p.lowerCaseDiff)
comment|//                qDebug()<< hex<< codepoint;
block|}
else|else
block|{
name|qFatal
argument_list|(
literal|"we currently don't support full case foldings"
argument_list|)
expr_stmt|;
comment|//             qDebug()<< "special"<< hex<< foldMap;
name|ud
operator|.
name|p
operator|.
name|caseFoldSpecial
operator|=
literal|true
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|caseFoldDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|foldMap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readGraphemeBreak
specifier|static
name|void
name|readGraphemeBreak
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading GraphemeBreakProperty.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/GraphemeBreakProperty.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find GraphemeBreakProperty.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|GraphemeBreakClass
name|brk
init|=
name|grapheme_break_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|GraphemeBreak_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|brk
operator|==
name|GraphemeBreak_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned grapheme break class: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|ud
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|ud
operator|.
name|p
operator|.
name|graphemeBreakClass
operator|=
name|brk
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readWordBreak
specifier|static
name|void
name|readWordBreak
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading WordBreakProperty.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/WordBreakProperty.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find WordBreakProperty.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|WordBreakClass
name|brk
init|=
name|word_break_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|WordBreak_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|brk
operator|==
name|WordBreak_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned word break class: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
comment|// ### [
comment|// as of Unicode 5.1, some punctuation marks were mapped to MidLetter and MidNumLet
comment|// which caused "hi.there" to be treated like if it were just a single word;
comment|// until we have a tailoring mechanism, retain the old behavior by remapping those characters here.
if|if
condition|(
name|codepoint
operator|==
literal|0x002E
condition|)
comment|// FULL STOP
name|brk
operator|=
name|WordBreak_MidNum
expr_stmt|;
elseif|else
if|if
condition|(
name|codepoint
operator|==
literal|0x003A
condition|)
comment|// COLON
name|brk
operator|=
name|WordBreak_Other
expr_stmt|;
comment|// ] ###
name|UnicodeData
modifier|&
name|ud
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|ud
operator|.
name|p
operator|.
name|wordBreakClass
operator|=
name|brk
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readSentenceBreak
specifier|static
name|void
name|readSentenceBreak
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading SentenceBreakProperty.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/SentenceBreakProperty.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find SentenceBreakProperty.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|SentenceBreakClass
name|brk
init|=
name|sentence_break_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|SentenceBreak_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|brk
operator|==
name|SentenceBreak_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned sentence break class: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|ud
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|ud
operator|.
name|p
operator|.
name|sentenceBreakClass
operator|=
name|brk
expr_stmt|;
block|}
block|}
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|// this piece of code does full case folding and comparison. We currently
end_comment
begin_comment
comment|// don't use it, since this gives lots of issues with things as case insensitive
end_comment
begin_comment
comment|// search and replace.
end_comment
begin_endif
unit|static inline void foldCase(uint ch, ushort *out) {     const QUnicodeTables::Properties *p = qGetProp(ch);     if (!p->caseFoldSpecial) {         *(out++) = ch + p->caseFoldDiff;     } else {         const ushort *folded = specialCaseMap + p->caseFoldDiff;         ushort length = *folded++;         while (length--)             *out++ = *folded++;     }     *out = 0; }  static int ucstricmp(const ushort *a, const ushort *ae, const ushort *b, const ushort *be) {     if (a == b)         return 0;     if (a == 0)         return 1;     if (b == 0)         return -1;      while (a != ae&& b != be) {         const QUnicodeTables::Properties *pa = qGetProp(*a);         const QUnicodeTables::Properties *pb = qGetProp(*b);         if (pa->caseFoldSpecial | pb->caseFoldSpecial)             goto special;             int diff = (int)(*a + pa->caseFoldDiff) - (int)(*b + pb->caseFoldDiff);         if ((diff))             return diff;         ++a;         ++b;         }     }     if (a == ae) {         if (b == be)             return 0;         return -1;     }     return 1; special:     ushort abuf[SPECIAL_CASE_MAX_LEN + 1];     ushort bbuf[SPECIAL_CASE_MAX_LEN + 1];     abuf[0] = bbuf[0] = 0;     ushort *ap = abuf;     ushort *bp = bbuf;     while (1) {         if (!*ap) {             if (a == ae) {                 if (!*bp&& b == be)                     return 0;                 return -1;             }             foldCase(*(a++), abuf);             ap = abuf;         }         if (!*bp) {             if (b == be)                 return 1;             foldCase(*(b++), bbuf);             bp = bbuf;         }         if (*ap != *bp)             return (int)*ap - (int)*bp;         ++ap;         ++bp;     } }   static int ucstricmp(const ushort *a, const ushort *ae, const uchar *b) {     if (a == 0)         return 1;     if (b == 0)         return -1;      while (a != ae&& *b) {         const QUnicodeTables::Properties *pa = qGetProp(*a);         const QUnicodeTables::Properties *pb = qGetProp((ushort)*b);         if (pa->caseFoldSpecial | pb->caseFoldSpecial)             goto special;         int diff = (int)(*a + pa->caseFoldDiff) - (int)(*b + pb->caseFoldDiff);         if ((diff))             return diff;         ++a;         ++b;     }     if (a == ae) {         if (!*b)             return 0;         return -1;     }     return 1;  special:     ushort abuf[SPECIAL_CASE_MAX_LEN + 1];     ushort bbuf[SPECIAL_CASE_MAX_LEN + 1];     abuf[0] = bbuf[0] = 0;     ushort *ap = abuf;     ushort *bp = bbuf;     while (1) {         if (!*ap) {             if (a == ae) {                 if (!*bp&& !*b)                     return 0;                 return -1;             }             foldCase(*(a++), abuf);             ap = abuf;         }         if (!*bp) {             if (!*b)                 return 1;             foldCase(*(b++), bbuf);             bp = bbuf;         }         if (*ap != *bp)             return (int)*ap - (int)*bp;         ++ap;         ++bp;     } }
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|static QList<QByteArray> blockNames; struct BlockInfo {     int blockIndex;     int firstCodePoint;     int lastCodePoint; }; static QList<BlockInfo> blockInfoList;  static void readBlocks() {     qDebug("Reading Blocks.txt");      QFile f("data/Blocks.txt");     if (!f.exists())         qFatal("Couldn't find Blocks.txt");      f.open(QFile::ReadOnly);      while (!f.atEnd()) {         QByteArray line = f.readLine();         line.resize(line.size() - 1);          int comment = line.indexOf("#");         if (comment>= 0)             line = line.left(comment);          line.replace(" ", "");          if (line.isEmpty())             continue;          int semicolon = line.indexOf(';');         Q_ASSERT(semicolon>= 0);         QByteArray codePoints = line.left(semicolon);         QByteArray blockName = line.mid(semicolon + 1);          int blockIndex = blockNames.indexOf(blockName);         if (blockIndex == -1) {             blockIndex = blockNames.size();             blockNames.append(blockName);         }          codePoints.replace("..", ".");         QList<QByteArray> cl = codePoints.split('.');          bool ok;         int first = cl[0].toInt(&ok, 16);         Q_ASSERT(ok);         int last = first;         if (cl.size() == 2) {             last = cl[1].toInt(&ok, 16);             Q_ASSERT(ok);         }          BlockInfo blockInfo = { blockIndex, first, last };         blockInfoList.append(blockInfo);     } }
endif|#
directive|endif
end_endif
begin_function
DECL|function|readScripts
specifier|static
name|void
name|readScripts
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading Scripts.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/Scripts.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find Scripts.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
init|=
name|f
operator|.
name|readLine
argument_list|()
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|line
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|"#"
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|"_"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|int
name|semicolon
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|semicolon
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|QByteArray
name|codePoints
init|=
name|line
operator|.
name|left
argument_list|(
name|semicolon
argument_list|)
decl_stmt|;
name|QByteArray
name|scriptName
init|=
name|line
operator|.
name|mid
argument_list|(
name|semicolon
operator|+
literal|1
argument_list|)
decl_stmt|;
name|codePoints
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codePoints
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|first
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|last
init|=
name|first
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|last
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|scriptMap
operator|.
name|contains
argument_list|(
name|scriptName
argument_list|)
condition|)
name|qFatal
argument_list|(
literal|"Unhandled script property value: %s"
argument_list|,
name|scriptName
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|QChar
operator|::
name|Script
name|script
init|=
name|scriptMap
operator|.
name|value
argument_list|(
name|scriptName
argument_list|,
name|QChar
operator|::
name|Script_Unknown
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|first
init|;
name|codepoint
operator|<=
name|last
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|ud
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|ud
operator|.
name|p
operator|.
name|script
operator|=
name|script
expr_stmt|;
block|}
block|}
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|static void dump(int from, int to) {     for (int i = from; i<= to; ++i) {         UnicodeData&d = UnicodeData::valueRef(i);         qDebug("0x%04x: cat=%d combining=%d dir=%d case=%x mirror=%x joining=%d age=%d",                i, d.p.category, d.p.combiningClass, d.p.direction, d.otherCase, d.mirroredChar, d.p.joining, d.p.age);         if (d.decompositionType != QChar::NoDecomposition) {             qDebug("    decomposition: type=%d, length=%d, first=%x", d.decompositionType, d.decomposition.size(),                    d.decomposition[0]);         }     }     qDebug(" "); }
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|uniqueProperties
specifier|static
name|QList
argument_list|<
name|PropertyFlags
argument_list|>
name|uniqueProperties
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|computeUniqueProperties
specifier|static
name|void
name|computeUniqueProperties
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"computeUniqueProperties:"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
literal|0
init|;
name|codepoint
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|uniqueProperties
operator|.
name|indexOf
argument_list|(
name|d
operator|.
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueProperties
operator|.
name|size
argument_list|()
expr_stmt|;
name|uniqueProperties
operator|.
name|append
argument_list|(
name|d
operator|.
name|p
argument_list|)
expr_stmt|;
block|}
name|d
operator|.
name|propertyIndex
operator|=
name|index
expr_stmt|;
block|}
name|qDebug
argument_list|(
literal|"    %d unique unicode properties found"
argument_list|,
name|uniqueProperties
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|UniqueBlock
struct|struct
name|UniqueBlock
block|{
DECL|function|UniqueBlock
specifier|inline
name|UniqueBlock
parameter_list|()
member_init_list|:
name|index
argument_list|(
operator|-
literal|1
argument_list|)
block|{}
DECL|function|operator ==
specifier|inline
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|UniqueBlock
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|values
operator|==
name|other
operator|.
name|values
return|;
block|}
DECL|member|index
name|int
name|index
decl_stmt|;
DECL|member|values
name|QVector
argument_list|<
name|int
argument_list|>
name|values
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|createPropertyInfo
specifier|static
name|QByteArray
name|createPropertyInfo
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"createPropertyInfo:"
argument_list|)
expr_stmt|;
comment|// we reserve one bit more than in the assert below for the sign
name|Q_ASSERT
argument_list|(
name|maxMirroredDiff
operator|<
operator|(
literal|1
operator|<<
literal|12
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|maxLowerCaseDiff
operator|<
operator|(
literal|1
operator|<<
literal|14
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|maxUpperCaseDiff
operator|<
operator|(
literal|1
operator|<<
literal|14
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|maxTitleCaseDiff
operator|<
operator|(
literal|1
operator|<<
literal|14
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|maxCaseFoldDiff
operator|<
operator|(
literal|1
operator|<<
literal|14
operator|)
argument_list|)
expr_stmt|;
specifier|const
name|int
name|BMP_BLOCKSIZE
init|=
literal|32
decl_stmt|;
specifier|const
name|int
name|BMP_SHIFT
init|=
literal|5
decl_stmt|;
specifier|const
name|int
name|BMP_END
init|=
literal|0x11000
decl_stmt|;
specifier|const
name|int
name|SMP_END
init|=
literal|0x110000
decl_stmt|;
specifier|const
name|int
name|SMP_BLOCKSIZE
init|=
literal|256
decl_stmt|;
specifier|const
name|int
name|SMP_SHIFT
init|=
literal|8
decl_stmt|;
name|QList
argument_list|<
name|UniqueBlock
argument_list|>
name|uniqueBlocks
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
name|blockMap
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
literal|0
init|;
name|block
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|UniqueBlock
name|b
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|reserve
argument_list|(
name|BMP_BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|BMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|uc
argument_list|)
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
name|d
operator|.
name|propertyIndex
argument_list|)
expr_stmt|;
block|}
name|int
name|index
init|=
name|uniqueBlocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|BMP_BLOCKSIZE
expr_stmt|;
name|uniqueBlocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|bmp_blocks
init|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
name|BMP_END
operator|/
name|SMP_BLOCKSIZE
init|;
name|block
operator|<
name|SMP_END
operator|/
name|SMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|UniqueBlock
name|b
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|reserve
argument_list|(
name|SMP_BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|SMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|uc
argument_list|)
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
name|d
operator|.
name|propertyIndex
argument_list|)
expr_stmt|;
block|}
name|int
name|index
init|=
name|uniqueBlocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|SMP_BLOCKSIZE
expr_stmt|;
name|uniqueBlocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|smp_blocks
init|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
operator|-
name|bmp_blocks
decl_stmt|;
name|int
name|bmp_block_data
init|=
name|bmp_blocks
operator|*
name|BMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|bmp_trie
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|bmp_mem
init|=
name|bmp_block_data
operator|+
name|bmp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in BMP."
argument_list|,
name|bmp_blocks
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|bmp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|bmp_trie
argument_list|)
expr_stmt|;
name|int
name|smp_block_data
init|=
name|smp_blocks
operator|*
name|SMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|smp_trie
init|=
operator|(
name|SMP_END
operator|-
name|BMP_END
operator|)
operator|/
name|SMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|smp_mem
init|=
name|smp_block_data
operator|+
name|smp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in SMP."
argument_list|,
name|smp_blocks
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|smp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|smp_trie
argument_list|)
expr_stmt|;
name|int
name|prop_data
init|=
name|uniqueProperties
operator|.
name|size
argument_list|()
operator|*
name|SizeOfPropertiesStruct
decl_stmt|;
name|qDebug
argument_list|(
literal|"\n        properties data uses : %d bytes"
argument_list|,
name|prop_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"    memory usage: %d bytes"
argument_list|,
name|bmp_mem
operator|+
name|smp_mem
operator|+
name|prop_data
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|blockMap
operator|.
name|last
argument_list|()
operator|+
name|blockMap
operator|.
name|size
argument_list|()
operator|<
operator|(
literal|1
operator|<<
operator|(
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
operator|*
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"static const unsigned short uc_property_trie[] = {\n"
expr_stmt|;
comment|// first write the map
name|out
operator|+=
literal|"    // 0 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|i
operator|*
name|BMP_BLOCKSIZE
operator|)
operator|%
literal|0x1000
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n\n    // 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|"\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
init|;
name|i
operator|<
name|blockMap
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
operator|(
literal|0x10000
operator|/
name|SMP_BLOCKSIZE
operator|)
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
comment|// write the data
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uniqueBlocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
specifier|const
name|UniqueBlock
modifier|&
name|b
init|=
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|b
operator|.
name|values
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|j
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|b
operator|.
name|values
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
name|out
operator|+=
literal|"#define GET_PROP_INDEX(ucs4) \\\n"
literal|"       (ucs4< 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" \\\n"
literal|"        ? (uc_property_trie[uc_property_trie[ucs4>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_SHIFT
argument_list|)
operator|+
literal|"] + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")]) \\\n"
literal|"        : (uc_property_trie[uc_property_trie[((ucs4 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|")>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_SHIFT
argument_list|)
operator|+
literal|") + 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
argument_list|,
literal|16
argument_list|)
operator|+
literal|"]"
literal|" + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")]))\n\n"
literal|"#define GET_PROP_INDEX_UCS2(ucs2) \\\n"
literal|"       (uc_property_trie[uc_property_trie[ucs2>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_SHIFT
argument_list|)
operator|+
literal|"] + (ucs2& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")])\n\n"
expr_stmt|;
name|out
operator|+=
literal|"static const Properties uc_properties[] = {"
expr_stmt|;
comment|// keep in sync with the property declaration
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uniqueProperties
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|PropertyFlags
modifier|&
name|p
init|=
name|uniqueProperties
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|out
operator|+=
literal|"\n    { "
expr_stmt|;
comment|//     "        ushort category            : 8; /* 5 used */\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|category
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort direction           : 8; /* 5 used */\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|direction
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort combiningClass      : 8;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|combiningClass
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort joining             : 2;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|joining
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        signed short digitValue    : 6; /* 5 used */\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|digitValue
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        signed short mirrorDiff    : 16;\n"
comment|//     "        signed short lowerCaseDiff : 16;\n"
comment|//     "        signed short upperCaseDiff : 16;\n"
comment|//     "        signed short titleCaseDiff : 16;\n"
comment|//     "        signed short caseFoldDiff  : 16;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|mirrorDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|lowerCaseDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|upperCaseDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|titleCaseDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|caseFoldDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort lowerCaseSpecial    : 1;\n"
comment|//     "        ushort upperCaseSpecial    : 1;\n"
comment|//     "        ushort titleCaseSpecial    : 1;\n"
comment|//     "        ushort caseFoldSpecial     : 1;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|lowerCaseSpecial
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|upperCaseSpecial
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|titleCaseSpecial
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|caseFoldSpecial
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort unicodeVersion      : 4;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|age
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort graphemeBreakClass  : 8; /* 4 used */\n"
comment|//     "        ushort wordBreakClass      : 8; /* 4 used */\n"
comment|//     "        ushort sentenceBreakClass  : 8; /* 4 used */\n"
comment|//     "        ushort lineBreakClass      : 8; /* 6 used */\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|graphemeBreakClass
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|wordBreakClass
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|sentenceBreakClass
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|lineBreakClass
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort script              : 8; /* 7 used */\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|script
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|" },"
expr_stmt|;
block|}
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
name|out
operator|+=
literal|"static inline const Properties *qGetProp(uint ucs4)\n"
literal|"{\n"
literal|"    const int index = GET_PROP_INDEX(ucs4);\n"
literal|"    return uc_properties + index;\n"
literal|"}\n"
literal|"\n"
literal|"static inline const Properties *qGetProp(ushort ucs2)\n"
literal|"{\n"
literal|"    const int index = GET_PROP_INDEX_UCS2(ucs2);\n"
literal|"    return uc_properties + index;\n"
literal|"}\n"
literal|"\n"
literal|"Q_CORE_EXPORT const Properties * QT_FASTCALL properties(uint ucs4)\n"
literal|"{\n"
literal|"    return qGetProp(ucs4);\n"
literal|"}\n"
literal|"\n"
literal|"Q_CORE_EXPORT const Properties * QT_FASTCALL properties(ushort ucs2)\n"
literal|"{\n"
literal|"    return qGetProp(ucs2);\n"
literal|"}\n\n"
expr_stmt|;
name|out
operator|+=
literal|"Q_CORE_EXPORT GraphemeBreakClass QT_FASTCALL graphemeBreakClass(uint ucs4)\n"
literal|"{\n"
literal|"    return (GraphemeBreakClass)qGetProp(ucs4)->graphemeBreakClass;\n"
literal|"}\n"
literal|"\n"
literal|"Q_CORE_EXPORT WordBreakClass QT_FASTCALL wordBreakClass(uint ucs4)\n"
literal|"{\n"
literal|"    return (WordBreakClass)qGetProp(ucs4)->wordBreakClass;\n"
literal|"}\n"
literal|"\n"
literal|"Q_CORE_EXPORT SentenceBreakClass QT_FASTCALL sentenceBreakClass(uint ucs4)\n"
literal|"{\n"
literal|"    return (SentenceBreakClass)qGetProp(ucs4)->sentenceBreakClass;\n"
literal|"}\n"
literal|"\n"
literal|"Q_CORE_EXPORT LineBreakClass QT_FASTCALL lineBreakClass(uint ucs4)\n"
literal|"{\n"
literal|"    return (LineBreakClass)qGetProp(ucs4)->lineBreakClass;\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|createSpecialCaseMap
specifier|static
name|QByteArray
name|createSpecialCaseMap
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"createSpecialCaseMap:"
argument_list|)
expr_stmt|;
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"static const ushort specialCaseMap[] = {\n"
literal|"    0x0, // placeholder"
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|specialCaseMap
operator|.
name|size
argument_list|()
condition|)
block|{
name|out
operator|+=
literal|"\n   "
expr_stmt|;
name|int
name|n
init|=
name|specialCaseMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
operator|++
name|j
control|)
block|{
name|out
operator|+=
name|QByteArray
argument_list|(
literal|" 0x"
argument_list|)
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|specialCaseMap
operator|.
name|at
argument_list|(
name|i
operator|+
name|j
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|","
expr_stmt|;
block|}
name|i
operator|+=
name|n
operator|+
literal|1
expr_stmt|;
block|}
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
name|qDebug
argument_list|(
literal|"    memory usage: %d bytes"
argument_list|,
name|specialCaseMap
operator|.
name|size
argument_list|()
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|createCompositionInfo
specifier|static
name|QByteArray
name|createCompositionInfo
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"createCompositionInfo: highestComposedCharacter=0x%x"
argument_list|,
name|highestComposedCharacter
argument_list|)
expr_stmt|;
specifier|const
name|int
name|BMP_BLOCKSIZE
init|=
literal|16
decl_stmt|;
specifier|const
name|int
name|BMP_SHIFT
init|=
literal|4
decl_stmt|;
specifier|const
name|int
name|BMP_END
init|=
literal|0x3400
decl_stmt|;
comment|// start of Han
specifier|const
name|int
name|SMP_END
init|=
literal|0x30000
decl_stmt|;
specifier|const
name|int
name|SMP_BLOCKSIZE
init|=
literal|256
decl_stmt|;
specifier|const
name|int
name|SMP_SHIFT
init|=
literal|8
decl_stmt|;
if|if
condition|(
name|SMP_END
operator|<=
name|highestComposedCharacter
condition|)
name|qFatal
argument_list|(
literal|"end of table smaller than highest composed character 0x%x"
argument_list|,
name|highestComposedCharacter
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|unsigned
name|short
argument_list|>
name|decompositions
decl_stmt|;
name|int
name|tableIndex
init|=
literal|0
decl_stmt|;
name|QList
argument_list|<
name|UniqueBlock
argument_list|>
name|uniqueBlocks
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
name|blockMap
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
literal|0
init|;
name|block
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|UniqueBlock
name|b
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|reserve
argument_list|(
name|BMP_BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|BMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|decomposition
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|utf16Length
init|=
literal|0
decl_stmt|;
name|decompositions
operator|.
name|append
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|.
name|decomposition
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|int
name|code
init|=
name|d
operator|.
name|decomposition
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|// save as surrogate pair
name|decompositions
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|decompositions
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|utf16Length
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|decompositions
operator|.
name|append
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|utf16Length
operator|++
expr_stmt|;
block|}
block|}
name|decompositions
index|[
name|tableIndex
index|]
operator|=
name|d
operator|.
name|decompositionType
operator|+
operator|(
name|utf16Length
operator|<<
literal|8
operator|)
expr_stmt|;
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
name|tableIndex
argument_list|)
expr_stmt|;
name|tableIndex
operator|+=
name|utf16Length
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|index
init|=
name|uniqueBlocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|BMP_BLOCKSIZE
expr_stmt|;
name|uniqueBlocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|bmp_blocks
init|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
name|BMP_END
operator|/
name|SMP_BLOCKSIZE
init|;
name|block
operator|<
name|SMP_END
operator|/
name|SMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|UniqueBlock
name|b
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|reserve
argument_list|(
name|SMP_BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|SMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|decomposition
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|utf16Length
init|=
literal|0
decl_stmt|;
name|decompositions
operator|.
name|append
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|.
name|decomposition
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|int
name|code
init|=
name|d
operator|.
name|decomposition
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|// save as surrogate pair
name|decompositions
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|decompositions
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|utf16Length
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|decompositions
operator|.
name|append
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|utf16Length
operator|++
expr_stmt|;
block|}
block|}
name|decompositions
index|[
name|tableIndex
index|]
operator|=
name|d
operator|.
name|decompositionType
operator|+
operator|(
name|utf16Length
operator|<<
literal|8
operator|)
expr_stmt|;
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
name|tableIndex
argument_list|)
expr_stmt|;
name|tableIndex
operator|+=
name|utf16Length
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|index
init|=
name|uniqueBlocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|SMP_BLOCKSIZE
expr_stmt|;
name|uniqueBlocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|smp_blocks
init|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
operator|-
name|bmp_blocks
decl_stmt|;
comment|// if the condition below doesn't hold anymore we need to modify our decomposition code
name|Q_ASSERT
argument_list|(
name|tableIndex
operator|<
literal|0xffff
argument_list|)
expr_stmt|;
name|int
name|bmp_block_data
init|=
name|bmp_blocks
operator|*
name|BMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|bmp_trie
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|bmp_mem
init|=
name|bmp_block_data
operator|+
name|bmp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in BMP."
argument_list|,
name|bmp_blocks
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|bmp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|bmp_trie
argument_list|)
expr_stmt|;
name|int
name|smp_block_data
init|=
name|smp_blocks
operator|*
name|SMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|smp_trie
init|=
operator|(
name|SMP_END
operator|-
name|BMP_END
operator|)
operator|/
name|SMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|smp_mem
init|=
name|smp_block_data
operator|+
name|smp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in SMP."
argument_list|,
name|smp_blocks
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|smp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|smp_trie
argument_list|)
expr_stmt|;
name|int
name|decomposition_data
init|=
name|decompositions
operator|.
name|size
argument_list|()
operator|*
literal|2
decl_stmt|;
name|qDebug
argument_list|(
literal|"\n        decomposition data uses : %d bytes"
argument_list|,
name|decomposition_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"    memory usage: %d bytes"
argument_list|,
name|bmp_mem
operator|+
name|smp_mem
operator|+
name|decomposition_data
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|blockMap
operator|.
name|last
argument_list|()
operator|+
name|blockMap
operator|.
name|size
argument_list|()
operator|<
operator|(
literal|1
operator|<<
operator|(
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
operator|*
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"static const unsigned short uc_decomposition_trie[] = {\n"
expr_stmt|;
comment|// first write the map
name|out
operator|+=
literal|"    // 0 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|i
operator|*
name|BMP_BLOCKSIZE
operator|)
operator|%
literal|0x1000
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n\n    // 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|"\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
init|;
name|i
operator|<
name|blockMap
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
operator|(
literal|0x10000
operator|/
name|SMP_BLOCKSIZE
operator|)
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
comment|// write the data
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uniqueBlocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
specifier|const
name|UniqueBlock
modifier|&
name|b
init|=
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|b
operator|.
name|values
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|j
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
literal|"0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|b
operator|.
name|values
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
name|out
operator|+=
literal|"#define GET_DECOMPOSITION_INDEX(ucs4) \\\n"
literal|"       (ucs4< 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" \\\n"
literal|"        ? (uc_decomposition_trie[uc_decomposition_trie[ucs4>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_SHIFT
argument_list|)
operator|+
literal|"] + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")]) \\\n"
literal|"        : (ucs4< 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|"\\\n"
literal|"           ? uc_decomposition_trie[uc_decomposition_trie[((ucs4 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|")>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_SHIFT
argument_list|)
operator|+
literal|") + 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
argument_list|,
literal|16
argument_list|)
operator|+
literal|"]"
literal|" + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")]\\\n"
literal|"           : 0xffff))\n\n"
expr_stmt|;
name|out
operator|+=
literal|"static const unsigned short uc_decomposition_map[] = {"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|decompositions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
literal|"0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|decompositions
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|createLigatureInfo
specifier|static
name|QByteArray
name|createLigatureInfo
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"createLigatureInfo: numLigatures=%d, highestLigature=0x%x"
argument_list|,
name|numLigatures
argument_list|,
name|highestLigature
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ligatureHashes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QList
argument_list|<
name|Ligature
argument_list|>
modifier|&
name|l
init|=
name|ligatureHashes
operator|.
name|value
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
comment|// if the condition below doesn't hold anymore we need to modify our ligatureHelper code
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|u2
argument_list|)
operator|==
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|ligature
argument_list|)
operator|&&
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|u2
argument_list|)
operator|==
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|u1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|const
name|int
name|BMP_BLOCKSIZE
init|=
literal|32
decl_stmt|;
specifier|const
name|int
name|BMP_SHIFT
init|=
literal|5
decl_stmt|;
specifier|const
name|int
name|BMP_END
init|=
literal|0x3100
decl_stmt|;
specifier|const
name|int
name|SMP_END
init|=
literal|0x12000
decl_stmt|;
specifier|const
name|int
name|SMP_BLOCKSIZE
init|=
literal|256
decl_stmt|;
specifier|const
name|int
name|SMP_SHIFT
init|=
literal|8
decl_stmt|;
if|if
condition|(
name|SMP_END
operator|<=
name|highestLigature
condition|)
name|qFatal
argument_list|(
literal|"end of table smaller than highest ligature character 0x%x"
argument_list|,
name|highestLigature
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|unsigned
name|short
argument_list|>
name|ligatures
decl_stmt|;
name|int
name|tableIndex
init|=
literal|0
decl_stmt|;
name|QList
argument_list|<
name|UniqueBlock
argument_list|>
name|uniqueBlocks
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
name|blockMap
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
literal|0
init|;
name|block
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|UniqueBlock
name|b
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|reserve
argument_list|(
name|BMP_BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|BMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|QList
argument_list|<
name|Ligature
argument_list|>
name|l
init|=
name|ligatureHashes
operator|.
name|value
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|l
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|uc
argument_list|)
argument_list|)
expr_stmt|;
name|qSort
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|// needed for bsearch in ligatureHelper code
name|ligatures
operator|.
name|append
argument_list|(
name|l
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|ligatures
operator|.
name|append
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|u1
argument_list|)
expr_stmt|;
name|ligatures
operator|.
name|append
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|ligature
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
name|tableIndex
argument_list|)
expr_stmt|;
name|tableIndex
operator|+=
literal|2
operator|*
name|l
operator|.
name|size
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|index
init|=
name|uniqueBlocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|BMP_BLOCKSIZE
expr_stmt|;
name|uniqueBlocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|bmp_blocks
init|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
name|BMP_END
operator|/
name|SMP_BLOCKSIZE
init|;
name|block
operator|<
name|SMP_END
operator|/
name|SMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|UniqueBlock
name|b
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|reserve
argument_list|(
name|SMP_BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|SMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|QList
argument_list|<
name|Ligature
argument_list|>
name|l
init|=
name|ligatureHashes
operator|.
name|value
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|l
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|uc
argument_list|)
argument_list|)
expr_stmt|;
name|qSort
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|// needed for bsearch in ligatureHelper code
name|ligatures
operator|.
name|append
argument_list|(
name|l
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|ligatures
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|u1
argument_list|)
argument_list|)
expr_stmt|;
name|ligatures
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|u1
argument_list|)
argument_list|)
expr_stmt|;
name|ligatures
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|ligature
argument_list|)
argument_list|)
expr_stmt|;
name|ligatures
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|ligature
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
name|tableIndex
argument_list|)
expr_stmt|;
name|tableIndex
operator|+=
literal|4
operator|*
name|l
operator|.
name|size
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|index
init|=
name|uniqueBlocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|SMP_BLOCKSIZE
expr_stmt|;
name|uniqueBlocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|smp_blocks
init|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
operator|-
name|bmp_blocks
decl_stmt|;
comment|// if the condition below doesn't hold anymore we need to modify our composition code
name|Q_ASSERT
argument_list|(
name|tableIndex
operator|<
literal|0xffff
argument_list|)
expr_stmt|;
name|int
name|bmp_block_data
init|=
name|bmp_blocks
operator|*
name|BMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|bmp_trie
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|bmp_mem
init|=
name|bmp_block_data
operator|+
name|bmp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in BMP."
argument_list|,
name|bmp_blocks
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|bmp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|bmp_trie
argument_list|)
expr_stmt|;
name|int
name|smp_block_data
init|=
name|smp_blocks
operator|*
name|SMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|smp_trie
init|=
operator|(
name|SMP_END
operator|-
name|BMP_END
operator|)
operator|/
name|SMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|smp_mem
init|=
name|smp_block_data
operator|+
name|smp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in SMP."
argument_list|,
name|smp_blocks
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|smp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|smp_trie
argument_list|)
expr_stmt|;
name|int
name|ligature_data
init|=
name|ligatures
operator|.
name|size
argument_list|()
operator|*
literal|2
decl_stmt|;
name|qDebug
argument_list|(
literal|"\n        ligature data uses : %d bytes"
argument_list|,
name|ligature_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"    memory usage: %d bytes"
argument_list|,
name|bmp_mem
operator|+
name|smp_mem
operator|+
name|ligature_data
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|blockMap
operator|.
name|last
argument_list|()
operator|+
name|blockMap
operator|.
name|size
argument_list|()
operator|<
operator|(
literal|1
operator|<<
operator|(
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
operator|*
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"static const unsigned short uc_ligature_trie[] = {\n"
expr_stmt|;
comment|// first write the map
name|out
operator|+=
literal|"    // 0 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|i
operator|*
name|BMP_BLOCKSIZE
operator|)
operator|%
literal|0x1000
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n\n    // 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|"\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
init|;
name|i
operator|<
name|blockMap
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
operator|(
literal|0x10000
operator|/
name|SMP_BLOCKSIZE
operator|)
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
comment|// write the data
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uniqueBlocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
specifier|const
name|UniqueBlock
modifier|&
name|b
init|=
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|b
operator|.
name|values
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|j
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
literal|"0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|b
operator|.
name|values
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
name|out
operator|+=
literal|"#define GET_LIGATURE_INDEX(ucs4) \\\n"
literal|"       (ucs4< 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" \\\n"
literal|"        ? (uc_ligature_trie[uc_ligature_trie[ucs4>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_SHIFT
argument_list|)
operator|+
literal|"] + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")]) \\\n"
literal|"        : (ucs4< 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|"\\\n"
literal|"           ? uc_ligature_trie[uc_ligature_trie[((ucs4 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|")>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_SHIFT
argument_list|)
operator|+
literal|") + 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
argument_list|,
literal|16
argument_list|)
operator|+
literal|"]"
literal|" + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")]\\\n"
literal|"           : 0xffff))\n\n"
expr_stmt|;
name|out
operator|+=
literal|"static const unsigned short uc_ligature_map[] = {"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ligatures
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
literal|"0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|ligatures
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|createCasingInfo
name|QByteArray
name|createCasingInfo
parameter_list|()
block|{
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"struct CasingInfo {\n"
literal|"    uint codePoint : 16;\n"
literal|"    uint flags : 8;\n"
literal|"    uint offset : 8;\n"
literal|"};\n\n"
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
block|{
name|initAgeMap
argument_list|()
expr_stmt|;
name|initCategoryMap
argument_list|()
expr_stmt|;
name|initDecompositionMap
argument_list|()
expr_stmt|;
name|initDirectionMap
argument_list|()
expr_stmt|;
name|initJoiningMap
argument_list|()
expr_stmt|;
name|initGraphemeBreak
argument_list|()
expr_stmt|;
name|initWordBreak
argument_list|()
expr_stmt|;
name|initSentenceBreak
argument_list|()
expr_stmt|;
name|initLineBreak
argument_list|()
expr_stmt|;
name|initScriptMap
argument_list|()
expr_stmt|;
name|readUnicodeData
argument_list|()
expr_stmt|;
name|readBidiMirroring
argument_list|()
expr_stmt|;
name|readArabicShaping
argument_list|()
expr_stmt|;
name|readDerivedAge
argument_list|()
expr_stmt|;
name|readDerivedNormalizationProps
argument_list|()
expr_stmt|;
name|readSpecialCasing
argument_list|()
expr_stmt|;
name|readCaseFolding
argument_list|()
expr_stmt|;
comment|// readBlocks();
name|readScripts
argument_list|()
expr_stmt|;
name|readGraphemeBreak
argument_list|()
expr_stmt|;
name|readWordBreak
argument_list|()
expr_stmt|;
name|readSentenceBreak
argument_list|()
expr_stmt|;
name|readLineBreak
argument_list|()
expr_stmt|;
name|computeUniqueProperties
argument_list|()
expr_stmt|;
name|QByteArray
name|properties
init|=
name|createPropertyInfo
argument_list|()
decl_stmt|;
name|QByteArray
name|specialCases
init|=
name|createSpecialCaseMap
argument_list|()
decl_stmt|;
name|QByteArray
name|compositions
init|=
name|createCompositionInfo
argument_list|()
decl_stmt|;
name|QByteArray
name|ligatures
init|=
name|createLigatureInfo
argument_list|()
decl_stmt|;
name|QByteArray
name|normalizationCorrections
init|=
name|createNormalizationCorrections
argument_list|()
decl_stmt|;
name|QByteArray
name|header
init|=
literal|"/****************************************************************************\n"
literal|"**\n"
literal|"** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).\n"
literal|"** Contact: http://www.qt-project.org/legal\n"
literal|"**\n"
literal|"** This file is part of the QtCore module of the Qt Toolkit.\n"
literal|"**\n"
literal|"** $QT_BEGIN_LICENSE:LGPL$\n"
literal|"** Commercial License Usage\n"
literal|"** Licensees holding valid commercial Qt licenses may use this file in\n"
literal|"** accordance with the commercial license agreement provided with the\n"
literal|"** Software or, alternatively, in accordance with the terms contained in\n"
literal|"** a written agreement between you and Digia.  For licensing terms and\n"
literal|"** conditions see http://qt.digia.com/licensing.  For further information\n"
literal|"** use the contact form at http://qt.digia.com/contact-us.\n"
literal|"**\n"
literal|"** GNU Lesser General Public License Usage\n"
literal|"** Alternatively, this file may be used under the terms of the GNU Lesser\n"
literal|"** General Public License version 2.1 as published by the Free Software\n"
literal|"** Foundation and appearing in the file LICENSE.LGPL included in the\n"
literal|"** packaging of this file.  Please review the following information to\n"
literal|"** ensure the GNU Lesser General Public License version 2.1 requirements\n"
literal|"** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.\n"
literal|"**\n"
literal|"** In addition, as a special exception, Digia gives you certain additional\n"
literal|"** rights.  These rights are described in the Digia Qt LGPL Exception\n"
literal|"** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.\n"
literal|"**\n"
literal|"** GNU General Public License Usage\n"
literal|"** Alternatively, this file may be used under the terms of the GNU\n"
literal|"** General Public License version 3.0 as published by the Free Software\n"
literal|"** Foundation and appearing in the file LICENSE.GPL included in the\n"
literal|"** packaging of this file.  Please review the following information to\n"
literal|"** ensure the GNU General Public License version 3.0 requirements will be\n"
literal|"** met: http://www.gnu.org/copyleft/gpl.html.\n"
literal|"**\n"
literal|"**\n"
literal|"** $QT_END_LICENSE$\n"
literal|"**\n"
literal|"****************************************************************************/\n\n"
decl_stmt|;
name|QByteArray
name|note
init|=
literal|"/* This file is autogenerated from the Unicode "
name|DATA_VERSION_S
literal|" database. Do not edit */\n\n"
decl_stmt|;
name|QByteArray
name|warning
init|=
literal|"//\n"
literal|"//  W A R N I N G\n"
literal|"//  -------------\n"
literal|"//\n"
literal|"// This file is not part of the Qt API.  It exists for the convenience\n"
literal|"// of internal files.  This header file may change from version to version\n"
literal|"// without notice, or even be removed.\n"
literal|"//\n"
literal|"// We mean it.\n"
literal|"//\n\n"
decl_stmt|;
name|QFile
name|f
argument_list|(
literal|"../../src/corelib/tools/qunicodetables.cpp"
argument_list|)
decl_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
operator||
name|QFile
operator|::
name|Truncate
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"#include \"qunicodetables_p.h\"\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"QT_BEGIN_NAMESPACE\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"namespace QUnicodeTables {\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|properties
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|specialCases
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|compositions
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|ligatures
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|normalizationCorrections
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"} // namespace QUnicodeTables\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"using namespace QUnicodeTables;\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"QT_END_NAMESPACE\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|close
argument_list|()
expr_stmt|;
name|f
operator|.
name|setFileName
argument_list|(
literal|"../../src/corelib/tools/qunicodetables_p.h"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
operator||
name|QFile
operator|::
name|Truncate
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|warning
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"#ifndef QUNICODETABLES_P_H\n"
literal|"#define QUNICODETABLES_P_H\n\n"
literal|"#include<QtCore/qchar.h>\n\n"
literal|"QT_BEGIN_NAMESPACE\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"#define UNICODE_DATA_VERSION "
name|DATA_VERSION_STR
literal|"\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"namespace QUnicodeTables {\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|property_string
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|grapheme_break_class_string
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|word_break_class_string
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|sentence_break_class_string
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|line_break_class_string
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|methods
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"} // namespace QUnicodeTables\n\n"
literal|"QT_END_NAMESPACE\n\n"
literal|"#endif // QUNICODETABLES_P_H\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|close
argument_list|()
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxMirroredDiff  = "
operator|<<
name|hex
operator|<<
name|maxMirroredDiff
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxLowerCaseDiff = "
operator|<<
name|hex
operator|<<
name|maxLowerCaseDiff
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxUpperCaseDiff = "
operator|<<
name|hex
operator|<<
name|maxUpperCaseDiff
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxTitleCaseDiff = "
operator|<<
name|hex
operator|<<
name|maxTitleCaseDiff
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxCaseFoldDiff  = "
operator|<<
name|hex
operator|<<
name|maxCaseFoldDiff
expr_stmt|;
if|#
directive|if
literal|0
comment|//     dump(0, 0x7f);
comment|//     dump(0x620, 0x640);
comment|//     dump(0x10000, 0x10020);
comment|//     dump(0x10800, 0x10820);
block|qDebug("decompositionLength used:");     int totalcompositions = 0;     int sum = 0;     for (int i = 1; i< 20; ++i) {         qDebug("    length %d used %d times", i, decompositionLength.value(i, 0));         totalcompositions += i*decompositionLength.value(i, 0);         sum += decompositionLength.value(i, 0);     }     qDebug("    len decomposition map %d, average length %f, num composed chars %d",            totalcompositions, (float)totalcompositions/(float)sum, sum);     qDebug("highest composed character %x", highestComposedCharacter);     qDebug("num ligatures = %d highest=%x, maxLength=%d", numLigatures, highestLigature, longestLigature);      qBubbleSort(ligatures);     for (int i = 0; i< ligatures.size(); ++i)         qDebug("%s", ligatures.at(i).data());
comment|//     qDebug("combiningClass usage:");
comment|//     int numClasses = 0;
comment|//     for (int i = 0; i< 255; ++i) {
comment|//         int num = combiningClassUsage.value(i, 0);
comment|//         if (num) {
comment|//             ++numClasses;
comment|//             qDebug("    combiningClass %d used %d times", i, num);
comment|//         }
comment|//     }
comment|//     qDebug("total of %d combining classes used", numClasses);
endif|#
directive|endif
block|}
end_function
end_unit
