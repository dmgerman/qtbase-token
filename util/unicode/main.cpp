begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the utils of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qlist.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qbytearray.h>
end_include
begin_include
include|#
directive|include
file|<qstring.h>
end_include
begin_include
include|#
directive|include
file|<qchar.h>
end_include
begin_include
include|#
directive|include
file|<qvector.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_if
if|#
directive|if
literal|0
end_if
begin_include
include|#
directive|include
file|<private/qunicodetables_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|DATA_VERSION_S
define|#
directive|define
name|DATA_VERSION_S
value|"5.0"
end_define
begin_define
DECL|macro|DATA_VERSION_STR
define|#
directive|define
name|DATA_VERSION_STR
value|"QChar::Unicode_5_0"
end_define
begin_define
DECL|macro|LAST_CODEPOINT
define|#
directive|define
name|LAST_CODEPOINT
value|0x10ffff
end_define
begin_define
DECL|macro|LAST_CODEPOINT_STR
define|#
directive|define
name|LAST_CODEPOINT_STR
value|"0x10ffff"
end_define
begin_decl_stmt
DECL|variable|age_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QChar
operator|::
name|UnicodeVersion
argument_list|>
name|age_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initAgeMap
specifier|static
name|void
name|initAgeMap
parameter_list|()
block|{
struct|struct
name|AgeMap
block|{
specifier|const
name|QChar
operator|::
name|UnicodeVersion
name|version
decl_stmt|;
specifier|const
name|char
modifier|*
name|age
decl_stmt|;
block|}
name|ageMap
index|[]
init|=
block|{
block|{
name|QChar
operator|::
name|Unicode_1_1
block|,
literal|"1.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_2_0
block|,
literal|"2.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_2_1_2
block|,
literal|"2.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_3_0
block|,
literal|"3.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_3_1
block|,
literal|"3.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_3_2
block|,
literal|"3.2"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_4_0
block|,
literal|"4.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_4_1
block|,
literal|"4.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_5_0
block|,
literal|"5.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|AgeMap
modifier|*
name|d
init|=
name|ageMap
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|age
condition|)
block|{
name|age_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|age
argument_list|,
name|d
operator|->
name|version
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_enum
DECL|enum|Joining
enum|enum
name|Joining
block|{
DECL|enumerator|Joining_None
name|Joining_None
block|,
DECL|enumerator|Joining_Left
name|Joining_Left
block|,
DECL|enumerator|Joining_Causing
name|Joining_Causing
block|,
DECL|enumerator|Joining_Dual
name|Joining_Dual
block|,
DECL|enumerator|Joining_Right
name|Joining_Right
block|,
DECL|enumerator|Joining_Transparent
name|Joining_Transparent
block|,
DECL|enumerator|Joining_Unassigned
name|Joining_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|joining_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|Joining
argument_list|>
name|joining_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initJoiningMap
specifier|static
name|void
name|initJoiningMap
parameter_list|()
block|{
struct|struct
name|JoiningList
block|{
name|Joining
name|joining
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|joinings
index|[]
init|=
block|{
block|{
name|Joining_None
block|,
literal|"U"
block|}
block|,
block|{
name|Joining_Left
block|,
literal|"L"
block|}
block|,
block|{
name|Joining_Causing
block|,
literal|"C"
block|}
block|,
block|{
name|Joining_Dual
block|,
literal|"D"
block|}
block|,
block|{
name|Joining_Right
block|,
literal|"R"
block|}
block|,
block|{
name|Joining_Transparent
block|,
literal|"T"
block|}
block|,
block|{
name|Joining_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|JoiningList
modifier|*
name|d
init|=
name|joinings
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|joining_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|joining
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|grapheme_break_string
specifier|static
specifier|const
name|char
modifier|*
name|grapheme_break_string
init|=
literal|"    enum GraphemeBreak {\n"
literal|"        GraphemeBreakOther,\n"
literal|"        GraphemeBreakCR,\n"
literal|"        GraphemeBreakLF,\n"
literal|"        GraphemeBreakControl,\n"
literal|"        GraphemeBreakExtend,\n"
literal|"        GraphemeBreakL,\n"
literal|"        GraphemeBreakV,\n"
literal|"        GraphemeBreakT,\n"
literal|"        GraphemeBreakLV,\n"
literal|"        GraphemeBreakLVT\n"
literal|"    };\n\n"
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|GraphemeBreak
enum|enum
name|GraphemeBreak
block|{
DECL|enumerator|GraphemeBreakOther
name|GraphemeBreakOther
block|,
DECL|enumerator|GraphemeBreakCR
name|GraphemeBreakCR
block|,
DECL|enumerator|GraphemeBreakLF
name|GraphemeBreakLF
block|,
DECL|enumerator|GraphemeBreakControl
name|GraphemeBreakControl
block|,
DECL|enumerator|GraphemeBreakExtend
name|GraphemeBreakExtend
block|,
DECL|enumerator|GraphemeBreakL
name|GraphemeBreakL
block|,
DECL|enumerator|GraphemeBreakV
name|GraphemeBreakV
block|,
DECL|enumerator|GraphemeBreakT
name|GraphemeBreakT
block|,
DECL|enumerator|GraphemeBreakLV
name|GraphemeBreakLV
block|,
DECL|enumerator|GraphemeBreakLVT
name|GraphemeBreakLVT
block|,
DECL|enumerator|GraphemeBreak_Unassigned
name|GraphemeBreak_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|grapheme_break_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|GraphemeBreak
argument_list|>
name|grapheme_break_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initGraphemeBreak
specifier|static
name|void
name|initGraphemeBreak
parameter_list|()
block|{
struct|struct
name|GraphemeBreakList
block|{
name|GraphemeBreak
name|brk
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|breaks
index|[]
init|=
block|{
block|{
name|GraphemeBreakOther
block|,
literal|"Other"
block|}
block|,
block|{
name|GraphemeBreakCR
block|,
literal|"CR"
block|}
block|,
block|{
name|GraphemeBreakLF
block|,
literal|"LF"
block|}
block|,
block|{
name|GraphemeBreakControl
block|,
literal|"Control"
block|}
block|,
block|{
name|GraphemeBreakExtend
block|,
literal|"Extend"
block|}
block|,
block|{
name|GraphemeBreakL
block|,
literal|"L"
block|}
block|,
block|{
name|GraphemeBreakV
block|,
literal|"V"
block|}
block|,
block|{
name|GraphemeBreakT
block|,
literal|"T"
block|}
block|,
block|{
name|GraphemeBreakLV
block|,
literal|"LV"
block|}
block|,
block|{
name|GraphemeBreakLVT
block|,
literal|"LVT"
block|}
block|,
block|{
name|GraphemeBreak_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|GraphemeBreakList
modifier|*
name|d
init|=
name|breaks
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|grapheme_break_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|brk
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|word_break_string
specifier|static
specifier|const
name|char
modifier|*
name|word_break_string
init|=
literal|"    enum WordBreak {\n"
literal|"        WordBreakOther,\n"
literal|"        WordBreakFormat,\n"
literal|"        WordBreakKatakana,\n"
literal|"        WordBreakALetter,\n"
literal|"        WordBreakMidLetter,\n"
literal|"        WordBreakMidNum,\n"
literal|"        WordBreakNumeric,\n"
literal|"        WordBreakExtendNumLet\n"
literal|"    };\n\n"
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|WordBreak
enum|enum
name|WordBreak
block|{
DECL|enumerator|WordBreakOther
name|WordBreakOther
block|,
DECL|enumerator|WordBreakFormat
name|WordBreakFormat
block|,
DECL|enumerator|WordBreakKatakana
name|WordBreakKatakana
block|,
DECL|enumerator|WordBreakALetter
name|WordBreakALetter
block|,
DECL|enumerator|WordBreakMidLetter
name|WordBreakMidLetter
block|,
DECL|enumerator|WordBreakMidNum
name|WordBreakMidNum
block|,
DECL|enumerator|WordBreakNumeric
name|WordBreakNumeric
block|,
DECL|enumerator|WordBreakExtendNumLet
name|WordBreakExtendNumLet
block|,
DECL|enumerator|WordBreak_Unassigned
name|WordBreak_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|word_break_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|WordBreak
argument_list|>
name|word_break_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initWordBreak
specifier|static
name|void
name|initWordBreak
parameter_list|()
block|{
struct|struct
name|WordBreakList
block|{
name|WordBreak
name|brk
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|breaks
index|[]
init|=
block|{
block|{
name|WordBreakFormat
block|,
literal|"Format"
block|}
block|,
block|{
name|WordBreakFormat
block|,
literal|"Extend"
block|}
block|,
comment|// these are copied in from GraphemeBreakProperty.txt
block|{
name|WordBreakKatakana
block|,
literal|"Katakana"
block|}
block|,
block|{
name|WordBreakALetter
block|,
literal|"ALetter"
block|}
block|,
block|{
name|WordBreakMidLetter
block|,
literal|"MidLetter"
block|}
block|,
block|{
name|WordBreakMidNum
block|,
literal|"MidNum"
block|}
block|,
block|{
name|WordBreakNumeric
block|,
literal|"Numeric"
block|}
block|,
block|{
name|WordBreakExtendNumLet
block|,
literal|"ExtendNumLet"
block|}
block|,
block|{
name|WordBreak_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|WordBreakList
modifier|*
name|d
init|=
name|breaks
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|word_break_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|brk
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|sentence_break_string
specifier|static
specifier|const
name|char
modifier|*
name|sentence_break_string
init|=
literal|"    enum SentenceBreak {\n"
literal|"        SentenceBreakOther,\n"
literal|"        SentenceBreakSep,\n"
literal|"        SentenceBreakFormat,\n"
literal|"        SentenceBreakSp,\n"
literal|"        SentenceBreakLower,\n"
literal|"        SentenceBreakUpper,\n"
literal|"        SentenceBreakOLetter,\n"
literal|"        SentenceBreakNumeric,\n"
literal|"        SentenceBreakATerm,\n"
literal|"        SentenceBreakSTerm,\n"
literal|"        SentenceBreakClose\n"
literal|"    };\n\n"
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|SentenceBreak
enum|enum
name|SentenceBreak
block|{
DECL|enumerator|SentenceBreakOther
name|SentenceBreakOther
block|,
DECL|enumerator|SentenceBreakSep
name|SentenceBreakSep
block|,
DECL|enumerator|SentenceBreakFormat
name|SentenceBreakFormat
block|,
DECL|enumerator|SentenceBreakSp
name|SentenceBreakSp
block|,
DECL|enumerator|SentenceBreakLower
name|SentenceBreakLower
block|,
DECL|enumerator|SentenceBreakUpper
name|SentenceBreakUpper
block|,
DECL|enumerator|SentenceBreakOLetter
name|SentenceBreakOLetter
block|,
DECL|enumerator|SentenceBreakNumeric
name|SentenceBreakNumeric
block|,
DECL|enumerator|SentenceBreakATerm
name|SentenceBreakATerm
block|,
DECL|enumerator|SentenceBreakSTerm
name|SentenceBreakSTerm
block|,
DECL|enumerator|SentenceBreakClose
name|SentenceBreakClose
block|,
DECL|enumerator|SentenceBreak_Unassigned
name|SentenceBreak_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|sentence_break_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|SentenceBreak
argument_list|>
name|sentence_break_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initSentenceBreak
specifier|static
name|void
name|initSentenceBreak
parameter_list|()
block|{
struct|struct
name|SentenceBreakList
block|{
name|SentenceBreak
name|brk
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|breaks
index|[]
init|=
block|{
block|{
name|SentenceBreakOther
block|,
literal|"Other"
block|}
block|,
block|{
name|SentenceBreakSep
block|,
literal|"Sep"
block|}
block|,
block|{
name|SentenceBreakFormat
block|,
literal|"Format"
block|}
block|,
block|{
name|SentenceBreakSp
block|,
literal|"Sp"
block|}
block|,
block|{
name|SentenceBreakLower
block|,
literal|"Lower"
block|}
block|,
block|{
name|SentenceBreakUpper
block|,
literal|"Upper"
block|}
block|,
block|{
name|SentenceBreakOLetter
block|,
literal|"OLetter"
block|}
block|,
block|{
name|SentenceBreakNumeric
block|,
literal|"Numeric"
block|}
block|,
block|{
name|SentenceBreakATerm
block|,
literal|"ATerm"
block|}
block|,
block|{
name|SentenceBreakSTerm
block|,
literal|"STerm"
block|}
block|,
block|{
name|SentenceBreakClose
block|,
literal|"Close"
block|}
block|,
block|{
name|SentenceBreak_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|SentenceBreakList
modifier|*
name|d
init|=
name|breaks
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|sentence_break_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|brk
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|lineBreakClass
specifier|static
specifier|const
name|char
modifier|*
name|lineBreakClass
init|=
literal|"    // see http://www.unicode.org/reports/tr14/tr14-19.html\n"
literal|"    // we don't use the XX, AI and CB properties and map them to AL instead.\n"
literal|"    // as we don't support any EBDIC based OS'es, NL is ignored and mapped to AL as well.\n"
literal|"    enum LineBreakClass {\n"
literal|"        LineBreak_OP, LineBreak_CL, LineBreak_QU, LineBreak_GL, LineBreak_NS,\n"
literal|"        LineBreak_EX, LineBreak_SY, LineBreak_IS, LineBreak_PR, LineBreak_PO,\n"
literal|"        LineBreak_NU, LineBreak_AL, LineBreak_ID, LineBreak_IN, LineBreak_HY,\n"
literal|"        LineBreak_BA, LineBreak_BB, LineBreak_B2, LineBreak_ZW, LineBreak_CM,\n"
literal|"        LineBreak_WJ, LineBreak_H2, LineBreak_H3, LineBreak_JL, LineBreak_JV,\n"
literal|"        LineBreak_JT, LineBreak_SA, LineBreak_SG,\n"
literal|"        LineBreak_SP, LineBreak_CR, LineBreak_LF, LineBreak_BK\n"
literal|"    };\n\n"
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|LineBreakClass
enum|enum
name|LineBreakClass
block|{
DECL|enumerator|LineBreak_OP
DECL|enumerator|LineBreak_CL
DECL|enumerator|LineBreak_QU
DECL|enumerator|LineBreak_GL
DECL|enumerator|LineBreak_NS
name|LineBreak_OP
block|,
name|LineBreak_CL
block|,
name|LineBreak_QU
block|,
name|LineBreak_GL
block|,
name|LineBreak_NS
block|,
DECL|enumerator|LineBreak_EX
DECL|enumerator|LineBreak_SY
DECL|enumerator|LineBreak_IS
DECL|enumerator|LineBreak_PR
DECL|enumerator|LineBreak_PO
name|LineBreak_EX
block|,
name|LineBreak_SY
block|,
name|LineBreak_IS
block|,
name|LineBreak_PR
block|,
name|LineBreak_PO
block|,
DECL|enumerator|LineBreak_NU
DECL|enumerator|LineBreak_AL
DECL|enumerator|LineBreak_ID
DECL|enumerator|LineBreak_IN
DECL|enumerator|LineBreak_HY
name|LineBreak_NU
block|,
name|LineBreak_AL
block|,
name|LineBreak_ID
block|,
name|LineBreak_IN
block|,
name|LineBreak_HY
block|,
DECL|enumerator|LineBreak_BA
DECL|enumerator|LineBreak_BB
DECL|enumerator|LineBreak_B2
DECL|enumerator|LineBreak_ZW
DECL|enumerator|LineBreak_CM
name|LineBreak_BA
block|,
name|LineBreak_BB
block|,
name|LineBreak_B2
block|,
name|LineBreak_ZW
block|,
name|LineBreak_CM
block|,
DECL|enumerator|LineBreak_WJ
DECL|enumerator|LineBreak_H2
DECL|enumerator|LineBreak_H3
DECL|enumerator|LineBreak_JL
DECL|enumerator|LineBreak_JV
name|LineBreak_WJ
block|,
name|LineBreak_H2
block|,
name|LineBreak_H3
block|,
name|LineBreak_JL
block|,
name|LineBreak_JV
block|,
DECL|enumerator|LineBreak_JT
DECL|enumerator|LineBreak_SA
DECL|enumerator|LineBreak_SG
name|LineBreak_JT
block|,
name|LineBreak_SA
block|,
name|LineBreak_SG
block|,
DECL|enumerator|LineBreak_SP
DECL|enumerator|LineBreak_CR
DECL|enumerator|LineBreak_LF
DECL|enumerator|LineBreak_BK
name|LineBreak_SP
block|,
name|LineBreak_CR
block|,
name|LineBreak_LF
block|,
name|LineBreak_BK
block|,
DECL|enumerator|LineBreak_Unassigned
name|LineBreak_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|line_break_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|LineBreakClass
argument_list|>
name|line_break_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initLineBreak
specifier|static
name|void
name|initLineBreak
parameter_list|()
block|{
comment|// ### Classes XX and AI are left out and mapped to AL for now;
comment|// ### Class NL is ignored and mapped to AL as well.
struct|struct
name|LineBreakList
block|{
name|LineBreakClass
name|brk
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|breaks
index|[]
init|=
block|{
block|{
name|LineBreak_BK
block|,
literal|"BK"
block|}
block|,
block|{
name|LineBreak_CR
block|,
literal|"CR"
block|}
block|,
block|{
name|LineBreak_LF
block|,
literal|"LF"
block|}
block|,
block|{
name|LineBreak_CM
block|,
literal|"CM"
block|}
block|,
block|{
name|LineBreak_AL
block|,
literal|"NL"
block|}
block|,
block|{
name|LineBreak_SG
block|,
literal|"SG"
block|}
block|,
block|{
name|LineBreak_WJ
block|,
literal|"WJ"
block|}
block|,
block|{
name|LineBreak_ZW
block|,
literal|"ZW"
block|}
block|,
block|{
name|LineBreak_GL
block|,
literal|"GL"
block|}
block|,
block|{
name|LineBreak_SP
block|,
literal|"SP"
block|}
block|,
block|{
name|LineBreak_B2
block|,
literal|"B2"
block|}
block|,
block|{
name|LineBreak_BA
block|,
literal|"BA"
block|}
block|,
block|{
name|LineBreak_BB
block|,
literal|"BB"
block|}
block|,
block|{
name|LineBreak_HY
block|,
literal|"HY"
block|}
block|,
block|{
name|LineBreak_AL
block|,
literal|"CB"
block|}
block|,
comment|// ###
block|{
name|LineBreak_CL
block|,
literal|"CL"
block|}
block|,
block|{
name|LineBreak_EX
block|,
literal|"EX"
block|}
block|,
block|{
name|LineBreak_IN
block|,
literal|"IN"
block|}
block|,
block|{
name|LineBreak_NS
block|,
literal|"NS"
block|}
block|,
block|{
name|LineBreak_OP
block|,
literal|"OP"
block|}
block|,
block|{
name|LineBreak_QU
block|,
literal|"QU"
block|}
block|,
block|{
name|LineBreak_IS
block|,
literal|"IS"
block|}
block|,
block|{
name|LineBreak_NU
block|,
literal|"NU"
block|}
block|,
block|{
name|LineBreak_PO
block|,
literal|"PO"
block|}
block|,
block|{
name|LineBreak_PR
block|,
literal|"PR"
block|}
block|,
block|{
name|LineBreak_SY
block|,
literal|"SY"
block|}
block|,
block|{
name|LineBreak_AL
block|,
literal|"AI"
block|}
block|,
block|{
name|LineBreak_AL
block|,
literal|"AL"
block|}
block|,
block|{
name|LineBreak_H2
block|,
literal|"H2"
block|}
block|,
block|{
name|LineBreak_H3
block|,
literal|"H3"
block|}
block|,
block|{
name|LineBreak_ID
block|,
literal|"ID"
block|}
block|,
block|{
name|LineBreak_JL
block|,
literal|"JL"
block|}
block|,
block|{
name|LineBreak_JV
block|,
literal|"JV"
block|}
block|,
block|{
name|LineBreak_JT
block|,
literal|"JT"
block|}
block|,
block|{
name|LineBreak_SA
block|,
literal|"SA"
block|}
block|,
block|{
name|LineBreak_AL
block|,
literal|"XX"
block|}
block|,
block|{
name|LineBreak_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|LineBreakList
modifier|*
name|d
init|=
name|breaks
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|line_break_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|brk
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Keep this one in sync with the code in createPropertyInfo
end_comment
begin_decl_stmt
DECL|variable|property_string
specifier|static
specifier|const
name|char
modifier|*
name|property_string
init|=
literal|"    struct Properties {\n"
literal|"        ushort category         : 8; /* 5 needed */\n"
literal|"        ushort line_break_class : 8; /* 6 needed */\n"
literal|"        ushort direction        : 8; /* 5 needed */\n"
literal|"        ushort combiningClass   : 8;\n"
literal|"        ushort joining          : 2;\n"
literal|"        signed short digitValue : 6; /* 5 needed */\n"
literal|"        ushort unicodeVersion   : 4;\n"
literal|"        ushort lowerCaseSpecial : 1;\n"
literal|"        ushort upperCaseSpecial : 1;\n"
literal|"        ushort titleCaseSpecial : 1;\n"
literal|"        ushort caseFoldSpecial  : 1; /* currently unused */\n"
literal|"        signed short mirrorDiff    : 16;\n"
literal|"        signed short lowerCaseDiff : 16;\n"
literal|"        signed short upperCaseDiff : 16;\n"
literal|"        signed short titleCaseDiff : 16;\n"
literal|"        signed short caseFoldDiff  : 16;\n"
literal|"        ushort graphemeBreak    : 8; /* 4 needed */\n"
literal|"        ushort wordBreak        : 8; /* 4 needed */\n"
literal|"        ushort sentenceBreak    : 8; /* 4 needed */\n"
literal|"    };\n"
literal|"    Q_CORE_EXPORT const Properties * QT_FASTCALL properties(uint ucs4);\n"
literal|"    Q_CORE_EXPORT const Properties * QT_FASTCALL properties(ushort ucs2);\n"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|methods
specifier|static
specifier|const
name|char
modifier|*
name|methods
init|=
literal|"    Q_CORE_EXPORT QUnicodeTables::LineBreakClass QT_FASTCALL lineBreakClass(uint ucs4);\n"
literal|"    inline int lineBreakClass(QChar ch)\n"
literal|"    { return lineBreakClass(ch.unicode()); }\n"
literal|"\n"
literal|"    Q_CORE_EXPORT int QT_FASTCALL script(uint ucs4);\n"
literal|"    inline int script(QChar ch)\n"
literal|"    { return script(ch.unicode()); }\n\n"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|SizeOfPropertiesStruct
specifier|static
specifier|const
name|int
name|SizeOfPropertiesStruct
init|=
literal|20
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|PropertyFlags
struct|struct
name|PropertyFlags
block|{
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|PropertyFlags
modifier|&
name|o
parameter_list|)
block|{
return|return
operator|(
name|combiningClass
operator|==
name|o
operator|.
name|combiningClass
operator|&&
name|category
operator|==
name|o
operator|.
name|category
operator|&&
name|direction
operator|==
name|o
operator|.
name|direction
operator|&&
name|joining
operator|==
name|o
operator|.
name|joining
operator|&&
name|age
operator|==
name|o
operator|.
name|age
operator|&&
name|digitValue
operator|==
name|o
operator|.
name|digitValue
operator|&&
name|line_break_class
operator|==
name|o
operator|.
name|line_break_class
operator|&&
name|mirrorDiff
operator|==
name|o
operator|.
name|mirrorDiff
operator|&&
name|lowerCaseDiff
operator|==
name|o
operator|.
name|lowerCaseDiff
operator|&&
name|upperCaseDiff
operator|==
name|o
operator|.
name|upperCaseDiff
operator|&&
name|titleCaseDiff
operator|==
name|o
operator|.
name|titleCaseDiff
operator|&&
name|caseFoldDiff
operator|==
name|o
operator|.
name|caseFoldDiff
operator|&&
name|lowerCaseSpecial
operator|==
name|o
operator|.
name|lowerCaseSpecial
operator|&&
name|upperCaseSpecial
operator|==
name|o
operator|.
name|upperCaseSpecial
operator|&&
name|titleCaseSpecial
operator|==
name|o
operator|.
name|titleCaseSpecial
operator|&&
name|caseFoldSpecial
operator|==
name|o
operator|.
name|caseFoldSpecial
operator|&&
name|graphemeBreak
operator|==
name|o
operator|.
name|graphemeBreak
operator|&&
name|wordBreak
operator|==
name|o
operator|.
name|wordBreak
operator|&&
name|sentenceBreak
operator|==
name|o
operator|.
name|sentenceBreak
operator|)
return|;
block|}
comment|// from UnicodeData.txt
DECL|member|combiningClass
name|uchar
name|combiningClass
range|:
literal|8
decl_stmt|;
DECL|member|category
name|QChar
operator|::
name|Category
name|category
range|:
literal|5
decl_stmt|;
DECL|member|direction
name|QChar
operator|::
name|Direction
name|direction
range|:
literal|5
decl_stmt|;
comment|// from ArabicShaping.txt
DECL|member|joining
name|QChar
operator|::
name|Joining
name|joining
range|:
literal|2
decl_stmt|;
comment|// from DerivedAge.txt
DECL|member|age
name|QChar
operator|::
name|UnicodeVersion
name|age
range|:
literal|4
decl_stmt|;
DECL|member|digitValue
name|int
name|digitValue
decl_stmt|;
DECL|member|line_break_class
name|LineBreakClass
name|line_break_class
decl_stmt|;
DECL|member|mirrorDiff
name|int
name|mirrorDiff
range|:
literal|16
decl_stmt|;
DECL|member|lowerCaseDiff
name|int
name|lowerCaseDiff
decl_stmt|;
DECL|member|upperCaseDiff
name|int
name|upperCaseDiff
decl_stmt|;
DECL|member|titleCaseDiff
name|int
name|titleCaseDiff
decl_stmt|;
DECL|member|caseFoldDiff
name|int
name|caseFoldDiff
decl_stmt|;
DECL|member|lowerCaseSpecial
name|bool
name|lowerCaseSpecial
decl_stmt|;
DECL|member|upperCaseSpecial
name|bool
name|upperCaseSpecial
decl_stmt|;
DECL|member|titleCaseSpecial
name|bool
name|titleCaseSpecial
decl_stmt|;
DECL|member|caseFoldSpecial
name|bool
name|caseFoldSpecial
decl_stmt|;
DECL|member|graphemeBreak
name|GraphemeBreak
name|graphemeBreak
decl_stmt|;
DECL|member|wordBreak
name|WordBreak
name|wordBreak
decl_stmt|;
DECL|member|sentenceBreak
name|SentenceBreak
name|sentenceBreak
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|specialCaseMap
specifier|static
name|QList
argument_list|<
name|int
argument_list|>
name|specialCaseMap
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|specialCaseMaxLen
specifier|static
name|int
name|specialCaseMaxLen
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|appendToSpecialCaseMap
specifier|static
name|int
name|appendToSpecialCaseMap
parameter_list|(
specifier|const
name|QList
argument_list|<
name|int
argument_list|>
modifier|&
name|map
parameter_list|)
block|{
name|QList
argument_list|<
name|int
argument_list|>
name|utf16map
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|map
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|val
init|=
name|map
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|>=
literal|0x10000
condition|)
block|{
name|utf16map
operator|<<
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|utf16map
operator|<<
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf16map
operator|<<
name|val
expr_stmt|;
block|}
block|}
name|specialCaseMaxLen
operator|=
name|qMax
argument_list|(
name|specialCaseMaxLen
argument_list|,
name|utf16map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|utf16map
operator|<<
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|specialCaseMap
operator|.
name|size
argument_list|()
operator|-
name|utf16map
operator|.
name|size
argument_list|()
operator|+
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|utf16map
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|specialCaseMap
operator|.
name|at
argument_list|(
name|i
operator|+
name|j
argument_list|)
operator|!=
name|utf16map
operator|.
name|at
argument_list|(
name|j
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|utf16map
operator|.
name|size
argument_list|()
condition|)
return|return
name|i
return|;
block|}
name|int
name|pos
init|=
name|specialCaseMap
operator|.
name|size
argument_list|()
decl_stmt|;
name|specialCaseMap
operator|<<
name|utf16map
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function
begin_struct
DECL|struct|UnicodeData
struct|struct
name|UnicodeData
block|{
DECL|function|UnicodeData
name|UnicodeData
parameter_list|(
name|int
name|codepoint
init|=
literal|0
parameter_list|)
block|{
name|p
operator|.
name|category
operator|=
name|QChar
operator|::
name|Other_NotAssigned
expr_stmt|;
comment|// Cn
name|p
operator|.
name|combiningClass
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|direction
operator|=
name|QChar
operator|::
name|DirL
expr_stmt|;
comment|// DerivedBidiClass.txt
comment|// DirR for:  U+0590..U+05FF, U+07C0..U+08FF, U+FB1D..U+FB4F, U+10800..U+10FFF
if|if
condition|(
operator|(
name|codepoint
operator|>=
literal|0x590
operator|&&
name|codepoint
operator|<=
literal|0x5ff
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x7c0
operator|&&
name|codepoint
operator|<=
literal|0x8ff
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0xfb1d
operator|&&
name|codepoint
operator|<=
literal|0xfb4f
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x10800
operator|&&
name|codepoint
operator|<=
literal|0x10fff
operator|)
condition|)
block|{
name|p
operator|.
name|direction
operator|=
name|QChar
operator|::
name|DirR
expr_stmt|;
block|}
comment|// DirAL for:  U+0600..U+07BF, U+FB50..U+FDFF, U+FE70..U+FEFF
comment|//             minus noncharacter code points (intersects with U+FDD0..U+FDEF)
if|if
condition|(
operator|(
name|codepoint
operator|>=
literal|0x600
operator|&&
name|codepoint
operator|<=
literal|0x7bf
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0xfb50
operator|&&
name|codepoint
operator|<=
literal|0xfdcf
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0xfdf0
operator|&&
name|codepoint
operator|<=
literal|0xfdff
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0xfe70
operator|&&
name|codepoint
operator|<=
literal|0xfeff
operator|)
condition|)
block|{
name|p
operator|.
name|direction
operator|=
name|QChar
operator|::
name|DirAL
expr_stmt|;
block|}
name|mirroredChar
operator|=
literal|0
expr_stmt|;
name|decompositionType
operator|=
name|QChar
operator|::
name|NoDecomposition
expr_stmt|;
name|p
operator|.
name|joining
operator|=
name|QChar
operator|::
name|OtherJoining
expr_stmt|;
name|p
operator|.
name|age
operator|=
name|QChar
operator|::
name|Unicode_Unassigned
expr_stmt|;
name|p
operator|.
name|mirrorDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|digitValue
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|.
name|line_break_class
operator|=
name|LineBreak_AL
expr_stmt|;
comment|// XX -> AL
name|p
operator|.
name|lowerCaseDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|upperCaseDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|titleCaseDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|caseFoldDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|lowerCaseSpecial
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|upperCaseSpecial
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|titleCaseSpecial
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|caseFoldSpecial
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|graphemeBreak
operator|=
name|GraphemeBreakOther
expr_stmt|;
name|p
operator|.
name|wordBreak
operator|=
name|WordBreakOther
expr_stmt|;
name|p
operator|.
name|sentenceBreak
operator|=
name|SentenceBreakOther
expr_stmt|;
name|propertyIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|excludedComposition
operator|=
literal|false
expr_stmt|;
block|}
DECL|member|p
name|PropertyFlags
name|p
decl_stmt|;
comment|// from UnicodeData.txt
DECL|member|decompositionType
name|QChar
operator|::
name|Decomposition
name|decompositionType
decl_stmt|;
DECL|member|decomposition
name|QList
argument_list|<
name|int
argument_list|>
name|decomposition
decl_stmt|;
DECL|member|specialFolding
name|QList
argument_list|<
name|int
argument_list|>
name|specialFolding
decl_stmt|;
comment|// from BidiMirroring.txt
DECL|member|mirroredChar
name|int
name|mirroredChar
decl_stmt|;
comment|// DerivedNormalizationProps.txt
DECL|member|excludedComposition
name|bool
name|excludedComposition
decl_stmt|;
comment|// computed position of unicode property set
DECL|member|propertyIndex
name|int
name|propertyIndex
decl_stmt|;
block|}
struct|;
end_struct
begin_enum
DECL|enum|UniDataFields
enum|enum
name|UniDataFields
block|{
DECL|enumerator|UD_Value
name|UD_Value
block|,
DECL|enumerator|UD_Name
name|UD_Name
block|,
DECL|enumerator|UD_Category
name|UD_Category
block|,
DECL|enumerator|UD_CombiningClass
name|UD_CombiningClass
block|,
DECL|enumerator|UD_BidiCategory
name|UD_BidiCategory
block|,
DECL|enumerator|UD_Decomposition
name|UD_Decomposition
block|,
DECL|enumerator|UD_DecimalDigitValue
name|UD_DecimalDigitValue
block|,
DECL|enumerator|UD_DigitValue
name|UD_DigitValue
block|,
DECL|enumerator|UD_NumericValue
name|UD_NumericValue
block|,
DECL|enumerator|UD_Mirrored
name|UD_Mirrored
block|,
DECL|enumerator|UD_OldName
name|UD_OldName
block|,
DECL|enumerator|UD_Comment
name|UD_Comment
block|,
DECL|enumerator|UD_UpperCase
name|UD_UpperCase
block|,
DECL|enumerator|UD_LowerCase
name|UD_LowerCase
block|,
DECL|enumerator|UD_TitleCase
name|UD_TitleCase
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|categoryMap
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QChar
operator|::
name|Category
argument_list|>
name|categoryMap
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initCategoryMap
specifier|static
name|void
name|initCategoryMap
parameter_list|()
block|{
struct|struct
name|Cat
block|{
name|QChar
operator|::
name|Category
name|cat
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|categories
index|[]
init|=
block|{
block|{
name|QChar
operator|::
name|Mark_NonSpacing
block|,
literal|"Mn"
block|}
block|,
block|{
name|QChar
operator|::
name|Mark_SpacingCombining
block|,
literal|"Mc"
block|}
block|,
block|{
name|QChar
operator|::
name|Mark_Enclosing
block|,
literal|"Me"
block|}
block|,
block|{
name|QChar
operator|::
name|Number_DecimalDigit
block|,
literal|"Nd"
block|}
block|,
block|{
name|QChar
operator|::
name|Number_Letter
block|,
literal|"Nl"
block|}
block|,
block|{
name|QChar
operator|::
name|Number_Other
block|,
literal|"No"
block|}
block|,
block|{
name|QChar
operator|::
name|Separator_Space
block|,
literal|"Zs"
block|}
block|,
block|{
name|QChar
operator|::
name|Separator_Line
block|,
literal|"Zl"
block|}
block|,
block|{
name|QChar
operator|::
name|Separator_Paragraph
block|,
literal|"Zp"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_Control
block|,
literal|"Cc"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_Format
block|,
literal|"Cf"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_Surrogate
block|,
literal|"Cs"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_PrivateUse
block|,
literal|"Co"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_NotAssigned
block|,
literal|"Cn"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Uppercase
block|,
literal|"Lu"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Lowercase
block|,
literal|"Ll"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Titlecase
block|,
literal|"Lt"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Modifier
block|,
literal|"Lm"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Other
block|,
literal|"Lo"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Connector
block|,
literal|"Pc"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Dash
block|,
literal|"Pd"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Open
block|,
literal|"Ps"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Close
block|,
literal|"Pe"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_InitialQuote
block|,
literal|"Pi"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_FinalQuote
block|,
literal|"Pf"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Other
block|,
literal|"Po"
block|}
block|,
block|{
name|QChar
operator|::
name|Symbol_Math
block|,
literal|"Sm"
block|}
block|,
block|{
name|QChar
operator|::
name|Symbol_Currency
block|,
literal|"Sc"
block|}
block|,
block|{
name|QChar
operator|::
name|Symbol_Modifier
block|,
literal|"Sk"
block|}
block|,
block|{
name|QChar
operator|::
name|Symbol_Other
block|,
literal|"So"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_NotAssigned
block|,
literal|0
block|}
block|}
struct|;
name|Cat
modifier|*
name|c
init|=
name|categories
decl_stmt|;
while|while
condition|(
name|c
operator|->
name|name
condition|)
block|{
name|categoryMap
operator|.
name|insert
argument_list|(
name|c
operator|->
name|name
argument_list|,
name|c
operator|->
name|cat
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|directionMap
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QChar
operator|::
name|Direction
argument_list|>
name|directionMap
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initDirectionMap
specifier|static
name|void
name|initDirectionMap
parameter_list|()
block|{
struct|struct
name|Dir
block|{
name|QChar
operator|::
name|Direction
name|dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|directions
index|[]
init|=
block|{
block|{
name|QChar
operator|::
name|DirL
block|,
literal|"L"
block|}
block|,
block|{
name|QChar
operator|::
name|DirR
block|,
literal|"R"
block|}
block|,
block|{
name|QChar
operator|::
name|DirEN
block|,
literal|"EN"
block|}
block|,
block|{
name|QChar
operator|::
name|DirES
block|,
literal|"ES"
block|}
block|,
block|{
name|QChar
operator|::
name|DirET
block|,
literal|"ET"
block|}
block|,
block|{
name|QChar
operator|::
name|DirAN
block|,
literal|"AN"
block|}
block|,
block|{
name|QChar
operator|::
name|DirCS
block|,
literal|"CS"
block|}
block|,
block|{
name|QChar
operator|::
name|DirB
block|,
literal|"B"
block|}
block|,
block|{
name|QChar
operator|::
name|DirS
block|,
literal|"S"
block|}
block|,
block|{
name|QChar
operator|::
name|DirWS
block|,
literal|"WS"
block|}
block|,
block|{
name|QChar
operator|::
name|DirON
block|,
literal|"ON"
block|}
block|,
block|{
name|QChar
operator|::
name|DirLRE
block|,
literal|"LRE"
block|}
block|,
block|{
name|QChar
operator|::
name|DirLRO
block|,
literal|"LRO"
block|}
block|,
block|{
name|QChar
operator|::
name|DirAL
block|,
literal|"AL"
block|}
block|,
block|{
name|QChar
operator|::
name|DirRLE
block|,
literal|"RLE"
block|}
block|,
block|{
name|QChar
operator|::
name|DirRLO
block|,
literal|"RLO"
block|}
block|,
block|{
name|QChar
operator|::
name|DirPDF
block|,
literal|"PDF"
block|}
block|,
block|{
name|QChar
operator|::
name|DirNSM
block|,
literal|"NSM"
block|}
block|,
block|{
name|QChar
operator|::
name|DirBN
block|,
literal|"BN"
block|}
block|,
block|{
name|QChar
operator|::
name|DirL
block|,
literal|0
block|}
block|}
struct|;
name|Dir
modifier|*
name|d
init|=
name|directions
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|directionMap
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|dir
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|decompositionMap
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QChar
operator|::
name|Decomposition
argument_list|>
name|decompositionMap
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initDecompositionMap
specifier|static
name|void
name|initDecompositionMap
parameter_list|()
block|{
struct|struct
name|Dec
block|{
name|QChar
operator|::
name|Decomposition
name|dec
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|decompositions
index|[]
init|=
block|{
block|{
name|QChar
operator|::
name|Canonical
block|,
literal|"<canonical>"
block|}
block|,
block|{
name|QChar
operator|::
name|Font
block|,
literal|"<font>"
block|}
block|,
block|{
name|QChar
operator|::
name|NoBreak
block|,
literal|"<noBreak>"
block|}
block|,
block|{
name|QChar
operator|::
name|Initial
block|,
literal|"<initial>"
block|}
block|,
block|{
name|QChar
operator|::
name|Medial
block|,
literal|"<medial>"
block|}
block|,
block|{
name|QChar
operator|::
name|Final
block|,
literal|"<final>"
block|}
block|,
block|{
name|QChar
operator|::
name|Isolated
block|,
literal|"<isolated>"
block|}
block|,
block|{
name|QChar
operator|::
name|Circle
block|,
literal|"<circle>"
block|}
block|,
block|{
name|QChar
operator|::
name|Super
block|,
literal|"<super>"
block|}
block|,
block|{
name|QChar
operator|::
name|Sub
block|,
literal|"<sub>"
block|}
block|,
block|{
name|QChar
operator|::
name|Vertical
block|,
literal|"<vertical>"
block|}
block|,
block|{
name|QChar
operator|::
name|Wide
block|,
literal|"<wide>"
block|}
block|,
block|{
name|QChar
operator|::
name|Narrow
block|,
literal|"<narrow>"
block|}
block|,
block|{
name|QChar
operator|::
name|Small
block|,
literal|"<small>"
block|}
block|,
block|{
name|QChar
operator|::
name|Square
block|,
literal|"<square>"
block|}
block|,
block|{
name|QChar
operator|::
name|Compat
block|,
literal|"<compat>"
block|}
block|,
block|{
name|QChar
operator|::
name|Fraction
block|,
literal|"<fraction>"
block|}
block|,
block|{
name|QChar
operator|::
name|NoDecomposition
block|,
literal|0
block|}
block|}
struct|;
name|Dec
modifier|*
name|d
init|=
name|decompositions
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|decompositionMap
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|dec
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|unicodeData
specifier|static
name|QHash
argument_list|<
name|int
argument_list|,
name|UnicodeData
argument_list|>
name|unicodeData
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|uniqueProperties
specifier|static
name|QList
argument_list|<
name|PropertyFlags
argument_list|>
name|uniqueProperties
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decompositionLength
specifier|static
name|QHash
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|decompositionLength
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|highestComposedCharacter
specifier|static
name|int
name|highestComposedCharacter
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|numLigatures
specifier|static
name|int
name|numLigatures
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|highestLigature
specifier|static
name|int
name|highestLigature
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|Ligature
struct|struct
name|Ligature
block|{
DECL|member|u1
name|ushort
name|u1
decl_stmt|;
DECL|member|u2
name|ushort
name|u2
decl_stmt|;
DECL|member|ligature
name|ushort
name|ligature
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|// we need them sorted after the first component for fast lookup
end_comment
begin_function
DECL|function|operator <
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|Ligature
modifier|&
name|l1
parameter_list|,
specifier|const
name|Ligature
modifier|&
name|l2
parameter_list|)
block|{
return|return
name|l1
operator|.
name|u1
operator|<
name|l2
operator|.
name|u1
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|ligatureHashes
specifier|static
name|QHash
argument_list|<
name|ushort
argument_list|,
name|QList
argument_list|<
name|Ligature
argument_list|>
argument_list|>
name|ligatureHashes
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|combiningClassUsage
specifier|static
name|QHash
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|combiningClassUsage
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|maxLowerCaseDiff
specifier|static
name|int
name|maxLowerCaseDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|maxUpperCaseDiff
specifier|static
name|int
name|maxUpperCaseDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|maxTitleCaseDiff
specifier|static
name|int
name|maxTitleCaseDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|readUnicodeData
specifier|static
name|void
name|readUnicodeData
parameter_list|()
block|{
name|QFile
name|f
argument_list|(
literal|"data/UnicodeData.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find UnicodeData.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|truncate
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|properties
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|properties
index|[
name|UD_Value
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|codepoint
operator|<=
name|LAST_CODEPOINT
argument_list|)
expr_stmt|;
name|int
name|lastCodepoint
init|=
name|codepoint
decl_stmt|;
name|QByteArray
name|name
init|=
name|properties
index|[
name|UD_Name
index|]
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|'<'
argument_list|)
operator|&&
name|name
operator|.
name|contains
argument_list|(
literal|"First"
argument_list|)
condition|)
block|{
name|QByteArray
name|nextLine
decl_stmt|;
name|nextLine
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|f
operator|.
name|readLine
argument_list|(
name|nextLine
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|properties
init|=
name|nextLine
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|properties
index|[
name|UD_Name
index|]
operator|.
name|startsWith
argument_list|(
literal|'<'
argument_list|)
operator|&&
name|properties
index|[
name|UD_Name
index|]
operator|.
name|contains
argument_list|(
literal|"Last"
argument_list|)
argument_list|)
expr_stmt|;
name|lastCodepoint
operator|=
name|properties
index|[
name|UD_Value
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|lastCodepoint
operator|<=
name|LAST_CODEPOINT
argument_list|)
expr_stmt|;
block|}
name|UnicodeData
name|data
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|data
operator|.
name|p
operator|.
name|category
operator|=
name|categoryMap
operator|.
name|value
argument_list|(
name|properties
index|[
name|UD_Category
index|]
argument_list|,
name|QChar
operator|::
name|Other_NotAssigned
argument_list|)
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|combiningClass
operator|=
name|properties
index|[
name|UD_CombiningClass
index|]
operator|.
name|toInt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|combiningClassUsage
operator|.
name|contains
argument_list|(
name|data
operator|.
name|p
operator|.
name|combiningClass
argument_list|)
condition|)
name|combiningClassUsage
index|[
name|data
operator|.
name|p
operator|.
name|combiningClass
index|]
operator|=
literal|1
expr_stmt|;
else|else
operator|++
name|combiningClassUsage
index|[
name|data
operator|.
name|p
operator|.
name|combiningClass
index|]
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|direction
operator|=
name|directionMap
operator|.
name|value
argument_list|(
name|properties
index|[
name|UD_BidiCategory
index|]
argument_list|,
name|data
operator|.
name|p
operator|.
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|properties
index|[
name|UD_UpperCase
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|upperCase
init|=
name|properties
index|[
name|UD_UpperCase
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|diff
init|=
name|upperCase
operator|-
name|codepoint
decl_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|diff
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|14
operator|)
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"upperCaseDiff exceeded ("
operator|<<
name|hex
operator|<<
name|codepoint
operator|<<
literal|"->"
operator|<<
name|upperCase
operator|<<
literal|")"
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|upperCaseDiff
operator|=
name|diff
expr_stmt|;
name|maxUpperCaseDiff
operator|=
name|qMax
argument_list|(
name|maxUpperCaseDiff
argument_list|,
name|qAbs
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|codepoint
operator|>=
literal|0x10000
operator|||
name|upperCase
operator|>=
literal|0x10000
condition|)
block|{
comment|// if the conditions below doesn't hold anymore we need to modify our upper casing code
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|upperCase
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|+
name|diff
operator|==
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|upperCase
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|properties
index|[
name|UD_LowerCase
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|lowerCase
init|=
name|properties
index|[
name|UD_LowerCase
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|diff
init|=
name|lowerCase
operator|-
name|codepoint
decl_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|diff
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|14
operator|)
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"lowerCaseDiff exceeded ("
operator|<<
name|hex
operator|<<
name|codepoint
operator|<<
literal|"->"
operator|<<
name|lowerCase
operator|<<
literal|")"
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|lowerCaseDiff
operator|=
name|diff
expr_stmt|;
name|maxLowerCaseDiff
operator|=
name|qMax
argument_list|(
name|maxLowerCaseDiff
argument_list|,
name|qAbs
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|codepoint
operator|>=
literal|0x10000
operator|||
name|lowerCase
operator|>=
literal|0x10000
condition|)
block|{
comment|// if the conditions below doesn't hold anymore we need to modify our lower casing code
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|lowerCase
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|+
name|diff
operator|==
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|lowerCase
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// we want toTitleCase to map to ToUpper in case we don't have any titlecase.
if|if
condition|(
name|properties
index|[
name|UD_TitleCase
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
name|properties
index|[
name|UD_TitleCase
index|]
operator|=
name|properties
index|[
name|UD_UpperCase
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|properties
index|[
name|UD_TitleCase
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|titleCase
init|=
name|properties
index|[
name|UD_TitleCase
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|diff
init|=
name|titleCase
operator|-
name|codepoint
decl_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|diff
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|14
operator|)
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"titleCaseDiff exceeded ("
operator|<<
name|hex
operator|<<
name|codepoint
operator|<<
literal|"->"
operator|<<
name|titleCase
operator|<<
literal|")"
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|titleCaseDiff
operator|=
name|diff
expr_stmt|;
name|maxTitleCaseDiff
operator|=
name|qMax
argument_list|(
name|maxTitleCaseDiff
argument_list|,
name|qAbs
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|codepoint
operator|>=
literal|0x10000
operator|||
name|titleCase
operator|>=
literal|0x10000
condition|)
block|{
comment|// if the conditions below doesn't hold anymore we need to modify our title casing code
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|titleCase
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|+
name|diff
operator|==
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|titleCase
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|properties
index|[
name|UD_DigitValue
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
name|data
operator|.
name|p
operator|.
name|digitValue
operator|=
name|properties
index|[
name|UD_DigitValue
index|]
operator|.
name|toInt
argument_list|()
expr_stmt|;
comment|// decompositition
name|QByteArray
name|decomposition
init|=
name|properties
index|[
name|UD_Decomposition
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|decomposition
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|highestComposedCharacter
operator|=
name|qMax
argument_list|(
name|highestComposedCharacter
argument_list|,
name|codepoint
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|d
init|=
name|decomposition
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
index|[
literal|0
index|]
operator|.
name|contains
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|data
operator|.
name|decompositionType
operator|=
name|decompositionMap
operator|.
name|value
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|QChar
operator|::
name|NoDecomposition
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|decompositionType
operator|==
name|QChar
operator|::
name|NoDecomposition
condition|)
name|qFatal
argument_list|(
literal|"unassigned decomposition type: %s"
argument_list|,
name|d
index|[
literal|0
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|data
operator|.
name|decompositionType
operator|=
name|QChar
operator|::
name|Canonical
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|data
operator|.
name|decomposition
operator|.
name|append
argument_list|(
name|d
index|[
name|i
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|decompositionLength
operator|.
name|contains
argument_list|(
name|data
operator|.
name|decomposition
operator|.
name|size
argument_list|()
argument_list|)
condition|)
name|decompositionLength
index|[
name|data
operator|.
name|decomposition
operator|.
name|size
argument_list|()
index|]
operator|=
literal|1
expr_stmt|;
else|else
operator|++
name|decompositionLength
index|[
name|data
operator|.
name|decomposition
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|codepoint
init|;
name|i
operator|<=
name|lastCodepoint
condition|;
operator|++
name|i
control|)
name|unicodeData
operator|.
name|insert
argument_list|(
name|i
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|maxMirroredDiff
specifier|static
name|int
name|maxMirroredDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|readBidiMirroring
specifier|static
name|void
name|readBidiMirroring
parameter_list|()
block|{
name|QFile
name|f
argument_list|(
literal|"data/BidiMirroring.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find BidiMirroring.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|line
operator|=
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|pair
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|pair
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|pair
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|mirror
init|=
name|pair
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|UnicodeData
name|d
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|codepoint
argument_list|,
name|UnicodeData
argument_list|(
name|codepoint
argument_list|)
argument_list|)
decl_stmt|;
name|d
operator|.
name|mirroredChar
operator|=
name|mirror
expr_stmt|;
name|d
operator|.
name|p
operator|.
name|mirrorDiff
operator|=
name|d
operator|.
name|mirroredChar
operator|-
name|codepoint
expr_stmt|;
name|maxMirroredDiff
operator|=
name|qMax
argument_list|(
name|maxMirroredDiff
argument_list|,
name|qAbs
argument_list|(
name|d
operator|.
name|p
operator|.
name|mirrorDiff
argument_list|)
argument_list|)
expr_stmt|;
name|unicodeData
operator|.
name|insert
argument_list|(
name|codepoint
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|readArabicShaping
specifier|static
name|void
name|readArabicShaping
parameter_list|()
block|{
name|QFile
name|f
argument_list|(
literal|"data/ArabicShaping.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find ArabicShaping.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|=
name|line
operator|.
name|trimmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|4
argument_list|)
expr_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|l
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|Joining
name|joining
init|=
name|joining_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|2
index|]
operator|.
name|trimmed
argument_list|()
argument_list|,
name|Joining_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|joining
operator|==
name|Joining_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned or unhandled joining value: %s"
argument_list|,
name|l
index|[
literal|2
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|joining
operator|==
name|Joining_Left
condition|)
block|{
comment|// There are currently no characters of joining type Left_Joining defined in Unicode.
name|qFatal
argument_list|(
literal|"%x: joining type '%s' was met; the current implementation needs to be revised!"
argument_list|,
name|codepoint
argument_list|,
name|l
index|[
literal|2
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|UnicodeData
name|d
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|codepoint
argument_list|,
name|UnicodeData
argument_list|(
name|codepoint
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|joining
operator|==
name|Joining_Right
condition|)
name|d
operator|.
name|p
operator|.
name|joining
operator|=
name|QChar
operator|::
name|Right
expr_stmt|;
elseif|else
if|if
condition|(
name|joining
operator|==
name|Joining_Dual
condition|)
name|d
operator|.
name|p
operator|.
name|joining
operator|=
name|QChar
operator|::
name|Dual
expr_stmt|;
elseif|else
if|if
condition|(
name|joining
operator|==
name|Joining_Causing
condition|)
name|d
operator|.
name|p
operator|.
name|joining
operator|=
name|QChar
operator|::
name|Center
expr_stmt|;
else|else
name|d
operator|.
name|p
operator|.
name|joining
operator|=
name|QChar
operator|::
name|OtherJoining
expr_stmt|;
name|unicodeData
operator|.
name|insert
argument_list|(
name|codepoint
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|readDerivedAge
specifier|static
name|void
name|readDerivedAge
parameter_list|()
block|{
name|QFile
name|f
argument_list|(
literal|"data/DerivedAge.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find DerivedAge.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|QChar
operator|::
name|UnicodeVersion
name|age
init|=
name|age_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
operator|.
name|trimmed
argument_list|()
argument_list|,
name|QChar
operator|::
name|Unicode_Unassigned
argument_list|)
decl_stmt|;
comment|//qDebug()<< hex<< from<< ".."<< to<< ba<< age;
if|if
condition|(
name|age
operator|==
name|QChar
operator|::
name|Unicode_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned or unhandled age value: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
name|d
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|codepoint
argument_list|,
name|UnicodeData
argument_list|(
name|codepoint
argument_list|)
argument_list|)
decl_stmt|;
name|d
operator|.
name|p
operator|.
name|age
operator|=
name|age
expr_stmt|;
name|unicodeData
operator|.
name|insert
argument_list|(
name|codepoint
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readDerivedNormalizationProps
specifier|static
name|void
name|readDerivedNormalizationProps
parameter_list|()
block|{
name|QFile
name|f
argument_list|(
literal|"data/DerivedNormalizationProps.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find DerivedNormalizationProps.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|trimmed
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|propName
init|=
name|l
index|[
literal|1
index|]
operator|.
name|trimmed
argument_list|()
decl_stmt|;
if|if
condition|(
name|propName
operator|!=
literal|"Full_Composition_Exclusion"
condition|)
comment|// ###
continue|continue;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
name|d
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|codepoint
argument_list|,
name|UnicodeData
argument_list|(
name|codepoint
argument_list|)
argument_list|)
decl_stmt|;
name|d
operator|.
name|excludedComposition
operator|=
literal|true
expr_stmt|;
name|unicodeData
operator|.
name|insert
argument_list|(
name|codepoint
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|codepoint
init|=
literal|0
init|;
name|codepoint
operator|<=
name|LAST_CODEPOINT
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
name|d
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|codepoint
argument_list|,
name|UnicodeData
argument_list|(
name|codepoint
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|excludedComposition
operator|&&
name|d
operator|.
name|decompositionType
operator|==
name|QChar
operator|::
name|Canonical
operator|&&
name|d
operator|.
name|decomposition
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|d
operator|.
name|decomposition
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|int
name|part1
init|=
name|d
operator|.
name|decomposition
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|part2
init|=
name|d
operator|.
name|decomposition
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// all non-starters are listed in DerivedNormalizationProps.txt
comment|// and already excluded from composition
name|Q_ASSERT
argument_list|(
name|unicodeData
operator|.
name|value
argument_list|(
name|part1
argument_list|,
name|UnicodeData
argument_list|(
name|part1
argument_list|)
argument_list|)
operator|.
name|p
operator|.
name|combiningClass
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|++
name|numLigatures
expr_stmt|;
name|highestLigature
operator|=
name|qMax
argument_list|(
name|highestLigature
argument_list|,
name|part1
argument_list|)
expr_stmt|;
name|Ligature
name|l
init|=
block|{
operator|(
name|ushort
operator|)
name|part1
block|,
operator|(
name|ushort
operator|)
name|part2
block|,
operator|(
name|ushort
operator|)
name|codepoint
block|}
decl_stmt|;
name|ligatureHashes
index|[
name|part2
index|]
operator|.
name|append
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_struct
DECL|struct|NormalizationCorrection
struct|struct
name|NormalizationCorrection
block|{
DECL|member|codepoint
name|uint
name|codepoint
decl_stmt|;
DECL|member|mapped
name|uint
name|mapped
decl_stmt|;
DECL|member|version
name|uint
name|version
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|createNormalizationCorrections
specifier|static
name|QByteArray
name|createNormalizationCorrections
parameter_list|()
block|{
name|QFile
name|f
argument_list|(
literal|"data/NormalizationCorrections.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find NormalizationCorrections.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"struct NormalizationCorrection {\n"
literal|"    uint ucs4;\n"
literal|"    uint old_mapping;\n"
literal|"    int version;\n"
literal|"};\n\n"
literal|"static const NormalizationCorrection uc_normalization_corrections[] = {\n"
expr_stmt|;
name|int
name|numCorrections
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|Q_ASSERT
argument_list|(
operator|!
name|line
operator|.
name|contains
argument_list|(
literal|".."
argument_list|)
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|fields
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|fields
operator|.
name|size
argument_list|()
operator|==
literal|4
argument_list|)
expr_stmt|;
name|NormalizationCorrection
name|c
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|c
operator|.
name|codepoint
operator|=
name|fields
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|c
operator|.
name|mapped
operator|=
name|fields
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|==
literal|"3.2.0"
condition|)
name|c
operator|.
name|version
operator|=
name|QChar
operator|::
name|Unicode_3_2
expr_stmt|;
elseif|else
if|if
condition|(
name|fields
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|==
literal|"4.0.0"
condition|)
name|c
operator|.
name|version
operator|=
name|QChar
operator|::
name|Unicode_4_0
expr_stmt|;
else|else
name|qFatal
argument_list|(
literal|"unknown unicode version in NormalizationCorrection.txt"
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"    { 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|c
operator|.
name|codepoint
argument_list|,
literal|16
argument_list|)
operator|+
literal|", 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|c
operator|.
name|mapped
argument_list|,
literal|16
argument_list|)
operator|+
literal|", "
operator|+
name|QString
operator|::
name|number
argument_list|(
name|c
operator|.
name|version
argument_list|)
operator|+
literal|" },\n"
expr_stmt|;
operator|++
name|numCorrections
expr_stmt|;
block|}
name|out
operator|+=
literal|"};\n\n"
literal|"enum { NumNormalizationCorrections = "
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|numCorrections
argument_list|)
operator|+
literal|" };\n\n"
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|computeUniqueProperties
specifier|static
name|void
name|computeUniqueProperties
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"computeUniqueProperties:"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|uc
init|=
literal|0
init|;
name|uc
operator|<=
name|LAST_CODEPOINT
condition|;
operator|++
name|uc
control|)
block|{
name|UnicodeData
name|d
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|uc
argument_list|,
name|UnicodeData
argument_list|(
name|uc
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|uniqueProperties
operator|.
name|indexOf
argument_list|(
name|d
operator|.
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueProperties
operator|.
name|size
argument_list|()
expr_stmt|;
name|uniqueProperties
operator|.
name|append
argument_list|(
name|d
operator|.
name|p
argument_list|)
expr_stmt|;
block|}
name|d
operator|.
name|propertyIndex
operator|=
name|index
expr_stmt|;
name|unicodeData
operator|.
name|insert
argument_list|(
name|uc
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
name|qDebug
argument_list|(
literal|"    %d unique unicode properties found"
argument_list|,
name|uniqueProperties
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|readLineBreak
specifier|static
name|void
name|readLineBreak
parameter_list|()
block|{
name|qDebug
argument_list|()
operator|<<
literal|"Reading LineBreak.txt"
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/LineBreak.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find LineBreak.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|LineBreakClass
name|lb
init|=
name|line_break_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|LineBreak_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|lb
operator|==
name|LineBreak_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned line break class: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
name|d
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|codepoint
argument_list|,
name|UnicodeData
argument_list|(
name|codepoint
argument_list|)
argument_list|)
decl_stmt|;
name|d
operator|.
name|p
operator|.
name|line_break_class
operator|=
name|lb
expr_stmt|;
name|unicodeData
operator|.
name|insert
argument_list|(
name|codepoint
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readSpecialCasing
specifier|static
name|void
name|readSpecialCasing
parameter_list|()
block|{
name|qDebug
argument_list|()
operator|<<
literal|"Reading SpecialCasing.txt"
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/SpecialCasing.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find SpecialCasing.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|QByteArray
name|condition
init|=
name|l
operator|.
name|size
argument_list|()
operator|<
literal|5
condition|?
name|QByteArray
argument_list|()
else|:
name|l
index|[
literal|4
index|]
operator|.
name|trimmed
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|condition
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// #####
continue|continue;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|l
index|[
literal|0
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
comment|// if the condition below doesn't hold anymore we need to modify our
comment|// lower/upper/title casing code and case folding code
name|Q_ASSERT
argument_list|(
name|codepoint
operator|<
literal|0x10000
argument_list|)
expr_stmt|;
comment|//         qDebug()<< "codepoint"<< hex<< codepoint;
comment|//         qDebug()<< line;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|lower
init|=
name|l
index|[
literal|1
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|lowerMap
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lower
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|ok
decl_stmt|;
name|lowerMap
operator|.
name|append
argument_list|(
name|lower
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|title
init|=
name|l
index|[
literal|2
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|titleMap
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|title
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|ok
decl_stmt|;
name|titleMap
operator|.
name|append
argument_list|(
name|title
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|upper
init|=
name|l
index|[
literal|3
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|upperMap
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|upper
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|ok
decl_stmt|;
name|upperMap
operator|.
name|append
argument_list|(
name|upper
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|UnicodeData
name|ud
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|codepoint
argument_list|,
name|UnicodeData
argument_list|(
name|codepoint
argument_list|)
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|lowerMap
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|lowerMap
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|codepoint
operator|+
name|ud
operator|.
name|p
operator|.
name|lowerCaseDiff
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|titleMap
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|titleMap
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|codepoint
operator|+
name|ud
operator|.
name|p
operator|.
name|titleCaseDiff
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|upperMap
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|upperMap
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|codepoint
operator|+
name|ud
operator|.
name|p
operator|.
name|upperCaseDiff
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowerMap
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ud
operator|.
name|p
operator|.
name|lowerCaseSpecial
operator|=
literal|true
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|lowerCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|lowerMap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|titleMap
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ud
operator|.
name|p
operator|.
name|titleCaseSpecial
operator|=
literal|true
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|titleCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|titleMap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|upperMap
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ud
operator|.
name|p
operator|.
name|upperCaseSpecial
operator|=
literal|true
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|upperCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|upperMap
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
name|unicodeData
operator|.
name|insert
argument_list|(
name|codepoint
argument_list|,
name|ud
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|maxCaseFoldDiff
specifier|static
name|int
name|maxCaseFoldDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|readCaseFolding
specifier|static
name|void
name|readCaseFolding
parameter_list|()
block|{
name|qDebug
argument_list|()
operator|<<
literal|"Reading CaseFolding.txt"
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/CaseFolding.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find CaseFolding.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|l
index|[
literal|0
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|l
index|[
literal|1
index|]
operator|=
name|l
index|[
literal|1
index|]
operator|.
name|trimmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|l
index|[
literal|1
index|]
operator|==
literal|"F"
operator|||
name|l
index|[
literal|1
index|]
operator|==
literal|"T"
condition|)
continue|continue;
comment|//         qDebug()<< "codepoint"<< hex<< codepoint;
comment|//         qDebug()<< line;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|fold
init|=
name|l
index|[
literal|2
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|foldMap
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fold
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|ok
decl_stmt|;
name|foldMap
operator|.
name|append
argument_list|(
name|fold
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|UnicodeData
name|ud
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|codepoint
argument_list|,
name|UnicodeData
argument_list|(
name|codepoint
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|foldMap
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|int
name|caseFolded
init|=
name|foldMap
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|diff
init|=
name|caseFolded
operator|-
name|codepoint
decl_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|diff
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|14
operator|)
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"caseFoldDiff exceeded ("
operator|<<
name|hex
operator|<<
name|codepoint
operator|<<
literal|"->"
operator|<<
name|caseFolded
operator|<<
literal|")"
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|caseFoldDiff
operator|=
name|diff
expr_stmt|;
name|maxCaseFoldDiff
operator|=
name|qMax
argument_list|(
name|maxCaseFoldDiff
argument_list|,
name|qAbs
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|codepoint
operator|>=
literal|0x10000
operator|||
name|caseFolded
operator|>=
literal|0x10000
condition|)
block|{
comment|// if the conditions below doesn't hold anymore we need to modify our case folding code
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|caseFolded
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|+
name|diff
operator|==
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|caseFolded
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|caseFolded
operator|!=
name|codepoint
operator|+
name|ud
operator|.
name|p
operator|.
name|lowerCaseDiff
condition|)
name|qDebug
argument_list|()
operator|<<
name|hex
operator|<<
name|codepoint
expr_stmt|;
block|}
else|else
block|{
name|qFatal
argument_list|(
literal|"we currently don't support full case foldings"
argument_list|)
expr_stmt|;
comment|//             qDebug()<< "special"<< hex<< foldMap;
name|ud
operator|.
name|p
operator|.
name|caseFoldSpecial
operator|=
literal|true
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|caseFoldDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|foldMap
argument_list|)
expr_stmt|;
block|}
name|unicodeData
operator|.
name|insert
argument_list|(
name|codepoint
argument_list|,
name|ud
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|readGraphemeBreak
specifier|static
name|void
name|readGraphemeBreak
parameter_list|()
block|{
name|qDebug
argument_list|()
operator|<<
literal|"Reading GraphemeBreakProperty.txt"
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/GraphemeBreakProperty.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find GraphemeBreakProperty.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|GraphemeBreak
name|brk
init|=
name|grapheme_break_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|GraphemeBreak_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|brk
operator|==
name|GraphemeBreak_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned grapheme break class: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
name|ud
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|codepoint
argument_list|,
name|UnicodeData
argument_list|(
name|codepoint
argument_list|)
argument_list|)
decl_stmt|;
name|ud
operator|.
name|p
operator|.
name|graphemeBreak
operator|=
name|brk
expr_stmt|;
name|unicodeData
operator|.
name|insert
argument_list|(
name|codepoint
argument_list|,
name|ud
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readWordBreak
specifier|static
name|void
name|readWordBreak
parameter_list|()
block|{
name|qDebug
argument_list|()
operator|<<
literal|"Reading WordBreakProperty.txt"
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/WordBreakProperty.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find WordBreakProperty.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|WordBreak
name|brk
init|=
name|word_break_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|WordBreak_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|brk
operator|==
name|WordBreak_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned word break class: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
name|ud
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|codepoint
argument_list|,
name|UnicodeData
argument_list|(
name|codepoint
argument_list|)
argument_list|)
decl_stmt|;
name|ud
operator|.
name|p
operator|.
name|wordBreak
operator|=
name|brk
expr_stmt|;
name|unicodeData
operator|.
name|insert
argument_list|(
name|codepoint
argument_list|,
name|ud
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readSentenceBreak
specifier|static
name|void
name|readSentenceBreak
parameter_list|()
block|{
name|qDebug
argument_list|()
operator|<<
literal|"Reading SentenceBreakProperty.txt"
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/SentenceBreakProperty.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find SentenceBreakProperty.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|SentenceBreak
name|brk
init|=
name|sentence_break_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|SentenceBreak_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|brk
operator|==
name|SentenceBreak_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned sentence break class: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
name|ud
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|codepoint
argument_list|,
name|UnicodeData
argument_list|(
name|codepoint
argument_list|)
argument_list|)
decl_stmt|;
name|ud
operator|.
name|p
operator|.
name|sentenceBreak
operator|=
name|brk
expr_stmt|;
name|unicodeData
operator|.
name|insert
argument_list|(
name|codepoint
argument_list|,
name|ud
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|// this piece of code does full case folding and comparison. We currently
end_comment
begin_comment
comment|// don't use it, since this gives lots of issues with things as case insensitive
end_comment
begin_comment
comment|// search and replace.
end_comment
begin_endif
unit|static inline void foldCase(uint ch, ushort *out) {     const QUnicodeTables::Properties *p = qGetProp(ch);     if (!p->caseFoldSpecial) {         *(out++) = ch + p->caseFoldDiff;     } else {         const ushort *folded = specialCaseMap + p->caseFoldDiff;         while (*folded)             *out++ = *folded++;     }     *out = 0; }  static int ucstricmp(const ushort *a, const ushort *ae, const ushort *b, const ushort *be) {     if (a == b)         return 0;     if (a == 0)         return 1;     if (b == 0)         return -1;      while (a != ae&& b != be) {         const QUnicodeTables::Properties *pa = qGetProp(*a);         const QUnicodeTables::Properties *pb = qGetProp(*b);         if (pa->caseFoldSpecial | pb->caseFoldSpecial)             goto special;             int diff = (int)(*a + pa->caseFoldDiff) - (int)(*b + pb->caseFoldDiff);         if ((diff))             return diff;         ++a;         ++b;         }     }     if (a == ae) {         if (b == be)             return 0;         return -1;     }     return 1; special:     ushort abuf[SPECIAL_CASE_MAX_LEN + 1];     ushort bbuf[SPECIAL_CASE_MAX_LEN + 1];     abuf[0] = bbuf[0] = 0;     ushort *ap = abuf;     ushort *bp = bbuf;     while (1) {         if (!*ap) {             if (a == ae) {                 if (!*bp&& b == be)                     return 0;                 return -1;             }             foldCase(*(a++), abuf);             ap = abuf;         }         if (!*bp) {             if (b == be)                 return 1;             foldCase(*(b++), bbuf);             bp = bbuf;         }         if (*ap != *bp)             return (int)*ap - (int)*bp;         ++ap;         ++bp;     } }   static int ucstricmp(const ushort *a, const ushort *ae, const uchar *b) {     if (a == 0)         return 1;     if (b == 0)         return -1;      while (a != ae&& *b) {         const QUnicodeTables::Properties *pa = qGetProp(*a);         const QUnicodeTables::Properties *pb = qGetProp((ushort)*b);         if (pa->caseFoldSpecial | pb->caseFoldSpecial)             goto special;         int diff = (int)(*a + pa->caseFoldDiff) - (int)(*b + pb->caseFoldDiff);         if ((diff))             return diff;         ++a;         ++b;     }     if (a == ae) {         if (!*b)             return 0;         return -1;     }     return 1;  special:     ushort abuf[SPECIAL_CASE_MAX_LEN + 1];     ushort bbuf[SPECIAL_CASE_MAX_LEN + 1];     abuf[0] = bbuf[0] = 0;     ushort *ap = abuf;     ushort *bp = bbuf;     while (1) {         if (!*ap) {             if (a == ae) {                 if (!*bp&& !*b)                     return 0;                 return -1;             }             foldCase(*(a++), abuf);             ap = abuf;         }         if (!*bp) {             if (!*b)                 return 1;             foldCase(*(b++), bbuf);             bp = bbuf;         }         if (*ap != *bp)             return (int)*ap - (int)*bp;         ++ap;         ++bp;     } }
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|static QList<QByteArray> blockNames; struct BlockInfo {     int blockIndex;     int firstCodePoint;     int lastCodePoint; }; static QList<BlockInfo> blockInfoList;  static void readBlocks() {     QFile f("data/Blocks.txt");     if (!f.exists())         qFatal("Couldn't find Blocks.txt");      f.open(QFile::ReadOnly);      while (!f.atEnd()) {         QByteArray line = f.readLine();         line.resize(line.size() - 1);          int comment = line.indexOf("#");         if (comment>= 0)             line = line.left(comment);          line.replace(" ", "");          if (line.isEmpty())             continue;          int semicolon = line.indexOf(';');         Q_ASSERT(semicolon>= 0);         QByteArray codePoints = line.left(semicolon);         QByteArray blockName = line.mid(semicolon + 1);          int blockIndex = blockNames.indexOf(blockName);         if (blockIndex == -1) {             blockIndex = blockNames.size();             blockNames.append(blockName);         }          codePoints.replace("..", ".");         QList<QByteArray> cl = codePoints.split('.');          bool ok;         int first = cl[0].toInt(&ok, 16);         Q_ASSERT(ok);         int last = first;         if (cl.size() == 2) {             last = cl[1].toInt(&ok, 16);             Q_ASSERT(ok);         }          BlockInfo blockInfo = { blockIndex, first, last };         blockInfoList.append(blockInfo);     } }
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|scriptNames
specifier|static
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|scriptNames
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|scriptAssignment
specifier|static
name|QHash
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|scriptAssignment
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|scriptHash
specifier|static
name|QHash
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|scriptHash
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|ExtraBlock
struct|struct
name|ExtraBlock
block|{
DECL|member|block
name|int
name|block
decl_stmt|;
DECL|member|vector
name|QVector
argument_list|<
name|int
argument_list|>
name|vector
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|extraBlockList
specifier|static
name|QList
argument_list|<
name|ExtraBlock
argument_list|>
name|extraBlockList
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|readScripts
specifier|static
name|void
name|readScripts
parameter_list|()
block|{
name|scriptNames
operator|.
name|append
argument_list|(
literal|"Common"
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|files
index|[]
init|=
block|{
literal|"data/ScriptsInitial.txt"
block|,
literal|"data/Scripts.txt"
block|,
literal|"data/ScriptsCorrections.txt"
block|}
decl_stmt|;
enum|enum
block|{
name|fileCount
init|=
sizeof|sizeof
argument_list|(
name|files
argument_list|)
operator|/
expr|sizeof
operator|(
specifier|const
name|char
operator|*
operator|)
block|}
enum|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileCount
condition|;
operator|++
name|i
control|)
block|{
name|QFile
name|f
argument_list|(
name|files
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find %s"
argument_list|,
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
init|=
name|f
operator|.
name|readLine
argument_list|()
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|line
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|"#"
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|"_"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|int
name|semicolon
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|semicolon
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|QByteArray
name|codePoints
init|=
name|line
operator|.
name|left
argument_list|(
name|semicolon
argument_list|)
decl_stmt|;
name|QByteArray
name|scriptName
init|=
name|line
operator|.
name|mid
argument_list|(
name|semicolon
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|scriptIndex
init|=
name|scriptNames
operator|.
name|indexOf
argument_list|(
name|scriptName
argument_list|)
decl_stmt|;
if|if
condition|(
name|scriptIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|scriptIndex
operator|=
name|scriptNames
operator|.
name|size
argument_list|()
expr_stmt|;
name|scriptNames
operator|.
name|append
argument_list|(
name|scriptName
argument_list|)
expr_stmt|;
block|}
name|codePoints
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codePoints
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|first
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|last
init|=
name|first
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|last
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|first
init|;
name|i
operator|<=
name|last
condition|;
operator|++
name|i
control|)
name|scriptAssignment
index|[
name|i
index|]
operator|=
name|scriptIndex
expr_stmt|;
block|}
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|scriptSentinel
specifier|static
name|int
name|scriptSentinel
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|createScriptEnumDeclaration
name|QByteArray
name|createScriptEnumDeclaration
parameter_list|()
block|{
specifier|static
specifier|const
name|char
modifier|*
name|specialScripts
index|[]
init|=
block|{
literal|"Common"
block|,
literal|"Arabic"
block|,
literal|"Armenian"
block|,
literal|"Bengali"
block|,
literal|"Cyrillic"
block|,
literal|"Devanagari"
block|,
literal|"Georgian"
block|,
literal|"Greek"
block|,
literal|"Gujarati"
block|,
literal|"Gurmukhi"
block|,
literal|"Hangul"
block|,
literal|"Hebrew"
block|,
literal|"Kannada"
block|,
literal|"Khmer"
block|,
literal|"Lao"
block|,
literal|"Malayalam"
block|,
literal|"Myanmar"
block|,
literal|"Nko"
block|,
literal|"Ogham"
block|,
literal|"Oriya"
block|,
literal|"Runic"
block|,
literal|"Sinhala"
block|,
literal|"Syriac"
block|,
literal|"Tamil"
block|,
literal|"Telugu"
block|,
literal|"Thaana"
block|,
literal|"Thai"
block|,
literal|"Tibetan"
block|,
literal|"Inherited"
block|}
decl_stmt|;
specifier|const
name|int
name|specialScriptsCount
init|=
sizeof|sizeof
argument_list|(
name|specialScripts
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
comment|// generate script enum
name|QByteArray
name|declaration
decl_stmt|;
name|declaration
operator|+=
literal|"    // See http://www.unicode.org/reports/tr24/tr24-5.html\n"
expr_stmt|;
name|declaration
operator|+=
literal|"    enum Script {\n        Common"
expr_stmt|;
name|int
name|uniqueScripts
init|=
literal|1
decl_stmt|;
comment|// Common
comment|// output the ones with special processing first
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|scriptNames
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QByteArray
name|scriptName
init|=
name|scriptNames
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// does the script require special processing?
name|bool
name|special
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|specialScriptsCount
condition|;
operator|++
name|s
control|)
block|{
if|if
condition|(
name|scriptName
operator|==
name|specialScripts
index|[
name|s
index|]
condition|)
block|{
name|special
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|special
condition|)
block|{
name|scriptHash
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|// alias for 'Common'
continue|continue;
block|}
else|else
block|{
operator|++
name|uniqueScripts
expr_stmt|;
name|scriptHash
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|scriptName
operator|!=
literal|"Inherited"
condition|)
block|{
name|declaration
operator|+=
literal|",\n        "
expr_stmt|;
name|declaration
operator|+=
name|scriptName
expr_stmt|;
block|}
block|}
name|declaration
operator|+=
literal|",\n        Inherited"
expr_stmt|;
name|declaration
operator|+=
literal|",\n        ScriptCount = Inherited"
expr_stmt|;
comment|// output the ones that are an alias for 'Common'
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|scriptNames
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|scriptHash
operator|.
name|value
argument_list|(
name|i
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|declaration
operator|+=
literal|",\n        "
expr_stmt|;
name|declaration
operator|+=
name|scriptNames
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|declaration
operator|+=
literal|" = Common"
expr_stmt|;
block|}
name|declaration
operator|+=
literal|"\n    };\n"
expr_stmt|;
name|scriptSentinel
operator|=
operator|(
operator|(
name|uniqueScripts
operator|+
literal|16
operator|)
operator|/
literal|32
operator|)
operator|*
literal|32
expr_stmt|;
comment|// a multiple of 32
name|declaration
operator|+=
literal|"    enum { ScriptSentinel = "
expr_stmt|;
name|declaration
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|scriptSentinel
argument_list|)
expr_stmt|;
name|declaration
operator|+=
literal|" };\n\n"
expr_stmt|;
return|return
name|declaration
return|;
block|}
end_function
begin_function
DECL|function|createScriptTableDeclaration
name|QByteArray
name|createScriptTableDeclaration
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|scriptSentinel
operator|>
literal|0
argument_list|)
expr_stmt|;
name|QByteArray
name|declaration
decl_stmt|;
specifier|const
name|int
name|unicodeBlockCount
init|=
literal|512
decl_stmt|;
comment|// number of unicode blocks
specifier|const
name|int
name|unicodeBlockSize
init|=
literal|128
decl_stmt|;
comment|// size of each block
name|declaration
operator|=
literal|"enum { UnicodeBlockCount = "
expr_stmt|;
name|declaration
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|unicodeBlockCount
argument_list|)
expr_stmt|;
name|declaration
operator|+=
literal|" }; // number of unicode blocks\n"
expr_stmt|;
name|declaration
operator|+=
literal|"enum { UnicodeBlockSize = "
expr_stmt|;
name|declaration
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|unicodeBlockSize
argument_list|)
expr_stmt|;
name|declaration
operator|+=
literal|" }; // size of each block\n\n"
expr_stmt|;
comment|// script table
name|declaration
operator|+=
literal|"namespace QUnicodeTables {\n\nstatic const unsigned char uc_scripts[] = {\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|unicodeBlockCount
condition|;
operator|++
name|i
control|)
block|{
name|int
name|block
init|=
operator|(
operator|(
operator|(
name|i
operator|<<
literal|7
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|*
literal|0x80
operator|)
operator|)
decl_stmt|;
name|int
name|blockAssignment
index|[
name|unicodeBlockSize
index|]
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|unicodeBlockSize
condition|;
operator|++
name|x
control|)
block|{
name|int
name|codePoint
init|=
operator|(
name|i
operator|<<
literal|7
operator|)
operator||
name|x
decl_stmt|;
name|blockAssignment
index|[
name|x
index|]
operator|=
name|scriptAssignment
operator|.
name|value
argument_list|(
name|codePoint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bool
name|allTheSame
init|=
literal|true
decl_stmt|;
specifier|const
name|int
name|originalScript
init|=
name|blockAssignment
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|int
name|script
init|=
name|scriptHash
operator|.
name|value
argument_list|(
name|originalScript
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|1
init|;
name|allTheSame
operator|&&
name|x
operator|<
name|unicodeBlockSize
condition|;
operator|++
name|x
control|)
block|{
specifier|const
name|int
name|s
init|=
name|scriptHash
operator|.
name|value
argument_list|(
name|blockAssignment
index|[
name|x
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|script
condition|)
name|allTheSame
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|allTheSame
condition|)
block|{
name|declaration
operator|+=
literal|"    "
expr_stmt|;
name|declaration
operator|+=
name|scriptNames
operator|.
name|value
argument_list|(
name|originalScript
argument_list|)
expr_stmt|;
name|declaration
operator|+=
literal|", /* U+"
expr_stmt|;
name|declaration
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|block
argument_list|,
literal|16
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|4
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
name|declaration
operator|+=
literal|'-'
expr_stmt|;
name|declaration
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|block
operator|+
name|unicodeBlockSize
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|4
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
name|declaration
operator|+=
literal|" */\n"
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|value
init|=
name|extraBlockList
operator|.
name|size
argument_list|()
operator|+
name|scriptSentinel
decl_stmt|;
specifier|const
name|int
name|offset
init|=
operator|(
operator|(
name|value
operator|-
name|scriptSentinel
operator|)
operator|*
name|unicodeBlockSize
operator|)
operator|+
name|unicodeBlockCount
decl_stmt|;
name|declaration
operator|+=
literal|"    "
expr_stmt|;
name|declaration
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|declaration
operator|+=
literal|", /* U+"
expr_stmt|;
name|declaration
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|block
argument_list|,
literal|16
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|4
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
name|declaration
operator|+=
literal|'-'
expr_stmt|;
name|declaration
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|block
operator|+
name|unicodeBlockSize
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|4
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
name|declaration
operator|+=
literal|" at offset "
expr_stmt|;
name|declaration
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|declaration
operator|+=
literal|" */\n"
expr_stmt|;
name|ExtraBlock
name|extraBlock
decl_stmt|;
name|extraBlock
operator|.
name|block
operator|=
name|block
expr_stmt|;
name|extraBlock
operator|.
name|vector
operator|.
name|resize
argument_list|(
name|unicodeBlockSize
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|unicodeBlockSize
condition|;
operator|++
name|x
control|)
name|extraBlock
operator|.
name|vector
index|[
name|x
index|]
operator|=
name|blockAssignment
index|[
name|x
index|]
expr_stmt|;
name|extraBlockList
operator|.
name|append
argument_list|(
name|extraBlock
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|extraBlockList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|value
init|=
name|i
operator|+
name|scriptSentinel
decl_stmt|;
specifier|const
name|int
name|offset
init|=
operator|(
operator|(
name|value
operator|-
name|scriptSentinel
operator|)
operator|*
name|unicodeBlockSize
operator|)
operator|+
name|unicodeBlockCount
decl_stmt|;
specifier|const
name|ExtraBlock
modifier|&
name|extraBlock
init|=
name|extraBlockList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|int
name|block
init|=
name|extraBlock
operator|.
name|block
decl_stmt|;
name|declaration
operator|+=
literal|"\n\n    /* U+"
expr_stmt|;
name|declaration
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|block
argument_list|,
literal|16
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|4
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
name|declaration
operator|+=
literal|'-'
expr_stmt|;
name|declaration
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|block
operator|+
name|unicodeBlockSize
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|4
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
name|declaration
operator|+=
literal|" at offset "
expr_stmt|;
name|declaration
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|declaration
operator|+=
literal|" */\n    "
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|extraBlock
operator|.
name|vector
operator|.
name|size
argument_list|()
condition|;
operator|++
name|x
control|)
block|{
specifier|const
name|int
name|o
init|=
name|extraBlock
operator|.
name|vector
operator|.
name|at
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|declaration
operator|+=
name|scriptNames
operator|.
name|value
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|extraBlock
operator|.
name|vector
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|||
name|i
operator|<
name|extraBlockList
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|declaration
operator|+=
literal|','
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|7
operator|)
operator|==
literal|7
operator|&&
name|x
operator|<
name|extraBlock
operator|.
name|vector
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|declaration
operator|+=
literal|"\n    "
expr_stmt|;
else|else
name|declaration
operator|+=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|declaration
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|declaration
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|declaration
operator|+=
literal|"\n};\n\n} // namespace QUnicodeTables\n\n"
expr_stmt|;
name|declaration
operator|+=
literal|"Q_CORE_EXPORT int QT_FASTCALL QUnicodeTables::script(uint ucs4)\n"
literal|"{\n"
literal|"    if (ucs4> 0xffff)\n"
literal|"        return Common;\n"
literal|"    int script = uc_scripts[ucs4>> 7];\n"
literal|"    if (script< ScriptSentinel)\n"
literal|"        return script;\n"
literal|"    script = (((script - ScriptSentinel) * UnicodeBlockSize) + UnicodeBlockCount);\n"
literal|"    script = uc_scripts[script + (ucs4& 0x7f)];\n"
literal|"    return script;\n"
literal|"}\n\n"
expr_stmt|;
name|qDebug
argument_list|(
literal|"createScriptTableDeclaration: table size is %d bytes"
argument_list|,
name|unicodeBlockCount
operator|+
operator|(
name|extraBlockList
operator|.
name|size
argument_list|()
operator|*
name|unicodeBlockSize
operator|)
argument_list|)
expr_stmt|;
return|return
name|declaration
return|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|static void dump(int from, int to) {     for (int i = from; i<= to; ++i) {         UnicodeData d = unicodeData.value(i, UnicodeData(i));         qDebug("0x%04x: cat=%d combining=%d dir=%d case=%x mirror=%x joining=%d age=%d",                i, d.p.category, d.p.combiningClass, d.p.direction, d.otherCase, d.mirroredChar, d.p.joining, d.p.age);         if (d.decompositionType != QChar::NoDecomposition) {             qDebug("    decomposition: type=%d, length=%d, first=%x", d.decompositionType, d.decomposition.size(),                    d.decomposition[0]);         }     }     qDebug(" "); }
endif|#
directive|endif
end_endif
begin_struct
DECL|struct|PropertyBlock
struct|struct
name|PropertyBlock
block|{
DECL|function|PropertyBlock
name|PropertyBlock
parameter_list|()
block|{
name|index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
DECL|member|index
name|int
name|index
decl_stmt|;
DECL|member|properties
name|QList
argument_list|<
name|int
argument_list|>
name|properties
decl_stmt|;
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|PropertyBlock
modifier|&
name|other
parameter_list|)
block|{
return|return
name|properties
operator|==
name|other
operator|.
name|properties
return|;
block|}
block|}
struct|;
end_struct
begin_function
DECL|function|createPropertyInfo
specifier|static
name|QByteArray
name|createPropertyInfo
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"createPropertyInfo:"
argument_list|)
expr_stmt|;
specifier|const
name|int
name|BMP_BLOCKSIZE
init|=
literal|32
decl_stmt|;
specifier|const
name|int
name|BMP_SHIFT
init|=
literal|5
decl_stmt|;
specifier|const
name|int
name|BMP_END
init|=
literal|0x11000
decl_stmt|;
specifier|const
name|int
name|SMP_END
init|=
literal|0x110000
decl_stmt|;
specifier|const
name|int
name|SMP_BLOCKSIZE
init|=
literal|256
decl_stmt|;
specifier|const
name|int
name|SMP_SHIFT
init|=
literal|8
decl_stmt|;
name|QList
argument_list|<
name|PropertyBlock
argument_list|>
name|blocks
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|blockMap
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
literal|0
init|;
name|block
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|PropertyBlock
name|b
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|BMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|UnicodeData
name|d
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|uc
argument_list|,
name|UnicodeData
argument_list|(
name|uc
argument_list|)
argument_list|)
decl_stmt|;
name|b
operator|.
name|properties
operator|.
name|append
argument_list|(
name|d
operator|.
name|propertyIndex
argument_list|)
expr_stmt|;
block|}
name|int
name|index
init|=
name|blocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|blocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|BMP_BLOCKSIZE
expr_stmt|;
name|blocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|blocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|bmp_blocks
init|=
name|blocks
operator|.
name|size
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|blockMap
operator|.
name|size
argument_list|()
operator|==
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|block
init|=
name|BMP_END
operator|/
name|SMP_BLOCKSIZE
init|;
name|block
operator|<
name|SMP_END
operator|/
name|SMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|PropertyBlock
name|b
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|SMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|UnicodeData
name|d
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|uc
argument_list|,
name|UnicodeData
argument_list|(
name|uc
argument_list|)
argument_list|)
decl_stmt|;
name|b
operator|.
name|properties
operator|.
name|append
argument_list|(
name|d
operator|.
name|propertyIndex
argument_list|)
expr_stmt|;
block|}
name|int
name|index
init|=
name|blocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|blocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|SMP_BLOCKSIZE
expr_stmt|;
name|blocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|blocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|bmp_block_data
init|=
name|bmp_blocks
operator|*
name|BMP_BLOCKSIZE
operator|*
literal|2
decl_stmt|;
name|int
name|bmp_trie
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
operator|*
literal|2
decl_stmt|;
name|int
name|bmp_mem
init|=
name|bmp_block_data
operator|+
name|bmp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in BMP."
argument_list|,
name|blocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|bmp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|bmp_trie
argument_list|)
expr_stmt|;
name|int
name|smp_block_data
init|=
operator|(
name|blocks
operator|.
name|size
argument_list|()
operator|-
name|bmp_blocks
operator|)
operator|*
name|SMP_BLOCKSIZE
operator|*
literal|2
decl_stmt|;
name|int
name|smp_trie
init|=
operator|(
name|SMP_END
operator|-
name|BMP_END
operator|)
operator|/
name|SMP_BLOCKSIZE
operator|*
literal|2
decl_stmt|;
name|int
name|smp_mem
init|=
name|smp_block_data
operator|+
name|smp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in SMP."
argument_list|,
name|blocks
operator|.
name|size
argument_list|()
operator|-
name|bmp_blocks
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|smp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|smp_trie
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"\n        properties uses : %d bytes"
argument_list|,
name|uniqueProperties
operator|.
name|size
argument_list|()
operator|*
name|SizeOfPropertiesStruct
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"    memory usage: %d bytes"
argument_list|,
name|bmp_mem
operator|+
name|smp_mem
operator|+
name|uniqueProperties
operator|.
name|size
argument_list|()
operator|*
name|SizeOfPropertiesStruct
argument_list|)
expr_stmt|;
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"static const unsigned short uc_property_trie[] = {\n"
expr_stmt|;
comment|// first write the map
name|out
operator|+=
literal|"    // 0 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|i
operator|*
name|BMP_BLOCKSIZE
operator|)
operator|%
literal|0x1000
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n\n    // 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|"\n"
expr_stmt|;
empty_stmt|;
for|for
control|(
name|int
name|i
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
init|;
name|i
operator|<
name|blockMap
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
operator|(
literal|0x10000
operator|/
name|SMP_BLOCKSIZE
operator|)
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
comment|// write the data
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
specifier|const
name|PropertyBlock
modifier|&
name|b
init|=
name|blocks
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|b
operator|.
name|properties
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|j
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|b
operator|.
name|properties
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
comment|// we reserve one bit more than in the assert below for the sign
name|Q_ASSERT
argument_list|(
name|maxMirroredDiff
operator|<
operator|(
literal|1
operator|<<
literal|12
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|maxLowerCaseDiff
operator|<
operator|(
literal|1
operator|<<
literal|14
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|maxUpperCaseDiff
operator|<
operator|(
literal|1
operator|<<
literal|14
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|maxTitleCaseDiff
operator|<
operator|(
literal|1
operator|<<
literal|14
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|maxCaseFoldDiff
operator|<
operator|(
literal|1
operator|<<
literal|14
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
literal|"#define GET_PROP_INDEX(ucs4) \\\n"
literal|"       (ucs4< 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" \\\n"
literal|"        ? (uc_property_trie[uc_property_trie[ucs4>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_SHIFT
argument_list|)
operator|+
literal|"] + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")]) \\\n"
literal|"        : (uc_property_trie[uc_property_trie[((ucs4 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|")>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_SHIFT
argument_list|)
operator|+
literal|") + 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
argument_list|,
literal|16
argument_list|)
operator|+
literal|"]"
literal|" + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")]))\n\n"
literal|"#define GET_PROP_INDEX_UCS2(ucs2) \\\n"
literal|"(uc_property_trie[uc_property_trie[ucs2>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_SHIFT
argument_list|)
operator|+
literal|"] + (ucs2& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")])\n\n"
literal|"static const QUnicodeTables::Properties uc_properties[] = {\n"
expr_stmt|;
comment|// keep in sync with the property declaration
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uniqueProperties
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|PropertyFlags
name|p
init|=
name|uniqueProperties
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|out
operator|+=
literal|"    { "
expr_stmt|;
comment|//     "        ushort category : 8;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|category
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort line_break_class : 8;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|line_break_class
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort direction : 8;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|direction
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort combiningClass :8;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|combiningClass
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort joining : 2;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|joining
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        signed short digitValue : 6;\n /* 5 needed */"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|digitValue
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort unicodeVersion : 4;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|age
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort lowerCaseSpecial : 1;\n"
comment|//     "        ushort upperCaseSpecial : 1;\n"
comment|//     "        ushort titleCaseSpecial : 1;\n"
comment|//     "        ushort caseFoldSpecial : 1;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|lowerCaseSpecial
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|upperCaseSpecial
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|titleCaseSpecial
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|caseFoldSpecial
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        signed short mirrorDiff : 16;\n"
comment|//     "        signed short lowerCaseDiff : 16;\n"
comment|//     "        signed short upperCaseDiff : 16;\n"
comment|//     "        signed short titleCaseDiff : 16;\n"
comment|//     "        signed short caseFoldDiff : 16;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|mirrorDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|lowerCaseDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|upperCaseDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|titleCaseDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|caseFoldDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|graphemeBreak
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|wordBreak
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|sentenceBreak
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|" },\n"
expr_stmt|;
block|}
name|out
operator|+=
literal|"};\n\n"
expr_stmt|;
name|out
operator|+=
literal|"static inline const QUnicodeTables::Properties *qGetProp(uint ucs4)\n"
literal|"{\n"
literal|"    int index = GET_PROP_INDEX(ucs4);\n"
literal|"    return uc_properties + index;\n"
literal|"}\n"
literal|"\n"
literal|"static inline const QUnicodeTables::Properties *qGetProp(ushort ucs2)\n"
literal|"{\n"
literal|"    int index = GET_PROP_INDEX_UCS2(ucs2);\n"
literal|"    return uc_properties + index;\n"
literal|"}\n"
literal|"\n"
literal|"Q_CORE_EXPORT const QUnicodeTables::Properties * QT_FASTCALL QUnicodeTables::properties(uint ucs4)\n"
literal|"{\n"
literal|"    int index = GET_PROP_INDEX(ucs4);\n"
literal|"    return uc_properties + index;\n"
literal|"}\n"
literal|"\n"
literal|"Q_CORE_EXPORT const QUnicodeTables::Properties * QT_FASTCALL QUnicodeTables::properties(ushort ucs2)\n"
literal|"{\n"
literal|"    int index = GET_PROP_INDEX_UCS2(ucs2);\n"
literal|"    return uc_properties + index;\n"
literal|"}\n\n"
expr_stmt|;
name|out
operator|+=
literal|"Q_CORE_EXPORT QUnicodeTables::LineBreakClass QT_FASTCALL QUnicodeTables::lineBreakClass(uint ucs4)\n"
literal|"{\n"
literal|"    return (QUnicodeTables::LineBreakClass)qGetProp(ucs4)->line_break_class;\n"
literal|"}\n\n"
expr_stmt|;
name|out
operator|+=
literal|"static const ushort specialCaseMap[] = {\n   "
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|specialCaseMap
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|out
operator|+=
name|QByteArray
argument_list|(
literal|" 0x"
argument_list|)
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|specialCaseMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|specialCaseMap
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|out
operator|+=
literal|","
expr_stmt|;
if|if
condition|(
operator|!
name|specialCaseMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
name|out
operator|+=
literal|"\n   "
expr_stmt|;
block|}
name|out
operator|+=
literal|"\n};\n"
expr_stmt|;
name|out
operator|+=
literal|"#define SPECIAL_CASE_MAX_LEN "
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|specialCaseMaxLen
argument_list|)
operator|+
literal|"\n\n"
expr_stmt|;
name|qDebug
argument_list|(
literal|"Special case map uses : %d bytes"
argument_list|,
name|specialCaseMap
operator|.
name|size
argument_list|()
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_struct
DECL|struct|DecompositionBlock
struct|struct
name|DecompositionBlock
block|{
DECL|function|DecompositionBlock
name|DecompositionBlock
parameter_list|()
block|{
name|index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
DECL|member|index
name|int
name|index
decl_stmt|;
DECL|member|decompositionPositions
name|QList
argument_list|<
name|int
argument_list|>
name|decompositionPositions
decl_stmt|;
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|DecompositionBlock
modifier|&
name|other
parameter_list|)
block|{
return|return
name|decompositionPositions
operator|==
name|other
operator|.
name|decompositionPositions
return|;
block|}
block|}
struct|;
end_struct
begin_function
DECL|function|createCompositionInfo
specifier|static
name|QByteArray
name|createCompositionInfo
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"createCompositionInfo:"
argument_list|)
expr_stmt|;
specifier|const
name|int
name|BMP_BLOCKSIZE
init|=
literal|16
decl_stmt|;
specifier|const
name|int
name|BMP_SHIFT
init|=
literal|4
decl_stmt|;
specifier|const
name|int
name|BMP_END
init|=
literal|0x3400
decl_stmt|;
comment|// start of Han
specifier|const
name|int
name|SMP_END
init|=
literal|0x30000
decl_stmt|;
specifier|const
name|int
name|SMP_BLOCKSIZE
init|=
literal|256
decl_stmt|;
specifier|const
name|int
name|SMP_SHIFT
init|=
literal|8
decl_stmt|;
if|if
condition|(
name|SMP_END
operator|<=
name|highestComposedCharacter
condition|)
name|qFatal
argument_list|(
literal|"end of table smaller than highest composed character at %x"
argument_list|,
name|highestComposedCharacter
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|DecompositionBlock
argument_list|>
name|blocks
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|blockMap
decl_stmt|;
name|QList
argument_list|<
name|unsigned
name|short
argument_list|>
name|decompositions
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
name|int
name|tableIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
literal|0
init|;
name|block
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|DecompositionBlock
name|b
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|BMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|UnicodeData
name|d
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|uc
argument_list|,
name|UnicodeData
argument_list|(
name|uc
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|decomposition
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|utf16Chars
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|.
name|decomposition
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
name|utf16Chars
operator|+=
name|d
operator|.
name|decomposition
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|>=
literal|0x10000
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|decompositions
operator|.
name|append
argument_list|(
name|d
operator|.
name|decompositionType
operator|+
operator|(
name|utf16Chars
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|.
name|decomposition
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|int
name|code
init|=
name|d
operator|.
name|decomposition
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0x10000
condition|)
block|{
comment|// save as surrogate pair
name|ushort
name|high
init|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|ushort
name|low
init|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|decompositions
operator|.
name|append
argument_list|(
name|high
argument_list|)
expr_stmt|;
name|decompositions
operator|.
name|append
argument_list|(
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decompositions
operator|.
name|append
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|.
name|decompositionPositions
operator|.
name|append
argument_list|(
name|tableIndex
argument_list|)
expr_stmt|;
name|tableIndex
operator|+=
name|utf16Chars
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|decompositionPositions
operator|.
name|append
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|index
init|=
name|blocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|blocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|BMP_BLOCKSIZE
expr_stmt|;
name|blocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|blocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|bmp_blocks
init|=
name|blocks
operator|.
name|size
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|blockMap
operator|.
name|size
argument_list|()
operator|==
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|block
init|=
name|BMP_END
operator|/
name|SMP_BLOCKSIZE
init|;
name|block
operator|<
name|SMP_END
operator|/
name|SMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|DecompositionBlock
name|b
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|SMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|UnicodeData
name|d
init|=
name|unicodeData
operator|.
name|value
argument_list|(
name|uc
argument_list|,
name|UnicodeData
argument_list|(
name|uc
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|decomposition
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|utf16Chars
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|.
name|decomposition
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
name|utf16Chars
operator|+=
name|d
operator|.
name|decomposition
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|>=
literal|0x10000
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|decompositions
operator|.
name|append
argument_list|(
name|d
operator|.
name|decompositionType
operator|+
operator|(
name|utf16Chars
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|.
name|decomposition
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|int
name|code
init|=
name|d
operator|.
name|decomposition
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0x10000
condition|)
block|{
comment|// save as surrogate pair
name|ushort
name|high
init|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|ushort
name|low
init|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|decompositions
operator|.
name|append
argument_list|(
name|high
argument_list|)
expr_stmt|;
name|decompositions
operator|.
name|append
argument_list|(
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decompositions
operator|.
name|append
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|.
name|decompositionPositions
operator|.
name|append
argument_list|(
name|tableIndex
argument_list|)
expr_stmt|;
name|tableIndex
operator|+=
name|utf16Chars
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|decompositionPositions
operator|.
name|append
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|index
init|=
name|blocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|blocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|SMP_BLOCKSIZE
expr_stmt|;
name|blocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|blocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|bmp_block_data
init|=
name|bmp_blocks
operator|*
name|BMP_BLOCKSIZE
operator|*
literal|2
decl_stmt|;
name|int
name|bmp_trie
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
operator|*
literal|2
decl_stmt|;
name|int
name|bmp_mem
init|=
name|bmp_block_data
operator|+
name|bmp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in BMP."
argument_list|,
name|blocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|bmp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|bmp_trie
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        memory usage: %d bytes"
argument_list|,
name|bmp_mem
argument_list|)
expr_stmt|;
name|int
name|smp_block_data
init|=
operator|(
name|blocks
operator|.
name|size
argument_list|()
operator|-
name|bmp_blocks
operator|)
operator|*
name|SMP_BLOCKSIZE
operator|*
literal|2
decl_stmt|;
name|int
name|smp_trie
init|=
operator|(
name|SMP_END
operator|-
name|BMP_END
operator|)
operator|/
name|SMP_BLOCKSIZE
operator|*
literal|2
decl_stmt|;
name|int
name|smp_mem
init|=
name|smp_block_data
operator|+
name|smp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in SMP."
argument_list|,
name|blocks
operator|.
name|size
argument_list|()
operator|-
name|bmp_blocks
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|smp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|smp_trie
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"\n        decomposition table use : %d bytes"
argument_list|,
name|decompositions
operator|.
name|size
argument_list|()
operator|*
literal|2
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"    memory usage: %d bytes"
argument_list|,
name|bmp_mem
operator|+
name|smp_mem
operator|+
name|decompositions
operator|.
name|size
argument_list|()
operator|*
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"static const unsigned short uc_decomposition_trie[] = {\n"
expr_stmt|;
comment|// first write the map
name|out
operator|+=
literal|"    // 0 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|i
operator|*
name|BMP_BLOCKSIZE
operator|)
operator|%
literal|0x1000
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n\n    // 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|"\n"
expr_stmt|;
empty_stmt|;
for|for
control|(
name|int
name|i
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
init|;
name|i
operator|<
name|blockMap
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
operator|(
literal|0x10000
operator|/
name|SMP_BLOCKSIZE
operator|)
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
comment|// write the data
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
specifier|const
name|DecompositionBlock
modifier|&
name|b
init|=
name|blocks
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|b
operator|.
name|decompositionPositions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|j
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
literal|"0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|b
operator|.
name|decompositionPositions
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
literal|"#define GET_DECOMPOSITION_INDEX(ucs4) \\\n"
literal|"       (ucs4< 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" \\\n"
literal|"        ? (uc_decomposition_trie[uc_decomposition_trie[ucs4>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_SHIFT
argument_list|)
operator|+
literal|"] + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")]) \\\n"
literal|"        : (ucs4< 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|"\\\n"
literal|"           ? uc_decomposition_trie[uc_decomposition_trie[((ucs4 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|")>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_SHIFT
argument_list|)
operator|+
literal|") + 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
argument_list|,
literal|16
argument_list|)
operator|+
literal|"]"
literal|" + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")]\\\n"
literal|"           : 0xffff))\n\n"
literal|"static const unsigned short uc_decomposition_map[] = {\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|decompositions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
literal|"0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|decompositions
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|createLigatureInfo
specifier|static
name|QByteArray
name|createLigatureInfo
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"createLigatureInfo: numLigatures=%d"
argument_list|,
name|numLigatures
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|DecompositionBlock
argument_list|>
name|blocks
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|blockMap
decl_stmt|;
name|QList
argument_list|<
name|unsigned
name|short
argument_list|>
name|ligatures
decl_stmt|;
specifier|const
name|int
name|BMP_BLOCKSIZE
init|=
literal|32
decl_stmt|;
specifier|const
name|int
name|BMP_SHIFT
init|=
literal|5
decl_stmt|;
specifier|const
name|int
name|BMP_END
init|=
literal|0x3100
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|highestLigature
operator|<
name|BMP_END
argument_list|)
expr_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
name|int
name|tableIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
literal|0
init|;
name|block
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|DecompositionBlock
name|b
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|BMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|QList
argument_list|<
name|Ligature
argument_list|>
name|l
init|=
name|ligatureHashes
operator|.
name|value
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|l
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qSort
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ligatures
operator|.
name|append
argument_list|(
name|l
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|u2
operator|==
name|uc
argument_list|)
expr_stmt|;
name|ligatures
operator|.
name|append
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|u1
argument_list|)
expr_stmt|;
name|ligatures
operator|.
name|append
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|ligature
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|decompositionPositions
operator|.
name|append
argument_list|(
name|tableIndex
argument_list|)
expr_stmt|;
name|tableIndex
operator|+=
literal|2
operator|*
name|l
operator|.
name|size
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|decompositionPositions
operator|.
name|append
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|index
init|=
name|blocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|blocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|BMP_BLOCKSIZE
expr_stmt|;
name|blocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|blocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|bmp_blocks
init|=
name|blocks
operator|.
name|size
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|blockMap
operator|.
name|size
argument_list|()
operator|==
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
argument_list|)
expr_stmt|;
name|int
name|bmp_block_data
init|=
name|bmp_blocks
operator|*
name|BMP_BLOCKSIZE
operator|*
literal|2
decl_stmt|;
name|int
name|bmp_trie
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
operator|*
literal|2
decl_stmt|;
name|int
name|bmp_mem
init|=
name|bmp_block_data
operator|+
name|bmp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in BMP."
argument_list|,
name|blocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|bmp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|bmp_trie
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"\n        ligature data uses : %d bytes"
argument_list|,
name|ligatures
operator|.
name|size
argument_list|()
operator|*
literal|2
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"    memory usage: %d bytes"
argument_list|,
name|bmp_mem
operator|+
name|ligatures
operator|.
name|size
argument_list|()
operator|*
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"static const unsigned short uc_ligature_trie[] = {\n"
expr_stmt|;
comment|// first write the map
name|out
operator|+=
literal|"    // 0 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|i
operator|*
name|BMP_BLOCKSIZE
operator|)
operator|%
literal|0x1000
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
comment|// write the data
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
specifier|const
name|DecompositionBlock
modifier|&
name|b
init|=
name|blocks
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|b
operator|.
name|decompositionPositions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|j
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
literal|"0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|b
operator|.
name|decompositionPositions
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
literal|"#define GET_LIGATURE_INDEX(u2) "
literal|"(u2< 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" ? "
literal|"uc_ligature_trie[uc_ligature_trie[u2>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_SHIFT
argument_list|)
operator|+
literal|"] + (u2& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")] : 0xffff);\n\n"
literal|"static const unsigned short uc_ligature_map[] = {\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ligatures
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
literal|"0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|ligatures
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|createCasingInfo
name|QByteArray
name|createCasingInfo
parameter_list|()
block|{
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"struct CasingInfo {\n"
literal|"    uint codePoint : 16;\n"
literal|"    uint flags : 8;\n"
literal|"    uint offset : 8;\n"
literal|"};\n\n"
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
block|{
name|initAgeMap
argument_list|()
expr_stmt|;
name|initCategoryMap
argument_list|()
expr_stmt|;
name|initDecompositionMap
argument_list|()
expr_stmt|;
name|initDirectionMap
argument_list|()
expr_stmt|;
name|initJoiningMap
argument_list|()
expr_stmt|;
name|initGraphemeBreak
argument_list|()
expr_stmt|;
name|initWordBreak
argument_list|()
expr_stmt|;
name|initSentenceBreak
argument_list|()
expr_stmt|;
name|initLineBreak
argument_list|()
expr_stmt|;
name|readUnicodeData
argument_list|()
expr_stmt|;
name|readBidiMirroring
argument_list|()
expr_stmt|;
name|readArabicShaping
argument_list|()
expr_stmt|;
name|readDerivedAge
argument_list|()
expr_stmt|;
name|readDerivedNormalizationProps
argument_list|()
expr_stmt|;
name|readSpecialCasing
argument_list|()
expr_stmt|;
name|readCaseFolding
argument_list|()
expr_stmt|;
comment|// readBlocks();
name|readScripts
argument_list|()
expr_stmt|;
name|readGraphemeBreak
argument_list|()
expr_stmt|;
name|readWordBreak
argument_list|()
expr_stmt|;
name|readSentenceBreak
argument_list|()
expr_stmt|;
name|readLineBreak
argument_list|()
expr_stmt|;
name|computeUniqueProperties
argument_list|()
expr_stmt|;
name|QByteArray
name|properties
init|=
name|createPropertyInfo
argument_list|()
decl_stmt|;
name|QByteArray
name|compositions
init|=
name|createCompositionInfo
argument_list|()
decl_stmt|;
name|QByteArray
name|ligatures
init|=
name|createLigatureInfo
argument_list|()
decl_stmt|;
name|QByteArray
name|normalizationCorrections
init|=
name|createNormalizationCorrections
argument_list|()
decl_stmt|;
name|QByteArray
name|scriptEnumDeclaration
init|=
name|createScriptEnumDeclaration
argument_list|()
decl_stmt|;
name|QByteArray
name|scriptTableDeclaration
init|=
name|createScriptTableDeclaration
argument_list|()
decl_stmt|;
name|QByteArray
name|header
init|=
literal|"/****************************************************************************\n"
literal|"**\n"
literal|"** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).\n"
literal|"** Contact: http://www.qt-project.org/\n"
literal|"**\n"
literal|"** This file is part of the QtCore module of the Qt Toolkit.\n"
literal|"**\n"
literal|"** $QT_BEGIN_LICENSE:LGPL$\n"
literal|"** GNU Lesser General Public License Usage\n"
literal|"** This file may be used under the terms of the GNU Lesser General Public\n"
literal|"** License version 2.1 as published by the Free Software Foundation and\n"
literal|"** appearing in the file LICENSE.LGPL included in the packaging of this\n"
literal|"** file. Please review the following information to ensure the GNU Lesser\n"
literal|"** General Public License version 2.1 requirements will be met:\n"
literal|"** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.\n"
literal|"**\n"
literal|"** In addition, as a special exception, Nokia gives you certain additional\n"
literal|"** rights. These rights are described in the Nokia Qt LGPL Exception\n"
literal|"** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.\n"
literal|"**\n"
literal|"** GNU General Public License Usage\n"
literal|"** Alternatively, this file may be used under the terms of the GNU General\n"
literal|"** Public License version 3.0 as published by the Free Software Foundation\n"
literal|"** and appearing in the file LICENSE.GPL included in the packaging of this\n"
literal|"** file. Please review the following information to ensure the GNU General\n"
literal|"** Public License version 3.0 requirements will be met:\n"
literal|"** http://www.gnu.org/copyleft/gpl.html.\n"
literal|"**\n"
literal|"** Other Usage\n"
literal|"** Alternatively, this file may be used in accordance with the terms and\n"
literal|"** conditions contained in a signed written agreement between you and Nokia.\n"
literal|"**\n"
literal|"**\n"
literal|"**\n"
literal|"**\n"
literal|"**\n"
literal|"**\n"
literal|"** $QT_END_LICENSE$\n"
literal|"**\n"
literal|"****************************************************************************/\n\n"
decl_stmt|;
name|QByteArray
name|note
init|=
literal|"/* This file is autogenerated from the Unicode "
name|DATA_VERSION_S
literal|" database. Do not edit */\n\n"
decl_stmt|;
name|QByteArray
name|warning
init|=
literal|"//\n"
literal|"//  W A R N I N G\n"
literal|"//  -------------\n"
literal|"//\n"
literal|"// This file is not part of the Qt API.  It exists for the convenience\n"
literal|"// of internal files.  This header file may change from version to version\n"
literal|"// without notice, or even be removed.\n"
literal|"//\n"
literal|"// We mean it.\n"
literal|"//\n\n"
decl_stmt|;
name|QFile
name|f
argument_list|(
literal|"../../src/corelib/tools/qunicodetables.cpp"
argument_list|)
decl_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
operator||
name|QFile
operator|::
name|Truncate
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"QT_BEGIN_NAMESPACE\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|properties
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|compositions
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|ligatures
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|normalizationCorrections
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|scriptTableDeclaration
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"QT_END_NAMESPACE\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|close
argument_list|()
expr_stmt|;
name|f
operator|.
name|setFileName
argument_list|(
literal|"../../src/corelib/tools/qunicodetables_p.h"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
operator||
name|QFile
operator|::
name|Truncate
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|warning
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"#ifndef QUNICODETABLES_P_H\n"
literal|"#define QUNICODETABLES_P_H\n\n"
literal|"#include<QtCore/qchar.h>\n\n"
literal|"QT_BEGIN_NAMESPACE\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"#define UNICODE_DATA_VERSION "
name|DATA_VERSION_STR
literal|"\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"#define UNICODE_LAST_CODEPOINT "
name|LAST_CODEPOINT_STR
literal|"\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"namespace QUnicodeTables {\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|property_string
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|scriptEnumDeclaration
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|grapheme_break_string
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|word_break_string
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|sentence_break_string
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|lineBreakClass
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|methods
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"} // namespace QUnicodeTables\n\n"
literal|"QT_END_NAMESPACE\n\n"
literal|"#endif // QUNICODETABLES_P_H\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|close
argument_list|()
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxMirroredDiff  = "
operator|<<
name|hex
operator|<<
name|maxMirroredDiff
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxLowerCaseDiff = "
operator|<<
name|hex
operator|<<
name|maxLowerCaseDiff
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxUpperCaseDiff = "
operator|<<
name|hex
operator|<<
name|maxUpperCaseDiff
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxTitleCaseDiff = "
operator|<<
name|hex
operator|<<
name|maxTitleCaseDiff
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxCaseFoldDiff  = "
operator|<<
name|hex
operator|<<
name|maxCaseFoldDiff
expr_stmt|;
if|#
directive|if
literal|0
comment|//     dump(0, 0x7f);
comment|//     dump(0x620, 0x640);
comment|//     dump(0x10000, 0x10020);
comment|//     dump(0x10800, 0x10820);
block|qDebug("decompositionLength used:");     int totalcompositions = 0;     int sum = 0;     for (int i = 1; i< 20; ++i) {         qDebug("    length %d used %d times", i, decompositionLength.value(i, 0));         totalcompositions += i*decompositionLength.value(i, 0);         sum += decompositionLength.value(i, 0);     }     qDebug("    len decomposition map %d, average length %f, num composed chars %d",            totalcompositions, (float)totalcompositions/(float)sum, sum);     qDebug("highest composed character %x", highestComposedCharacter);     qDebug("num ligatures = %d highest=%x, maxLength=%d", numLigatures, highestLigature, longestLigature);      qBubbleSort(ligatures);     for (int i = 0; i< ligatures.size(); ++i)         qDebug("%s", ligatures.at(i).data());
comment|//     qDebug("combiningClass usage:");
comment|//     int numClasses = 0;
comment|//     for (int i = 0; i< 255; ++i) {
comment|//         int num = combiningClassUsage.value(i, 0);
comment|//         if (num) {
comment|//             ++numClasses;
comment|//             qDebug("    combiningClass %d used %d times", i, num);
comment|//         }
comment|//     }
comment|//     qDebug("total of %d combining classes used", numClasses);
endif|#
directive|endif
block|}
end_function
end_unit
