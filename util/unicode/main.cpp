begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the utils of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qlist.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qbytearray.h>
end_include
begin_include
include|#
directive|include
file|<qstring.h>
end_include
begin_include
include|#
directive|include
file|<qchar.h>
end_include
begin_include
include|#
directive|include
file|<qvector.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_if
if|#
directive|if
literal|0
end_if
begin_include
include|#
directive|include
file|<private/qunicodetables_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|DATA_VERSION_S
define|#
directive|define
name|DATA_VERSION_S
value|"8.0"
end_define
begin_define
DECL|macro|DATA_VERSION_STR
define|#
directive|define
name|DATA_VERSION_STR
value|"QChar::Unicode_8_0"
end_define
begin_decl_stmt
DECL|variable|age_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QChar
operator|::
name|UnicodeVersion
argument_list|>
name|age_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initAgeMap
specifier|static
name|void
name|initAgeMap
parameter_list|()
block|{
struct|struct
name|AgeMap
block|{
specifier|const
name|QChar
operator|::
name|UnicodeVersion
name|version
decl_stmt|;
specifier|const
name|char
modifier|*
name|age
decl_stmt|;
block|}
name|ageMap
index|[]
init|=
block|{
block|{
name|QChar
operator|::
name|Unicode_1_1
block|,
literal|"1.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_2_0
block|,
literal|"2.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_2_1_2
block|,
literal|"2.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_3_0
block|,
literal|"3.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_3_1
block|,
literal|"3.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_3_2
block|,
literal|"3.2"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_4_0
block|,
literal|"4.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_4_1
block|,
literal|"4.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_5_0
block|,
literal|"5.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_5_1
block|,
literal|"5.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_5_2
block|,
literal|"5.2"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_6_0
block|,
literal|"6.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_6_1
block|,
literal|"6.1"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_6_2
block|,
literal|"6.2"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_6_3
block|,
literal|"6.3"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_7_0
block|,
literal|"7.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_8_0
block|,
literal|"8.0"
block|}
block|,
block|{
name|QChar
operator|::
name|Unicode_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|AgeMap
modifier|*
name|d
init|=
name|ageMap
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|age
condition|)
block|{
name|age_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|age
argument_list|,
name|d
operator|->
name|version
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|categoryMap
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QChar
operator|::
name|Category
argument_list|>
name|categoryMap
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initCategoryMap
specifier|static
name|void
name|initCategoryMap
parameter_list|()
block|{
struct|struct
name|Cat
block|{
name|QChar
operator|::
name|Category
name|cat
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|categories
index|[]
init|=
block|{
block|{
name|QChar
operator|::
name|Mark_NonSpacing
block|,
literal|"Mn"
block|}
block|,
block|{
name|QChar
operator|::
name|Mark_SpacingCombining
block|,
literal|"Mc"
block|}
block|,
block|{
name|QChar
operator|::
name|Mark_Enclosing
block|,
literal|"Me"
block|}
block|,
block|{
name|QChar
operator|::
name|Number_DecimalDigit
block|,
literal|"Nd"
block|}
block|,
block|{
name|QChar
operator|::
name|Number_Letter
block|,
literal|"Nl"
block|}
block|,
block|{
name|QChar
operator|::
name|Number_Other
block|,
literal|"No"
block|}
block|,
block|{
name|QChar
operator|::
name|Separator_Space
block|,
literal|"Zs"
block|}
block|,
block|{
name|QChar
operator|::
name|Separator_Line
block|,
literal|"Zl"
block|}
block|,
block|{
name|QChar
operator|::
name|Separator_Paragraph
block|,
literal|"Zp"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_Control
block|,
literal|"Cc"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_Format
block|,
literal|"Cf"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_Surrogate
block|,
literal|"Cs"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_PrivateUse
block|,
literal|"Co"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_NotAssigned
block|,
literal|"Cn"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Uppercase
block|,
literal|"Lu"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Lowercase
block|,
literal|"Ll"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Titlecase
block|,
literal|"Lt"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Modifier
block|,
literal|"Lm"
block|}
block|,
block|{
name|QChar
operator|::
name|Letter_Other
block|,
literal|"Lo"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Connector
block|,
literal|"Pc"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Dash
block|,
literal|"Pd"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Open
block|,
literal|"Ps"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Close
block|,
literal|"Pe"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_InitialQuote
block|,
literal|"Pi"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_FinalQuote
block|,
literal|"Pf"
block|}
block|,
block|{
name|QChar
operator|::
name|Punctuation_Other
block|,
literal|"Po"
block|}
block|,
block|{
name|QChar
operator|::
name|Symbol_Math
block|,
literal|"Sm"
block|}
block|,
block|{
name|QChar
operator|::
name|Symbol_Currency
block|,
literal|"Sc"
block|}
block|,
block|{
name|QChar
operator|::
name|Symbol_Modifier
block|,
literal|"Sk"
block|}
block|,
block|{
name|QChar
operator|::
name|Symbol_Other
block|,
literal|"So"
block|}
block|,
block|{
name|QChar
operator|::
name|Other_NotAssigned
block|,
literal|0
block|}
block|}
struct|;
name|Cat
modifier|*
name|c
init|=
name|categories
decl_stmt|;
while|while
condition|(
name|c
operator|->
name|name
condition|)
block|{
name|categoryMap
operator|.
name|insert
argument_list|(
name|c
operator|->
name|name
argument_list|,
name|c
operator|->
name|cat
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|decompositionMap
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QChar
operator|::
name|Decomposition
argument_list|>
name|decompositionMap
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initDecompositionMap
specifier|static
name|void
name|initDecompositionMap
parameter_list|()
block|{
struct|struct
name|Dec
block|{
name|QChar
operator|::
name|Decomposition
name|dec
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|decompositions
index|[]
init|=
block|{
block|{
name|QChar
operator|::
name|Canonical
block|,
literal|"<canonical>"
block|}
block|,
block|{
name|QChar
operator|::
name|Font
block|,
literal|"<font>"
block|}
block|,
block|{
name|QChar
operator|::
name|NoBreak
block|,
literal|"<noBreak>"
block|}
block|,
block|{
name|QChar
operator|::
name|Initial
block|,
literal|"<initial>"
block|}
block|,
block|{
name|QChar
operator|::
name|Medial
block|,
literal|"<medial>"
block|}
block|,
block|{
name|QChar
operator|::
name|Final
block|,
literal|"<final>"
block|}
block|,
block|{
name|QChar
operator|::
name|Isolated
block|,
literal|"<isolated>"
block|}
block|,
block|{
name|QChar
operator|::
name|Circle
block|,
literal|"<circle>"
block|}
block|,
block|{
name|QChar
operator|::
name|Super
block|,
literal|"<super>"
block|}
block|,
block|{
name|QChar
operator|::
name|Sub
block|,
literal|"<sub>"
block|}
block|,
block|{
name|QChar
operator|::
name|Vertical
block|,
literal|"<vertical>"
block|}
block|,
block|{
name|QChar
operator|::
name|Wide
block|,
literal|"<wide>"
block|}
block|,
block|{
name|QChar
operator|::
name|Narrow
block|,
literal|"<narrow>"
block|}
block|,
block|{
name|QChar
operator|::
name|Small
block|,
literal|"<small>"
block|}
block|,
block|{
name|QChar
operator|::
name|Square
block|,
literal|"<square>"
block|}
block|,
block|{
name|QChar
operator|::
name|Compat
block|,
literal|"<compat>"
block|}
block|,
block|{
name|QChar
operator|::
name|Fraction
block|,
literal|"<fraction>"
block|}
block|,
block|{
name|QChar
operator|::
name|NoDecomposition
block|,
literal|0
block|}
block|}
struct|;
name|Dec
modifier|*
name|d
init|=
name|decompositions
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|decompositionMap
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|dec
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_enum
DECL|enum|Direction
enum|enum
name|Direction
block|{
DECL|enumerator|DirL
name|DirL
init|=
name|QChar
operator|::
name|DirL
block|,
DECL|enumerator|DirR
name|DirR
init|=
name|QChar
operator|::
name|DirR
block|,
DECL|enumerator|DirEN
name|DirEN
init|=
name|QChar
operator|::
name|DirEN
block|,
DECL|enumerator|DirES
name|DirES
init|=
name|QChar
operator|::
name|DirES
block|,
DECL|enumerator|DirET
name|DirET
init|=
name|QChar
operator|::
name|DirET
block|,
DECL|enumerator|DirAN
name|DirAN
init|=
name|QChar
operator|::
name|DirAN
block|,
DECL|enumerator|DirCS
name|DirCS
init|=
name|QChar
operator|::
name|DirCS
block|,
DECL|enumerator|DirB
name|DirB
init|=
name|QChar
operator|::
name|DirB
block|,
DECL|enumerator|DirS
name|DirS
init|=
name|QChar
operator|::
name|DirS
block|,
DECL|enumerator|DirWS
name|DirWS
init|=
name|QChar
operator|::
name|DirWS
block|,
DECL|enumerator|DirON
name|DirON
init|=
name|QChar
operator|::
name|DirON
block|,
DECL|enumerator|DirLRE
name|DirLRE
init|=
name|QChar
operator|::
name|DirLRE
block|,
DECL|enumerator|DirLRO
name|DirLRO
init|=
name|QChar
operator|::
name|DirLRO
block|,
DECL|enumerator|DirAL
name|DirAL
init|=
name|QChar
operator|::
name|DirAL
block|,
DECL|enumerator|DirRLE
name|DirRLE
init|=
name|QChar
operator|::
name|DirRLE
block|,
DECL|enumerator|DirRLO
name|DirRLO
init|=
name|QChar
operator|::
name|DirRLO
block|,
DECL|enumerator|DirPDF
name|DirPDF
init|=
name|QChar
operator|::
name|DirPDF
block|,
DECL|enumerator|DirNSM
name|DirNSM
init|=
name|QChar
operator|::
name|DirNSM
block|,
DECL|enumerator|DirBN
name|DirBN
init|=
name|QChar
operator|::
name|DirBN
block|,
DECL|enumerator|DirLRI
name|DirLRI
init|=
name|QChar
operator|::
name|DirLRI
block|,
DECL|enumerator|DirRLI
name|DirRLI
init|=
name|QChar
operator|::
name|DirRLI
block|,
DECL|enumerator|DirFSI
name|DirFSI
init|=
name|QChar
operator|::
name|DirFSI
block|,
DECL|enumerator|DirPDI
name|DirPDI
init|=
name|QChar
operator|::
name|DirPDI
block|,
DECL|enumerator|Dir_Unassigned
name|Dir_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|directionMap
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|Direction
argument_list|>
name|directionMap
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initDirectionMap
specifier|static
name|void
name|initDirectionMap
parameter_list|()
block|{
struct|struct
name|Dir
block|{
name|Direction
name|dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|directions
index|[]
init|=
block|{
block|{
name|DirL
block|,
literal|"L"
block|}
block|,
block|{
name|DirR
block|,
literal|"R"
block|}
block|,
block|{
name|DirEN
block|,
literal|"EN"
block|}
block|,
block|{
name|DirES
block|,
literal|"ES"
block|}
block|,
block|{
name|DirET
block|,
literal|"ET"
block|}
block|,
block|{
name|DirAN
block|,
literal|"AN"
block|}
block|,
block|{
name|DirCS
block|,
literal|"CS"
block|}
block|,
block|{
name|DirB
block|,
literal|"B"
block|}
block|,
block|{
name|DirS
block|,
literal|"S"
block|}
block|,
block|{
name|DirWS
block|,
literal|"WS"
block|}
block|,
block|{
name|DirON
block|,
literal|"ON"
block|}
block|,
block|{
name|DirLRE
block|,
literal|"LRE"
block|}
block|,
block|{
name|DirLRO
block|,
literal|"LRO"
block|}
block|,
block|{
name|DirAL
block|,
literal|"AL"
block|}
block|,
block|{
name|DirRLE
block|,
literal|"RLE"
block|}
block|,
block|{
name|DirRLO
block|,
literal|"RLO"
block|}
block|,
block|{
name|DirPDF
block|,
literal|"PDF"
block|}
block|,
block|{
name|DirNSM
block|,
literal|"NSM"
block|}
block|,
block|{
name|DirBN
block|,
literal|"BN"
block|}
block|,
block|{
name|DirLRI
block|,
literal|"LRI"
block|}
block|,
block|{
name|DirRLI
block|,
literal|"RLI"
block|}
block|,
block|{
name|DirFSI
block|,
literal|"FSI"
block|}
block|,
block|{
name|DirPDI
block|,
literal|"PDI"
block|}
block|,
block|{
name|Dir_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|Dir
modifier|*
name|d
init|=
name|directions
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|directionMap
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|dir
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_enum
DECL|enum|JoiningType
enum|enum
name|JoiningType
block|{
DECL|enumerator|Joining_None
name|Joining_None
block|,
DECL|enumerator|Joining_Causing
name|Joining_Causing
block|,
DECL|enumerator|Joining_Dual
name|Joining_Dual
block|,
DECL|enumerator|Joining_Right
name|Joining_Right
block|,
DECL|enumerator|Joining_Left
name|Joining_Left
block|,
DECL|enumerator|Joining_Transparent
name|Joining_Transparent
block|,
DECL|enumerator|Joining_Unassigned
name|Joining_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|joining_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|JoiningType
argument_list|>
name|joining_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initJoiningMap
specifier|static
name|void
name|initJoiningMap
parameter_list|()
block|{
struct|struct
name|JoiningList
block|{
name|JoiningType
name|joining
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|joinings
index|[]
init|=
block|{
block|{
name|Joining_None
block|,
literal|"U"
block|}
block|,
block|{
name|Joining_Causing
block|,
literal|"C"
block|}
block|,
block|{
name|Joining_Dual
block|,
literal|"D"
block|}
block|,
block|{
name|Joining_Right
block|,
literal|"R"
block|}
block|,
block|{
name|Joining_Left
block|,
literal|"L"
block|}
block|,
block|{
name|Joining_Transparent
block|,
literal|"T"
block|}
block|,
block|{
name|Joining_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|JoiningList
modifier|*
name|d
init|=
name|joinings
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|joining_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|joining
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|grapheme_break_class_string
specifier|static
specifier|const
name|char
modifier|*
name|grapheme_break_class_string
init|=
literal|"enum GraphemeBreakClass {\n"
literal|"    GraphemeBreak_Other,\n"
literal|"    GraphemeBreak_CR,\n"
literal|"    GraphemeBreak_LF,\n"
literal|"    GraphemeBreak_Control,\n"
literal|"    GraphemeBreak_Extend,\n"
literal|"    GraphemeBreak_RegionalIndicator,\n"
literal|"    GraphemeBreak_Prepend,\n"
literal|"    GraphemeBreak_SpacingMark,\n"
literal|"    GraphemeBreak_L,\n"
literal|"    GraphemeBreak_V,\n"
literal|"    GraphemeBreak_T,\n"
literal|"    GraphemeBreak_LV,\n"
literal|"    GraphemeBreak_LVT\n"
literal|"};\n\n"
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|GraphemeBreakClass
enum|enum
name|GraphemeBreakClass
block|{
DECL|enumerator|GraphemeBreak_Other
name|GraphemeBreak_Other
block|,
DECL|enumerator|GraphemeBreak_CR
name|GraphemeBreak_CR
block|,
DECL|enumerator|GraphemeBreak_LF
name|GraphemeBreak_LF
block|,
DECL|enumerator|GraphemeBreak_Control
name|GraphemeBreak_Control
block|,
DECL|enumerator|GraphemeBreak_Extend
name|GraphemeBreak_Extend
block|,
DECL|enumerator|GraphemeBreak_RegionalIndicator
name|GraphemeBreak_RegionalIndicator
block|,
DECL|enumerator|GraphemeBreak_Prepend
name|GraphemeBreak_Prepend
block|,
DECL|enumerator|GraphemeBreak_SpacingMark
name|GraphemeBreak_SpacingMark
block|,
DECL|enumerator|GraphemeBreak_L
name|GraphemeBreak_L
block|,
DECL|enumerator|GraphemeBreak_V
name|GraphemeBreak_V
block|,
DECL|enumerator|GraphemeBreak_T
name|GraphemeBreak_T
block|,
DECL|enumerator|GraphemeBreak_LV
name|GraphemeBreak_LV
block|,
DECL|enumerator|GraphemeBreak_LVT
name|GraphemeBreak_LVT
block|,
DECL|enumerator|GraphemeBreak_Unassigned
name|GraphemeBreak_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|grapheme_break_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|GraphemeBreakClass
argument_list|>
name|grapheme_break_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initGraphemeBreak
specifier|static
name|void
name|initGraphemeBreak
parameter_list|()
block|{
struct|struct
name|GraphemeBreakList
block|{
name|GraphemeBreakClass
name|brk
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|breaks
index|[]
init|=
block|{
block|{
name|GraphemeBreak_Other
block|,
literal|"Other"
block|}
block|,
block|{
name|GraphemeBreak_CR
block|,
literal|"CR"
block|}
block|,
block|{
name|GraphemeBreak_LF
block|,
literal|"LF"
block|}
block|,
block|{
name|GraphemeBreak_Control
block|,
literal|"Control"
block|}
block|,
block|{
name|GraphemeBreak_Extend
block|,
literal|"Extend"
block|}
block|,
block|{
name|GraphemeBreak_RegionalIndicator
block|,
literal|"Regional_Indicator"
block|}
block|,
block|{
name|GraphemeBreak_Prepend
block|,
literal|"Prepend"
block|}
block|,
block|{
name|GraphemeBreak_SpacingMark
block|,
literal|"SpacingMark"
block|}
block|,
block|{
name|GraphemeBreak_L
block|,
literal|"L"
block|}
block|,
block|{
name|GraphemeBreak_V
block|,
literal|"V"
block|}
block|,
block|{
name|GraphemeBreak_T
block|,
literal|"T"
block|}
block|,
block|{
name|GraphemeBreak_LV
block|,
literal|"LV"
block|}
block|,
block|{
name|GraphemeBreak_LVT
block|,
literal|"LVT"
block|}
block|,
block|{
name|GraphemeBreak_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|GraphemeBreakList
modifier|*
name|d
init|=
name|breaks
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|grapheme_break_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|brk
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|word_break_class_string
specifier|static
specifier|const
name|char
modifier|*
name|word_break_class_string
init|=
literal|"enum WordBreakClass {\n"
literal|"    WordBreak_Other,\n"
literal|"    WordBreak_CR,\n"
literal|"    WordBreak_LF,\n"
literal|"    WordBreak_Newline,\n"
literal|"    WordBreak_Extend,\n"
literal|"    WordBreak_RegionalIndicator,\n"
literal|"    WordBreak_Katakana,\n"
literal|"    WordBreak_HebrewLetter,\n"
literal|"    WordBreak_ALetter,\n"
literal|"    WordBreak_SingleQuote,\n"
literal|"    WordBreak_DoubleQuote,\n"
literal|"    WordBreak_MidNumLet,\n"
literal|"    WordBreak_MidLetter,\n"
literal|"    WordBreak_MidNum,\n"
literal|"    WordBreak_Numeric,\n"
literal|"    WordBreak_ExtendNumLet\n"
literal|"};\n\n"
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|WordBreakClass
enum|enum
name|WordBreakClass
block|{
DECL|enumerator|WordBreak_Other
name|WordBreak_Other
block|,
DECL|enumerator|WordBreak_CR
name|WordBreak_CR
block|,
DECL|enumerator|WordBreak_LF
name|WordBreak_LF
block|,
DECL|enumerator|WordBreak_Newline
name|WordBreak_Newline
block|,
DECL|enumerator|WordBreak_Extend
name|WordBreak_Extend
block|,
DECL|enumerator|WordBreak_RegionalIndicator
name|WordBreak_RegionalIndicator
block|,
DECL|enumerator|WordBreak_Katakana
name|WordBreak_Katakana
block|,
DECL|enumerator|WordBreak_HebrewLetter
name|WordBreak_HebrewLetter
block|,
DECL|enumerator|WordBreak_ALetter
name|WordBreak_ALetter
block|,
DECL|enumerator|WordBreak_SingleQuote
name|WordBreak_SingleQuote
block|,
DECL|enumerator|WordBreak_DoubleQuote
name|WordBreak_DoubleQuote
block|,
DECL|enumerator|WordBreak_MidNumLet
name|WordBreak_MidNumLet
block|,
DECL|enumerator|WordBreak_MidLetter
name|WordBreak_MidLetter
block|,
DECL|enumerator|WordBreak_MidNum
name|WordBreak_MidNum
block|,
DECL|enumerator|WordBreak_Numeric
name|WordBreak_Numeric
block|,
DECL|enumerator|WordBreak_ExtendNumLet
name|WordBreak_ExtendNumLet
block|,
DECL|enumerator|WordBreak_Unassigned
name|WordBreak_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|word_break_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|WordBreakClass
argument_list|>
name|word_break_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initWordBreak
specifier|static
name|void
name|initWordBreak
parameter_list|()
block|{
struct|struct
name|WordBreakList
block|{
name|WordBreakClass
name|brk
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|breaks
index|[]
init|=
block|{
block|{
name|WordBreak_Other
block|,
literal|"Other"
block|}
block|,
block|{
name|WordBreak_CR
block|,
literal|"CR"
block|}
block|,
block|{
name|WordBreak_LF
block|,
literal|"LF"
block|}
block|,
block|{
name|WordBreak_Newline
block|,
literal|"Newline"
block|}
block|,
block|{
name|WordBreak_Extend
block|,
literal|"Extend"
block|}
block|,
block|{
name|WordBreak_Extend
block|,
literal|"Format"
block|}
block|,
block|{
name|WordBreak_RegionalIndicator
block|,
literal|"Regional_Indicator"
block|}
block|,
block|{
name|WordBreak_Katakana
block|,
literal|"Katakana"
block|}
block|,
block|{
name|WordBreak_HebrewLetter
block|,
literal|"Hebrew_Letter"
block|}
block|,
block|{
name|WordBreak_ALetter
block|,
literal|"ALetter"
block|}
block|,
block|{
name|WordBreak_SingleQuote
block|,
literal|"Single_Quote"
block|}
block|,
block|{
name|WordBreak_DoubleQuote
block|,
literal|"Double_Quote"
block|}
block|,
block|{
name|WordBreak_MidNumLet
block|,
literal|"MidNumLet"
block|}
block|,
block|{
name|WordBreak_MidLetter
block|,
literal|"MidLetter"
block|}
block|,
block|{
name|WordBreak_MidNum
block|,
literal|"MidNum"
block|}
block|,
block|{
name|WordBreak_Numeric
block|,
literal|"Numeric"
block|}
block|,
block|{
name|WordBreak_ExtendNumLet
block|,
literal|"ExtendNumLet"
block|}
block|,
block|{
name|WordBreak_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|WordBreakList
modifier|*
name|d
init|=
name|breaks
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|word_break_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|brk
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|sentence_break_class_string
specifier|static
specifier|const
name|char
modifier|*
name|sentence_break_class_string
init|=
literal|"enum SentenceBreakClass {\n"
literal|"    SentenceBreak_Other,\n"
literal|"    SentenceBreak_CR,\n"
literal|"    SentenceBreak_LF,\n"
literal|"    SentenceBreak_Sep,\n"
literal|"    SentenceBreak_Extend,\n"
literal|"    SentenceBreak_Sp,\n"
literal|"    SentenceBreak_Lower,\n"
literal|"    SentenceBreak_Upper,\n"
literal|"    SentenceBreak_OLetter,\n"
literal|"    SentenceBreak_Numeric,\n"
literal|"    SentenceBreak_ATerm,\n"
literal|"    SentenceBreak_SContinue,\n"
literal|"    SentenceBreak_STerm,\n"
literal|"    SentenceBreak_Close\n"
literal|"};\n\n"
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|SentenceBreakClass
enum|enum
name|SentenceBreakClass
block|{
DECL|enumerator|SentenceBreak_Other
name|SentenceBreak_Other
block|,
DECL|enumerator|SentenceBreak_CR
name|SentenceBreak_CR
block|,
DECL|enumerator|SentenceBreak_LF
name|SentenceBreak_LF
block|,
DECL|enumerator|SentenceBreak_Sep
name|SentenceBreak_Sep
block|,
DECL|enumerator|SentenceBreak_Extend
name|SentenceBreak_Extend
block|,
DECL|enumerator|SentenceBreak_Sp
name|SentenceBreak_Sp
block|,
DECL|enumerator|SentenceBreak_Lower
name|SentenceBreak_Lower
block|,
DECL|enumerator|SentenceBreak_Upper
name|SentenceBreak_Upper
block|,
DECL|enumerator|SentenceBreak_OLetter
name|SentenceBreak_OLetter
block|,
DECL|enumerator|SentenceBreak_Numeric
name|SentenceBreak_Numeric
block|,
DECL|enumerator|SentenceBreak_ATerm
name|SentenceBreak_ATerm
block|,
DECL|enumerator|SentenceBreak_SContinue
name|SentenceBreak_SContinue
block|,
DECL|enumerator|SentenceBreak_STerm
name|SentenceBreak_STerm
block|,
DECL|enumerator|SentenceBreak_Close
name|SentenceBreak_Close
block|,
DECL|enumerator|SentenceBreak_Unassigned
name|SentenceBreak_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|sentence_break_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|SentenceBreakClass
argument_list|>
name|sentence_break_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initSentenceBreak
specifier|static
name|void
name|initSentenceBreak
parameter_list|()
block|{
struct|struct
name|SentenceBreakList
block|{
name|SentenceBreakClass
name|brk
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|breaks
index|[]
init|=
block|{
block|{
name|SentenceBreak_Other
block|,
literal|"Other"
block|}
block|,
block|{
name|SentenceBreak_CR
block|,
literal|"CR"
block|}
block|,
block|{
name|SentenceBreak_LF
block|,
literal|"LF"
block|}
block|,
block|{
name|SentenceBreak_Sep
block|,
literal|"Sep"
block|}
block|,
block|{
name|SentenceBreak_Extend
block|,
literal|"Extend"
block|}
block|,
block|{
name|SentenceBreak_Extend
block|,
literal|"Format"
block|}
block|,
block|{
name|SentenceBreak_Sp
block|,
literal|"Sp"
block|}
block|,
block|{
name|SentenceBreak_Lower
block|,
literal|"Lower"
block|}
block|,
block|{
name|SentenceBreak_Upper
block|,
literal|"Upper"
block|}
block|,
block|{
name|SentenceBreak_OLetter
block|,
literal|"OLetter"
block|}
block|,
block|{
name|SentenceBreak_Numeric
block|,
literal|"Numeric"
block|}
block|,
block|{
name|SentenceBreak_ATerm
block|,
literal|"ATerm"
block|}
block|,
block|{
name|SentenceBreak_SContinue
block|,
literal|"SContinue"
block|}
block|,
block|{
name|SentenceBreak_STerm
block|,
literal|"STerm"
block|}
block|,
block|{
name|SentenceBreak_Close
block|,
literal|"Close"
block|}
block|,
block|{
name|SentenceBreak_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|SentenceBreakList
modifier|*
name|d
init|=
name|breaks
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|sentence_break_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|brk
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|line_break_class_string
specifier|static
specifier|const
name|char
modifier|*
name|line_break_class_string
init|=
literal|"// see http://www.unicode.org/reports/tr14/tr14-30.html\n"
literal|"// we don't use the XX and AI classes and map them to AL instead.\n"
literal|"enum LineBreakClass {\n"
literal|"    LineBreak_OP, LineBreak_CL, LineBreak_CP, LineBreak_QU, LineBreak_GL,\n"
literal|"    LineBreak_NS, LineBreak_EX, LineBreak_SY, LineBreak_IS, LineBreak_PR,\n"
literal|"    LineBreak_PO, LineBreak_NU, LineBreak_AL, LineBreak_HL, LineBreak_ID,\n"
literal|"    LineBreak_IN, LineBreak_HY, LineBreak_BA, LineBreak_BB, LineBreak_B2,\n"
literal|"    LineBreak_ZW, LineBreak_CM, LineBreak_WJ, LineBreak_H2, LineBreak_H3,\n"
literal|"    LineBreak_JL, LineBreak_JV, LineBreak_JT, LineBreak_RI, LineBreak_CB,\n"
literal|"    LineBreak_SA, LineBreak_SG, LineBreak_SP, LineBreak_CR, LineBreak_LF,\n"
literal|"    LineBreak_BK\n"
literal|"};\n\n"
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|LineBreakClass
enum|enum
name|LineBreakClass
block|{
DECL|enumerator|LineBreak_OP
DECL|enumerator|LineBreak_CL
DECL|enumerator|LineBreak_CP
DECL|enumerator|LineBreak_QU
DECL|enumerator|LineBreak_GL
name|LineBreak_OP
block|,
name|LineBreak_CL
block|,
name|LineBreak_CP
block|,
name|LineBreak_QU
block|,
name|LineBreak_GL
block|,
DECL|enumerator|LineBreak_NS
DECL|enumerator|LineBreak_EX
DECL|enumerator|LineBreak_SY
DECL|enumerator|LineBreak_IS
DECL|enumerator|LineBreak_PR
name|LineBreak_NS
block|,
name|LineBreak_EX
block|,
name|LineBreak_SY
block|,
name|LineBreak_IS
block|,
name|LineBreak_PR
block|,
DECL|enumerator|LineBreak_PO
DECL|enumerator|LineBreak_NU
DECL|enumerator|LineBreak_AL
DECL|enumerator|LineBreak_HL
DECL|enumerator|LineBreak_ID
name|LineBreak_PO
block|,
name|LineBreak_NU
block|,
name|LineBreak_AL
block|,
name|LineBreak_HL
block|,
name|LineBreak_ID
block|,
DECL|enumerator|LineBreak_IN
DECL|enumerator|LineBreak_HY
DECL|enumerator|LineBreak_BA
DECL|enumerator|LineBreak_BB
DECL|enumerator|LineBreak_B2
name|LineBreak_IN
block|,
name|LineBreak_HY
block|,
name|LineBreak_BA
block|,
name|LineBreak_BB
block|,
name|LineBreak_B2
block|,
DECL|enumerator|LineBreak_ZW
DECL|enumerator|LineBreak_CM
DECL|enumerator|LineBreak_WJ
DECL|enumerator|LineBreak_H2
DECL|enumerator|LineBreak_H3
name|LineBreak_ZW
block|,
name|LineBreak_CM
block|,
name|LineBreak_WJ
block|,
name|LineBreak_H2
block|,
name|LineBreak_H3
block|,
DECL|enumerator|LineBreak_JL
DECL|enumerator|LineBreak_JV
DECL|enumerator|LineBreak_JT
DECL|enumerator|LineBreak_RI
DECL|enumerator|LineBreak_CB
name|LineBreak_JL
block|,
name|LineBreak_JV
block|,
name|LineBreak_JT
block|,
name|LineBreak_RI
block|,
name|LineBreak_CB
block|,
DECL|enumerator|LineBreak_SA
DECL|enumerator|LineBreak_SG
DECL|enumerator|LineBreak_SP
DECL|enumerator|LineBreak_CR
DECL|enumerator|LineBreak_LF
name|LineBreak_SA
block|,
name|LineBreak_SG
block|,
name|LineBreak_SP
block|,
name|LineBreak_CR
block|,
name|LineBreak_LF
block|,
DECL|enumerator|LineBreak_BK
name|LineBreak_BK
block|,
DECL|enumerator|LineBreak_Unassigned
name|LineBreak_Unassigned
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|line_break_map
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|LineBreakClass
argument_list|>
name|line_break_map
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initLineBreak
specifier|static
name|void
name|initLineBreak
parameter_list|()
block|{
comment|// ### Classes XX and AI are left out and mapped to AL for now.
comment|// ### Class NL is mapped to BK.
comment|// ### Treating characters of class CJ as class NS will give CSS strict line breaking;
comment|//     treating them as class ID will give CSS normal breaking.
struct|struct
name|LineBreakList
block|{
name|LineBreakClass
name|brk
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|breaks
index|[]
init|=
block|{
block|{
name|LineBreak_BK
block|,
literal|"BK"
block|}
block|,
block|{
name|LineBreak_CR
block|,
literal|"CR"
block|}
block|,
block|{
name|LineBreak_LF
block|,
literal|"LF"
block|}
block|,
block|{
name|LineBreak_CM
block|,
literal|"CM"
block|}
block|,
block|{
name|LineBreak_BK
block|,
literal|"NL"
block|}
block|,
block|{
name|LineBreak_SG
block|,
literal|"SG"
block|}
block|,
block|{
name|LineBreak_WJ
block|,
literal|"WJ"
block|}
block|,
block|{
name|LineBreak_ZW
block|,
literal|"ZW"
block|}
block|,
block|{
name|LineBreak_GL
block|,
literal|"GL"
block|}
block|,
block|{
name|LineBreak_SP
block|,
literal|"SP"
block|}
block|,
block|{
name|LineBreak_B2
block|,
literal|"B2"
block|}
block|,
block|{
name|LineBreak_BA
block|,
literal|"BA"
block|}
block|,
block|{
name|LineBreak_BB
block|,
literal|"BB"
block|}
block|,
block|{
name|LineBreak_HY
block|,
literal|"HY"
block|}
block|,
block|{
name|LineBreak_CB
block|,
literal|"CB"
block|}
block|,
block|{
name|LineBreak_NS
block|,
literal|"CJ"
block|}
block|,
block|{
name|LineBreak_CL
block|,
literal|"CL"
block|}
block|,
block|{
name|LineBreak_CP
block|,
literal|"CP"
block|}
block|,
block|{
name|LineBreak_EX
block|,
literal|"EX"
block|}
block|,
block|{
name|LineBreak_IN
block|,
literal|"IN"
block|}
block|,
block|{
name|LineBreak_NS
block|,
literal|"NS"
block|}
block|,
block|{
name|LineBreak_OP
block|,
literal|"OP"
block|}
block|,
block|{
name|LineBreak_QU
block|,
literal|"QU"
block|}
block|,
block|{
name|LineBreak_IS
block|,
literal|"IS"
block|}
block|,
block|{
name|LineBreak_NU
block|,
literal|"NU"
block|}
block|,
block|{
name|LineBreak_PO
block|,
literal|"PO"
block|}
block|,
block|{
name|LineBreak_PR
block|,
literal|"PR"
block|}
block|,
block|{
name|LineBreak_SY
block|,
literal|"SY"
block|}
block|,
block|{
name|LineBreak_AL
block|,
literal|"AI"
block|}
block|,
block|{
name|LineBreak_AL
block|,
literal|"AL"
block|}
block|,
block|{
name|LineBreak_HL
block|,
literal|"HL"
block|}
block|,
block|{
name|LineBreak_H2
block|,
literal|"H2"
block|}
block|,
block|{
name|LineBreak_H3
block|,
literal|"H3"
block|}
block|,
block|{
name|LineBreak_ID
block|,
literal|"ID"
block|}
block|,
block|{
name|LineBreak_JL
block|,
literal|"JL"
block|}
block|,
block|{
name|LineBreak_JV
block|,
literal|"JV"
block|}
block|,
block|{
name|LineBreak_JT
block|,
literal|"JT"
block|}
block|,
block|{
name|LineBreak_RI
block|,
literal|"RI"
block|}
block|,
block|{
name|LineBreak_SA
block|,
literal|"SA"
block|}
block|,
block|{
name|LineBreak_AL
block|,
literal|"XX"
block|}
block|,
block|{
name|LineBreak_Unassigned
block|,
literal|0
block|}
block|}
struct|;
name|LineBreakList
modifier|*
name|d
init|=
name|breaks
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|line_break_map
operator|.
name|insert
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|brk
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|scriptMap
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QChar
operator|::
name|Script
argument_list|>
name|scriptMap
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initScriptMap
specifier|static
name|void
name|initScriptMap
parameter_list|()
block|{
struct|struct
name|Scrpt
block|{
name|QChar
operator|::
name|Script
name|script
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|scripts
index|[]
init|=
block|{
comment|// general
block|{
name|QChar
operator|::
name|Script_Unknown
block|,
literal|"Unknown"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Inherited
block|,
literal|"Inherited"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Common
block|,
literal|"Common"
block|}
block|,
comment|// pre-4.0
block|{
name|QChar
operator|::
name|Script_Latin
block|,
literal|"Latin"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Greek
block|,
literal|"Greek"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Cyrillic
block|,
literal|"Cyrillic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Armenian
block|,
literal|"Armenian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Hebrew
block|,
literal|"Hebrew"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Arabic
block|,
literal|"Arabic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Syriac
block|,
literal|"Syriac"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Thaana
block|,
literal|"Thaana"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Devanagari
block|,
literal|"Devanagari"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Bengali
block|,
literal|"Bengali"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Gurmukhi
block|,
literal|"Gurmukhi"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Gujarati
block|,
literal|"Gujarati"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Oriya
block|,
literal|"Oriya"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Tamil
block|,
literal|"Tamil"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Telugu
block|,
literal|"Telugu"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Kannada
block|,
literal|"Kannada"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Malayalam
block|,
literal|"Malayalam"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Sinhala
block|,
literal|"Sinhala"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Thai
block|,
literal|"Thai"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Lao
block|,
literal|"Lao"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Tibetan
block|,
literal|"Tibetan"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Myanmar
block|,
literal|"Myanmar"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Georgian
block|,
literal|"Georgian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Hangul
block|,
literal|"Hangul"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Ethiopic
block|,
literal|"Ethiopic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Cherokee
block|,
literal|"Cherokee"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_CanadianAboriginal
block|,
literal|"CanadianAboriginal"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Ogham
block|,
literal|"Ogham"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Runic
block|,
literal|"Runic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Khmer
block|,
literal|"Khmer"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Mongolian
block|,
literal|"Mongolian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Hiragana
block|,
literal|"Hiragana"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Katakana
block|,
literal|"Katakana"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Bopomofo
block|,
literal|"Bopomofo"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Han
block|,
literal|"Han"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Yi
block|,
literal|"Yi"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_OldItalic
block|,
literal|"OldItalic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Gothic
block|,
literal|"Gothic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Deseret
block|,
literal|"Deseret"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Tagalog
block|,
literal|"Tagalog"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Hanunoo
block|,
literal|"Hanunoo"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Buhid
block|,
literal|"Buhid"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Tagbanwa
block|,
literal|"Tagbanwa"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Coptic
block|,
literal|"Coptic"
block|}
block|,
comment|// 4.0
block|{
name|QChar
operator|::
name|Script_Limbu
block|,
literal|"Limbu"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_TaiLe
block|,
literal|"TaiLe"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_LinearB
block|,
literal|"LinearB"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Ugaritic
block|,
literal|"Ugaritic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Shavian
block|,
literal|"Shavian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Osmanya
block|,
literal|"Osmanya"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Cypriot
block|,
literal|"Cypriot"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Braille
block|,
literal|"Braille"
block|}
block|,
comment|// 4.1
block|{
name|QChar
operator|::
name|Script_Buginese
block|,
literal|"Buginese"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_NewTaiLue
block|,
literal|"NewTaiLue"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Glagolitic
block|,
literal|"Glagolitic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Tifinagh
block|,
literal|"Tifinagh"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_SylotiNagri
block|,
literal|"SylotiNagri"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_OldPersian
block|,
literal|"OldPersian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Kharoshthi
block|,
literal|"Kharoshthi"
block|}
block|,
comment|// 5.0
block|{
name|QChar
operator|::
name|Script_Balinese
block|,
literal|"Balinese"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Cuneiform
block|,
literal|"Cuneiform"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Phoenician
block|,
literal|"Phoenician"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_PhagsPa
block|,
literal|"PhagsPa"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Nko
block|,
literal|"Nko"
block|}
block|,
comment|// 5.1
block|{
name|QChar
operator|::
name|Script_Sundanese
block|,
literal|"Sundanese"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Lepcha
block|,
literal|"Lepcha"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_OlChiki
block|,
literal|"OlChiki"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Vai
block|,
literal|"Vai"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Saurashtra
block|,
literal|"Saurashtra"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_KayahLi
block|,
literal|"KayahLi"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Rejang
block|,
literal|"Rejang"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Lycian
block|,
literal|"Lycian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Carian
block|,
literal|"Carian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Lydian
block|,
literal|"Lydian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Cham
block|,
literal|"Cham"
block|}
block|,
comment|// 5.2
block|{
name|QChar
operator|::
name|Script_TaiTham
block|,
literal|"TaiTham"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_TaiViet
block|,
literal|"TaiViet"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Avestan
block|,
literal|"Avestan"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_EgyptianHieroglyphs
block|,
literal|"EgyptianHieroglyphs"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Samaritan
block|,
literal|"Samaritan"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Lisu
block|,
literal|"Lisu"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Bamum
block|,
literal|"Bamum"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Javanese
block|,
literal|"Javanese"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_MeeteiMayek
block|,
literal|"MeeteiMayek"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_ImperialAramaic
block|,
literal|"ImperialAramaic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_OldSouthArabian
block|,
literal|"OldSouthArabian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_InscriptionalParthian
block|,
literal|"InscriptionalParthian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_InscriptionalPahlavi
block|,
literal|"InscriptionalPahlavi"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_OldTurkic
block|,
literal|"OldTurkic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Kaithi
block|,
literal|"Kaithi"
block|}
block|,
comment|// 6.0
block|{
name|QChar
operator|::
name|Script_Batak
block|,
literal|"Batak"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Brahmi
block|,
literal|"Brahmi"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Mandaic
block|,
literal|"Mandaic"
block|}
block|,
comment|// 6.1
block|{
name|QChar
operator|::
name|Script_Chakma
block|,
literal|"Chakma"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_MeroiticCursive
block|,
literal|"MeroiticCursive"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_MeroiticHieroglyphs
block|,
literal|"MeroiticHieroglyphs"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Miao
block|,
literal|"Miao"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Sharada
block|,
literal|"Sharada"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_SoraSompeng
block|,
literal|"SoraSompeng"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Takri
block|,
literal|"Takri"
block|}
block|,
comment|// 7.0
block|{
name|QChar
operator|::
name|Script_CaucasianAlbanian
block|,
literal|"CaucasianAlbanian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_BassaVah
block|,
literal|"BassaVah"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Duployan
block|,
literal|"Duployan"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Elbasan
block|,
literal|"Elbasan"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Grantha
block|,
literal|"Grantha"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_PahawhHmong
block|,
literal|"PahawhHmong"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Khojki
block|,
literal|"Khojki"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_LinearA
block|,
literal|"LinearA"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Mahajani
block|,
literal|"Mahajani"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Manichaean
block|,
literal|"Manichaean"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_MendeKikakui
block|,
literal|"MendeKikakui"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Modi
block|,
literal|"Modi"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Mro
block|,
literal|"Mro"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_OldNorthArabian
block|,
literal|"OldNorthArabian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Nabataean
block|,
literal|"Nabataean"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Palmyrene
block|,
literal|"Palmyrene"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_PauCinHau
block|,
literal|"PauCinHau"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_OldPermic
block|,
literal|"OldPermic"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_PsalterPahlavi
block|,
literal|"PsalterPahlavi"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Siddham
block|,
literal|"Siddham"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Khudawadi
block|,
literal|"Khudawadi"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Tirhuta
block|,
literal|"Tirhuta"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_WarangCiti
block|,
literal|"WarangCiti"
block|}
block|,
comment|// 8.0
block|{
name|QChar
operator|::
name|Script_Ahom
block|,
literal|"Ahom"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_AnatolianHieroglyphs
block|,
literal|"AnatolianHieroglyphs"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Hatran
block|,
literal|"Hatran"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_Multani
block|,
literal|"Multani"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_OldHungarian
block|,
literal|"OldHungarian"
block|}
block|,
block|{
name|QChar
operator|::
name|Script_SignWriting
block|,
literal|"SignWriting"
block|}
block|,
comment|// unhandled
block|{
name|QChar
operator|::
name|Script_Unknown
block|,
literal|0
block|}
block|}
struct|;
name|Scrpt
modifier|*
name|p
init|=
name|scripts
decl_stmt|;
while|while
condition|(
name|p
operator|->
name|name
condition|)
block|{
name|scriptMap
operator|.
name|insert
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|script
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Keep this one in sync with the code in createPropertyInfo
end_comment
begin_decl_stmt
DECL|variable|property_string
specifier|static
specifier|const
name|char
modifier|*
name|property_string
init|=
literal|"struct Properties {\n"
literal|"    ushort category            : 8; /* 5 used */\n"
literal|"    ushort direction           : 8; /* 5 used */\n"
literal|"    ushort combiningClass      : 8;\n"
literal|"    ushort joining             : 3;\n"
literal|"    signed short digitValue    : 5;\n"
literal|"    signed short mirrorDiff    : 16;\n"
literal|"    ushort lowerCaseSpecial    : 1;\n"
literal|"    signed short lowerCaseDiff : 15;\n"
literal|"    ushort upperCaseSpecial    : 1;\n"
literal|"    signed short upperCaseDiff : 15;\n"
literal|"    ushort titleCaseSpecial    : 1;\n"
literal|"    signed short titleCaseDiff : 15;\n"
literal|"    ushort caseFoldSpecial     : 1;\n"
literal|"    signed short caseFoldDiff  : 15;\n"
literal|"    ushort unicodeVersion      : 8; /* 5 used */\n"
literal|"    ushort nfQuickCheck        : 8;\n"
comment|// could be narrowed
literal|"    ushort graphemeBreakClass  : 4; /* 4 used */\n"
literal|"    ushort wordBreakClass      : 4; /* 4 used */\n"
literal|"    ushort sentenceBreakClass  : 8; /* 4 used */\n"
literal|"    ushort lineBreakClass      : 8; /* 6 used */\n"
literal|"    ushort script              : 8;\n"
literal|"};\n\n"
literal|"Q_CORE_EXPORT const Properties * QT_FASTCALL properties(uint ucs4) Q_DECL_NOTHROW;\n"
literal|"Q_CORE_EXPORT const Properties * QT_FASTCALL properties(ushort ucs2) Q_DECL_NOTHROW;\n"
literal|"\n"
literal|"struct LowercaseTraits\n"
literal|"{\n"
literal|"    static inline signed short caseDiff(const Properties *prop)\n"
literal|"    { return prop->lowerCaseDiff; }\n"
literal|"    static inline bool caseSpecial(const Properties *prop)\n"
literal|"    { return prop->lowerCaseSpecial; }\n"
literal|"};\n"
literal|"\n"
literal|"struct UppercaseTraits\n"
literal|"{\n"
literal|"    static inline signed short caseDiff(const Properties *prop)\n"
literal|"    { return prop->upperCaseDiff; }\n"
literal|"    static inline bool caseSpecial(const Properties *prop)\n"
literal|"    { return prop->upperCaseSpecial; }\n"
literal|"};\n"
literal|"\n"
literal|"struct TitlecaseTraits\n"
literal|"{\n"
literal|"    static inline signed short caseDiff(const Properties *prop)\n"
literal|"    { return prop->titleCaseDiff; }\n"
literal|"    static inline bool caseSpecial(const Properties *prop)\n"
literal|"    { return prop->titleCaseSpecial; }\n"
literal|"};\n"
literal|"\n"
literal|"struct CasefoldTraits\n"
literal|"{\n"
literal|"    static inline signed short caseDiff(const Properties *prop)\n"
literal|"    { return prop->caseFoldDiff; }\n"
literal|"    static inline bool caseSpecial(const Properties *prop)\n"
literal|"    { return prop->caseFoldSpecial; }\n"
literal|"};\n"
literal|"\n"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|methods
specifier|static
specifier|const
name|char
modifier|*
name|methods
init|=
literal|"Q_CORE_EXPORT GraphemeBreakClass QT_FASTCALL graphemeBreakClass(uint ucs4) Q_DECL_NOTHROW;\n"
literal|"inline GraphemeBreakClass graphemeBreakClass(QChar ch) Q_DECL_NOTHROW\n"
literal|"{ return graphemeBreakClass(ch.unicode()); }\n"
literal|"\n"
literal|"Q_CORE_EXPORT WordBreakClass QT_FASTCALL wordBreakClass(uint ucs4) Q_DECL_NOTHROW;\n"
literal|"inline WordBreakClass wordBreakClass(QChar ch) Q_DECL_NOTHROW\n"
literal|"{ return wordBreakClass(ch.unicode()); }\n"
literal|"\n"
literal|"Q_CORE_EXPORT SentenceBreakClass QT_FASTCALL sentenceBreakClass(uint ucs4) Q_DECL_NOTHROW;\n"
literal|"inline SentenceBreakClass sentenceBreakClass(QChar ch) Q_DECL_NOTHROW\n"
literal|"{ return sentenceBreakClass(ch.unicode()); }\n"
literal|"\n"
literal|"Q_CORE_EXPORT LineBreakClass QT_FASTCALL lineBreakClass(uint ucs4) Q_DECL_NOTHROW;\n"
literal|"inline LineBreakClass lineBreakClass(QChar ch) Q_DECL_NOTHROW\n"
literal|"{ return lineBreakClass(ch.unicode()); }\n"
literal|"\n"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|SizeOfPropertiesStruct
specifier|static
specifier|const
name|int
name|SizeOfPropertiesStruct
init|=
literal|20
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|PropertyFlags
struct|struct
name|PropertyFlags
block|{
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|PropertyFlags
modifier|&
name|o
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|combiningClass
operator|==
name|o
operator|.
name|combiningClass
operator|&&
name|category
operator|==
name|o
operator|.
name|category
operator|&&
name|direction
operator|==
name|o
operator|.
name|direction
operator|&&
name|joining
operator|==
name|o
operator|.
name|joining
operator|&&
name|age
operator|==
name|o
operator|.
name|age
operator|&&
name|digitValue
operator|==
name|o
operator|.
name|digitValue
operator|&&
name|mirrorDiff
operator|==
name|o
operator|.
name|mirrorDiff
operator|&&
name|lowerCaseDiff
operator|==
name|o
operator|.
name|lowerCaseDiff
operator|&&
name|upperCaseDiff
operator|==
name|o
operator|.
name|upperCaseDiff
operator|&&
name|titleCaseDiff
operator|==
name|o
operator|.
name|titleCaseDiff
operator|&&
name|caseFoldDiff
operator|==
name|o
operator|.
name|caseFoldDiff
operator|&&
name|lowerCaseSpecial
operator|==
name|o
operator|.
name|lowerCaseSpecial
operator|&&
name|upperCaseSpecial
operator|==
name|o
operator|.
name|upperCaseSpecial
operator|&&
name|titleCaseSpecial
operator|==
name|o
operator|.
name|titleCaseSpecial
operator|&&
name|caseFoldSpecial
operator|==
name|o
operator|.
name|caseFoldSpecial
operator|&&
name|graphemeBreakClass
operator|==
name|o
operator|.
name|graphemeBreakClass
operator|&&
name|wordBreakClass
operator|==
name|o
operator|.
name|wordBreakClass
operator|&&
name|sentenceBreakClass
operator|==
name|o
operator|.
name|sentenceBreakClass
operator|&&
name|lineBreakClass
operator|==
name|o
operator|.
name|lineBreakClass
operator|&&
name|script
operator|==
name|o
operator|.
name|script
operator|&&
name|nfQuickCheck
operator|==
name|o
operator|.
name|nfQuickCheck
operator|)
return|;
block|}
comment|// from UnicodeData.txt
DECL|member|combiningClass
name|uchar
name|combiningClass
range|:
literal|8
decl_stmt|;
DECL|member|category
name|QChar
operator|::
name|Category
name|category
range|:
literal|5
decl_stmt|;
DECL|member|direction
name|QChar
operator|::
name|Direction
name|direction
range|:
literal|5
decl_stmt|;
comment|// from ArabicShaping.txt
DECL|member|joining
name|QChar
operator|::
name|JoiningType
name|joining
range|:
literal|3
decl_stmt|;
comment|// from DerivedAge.txt
DECL|member|age
name|QChar
operator|::
name|UnicodeVersion
name|age
range|:
literal|5
decl_stmt|;
DECL|member|digitValue
name|int
name|digitValue
decl_stmt|;
DECL|member|mirrorDiff
name|int
name|mirrorDiff
range|:
literal|16
decl_stmt|;
DECL|member|lowerCaseDiff
name|int
name|lowerCaseDiff
decl_stmt|;
DECL|member|upperCaseDiff
name|int
name|upperCaseDiff
decl_stmt|;
DECL|member|titleCaseDiff
name|int
name|titleCaseDiff
decl_stmt|;
DECL|member|caseFoldDiff
name|int
name|caseFoldDiff
decl_stmt|;
DECL|member|lowerCaseSpecial
name|bool
name|lowerCaseSpecial
decl_stmt|;
DECL|member|upperCaseSpecial
name|bool
name|upperCaseSpecial
decl_stmt|;
DECL|member|titleCaseSpecial
name|bool
name|titleCaseSpecial
decl_stmt|;
DECL|member|caseFoldSpecial
name|bool
name|caseFoldSpecial
decl_stmt|;
DECL|member|graphemeBreakClass
name|GraphemeBreakClass
name|graphemeBreakClass
decl_stmt|;
DECL|member|wordBreakClass
name|WordBreakClass
name|wordBreakClass
decl_stmt|;
DECL|member|sentenceBreakClass
name|SentenceBreakClass
name|sentenceBreakClass
decl_stmt|;
DECL|member|lineBreakClass
name|LineBreakClass
name|lineBreakClass
decl_stmt|;
DECL|member|script
name|int
name|script
decl_stmt|;
comment|// from DerivedNormalizationProps.txt
DECL|member|nfQuickCheck
name|uchar
name|nfQuickCheck
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|specialCaseMap
specifier|static
name|QList
argument_list|<
name|int
argument_list|>
name|specialCaseMap
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|appendToSpecialCaseMap
specifier|static
name|int
name|appendToSpecialCaseMap
parameter_list|(
specifier|const
name|QList
argument_list|<
name|int
argument_list|>
modifier|&
name|map
parameter_list|)
block|{
name|QList
argument_list|<
name|int
argument_list|>
name|utf16map
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|map
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|uint
name|codepoint
init|=
name|map
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// if the condition below doesn't hold anymore we need to modify our special case mapping code
name|Q_ASSERT
argument_list|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
condition|)
block|{
name|utf16map
operator|<<
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|codepoint
argument_list|)
expr_stmt|;
name|utf16map
operator|<<
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|codepoint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf16map
operator|<<
name|codepoint
expr_stmt|;
block|}
block|}
name|int
name|length
init|=
name|utf16map
operator|.
name|size
argument_list|()
decl_stmt|;
name|utf16map
operator|.
name|prepend
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|specialCaseMap
operator|.
name|isEmpty
argument_list|()
condition|)
name|specialCaseMap
operator|<<
literal|0
expr_stmt|;
comment|// placeholder
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|specialCaseMap
operator|.
name|size
argument_list|()
condition|)
block|{
name|int
name|n
init|=
name|specialCaseMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|length
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|specialCaseMap
operator|.
name|at
argument_list|(
name|i
operator|+
name|j
argument_list|)
operator|!=
name|utf16map
operator|.
name|at
argument_list|(
name|j
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>
name|n
condition|)
return|return
name|i
return|;
block|}
name|i
operator|+=
name|n
operator|+
literal|1
expr_stmt|;
block|}
name|int
name|pos
init|=
name|specialCaseMap
operator|.
name|size
argument_list|()
decl_stmt|;
name|specialCaseMap
operator|<<
name|utf16map
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function
begin_comment
comment|// DerivedCoreProperties.txt
end_comment
begin_function
DECL|function|isDefaultIgnorable
specifier|static
specifier|inline
name|bool
name|isDefaultIgnorable
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
comment|// Default_Ignorable_Code_Point:
comment|//  Generated from
comment|//    Other_Default_Ignorable_Code_Point + Cf + Variation_Selector
comment|//    - White_Space - FFF9..FFFB (Annotation Characters)
comment|//    - 0600..0604, 06DD, 070F, 110BD (exceptional Cf characters that should be visible)
if|if
condition|(
name|ucs4
operator|<=
literal|0xff
condition|)
return|return
name|ucs4
operator|==
literal|0xad
return|;
return|return
name|ucs4
operator|==
literal|0x034f
operator|||
name|ucs4
operator|==
literal|0x061c
operator|||
operator|(
name|ucs4
operator|>=
literal|0x115f
operator|&&
name|ucs4
operator|<=
literal|0x1160
operator|)
operator|||
operator|(
name|ucs4
operator|>=
literal|0x17b4
operator|&&
name|ucs4
operator|<=
literal|0x17b5
operator|)
operator|||
operator|(
name|ucs4
operator|>=
literal|0x180b
operator|&&
name|ucs4
operator|<=
literal|0x180d
operator|)
operator|||
name|ucs4
operator|==
literal|0x180e
operator|||
operator|(
name|ucs4
operator|>=
literal|0x200b
operator|&&
name|ucs4
operator|<=
literal|0x200f
operator|)
operator|||
operator|(
name|ucs4
operator|>=
literal|0x202a
operator|&&
name|ucs4
operator|<=
literal|0x202e
operator|)
operator|||
operator|(
name|ucs4
operator|>=
literal|0x2060
operator|&&
name|ucs4
operator|<=
literal|0x206f
operator|)
operator|||
name|ucs4
operator|==
literal|0x3164
operator|||
operator|(
name|ucs4
operator|>=
literal|0xfe00
operator|&&
name|ucs4
operator|<=
literal|0xfe0f
operator|)
operator|||
name|ucs4
operator|==
literal|0xfeff
operator|||
name|ucs4
operator|==
literal|0xffa0
operator|||
operator|(
name|ucs4
operator|>=
literal|0xfff0
operator|&&
name|ucs4
operator|<=
literal|0xfff8
operator|)
operator|||
operator|(
name|ucs4
operator|>=
literal|0x1bca0
operator|&&
name|ucs4
operator|<=
literal|0x1bca3
operator|)
operator|||
operator|(
name|ucs4
operator|>=
literal|0x1d173
operator|&&
name|ucs4
operator|<=
literal|0x1d17a
operator|)
operator|||
operator|(
name|ucs4
operator|>=
literal|0xe0000
operator|&&
name|ucs4
operator|<=
literal|0xe0fff
operator|)
return|;
block|}
end_function
begin_struct
DECL|struct|UnicodeData
struct|struct
name|UnicodeData
block|{
DECL|function|UnicodeData
name|UnicodeData
parameter_list|(
name|int
name|codepoint
init|=
literal|0
parameter_list|)
block|{
name|p
operator|.
name|category
operator|=
name|QChar
operator|::
name|Other_NotAssigned
expr_stmt|;
comment|// Cn
name|p
operator|.
name|combiningClass
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|direction
operator|=
name|QChar
operator|::
name|DirL
expr_stmt|;
comment|// DerivedBidiClass.txt
comment|// The unassigned code points that default to AL are in the ranges:
comment|//     [U+0600..U+07BF, U+08A0..U+08FF, U+FB50..U+FDCF, U+FDF0..U+FDFF, U+FE70..U+FEFF, U+1EE00..U+1EEFF]
if|if
condition|(
operator|(
name|codepoint
operator|>=
literal|0x0600
operator|&&
name|codepoint
operator|<=
literal|0x07BF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x08A0
operator|&&
name|codepoint
operator|<=
literal|0x08FF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0xFB50
operator|&&
name|codepoint
operator|<=
literal|0xFDCF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0xFDF0
operator|&&
name|codepoint
operator|<=
literal|0xFDFF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0xFE70
operator|&&
name|codepoint
operator|<=
literal|0xFEFF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x1EE00
operator|&&
name|codepoint
operator|<=
literal|0x1EEFF
operator|)
condition|)
block|{
name|p
operator|.
name|direction
operator|=
name|QChar
operator|::
name|DirAL
expr_stmt|;
block|}
comment|// The unassigned code points that default to R are in the ranges:
comment|//     [U+0590..U+05FF, U+07C0..U+089F, U+FB1D..U+FB4F, U+10800..U+10FFF, U+1E800..U+1EDFF, U+1EF00..U+1EFFF]
elseif|else
if|if
condition|(
operator|(
name|codepoint
operator|>=
literal|0x0590
operator|&&
name|codepoint
operator|<=
literal|0x05FF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x07C0
operator|&&
name|codepoint
operator|<=
literal|0x089F
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0xFB1D
operator|&&
name|codepoint
operator|<=
literal|0xFB4F
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x10800
operator|&&
name|codepoint
operator|<=
literal|0x10FFF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x1E800
operator|&&
name|codepoint
operator|<=
literal|0x1EDFF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x1EF00
operator|&&
name|codepoint
operator|<=
literal|0x1EFFF
operator|)
condition|)
block|{
name|p
operator|.
name|direction
operator|=
name|QChar
operator|::
name|DirR
expr_stmt|;
block|}
comment|// The unassigned code points that default to ET are in the range:
comment|//     [U+20A0..U+20CF]
elseif|else
if|if
condition|(
name|codepoint
operator|>=
literal|0x20A0
operator|&&
name|codepoint
operator|<=
literal|0x20CF
condition|)
block|{
name|p
operator|.
name|direction
operator|=
name|QChar
operator|::
name|DirET
expr_stmt|;
block|}
comment|// The unassigned code points that default to BN have one of the following properties:
comment|//     Default_Ignorable_Code_Point
comment|//     Noncharacter_Code_Point
elseif|else
if|if
condition|(
name|QChar
operator|::
name|isNonCharacter
argument_list|(
name|codepoint
argument_list|)
operator|||
name|isDefaultIgnorable
argument_list|(
name|codepoint
argument_list|)
condition|)
block|{
name|p
operator|.
name|direction
operator|=
name|QChar
operator|::
name|DirBN
expr_stmt|;
block|}
name|p
operator|.
name|lineBreakClass
operator|=
name|LineBreak_AL
expr_stmt|;
comment|// XX -> AL
comment|// LineBreak.txt
comment|// The unassigned code points that default to "ID" include ranges in the following blocks:
comment|//     [U+3400..U+4DBF, U+4E00..U+9FFF, U+F900..U+FAFF, U+20000..U+2A6DF, U+2A700..U+2B73F, U+2B740..U+2B81F, U+2B820..U+2CEAF, U+2F800..U+2FA1F]
comment|// and any other reserved code points on
comment|//     [U+20000..U+2FFFD, U+30000..U+3FFFD]
if|if
condition|(
operator|(
name|codepoint
operator|>=
literal|0x3400
operator|&&
name|codepoint
operator|<=
literal|0x4DBF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x4E00
operator|&&
name|codepoint
operator|<=
literal|0x9FFF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0xF900
operator|&&
name|codepoint
operator|<=
literal|0xFAFF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x20000
operator|&&
name|codepoint
operator|<=
literal|0x2A6DF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x2A700
operator|&&
name|codepoint
operator|<=
literal|0x2B73F
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x2B740
operator|&&
name|codepoint
operator|<=
literal|0x2B81F
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x2B820
operator|&&
name|codepoint
operator|<=
literal|0x2CEAF
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x2F800
operator|&&
name|codepoint
operator|<=
literal|0x2FA1F
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x20000
operator|&&
name|codepoint
operator|<=
literal|0x2FFFD
operator|)
operator|||
operator|(
name|codepoint
operator|>=
literal|0x30000
operator|&&
name|codepoint
operator|<=
literal|0x3FFFD
operator|)
condition|)
block|{
name|p
operator|.
name|lineBreakClass
operator|=
name|LineBreak_ID
expr_stmt|;
block|}
comment|// The unassigned code points that default to "PR" comprise a range in the following block:
comment|//     [U+20A0..U+20CF]
elseif|else
if|if
condition|(
name|codepoint
operator|>=
literal|0x20A0
operator|&&
name|codepoint
operator|<=
literal|0x20CF
condition|)
block|{
name|p
operator|.
name|lineBreakClass
operator|=
name|LineBreak_PR
expr_stmt|;
block|}
name|mirroredChar
operator|=
literal|0
expr_stmt|;
name|decompositionType
operator|=
name|QChar
operator|::
name|NoDecomposition
expr_stmt|;
name|p
operator|.
name|joining
operator|=
name|QChar
operator|::
name|Joining_None
expr_stmt|;
name|p
operator|.
name|age
operator|=
name|QChar
operator|::
name|Unicode_Unassigned
expr_stmt|;
name|p
operator|.
name|mirrorDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|digitValue
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|.
name|lowerCaseDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|upperCaseDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|titleCaseDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|caseFoldDiff
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|lowerCaseSpecial
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|upperCaseSpecial
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|titleCaseSpecial
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|caseFoldSpecial
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|graphemeBreakClass
operator|=
name|GraphemeBreak_Other
expr_stmt|;
name|p
operator|.
name|wordBreakClass
operator|=
name|WordBreak_Other
expr_stmt|;
name|p
operator|.
name|sentenceBreakClass
operator|=
name|SentenceBreak_Other
expr_stmt|;
name|p
operator|.
name|script
operator|=
name|QChar
operator|::
name|Script_Unknown
expr_stmt|;
name|p
operator|.
name|nfQuickCheck
operator|=
literal|0
expr_stmt|;
name|propertyIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|excludedComposition
operator|=
literal|false
expr_stmt|;
block|}
specifier|static
name|UnicodeData
modifier|&
name|valueRef
parameter_list|(
name|int
name|codepoint
parameter_list|)
function_decl|;
DECL|member|p
name|PropertyFlags
name|p
decl_stmt|;
comment|// from UnicodeData.txt
DECL|member|decompositionType
name|QChar
operator|::
name|Decomposition
name|decompositionType
decl_stmt|;
DECL|member|decomposition
name|QList
argument_list|<
name|int
argument_list|>
name|decomposition
decl_stmt|;
DECL|member|specialFolding
name|QList
argument_list|<
name|int
argument_list|>
name|specialFolding
decl_stmt|;
comment|// from BidiMirroring.txt
DECL|member|mirroredChar
name|int
name|mirroredChar
decl_stmt|;
comment|// DerivedNormalizationProps.txt
DECL|member|excludedComposition
name|bool
name|excludedComposition
decl_stmt|;
comment|// computed position of unicode property set
DECL|member|propertyIndex
name|int
name|propertyIndex
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|unicodeData
specifier|static
name|QList
argument_list|<
name|UnicodeData
argument_list|>
name|unicodeData
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|valueRef
name|UnicodeData
modifier|&
name|UnicodeData
operator|::
name|valueRef
parameter_list|(
name|int
name|codepoint
parameter_list|)
block|{
specifier|static
name|bool
name|initialized
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|unicodeData
operator|.
name|reserve
argument_list|(
name|QChar
operator|::
name|LastValidCodePoint
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|uc
init|=
literal|0
init|;
name|uc
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
condition|;
operator|++
name|uc
control|)
name|unicodeData
operator|.
name|append
argument_list|(
name|UnicodeData
argument_list|(
name|uc
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|true
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|codepoint
operator|<=
literal|0x10ffff
argument_list|)
expr_stmt|;
return|return
name|unicodeData
index|[
name|codepoint
index|]
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|decompositionLength
specifier|static
name|QHash
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|decompositionLength
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|highestComposedCharacter
specifier|static
name|int
name|highestComposedCharacter
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|numLigatures
specifier|static
name|int
name|numLigatures
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|highestLigature
specifier|static
name|int
name|highestLigature
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|Ligature
struct|struct
name|Ligature
block|{
DECL|member|u1
name|int
name|u1
decl_stmt|;
DECL|member|u2
name|int
name|u2
decl_stmt|;
DECL|member|ligature
name|int
name|ligature
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|// we need them sorted after the first component for fast lookup
end_comment
begin_function
DECL|function|operator <
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|Ligature
modifier|&
name|l1
parameter_list|,
specifier|const
name|Ligature
modifier|&
name|l2
parameter_list|)
block|{
return|return
name|l1
operator|.
name|u1
operator|<
name|l2
operator|.
name|u1
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|ligatureHashes
specifier|static
name|QHash
argument_list|<
name|int
argument_list|,
name|QList
argument_list|<
name|Ligature
argument_list|>
argument_list|>
name|ligatureHashes
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|combiningClassUsage
specifier|static
name|QHash
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|combiningClassUsage
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|maxLowerCaseDiff
specifier|static
name|int
name|maxLowerCaseDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|maxUpperCaseDiff
specifier|static
name|int
name|maxUpperCaseDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|maxTitleCaseDiff
specifier|static
name|int
name|maxTitleCaseDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|readUnicodeData
specifier|static
name|void
name|readUnicodeData
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading UnicodeData.txt"
argument_list|)
expr_stmt|;
enum|enum
name|UniDataFields
block|{
name|UD_Value
block|,
name|UD_Name
block|,
name|UD_Category
block|,
name|UD_CombiningClass
block|,
name|UD_BidiCategory
block|,
name|UD_Decomposition
block|,
name|UD_DecimalDigitValue
block|,
name|UD_DigitValue
block|,
name|UD_NumericValue
block|,
name|UD_Mirrored
block|,
name|UD_OldName
block|,
name|UD_Comment
block|,
name|UD_UpperCase
block|,
name|UD_LowerCase
block|,
name|UD_TitleCase
block|}
enum|;
name|QFile
name|f
argument_list|(
literal|"data/UnicodeData.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find UnicodeData.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|truncate
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|properties
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|properties
index|[
name|UD_Value
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|codepoint
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
argument_list|)
expr_stmt|;
name|int
name|lastCodepoint
init|=
name|codepoint
decl_stmt|;
name|QByteArray
name|name
init|=
name|properties
index|[
name|UD_Name
index|]
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|'<'
argument_list|)
operator|&&
name|name
operator|.
name|contains
argument_list|(
literal|"First"
argument_list|)
condition|)
block|{
name|QByteArray
name|nextLine
decl_stmt|;
name|nextLine
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|f
operator|.
name|readLine
argument_list|(
name|nextLine
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|properties
init|=
name|nextLine
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|properties
index|[
name|UD_Name
index|]
operator|.
name|startsWith
argument_list|(
literal|'<'
argument_list|)
operator|&&
name|properties
index|[
name|UD_Name
index|]
operator|.
name|contains
argument_list|(
literal|"Last"
argument_list|)
argument_list|)
expr_stmt|;
name|lastCodepoint
operator|=
name|properties
index|[
name|UD_Value
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|lastCodepoint
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
argument_list|)
expr_stmt|;
block|}
name|UnicodeData
modifier|&
name|data
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|data
operator|.
name|p
operator|.
name|category
operator|=
name|categoryMap
operator|.
name|value
argument_list|(
name|properties
index|[
name|UD_Category
index|]
argument_list|,
name|QChar
operator|::
name|Other_NotAssigned
argument_list|)
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|combiningClass
operator|=
name|properties
index|[
name|UD_CombiningClass
index|]
operator|.
name|toInt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|combiningClassUsage
operator|.
name|contains
argument_list|(
name|data
operator|.
name|p
operator|.
name|combiningClass
argument_list|)
condition|)
name|combiningClassUsage
index|[
name|data
operator|.
name|p
operator|.
name|combiningClass
index|]
operator|=
literal|1
expr_stmt|;
else|else
operator|++
name|combiningClassUsage
index|[
name|data
operator|.
name|p
operator|.
name|combiningClass
index|]
expr_stmt|;
name|Direction
name|dir
init|=
name|directionMap
operator|.
name|value
argument_list|(
name|properties
index|[
name|UD_BidiCategory
index|]
argument_list|,
name|Dir_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|Dir_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unhandled direction value: %s"
argument_list|,
name|properties
index|[
name|UD_BidiCategory
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|direction
operator|=
name|QChar
operator|::
name|Direction
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|properties
index|[
name|UD_UpperCase
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|upperCase
init|=
name|properties
index|[
name|UD_UpperCase
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|diff
init|=
name|upperCase
operator|-
name|codepoint
decl_stmt|;
comment|// if the conditions below doesn't hold anymore we need to modify our upper casing code
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|upperCase
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|upperCase
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|+
name|diff
operator|==
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|upperCase
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qAbs
argument_list|(
name|diff
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|13
operator|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"upperCaseDiff exceeded ("
operator|<<
name|hex
operator|<<
name|codepoint
operator|<<
literal|"->"
operator|<<
name|upperCase
operator|<<
literal|"); map it for special case"
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|upperCaseSpecial
operator|=
literal|true
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|upperCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|QList
argument_list|<
name|int
argument_list|>
argument_list|()
operator|<<
name|upperCase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|.
name|p
operator|.
name|upperCaseDiff
operator|=
name|diff
expr_stmt|;
name|maxUpperCaseDiff
operator|=
name|qMax
argument_list|(
name|maxUpperCaseDiff
argument_list|,
name|qAbs
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|properties
index|[
name|UD_LowerCase
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|lowerCase
init|=
name|properties
index|[
name|UD_LowerCase
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|diff
init|=
name|lowerCase
operator|-
name|codepoint
decl_stmt|;
comment|// if the conditions below doesn't hold anymore we need to modify our lower casing code
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|lowerCase
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|lowerCase
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|+
name|diff
operator|==
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|lowerCase
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qAbs
argument_list|(
name|diff
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|13
operator|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"lowerCaseDiff exceeded ("
operator|<<
name|hex
operator|<<
name|codepoint
operator|<<
literal|"->"
operator|<<
name|lowerCase
operator|<<
literal|"); map it for special case"
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|lowerCaseSpecial
operator|=
literal|true
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|lowerCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|QList
argument_list|<
name|int
argument_list|>
argument_list|()
operator|<<
name|lowerCase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|.
name|p
operator|.
name|lowerCaseDiff
operator|=
name|diff
expr_stmt|;
name|maxLowerCaseDiff
operator|=
name|qMax
argument_list|(
name|maxLowerCaseDiff
argument_list|,
name|qAbs
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// we want toTitleCase to map to ToUpper in case we don't have any titlecase.
if|if
condition|(
name|properties
index|[
name|UD_TitleCase
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
name|properties
index|[
name|UD_TitleCase
index|]
operator|=
name|properties
index|[
name|UD_UpperCase
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|properties
index|[
name|UD_TitleCase
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|titleCase
init|=
name|properties
index|[
name|UD_TitleCase
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|diff
init|=
name|titleCase
operator|-
name|codepoint
decl_stmt|;
comment|// if the conditions below doesn't hold anymore we need to modify our title casing code
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|titleCase
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|titleCase
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|+
name|diff
operator|==
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|titleCase
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qAbs
argument_list|(
name|diff
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|13
operator|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"titleCaseDiff exceeded ("
operator|<<
name|hex
operator|<<
name|codepoint
operator|<<
literal|"->"
operator|<<
name|titleCase
operator|<<
literal|"); map it for special case"
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|titleCaseSpecial
operator|=
literal|true
expr_stmt|;
name|data
operator|.
name|p
operator|.
name|titleCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|QList
argument_list|<
name|int
argument_list|>
argument_list|()
operator|<<
name|titleCase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|.
name|p
operator|.
name|titleCaseDiff
operator|=
name|diff
expr_stmt|;
name|maxTitleCaseDiff
operator|=
name|qMax
argument_list|(
name|maxTitleCaseDiff
argument_list|,
name|qAbs
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|properties
index|[
name|UD_DigitValue
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
name|data
operator|.
name|p
operator|.
name|digitValue
operator|=
name|properties
index|[
name|UD_DigitValue
index|]
operator|.
name|toInt
argument_list|()
expr_stmt|;
comment|// decompositition
name|QByteArray
name|decomposition
init|=
name|properties
index|[
name|UD_Decomposition
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|decomposition
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|highestComposedCharacter
operator|=
name|qMax
argument_list|(
name|highestComposedCharacter
argument_list|,
name|codepoint
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|d
init|=
name|decomposition
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
index|[
literal|0
index|]
operator|.
name|contains
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|data
operator|.
name|decompositionType
operator|=
name|decompositionMap
operator|.
name|value
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|QChar
operator|::
name|NoDecomposition
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|decompositionType
operator|==
name|QChar
operator|::
name|NoDecomposition
condition|)
name|qFatal
argument_list|(
literal|"unhandled decomposition type: %s"
argument_list|,
name|d
index|[
literal|0
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|data
operator|.
name|decompositionType
operator|=
name|QChar
operator|::
name|Canonical
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|data
operator|.
name|decomposition
operator|.
name|append
argument_list|(
name|d
index|[
name|i
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
operator|++
name|decompositionLength
index|[
name|data
operator|.
name|decomposition
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|codepoint
init|;
name|i
operator|<=
name|lastCodepoint
condition|;
operator|++
name|i
control|)
name|unicodeData
index|[
name|i
index|]
operator|=
name|data
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|maxMirroredDiff
specifier|static
name|int
name|maxMirroredDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|readBidiMirroring
specifier|static
name|void
name|readBidiMirroring
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading BidiMirroring.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/BidiMirroring.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find BidiMirroring.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|line
operator|=
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|pair
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|pair
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|pair
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|mirror
init|=
name|pair
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|d
operator|.
name|mirroredChar
operator|=
name|mirror
expr_stmt|;
name|d
operator|.
name|p
operator|.
name|mirrorDiff
operator|=
name|d
operator|.
name|mirroredChar
operator|-
name|codepoint
expr_stmt|;
name|maxMirroredDiff
operator|=
name|qMax
argument_list|(
name|maxMirroredDiff
argument_list|,
name|qAbs
argument_list|(
name|d
operator|.
name|p
operator|.
name|mirrorDiff
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|readArabicShaping
specifier|static
name|void
name|readArabicShaping
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading ArabicShaping.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/ArabicShaping.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find ArabicShaping.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|=
name|line
operator|.
name|trimmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|4
argument_list|)
expr_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|l
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|JoiningType
name|joining
init|=
name|joining_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|2
index|]
operator|.
name|trimmed
argument_list|()
argument_list|,
name|Joining_Unassigned
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|joining
condition|)
block|{
case|case
name|Joining_Unassigned
case|:
name|qFatal
argument_list|(
literal|"%x: unassigned or unhandled joining type: %s"
argument_list|,
name|codepoint
argument_list|,
name|l
index|[
literal|2
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Joining_Transparent
case|:
if|if
condition|(
name|d
operator|.
name|p
operator|.
name|category
operator|!=
name|QChar
operator|::
name|Mark_NonSpacing
operator|&&
name|d
operator|.
name|p
operator|.
name|category
operator|!=
name|QChar
operator|::
name|Mark_Enclosing
operator|&&
name|d
operator|.
name|p
operator|.
name|category
operator|!=
name|QChar
operator|::
name|Other_Format
condition|)
block|{
name|qFatal
argument_list|(
literal|"%x: joining type '%s' was met; the current implementation needs to be revised!"
argument_list|,
name|codepoint
argument_list|,
name|l
index|[
literal|2
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// fall through
default|default:
name|d
operator|.
name|p
operator|.
name|joining
operator|=
name|QChar
operator|::
name|JoiningType
argument_list|(
name|joining
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// Code points that are not explicitly listed in ArabicShaping.txt are either of joining type T or U:
comment|// - Those that not explicitly listed that are of General Category Mn, Me, or Cf have joining type T.
comment|// - All others not explicitly listed have joining type U.
for|for
control|(
name|int
name|codepoint
init|=
literal|0
init|;
name|codepoint
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|p
operator|.
name|joining
operator|==
name|QChar
operator|::
name|Joining_None
condition|)
block|{
if|if
condition|(
name|d
operator|.
name|p
operator|.
name|category
operator|==
name|QChar
operator|::
name|Mark_NonSpacing
operator|||
name|d
operator|.
name|p
operator|.
name|category
operator|==
name|QChar
operator|::
name|Mark_Enclosing
operator|||
name|d
operator|.
name|p
operator|.
name|category
operator|==
name|QChar
operator|::
name|Other_Format
condition|)
name|d
operator|.
name|p
operator|.
name|joining
operator|=
name|QChar
operator|::
name|Joining_Transparent
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readDerivedAge
specifier|static
name|void
name|readDerivedAge
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading DerivedAge.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/DerivedAge.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find DerivedAge.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|QChar
operator|::
name|UnicodeVersion
name|age
init|=
name|age_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
operator|.
name|trimmed
argument_list|()
argument_list|,
name|QChar
operator|::
name|Unicode_Unassigned
argument_list|)
decl_stmt|;
comment|//qDebug()<< hex<< from<< ".."<< to<< ba<< age;
if|if
condition|(
name|age
operator|==
name|QChar
operator|::
name|Unicode_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned or unhandled age value: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|d
operator|.
name|p
operator|.
name|age
operator|=
name|age
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readDerivedNormalizationProps
specifier|static
name|void
name|readDerivedNormalizationProps
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading DerivedNormalizationProps.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/DerivedNormalizationProps.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find DerivedNormalizationProps.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|trimmed
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|propName
init|=
name|l
index|[
literal|1
index|]
operator|.
name|trimmed
argument_list|()
decl_stmt|;
if|if
condition|(
name|propName
operator|!=
literal|"Full_Composition_Exclusion"
operator|&&
name|propName
operator|!=
literal|"NFD_QC"
operator|&&
name|propName
operator|!=
literal|"NFC_QC"
operator|&&
name|propName
operator|!=
literal|"NFKD_QC"
operator|&&
name|propName
operator|!=
literal|"NFKC_QC"
condition|)
block|{
comment|// ###
continue|continue;
block|}
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
if|if
condition|(
name|propName
operator|==
literal|"Full_Composition_Exclusion"
condition|)
block|{
name|d
operator|.
name|excludedComposition
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|Q_STATIC_ASSERT
argument_list|(
name|QString
operator|::
name|NormalizationForm_D
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Q_STATIC_ASSERT
argument_list|(
name|QString
operator|::
name|NormalizationForm_C
operator|==
literal|1
argument_list|)
expr_stmt|;
name|Q_STATIC_ASSERT
argument_list|(
name|QString
operator|::
name|NormalizationForm_KD
operator|==
literal|2
argument_list|)
expr_stmt|;
name|Q_STATIC_ASSERT
argument_list|(
name|QString
operator|::
name|NormalizationForm_KC
operator|==
literal|3
argument_list|)
expr_stmt|;
name|QString
operator|::
name|NormalizationForm
name|form
decl_stmt|;
if|if
condition|(
name|propName
operator|==
literal|"NFD_QC"
condition|)
name|form
operator|=
name|QString
operator|::
name|NormalizationForm_D
expr_stmt|;
elseif|else
if|if
condition|(
name|propName
operator|==
literal|"NFC_QC"
condition|)
name|form
operator|=
name|QString
operator|::
name|NormalizationForm_C
expr_stmt|;
elseif|else
if|if
condition|(
name|propName
operator|==
literal|"NFKD_QC"
condition|)
name|form
operator|=
name|QString
operator|::
name|NormalizationForm_KD
expr_stmt|;
else|else
comment|// if (propName == "NFKC_QC")
name|form
operator|=
name|QString
operator|::
name|NormalizationForm_KC
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|3
argument_list|)
expr_stmt|;
name|l
index|[
literal|2
index|]
operator|=
name|l
index|[
literal|2
index|]
operator|.
name|trimmed
argument_list|()
expr_stmt|;
enum|enum
block|{
name|NFQC_YES
init|=
literal|0
block|,
name|NFQC_NO
init|=
literal|1
block|,
name|NFQC_MAYBE
init|=
literal|3
block|}
enum|;
name|uchar
name|ynm
init|=
operator|(
name|l
index|[
literal|2
index|]
operator|==
literal|"N"
condition|?
name|NFQC_NO
else|:
name|l
index|[
literal|2
index|]
operator|==
literal|"M"
condition|?
name|NFQC_MAYBE
else|:
name|NFQC_YES
operator|)
decl_stmt|;
if|if
condition|(
name|ynm
operator|==
name|NFQC_MAYBE
condition|)
block|{
comment|// if this changes, we need to revise the normalizationQuickCheckHelper() implementation
name|Q_ASSERT
argument_list|(
name|form
operator|==
name|QString
operator|::
name|NormalizationForm_C
operator|||
name|form
operator|==
name|QString
operator|::
name|NormalizationForm_KC
argument_list|)
expr_stmt|;
block|}
name|d
operator|.
name|p
operator|.
name|nfQuickCheck
operator||=
operator|(
name|ynm
operator|<<
operator|(
name|form
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
comment|// 2 bits per NF
block|}
block|}
block|}
for|for
control|(
name|int
name|codepoint
init|=
literal|0
init|;
name|codepoint
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|excludedComposition
operator|&&
name|d
operator|.
name|decompositionType
operator|==
name|QChar
operator|::
name|Canonical
operator|&&
name|d
operator|.
name|decomposition
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|d
operator|.
name|decomposition
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|int
name|part1
init|=
name|d
operator|.
name|decomposition
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|part2
init|=
name|d
operator|.
name|decomposition
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// all non-starters are listed in DerivedNormalizationProps.txt
comment|// and already excluded from composition
name|Q_ASSERT
argument_list|(
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|part1
argument_list|)
operator|.
name|p
operator|.
name|combiningClass
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|++
name|numLigatures
expr_stmt|;
name|highestLigature
operator|=
name|qMax
argument_list|(
name|highestLigature
argument_list|,
name|part1
argument_list|)
expr_stmt|;
name|Ligature
name|l
init|=
block|{
name|part1
block|,
name|part2
block|,
name|codepoint
block|}
decl_stmt|;
name|ligatureHashes
index|[
name|part2
index|]
operator|.
name|append
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_struct
DECL|struct|NormalizationCorrection
struct|struct
name|NormalizationCorrection
block|{
DECL|member|codepoint
name|uint
name|codepoint
decl_stmt|;
DECL|member|mapped
name|uint
name|mapped
decl_stmt|;
DECL|member|version
name|int
name|version
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|createNormalizationCorrections
specifier|static
name|QByteArray
name|createNormalizationCorrections
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading NormalizationCorrections.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/NormalizationCorrections.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find NormalizationCorrections.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"struct NormalizationCorrection {\n"
literal|"    uint ucs4;\n"
literal|"    uint old_mapping;\n"
literal|"    int version;\n"
literal|"};\n\n"
literal|"static const NormalizationCorrection uc_normalization_corrections[] = {\n"
expr_stmt|;
name|int
name|maxVersion
init|=
literal|0
decl_stmt|;
name|int
name|numCorrections
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|Q_ASSERT
argument_list|(
operator|!
name|line
operator|.
name|contains
argument_list|(
literal|".."
argument_list|)
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|fields
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|fields
operator|.
name|size
argument_list|()
operator|==
literal|4
argument_list|)
expr_stmt|;
name|NormalizationCorrection
name|c
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|c
operator|.
name|codepoint
operator|=
name|fields
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|c
operator|.
name|mapped
operator|=
name|fields
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|==
literal|"3.2.0"
condition|)
name|c
operator|.
name|version
operator|=
name|QChar
operator|::
name|Unicode_3_2
expr_stmt|;
elseif|else
if|if
condition|(
name|fields
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|==
literal|"4.0.0"
condition|)
name|c
operator|.
name|version
operator|=
name|QChar
operator|::
name|Unicode_4_0
expr_stmt|;
else|else
name|qFatal
argument_list|(
literal|"unknown unicode version in NormalizationCorrection.txt"
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"    { 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|c
operator|.
name|codepoint
argument_list|,
literal|16
argument_list|)
operator|+
literal|", 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|c
operator|.
name|mapped
argument_list|,
literal|16
argument_list|)
operator|+
literal|", "
operator|+
name|QString
operator|::
name|number
argument_list|(
name|c
operator|.
name|version
argument_list|)
operator|+
literal|" },\n"
expr_stmt|;
operator|++
name|numCorrections
expr_stmt|;
name|maxVersion
operator|=
name|qMax
argument_list|(
name|c
operator|.
name|version
argument_list|,
name|maxVersion
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|",\n"
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
literal|"enum { NumNormalizationCorrections = "
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|numCorrections
argument_list|)
operator|+
literal|" };\n"
literal|"enum { NormalizationCorrectionsVersionMax = "
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|maxVersion
argument_list|)
operator|+
literal|" };\n\n"
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|readLineBreak
specifier|static
name|void
name|readLineBreak
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading LineBreak.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/LineBreak.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find LineBreak.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|LineBreakClass
name|lb
init|=
name|line_break_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|LineBreak_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|lb
operator|==
name|LineBreak_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned line break class: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|d
operator|.
name|p
operator|.
name|lineBreakClass
operator|=
name|lb
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readSpecialCasing
specifier|static
name|void
name|readSpecialCasing
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading SpecialCasing.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/SpecialCasing.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find SpecialCasing.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|QByteArray
name|condition
init|=
name|l
operator|.
name|size
argument_list|()
operator|<
literal|5
condition|?
name|QByteArray
argument_list|()
else|:
name|l
index|[
literal|4
index|]
operator|.
name|trimmed
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|condition
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// #####
continue|continue;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|l
index|[
literal|0
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
comment|// if the condition below doesn't hold anymore we need to modify our
comment|// lower/upper/title casing code and case folding code
name|Q_ASSERT
argument_list|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
argument_list|)
expr_stmt|;
comment|//         qDebug()<< "codepoint"<< hex<< codepoint;
comment|//         qDebug()<< line;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|lower
init|=
name|l
index|[
literal|1
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|lowerMap
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lower
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|ok
decl_stmt|;
name|lowerMap
operator|.
name|append
argument_list|(
name|lower
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|title
init|=
name|l
index|[
literal|2
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|titleMap
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|title
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|ok
decl_stmt|;
name|titleMap
operator|.
name|append
argument_list|(
name|title
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|upper
init|=
name|l
index|[
literal|3
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|upperMap
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|upper
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|ok
decl_stmt|;
name|upperMap
operator|.
name|append
argument_list|(
name|upper
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|UnicodeData
modifier|&
name|ud
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|lowerMap
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|lowerMap
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|codepoint
operator|+
name|ud
operator|.
name|p
operator|.
name|lowerCaseDiff
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|titleMap
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|titleMap
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|codepoint
operator|+
name|ud
operator|.
name|p
operator|.
name|titleCaseDiff
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|upperMap
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|upperMap
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|codepoint
operator|+
name|ud
operator|.
name|p
operator|.
name|upperCaseDiff
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowerMap
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ud
operator|.
name|p
operator|.
name|lowerCaseSpecial
operator|=
literal|true
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|lowerCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|lowerMap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|titleMap
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ud
operator|.
name|p
operator|.
name|titleCaseSpecial
operator|=
literal|true
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|titleCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|titleMap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|upperMap
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ud
operator|.
name|p
operator|.
name|upperCaseSpecial
operator|=
literal|true
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|upperCaseDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|upperMap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|maxCaseFoldDiff
specifier|static
name|int
name|maxCaseFoldDiff
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|readCaseFolding
specifier|static
name|void
name|readCaseFolding
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading CaseFolding.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/CaseFolding.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find CaseFolding.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|codepoint
init|=
name|l
index|[
literal|0
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|l
index|[
literal|1
index|]
operator|=
name|l
index|[
literal|1
index|]
operator|.
name|trimmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|l
index|[
literal|1
index|]
operator|==
literal|"F"
operator|||
name|l
index|[
literal|1
index|]
operator|==
literal|"T"
condition|)
continue|continue;
comment|//         qDebug()<< "codepoint"<< hex<< codepoint;
comment|//         qDebug()<< line;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|fold
init|=
name|l
index|[
literal|2
index|]
operator|.
name|trimmed
argument_list|()
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|foldMap
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fold
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|ok
decl_stmt|;
name|foldMap
operator|.
name|append
argument_list|(
name|fold
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|UnicodeData
modifier|&
name|ud
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
if|if
condition|(
name|foldMap
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|int
name|caseFolded
init|=
name|foldMap
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|diff
init|=
name|caseFolded
operator|-
name|codepoint
decl_stmt|;
comment|// if the conditions below doesn't hold anymore we need to modify our case folding code
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|caseFolded
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|codepoint
argument_list|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|==
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|caseFolded
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|codepoint
argument_list|)
operator|+
name|diff
operator|==
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|caseFolded
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qAbs
argument_list|(
name|diff
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|13
operator|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"caseFoldDiff exceeded ("
operator|<<
name|hex
operator|<<
name|codepoint
operator|<<
literal|"->"
operator|<<
name|caseFolded
operator|<<
literal|"); map it for special case"
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|caseFoldSpecial
operator|=
literal|true
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|caseFoldDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|foldMap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ud
operator|.
name|p
operator|.
name|caseFoldDiff
operator|=
name|diff
expr_stmt|;
name|maxCaseFoldDiff
operator|=
name|qMax
argument_list|(
name|maxCaseFoldDiff
argument_list|,
name|qAbs
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|qFatal
argument_list|(
literal|"we currently don't support full case foldings"
argument_list|)
expr_stmt|;
comment|//             qDebug()<< "special"<< hex<< foldMap;
name|ud
operator|.
name|p
operator|.
name|caseFoldSpecial
operator|=
literal|true
expr_stmt|;
name|ud
operator|.
name|p
operator|.
name|caseFoldDiff
operator|=
name|appendToSpecialCaseMap
argument_list|(
name|foldMap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readGraphemeBreak
specifier|static
name|void
name|readGraphemeBreak
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading GraphemeBreakProperty.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/GraphemeBreakProperty.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find GraphemeBreakProperty.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|GraphemeBreakClass
name|brk
init|=
name|grapheme_break_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|GraphemeBreak_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|brk
operator|==
name|GraphemeBreak_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned grapheme break class: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|ud
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|ud
operator|.
name|p
operator|.
name|graphemeBreakClass
operator|=
name|brk
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readWordBreak
specifier|static
name|void
name|readWordBreak
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading WordBreakProperty.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/WordBreakProperty.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find WordBreakProperty.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|WordBreakClass
name|brk
init|=
name|word_break_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|WordBreak_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|brk
operator|==
name|WordBreak_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned word break class: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
comment|// ### [
comment|// as of Unicode 5.1, some punctuation marks were mapped to MidLetter and MidNumLet
comment|// which caused "hi.there" to be treated like if it were just a single word;
comment|// until we have a tailoring mechanism, retain the old behavior by remapping those characters here.
if|if
condition|(
name|codepoint
operator|==
literal|0x002E
condition|)
comment|// FULL STOP
name|brk
operator|=
name|WordBreak_MidNum
expr_stmt|;
elseif|else
if|if
condition|(
name|codepoint
operator|==
literal|0x003A
condition|)
comment|// COLON
name|brk
operator|=
name|WordBreak_Other
expr_stmt|;
comment|// ] ###
name|UnicodeData
modifier|&
name|ud
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|ud
operator|.
name|p
operator|.
name|wordBreakClass
operator|=
name|brk
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readSentenceBreak
specifier|static
name|void
name|readSentenceBreak
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading SentenceBreakProperty.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/SentenceBreakProperty.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find SentenceBreakProperty.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|f
operator|.
name|readLine
argument_list|(
name|line
operator|.
name|data
argument_list|()
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|l
init|=
name|line
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|QByteArray
name|codes
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|codes
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codes
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|from
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|to
init|=
name|from
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|to
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|SentenceBreakClass
name|brk
init|=
name|sentence_break_map
operator|.
name|value
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|SentenceBreak_Unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|brk
operator|==
name|SentenceBreak_Unassigned
condition|)
name|qFatal
argument_list|(
literal|"unassigned sentence break class: %s"
argument_list|,
name|l
index|[
literal|1
index|]
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|from
init|;
name|codepoint
operator|<=
name|to
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|ud
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|ud
operator|.
name|p
operator|.
name|sentenceBreakClass
operator|=
name|brk
expr_stmt|;
block|}
block|}
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|// this piece of code does full case folding and comparison. We currently
end_comment
begin_comment
comment|// don't use it, since this gives lots of issues with things as case insensitive
end_comment
begin_comment
comment|// search and replace.
end_comment
begin_endif
unit|static inline void foldCase(uint ch, ushort *out) {     const QUnicodeTables::Properties *p = qGetProp(ch);     if (!p->caseFoldSpecial) {         *(out++) = ch + p->caseFoldDiff;     } else {         const ushort *folded = specialCaseMap + p->caseFoldDiff;         ushort length = *folded++;         while (length--)             *out++ = *folded++;     }     *out = 0; }  static int ucstricmp(const ushort *a, const ushort *ae, const ushort *b, const ushort *be) {     if (a == b)         return 0;     if (a == 0)         return 1;     if (b == 0)         return -1;      while (a != ae&& b != be) {         const QUnicodeTables::Properties *pa = qGetProp(*a);         const QUnicodeTables::Properties *pb = qGetProp(*b);         if (pa->caseFoldSpecial | pb->caseFoldSpecial)             goto special;             int diff = (int)(*a + pa->caseFoldDiff) - (int)(*b + pb->caseFoldDiff);         if ((diff))             return diff;         ++a;         ++b;         }     }     if (a == ae) {         if (b == be)             return 0;         return -1;     }     return 1; special:     ushort abuf[SPECIAL_CASE_MAX_LEN + 1];     ushort bbuf[SPECIAL_CASE_MAX_LEN + 1];     abuf[0] = bbuf[0] = 0;     ushort *ap = abuf;     ushort *bp = bbuf;     while (1) {         if (!*ap) {             if (a == ae) {                 if (!*bp&& b == be)                     return 0;                 return -1;             }             foldCase(*(a++), abuf);             ap = abuf;         }         if (!*bp) {             if (b == be)                 return 1;             foldCase(*(b++), bbuf);             bp = bbuf;         }         if (*ap != *bp)             return (int)*ap - (int)*bp;         ++ap;         ++bp;     } }   static int ucstricmp(const ushort *a, const ushort *ae, const uchar *b) {     if (a == 0)         return 1;     if (b == 0)         return -1;      while (a != ae&& *b) {         const QUnicodeTables::Properties *pa = qGetProp(*a);         const QUnicodeTables::Properties *pb = qGetProp((ushort)*b);         if (pa->caseFoldSpecial | pb->caseFoldSpecial)             goto special;         int diff = (int)(*a + pa->caseFoldDiff) - (int)(*b + pb->caseFoldDiff);         if ((diff))             return diff;         ++a;         ++b;     }     if (a == ae) {         if (!*b)             return 0;         return -1;     }     return 1;  special:     ushort abuf[SPECIAL_CASE_MAX_LEN + 1];     ushort bbuf[SPECIAL_CASE_MAX_LEN + 1];     abuf[0] = bbuf[0] = 0;     ushort *ap = abuf;     ushort *bp = bbuf;     while (1) {         if (!*ap) {             if (a == ae) {                 if (!*bp&& !*b)                     return 0;                 return -1;             }             foldCase(*(a++), abuf);             ap = abuf;         }         if (!*bp) {             if (!*b)                 return 1;             foldCase(*(b++), bbuf);             bp = bbuf;         }         if (*ap != *bp)             return (int)*ap - (int)*bp;         ++ap;         ++bp;     } }
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|static QList<QByteArray> blockNames; struct BlockInfo {     int blockIndex;     int firstCodePoint;     int lastCodePoint; }; static QList<BlockInfo> blockInfoList;  static void readBlocks() {     qDebug("Reading Blocks.txt");      QFile f("data/Blocks.txt");     if (!f.exists())         qFatal("Couldn't find Blocks.txt");      f.open(QFile::ReadOnly);      while (!f.atEnd()) {         QByteArray line = f.readLine();         line.resize(line.size() - 1);          int comment = line.indexOf("#");         if (comment>= 0)             line = line.left(comment);          line.replace(" ", "");          if (line.isEmpty())             continue;          int semicolon = line.indexOf(';');         Q_ASSERT(semicolon>= 0);         QByteArray codePoints = line.left(semicolon);         QByteArray blockName = line.mid(semicolon + 1);          int blockIndex = blockNames.indexOf(blockName);         if (blockIndex == -1) {             blockIndex = blockNames.size();             blockNames.append(blockName);         }          codePoints.replace("..", ".");         QList<QByteArray> cl = codePoints.split('.');          bool ok;         int first = cl[0].toInt(&ok, 16);         Q_ASSERT(ok);         int last = first;         if (cl.size() == 2) {             last = cl[1].toInt(&ok, 16);             Q_ASSERT(ok);         }          BlockInfo blockInfo = { blockIndex, first, last };         blockInfoList.append(blockInfo);     } }
endif|#
directive|endif
end_endif
begin_function
DECL|function|readScripts
specifier|static
name|void
name|readScripts
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Reading Scripts.txt"
argument_list|)
expr_stmt|;
name|QFile
name|f
argument_list|(
literal|"data/Scripts.txt"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
name|qFatal
argument_list|(
literal|"Couldn't find Scripts.txt"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|f
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
init|=
name|f
operator|.
name|readLine
argument_list|()
decl_stmt|;
name|line
operator|.
name|resize
argument_list|(
name|line
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|comment
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|"#"
argument_list|)
decl_stmt|;
if|if
condition|(
name|comment
operator|>=
literal|0
condition|)
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|"_"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|int
name|semicolon
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|semicolon
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|QByteArray
name|codePoints
init|=
name|line
operator|.
name|left
argument_list|(
name|semicolon
argument_list|)
decl_stmt|;
name|QByteArray
name|scriptName
init|=
name|line
operator|.
name|mid
argument_list|(
name|semicolon
operator|+
literal|1
argument_list|)
decl_stmt|;
name|codePoints
operator|.
name|replace
argument_list|(
literal|".."
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cl
init|=
name|codePoints
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|first
init|=
name|cl
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|int
name|last
init|=
name|first
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|last
operator|=
name|cl
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|scriptMap
operator|.
name|contains
argument_list|(
name|scriptName
argument_list|)
condition|)
name|qFatal
argument_list|(
literal|"Unhandled script property value: %s"
argument_list|,
name|scriptName
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|QChar
operator|::
name|Script
name|script
init|=
name|scriptMap
operator|.
name|value
argument_list|(
name|scriptName
argument_list|,
name|QChar
operator|::
name|Script_Unknown
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
name|first
init|;
name|codepoint
operator|<=
name|last
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|ud
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|ud
operator|.
name|p
operator|.
name|script
operator|=
name|script
expr_stmt|;
block|}
block|}
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|static void dump(int from, int to) {     for (int i = from; i<= to; ++i) {         UnicodeData&d = UnicodeData::valueRef(i);         qDebug("0x%04x: cat=%d combining=%d dir=%d case=%x mirror=%x joining=%d age=%d",                i, d.p.category, d.p.combiningClass, d.p.direction, d.otherCase, d.mirroredChar, d.p.joining, d.p.age);         if (d.decompositionType != QChar::NoDecomposition) {             qDebug("    decomposition: type=%d, length=%d, first=%x", d.decompositionType, d.decomposition.size(),                    d.decomposition[0]);         }     }     qDebug(" "); }
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|uniqueProperties
specifier|static
name|QList
argument_list|<
name|PropertyFlags
argument_list|>
name|uniqueProperties
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|computeUniqueProperties
specifier|static
name|void
name|computeUniqueProperties
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"computeUniqueProperties:"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|codepoint
init|=
literal|0
init|;
name|codepoint
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
condition|;
operator|++
name|codepoint
control|)
block|{
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|codepoint
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|uniqueProperties
operator|.
name|indexOf
argument_list|(
name|d
operator|.
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueProperties
operator|.
name|size
argument_list|()
expr_stmt|;
name|uniqueProperties
operator|.
name|append
argument_list|(
name|d
operator|.
name|p
argument_list|)
expr_stmt|;
block|}
name|d
operator|.
name|propertyIndex
operator|=
name|index
expr_stmt|;
block|}
name|qDebug
argument_list|(
literal|"    %d unique unicode properties found"
argument_list|,
name|uniqueProperties
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|UniqueBlock
struct|struct
name|UniqueBlock
block|{
DECL|function|UniqueBlock
specifier|inline
name|UniqueBlock
parameter_list|()
member_init_list|:
name|index
argument_list|(
operator|-
literal|1
argument_list|)
block|{}
DECL|function|operator ==
specifier|inline
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|UniqueBlock
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|values
operator|==
name|other
operator|.
name|values
return|;
block|}
DECL|member|index
name|int
name|index
decl_stmt|;
DECL|member|values
name|QVector
argument_list|<
name|int
argument_list|>
name|values
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|createPropertyInfo
specifier|static
name|QByteArray
name|createPropertyInfo
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"createPropertyInfo:"
argument_list|)
expr_stmt|;
comment|// we reserve one bit more than in the assert below for the sign
name|Q_ASSERT
argument_list|(
name|maxMirroredDiff
operator|<
operator|(
literal|1
operator|<<
literal|12
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|maxLowerCaseDiff
operator|<
operator|(
literal|1
operator|<<
literal|13
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|maxUpperCaseDiff
operator|<
operator|(
literal|1
operator|<<
literal|13
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|maxTitleCaseDiff
operator|<
operator|(
literal|1
operator|<<
literal|13
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|maxCaseFoldDiff
operator|<
operator|(
literal|1
operator|<<
literal|13
operator|)
argument_list|)
expr_stmt|;
specifier|const
name|int
name|BMP_BLOCKSIZE
init|=
literal|32
decl_stmt|;
specifier|const
name|int
name|BMP_SHIFT
init|=
literal|5
decl_stmt|;
specifier|const
name|int
name|BMP_END
init|=
literal|0x11000
decl_stmt|;
specifier|const
name|int
name|SMP_END
init|=
literal|0x110000
decl_stmt|;
specifier|const
name|int
name|SMP_BLOCKSIZE
init|=
literal|256
decl_stmt|;
specifier|const
name|int
name|SMP_SHIFT
init|=
literal|8
decl_stmt|;
name|QList
argument_list|<
name|UniqueBlock
argument_list|>
name|uniqueBlocks
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
name|blockMap
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
literal|0
init|;
name|block
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|UniqueBlock
name|b
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|reserve
argument_list|(
name|BMP_BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|BMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|uc
argument_list|)
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
name|d
operator|.
name|propertyIndex
argument_list|)
expr_stmt|;
block|}
name|int
name|index
init|=
name|uniqueBlocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|BMP_BLOCKSIZE
expr_stmt|;
name|uniqueBlocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|bmp_blocks
init|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
name|BMP_END
operator|/
name|SMP_BLOCKSIZE
init|;
name|block
operator|<
name|SMP_END
operator|/
name|SMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|UniqueBlock
name|b
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|reserve
argument_list|(
name|SMP_BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|SMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|uc
argument_list|)
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
name|d
operator|.
name|propertyIndex
argument_list|)
expr_stmt|;
block|}
name|int
name|index
init|=
name|uniqueBlocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|SMP_BLOCKSIZE
expr_stmt|;
name|uniqueBlocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|smp_blocks
init|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
operator|-
name|bmp_blocks
decl_stmt|;
name|int
name|bmp_block_data
init|=
name|bmp_blocks
operator|*
name|BMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|bmp_trie
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|bmp_mem
init|=
name|bmp_block_data
operator|+
name|bmp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in BMP."
argument_list|,
name|bmp_blocks
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|bmp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|bmp_trie
argument_list|)
expr_stmt|;
name|int
name|smp_block_data
init|=
name|smp_blocks
operator|*
name|SMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|smp_trie
init|=
operator|(
name|SMP_END
operator|-
name|BMP_END
operator|)
operator|/
name|SMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|smp_mem
init|=
name|smp_block_data
operator|+
name|smp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in SMP."
argument_list|,
name|smp_blocks
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|smp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|smp_trie
argument_list|)
expr_stmt|;
name|int
name|prop_data
init|=
name|uniqueProperties
operator|.
name|size
argument_list|()
operator|*
name|SizeOfPropertiesStruct
decl_stmt|;
name|qDebug
argument_list|(
literal|"\n        properties data uses : %d bytes"
argument_list|,
name|prop_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"    memory usage: %d bytes"
argument_list|,
name|bmp_mem
operator|+
name|smp_mem
operator|+
name|prop_data
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|blockMap
operator|.
name|last
argument_list|()
operator|+
name|blockMap
operator|.
name|size
argument_list|()
operator|<
operator|(
literal|1
operator|<<
operator|(
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
operator|*
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"static const unsigned short uc_property_trie[] = {\n"
expr_stmt|;
comment|// first write the map
name|out
operator|+=
literal|"    // [0x0..0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|")"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|i
operator|*
name|BMP_BLOCKSIZE
operator|)
operator|%
literal|0x1000
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n\n    // [0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|"..0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|")\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
init|;
name|i
operator|<
name|blockMap
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
operator|(
literal|0x10000
operator|/
name|SMP_BLOCKSIZE
operator|)
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
comment|// write the data
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uniqueBlocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
specifier|const
name|UniqueBlock
modifier|&
name|b
init|=
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|b
operator|.
name|values
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|j
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|b
operator|.
name|values
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|", "
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
name|out
operator|+=
literal|"#define GET_PROP_INDEX(ucs4) \\\n"
literal|"       (ucs4< 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" \\\n"
literal|"        ? (uc_property_trie[uc_property_trie[ucs4>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_SHIFT
argument_list|)
operator|+
literal|"] + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")]) \\\n"
literal|"        : (uc_property_trie[uc_property_trie[((ucs4 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|")>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_SHIFT
argument_list|)
operator|+
literal|") + 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
argument_list|,
literal|16
argument_list|)
operator|+
literal|"]"
literal|" + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")]))\n\n"
literal|"#define GET_PROP_INDEX_UCS2(ucs2) \\\n"
literal|"       (uc_property_trie[uc_property_trie[ucs2>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_SHIFT
argument_list|)
operator|+
literal|"] + (ucs2& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")])\n\n"
expr_stmt|;
name|out
operator|+=
literal|"static const Properties uc_properties[] = {"
expr_stmt|;
comment|// keep in sync with the property declaration
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uniqueProperties
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|PropertyFlags
modifier|&
name|p
init|=
name|uniqueProperties
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|out
operator|+=
literal|"\n    { "
expr_stmt|;
comment|//     "        ushort category            : 8; /* 5 used */\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|category
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort direction           : 8; /* 5 used */\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|direction
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort combiningClass      : 8;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|combiningClass
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort joining             : 3;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|joining
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        signed short digitValue    : 5;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|digitValue
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        signed short mirrorDiff    : 16;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|mirrorDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort lowerCaseSpecial    : 1;\n"
comment|//     "        signed short lowerCaseDiff : 15;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|lowerCaseSpecial
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|lowerCaseDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort upperCaseSpecial    : 1;\n"
comment|//     "        signed short upperCaseDiff : 15;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|upperCaseSpecial
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|upperCaseDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort titleCaseSpecial    : 1;\n"
comment|//     "        signed short titleCaseDiff : 15;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|titleCaseSpecial
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|titleCaseDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort caseFoldSpecial     : 1;\n"
comment|//     "        signed short caseFoldDiff  : 15;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|caseFoldSpecial
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|caseFoldDiff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort unicodeVersion      : 8; /* 5 used */\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|age
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "    ushort nfQuickCheck        : 8;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|nfQuickCheck
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort graphemeBreakClass  : 4; /* 4 used */\n"
comment|//     "        ushort wordBreakClass      : 4; /* 4 used */\n"
comment|//     "        ushort sentenceBreakClass  : 8; /* 4 used */\n"
comment|//     "        ushort lineBreakClass      : 8; /* 6 used */\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|graphemeBreakClass
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|wordBreakClass
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|sentenceBreakClass
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|lineBreakClass
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
comment|//     "        ushort script              : 8;\n"
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|p
operator|.
name|script
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|" },"
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|','
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
name|out
operator|+=
literal|"Q_DECL_CONST_FUNCTION static inline const Properties *qGetProp(uint ucs4) Q_DECL_NOTHROW\n"
literal|"{\n"
literal|"    return uc_properties + GET_PROP_INDEX(ucs4);\n"
literal|"}\n"
literal|"\n"
literal|"Q_DECL_CONST_FUNCTION static inline const Properties *qGetProp(ushort ucs2) Q_DECL_NOTHROW\n"
literal|"{\n"
literal|"    return uc_properties + GET_PROP_INDEX_UCS2(ucs2);\n"
literal|"}\n"
literal|"\n"
literal|"Q_DECL_CONST_FUNCTION Q_CORE_EXPORT const Properties * QT_FASTCALL properties(uint ucs4) Q_DECL_NOTHROW\n"
literal|"{\n"
literal|"    return qGetProp(ucs4);\n"
literal|"}\n"
literal|"\n"
literal|"Q_DECL_CONST_FUNCTION Q_CORE_EXPORT const Properties * QT_FASTCALL properties(ushort ucs2) Q_DECL_NOTHROW\n"
literal|"{\n"
literal|"    return qGetProp(ucs2);\n"
literal|"}\n\n"
expr_stmt|;
name|out
operator|+=
literal|"Q_CORE_EXPORT GraphemeBreakClass QT_FASTCALL graphemeBreakClass(uint ucs4) Q_DECL_NOTHROW\n"
literal|"{\n"
literal|"    return static_cast<GraphemeBreakClass>(qGetProp(ucs4)->graphemeBreakClass);\n"
literal|"}\n"
literal|"\n"
literal|"Q_CORE_EXPORT WordBreakClass QT_FASTCALL wordBreakClass(uint ucs4) Q_DECL_NOTHROW\n"
literal|"{\n"
literal|"    return static_cast<WordBreakClass>(qGetProp(ucs4)->wordBreakClass);\n"
literal|"}\n"
literal|"\n"
literal|"Q_CORE_EXPORT SentenceBreakClass QT_FASTCALL sentenceBreakClass(uint ucs4) Q_DECL_NOTHROW\n"
literal|"{\n"
literal|"    return static_cast<SentenceBreakClass>(qGetProp(ucs4)->sentenceBreakClass);\n"
literal|"}\n"
literal|"\n"
literal|"Q_CORE_EXPORT LineBreakClass QT_FASTCALL lineBreakClass(uint ucs4) Q_DECL_NOTHROW\n"
literal|"{\n"
literal|"    return static_cast<LineBreakClass>(qGetProp(ucs4)->lineBreakClass);\n"
literal|"}\n"
literal|"\n"
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|createSpecialCaseMap
specifier|static
name|QByteArray
name|createSpecialCaseMap
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"createSpecialCaseMap:"
argument_list|)
expr_stmt|;
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"static const unsigned short specialCaseMap[] = {\n"
literal|"    0x0, // placeholder"
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|specialCaseMap
operator|.
name|size
argument_list|()
condition|)
block|{
name|out
operator|+=
literal|"\n   "
expr_stmt|;
name|int
name|n
init|=
name|specialCaseMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
operator|++
name|j
control|)
block|{
name|out
operator|+=
name|QByteArray
argument_list|(
literal|" 0x"
argument_list|)
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|specialCaseMap
operator|.
name|at
argument_list|(
name|i
operator|+
name|j
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|","
expr_stmt|;
block|}
name|i
operator|+=
name|n
operator|+
literal|1
expr_stmt|;
block|}
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
name|qDebug
argument_list|(
literal|"    memory usage: %d bytes"
argument_list|,
name|specialCaseMap
operator|.
name|size
argument_list|()
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|createCompositionInfo
specifier|static
name|QByteArray
name|createCompositionInfo
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"createCompositionInfo: highestComposedCharacter=0x%x"
argument_list|,
name|highestComposedCharacter
argument_list|)
expr_stmt|;
specifier|const
name|int
name|BMP_BLOCKSIZE
init|=
literal|16
decl_stmt|;
specifier|const
name|int
name|BMP_SHIFT
init|=
literal|4
decl_stmt|;
specifier|const
name|int
name|BMP_END
init|=
literal|0x3400
decl_stmt|;
comment|// start of Han
specifier|const
name|int
name|SMP_END
init|=
literal|0x30000
decl_stmt|;
specifier|const
name|int
name|SMP_BLOCKSIZE
init|=
literal|256
decl_stmt|;
specifier|const
name|int
name|SMP_SHIFT
init|=
literal|8
decl_stmt|;
if|if
condition|(
name|SMP_END
operator|<=
name|highestComposedCharacter
condition|)
name|qFatal
argument_list|(
literal|"end of table smaller than highest composed character 0x%x"
argument_list|,
name|highestComposedCharacter
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|unsigned
name|short
argument_list|>
name|decompositions
decl_stmt|;
name|int
name|tableIndex
init|=
literal|0
decl_stmt|;
name|QList
argument_list|<
name|UniqueBlock
argument_list|>
name|uniqueBlocks
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
name|blockMap
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
literal|0
init|;
name|block
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|UniqueBlock
name|b
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|reserve
argument_list|(
name|BMP_BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|BMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|decomposition
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|utf16Length
init|=
literal|0
decl_stmt|;
name|decompositions
operator|.
name|append
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|.
name|decomposition
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|int
name|code
init|=
name|d
operator|.
name|decomposition
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|// save as surrogate pair
name|decompositions
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|decompositions
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|utf16Length
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|decompositions
operator|.
name|append
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|utf16Length
operator|++
expr_stmt|;
block|}
block|}
name|decompositions
index|[
name|tableIndex
index|]
operator|=
name|d
operator|.
name|decompositionType
operator|+
operator|(
name|utf16Length
operator|<<
literal|8
operator|)
expr_stmt|;
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
name|tableIndex
argument_list|)
expr_stmt|;
name|tableIndex
operator|+=
name|utf16Length
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|index
init|=
name|uniqueBlocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|BMP_BLOCKSIZE
expr_stmt|;
name|uniqueBlocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|bmp_blocks
init|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
name|BMP_END
operator|/
name|SMP_BLOCKSIZE
init|;
name|block
operator|<
name|SMP_END
operator|/
name|SMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|UniqueBlock
name|b
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|reserve
argument_list|(
name|SMP_BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|SMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|UnicodeData
modifier|&
name|d
init|=
name|UnicodeData
operator|::
name|valueRef
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|decomposition
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|utf16Length
init|=
literal|0
decl_stmt|;
name|decompositions
operator|.
name|append
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|.
name|decomposition
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|int
name|code
init|=
name|d
operator|.
name|decomposition
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|// save as surrogate pair
name|decompositions
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|decompositions
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|utf16Length
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|decompositions
operator|.
name|append
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|utf16Length
operator|++
expr_stmt|;
block|}
block|}
name|decompositions
index|[
name|tableIndex
index|]
operator|=
name|d
operator|.
name|decompositionType
operator|+
operator|(
name|utf16Length
operator|<<
literal|8
operator|)
expr_stmt|;
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
name|tableIndex
argument_list|)
expr_stmt|;
name|tableIndex
operator|+=
name|utf16Length
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|index
init|=
name|uniqueBlocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|SMP_BLOCKSIZE
expr_stmt|;
name|uniqueBlocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|smp_blocks
init|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
operator|-
name|bmp_blocks
decl_stmt|;
comment|// if the condition below doesn't hold anymore we need to modify our decomposition code
name|Q_ASSERT
argument_list|(
name|tableIndex
operator|<
literal|0xffff
argument_list|)
expr_stmt|;
name|int
name|bmp_block_data
init|=
name|bmp_blocks
operator|*
name|BMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|bmp_trie
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|bmp_mem
init|=
name|bmp_block_data
operator|+
name|bmp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in BMP."
argument_list|,
name|bmp_blocks
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|bmp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|bmp_trie
argument_list|)
expr_stmt|;
name|int
name|smp_block_data
init|=
name|smp_blocks
operator|*
name|SMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|smp_trie
init|=
operator|(
name|SMP_END
operator|-
name|BMP_END
operator|)
operator|/
name|SMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|smp_mem
init|=
name|smp_block_data
operator|+
name|smp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in SMP."
argument_list|,
name|smp_blocks
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|smp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|smp_trie
argument_list|)
expr_stmt|;
name|int
name|decomposition_data
init|=
name|decompositions
operator|.
name|size
argument_list|()
operator|*
literal|2
decl_stmt|;
name|qDebug
argument_list|(
literal|"\n        decomposition data uses : %d bytes"
argument_list|,
name|decomposition_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"    memory usage: %d bytes"
argument_list|,
name|bmp_mem
operator|+
name|smp_mem
operator|+
name|decomposition_data
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|blockMap
operator|.
name|last
argument_list|()
operator|+
name|blockMap
operator|.
name|size
argument_list|()
operator|<
operator|(
literal|1
operator|<<
operator|(
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
operator|*
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"static const unsigned short uc_decomposition_trie[] = {\n"
expr_stmt|;
comment|// first write the map
name|out
operator|+=
literal|"    // 0 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|i
operator|*
name|BMP_BLOCKSIZE
operator|)
operator|%
literal|0x1000
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n\n    // 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|"\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
init|;
name|i
operator|<
name|blockMap
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
operator|(
literal|0x10000
operator|/
name|SMP_BLOCKSIZE
operator|)
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
comment|// write the data
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uniqueBlocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
specifier|const
name|UniqueBlock
modifier|&
name|b
init|=
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|b
operator|.
name|values
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|j
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
literal|"0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|b
operator|.
name|values
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
name|out
operator|+=
literal|"#define GET_DECOMPOSITION_INDEX(ucs4) \\\n"
literal|"       (ucs4< 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" \\\n"
literal|"        ? (uc_decomposition_trie[uc_decomposition_trie[ucs4>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_SHIFT
argument_list|)
operator|+
literal|"] + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")]) \\\n"
literal|"        : (ucs4< 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" \\\n"
literal|"           ? uc_decomposition_trie[uc_decomposition_trie[((ucs4 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|")>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_SHIFT
argument_list|)
operator|+
literal|") + 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
argument_list|,
literal|16
argument_list|)
operator|+
literal|"]"
literal|" + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")] \\\n"
literal|"           : 0xffff))\n\n"
expr_stmt|;
name|out
operator|+=
literal|"static const unsigned short uc_decomposition_map[] = {"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|decompositions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
literal|"0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|decompositions
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|createLigatureInfo
specifier|static
name|QByteArray
name|createLigatureInfo
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"createLigatureInfo: numLigatures=%d, highestLigature=0x%x"
argument_list|,
name|numLigatures
argument_list|,
name|highestLigature
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ligatureHashes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QList
argument_list|<
name|Ligature
argument_list|>
modifier|&
name|l
init|=
name|ligatureHashes
operator|.
name|value
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
comment|// if the condition below doesn't hold anymore we need to modify our ligatureHelper code
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|u2
argument_list|)
operator|==
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|ligature
argument_list|)
operator|&&
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|u2
argument_list|)
operator|==
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|u1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|const
name|int
name|BMP_BLOCKSIZE
init|=
literal|32
decl_stmt|;
specifier|const
name|int
name|BMP_SHIFT
init|=
literal|5
decl_stmt|;
specifier|const
name|int
name|BMP_END
init|=
literal|0x3100
decl_stmt|;
specifier|const
name|int
name|SMP_END
init|=
literal|0x12000
decl_stmt|;
specifier|const
name|int
name|SMP_BLOCKSIZE
init|=
literal|256
decl_stmt|;
specifier|const
name|int
name|SMP_SHIFT
init|=
literal|8
decl_stmt|;
if|if
condition|(
name|SMP_END
operator|<=
name|highestLigature
condition|)
name|qFatal
argument_list|(
literal|"end of table smaller than highest ligature character 0x%x"
argument_list|,
name|highestLigature
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|unsigned
name|short
argument_list|>
name|ligatures
decl_stmt|;
name|int
name|tableIndex
init|=
literal|0
decl_stmt|;
name|QList
argument_list|<
name|UniqueBlock
argument_list|>
name|uniqueBlocks
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
name|blockMap
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
literal|0
init|;
name|block
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|UniqueBlock
name|b
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|reserve
argument_list|(
name|BMP_BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|BMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|QList
argument_list|<
name|Ligature
argument_list|>
name|l
init|=
name|ligatureHashes
operator|.
name|value
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|l
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|uc
argument_list|)
argument_list|)
expr_stmt|;
name|qSort
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|// needed for bsearch in ligatureHelper code
name|ligatures
operator|.
name|append
argument_list|(
name|l
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|ligatures
operator|.
name|append
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|u1
argument_list|)
expr_stmt|;
name|ligatures
operator|.
name|append
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|ligature
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
name|tableIndex
argument_list|)
expr_stmt|;
name|tableIndex
operator|+=
literal|2
operator|*
name|l
operator|.
name|size
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|index
init|=
name|uniqueBlocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|BMP_BLOCKSIZE
expr_stmt|;
name|uniqueBlocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|bmp_blocks
init|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|block
init|=
name|BMP_END
operator|/
name|SMP_BLOCKSIZE
init|;
name|block
operator|<
name|SMP_END
operator|/
name|SMP_BLOCKSIZE
condition|;
operator|++
name|block
control|)
block|{
name|UniqueBlock
name|b
decl_stmt|;
name|b
operator|.
name|values
operator|.
name|reserve
argument_list|(
name|SMP_BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
name|int
name|uc
init|=
name|block
operator|*
name|SMP_BLOCKSIZE
operator|+
name|i
decl_stmt|;
name|QList
argument_list|<
name|Ligature
argument_list|>
name|l
init|=
name|ligatureHashes
operator|.
name|value
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|l
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|uc
argument_list|)
argument_list|)
expr_stmt|;
name|qSort
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|// needed for bsearch in ligatureHelper code
name|ligatures
operator|.
name|append
argument_list|(
name|l
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|ligatures
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|u1
argument_list|)
argument_list|)
expr_stmt|;
name|ligatures
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|u1
argument_list|)
argument_list|)
expr_stmt|;
name|ligatures
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|ligature
argument_list|)
argument_list|)
expr_stmt|;
name|ligatures
operator|.
name|append
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|ligature
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
name|tableIndex
argument_list|)
expr_stmt|;
name|tableIndex
operator|+=
literal|4
operator|*
name|l
operator|.
name|size
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|values
operator|.
name|append
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|index
init|=
name|uniqueBlocks
operator|.
name|indexOf
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
expr_stmt|;
name|b
operator|.
name|index
operator|=
name|used
expr_stmt|;
name|used
operator|+=
name|SMP_BLOCKSIZE
expr_stmt|;
name|uniqueBlocks
operator|.
name|append
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|blockMap
operator|.
name|append
argument_list|(
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|smp_blocks
init|=
name|uniqueBlocks
operator|.
name|size
argument_list|()
operator|-
name|bmp_blocks
decl_stmt|;
comment|// if the condition below doesn't hold anymore we need to modify our composition code
name|Q_ASSERT
argument_list|(
name|tableIndex
operator|<
literal|0xffff
argument_list|)
expr_stmt|;
name|int
name|bmp_block_data
init|=
name|bmp_blocks
operator|*
name|BMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|bmp_trie
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|bmp_mem
init|=
name|bmp_block_data
operator|+
name|bmp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in BMP."
argument_list|,
name|bmp_blocks
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|bmp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|bmp_trie
argument_list|)
expr_stmt|;
name|int
name|smp_block_data
init|=
name|smp_blocks
operator|*
name|SMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|smp_trie
init|=
operator|(
name|SMP_END
operator|-
name|BMP_END
operator|)
operator|/
name|SMP_BLOCKSIZE
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
name|int
name|smp_mem
init|=
name|smp_block_data
operator|+
name|smp_trie
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %d unique blocks in SMP."
argument_list|,
name|smp_blocks
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        block data uses: %d bytes"
argument_list|,
name|smp_block_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"        trie data uses : %d bytes"
argument_list|,
name|smp_trie
argument_list|)
expr_stmt|;
name|int
name|ligature_data
init|=
name|ligatures
operator|.
name|size
argument_list|()
operator|*
literal|2
decl_stmt|;
name|qDebug
argument_list|(
literal|"\n        ligature data uses : %d bytes"
argument_list|,
name|ligature_data
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"    memory usage: %d bytes"
argument_list|,
name|bmp_mem
operator|+
name|smp_mem
operator|+
name|ligature_data
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|blockMap
operator|.
name|last
argument_list|()
operator|+
name|blockMap
operator|.
name|size
argument_list|()
operator|<
operator|(
literal|1
operator|<<
operator|(
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
operator|*
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"static const unsigned short uc_ligature_trie[] = {\n"
expr_stmt|;
comment|// first write the map
name|out
operator|+=
literal|"    // 0 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|i
operator|*
name|BMP_BLOCKSIZE
operator|)
operator|%
literal|0x1000
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n\n    // 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|"\n"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
init|;
name|i
operator|<
name|blockMap
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|%
operator|(
literal|0x10000
operator|/
name|SMP_BLOCKSIZE
operator|)
operator|)
condition|)
name|out
operator|+=
literal|"\n"
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|blockMap
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|+
name|blockMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
comment|// write the data
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uniqueBlocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n"
expr_stmt|;
specifier|const
name|UniqueBlock
modifier|&
name|b
init|=
name|uniqueBlocks
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|b
operator|.
name|values
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|j
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
literal|"0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|b
operator|.
name|values
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
name|out
operator|+=
literal|"#define GET_LIGATURE_INDEX(ucs4) \\\n"
literal|"       (ucs4< 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" \\\n"
literal|"        ? (uc_ligature_trie[uc_ligature_trie[ucs4>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_SHIFT
argument_list|)
operator|+
literal|"] + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")]) \\\n"
literal|"        : (ucs4< 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|" \\\n"
literal|"           ? uc_ligature_trie[uc_ligature_trie[((ucs4 - 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
argument_list|,
literal|16
argument_list|)
operator|+
literal|")>>"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_SHIFT
argument_list|)
operator|+
literal|") + 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|BMP_END
operator|/
name|BMP_BLOCKSIZE
argument_list|,
literal|16
argument_list|)
operator|+
literal|"]"
literal|" + (ucs4& 0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|SMP_BLOCKSIZE
operator|-
literal|1
argument_list|,
literal|16
argument_list|)
operator|+
literal|")] \\\n"
literal|"           : 0xffff))\n\n"
expr_stmt|;
name|out
operator|+=
literal|"static const unsigned short uc_ligature_map[] = {"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ligatures
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n    "
expr_stmt|;
block|}
name|out
operator|+=
literal|"0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|ligatures
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|.
name|endsWith
argument_list|(
literal|' '
argument_list|)
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|"\n};\n\n"
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|createCasingInfo
name|QByteArray
name|createCasingInfo
parameter_list|()
block|{
name|QByteArray
name|out
decl_stmt|;
name|out
operator|+=
literal|"struct CasingInfo {\n"
literal|"    uint codePoint : 16;\n"
literal|"    uint flags : 8;\n"
literal|"    uint offset : 8;\n"
literal|"};\n\n"
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
block|{
name|initAgeMap
argument_list|()
expr_stmt|;
name|initCategoryMap
argument_list|()
expr_stmt|;
name|initDecompositionMap
argument_list|()
expr_stmt|;
name|initDirectionMap
argument_list|()
expr_stmt|;
name|initJoiningMap
argument_list|()
expr_stmt|;
name|initGraphemeBreak
argument_list|()
expr_stmt|;
name|initWordBreak
argument_list|()
expr_stmt|;
name|initSentenceBreak
argument_list|()
expr_stmt|;
name|initLineBreak
argument_list|()
expr_stmt|;
name|initScriptMap
argument_list|()
expr_stmt|;
name|readUnicodeData
argument_list|()
expr_stmt|;
name|readBidiMirroring
argument_list|()
expr_stmt|;
name|readArabicShaping
argument_list|()
expr_stmt|;
name|readDerivedAge
argument_list|()
expr_stmt|;
name|readDerivedNormalizationProps
argument_list|()
expr_stmt|;
name|readSpecialCasing
argument_list|()
expr_stmt|;
name|readCaseFolding
argument_list|()
expr_stmt|;
comment|// readBlocks();
name|readScripts
argument_list|()
expr_stmt|;
name|readGraphemeBreak
argument_list|()
expr_stmt|;
name|readWordBreak
argument_list|()
expr_stmt|;
name|readSentenceBreak
argument_list|()
expr_stmt|;
name|readLineBreak
argument_list|()
expr_stmt|;
name|computeUniqueProperties
argument_list|()
expr_stmt|;
name|QByteArray
name|properties
init|=
name|createPropertyInfo
argument_list|()
decl_stmt|;
name|QByteArray
name|specialCases
init|=
name|createSpecialCaseMap
argument_list|()
decl_stmt|;
name|QByteArray
name|compositions
init|=
name|createCompositionInfo
argument_list|()
decl_stmt|;
name|QByteArray
name|ligatures
init|=
name|createLigatureInfo
argument_list|()
decl_stmt|;
name|QByteArray
name|normalizationCorrections
init|=
name|createNormalizationCorrections
argument_list|()
decl_stmt|;
name|QByteArray
name|header
init|=
literal|"/****************************************************************************\n"
literal|"**\n"
literal|"** Copyright (C) 2015 The Qt Company Ltd.\n"
literal|"** Contact: http://www.qt.io/licensing/\n"
literal|"**\n"
literal|"** This file is part of the QtCore module of the Qt Toolkit.\n"
literal|"**\n"
literal|"** $QT_BEGIN_LICENSE:LGPL21$\n"
literal|"** Commercial License Usage\n"
literal|"** Licensees holding valid commercial Qt licenses may use this file in\n"
literal|"** accordance with the commercial license agreement provided with the\n"
literal|"** Software or, alternatively, in accordance with the terms contained in\n"
literal|"** a written agreement between you and The Qt Company. For licensing terms\n"
literal|"** and conditions see http://www.qt.io/terms-conditions. For further\n"
literal|"** information use the contact form at http://www.qt.io/contact-us.\n"
literal|"**\n"
literal|"** GNU Lesser General Public License Usage\n"
literal|"** Alternatively, this file may be used under the terms of the GNU Lesser\n"
literal|"** General Public License version 2.1 or version 3 as published by the Free\n"
literal|"** Software Foundation and appearing in the file LICENSE.LGPLv21 and\n"
literal|"** LICENSE.LGPLv3 included in the packaging of this file. Please review the\n"
literal|"** following information to ensure the GNU Lesser General Public License\n"
literal|"** requirements will be met: https://www.gnu.org/licenses/lgpl.html and\n"
literal|"** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.\n"
literal|"**\n"
literal|"** As a special exception, The Qt Company gives you certain additional\n"
literal|"** rights. These rights are described in The Qt Company LGPL Exception\n"
literal|"** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.\n"
literal|"**\n"
literal|"** $QT_END_LICENSE$\n"
literal|"**\n"
literal|"****************************************************************************/\n\n"
decl_stmt|;
name|QByteArray
name|note
init|=
literal|"/* This file is autogenerated from the Unicode "
name|DATA_VERSION_S
literal|" database. Do not edit */\n\n"
decl_stmt|;
name|QByteArray
name|warning
init|=
literal|"//\n"
literal|"//  W A R N I N G\n"
literal|"//  -------------\n"
literal|"//\n"
literal|"// This file is not part of the Qt API.  It exists for the convenience\n"
literal|"// of internal files.  This header file may change from version to version\n"
literal|"// without notice, or even be removed.\n"
literal|"//\n"
literal|"// We mean it.\n"
literal|"//\n\n"
decl_stmt|;
name|QFile
name|f
argument_list|(
literal|"../../src/corelib/tools/qunicodetables.cpp"
argument_list|)
decl_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
operator||
name|QFile
operator|::
name|Truncate
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"#include \"qunicodetables_p.h\"\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"QT_BEGIN_NAMESPACE\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"namespace QUnicodeTables {\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|properties
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|specialCases
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|compositions
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|ligatures
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|normalizationCorrections
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"} // namespace QUnicodeTables\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"using namespace QUnicodeTables;\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"QT_END_NAMESPACE\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|close
argument_list|()
expr_stmt|;
name|f
operator|.
name|setFileName
argument_list|(
literal|"../../src/corelib/tools/qunicodetables_p.h"
argument_list|)
expr_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
operator||
name|QFile
operator|::
name|Truncate
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|warning
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"#ifndef QUNICODETABLES_P_H\n"
literal|"#define QUNICODETABLES_P_H\n\n"
literal|"#include<QtCore/qchar.h>\n\n"
literal|"QT_BEGIN_NAMESPACE\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"#define UNICODE_DATA_VERSION "
name|DATA_VERSION_STR
literal|"\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"namespace QUnicodeTables {\n\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|property_string
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|grapheme_break_class_string
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|word_break_class_string
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|sentence_break_class_string
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|line_break_class_string
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|methods
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
literal|"} // namespace QUnicodeTables\n\n"
literal|"QT_END_NAMESPACE\n\n"
literal|"#endif // QUNICODETABLES_P_H\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|close
argument_list|()
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxMirroredDiff  = "
operator|<<
name|hex
operator|<<
name|maxMirroredDiff
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxLowerCaseDiff = "
operator|<<
name|hex
operator|<<
name|maxLowerCaseDiff
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxUpperCaseDiff = "
operator|<<
name|hex
operator|<<
name|maxUpperCaseDiff
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxTitleCaseDiff = "
operator|<<
name|hex
operator|<<
name|maxTitleCaseDiff
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"maxCaseFoldDiff  = "
operator|<<
name|hex
operator|<<
name|maxCaseFoldDiff
expr_stmt|;
if|#
directive|if
literal|0
comment|//     dump(0, 0x7f);
comment|//     dump(0x620, 0x640);
comment|//     dump(0x10000, 0x10020);
comment|//     dump(0x10800, 0x10820);
block|qDebug("decompositionLength used:");     int totalcompositions = 0;     int sum = 0;     for (int i = 1; i< 20; ++i) {         qDebug("    length %d used %d times", i, decompositionLength.value(i, 0));         totalcompositions += i*decompositionLength.value(i, 0);         sum += decompositionLength.value(i, 0);     }     qDebug("    len decomposition map %d, average length %f, num composed chars %d",            totalcompositions, (float)totalcompositions/(float)sum, sum);     qDebug("highest composed character %x", highestComposedCharacter);     qDebug("num ligatures = %d highest=%x, maxLength=%d", numLigatures, highestLigature, longestLigature);      qBubbleSort(ligatures);     for (int i = 0; i< ligatures.size(); ++i)         qDebug("%s", ligatures.at(i).data());
comment|//     qDebug("combiningClass usage:");
comment|//     int numClasses = 0;
comment|//     for (int i = 0; i< 255; ++i) {
comment|//         int num = combiningClassUsage.value(i, 0);
comment|//         if (num) {
comment|//             ++numClasses;
comment|//             qDebug("    combiningClass %d used %d times", i, num);
comment|//         }
comment|//     }
comment|//     qDebug("total of %d combining classes used", numClasses);
endif|#
directive|endif
block|}
end_function
end_unit
