begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the utils of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"nfa.h"
end_include
begin_include
include|#
directive|include
file|"re2nfa.h"
end_include
begin_include
include|#
directive|include
file|"configfile.h"
end_include
begin_include
include|#
directive|include
file|"generator.h"
end_include
begin_include
include|#
directive|include
file|<QFile>
end_include
begin_include
include|#
directive|include
file|<QCoreApplication>
end_include
begin_include
include|#
directive|include
file|<QFileInfo>
end_include
begin_include
include|#
directive|include
file|<QDateTime>
end_include
begin_struct
DECL|struct|Symbol
struct|struct
name|Symbol
block|{
DECL|member|token
name|QString
name|token
decl_stmt|;
DECL|member|lexem
name|QString
name|lexem
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|tokenize
specifier|static
name|QList
argument_list|<
name|Symbol
argument_list|>
name|tokenize
parameter_list|(
specifier|const
name|DFA
modifier|&
name|dfa
parameter_list|,
specifier|const
name|QString
modifier|&
name|input
parameter_list|,
name|Config
modifier|*
name|cfg
parameter_list|,
name|bool
modifier|*
name|ok
init|=
literal|0
parameter_list|)
block|{
name|QList
argument_list|<
name|Symbol
argument_list|>
name|symbols
decl_stmt|;
name|Symbol
name|lastSymbol
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
name|int
name|lastAcceptingState
init|=
operator|-
literal|1
decl_stmt|;
name|QString
name|lastAcceptingLexem
decl_stmt|;
name|int
name|lastAcceptingPos
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|input
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|ch
init|=
name|input
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QChar
name|chForInput
init|=
name|ch
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|caseSensitivity
operator|==
name|Qt
operator|::
name|CaseInsensitive
condition|)
name|chForInput
operator|=
name|chForInput
operator|.
name|toLower
argument_list|()
expr_stmt|;
name|int
name|next
init|=
name|dfa
operator|.
name|at
argument_list|(
name|state
argument_list|)
operator|.
name|transitions
operator|.
name|value
argument_list|(
name|chForInput
operator|.
name|unicode
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"input"
operator|<<
name|input
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|<<
literal|"leads to state"
operator|<<
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
name|lastSymbol
operator|.
name|lexem
operator|.
name|append
argument_list|(
name|input
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|lastSymbol
operator|.
name|token
operator|=
name|dfa
operator|.
name|at
argument_list|(
name|next
argument_list|)
operator|.
name|symbol
expr_stmt|;
if|if
condition|(
operator|!
name|lastSymbol
operator|.
name|token
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lastAcceptingState
operator|=
name|next
expr_stmt|;
name|lastAcceptingLexem
operator|=
name|lastSymbol
operator|.
name|lexem
expr_stmt|;
name|lastAcceptingPos
operator|=
name|i
expr_stmt|;
block|}
name|state
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lastAcceptingState
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|cfg
operator|->
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"adding"
operator|<<
name|dfa
operator|.
name|at
argument_list|(
name|lastAcceptingState
argument_list|)
operator|.
name|symbol
operator|<<
literal|"and backtracking to"
operator|<<
name|lastAcceptingPos
expr_stmt|;
name|Symbol
name|s
decl_stmt|;
name|s
operator|.
name|token
operator|=
name|dfa
operator|.
name|at
argument_list|(
name|lastAcceptingState
argument_list|)
operator|.
name|symbol
expr_stmt|;
name|s
operator|.
name|lexem
operator|=
name|lastAcceptingLexem
expr_stmt|;
name|symbols
operator|<<
name|s
expr_stmt|;
name|lastSymbol
operator|=
name|Symbol
argument_list|()
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|lastAcceptingPos
expr_stmt|;
name|lastAcceptingPos
operator|=
operator|-
literal|1
expr_stmt|;
name|lastAcceptingState
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|state
operator|==
literal|0
operator|||
name|lastSymbol
operator|.
name|token
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|cfg
operator|->
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"invalid input"
expr_stmt|;
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|symbols
return|;
block|}
if|if
condition|(
name|cfg
operator|->
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"appending symbol with token"
operator|<<
name|lastSymbol
operator|.
name|token
expr_stmt|;
name|symbols
operator|<<
name|lastSymbol
expr_stmt|;
name|lastSymbol
operator|=
name|Symbol
argument_list|()
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|lastAcceptingState
operator|=
operator|-
literal|1
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|lastSymbol
operator|.
name|token
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|cfg
operator|->
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"appending (last) symbol with token"
operator|<<
name|lastSymbol
operator|.
name|token
expr_stmt|;
name|symbols
operator|<<
name|lastSymbol
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastAcceptingState
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|cfg
operator|->
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"appending last accepting state with token"
operator|<<
name|dfa
operator|.
name|at
argument_list|(
name|lastAcceptingState
argument_list|)
operator|.
name|symbol
expr_stmt|;
name|Symbol
name|s
decl_stmt|;
name|s
operator|.
name|lexem
operator|=
name|lastAcceptingLexem
expr_stmt|;
name|s
operator|.
name|token
operator|=
name|dfa
operator|.
name|at
argument_list|(
name|lastAcceptingState
argument_list|)
operator|.
name|symbol
expr_stmt|;
name|symbols
operator|<<
name|s
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|symbols
return|;
block|}
end_function
begin_function
DECL|function|determineMaxInputSet
specifier|static
name|QSet
argument_list|<
name|InputType
argument_list|>
name|determineMaxInputSet
parameter_list|(
specifier|const
name|ConfigFile
operator|::
name|Section
modifier|&
name|section
parameter_list|)
block|{
name|QSet
argument_list|<
name|InputType
argument_list|>
name|set
decl_stmt|;
name|QString
name|inputTypeName
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|ConfigFile
operator|::
name|Entry
modifier|&
name|entry
decl|,
name|section
control|)
if|if
condition|(
name|entry
operator|.
name|key
operator|==
name|QLatin1String
argument_list|(
literal|"InputType"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inputTypeName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Error: InputType field specified multiple times in config file"
argument_list|)
expr_stmt|;
return|return
name|QSet
argument_list|<
name|InputType
argument_list|>
argument_list|()
return|;
block|}
name|inputTypeName
operator|=
name|entry
operator|.
name|value
expr_stmt|;
block|}
if|if
condition|(
name|inputTypeName
operator|.
name|isEmpty
argument_list|()
condition|)
name|inputTypeName
operator|=
literal|"quint8"
expr_stmt|;
if|if
condition|(
name|inputTypeName
operator|==
literal|"quint8"
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|set
operator|.
name|insert
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* else if ### */
else|else
block|{
name|qWarning
argument_list|(
literal|"Error: Unknown input type '%s'"
argument_list|,
name|qPrintable
argument_list|(
name|inputTypeName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QSet
argument_list|<
name|InputType
argument_list|>
argument_list|()
return|;
block|}
return|return
name|set
return|;
block|}
end_function
begin_function
DECL|function|loadConfig
specifier|static
name|bool
name|loadConfig
parameter_list|(
specifier|const
name|QString
modifier|&
name|ruleFile
parameter_list|,
name|Config
modifier|*
name|cfg
parameter_list|)
block|{
name|ConfigFile
operator|::
name|SectionMap
name|sections
init|=
name|ConfigFile
operator|::
name|parse
argument_list|(
name|ruleFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|sections
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Error parsing %s"
argument_list|,
name|qPrintable
argument_list|(
name|ruleFile
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QSet
argument_list|<
name|InputType
argument_list|>
name|maxInputSet
init|=
name|determineMaxInputSet
argument_list|(
name|sections
operator|.
name|value
argument_list|(
literal|"Options"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxInputSet
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|Qt
operator|::
name|CaseSensitivity
name|cs
init|=
name|Qt
operator|::
name|CaseInsensitive
decl_stmt|;
if|if
condition|(
name|sections
operator|.
name|value
argument_list|(
literal|"Options"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"case-sensitive"
argument_list|)
condition|)
name|cs
operator|=
name|Qt
operator|::
name|CaseSensitive
expr_stmt|;
name|cfg
operator|->
name|configSections
operator|=
name|sections
expr_stmt|;
name|cfg
operator|->
name|caseSensitivity
operator|=
name|cs
expr_stmt|;
name|cfg
operator|->
name|className
operator|=
name|sections
operator|.
name|value
argument_list|(
literal|"Options"
argument_list|)
operator|.
name|value
argument_list|(
literal|"classname"
argument_list|,
literal|"Scanner"
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|maxInputSet
operator|=
name|maxInputSet
expr_stmt|;
name|cfg
operator|->
name|ruleFile
operator|=
name|ruleFile
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|generateMachine
specifier|static
name|DFA
name|generateMachine
parameter_list|(
specifier|const
name|Config
modifier|&
name|cfg
parameter_list|)
block|{
if|if
condition|(
name|cfg
operator|.
name|cache
condition|)
block|{
name|QFileInfo
name|ruleInfo
argument_list|(
name|cfg
operator|.
name|ruleFile
argument_list|)
decl_stmt|;
name|QFileInfo
name|cacheInfo
argument_list|(
name|ruleInfo
operator|.
name|baseName
argument_list|()
operator|+
literal|".dfa"
argument_list|)
decl_stmt|;
if|if
condition|(
name|cacheInfo
operator|.
name|exists
argument_list|()
operator|&&
name|cacheInfo
operator|.
name|lastModified
argument_list|()
operator|>
name|ruleInfo
operator|.
name|lastModified
argument_list|()
condition|)
block|{
name|QFile
name|f
argument_list|(
name|cacheInfo
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
decl_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
name|QDataStream
name|stream
argument_list|(
operator|&
name|f
argument_list|)
decl_stmt|;
name|DFA
name|machine
decl_stmt|;
name|stream
operator|>>
name|machine
expr_stmt|;
return|return
name|machine
return|;
block|}
block|}
name|QMap
argument_list|<
name|QString
argument_list|,
name|NFA
argument_list|>
name|macros
decl_stmt|;
foreach|foreach
control|(
name|ConfigFile
operator|::
name|Entry
name|e
decl|,
name|cfg
operator|.
name|configSections
operator|.
name|value
argument_list|(
literal|"Macros"
argument_list|)
control|)
block|{
name|int
name|errCol
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cfg
operator|.
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"parsing"
operator|<<
name|e
operator|.
name|value
expr_stmt|;
name|NFA
name|nfa
init|=
name|RE2NFA
argument_list|(
name|macros
argument_list|,
name|cfg
operator|.
name|maxInputSet
argument_list|,
name|cfg
operator|.
name|caseSensitivity
argument_list|)
operator|.
name|parse
argument_list|(
name|e
operator|.
name|value
argument_list|,
operator|&
name|errCol
argument_list|)
decl_stmt|;
if|if
condition|(
name|nfa
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Parse error in line %d column %d"
argument_list|,
name|e
operator|.
name|lineNumber
argument_list|,
name|errCol
argument_list|)
expr_stmt|;
return|return
name|DFA
argument_list|()
return|;
block|}
name|macros
operator|.
name|insert
argument_list|(
name|e
operator|.
name|key
argument_list|,
name|nfa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cfg
operator|.
name|configSections
operator|.
name|contains
argument_list|(
literal|"Tokens"
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Rule file does not contain a [Tokens] section!"
argument_list|)
expr_stmt|;
return|return
name|DFA
argument_list|()
return|;
block|}
name|QVector
argument_list|<
name|NFA
argument_list|>
name|tokens
decl_stmt|;
foreach|foreach
control|(
name|ConfigFile
operator|::
name|Entry
name|e
decl|,
name|cfg
operator|.
name|configSections
operator|.
name|value
argument_list|(
literal|"Tokens"
argument_list|)
control|)
block|{
name|int
name|errCol
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cfg
operator|.
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"parsing"
operator|<<
name|e
operator|.
name|value
expr_stmt|;
name|NFA
name|tok
init|=
name|RE2NFA
argument_list|(
name|macros
argument_list|,
name|cfg
operator|.
name|maxInputSet
argument_list|,
name|cfg
operator|.
name|caseSensitivity
argument_list|)
operator|.
name|parse
argument_list|(
name|e
operator|.
name|value
argument_list|,
operator|&
name|errCol
argument_list|)
decl_stmt|;
if|if
condition|(
name|tok
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Parse error in line %d column %d while parsing token %s"
argument_list|,
name|e
operator|.
name|lineNumber
argument_list|,
name|errCol
argument_list|,
name|e
operator|.
name|key
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|DFA
argument_list|()
return|;
block|}
name|tok
operator|.
name|setTerminationSymbol
argument_list|(
name|e
operator|.
name|key
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|append
argument_list|(
name|tok
argument_list|)
expr_stmt|;
block|}
name|NFA
name|giganticStateMachine
decl_stmt|;
foreach|foreach
control|(
name|NFA
name|nfa
decl|,
name|tokens
control|)
if|if
condition|(
name|giganticStateMachine
operator|.
name|isEmpty
argument_list|()
condition|)
name|giganticStateMachine
operator|=
name|nfa
expr_stmt|;
else|else
name|giganticStateMachine
operator|=
name|NFA
operator|::
name|createAlternatingNFA
argument_list|(
name|giganticStateMachine
argument_list|,
name|nfa
argument_list|)
expr_stmt|;
name|DFA
name|result
init|=
name|giganticStateMachine
operator|.
name|toDFA
argument_list|()
operator|.
name|minimize
argument_list|()
decl_stmt|;
if|if
condition|(
name|cfg
operator|.
name|cache
condition|)
block|{
name|QFileInfo
name|ruleInfo
argument_list|(
name|cfg
operator|.
name|ruleFile
argument_list|)
decl_stmt|;
name|QFileInfo
name|cacheInfo
argument_list|(
name|ruleInfo
operator|.
name|baseName
argument_list|()
operator|+
literal|".dfa"
argument_list|)
decl_stmt|;
name|QFile
name|f
argument_list|(
name|cacheInfo
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
decl_stmt|;
name|f
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
operator||
name|QIODevice
operator|::
name|Truncate
argument_list|)
expr_stmt|;
name|QDataStream
name|stream
argument_list|(
operator|&
name|f
argument_list|)
decl_stmt|;
name|stream
operator|<<
name|result
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|AUTOTEST
argument_list|)
end_if
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|QCoreApplication
name|app
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
decl_stmt|;
name|QString
name|ruleFile
decl_stmt|;
name|Config
name|cfg
decl_stmt|;
specifier|const
name|QStringList
name|arguments
init|=
name|app
operator|.
name|arguments
argument_list|()
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|cfg
operator|.
name|debug
operator|=
name|arguments
operator|.
name|contains
argument_list|(
literal|"-debug"
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|testRules
init|=
name|arguments
operator|.
name|contains
argument_list|(
literal|"-test"
argument_list|)
decl_stmt|;
name|cfg
operator|.
name|cache
operator|=
name|arguments
operator|.
name|contains
argument_list|(
literal|"-cache"
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|arg
decl|,
name|arguments
control|)
if|if
condition|(
operator|!
name|arg
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
condition|)
block|{
name|ruleFile
operator|=
name|arg
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ruleFile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"usage: lexgen [-test rulefile"
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"    the -test option will cause lexgen to interpret standard input"
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"    according to the specified rules and print out pairs of token and"
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"    lexical element"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|loadConfig
argument_list|(
name|ruleFile
argument_list|,
operator|&
name|cfg
argument_list|)
condition|)
return|return
literal|1
return|;
name|DFA
name|machine
init|=
name|generateMachine
argument_list|(
name|cfg
argument_list|)
decl_stmt|;
if|if
condition|(
name|machine
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|testRules
condition|)
block|{
name|qWarning
argument_list|(
literal|"Testing:"
argument_list|)
expr_stmt|;
name|QString
name|input
init|=
name|QTextStream
argument_list|(
name|stdin
argument_list|)
operator|.
name|readAll
argument_list|()
decl_stmt|;
comment|/*         qDebug()<< "NFA has"<< machine.stateCount()<< "states";         qDebug()<< "Converting to DFA... (this may take a while)";         DFA dfa = machine.toDFA();         qDebug()<< "DFA has"<< dfa.count()<< "states";         qDebug()<< "Minimizing...";         dfa = dfa.minimize();         qDebug()<< "Minimized DFA has"<< dfa.count()<< "states";         */
name|DFA
name|dfa
init|=
name|machine
decl_stmt|;
if|if
condition|(
name|cfg
operator|.
name|debug
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"tokenizing"
operator|<<
name|input
expr_stmt|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|QList
argument_list|<
name|Symbol
argument_list|>
name|symbols
init|=
name|tokenize
argument_list|(
name|dfa
argument_list|,
name|input
argument_list|,
operator|&
name|cfg
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbols
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"No tokens produced!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
foreach|foreach
control|(
name|Symbol
name|s
decl|,
name|symbols
control|)
name|qDebug
argument_list|()
operator|<<
name|s
operator|.
name|token
operator|<<
literal|":"
operator|<<
name|s
operator|.
name|lexem
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
name|qDebug
argument_list|()
operator|<<
name|symbols
operator|.
name|count
argument_list|()
operator|<<
literal|"tokens produced."
expr_stmt|;
else|else
name|qDebug
argument_list|()
operator|<<
literal|"Error while tokenizing!"
expr_stmt|;
block|}
else|else
block|{
name|Generator
name|gen
argument_list|(
name|machine
argument_list|,
name|cfg
argument_list|)
decl_stmt|;
name|QTextStream
argument_list|(
name|stdout
argument_list|)
operator|<<
name|gen
operator|.
name|generate
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
end_unit
