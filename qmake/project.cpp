begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the qmake application of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"project.h"
end_include
begin_include
include|#
directive|include
file|"property.h"
end_include
begin_include
include|#
directive|include
file|"option.h"
end_include
begin_include
include|#
directive|include
file|"cachekeys.h"
end_include
begin_include
include|#
directive|include
file|"generators/metamakefile.h"
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qregexp.h>
end_include
begin_include
include|#
directive|include
file|<qtextstream.h>
end_include
begin_include
include|#
directive|include
file|<qstack.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_include
include|#
directive|include
file|<utime.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_include
include|#
directive|include
file|<sys/stat.h>
end_include
begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
end_elif
begin_include
include|#
directive|include
file|<windows.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN32
end_ifdef
begin_define
DECL|macro|QT_POPEN
define|#
directive|define
name|QT_POPEN
value|_popen
end_define
begin_define
DECL|macro|QT_PCLOSE
define|#
directive|define
name|QT_PCLOSE
value|_pclose
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_POPEN
define|#
directive|define
name|QT_POPEN
value|popen
end_define
begin_define
DECL|macro|QT_PCLOSE
define|#
directive|define
name|QT_PCLOSE
value|pclose
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|//expand functions
DECL|enum|ExpandFunc
DECL|enumerator|E_MEMBER
DECL|enumerator|E_FIRST
DECL|enumerator|E_LAST
DECL|enumerator|E_CAT
DECL|enumerator|E_FROMFILE
DECL|enumerator|E_EVAL
DECL|enumerator|E_LIST
name|enum
name|ExpandFunc
argument_list|{
name|E_MEMBER
operator|=
literal|1
argument_list|,
name|E_FIRST
argument_list|,
name|E_LAST
argument_list|,
name|E_CAT
argument_list|,
name|E_FROMFILE
argument_list|,
name|E_EVAL
argument_list|,
name|E_LIST
argument_list|,
DECL|enumerator|E_SPRINTF
DECL|enumerator|E_FORMAT_NUMBER
DECL|enumerator|E_JOIN
DECL|enumerator|E_SPLIT
DECL|enumerator|E_BASENAME
DECL|enumerator|E_DIRNAME
DECL|enumerator|E_SECTION
name|E_SPRINTF
argument_list|,
name|E_FORMAT_NUMBER
argument_list|,
name|E_JOIN
argument_list|,
name|E_SPLIT
argument_list|,
name|E_BASENAME
argument_list|,
name|E_DIRNAME
argument_list|,
name|E_SECTION
argument_list|,
DECL|enumerator|E_FIND
DECL|enumerator|E_SYSTEM
DECL|enumerator|E_UNIQUE
DECL|enumerator|E_REVERSE
DECL|enumerator|E_QUOTE
DECL|enumerator|E_ESCAPE_EXPAND
name|E_FIND
argument_list|,
name|E_SYSTEM
argument_list|,
name|E_UNIQUE
argument_list|,
name|E_REVERSE
argument_list|,
name|E_QUOTE
argument_list|,
name|E_ESCAPE_EXPAND
argument_list|,
DECL|enumerator|E_UPPER
DECL|enumerator|E_LOWER
DECL|enumerator|E_FILES
DECL|enumerator|E_PROMPT
DECL|enumerator|E_RE_ESCAPE
DECL|enumerator|E_VAL_ESCAPE
DECL|enumerator|E_REPLACE
name|E_UPPER
argument_list|,
name|E_LOWER
argument_list|,
name|E_FILES
argument_list|,
name|E_PROMPT
argument_list|,
name|E_RE_ESCAPE
argument_list|,
name|E_VAL_ESCAPE
argument_list|,
name|E_REPLACE
argument_list|,
DECL|enumerator|E_SIZE
DECL|enumerator|E_SORT_DEPENDS
DECL|enumerator|E_RESOLVE_DEPENDS
DECL|enumerator|E_ENUMERATE_VARS
name|E_SIZE
argument_list|,
name|E_SORT_DEPENDS
argument_list|,
name|E_RESOLVE_DEPENDS
argument_list|,
name|E_ENUMERATE_VARS
argument_list|,
DECL|enumerator|E_SHADOWED
DECL|enumerator|E_ABSOLUTE_PATH
DECL|enumerator|E_RELATIVE_PATH
DECL|enumerator|E_CLEAN_PATH
DECL|enumerator|E_NATIVE_PATH
name|E_SHADOWED
argument_list|,
name|E_ABSOLUTE_PATH
argument_list|,
name|E_RELATIVE_PATH
argument_list|,
name|E_CLEAN_PATH
argument_list|,
name|E_NATIVE_PATH
argument_list|,
DECL|enumerator|E_SHELL_QUOTE
name|E_SHELL_QUOTE
argument_list|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qmake_expandFunctions
name|QHash
argument_list|<
name|QString
argument_list|,
name|ExpandFunc
argument_list|>
name|qmake_expandFunctions
parameter_list|()
block|{
specifier|static
name|QHash
argument_list|<
name|QString
argument_list|,
name|ExpandFunc
argument_list|>
modifier|*
name|qmake_expand_functions
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|qmake_expand_functions
condition|)
block|{
name|qmake_expand_functions
operator|=
operator|new
name|QHash
argument_list|<
name|QString
argument_list|,
name|ExpandFunc
argument_list|>
expr_stmt|;
name|qmakeAddCacheClear
argument_list|(
name|qmakeDeleteCacheClear
argument_list|<
name|QHash
argument_list|<
name|QString
argument_list|,
name|ExpandFunc
argument_list|>
argument_list|>
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|qmake_expand_functions
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"member"
argument_list|,
name|E_MEMBER
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"first"
argument_list|,
name|E_FIRST
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"last"
argument_list|,
name|E_LAST
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"cat"
argument_list|,
name|E_CAT
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"fromfile"
argument_list|,
name|E_FROMFILE
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"eval"
argument_list|,
name|E_EVAL
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"list"
argument_list|,
name|E_LIST
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"sprintf"
argument_list|,
name|E_SPRINTF
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"format_number"
argument_list|,
name|E_FORMAT_NUMBER
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"join"
argument_list|,
name|E_JOIN
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"split"
argument_list|,
name|E_SPLIT
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"basename"
argument_list|,
name|E_BASENAME
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"dirname"
argument_list|,
name|E_DIRNAME
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"section"
argument_list|,
name|E_SECTION
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"find"
argument_list|,
name|E_FIND
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"system"
argument_list|,
name|E_SYSTEM
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"unique"
argument_list|,
name|E_UNIQUE
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"reverse"
argument_list|,
name|E_REVERSE
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"quote"
argument_list|,
name|E_QUOTE
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"escape_expand"
argument_list|,
name|E_ESCAPE_EXPAND
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"upper"
argument_list|,
name|E_UPPER
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"lower"
argument_list|,
name|E_LOWER
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"re_escape"
argument_list|,
name|E_RE_ESCAPE
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"val_escape"
argument_list|,
name|E_VAL_ESCAPE
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"files"
argument_list|,
name|E_FILES
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"prompt"
argument_list|,
name|E_PROMPT
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"replace"
argument_list|,
name|E_REPLACE
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"size"
argument_list|,
name|E_SIZE
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"sort_depends"
argument_list|,
name|E_SORT_DEPENDS
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"resolve_depends"
argument_list|,
name|E_RESOLVE_DEPENDS
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"enumerate_vars"
argument_list|,
name|E_ENUMERATE_VARS
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"shadowed"
argument_list|,
name|E_SHADOWED
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"absolute_path"
argument_list|,
name|E_ABSOLUTE_PATH
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"relative_path"
argument_list|,
name|E_RELATIVE_PATH
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"clean_path"
argument_list|,
name|E_CLEAN_PATH
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"native_path"
argument_list|,
name|E_NATIVE_PATH
argument_list|)
expr_stmt|;
name|qmake_expand_functions
operator|->
name|insert
argument_list|(
literal|"shell_quote"
argument_list|,
name|E_SHELL_QUOTE
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|qmake_expand_functions
return|;
block|}
end_function
begin_comment
comment|//replace functions
end_comment
begin_enum
DECL|enum|TestFunc
DECL|enumerator|T_REQUIRES
DECL|enumerator|T_GREATERTHAN
DECL|enumerator|T_LESSTHAN
DECL|enumerator|T_EQUALS
enum|enum
name|TestFunc
block|{
name|T_REQUIRES
init|=
literal|1
block|,
name|T_GREATERTHAN
block|,
name|T_LESSTHAN
block|,
name|T_EQUALS
block|,
DECL|enumerator|T_EXISTS
DECL|enumerator|T_EXPORT
DECL|enumerator|T_CLEAR
DECL|enumerator|T_UNSET
DECL|enumerator|T_EVAL
DECL|enumerator|T_CONFIG
DECL|enumerator|T_SYSTEM
name|T_EXISTS
block|,
name|T_EXPORT
block|,
name|T_CLEAR
block|,
name|T_UNSET
block|,
name|T_EVAL
block|,
name|T_CONFIG
block|,
name|T_SYSTEM
block|,
DECL|enumerator|T_RETURN
DECL|enumerator|T_BREAK
DECL|enumerator|T_NEXT
DECL|enumerator|T_DEFINED
DECL|enumerator|T_CONTAINS
DECL|enumerator|T_INFILE
name|T_RETURN
block|,
name|T_BREAK
block|,
name|T_NEXT
block|,
name|T_DEFINED
block|,
name|T_CONTAINS
block|,
name|T_INFILE
block|,
DECL|enumerator|T_COUNT
DECL|enumerator|T_ISEMPTY
DECL|enumerator|T_INCLUDE
DECL|enumerator|T_LOAD
name|T_COUNT
block|,
name|T_ISEMPTY
block|,
name|T_INCLUDE
block|,
name|T_LOAD
block|,
DECL|enumerator|T_DEBUG
DECL|enumerator|T_ERROR
DECL|enumerator|T_MESSAGE
DECL|enumerator|T_WARNING
DECL|enumerator|T_LOG
name|T_DEBUG
block|,
name|T_ERROR
block|,
name|T_MESSAGE
block|,
name|T_WARNING
block|,
name|T_LOG
block|,
DECL|enumerator|T_IF
DECL|enumerator|T_OPTION
DECL|enumerator|T_CACHE
DECL|enumerator|T_MKPATH
DECL|enumerator|T_WRITE_FILE
DECL|enumerator|T_TOUCH
name|T_IF
block|,
name|T_OPTION
block|,
name|T_CACHE
block|,
name|T_MKPATH
block|,
name|T_WRITE_FILE
block|,
name|T_TOUCH
block|}
enum|;
end_enum
begin_function
DECL|function|qmake_testFunctions
name|QHash
argument_list|<
name|QString
argument_list|,
name|TestFunc
argument_list|>
name|qmake_testFunctions
parameter_list|()
block|{
specifier|static
name|QHash
argument_list|<
name|QString
argument_list|,
name|TestFunc
argument_list|>
modifier|*
name|qmake_test_functions
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|qmake_test_functions
condition|)
block|{
name|qmake_test_functions
operator|=
operator|new
name|QHash
argument_list|<
name|QString
argument_list|,
name|TestFunc
argument_list|>
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"requires"
argument_list|,
name|T_REQUIRES
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"greaterThan"
argument_list|,
name|T_GREATERTHAN
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"lessThan"
argument_list|,
name|T_LESSTHAN
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"equals"
argument_list|,
name|T_EQUALS
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"isEqual"
argument_list|,
name|T_EQUALS
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"exists"
argument_list|,
name|T_EXISTS
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"export"
argument_list|,
name|T_EXPORT
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"clear"
argument_list|,
name|T_CLEAR
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"unset"
argument_list|,
name|T_UNSET
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"eval"
argument_list|,
name|T_EVAL
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"CONFIG"
argument_list|,
name|T_CONFIG
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"if"
argument_list|,
name|T_IF
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"isActiveConfig"
argument_list|,
name|T_CONFIG
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"system"
argument_list|,
name|T_SYSTEM
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"return"
argument_list|,
name|T_RETURN
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"break"
argument_list|,
name|T_BREAK
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"next"
argument_list|,
name|T_NEXT
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"defined"
argument_list|,
name|T_DEFINED
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"contains"
argument_list|,
name|T_CONTAINS
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"infile"
argument_list|,
name|T_INFILE
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"count"
argument_list|,
name|T_COUNT
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"isEmpty"
argument_list|,
name|T_ISEMPTY
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"include"
argument_list|,
name|T_INCLUDE
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"load"
argument_list|,
name|T_LOAD
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"debug"
argument_list|,
name|T_DEBUG
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"error"
argument_list|,
name|T_ERROR
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"message"
argument_list|,
name|T_MESSAGE
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"warning"
argument_list|,
name|T_WARNING
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"log"
argument_list|,
name|T_LOG
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"option"
argument_list|,
name|T_OPTION
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"cache"
argument_list|,
name|T_CACHE
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"mkpath"
argument_list|,
name|T_MKPATH
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"write_file"
argument_list|,
name|T_WRITE_FILE
argument_list|)
expr_stmt|;
name|qmake_test_functions
operator|->
name|insert
argument_list|(
literal|"touch"
argument_list|,
name|T_TOUCH
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|qmake_test_functions
return|;
block|}
end_function
begin_struct
DECL|struct|parser_info
struct|struct
name|parser_info
block|{
DECL|member|file
name|QString
name|file
decl_stmt|;
DECL|member|line_no
name|int
name|line_no
decl_stmt|;
DECL|member|from_file
name|bool
name|from_file
decl_stmt|;
block|}
DECL|variable|parser
name|parser
struct|;
end_struct
begin_decl_stmt
DECL|variable|cached_source_root
specifier|static
name|QString
name|cached_source_root
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cached_build_root
specifier|static
name|QString
name|cached_build_root
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cached_qmakepath
specifier|static
name|QStringList
name|cached_qmakepath
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cached_qmakefeatures
specifier|static
name|QStringList
name|cached_qmakefeatures
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|all_feature_roots
specifier|static
name|QStringList
modifier|*
name|all_feature_roots
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|void
DECL|function|invalidateFeatureRoots
name|invalidateFeatureRoots
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_feature_roots
index|[
name|i
index|]
condition|)
name|all_feature_roots
index|[
name|i
index|]
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|remove_quotes
specifier|static
name|QString
name|remove_quotes
parameter_list|(
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
block|{
specifier|const
name|ushort
name|SINGLEQUOTE
init|=
literal|'\''
decl_stmt|;
specifier|const
name|ushort
name|DOUBLEQUOTE
init|=
literal|'"'
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|arg_data
init|=
name|arg
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|ushort
name|first
init|=
name|arg_data
operator|->
name|unicode
argument_list|()
decl_stmt|;
specifier|const
name|int
name|arg_len
init|=
name|arg
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
operator|==
name|SINGLEQUOTE
operator|||
name|first
operator|==
name|DOUBLEQUOTE
condition|)
block|{
specifier|const
name|ushort
name|last
init|=
operator|(
name|arg_data
operator|+
name|arg_len
operator|-
literal|1
operator|)
operator|->
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|last
operator|==
name|first
condition|)
return|return
name|arg
operator|.
name|mid
argument_list|(
literal|1
argument_list|,
name|arg_len
operator|-
literal|2
argument_list|)
return|;
block|}
return|return
name|arg
return|;
block|}
end_function
begin_function
DECL|function|varMap
specifier|static
name|QString
name|varMap
parameter_list|(
specifier|const
name|QString
modifier|&
name|x
parameter_list|)
block|{
name|QString
name|ret
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|"INTERFACES"
condition|)
name|ret
operator|=
literal|"FORMS"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"QMAKE_POST_BUILD"
condition|)
name|ret
operator|=
literal|"QMAKE_POST_LINK"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"TARGETDEPS"
condition|)
name|ret
operator|=
literal|"POST_TARGETDEPS"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"LIBPATH"
condition|)
name|ret
operator|=
literal|"QMAKE_LIBDIR"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"QMAKE_EXT_MOC"
condition|)
name|ret
operator|=
literal|"QMAKE_EXT_CPP_MOC"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"QMAKE_MOD_MOC"
condition|)
name|ret
operator|=
literal|"QMAKE_H_MOD_MOC"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"QMAKE_LFLAGS_SHAPP"
condition|)
name|ret
operator|=
literal|"QMAKE_LFLAGS_APP"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"PRECOMPH"
condition|)
name|ret
operator|=
literal|"PRECOMPILED_HEADER"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"PRECOMPCPP"
condition|)
name|ret
operator|=
literal|"PRECOMPILED_SOURCE"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"INCPATH"
condition|)
name|ret
operator|=
literal|"INCLUDEPATH"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"QMAKE_EXTRA_WIN_COMPILERS"
operator|||
name|ret
operator|==
literal|"QMAKE_EXTRA_UNIX_COMPILERS"
condition|)
name|ret
operator|=
literal|"QMAKE_EXTRA_COMPILERS"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"QMAKE_EXTRA_WIN_TARGETS"
operator|||
name|ret
operator|==
literal|"QMAKE_EXTRA_UNIX_TARGETS"
condition|)
name|ret
operator|=
literal|"QMAKE_EXTRA_TARGETS"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"QMAKE_EXTRA_UNIX_INCLUDES"
condition|)
name|ret
operator|=
literal|"QMAKE_EXTRA_INCLUDES"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"QMAKE_EXTRA_UNIX_VARIABLES"
condition|)
name|ret
operator|=
literal|"QMAKE_EXTRA_VARIABLES"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"QMAKE_RPATH"
condition|)
name|ret
operator|=
literal|"QMAKE_LFLAGS_RPATH"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"QMAKE_FRAMEWORKDIR"
condition|)
name|ret
operator|=
literal|"QMAKE_FRAMEWORKPATH"
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|"QMAKE_FRAMEWORKDIR_FLAGS"
condition|)
name|ret
operator|=
literal|"QMAKE_FRAMEWORKPATH_FLAGS"
expr_stmt|;
else|else
return|return
name|ret
return|;
name|warn_msg
argument_list|(
name|WarnDeprecated
argument_list|,
literal|"%s:%d: Variable %s is deprecated; use %s instead."
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|x
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|ret
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|split_arg_list
specifier|static
name|QStringList
name|split_arg_list
parameter_list|(
specifier|const
name|QString
modifier|&
name|params
parameter_list|)
block|{
name|int
name|quote
init|=
literal|0
decl_stmt|;
name|QStringList
name|args
decl_stmt|;
specifier|const
name|ushort
name|LPAREN
init|=
literal|'('
decl_stmt|;
specifier|const
name|ushort
name|RPAREN
init|=
literal|')'
decl_stmt|;
specifier|const
name|ushort
name|SINGLEQUOTE
init|=
literal|'\''
decl_stmt|;
specifier|const
name|ushort
name|DOUBLEQUOTE
init|=
literal|'"'
decl_stmt|;
specifier|const
name|ushort
name|BACKSLASH
init|=
literal|'\\'
decl_stmt|;
specifier|const
name|ushort
name|COMMA
init|=
literal|','
decl_stmt|;
specifier|const
name|ushort
name|SPACE
init|=
literal|' '
decl_stmt|;
comment|//const ushort TAB = '\t';
specifier|const
name|QChar
modifier|*
name|params_data
init|=
name|params
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|int
name|params_len
init|=
name|params
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|last
init|=
literal|0
init|;
condition|;
control|)
block|{
while|while
condition|(
name|last
operator|<
name|params_len
operator|&&
operator|(
name|params_data
index|[
name|last
index|]
operator|.
name|unicode
argument_list|()
operator|==
name|SPACE
comment|/*|| params_data[last].unicode() == TAB*/
operator|)
condition|)
operator|++
name|last
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
name|last
init|,
name|parens
init|=
literal|0
init|;
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|x
operator|==
name|params_len
condition|)
block|{
while|while
condition|(
name|x
operator|>
name|last
operator|&&
name|params_data
index|[
name|x
operator|-
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
name|SPACE
condition|)
operator|--
name|x
expr_stmt|;
name|args
operator|<<
name|params
operator|.
name|mid
argument_list|(
name|last
argument_list|,
name|x
operator|-
name|last
argument_list|)
expr_stmt|;
comment|// Could do a check for unmatched parens here, but split_value_list()
comment|// is called on all our output, so mistakes will be caught anyway.
return|return
name|args
return|;
block|}
name|ushort
name|unicode
init|=
name|params_data
index|[
name|x
index|]
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|!=
operator|(
name|int
operator|)
name|params_len
operator|-
literal|1
operator|&&
name|unicode
operator|==
name|BACKSLASH
operator|&&
operator|(
name|params_data
index|[
name|x
operator|+
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
name|SINGLEQUOTE
operator|||
name|params_data
index|[
name|x
operator|+
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
name|DOUBLEQUOTE
operator|)
condition|)
block|{
name|x
operator|++
expr_stmt|;
comment|//get that 'escape'
block|}
elseif|else
if|if
condition|(
name|quote
operator|&&
name|unicode
operator|==
name|quote
condition|)
block|{
name|quote
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quote
operator|&&
operator|(
name|unicode
operator|==
name|SINGLEQUOTE
operator|||
name|unicode
operator|==
name|DOUBLEQUOTE
operator|)
condition|)
block|{
name|quote
operator|=
name|unicode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unicode
operator|==
name|RPAREN
condition|)
block|{
operator|--
name|parens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unicode
operator|==
name|LPAREN
condition|)
block|{
operator|++
name|parens
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parens
operator|&&
operator|!
name|quote
operator|&&
name|unicode
operator|==
name|COMMA
condition|)
block|{
name|int
name|prev
init|=
name|last
decl_stmt|;
name|last
operator|=
name|x
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|x
operator|>
name|prev
operator|&&
name|params_data
index|[
name|x
operator|-
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
name|SPACE
condition|)
operator|--
name|x
expr_stmt|;
name|args
operator|<<
name|params
operator|.
name|mid
argument_list|(
name|prev
argument_list|,
name|x
operator|-
name|prev
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|split_value_list
specifier|static
name|QStringList
name|split_value_list
parameter_list|(
specifier|const
name|QString
modifier|&
name|vals
parameter_list|)
block|{
name|QString
name|build
decl_stmt|;
name|QStringList
name|ret
decl_stmt|;
name|ushort
name|quote
init|=
literal|0
decl_stmt|;
name|int
name|parens
init|=
literal|0
decl_stmt|;
specifier|const
name|ushort
name|LPAREN
init|=
literal|'('
decl_stmt|;
specifier|const
name|ushort
name|RPAREN
init|=
literal|')'
decl_stmt|;
specifier|const
name|ushort
name|SINGLEQUOTE
init|=
literal|'\''
decl_stmt|;
specifier|const
name|ushort
name|DOUBLEQUOTE
init|=
literal|'"'
decl_stmt|;
specifier|const
name|ushort
name|BACKSLASH
init|=
literal|'\\'
decl_stmt|;
name|ushort
name|unicode
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|vals_data
init|=
name|vals
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|int
name|vals_len
init|=
name|vals
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|vals_len
condition|;
name|x
operator|++
control|)
block|{
name|unicode
operator|=
name|vals_data
index|[
name|x
index|]
operator|.
name|unicode
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
operator|(
name|int
operator|)
name|vals_len
operator|-
literal|1
operator|&&
name|unicode
operator|==
name|BACKSLASH
operator|&&
operator|(
name|vals_data
index|[
name|x
operator|+
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
name|SINGLEQUOTE
operator|||
name|vals_data
index|[
name|x
operator|+
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
name|DOUBLEQUOTE
operator|)
condition|)
block|{
name|build
operator|+=
name|vals_data
index|[
name|x
operator|++
index|]
expr_stmt|;
comment|//get that 'escape'
block|}
elseif|else
if|if
condition|(
name|quote
operator|&&
name|unicode
operator|==
name|quote
condition|)
block|{
name|quote
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quote
operator|&&
operator|(
name|unicode
operator|==
name|SINGLEQUOTE
operator|||
name|unicode
operator|==
name|DOUBLEQUOTE
operator|)
condition|)
block|{
name|quote
operator|=
name|unicode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unicode
operator|==
name|RPAREN
condition|)
block|{
operator|--
name|parens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unicode
operator|==
name|LPAREN
condition|)
block|{
operator|++
name|parens
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parens
operator|&&
operator|!
name|quote
operator|&&
operator|(
name|vals_data
index|[
name|x
index|]
operator|==
name|Option
operator|::
name|field_sep
operator|)
condition|)
block|{
name|ret
operator|<<
name|build
expr_stmt|;
name|build
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|build
operator|+=
name|vals_data
index|[
name|x
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|build
operator|.
name|isEmpty
argument_list|()
condition|)
name|ret
operator|<<
name|build
expr_stmt|;
if|if
condition|(
name|parens
condition|)
name|warn_msg
argument_list|(
name|WarnDeprecated
argument_list|,
literal|"%s:%d: Unmatched parentheses are deprecated."
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
comment|// Could do a check for unmatched quotes here, but doVariableReplaceExpand()
comment|// is called on all our output, so mistakes will be caught anyway.
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|//just a parsable entity
end_comment
begin_struct
DECL|struct|ParsableBlock
struct|struct
name|ParsableBlock
block|{
DECL|function|ParsableBlock
name|ParsableBlock
parameter_list|()
member_init_list|:
name|ref_cnt
argument_list|(
literal|1
argument_list|)
block|{ }
DECL|function|~ParsableBlock
specifier|virtual
name|~
name|ParsableBlock
parameter_list|()
block|{ }
DECL|struct|Parse
struct|struct
name|Parse
block|{
DECL|member|text
name|QString
name|text
decl_stmt|;
DECL|member|pi
name|parser_info
name|pi
decl_stmt|;
DECL|function|Parse
name|Parse
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|)
member_init_list|:
name|text
argument_list|(
name|t
argument_list|)
block|{
name|pi
operator|=
name|parser
expr_stmt|;
block|}
block|}
struct|;
DECL|member|parselist
name|QList
argument_list|<
name|Parse
argument_list|>
name|parselist
decl_stmt|;
DECL|function|ref
specifier|inline
name|int
name|ref
parameter_list|()
block|{
return|return
operator|++
name|ref_cnt
return|;
block|}
DECL|function|deref
specifier|inline
name|int
name|deref
parameter_list|()
block|{
return|return
operator|--
name|ref_cnt
return|;
block|}
protected|protected:
DECL|member|ref_cnt
name|int
name|ref_cnt
decl_stmt|;
specifier|virtual
name|bool
name|continueBlock
parameter_list|()
function_decl|=
literal|0
function_decl|;
name|bool
name|eval
parameter_list|(
name|QMakeProject
modifier|*
name|p
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
function_decl|;
block|}
struct|;
end_struct
begin_function
DECL|function|eval
name|bool
name|ParsableBlock
operator|::
name|eval
parameter_list|(
name|QMakeProject
modifier|*
name|p
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
comment|//save state
name|parser_info
name|pi
init|=
name|parser
decl_stmt|;
specifier|const
name|int
name|block_count
init|=
name|p
operator|->
name|scope_blocks
operator|.
name|count
argument_list|()
decl_stmt|;
comment|//execute
name|bool
name|ret
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parselist
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|parser
operator|=
name|parselist
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|pi
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ret
operator|=
name|p
operator|->
name|parse
argument_list|(
name|parselist
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|text
argument_list|,
name|place
argument_list|)
operator|)
operator|||
operator|!
name|continueBlock
argument_list|()
condition|)
break|break;
block|}
comment|//restore state
name|parser
operator|=
name|pi
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|scope_blocks
operator|.
name|count
argument_list|()
operator|>
name|block_count
condition|)
name|p
operator|->
name|scope_blocks
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|//defined functions
end_comment
begin_struct
DECL|struct|FunctionBlock
struct|struct
name|FunctionBlock
super|:
specifier|public
name|ParsableBlock
block|{
DECL|function|FunctionBlock
name|FunctionBlock
parameter_list|()
member_init_list|:
name|calling_place
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|scope_level
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|cause_return
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|member|vars
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
name|vars
decl_stmt|;
DECL|member|calling_place
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|*
name|calling_place
decl_stmt|;
DECL|member|return_value
name|QStringList
name|return_value
decl_stmt|;
DECL|member|scope_level
name|int
name|scope_level
decl_stmt|;
DECL|member|cause_return
name|bool
name|cause_return
decl_stmt|;
name|bool
name|exec
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QStringList
argument_list|>
modifier|&
name|args
parameter_list|,
name|QMakeProject
modifier|*
name|p
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|,
name|QStringList
modifier|&
name|functionReturn
parameter_list|)
function_decl|;
DECL|function|continueBlock
specifier|virtual
name|bool
name|continueBlock
parameter_list|()
block|{
return|return
operator|!
name|cause_return
return|;
block|}
block|}
struct|;
end_struct
begin_function
DECL|function|exec
name|bool
name|FunctionBlock
operator|::
name|exec
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QStringList
argument_list|>
modifier|&
name|args
parameter_list|,
name|QMakeProject
modifier|*
name|proj
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|,
name|QStringList
modifier|&
name|functionReturn
parameter_list|)
block|{
comment|//save state
if|#
directive|if
literal|1
name|calling_place
operator|=
operator|&
name|place
expr_stmt|;
else|#
directive|else
name|calling_place
operator|=
operator|&
name|proj
operator|->
name|variables
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|return_value
operator|.
name|clear
argument_list|()
expr_stmt|;
name|cause_return
operator|=
literal|false
expr_stmt|;
comment|//execute
if|#
directive|if
literal|0
block|vars = proj->variables();
comment|// should be place so that local variables can be inherited
else|#
directive|else
name|vars
operator|=
name|place
expr_stmt|;
endif|#
directive|endif
name|vars
index|[
literal|"ARGS"
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|vars
index|[
literal|"ARGS"
index|]
operator|+=
name|args
index|[
name|i
index|]
expr_stmt|;
name|vars
index|[
name|QString
operator|::
name|number
argument_list|(
name|i
operator|+
literal|1
argument_list|)
index|]
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
block|}
name|bool
name|ret
init|=
name|ParsableBlock
operator|::
name|eval
argument_list|(
name|proj
argument_list|,
name|vars
argument_list|)
decl_stmt|;
name|functionReturn
operator|=
name|return_value
expr_stmt|;
comment|//restore state
name|calling_place
operator|=
literal|0
expr_stmt|;
name|return_value
operator|.
name|clear
argument_list|()
expr_stmt|;
name|vars
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|//loops
end_comment
begin_struct
DECL|struct|IteratorBlock
struct|struct
name|IteratorBlock
super|:
specifier|public
name|ParsableBlock
block|{
DECL|function|IteratorBlock
name|IteratorBlock
parameter_list|()
member_init_list|:
name|scope_level
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|loop_forever
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|cause_break
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|cause_next
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|member|scope_level
name|int
name|scope_level
decl_stmt|;
DECL|struct|Test
struct|struct
name|Test
block|{
DECL|member|func
name|QString
name|func
decl_stmt|;
DECL|member|args
name|QStringList
name|args
decl_stmt|;
DECL|member|invert
name|bool
name|invert
decl_stmt|;
DECL|member|pi
name|parser_info
name|pi
decl_stmt|;
DECL|function|Test
name|Test
parameter_list|(
specifier|const
name|QString
modifier|&
name|f
parameter_list|,
name|QStringList
modifier|&
name|a
parameter_list|,
name|bool
name|i
parameter_list|)
member_init_list|:
name|func
argument_list|(
name|f
argument_list|)
member_init_list|,
name|args
argument_list|(
name|a
argument_list|)
member_init_list|,
name|invert
argument_list|(
name|i
argument_list|)
block|{
name|pi
operator|=
name|parser
expr_stmt|;
block|}
block|}
struct|;
DECL|member|test
name|QList
argument_list|<
name|Test
argument_list|>
name|test
decl_stmt|;
DECL|member|variable
name|QString
name|variable
decl_stmt|;
DECL|member|loop_forever
DECL|member|cause_break
DECL|member|cause_next
name|bool
name|loop_forever
decl_stmt|,
name|cause_break
decl_stmt|,
name|cause_next
decl_stmt|;
DECL|member|list
name|QStringList
name|list
decl_stmt|;
name|bool
name|exec
parameter_list|(
name|QMakeProject
modifier|*
name|p
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
function_decl|;
DECL|function|continueBlock
specifier|virtual
name|bool
name|continueBlock
parameter_list|()
block|{
return|return
operator|!
name|cause_next
operator|&&
operator|!
name|cause_break
return|;
block|}
block|}
struct|;
end_struct
begin_function
DECL|function|exec
name|bool
name|IteratorBlock
operator|::
name|exec
parameter_list|(
name|QMakeProject
modifier|*
name|p
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
name|bool
name|ret
init|=
literal|true
decl_stmt|;
name|QStringList
operator|::
name|Iterator
name|it
decl_stmt|;
if|if
condition|(
operator|!
name|loop_forever
condition|)
name|it
operator|=
name|list
operator|.
name|begin
argument_list|()
expr_stmt|;
name|int
name|iterate_count
init|=
literal|0
decl_stmt|;
comment|//save state
name|IteratorBlock
modifier|*
name|saved_iterator
init|=
name|p
operator|->
name|iterator
decl_stmt|;
name|p
operator|->
name|iterator
operator|=
name|this
expr_stmt|;
comment|//do the loop
while|while
condition|(
name|loop_forever
operator|||
name|it
operator|!=
name|list
operator|.
name|end
argument_list|()
condition|)
block|{
name|cause_next
operator|=
name|cause_break
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|loop_forever
operator|&&
operator|(
operator|*
name|it
operator|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//ignore empty items
operator|++
name|it
expr_stmt|;
continue|continue;
block|}
comment|//set up the loop variable
name|QStringList
name|va
decl_stmt|;
if|if
condition|(
operator|!
name|variable
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|va
operator|=
name|place
index|[
name|variable
index|]
expr_stmt|;
if|if
condition|(
name|loop_forever
condition|)
name|place
index|[
name|variable
index|]
operator|=
name|QStringList
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|iterate_count
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|place
index|[
name|variable
index|]
operator|=
name|QStringList
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
block|}
comment|//do the iterations
name|bool
name|succeed
init|=
literal|true
decl_stmt|;
for|for
control|(
name|QList
argument_list|<
name|Test
argument_list|>
operator|::
name|Iterator
name|test_it
init|=
name|test
operator|.
name|begin
argument_list|()
init|;
name|test_it
operator|!=
name|test
operator|.
name|end
argument_list|()
condition|;
operator|++
name|test_it
control|)
block|{
name|parser
operator|=
operator|(
operator|*
name|test_it
operator|)
operator|.
name|pi
expr_stmt|;
name|succeed
operator|=
name|p
operator|->
name|doProjectTest
argument_list|(
operator|(
operator|*
name|test_it
operator|)
operator|.
name|func
argument_list|,
operator|(
operator|*
name|test_it
operator|)
operator|.
name|args
argument_list|,
name|place
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|test_it
operator|)
operator|.
name|invert
condition|)
name|succeed
operator|=
operator|!
name|succeed
expr_stmt|;
if|if
condition|(
operator|!
name|succeed
condition|)
break|break;
block|}
if|if
condition|(
name|succeed
condition|)
name|ret
operator|=
name|ParsableBlock
operator|::
name|eval
argument_list|(
name|p
argument_list|,
name|place
argument_list|)
expr_stmt|;
comment|//restore the variable in the map
if|if
condition|(
operator|!
name|variable
operator|.
name|isEmpty
argument_list|()
condition|)
name|place
index|[
name|variable
index|]
operator|=
name|va
expr_stmt|;
comment|//loop counters
if|if
condition|(
operator|!
name|loop_forever
condition|)
operator|++
name|it
expr_stmt|;
name|iterate_count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|||
name|cause_break
condition|)
break|break;
block|}
comment|//restore state
name|p
operator|->
name|iterator
operator|=
name|saved_iterator
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_destructor
DECL|function|~ScopeBlock
name|QMakeProject
operator|::
name|ScopeBlock
operator|::
name|~
name|ScopeBlock
parameter_list|()
block|{
if|#
directive|if
literal|0
block|if(iterate)         delete iterate;
endif|#
directive|endif
block|}
end_destructor
begin_function
DECL|function|qmake_error_msg
specifier|static
name|void
name|qmake_error_msg
parameter_list|(
specifier|const
name|QString
modifier|&
name|msg
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: %s\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|msg
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*    1) environment variable QMAKEFEATURES (as separated by colons)    2) property variable QMAKEFEATURES (as separated by colons)    3)<project_root> (where .qmake.cache lives) + FEATURES_DIR    4) environment variable QMAKEPATH (as separated by colons) + /mkspecs/FEATURES_DIR    5) your QMAKESPEC/features dir    6) your data_install/mkspecs/FEATURES_DIR    7) your QMAKESPEC/../FEATURES_DIR dir     FEATURES_DIR is defined as:     1) features/(unix|win32|macx)/    2) features/ */
end_comment
begin_function
DECL|function|qmake_feature_paths
name|QStringList
name|qmake_feature_paths
parameter_list|(
name|QMakeProperty
modifier|*
name|prop
parameter_list|,
name|bool
name|host_build
parameter_list|)
block|{
specifier|const
name|QString
name|mkspecs_concat
init|=
name|QLatin1String
argument_list|(
literal|"/mkspecs"
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|base_concat
init|=
name|QLatin1String
argument_list|(
literal|"/features"
argument_list|)
decl_stmt|;
name|QStringList
name|concat
decl_stmt|;
block|{
switch|switch
condition|(
name|Option
operator|::
name|target_mode
condition|)
block|{
case|case
name|Option
operator|::
name|TARG_MACX_MODE
case|:
comment|//also a unix
name|concat
operator|<<
name|base_concat
operator|+
name|QLatin1String
argument_list|(
literal|"/mac"
argument_list|)
expr_stmt|;
name|concat
operator|<<
name|base_concat
operator|+
name|QLatin1String
argument_list|(
literal|"/macx"
argument_list|)
expr_stmt|;
name|concat
operator|<<
name|base_concat
operator|+
name|QLatin1String
argument_list|(
literal|"/unix"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Can't happen, just make the compiler shut up
case|case
name|Option
operator|::
name|TARG_UNIX_MODE
case|:
name|concat
operator|<<
name|base_concat
operator|+
name|QLatin1String
argument_list|(
literal|"/unix"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Option
operator|::
name|TARG_WIN_MODE
case|:
name|concat
operator|<<
name|base_concat
operator|+
name|QLatin1String
argument_list|(
literal|"/win32"
argument_list|)
expr_stmt|;
break|break;
block|}
name|concat
operator|<<
name|base_concat
expr_stmt|;
block|}
name|QStringList
name|feature_roots
init|=
name|splitPathList
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"QMAKEFEATURES"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|feature_roots
operator|+=
name|cached_qmakefeatures
expr_stmt|;
if|if
condition|(
name|prop
condition|)
name|feature_roots
operator|+=
name|splitPathList
argument_list|(
name|prop
operator|->
name|value
argument_list|(
literal|"QMAKEFEATURES"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cached_build_root
operator|.
name|isEmpty
argument_list|()
condition|)
for|for
control|(
name|QStringList
operator|::
name|Iterator
name|concat_it
init|=
name|concat
operator|.
name|begin
argument_list|()
init|;
name|concat_it
operator|!=
name|concat
operator|.
name|end
argument_list|()
condition|;
operator|++
name|concat_it
control|)
name|feature_roots
operator|<<
operator|(
name|cached_build_root
operator|+
operator|(
operator|*
name|concat_it
operator|)
operator|)
expr_stmt|;
name|QStringList
name|qmakepath
init|=
name|splitPathList
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"QMAKEPATH"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|qmakepath
operator|+=
name|cached_qmakepath
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|path
decl|,
name|qmakepath
control|)
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|cat
decl|,
name|concat
control|)
name|feature_roots
operator|<<
operator|(
name|path
operator|+
name|mkspecs_concat
operator|+
name|cat
operator|)
expr_stmt|;
name|QString
modifier|*
name|specp
init|=
name|host_build
condition|?
operator|&
name|Option
operator|::
name|mkfile
operator|::
name|qmakespec
else|:
operator|&
name|Option
operator|::
name|mkfile
operator|::
name|xqmakespec
decl_stmt|;
if|if
condition|(
operator|!
name|specp
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
comment|// The spec is already platform-dependent, so no subdirs here.
name|feature_roots
operator|<<
operator|*
name|specp
operator|+
name|base_concat
expr_stmt|;
comment|// Also check directly under the root directory of the mkspecs collection
name|QFileInfo
name|specfi
argument_list|(
operator|*
name|specp
argument_list|)
decl_stmt|;
name|QDir
name|specrootdir
argument_list|(
name|specfi
operator|.
name|absolutePath
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|specrootdir
operator|.
name|isRoot
argument_list|()
condition|)
block|{
specifier|const
name|QString
name|specrootpath
init|=
name|specrootdir
operator|.
name|path
argument_list|()
decl_stmt|;
if|if
condition|(
name|specrootpath
operator|.
name|endsWith
argument_list|(
name|mkspecs_concat
argument_list|)
condition|)
block|{
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|specrootpath
operator|+
name|base_concat
argument_list|)
condition|)
for|for
control|(
name|QStringList
operator|::
name|Iterator
name|concat_it
init|=
name|concat
operator|.
name|begin
argument_list|()
init|;
name|concat_it
operator|!=
name|concat
operator|.
name|end
argument_list|()
condition|;
operator|++
name|concat_it
control|)
name|feature_roots
operator|<<
operator|(
name|specrootpath
operator|+
operator|(
operator|*
name|concat_it
operator|)
operator|)
expr_stmt|;
break|break;
block|}
name|specrootdir
operator|.
name|cdUp
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|QStringList
operator|::
name|Iterator
name|concat_it
init|=
name|concat
operator|.
name|begin
argument_list|()
init|;
name|concat_it
operator|!=
name|concat
operator|.
name|end
argument_list|()
condition|;
operator|++
name|concat_it
control|)
name|feature_roots
operator|<<
operator|(
name|QLibraryInfo
operator|::
name|rawLocation
argument_list|(
name|QLibraryInfo
operator|::
name|HostDataPath
argument_list|,
name|QLibraryInfo
operator|::
name|EffectivePaths
argument_list|)
operator|+
name|mkspecs_concat
operator|+
operator|(
operator|*
name|concat_it
operator|)
operator|)
expr_stmt|;
name|feature_roots
operator|.
name|removeDuplicates
argument_list|()
expr_stmt|;
return|return
name|feature_roots
return|;
block|}
end_function
begin_function
DECL|function|qmake_mkspec_paths
name|QStringList
name|qmake_mkspec_paths
parameter_list|()
block|{
name|QStringList
name|ret
decl_stmt|;
specifier|const
name|QString
name|concat
init|=
name|QLatin1String
argument_list|(
literal|"/mkspecs"
argument_list|)
decl_stmt|;
name|QStringList
name|qmakepath
init|=
name|splitPathList
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"QMAKEPATH"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|qmakepath
operator|+=
name|cached_qmakepath
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|path
decl|,
name|qmakepath
control|)
name|ret
operator|<<
operator|(
name|path
operator|+
name|concat
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|cached_build_root
operator|.
name|isEmpty
argument_list|()
condition|)
name|ret
operator|<<
name|cached_build_root
operator|+
name|concat
expr_stmt|;
if|if
condition|(
operator|!
name|cached_source_root
operator|.
name|isEmpty
argument_list|()
condition|)
name|ret
operator|<<
name|cached_source_root
operator|+
name|concat
expr_stmt|;
name|ret
operator|<<
name|QLibraryInfo
operator|::
name|rawLocation
argument_list|(
name|QLibraryInfo
operator|::
name|HostDataPath
argument_list|,
name|QLibraryInfo
operator|::
name|EffectivePaths
argument_list|)
operator|+
name|concat
expr_stmt|;
name|ret
operator|.
name|removeDuplicates
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_destructor
DECL|function|~QMakeProject
name|QMakeProject
operator|::
name|~
name|QMakeProject
parameter_list|()
block|{
if|if
condition|(
name|own_prop
condition|)
operator|delete
name|prop
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
name|void
DECL|function|init
name|QMakeProject
operator|::
name|init
parameter_list|(
name|QMakeProperty
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|prop
operator|=
operator|new
name|QMakeProperty
expr_stmt|;
name|own_prop
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|prop
operator|=
name|p
expr_stmt|;
name|own_prop
operator|=
literal|false
expr_stmt|;
block|}
name|recursive
operator|=
literal|false
expr_stmt|;
name|host_build
operator|=
literal|false
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|cleanup
name|QMakeProject
operator|::
name|cleanup
parameter_list|()
block|{
for|for
control|(
name|QHash
argument_list|<
name|QString
argument_list|,
name|FunctionBlock
operator|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|replaceFunctions
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|replaceFunctions
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
if|if
condition|(
operator|!
name|it
operator|.
name|value
argument_list|()
operator|->
name|deref
argument_list|()
condition|)
operator|delete
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
name|replaceFunctions
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|QHash
argument_list|<
name|QString
argument_list|,
name|FunctionBlock
operator|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|testFunctions
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|testFunctions
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
if|if
condition|(
operator|!
name|it
operator|.
name|value
argument_list|()
operator|->
name|deref
argument_list|()
condition|)
operator|delete
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
name|testFunctions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// Duplicate project. It is *not* allowed to call the complex read() functions on the copy.
end_comment
begin_constructor
DECL|function|QMakeProject
name|QMakeProject
operator|::
name|QMakeProject
parameter_list|(
name|QMakeProject
modifier|*
name|p
parameter_list|,
specifier|const
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|*
name|_vars
parameter_list|)
block|{
name|init
argument_list|(
name|p
operator|->
name|properties
argument_list|()
argument_list|)
expr_stmt|;
name|vars
operator|=
name|_vars
condition|?
operator|*
name|_vars
else|:
name|p
operator|->
name|variables
argument_list|()
expr_stmt|;
name|host_build
operator|=
name|p
operator|->
name|host_build
expr_stmt|;
for|for
control|(
name|QHash
argument_list|<
name|QString
argument_list|,
name|FunctionBlock
operator|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|p
operator|->
name|replaceFunctions
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|p
operator|->
name|replaceFunctions
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|it
operator|.
name|value
argument_list|()
operator|->
name|ref
argument_list|()
expr_stmt|;
name|replaceFunctions
operator|.
name|insert
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|QHash
argument_list|<
name|QString
argument_list|,
name|FunctionBlock
operator|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|p
operator|->
name|testFunctions
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|p
operator|->
name|testFunctions
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|it
operator|.
name|value
argument_list|()
operator|->
name|ref
argument_list|()
expr_stmt|;
name|testFunctions
operator|.
name|insert
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_function
name|void
DECL|function|reset
name|QMakeProject
operator|::
name|reset
parameter_list|()
block|{
comment|// scope_blocks starts with one non-ignoring entity
name|scope_blocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|scope_blocks
operator|.
name|push
argument_list|(
name|ScopeBlock
argument_list|()
argument_list|)
expr_stmt|;
name|iterator
operator|=
literal|0
expr_stmt|;
name|function
operator|=
literal|0
expr_stmt|;
name|backslashWarned
operator|=
literal|false
expr_stmt|;
name|need_restart
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
name|bool
DECL|function|parse
name|QMakeProject
operator|::
name|parse
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|,
name|int
name|numLines
parameter_list|)
block|{
comment|// To preserve the integrity of any UTF-8 characters in .pro file, temporarily replace the
comment|// non-breaking space (0xA0) characters with another non-space character, so that
comment|// QString::simplified() call will not replace it with space.
comment|// Note: There won't be any two byte characters in .pro files, so 0x10A0 should be a safe
comment|// replacement character.
specifier|static
name|QChar
name|nbsp
argument_list|(
literal|0xA0
argument_list|)
decl_stmt|;
specifier|static
name|QChar
name|nbspFix
argument_list|(
literal|0x01A0
argument_list|)
decl_stmt|;
name|QString
name|s
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|indexOf
argument_list|(
name|nbsp
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|s
operator|=
name|t
expr_stmt|;
name|s
operator|.
name|replace
argument_list|(
name|nbsp
argument_list|,
name|nbspFix
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|.
name|simplified
argument_list|()
expr_stmt|;
name|s
operator|.
name|replace
argument_list|(
name|nbspFix
argument_list|,
name|nbsp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|t
operator|.
name|simplified
argument_list|()
expr_stmt|;
block|}
name|int
name|hash_mark
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|"#"
argument_list|)
decl_stmt|;
if|if
condition|(
name|hash_mark
operator|!=
operator|-
literal|1
condition|)
comment|//good bye comments
name|s
operator|=
name|s
operator|.
name|left
argument_list|(
name|hash_mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// blank_line
return|return
literal|true
return|;
if|if
condition|(
name|scope_blocks
operator|.
name|top
argument_list|()
operator|.
name|ignore
condition|)
block|{
name|bool
name|continue_parsing
init|=
literal|false
decl_stmt|;
comment|// adjust scope for each block which appears on a single line
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|'{'
condition|)
block|{
name|scope_blocks
operator|.
name|push
argument_list|(
name|ScopeBlock
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|'}'
condition|)
block|{
if|if
condition|(
name|scope_blocks
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Braces mismatch %s:%d\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|ScopeBlock
name|sb
init|=
name|scope_blocks
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|sb
operator|.
name|iterate
condition|)
block|{
name|sb
operator|.
name|iterate
operator|->
name|exec
argument_list|(
name|this
argument_list|,
name|place
argument_list|)
expr_stmt|;
operator|delete
name|sb
operator|.
name|iterate
expr_stmt|;
name|sb
operator|.
name|iterate
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|scope_blocks
operator|.
name|top
argument_list|()
operator|.
name|ignore
condition|)
block|{
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Project Parser: %s:%d : Leaving block %d"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|scope_blocks
operator|.
name|count
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|.
name|mid
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|.
name|trimmed
argument_list|()
expr_stmt|;
name|continue_parsing
operator|=
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|continue_parsing
condition|)
block|{
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Project Parser: %s:%d : Ignored due to block being false."
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|function
condition|)
block|{
name|QString
name|append
decl_stmt|;
name|int
name|d_off
init|=
literal|0
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|d
init|=
name|s
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|bool
name|function_finished
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|d_off
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
condition|)
block|{
name|function
operator|->
name|scope_level
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|function
operator|->
name|scope_level
condition|)
block|{
name|function_finished
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
name|function
operator|->
name|scope_level
operator|++
expr_stmt|;
block|}
name|append
operator|+=
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
expr_stmt|;
operator|++
name|d_off
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|append
operator|.
name|isEmpty
argument_list|()
condition|)
name|function
operator|->
name|parselist
operator|.
name|append
argument_list|(
name|IteratorBlock
operator|::
name|Parse
argument_list|(
name|append
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_finished
condition|)
block|{
name|function
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|QString
argument_list|(
name|d
operator|+
name|d_off
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
name|d_off
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|IteratorBlock
modifier|*
name|it
init|=
name|scope_blocks
operator|.
name|top
argument_list|()
operator|.
name|iterate
condition|)
block|{
name|QString
name|append
decl_stmt|;
name|int
name|d_off
init|=
literal|0
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|d
init|=
name|s
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|bool
name|iterate_finished
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|d_off
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
condition|)
block|{
name|it
operator|->
name|scope_level
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|it
operator|->
name|scope_level
condition|)
block|{
name|iterate_finished
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
name|it
operator|->
name|scope_level
operator|++
expr_stmt|;
block|}
name|append
operator|+=
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
expr_stmt|;
operator|++
name|d_off
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|append
operator|.
name|isEmpty
argument_list|()
condition|)
name|scope_blocks
operator|.
name|top
argument_list|()
operator|.
name|iterate
operator|->
name|parselist
operator|.
name|append
argument_list|(
name|IteratorBlock
operator|::
name|Parse
argument_list|(
name|append
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterate_finished
condition|)
block|{
name|scope_blocks
operator|.
name|top
argument_list|()
operator|.
name|iterate
operator|=
literal|0
expr_stmt|;
name|bool
name|ret
init|=
name|it
operator|->
name|exec
argument_list|(
name|this
argument_list|,
name|place
argument_list|)
decl_stmt|;
operator|delete
name|it
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
literal|false
return|;
name|s
operator|=
name|s
operator|.
name|mid
argument_list|(
name|d_off
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
name|QString
name|scope
decl_stmt|,
name|var
decl_stmt|,
name|op
decl_stmt|;
name|QStringList
name|val
decl_stmt|;
DECL|macro|SKIP_WS
define|#
directive|define
name|SKIP_WS
parameter_list|(
name|d
parameter_list|,
name|o
parameter_list|,
name|l
parameter_list|)
value|while(o< l&& (*(d+o) == QLatin1Char(' ') || *(d+o) == QLatin1Char('\t'))) ++o
specifier|const
name|QChar
modifier|*
name|d
init|=
name|s
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|int
name|d_off
init|=
literal|0
decl_stmt|;
name|SKIP_WS
argument_list|(
name|d
argument_list|,
name|d_off
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|IteratorBlock
modifier|*
name|iterator
init|=
literal|0
decl_stmt|;
name|bool
name|scope_failed
init|=
literal|false
decl_stmt|,
name|else_line
init|=
literal|false
decl_stmt|,
name|or_op
init|=
literal|false
decl_stmt|;
name|QChar
name|quote
init|=
literal|0
decl_stmt|;
name|int
name|parens
init|=
literal|0
decl_stmt|,
name|scope_count
init|=
literal|0
decl_stmt|,
name|start_block
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|d_off
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|parens
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
operator|||
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|||
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
operator|||
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'~'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|+
literal|1
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|+
literal|1
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
condition|)
block|{
specifier|const
name|QChar
modifier|*
name|k
init|=
name|d
operator|+
name|d_off
operator|+
literal|1
decl_stmt|;
name|int
name|k_off
init|=
literal|0
decl_stmt|;
name|SKIP_WS
argument_list|(
name|k
argument_list|,
name|k_off
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
name|d_off
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|k
operator|+
name|k_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|QString
name|msg
decl_stmt|;
name|qmake_error_msg
argument_list|(
name|QString
argument_list|(
name|d
operator|+
name|d_off
argument_list|,
literal|1
argument_list|)
operator|+
literal|"must be followed immediately by ="
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|quote
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|quote
condition|)
name|quote
operator|=
name|QChar
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
literal|'('
condition|)
block|{
operator|++
name|parens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
literal|')'
condition|)
block|{
operator|--
name|parens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
literal|'"'
comment|/*|| *(d+d_off) == '\''*/
condition|)
block|{
name|quote
operator|=
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parens
operator|&&
name|quote
operator|.
name|isNull
argument_list|()
operator|&&
operator|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|||
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
operator|||
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
operator|||
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
operator|)
condition|)
block|{
name|scope_count
operator|++
expr_stmt|;
name|scope
operator|=
name|var
operator|.
name|trimmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
condition|)
name|scope
operator|+=
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
expr_stmt|;
comment|// need this
name|var
operator|=
literal|""
expr_stmt|;
name|bool
name|test
init|=
name|scope_failed
decl_stmt|;
if|if
condition|(
name|scope
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|test
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scope
operator|.
name|toLower
argument_list|()
operator|==
literal|"else"
condition|)
block|{
comment|//else is a builtin scope here as it modifies state
if|if
condition|(
name|scope_count
operator|!=
literal|1
operator|||
name|scope_blocks
operator|.
name|top
argument_list|()
operator|.
name|else_status
operator|==
name|ScopeBlock
operator|::
name|TestNone
condition|)
block|{
name|qmake_error_msg
argument_list|(
operator|(
literal|"Unexpected "
operator|+
name|scope
operator|+
literal|" ('"
operator|+
name|s
operator|+
literal|"')"
operator|)
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|else_line
operator|=
literal|true
expr_stmt|;
name|test
operator|=
operator|(
name|scope_blocks
operator|.
name|top
argument_list|()
operator|.
name|else_status
operator|==
name|ScopeBlock
operator|::
name|TestSeek
operator|)
expr_stmt|;
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Project Parser: %s:%d : Else%s %s."
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|scope
operator|==
literal|"else"
condition|?
literal|""
else|:
name|QString
argument_list|(
literal|" ("
operator|+
name|scope
operator|+
literal|")"
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|test
condition|?
literal|"considered"
else|:
literal|"excluded"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|comp_scope
init|=
name|scope
decl_stmt|;
name|bool
name|invert_test
init|=
operator|(
name|comp_scope
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'!'
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|invert_test
condition|)
name|comp_scope
operator|=
name|comp_scope
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|int
name|lparen
init|=
name|comp_scope
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
decl_stmt|;
if|if
condition|(
name|or_op
operator|==
name|scope_failed
condition|)
block|{
if|if
condition|(
name|lparen
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// if there is an lparen in the scope, it IS a function
name|int
name|rparen
init|=
name|comp_scope
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
decl_stmt|;
if|if
condition|(
name|rparen
operator|==
operator|-
literal|1
condition|)
block|{
name|qmake_error_msg
argument_list|(
literal|"Function missing right paren: "
operator|+
name|comp_scope
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QString
name|func
init|=
name|comp_scope
operator|.
name|left
argument_list|(
name|lparen
argument_list|)
decl_stmt|;
name|QStringList
name|args
init|=
name|split_arg_list
argument_list|(
name|comp_scope
operator|.
name|mid
argument_list|(
name|lparen
operator|+
literal|1
argument_list|,
name|rparen
operator|-
name|lparen
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|function
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: No tests can come after a function definition!\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|func
operator|==
literal|"for"
condition|)
block|{
comment|//for is a builtin function here, as it modifies state
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
operator|||
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: for(iterate, list) requires two arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|iterator
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d unexpected nested for()\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|iterator
operator|=
operator|new
name|IteratorBlock
expr_stmt|;
name|QString
name|it_list
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
name|doVariableReplace
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|it_list
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|!=
literal|"ever"
condition|)
block|{
operator|delete
name|iterator
expr_stmt|;
name|iterator
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: for(iterate, list) requires two arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|it_list
operator|=
literal|"forever"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|2
condition|)
block|{
name|iterator
operator|->
name|variable
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|doVariableReplace
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|it_list
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
block|}
name|QStringList
name|list
init|=
name|place
index|[
name|it_list
index|]
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|it_list
operator|==
literal|"forever"
condition|)
block|{
name|iterator
operator|->
name|loop_forever
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|int
name|dotdot
init|=
name|it_list
operator|.
name|indexOf
argument_list|(
literal|".."
argument_list|)
decl_stmt|;
if|if
condition|(
name|dotdot
operator|!=
operator|-
literal|1
condition|)
block|{
name|bool
name|ok
decl_stmt|;
name|int
name|start
init|=
name|it_list
operator|.
name|left
argument_list|(
name|dotdot
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|int
name|end
init|=
name|it_list
operator|.
name|mid
argument_list|(
name|dotdot
operator|+
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|start
operator|<
name|end
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
control|)
name|list
operator|<<
name|QString
operator|::
name|number
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|>=
name|end
condition|;
name|i
operator|--
control|)
name|list
operator|<<
name|QString
operator|::
name|number
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|iterator
operator|->
name|list
operator|=
name|list
expr_stmt|;
name|test
operator|=
operator|!
name|invert_test
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iterator
condition|)
block|{
name|iterator
operator|->
name|test
operator|.
name|append
argument_list|(
name|IteratorBlock
operator|::
name|Test
argument_list|(
name|func
argument_list|,
name|args
argument_list|,
name|invert_test
argument_list|)
argument_list|)
expr_stmt|;
name|test
operator|=
operator|!
name|invert_test
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|func
operator|==
literal|"defineTest"
operator|||
name|func
operator|==
literal|"defineReplace"
condition|)
block|{
if|if
condition|(
operator|!
name|function_blocks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: cannot define a function within another definition.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: %s(function_name) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|func
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QHash
argument_list|<
name|QString
argument_list|,
name|FunctionBlock
modifier|*
argument_list|>
modifier|*
name|map
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|func
operator|==
literal|"defineTest"
condition|)
name|map
operator|=
operator|&
name|testFunctions
expr_stmt|;
else|else
name|map
operator|=
operator|&
name|replaceFunctions
expr_stmt|;
if|#
directive|if
literal|0
block|if(!map || map->contains(args[0])) {                                 fprintf(stderr, "%s:%d: Function[%s] multiply defined.\n",                                         parser.file.toLatin1().constData(), parser.line_no, args[0].toLatin1().constData());                                 return false;                             }
endif|#
directive|endif
name|function
operator|=
operator|new
name|FunctionBlock
expr_stmt|;
name|map
operator|->
name|insert
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|test
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|test
operator|=
name|doProjectTest
argument_list|(
name|func
argument_list|,
name|args
argument_list|,
name|place
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
operator|&&
name|d_off
operator|==
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|invert_test
condition|)
name|test
operator|=
operator|!
name|test
expr_stmt|;
name|scope_blocks
operator|.
name|top
argument_list|()
operator|.
name|else_status
operator|=
operator|(
name|test
condition|?
name|ScopeBlock
operator|::
name|TestFound
else|:
name|ScopeBlock
operator|::
name|TestSeek
operator|)
expr_stmt|;
return|return
literal|true
return|;
comment|// assume we are done
block|}
block|}
block|}
else|else
block|{
name|QString
name|cscope
init|=
name|comp_scope
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|doVariableReplace
argument_list|(
name|cscope
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|test
operator|=
name|isActiveConfig
argument_list|(
name|cscope
operator|.
name|trimmed
argument_list|()
argument_list|,
literal|true
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|invert_test
condition|)
name|test
operator|=
operator|!
name|test
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|test
operator|&&
operator|!
name|scope_failed
condition|)
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Project Parser: %s:%d : Test (%s) failed."
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|scope
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
operator|==
name|or_op
condition|)
name|scope_failed
operator|=
operator|!
name|test
expr_stmt|;
name|or_op
operator|=
operator|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
comment|// scoping block
name|start_block
operator|++
expr_stmt|;
if|if
condition|(
name|iterator
condition|)
block|{
for|for
control|(
name|int
name|off
init|=
literal|0
init|,
name|braces
init|=
literal|0
init|;
literal|true
condition|;
operator|++
name|off
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|+
name|off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
condition|)
operator|++
name|braces
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|+
name|off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
operator|&&
name|braces
condition|)
operator|--
name|braces
expr_stmt|;
if|if
condition|(
operator|!
name|braces
operator|||
name|d_off
operator|+
name|off
operator|==
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
name|iterator
operator|->
name|parselist
operator|.
name|append
argument_list|(
name|s
operator|.
name|mid
argument_list|(
name|d_off
argument_list|,
name|off
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|braces
operator|>
literal|1
condition|)
name|iterator
operator|->
name|scope_level
operator|+=
name|braces
operator|-
literal|1
expr_stmt|;
name|d_off
operator|+=
name|off
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|parens
operator|&&
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
condition|)
block|{
if|if
condition|(
name|start_block
condition|)
block|{
operator|--
name|start_block
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|scope_blocks
operator|.
name|count
argument_list|()
condition|)
block|{
name|warn_msg
argument_list|(
name|WarnParser
argument_list|,
literal|"Possible braces mismatch %s:%d"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scope_blocks
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Braces mismatch %s:%d\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Project Parser: %s:%d : Leaving block %d"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|scope_blocks
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|ScopeBlock
name|sb
init|=
name|scope_blocks
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|sb
operator|.
name|iterate
condition|)
name|sb
operator|.
name|iterate
operator|->
name|exec
argument_list|(
name|this
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|var
operator|+=
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
expr_stmt|;
block|}
operator|++
name|d_off
expr_stmt|;
block|}
name|var
operator|=
name|var
operator|.
name|trimmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|else_line
operator|||
operator|(
name|else_line
operator|&&
operator|!
name|scope_failed
operator|)
condition|)
name|scope_blocks
operator|.
name|top
argument_list|()
operator|.
name|else_status
operator|=
operator|(
operator|!
name|scope_failed
condition|?
name|ScopeBlock
operator|::
name|TestFound
else|:
name|ScopeBlock
operator|::
name|TestSeek
operator|)
expr_stmt|;
if|if
condition|(
name|start_block
condition|)
block|{
name|ScopeBlock
name|next_block
argument_list|(
name|scope_failed
argument_list|)
decl_stmt|;
name|next_block
operator|.
name|iterate
operator|=
name|iterator
expr_stmt|;
if|if
condition|(
name|iterator
condition|)
name|next_block
operator|.
name|else_status
operator|=
name|ScopeBlock
operator|::
name|TestNone
expr_stmt|;
elseif|else
if|if
condition|(
name|scope_failed
condition|)
name|next_block
operator|.
name|else_status
operator|=
name|ScopeBlock
operator|::
name|TestSeek
expr_stmt|;
else|else
name|next_block
operator|.
name|else_status
operator|=
name|ScopeBlock
operator|::
name|TestFound
expr_stmt|;
name|scope_blocks
operator|.
name|push
argument_list|(
name|next_block
argument_list|)
expr_stmt|;
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Project Parser: %s:%d : Entering block %d (%d). [%s]"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|scope_blocks
operator|.
name|count
argument_list|()
argument_list|,
name|scope_failed
argument_list|,
name|s
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iterator
condition|)
block|{
name|iterator
operator|->
name|parselist
operator|.
name|append
argument_list|(
name|QString
argument_list|(
name|var
operator|+
name|s
operator|.
name|mid
argument_list|(
name|d_off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|ret
init|=
name|iterator
operator|->
name|exec
argument_list|(
name|this
argument_list|,
name|place
argument_list|)
decl_stmt|;
operator|delete
name|iterator
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|(
operator|!
name|scope_count
operator|&&
operator|!
name|var
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
operator|(
name|scope_count
operator|==
literal|1
operator|&&
name|else_line
operator|)
condition|)
name|scope_blocks
operator|.
name|top
argument_list|()
operator|.
name|else_status
operator|=
name|ScopeBlock
operator|::
name|TestNone
expr_stmt|;
if|if
condition|(
name|d_off
operator|==
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|var
operator|.
name|trimmed
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|qmake_error_msg
argument_list|(
operator|(
literal|"Parse Error ('"
operator|+
name|s
operator|+
literal|"')"
operator|)
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|var
operator|.
name|isEmpty
argument_list|()
return|;
comment|// allow just a scope
block|}
name|SKIP_WS
argument_list|(
name|d
argument_list|,
name|d_off
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|d_off
operator|<
name|s
operator|.
name|length
argument_list|()
operator|&&
name|op
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
operator|==
operator|-
literal|1
condition|;
name|op
operator|+=
operator|*
operator|(
name|d
operator|+
operator|(
name|d_off
operator|++
operator|)
operator|)
control|)
empty_stmt|;
name|op
operator|.
name|replace
argument_list|(
name|QRegExp
argument_list|(
literal|"\\s"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SKIP_WS
argument_list|(
name|d
argument_list|,
name|d_off
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|vals
init|=
name|s
operator|.
name|mid
argument_list|(
name|d_off
argument_list|)
decl_stmt|;
comment|// vals now contains the space separated list of values
name|int
name|rbraces
init|=
name|vals
operator|.
name|count
argument_list|(
literal|'}'
argument_list|)
decl_stmt|,
name|lbraces
init|=
name|vals
operator|.
name|count
argument_list|(
literal|'{'
argument_list|)
decl_stmt|;
if|if
condition|(
name|scope_blocks
operator|.
name|count
argument_list|()
operator|>
literal|1
operator|&&
name|rbraces
operator|-
name|lbraces
operator|==
literal|1
operator|&&
name|vals
operator|.
name|endsWith
argument_list|(
literal|'}'
argument_list|)
condition|)
block|{
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Project Parser: %s:%d : Leaving block %d"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|scope_blocks
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|ScopeBlock
name|sb
init|=
name|scope_blocks
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|sb
operator|.
name|iterate
condition|)
name|sb
operator|.
name|iterate
operator|->
name|exec
argument_list|(
name|this
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|vals
operator|.
name|truncate
argument_list|(
name|vals
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rbraces
operator|!=
name|lbraces
condition|)
block|{
name|warn_msg
argument_list|(
name|WarnParser
argument_list|,
literal|"Possible braces mismatch {%s} %s:%d"
argument_list|,
name|vals
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scope_failed
condition|)
return|return
literal|true
return|;
comment|// oh well
DECL|macro|SKIP_WS
undef|#
directive|undef
name|SKIP_WS
name|doVariableReplace
argument_list|(
name|var
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|var
operator|=
name|varMap
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|//backwards compatibility
if|if
condition|(
operator|!
name|var
operator|.
name|isEmpty
argument_list|()
operator|&&
name|Option
operator|::
name|mkfile
operator|::
name|do_preprocess
condition|)
block|{
specifier|static
name|QString
name|last_file
argument_list|(
literal|"*none*"
argument_list|)
decl_stmt|;
if|if
condition|(
name|parser
operator|.
name|file
operator|!=
name|last_file
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#file %s:%d\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
name|last_file
operator|=
name|parser
operator|.
name|file
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s %s %s\n"
argument_list|,
name|var
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|op
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|vals
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vals
operator|.
name|contains
argument_list|(
literal|'='
argument_list|)
operator|&&
name|numLines
operator|>
literal|1
condition|)
name|warn_msg
argument_list|(
name|WarnParser
argument_list|,
literal|"Possible accidental line continuation: {%s} at %s:%d"
argument_list|,
name|var
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
name|QStringList
modifier|&
name|varlist
init|=
name|place
index|[
name|var
index|]
decl_stmt|;
comment|// varlist is the list in the symbol table
if|if
condition|(
name|Option
operator|::
name|debug_level
operator|>=
literal|1
condition|)
block|{
name|QString
name|tmp_vals
init|=
name|vals
decl_stmt|;
name|doVariableReplace
argument_list|(
name|tmp_vals
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Project Parser: %s:%d :%s: :%s: (%s)"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|var
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|op
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|tmp_vals
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// now do the operation
if|if
condition|(
name|op
operator|==
literal|"~="
condition|)
block|{
name|doVariableReplace
argument_list|(
name|vals
argument_list|,
name|place
argument_list|)
expr_stmt|;
if|if
condition|(
name|vals
operator|.
name|length
argument_list|()
operator|<
literal|4
operator|||
name|vals
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'s'
condition|)
block|{
name|qmake_error_msg
argument_list|(
operator|(
literal|"~= operator only can handle s/// function ('"
operator|+
name|s
operator|+
literal|"')"
operator|)
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QChar
name|sep
init|=
name|vals
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|QStringList
name|func
init|=
name|vals
operator|.
name|split
argument_list|(
name|sep
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|.
name|count
argument_list|()
operator|<
literal|3
operator|||
name|func
operator|.
name|count
argument_list|()
operator|>
literal|4
condition|)
block|{
name|qmake_error_msg
argument_list|(
operator|(
literal|"~= operator only can handle s/// function ('"
operator|+
name|s
operator|+
literal|"')"
operator|)
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|bool
name|global
init|=
literal|false
decl_stmt|,
name|case_sense
init|=
literal|true
decl_stmt|,
name|quote
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|func
operator|.
name|count
argument_list|()
operator|==
literal|4
condition|)
block|{
name|global
operator|=
name|func
index|[
literal|3
index|]
operator|.
name|indexOf
argument_list|(
literal|'g'
argument_list|)
operator|!=
operator|-
literal|1
expr_stmt|;
name|case_sense
operator|=
name|func
index|[
literal|3
index|]
operator|.
name|indexOf
argument_list|(
literal|'i'
argument_list|)
operator|==
operator|-
literal|1
expr_stmt|;
name|quote
operator|=
name|func
index|[
literal|3
index|]
operator|.
name|indexOf
argument_list|(
literal|'q'
argument_list|)
operator|!=
operator|-
literal|1
expr_stmt|;
block|}
name|QString
name|from
init|=
name|func
index|[
literal|1
index|]
decl_stmt|,
name|to
init|=
name|func
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|quote
condition|)
name|from
operator|=
name|QRegExp
operator|::
name|escape
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|QRegExp
name|regexp
argument_list|(
name|from
argument_list|,
name|case_sense
condition|?
name|Qt
operator|::
name|CaseSensitive
else|:
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|Iterator
name|varit
init|=
name|varlist
operator|.
name|begin
argument_list|()
init|;
name|varit
operator|!=
name|varlist
operator|.
name|end
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|varit
operator|)
operator|.
name|contains
argument_list|(
name|regexp
argument_list|)
condition|)
block|{
operator|(
operator|*
name|varit
operator|)
operator|=
operator|(
operator|*
name|varit
operator|)
operator|.
name|replace
argument_list|(
name|regexp
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|varit
operator|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|varit
operator|=
name|varlist
operator|.
name|erase
argument_list|(
name|varit
argument_list|)
expr_stmt|;
else|else
operator|++
name|varit
expr_stmt|;
if|if
condition|(
operator|!
name|global
condition|)
break|break;
block|}
else|else
operator|++
name|varit
expr_stmt|;
block|}
block|}
else|else
block|{
name|QStringList
name|vallist
decl_stmt|;
block|{
comment|//doVariableReplace(vals, place);
name|QStringList
name|tmp
init|=
name|split_value_list
argument_list|(
name|vals
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tmp
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|vallist
operator|+=
name|doVariableReplaceExpand
argument_list|(
name|tmp
index|[
name|i
index|]
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
literal|"="
condition|)
block|{
if|if
condition|(
operator|!
name|varlist
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bool
name|send_warning
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|var
operator|!=
literal|"TEMPLATE"
operator|&&
name|var
operator|!=
literal|"TARGET"
condition|)
block|{
name|QSet
argument_list|<
name|QString
argument_list|>
name|incoming_vals
init|=
name|vallist
operator|.
name|toSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|varlist
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
name|var
init|=
name|varlist
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|var
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|incoming_vals
operator|.
name|contains
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|send_warning
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|send_warning
condition|)
name|warn_msg
argument_list|(
name|WarnParser
argument_list|,
literal|"Operator=(%s) clears variables previously set: %s:%d"
argument_list|,
name|var
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
name|varlist
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|QStringList
operator|::
name|ConstIterator
name|valit
init|=
name|vallist
operator|.
name|begin
argument_list|()
init|;
name|valit
operator|!=
name|vallist
operator|.
name|end
argument_list|()
condition|;
operator|++
name|valit
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|valit
operator|)
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
if|if
condition|(
operator|(
name|op
operator|==
literal|"*="
operator|&&
operator|!
name|varlist
operator|.
name|contains
argument_list|(
operator|(
operator|*
name|valit
operator|)
argument_list|)
operator|)
operator|||
name|op
operator|==
literal|"="
operator|||
name|op
operator|==
literal|"+="
condition|)
name|varlist
operator|.
name|append
argument_list|(
operator|(
operator|*
name|valit
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
literal|"-="
condition|)
name|varlist
operator|.
name|removeAll
argument_list|(
operator|(
operator|*
name|valit
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|var
operator|==
literal|"REQUIRES"
condition|)
comment|// special case to get communicated to backends!
name|doProjectCheckReqs
argument_list|(
name|vallist
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
name|bool
DECL|function|read
name|QMakeProject
operator|::
name|read
parameter_list|(
name|QTextStream
modifier|&
name|file
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
name|int
name|numLines
init|=
literal|0
decl_stmt|;
name|bool
name|ret
init|=
literal|true
decl_stmt|;
name|QString
name|s
decl_stmt|;
while|while
condition|(
operator|!
name|file
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|parser
operator|.
name|line_no
operator|++
expr_stmt|;
name|QString
name|line
init|=
name|file
operator|.
name|readLine
argument_list|()
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|int
name|prelen
init|=
name|line
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|hash_mark
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|"#"
argument_list|)
decl_stmt|;
if|if
condition|(
name|hash_mark
operator|!=
operator|-
literal|1
condition|)
comment|//good bye comments
name|line
operator|=
name|line
operator|.
name|left
argument_list|(
name|hash_mark
argument_list|)
operator|.
name|trimmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|line
operator|.
name|isEmpty
argument_list|()
operator|&&
name|line
operator|.
name|right
argument_list|(
literal|1
argument_list|)
operator|==
literal|"\\"
condition|)
block|{
if|if
condition|(
operator|!
name|line
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
condition|)
block|{
name|line
operator|.
name|truncate
argument_list|(
name|line
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|+=
name|line
operator|+
name|Option
operator|::
name|field_sep
expr_stmt|;
operator|++
name|numLines
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|line
operator|.
name|isEmpty
argument_list|()
operator|||
operator|(
name|line
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|prelen
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
operator|&&
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
if|if
condition|(
operator|!
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|s
operator|+=
name|line
expr_stmt|;
operator|++
name|numLines
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ret
operator|=
name|parse
argument_list|(
name|s
argument_list|,
name|place
argument_list|,
name|numLines
argument_list|)
operator|)
condition|)
block|{
name|s
operator|=
literal|""
expr_stmt|;
name|numLines
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|s
operator|=
literal|""
expr_stmt|;
name|numLines
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|need_restart
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
name|ret
operator|=
name|parse
argument_list|(
name|s
argument_list|,
name|place
argument_list|,
name|numLines
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
name|bool
DECL|function|read
name|QMakeProject
operator|::
name|read
parameter_list|(
specifier|const
name|QString
modifier|&
name|file
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
name|parser_info
name|pi
init|=
name|parser
decl_stmt|;
name|reset
argument_list|()
expr_stmt|;
specifier|const
name|QString
name|oldpwd
init|=
name|qmake_getpwd
argument_list|()
decl_stmt|;
name|QString
name|filename
init|=
name|Option
operator|::
name|normalizePath
argument_list|(
name|file
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|bool
name|ret
init|=
literal|false
decl_stmt|,
name|using_stdin
init|=
literal|false
decl_stmt|;
name|QFile
name|qfile
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|QLatin1String
argument_list|(
literal|"-"
argument_list|)
condition|)
block|{
name|qfile
operator|.
name|setFileName
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|ret
operator|=
name|qfile
operator|.
name|open
argument_list|(
name|stdin
argument_list|,
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
name|using_stdin
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QFileInfo
argument_list|(
name|file
argument_list|)
operator|.
name|isDir
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|qfile
operator|.
name|setFileName
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|ret
operator|=
name|qfile
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
name|qmake_setpwd
argument_list|(
name|QFileInfo
argument_list|(
name|filename
argument_list|)
operator|.
name|absolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
name|parser_info
name|pi
init|=
name|parser
decl_stmt|;
name|parser
operator|.
name|from_file
operator|=
literal|true
expr_stmt|;
name|parser
operator|.
name|file
operator|=
name|filename
expr_stmt|;
name|parser
operator|.
name|line_no
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qfile
operator|.
name|peek
argument_list|(
literal|3
argument_list|)
operator|==
name|QByteArray
argument_list|(
literal|"\xef\xbb\xbf"
argument_list|)
condition|)
block|{
comment|//UTF-8 BOM will cause subtle errors
name|qmake_error_msg
argument_list|(
literal|"Unexpected UTF-8 BOM found"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|QTextStream
name|t
argument_list|(
operator|&
name|qfile
argument_list|)
decl_stmt|;
name|ret
operator|=
name|read
argument_list|(
name|t
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|using_stdin
condition|)
name|qfile
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|need_restart
operator|&&
name|scope_blocks
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|qmake_error_msg
argument_list|(
literal|"Unterminated conditional block at end of file"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|false
expr_stmt|;
block|}
name|parser
operator|=
name|pi
expr_stmt|;
name|qmake_setpwd
argument_list|(
name|oldpwd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
name|bool
DECL|function|read
name|QMakeProject
operator|::
name|read
parameter_list|(
specifier|const
name|QString
modifier|&
name|project
parameter_list|,
name|uchar
name|cmd
parameter_list|)
block|{
name|pfile
operator|=
name|QFileInfo
argument_list|(
name|project
argument_list|)
operator|.
name|absoluteFilePath
argument_list|()
expr_stmt|;
return|return
name|read
argument_list|(
name|cmd
argument_list|)
return|;
block|}
end_function
begin_function
name|bool
DECL|function|read
name|QMakeProject
operator|::
name|read
parameter_list|(
name|uchar
name|cmd
parameter_list|)
block|{
name|again
label|:
if|if
condition|(
operator|(
name|cmd
operator|&
name|ReadSetup
operator|)
operator|&&
name|base_vars
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// hack to get the Option stuff in there
name|base_vars
index|[
literal|"QMAKE_EXT_CPP"
index|]
operator|=
name|Option
operator|::
name|cpp_ext
expr_stmt|;
name|base_vars
index|[
literal|"QMAKE_EXT_C"
index|]
operator|=
name|Option
operator|::
name|c_ext
expr_stmt|;
name|base_vars
index|[
literal|"QMAKE_EXT_H"
index|]
operator|=
name|Option
operator|::
name|h_ext
expr_stmt|;
name|base_vars
index|[
literal|"QMAKE_SH"
index|]
operator|=
name|Option
operator|::
name|shellPath
expr_stmt|;
if|if
condition|(
operator|!
name|Option
operator|::
name|user_template_prefix
operator|.
name|isEmpty
argument_list|()
condition|)
name|base_vars
index|[
literal|"TEMPLATE_PREFIX"
index|]
operator|=
name|QStringList
argument_list|(
name|Option
operator|::
name|user_template_prefix
argument_list|)
expr_stmt|;
name|QString
name|superdir
decl_stmt|;
name|QString
name|project_root
decl_stmt|;
name|QString
name|project_build_root
decl_stmt|;
name|QStringList
name|qmakepath
decl_stmt|;
name|QStringList
name|qmakefeatures
decl_stmt|;
if|if
condition|(
name|Option
operator|::
name|mkfile
operator|::
name|do_cache
condition|)
block|{
comment|// parse the cache
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
name|cache
decl_stmt|;
name|QString
name|rdir
init|=
name|Option
operator|::
name|output_dir
decl_stmt|;
forever|forever
block|{
name|QFileInfo
name|qfi
argument_list|(
name|rdir
argument_list|,
name|QLatin1String
argument_list|(
literal|".qmake.super"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|qfi
operator|.
name|exists
argument_list|()
condition|)
block|{
name|superfile
operator|=
name|qfi
operator|.
name|filePath
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|read
argument_list|(
name|superfile
argument_list|,
name|cache
argument_list|)
condition|)
return|return
literal|false
return|;
name|superdir
operator|=
name|rdir
expr_stmt|;
break|break;
block|}
name|QFileInfo
name|qdfi
argument_list|(
name|rdir
argument_list|)
decl_stmt|;
if|if
condition|(
name|qdfi
operator|.
name|isRoot
argument_list|()
condition|)
break|break;
name|rdir
operator|=
name|qdfi
operator|.
name|path
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|Option
operator|::
name|mkfile
operator|::
name|cachefile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//find it as it has not been specified
name|QString
name|sdir
init|=
name|qmake_getpwd
argument_list|()
decl_stmt|;
name|QString
name|dir
init|=
name|Option
operator|::
name|output_dir
decl_stmt|;
forever|forever
block|{
name|QFileInfo
name|qsfi
argument_list|(
name|sdir
argument_list|,
name|QLatin1String
argument_list|(
literal|".qmake.conf"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|qsfi
operator|.
name|exists
argument_list|()
condition|)
block|{
name|conffile
operator|=
name|qsfi
operator|.
name|filePath
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|read
argument_list|(
name|conffile
argument_list|,
name|cache
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
name|QFileInfo
name|qfi
argument_list|(
name|dir
argument_list|,
name|QLatin1String
argument_list|(
literal|".qmake.cache"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|qfi
operator|.
name|exists
argument_list|()
condition|)
block|{
name|cachefile
operator|=
name|qfi
operator|.
name|filePath
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|read
argument_list|(
name|cachefile
argument_list|,
name|cache
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|conffile
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|cachefile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|project_root
operator|=
name|sdir
expr_stmt|;
name|project_build_root
operator|=
name|dir
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dir
operator|==
name|superdir
condition|)
goto|goto
name|no_cache
goto|;
name|QFileInfo
name|qsdfi
argument_list|(
name|sdir
argument_list|)
decl_stmt|;
name|QFileInfo
name|qdfi
argument_list|(
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|qsdfi
operator|.
name|isRoot
argument_list|()
operator|||
name|qdfi
operator|.
name|isRoot
argument_list|()
condition|)
goto|goto
name|no_cache
goto|;
name|sdir
operator|=
name|qsdfi
operator|.
name|path
argument_list|()
expr_stmt|;
name|dir
operator|=
name|qdfi
operator|.
name|path
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|QFileInfo
name|fi
argument_list|(
name|Option
operator|::
name|mkfile
operator|::
name|cachefile
argument_list|)
decl_stmt|;
name|cachefile
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|fi
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|read
argument_list|(
name|cachefile
argument_list|,
name|cache
argument_list|)
condition|)
return|return
literal|false
return|;
name|project_build_root
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|fi
operator|.
name|absolutePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// This intentionally bypasses finding a source root,
comment|// as the result would be more or less arbitrary.
block|}
if|if
condition|(
name|Option
operator|::
name|mkfile
operator|::
name|xqmakespec
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|cache
index|[
literal|"XQMAKESPEC"
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
name|Option
operator|::
name|mkfile
operator|::
name|xqmakespec
operator|=
name|cache
index|[
literal|"XQMAKESPEC"
index|]
operator|.
name|first
argument_list|()
expr_stmt|;
if|if
condition|(
name|Option
operator|::
name|mkfile
operator|::
name|qmakespec
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|cache
index|[
literal|"QMAKESPEC"
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Option
operator|::
name|mkfile
operator|::
name|qmakespec
operator|=
name|cache
index|[
literal|"QMAKESPEC"
index|]
operator|.
name|first
argument_list|()
expr_stmt|;
if|if
condition|(
name|Option
operator|::
name|mkfile
operator|::
name|xqmakespec
operator|.
name|isEmpty
argument_list|()
condition|)
name|Option
operator|::
name|mkfile
operator|::
name|xqmakespec
operator|=
name|Option
operator|::
name|mkfile
operator|::
name|qmakespec
expr_stmt|;
block|}
name|qmakepath
operator|=
name|cache
operator|.
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"QMAKEPATH"
argument_list|)
argument_list|)
expr_stmt|;
name|qmakefeatures
operator|=
name|cache
operator|.
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"QMAKEFEATURES"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Option
operator|::
name|output_dir
operator|.
name|startsWith
argument_list|(
name|project_build_root
argument_list|)
condition|)
name|Option
operator|::
name|mkfile
operator|::
name|cachefile_depth
operator|=
name|Option
operator|::
name|output_dir
operator|.
name|mid
argument_list|(
name|project_build_root
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|count
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|no_cache
label|:
comment|// Look for mkspecs/ in source and build. First to win determines the root.
name|QString
name|sdir
init|=
name|qmake_getpwd
argument_list|()
decl_stmt|;
name|QString
name|dir
init|=
name|Option
operator|::
name|output_dir
decl_stmt|;
while|while
condition|(
name|dir
operator|!=
name|project_build_root
condition|)
block|{
if|if
condition|(
operator|(
name|dir
operator|!=
name|sdir
operator|&&
name|QFileInfo
argument_list|(
name|sdir
argument_list|,
name|QLatin1String
argument_list|(
literal|"mkspecs"
argument_list|)
argument_list|)
operator|.
name|isDir
argument_list|()
operator|)
operator|||
name|QFileInfo
argument_list|(
name|dir
argument_list|,
name|QLatin1String
argument_list|(
literal|"mkspecs"
argument_list|)
argument_list|)
operator|.
name|isDir
argument_list|()
condition|)
block|{
if|if
condition|(
name|dir
operator|!=
name|sdir
condition|)
name|project_root
operator|=
name|sdir
expr_stmt|;
name|project_build_root
operator|=
name|dir
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dir
operator|==
name|superdir
condition|)
break|break;
name|QFileInfo
name|qsdfi
argument_list|(
name|sdir
argument_list|)
decl_stmt|;
name|QFileInfo
name|qdfi
argument_list|(
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|qsdfi
operator|.
name|isRoot
argument_list|()
operator|||
name|qdfi
operator|.
name|isRoot
argument_list|()
condition|)
break|break;
name|sdir
operator|=
name|qsdfi
operator|.
name|path
argument_list|()
expr_stmt|;
name|dir
operator|=
name|qdfi
operator|.
name|path
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|qmakepath
operator|!=
name|cached_qmakepath
operator|||
name|qmakefeatures
operator|!=
name|cached_qmakefeatures
operator|||
name|project_build_root
operator|!=
name|cached_build_root
condition|)
block|{
comment|// No need to check source dir, as it goes in sync
name|cached_source_root
operator|=
name|project_root
expr_stmt|;
name|cached_build_root
operator|=
name|project_build_root
expr_stmt|;
name|cached_qmakepath
operator|=
name|qmakepath
expr_stmt|;
name|cached_qmakefeatures
operator|=
name|qmakefeatures
expr_stmt|;
name|invalidateFeatureRoots
argument_list|()
expr_stmt|;
block|}
block|{
comment|// parse mkspec
name|QString
modifier|*
name|specp
init|=
name|host_build
condition|?
operator|&
name|Option
operator|::
name|mkfile
operator|::
name|qmakespec
else|:
operator|&
name|Option
operator|::
name|mkfile
operator|::
name|xqmakespec
decl_stmt|;
name|QString
name|qmakespec
init|=
operator|*
name|specp
decl_stmt|;
if|if
condition|(
name|qmakespec
operator|.
name|isEmpty
argument_list|()
condition|)
name|qmakespec
operator|=
name|host_build
condition|?
literal|"default-host"
else|:
literal|"default"
expr_stmt|;
if|if
condition|(
name|QDir
operator|::
name|isRelativePath
argument_list|(
name|qmakespec
argument_list|)
condition|)
block|{
name|QStringList
name|mkspec_roots
init|=
name|qmake_mkspec_paths
argument_list|()
decl_stmt|;
name|debug_msg
argument_list|(
literal|2
argument_list|,
literal|"Looking for mkspec %s in (%s)"
argument_list|,
name|qmakespec
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|mkspec_roots
operator|.
name|join
argument_list|(
literal|"::"
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|bool
name|found_mkspec
init|=
literal|false
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|ConstIterator
name|it
init|=
name|mkspec_roots
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|mkspec_roots
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QString
name|mkspec
init|=
operator|(
operator|*
name|it
operator|)
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|qmakespec
decl_stmt|;
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|mkspec
argument_list|)
condition|)
block|{
name|found_mkspec
operator|=
literal|true
expr_stmt|;
operator|*
name|specp
operator|=
name|qmakespec
operator|=
name|mkspec
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found_mkspec
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not find mkspecs for your QMAKESPEC(%s) after trying:\n\t%s\n"
argument_list|,
name|qmakespec
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|mkspec_roots
operator|.
name|join
argument_list|(
literal|"\n\t"
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// We do this before reading the spec, so it can use module and feature paths from
comment|// here without resorting to tricks. This is the only planned use case anyway.
if|if
condition|(
operator|!
name|superfile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Project super cache file: reading %s"
argument_list|,
name|superfile
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|superfile
argument_list|,
name|base_vars
argument_list|)
expr_stmt|;
block|}
comment|// parse qmake configuration
while|while
condition|(
name|qmakespec
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|qmakespec
operator|.
name|truncate
argument_list|(
name|qmakespec
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QString
name|spec
init|=
name|qmakespec
operator|+
name|QLatin1String
argument_list|(
literal|"/qmake.conf"
argument_list|)
decl_stmt|;
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"QMAKESPEC conf: reading %s"
argument_list|,
name|spec
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|read
argument_list|(
name|spec
argument_list|,
name|base_vars
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failure to read QMAKESPEC conf file %s.\n"
argument_list|,
name|spec
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|validateModes
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|conffile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Project config file: reading %s"
argument_list|,
name|conffile
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|conffile
argument_list|,
name|base_vars
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cachefile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"QMAKECACHE file: reading %s"
argument_list|,
name|cachefile
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|cachefile
argument_list|,
name|base_vars
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|vars
operator|=
name|base_vars
expr_stmt|;
comment|// start with the base
for|for
control|(
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|extra_vars
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|extra_vars
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|vars
operator|.
name|insert
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
name|ReadFeatures
condition|)
block|{
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Processing default_pre: %s"
argument_list|,
name|vars
index|[
literal|"CONFIG"
index|]
operator|.
name|join
argument_list|(
literal|"::"
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|doProjectInclude
argument_list|(
literal|"default_pre"
argument_list|,
name|IncludeFlagFeature
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
comment|//get a default
if|if
condition|(
name|pfile
operator|!=
literal|"-"
operator|&&
name|vars
index|[
literal|"TARGET"
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
name|vars
index|[
literal|"TARGET"
index|]
operator|.
name|append
argument_list|(
name|QFileInfo
argument_list|(
name|pfile
argument_list|)
operator|.
name|baseName
argument_list|()
argument_list|)
expr_stmt|;
comment|//before commandline
if|if
condition|(
name|cmd
operator|&
name|ReadSetup
condition|)
block|{
name|parser
operator|.
name|file
operator|=
literal|"(internal)"
expr_stmt|;
name|parser
operator|.
name|from_file
operator|=
literal|false
expr_stmt|;
name|parser
operator|.
name|line_no
operator|=
literal|1
expr_stmt|;
comment|//really arg count now.. duh
name|reset
argument_list|()
expr_stmt|;
for|for
control|(
name|QStringList
operator|::
name|ConstIterator
name|it
init|=
name|Option
operator|::
name|before_user_vars
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|Option
operator|::
name|before_user_vars
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|!
name|parse
argument_list|(
operator|(
operator|*
name|it
operator|)
argument_list|,
name|vars
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Argument failed to parse: %s\n"
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|parser
operator|.
name|line_no
operator|++
expr_stmt|;
block|}
block|}
comment|// After user configs, to override them
if|if
condition|(
operator|!
name|extra_configs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|parser
operator|.
name|file
operator|=
literal|"(extra configs)"
expr_stmt|;
name|parser
operator|.
name|from_file
operator|=
literal|false
expr_stmt|;
name|parser
operator|.
name|line_no
operator|=
literal|1
expr_stmt|;
comment|//really arg count now.. duh
name|parse
argument_list|(
literal|"CONFIG += "
operator|+
name|extra_configs
operator|.
name|join
argument_list|(
literal|" "
argument_list|)
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|&
name|ReadProFile
condition|)
block|{
comment|// parse project file
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Project file: reading %s"
argument_list|,
name|pfile
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|!=
literal|"-"
operator|&&
operator|!
name|QFile
operator|::
name|exists
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|pfile
operator|.
name|endsWith
argument_list|(
name|Option
operator|::
name|pro_ext
argument_list|)
condition|)
name|pfile
operator|+=
name|Option
operator|::
name|pro_ext
expr_stmt|;
if|if
condition|(
operator|!
name|read
argument_list|(
name|pfile
argument_list|,
name|vars
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|need_restart
condition|)
block|{
name|base_vars
operator|.
name|clear
argument_list|()
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
if|if
condition|(
name|cmd
operator|&
name|ReadSetup
condition|)
block|{
name|parser
operator|.
name|file
operator|=
literal|"(internal)"
expr_stmt|;
name|parser
operator|.
name|from_file
operator|=
literal|false
expr_stmt|;
name|parser
operator|.
name|line_no
operator|=
literal|1
expr_stmt|;
comment|//really arg count now.. duh
name|reset
argument_list|()
expr_stmt|;
for|for
control|(
name|QStringList
operator|::
name|ConstIterator
name|it
init|=
name|Option
operator|::
name|after_user_vars
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|Option
operator|::
name|after_user_vars
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|!
name|parse
argument_list|(
operator|(
operator|*
name|it
operator|)
argument_list|,
name|vars
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Argument failed to parse: %s\n"
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|parser
operator|.
name|line_no
operator|++
expr_stmt|;
block|}
block|}
comment|// Again, to ensure the project does not mess with us.
comment|// Specifically, do not allow a project to override debug/release within a
comment|// debug_and_release build pass - it's too late for that at this point anyway.
if|if
condition|(
operator|!
name|extra_configs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|parser
operator|.
name|file
operator|=
literal|"(extra configs)"
expr_stmt|;
name|parser
operator|.
name|from_file
operator|=
literal|false
expr_stmt|;
name|parser
operator|.
name|line_no
operator|=
literal|1
expr_stmt|;
comment|//really arg count now.. duh
name|parse
argument_list|(
literal|"CONFIG += "
operator|+
name|extra_configs
operator|.
name|join
argument_list|(
literal|" "
argument_list|)
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|&
name|ReadFeatures
condition|)
block|{
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Processing default_post: %s"
argument_list|,
name|vars
index|[
literal|"CONFIG"
index|]
operator|.
name|join
argument_list|(
literal|"::"
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|doProjectInclude
argument_list|(
literal|"default_post"
argument_list|,
name|IncludeFlagFeature
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|QHash
argument_list|<
name|QString
argument_list|,
name|bool
argument_list|>
name|processed
decl_stmt|;
specifier|const
name|QStringList
modifier|&
name|configs
init|=
name|vars
index|[
literal|"CONFIG"
index|]
decl_stmt|;
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Processing CONFIG features: %s"
argument_list|,
name|configs
operator|.
name|join
argument_list|(
literal|"::"
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|bool
name|finished
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|configs
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
specifier|const
name|QString
name|config
init|=
name|configs
index|[
name|i
index|]
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|processed
operator|.
name|contains
argument_list|(
name|config
argument_list|)
condition|)
block|{
name|processed
operator|.
name|insert
argument_list|(
name|config
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|doProjectInclude
argument_list|(
name|config
argument_list|,
name|IncludeFlagFeature
argument_list|,
name|vars
argument_list|)
operator|==
name|IncludeSuccess
condition|)
block|{
name|finished
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|finished
condition|)
break|break;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|validateModes
name|void
name|QMakeProject
operator|::
name|validateModes
parameter_list|()
block|{
if|if
condition|(
name|Option
operator|::
name|target_mode
operator|==
name|Option
operator|::
name|TARG_UNKNOWN_MODE
condition|)
block|{
name|Option
operator|::
name|TARG_MODE
name|target_mode
decl_stmt|;
specifier|const
name|QStringList
modifier|&
name|gen
init|=
name|base_vars
operator|.
name|value
argument_list|(
literal|"MAKEFILE_GENERATOR"
argument_list|)
decl_stmt|;
if|if
condition|(
name|gen
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: Using OS scope before setting MAKEFILE_GENERATOR\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MetaMakefileGenerator
operator|::
name|modeForGenerator
argument_list|(
name|gen
operator|.
name|first
argument_list|()
argument_list|,
operator|&
name|target_mode
argument_list|)
condition|)
block|{
specifier|const
name|QStringList
modifier|&
name|tgt
init|=
name|base_vars
operator|.
name|value
argument_list|(
literal|"TARGET_PLATFORM"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tgt
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|QString
modifier|&
name|os
init|=
name|tgt
operator|.
name|first
argument_list|()
decl_stmt|;
if|if
condition|(
name|os
operator|==
literal|"unix"
condition|)
name|Option
operator|::
name|target_mode
operator|=
name|Option
operator|::
name|TARG_UNIX_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|os
operator|==
literal|"macx"
condition|)
name|Option
operator|::
name|target_mode
operator|=
name|Option
operator|::
name|TARG_MACX_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|os
operator|==
literal|"win32"
condition|)
name|Option
operator|::
name|target_mode
operator|=
name|Option
operator|::
name|TARG_WIN_MODE
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown target platform specified: %s\n"
argument_list|,
name|os
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Option
operator|::
name|target_mode
operator|=
name|target_mode
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
name|void
DECL|function|resolveSpec
name|QMakeProject
operator|::
name|resolveSpec
parameter_list|(
name|QString
modifier|*
name|spec
parameter_list|,
specifier|const
name|QString
modifier|&
name|qmakespec
parameter_list|)
block|{
if|if
condition|(
name|spec
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|spec
operator|=
name|QFileInfo
argument_list|(
name|qmakespec
argument_list|)
operator|.
name|fileName
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|spec
operator|==
literal|"default"
operator|||
operator|*
name|spec
operator|==
literal|"default-host"
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|l
init|=
name|readlink
argument_list|(
name|qmakespec
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|buffer
argument_list|,
literal|1023
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|!=
operator|-
literal|1
condition|)
block|{
name|buffer
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|spec
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// We can't resolve symlinks as they do on Unix, so configure.exe puts the source of the
comment|// qmake.conf at the end of the default/qmake.conf in the QMAKESPEC_ORG variable.
specifier|const
name|QStringList
modifier|&
name|spec_org
init|=
name|base_vars
index|[
literal|"QMAKESPEC_ORIGINAL"
index|]
decl_stmt|;
if|if
condition|(
name|spec_org
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// try again the next time around
operator|*
name|spec
operator|=
name|QString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|*
name|spec
operator|=
name|spec_org
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|lastSlash
init|=
name|spec
operator|->
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastSlash
operator|!=
operator|-
literal|1
condition|)
name|spec
operator|->
name|remove
argument_list|(
literal|0
argument_list|,
name|lastSlash
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|bool
DECL|function|isActiveConfig
name|QMakeProject
operator|::
name|isActiveConfig
parameter_list|(
specifier|const
name|QString
modifier|&
name|x
parameter_list|,
name|bool
name|regex
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|*
name|place
parameter_list|)
block|{
if|if
condition|(
name|x
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
comment|//magic types for easy flipping
if|if
condition|(
name|x
operator|==
literal|"true"
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|x
operator|==
literal|"false"
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|x
operator|==
literal|"unix"
condition|)
block|{
name|validateModes
argument_list|()
expr_stmt|;
return|return
name|Option
operator|::
name|target_mode
operator|==
name|Option
operator|::
name|TARG_UNIX_MODE
operator|||
name|Option
operator|::
name|target_mode
operator|==
name|Option
operator|::
name|TARG_MACX_MODE
return|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|"macx"
operator|||
name|x
operator|==
literal|"mac"
condition|)
block|{
name|validateModes
argument_list|()
expr_stmt|;
return|return
name|Option
operator|::
name|target_mode
operator|==
name|Option
operator|::
name|TARG_MACX_MODE
return|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|"win32"
condition|)
block|{
name|validateModes
argument_list|()
expr_stmt|;
return|return
name|Option
operator|::
name|target_mode
operator|==
name|Option
operator|::
name|TARG_WIN_MODE
return|;
block|}
if|if
condition|(
name|x
operator|==
literal|"host_build"
condition|)
return|return
name|host_build
return|;
comment|//mkspecs
specifier|static
name|QString
name|hspec
decl_stmt|,
name|xspec
decl_stmt|;
name|resolveSpec
argument_list|(
operator|&
name|hspec
argument_list|,
name|Option
operator|::
name|mkfile
operator|::
name|qmakespec
argument_list|)
expr_stmt|;
name|resolveSpec
argument_list|(
operator|&
name|xspec
argument_list|,
name|Option
operator|::
name|mkfile
operator|::
name|xqmakespec
argument_list|)
expr_stmt|;
specifier|const
name|QString
modifier|&
name|spec
init|=
name|host_build
condition|?
name|hspec
else|:
name|xspec
decl_stmt|;
name|QRegExp
name|re
argument_list|(
name|x
argument_list|,
name|Qt
operator|::
name|CaseSensitive
argument_list|,
name|QRegExp
operator|::
name|Wildcard
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|regex
operator|&&
name|re
operator|.
name|exactMatch
argument_list|(
name|spec
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|regex
operator|&&
name|spec
operator|==
name|x
operator|)
condition|)
return|return
literal|true
return|;
comment|//simple matching
specifier|const
name|QStringList
modifier|&
name|configs
init|=
operator|(
name|place
condition|?
operator|(
operator|*
name|place
operator|)
index|[
literal|"CONFIG"
index|]
else|:
name|vars
index|[
literal|"CONFIG"
index|]
operator|)
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|ConstIterator
name|it
init|=
name|configs
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|configs
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|regex
operator|&&
name|re
operator|.
name|exactMatch
argument_list|(
operator|(
operator|*
name|it
operator|)
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|regex
operator|&&
operator|(
operator|*
name|it
operator|)
operator|==
name|x
operator|)
operator|)
operator|&&
name|re
operator|.
name|exactMatch
argument_list|(
operator|(
operator|*
name|it
operator|)
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
name|bool
DECL|function|doProjectTest
name|QMakeProject
operator|::
name|doProjectTest
parameter_list|(
name|QString
name|str
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
name|QString
name|chk
init|=
name|remove_quotes
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|chk
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
name|bool
name|invert_test
init|=
operator|(
name|chk
operator|.
name|left
argument_list|(
literal|1
argument_list|)
operator|==
literal|"!"
operator|)
decl_stmt|;
if|if
condition|(
name|invert_test
condition|)
name|chk
operator|=
name|chk
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bool
name|test
init|=
literal|false
decl_stmt|;
name|int
name|lparen
init|=
name|chk
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
decl_stmt|;
if|if
condition|(
name|lparen
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// if there is an lparen in the chk, it IS a function
name|int
name|rparen
init|=
name|chk
operator|.
name|indexOf
argument_list|(
literal|')'
argument_list|,
name|lparen
argument_list|)
decl_stmt|;
if|if
condition|(
name|rparen
operator|==
operator|-
literal|1
condition|)
block|{
name|qmake_error_msg
argument_list|(
literal|"Function missing right paren: "
operator|+
name|chk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|func
init|=
name|chk
operator|.
name|left
argument_list|(
name|lparen
argument_list|)
decl_stmt|;
name|test
operator|=
name|doProjectTest
argument_list|(
name|func
argument_list|,
name|chk
operator|.
name|mid
argument_list|(
name|lparen
operator|+
literal|1
argument_list|,
name|rparen
operator|-
name|lparen
operator|-
literal|1
argument_list|)
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|test
operator|=
name|isActiveConfig
argument_list|(
name|chk
argument_list|,
literal|true
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|invert_test
condition|)
return|return
operator|!
name|test
return|;
return|return
name|test
return|;
block|}
name|bool
DECL|function|doProjectTest
name|QMakeProject
operator|::
name|doProjectTest
parameter_list|(
name|QString
name|func
parameter_list|,
specifier|const
name|QString
modifier|&
name|params
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
return|return
name|doProjectTest
argument_list|(
name|func
argument_list|,
name|split_arg_list
argument_list|(
name|params
argument_list|)
argument_list|,
name|place
argument_list|)
return|;
block|}
name|QMakeProject
operator|::
name|IncludeStatus
DECL|function|doProjectInclude
name|QMakeProject
operator|::
name|doProjectInclude
parameter_list|(
name|QString
name|file
parameter_list|,
name|uchar
name|flags
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|IncludeFlagFeature
condition|)
block|{
if|if
condition|(
operator|!
name|file
operator|.
name|endsWith
argument_list|(
name|Option
operator|::
name|prf_ext
argument_list|)
condition|)
name|file
operator|+=
name|Option
operator|::
name|prf_ext
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|!
name|QFile
operator|::
name|exists
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|QStringList
modifier|*
modifier|&
name|feature_roots
init|=
name|all_feature_roots
index|[
name|host_build
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|feature_roots
condition|)
block|{
name|feature_roots
operator|=
operator|new
name|QStringList
expr_stmt|;
name|qmakeAddCacheClear
argument_list|(
name|qmakeDeleteCacheClear
argument_list|<
name|QStringList
argument_list|>
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|feature_roots
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|feature_roots
operator|->
name|isEmpty
argument_list|()
condition|)
operator|*
name|feature_roots
operator|=
name|qmake_feature_paths
argument_list|(
name|prop
argument_list|,
name|host_build
argument_list|)
expr_stmt|;
name|debug_msg
argument_list|(
literal|2
argument_list|,
literal|"Looking for feature '%s' in (%s)"
argument_list|,
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|feature_roots
operator|->
name|join
argument_list|(
literal|"::"
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|start_root
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|parser
operator|.
name|from_file
condition|)
block|{
name|QFileInfo
name|currFile
argument_list|(
name|parser
operator|.
name|file
argument_list|)
decl_stmt|,
name|prfFile
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|currFile
operator|.
name|fileName
argument_list|()
operator|==
name|prfFile
operator|.
name|fileName
argument_list|()
condition|)
block|{
name|currFile
operator|=
name|QFileInfo
argument_list|(
name|currFile
operator|.
name|canonicalFilePath
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|root
init|=
literal|0
init|;
name|root
operator|<
name|feature_roots
operator|->
name|size
argument_list|()
condition|;
operator|++
name|root
control|)
block|{
name|prfFile
operator|=
name|QFileInfo
argument_list|(
name|feature_roots
operator|->
name|at
argument_list|(
name|root
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|file
argument_list|)
operator|.
name|canonicalFilePath
argument_list|()
expr_stmt|;
if|if
condition|(
name|prfFile
operator|==
name|currFile
condition|)
block|{
name|start_root
operator|=
name|root
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
for|for
control|(
name|int
name|root
init|=
name|start_root
init|;
name|root
operator|<
name|feature_roots
operator|->
name|size
argument_list|()
condition|;
operator|++
name|root
control|)
block|{
name|QString
name|prf
argument_list|(
name|feature_roots
operator|->
name|at
argument_list|(
name|root
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|prf
argument_list|)
condition|)
block|{
name|file
operator|=
name|prf
expr_stmt|;
goto|goto
name|foundf
goto|;
block|}
block|}
return|return
name|IncludeNoExist
return|;
name|foundf
label|:
empty_stmt|;
block|}
if|if
condition|(
name|place
index|[
literal|"QMAKE_INTERNAL_INCLUDED_FEATURES"
index|]
operator|.
name|indexOf
argument_list|(
name|file
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|IncludeFeatureAlreadyLoaded
return|;
name|place
index|[
literal|"QMAKE_INTERNAL_INCLUDED_FEATURES"
index|]
operator|.
name|append
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QDir
operator|::
name|isRelativePath
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|QStringList
name|include_roots
decl_stmt|;
if|if
condition|(
name|Option
operator|::
name|output_dir
operator|!=
name|qmake_getpwd
argument_list|()
condition|)
name|include_roots
operator|<<
name|qmake_getpwd
argument_list|()
expr_stmt|;
name|include_roots
operator|<<
name|Option
operator|::
name|output_dir
expr_stmt|;
for|for
control|(
name|int
name|root
init|=
literal|0
init|;
name|root
operator|<
name|include_roots
operator|.
name|size
argument_list|()
condition|;
operator|++
name|root
control|)
block|{
name|QString
name|testName
init|=
name|QDir
operator|::
name|fromNativeSeparators
argument_list|(
name|include_roots
index|[
name|root
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|testName
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|testName
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|testName
operator|+=
name|file
expr_stmt|;
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|testName
argument_list|)
condition|)
block|{
name|file
operator|=
name|testName
expr_stmt|;
goto|goto
name|foundi
goto|;
block|}
block|}
return|return
name|IncludeNoExist
return|;
name|foundi
label|:
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|QFile
operator|::
name|exists
argument_list|(
name|file
argument_list|)
condition|)
block|{
return|return
name|IncludeNoExist
return|;
block|}
if|if
condition|(
name|Option
operator|::
name|mkfile
operator|::
name|do_preprocess
condition|)
comment|//nice to see this first..
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"#switching file %s(%s) - %s:%d\n"
argument_list|,
operator|(
name|flags
operator|&
name|IncludeFlagFeature
operator|)
condition|?
literal|"load"
else|:
literal|"include"
argument_list|,
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Project Parser: %s'ing file %s."
argument_list|,
operator|(
name|flags
operator|&
name|IncludeFlagFeature
operator|)
condition|?
literal|"load"
else|:
literal|"include"
argument_list|,
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|orig_file
init|=
name|file
decl_stmt|;
name|int
name|di
init|=
name|file
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|oldpwd
init|=
name|qmake_getpwd
argument_list|()
decl_stmt|;
if|if
condition|(
name|di
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|qmake_setpwd
argument_list|(
name|file
operator|.
name|left
argument_list|(
name|file
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot find directory: %s\n"
argument_list|,
name|file
operator|.
name|left
argument_list|(
name|di
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|IncludeFailure
return|;
block|}
block|}
name|bool
name|parsed
init|=
literal|false
decl_stmt|;
name|parser_info
name|pi
init|=
name|parser
decl_stmt|;
block|{
if|if
condition|(
name|flags
operator|&
operator|(
name|IncludeFlagNewProject
operator||
name|IncludeFlagNewParser
operator|)
condition|)
block|{
comment|// The "project's variables" are used in other places (eg. export()) so it's not
comment|// possible to use "place" everywhere. Instead just set variables and grab them later
name|QMakeProject
name|proj
argument_list|(
name|prop
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|IncludeFlagNewParser
condition|)
block|{
name|parsed
operator|=
name|proj
operator|.
name|read
argument_list|(
name|file
argument_list|,
name|proj
operator|.
name|variables
argument_list|()
argument_list|)
expr_stmt|;
comment|// parse just that file (fromfile, infile)
block|}
else|else
block|{
name|parsed
operator|=
name|proj
operator|.
name|read
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|// parse all aux files (load/include into)
block|}
name|place
operator|=
name|proj
operator|.
name|variables
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QStack
argument_list|<
name|ScopeBlock
argument_list|>
name|sc
init|=
name|scope_blocks
decl_stmt|;
name|IteratorBlock
modifier|*
name|it
init|=
name|iterator
decl_stmt|;
name|FunctionBlock
modifier|*
name|fu
init|=
name|function
decl_stmt|;
name|parsed
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|it
expr_stmt|;
name|function
operator|=
name|fu
expr_stmt|;
name|scope_blocks
operator|=
name|sc
expr_stmt|;
block|}
block|}
if|if
condition|(
name|parsed
condition|)
block|{
if|if
condition|(
name|place
index|[
literal|"QMAKE_INTERNAL_INCLUDED_FILES"
index|]
operator|.
name|indexOf
argument_list|(
name|orig_file
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|place
index|[
literal|"QMAKE_INTERNAL_INCLUDED_FILES"
index|]
operator|.
name|append
argument_list|(
name|orig_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warn_msg
argument_list|(
name|WarnParser
argument_list|,
literal|"%s:%d: Failure to include file %s."
argument_list|,
name|pi
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|pi
operator|.
name|line_no
argument_list|,
name|orig_file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|parser
operator|=
name|pi
expr_stmt|;
name|qmake_setpwd
argument_list|(
name|oldpwd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parsed
condition|)
return|return
name|IncludeParseFailure
return|;
return|return
name|IncludeSuccess
return|;
block|}
specifier|static
name|void
DECL|function|subAll
name|subAll
parameter_list|(
name|QStringList
modifier|*
name|val
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|diffval
parameter_list|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|dv
decl|,
name|diffval
control|)
name|val
operator|->
name|removeAll
argument_list|(
name|dv
argument_list|)
expr_stmt|;
block|}
specifier|inline
specifier|static
DECL|function|isSpecialChar
name|bool
name|isSpecialChar
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
comment|// Chars that should be quoted (TM). This includes:
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// - control chars& space
comment|// - the shell meta chars "&()<>^|
comment|// - the potential separators ,;=
specifier|static
specifier|const
name|uchar
name|iqm
index|[]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x45
block|,
literal|0x13
block|,
literal|0x00
block|,
literal|0x78
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x10
block|}
decl_stmt|;
else|#
directive|else
specifier|static
specifier|const
name|uchar
name|iqm
index|[]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xdf
block|,
literal|0x07
block|,
literal|0x00
block|,
literal|0xd8
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x38
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x78
block|}
decl_stmt|;
comment|// 0-32 \'"$`<>|;&(){}*?#!~[]
endif|#
directive|endif
return|return
operator|(
name|c
operator|<
sizeof|sizeof
argument_list|(
name|iqm
argument_list|)
operator|*
literal|8
operator|)
operator|&&
operator|(
name|iqm
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
return|;
block|}
specifier|inline
specifier|static
DECL|function|hasSpecialChars
name|bool
name|hasSpecialChars
parameter_list|(
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
block|{
for|for
control|(
name|int
name|x
init|=
name|arg
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
if|if
condition|(
name|isSpecialChar
argument_list|(
name|arg
operator|.
name|unicode
argument_list|()
index|[
name|x
index|]
operator|.
name|unicode
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
specifier|static
name|QString
DECL|function|shellQuote
name|shellQuote
parameter_list|(
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arg
operator|.
name|length
argument_list|()
condition|)
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"\"\""
argument_list|)
return|;
name|QString
name|ret
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasSpecialChars
argument_list|(
name|ret
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// Quotes are escaped and their preceding backslashes are doubled.
comment|// It's impossible to escape anything inside a quoted string on cmd
comment|// level, so the outer quoting must be "suspended".
name|ret
operator|.
name|replace
argument_list|(
name|QRegExp
argument_list|(
name|QLatin1String
argument_list|(
literal|"(\\\\*)\""
argument_list|)
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"\"\\1\\1\\^\"\""
argument_list|)
argument_list|)
expr_stmt|;
comment|// The argument must not end with a \ since this would be interpreted
comment|// as escaping the quote -- rather put the \ behind the quote: e.g.
comment|// rather use "foo"\ than "foo\"
name|int
name|i
init|=
name|ret
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|ret
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
condition|)
operator|--
name|i
expr_stmt|;
name|ret
operator|.
name|insert
argument_list|(
name|i
argument_list|,
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// Q_OS_WIN
name|ret
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"'\\''"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Q_OS_WIN
block|}
return|return
name|ret
return|;
block|}
specifier|static
name|QString
DECL|function|quoteValue
name|quoteValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|val
parameter_list|)
block|{
name|QString
name|ret
decl_stmt|;
name|ret
operator|.
name|reserve
argument_list|(
name|val
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|bool
name|quote
init|=
name|val
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|bool
name|escaping
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|l
init|=
name|val
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
name|QChar
name|c
init|=
name|val
operator|.
name|unicode
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|ushort
name|uc
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|uc
operator|<
literal|32
condition|)
block|{
if|if
condition|(
operator|!
name|escaping
condition|)
block|{
name|escaping
operator|=
literal|true
expr_stmt|;
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"$$escape_expand("
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|uc
condition|)
block|{
case|case
literal|'\r'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\\t"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"\\\\x%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|uc
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|escaping
condition|)
block|{
name|escaping
operator|=
literal|false
expr_stmt|;
name|ret
operator|+=
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|uc
condition|)
block|{
case|case
literal|'\\'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\$"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"$${LITERAL_HASH}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|quote
operator|=
literal|true
expr_stmt|;
comment|// fallthrough
default|default:
name|ret
operator|+=
name|c
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|escaping
condition|)
name|ret
operator|+=
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
condition|)
block|{
name|ret
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|static
name|bool
DECL|function|writeFile
name|writeFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|QIODevice
operator|::
name|OpenMode
name|mode
parameter_list|,
specifier|const
name|QString
modifier|&
name|contents
parameter_list|,
name|QString
modifier|*
name|errStr
parameter_list|)
block|{
name|QByteArray
name|bytes
init|=
name|contents
operator|.
name|toLocal8Bit
argument_list|()
decl_stmt|;
name|QFile
name|cfile
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|QIODevice
operator|::
name|Append
operator|)
operator|&&
name|cfile
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
operator||
name|QIODevice
operator|::
name|Text
argument_list|)
condition|)
block|{
if|if
condition|(
name|cfile
operator|.
name|readAll
argument_list|()
operator|==
name|bytes
condition|)
return|return
literal|true
return|;
name|cfile
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cfile
operator|.
name|open
argument_list|(
name|mode
operator||
name|QIODevice
operator|::
name|WriteOnly
operator||
name|QIODevice
operator|::
name|Text
argument_list|)
condition|)
block|{
operator|*
name|errStr
operator|=
name|cfile
operator|.
name|errorString
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|cfile
operator|.
name|write
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|cfile
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|cfile
operator|.
name|error
argument_list|()
operator|!=
name|QFile
operator|::
name|NoError
condition|)
block|{
operator|*
name|errStr
operator|=
name|cfile
operator|.
name|errorString
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|static
name|QByteArray
DECL|function|getCommandOutput
name|getCommandOutput
parameter_list|(
specifier|const
name|QString
modifier|&
name|args
parameter_list|)
block|{
name|QByteArray
name|out
decl_stmt|;
if|if
condition|(
name|FILE
modifier|*
name|proc
init|=
name|QT_POPEN
argument_list|(
name|args
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|feof
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|char
name|buff
index|[
literal|10
operator|*
literal|1024
index|]
decl_stmt|;
name|int
name|read_in
init|=
name|int
argument_list|(
name|fread
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|proc
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|read_in
condition|)
break|break;
name|out
operator|+=
name|QByteArray
argument_list|(
name|buff
argument_list|,
name|read_in
argument_list|)
expr_stmt|;
block|}
name|QT_PCLOSE
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
ifdef|#
directive|ifdef
name|Q_OS_WIN
DECL|function|windowsErrorCode
specifier|static
name|QString
name|windowsErrorCode
parameter_list|()
block|{
name|wchar_t
modifier|*
name|string
init|=
literal|0
decl_stmt|;
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_ALLOCATE_BUFFER
operator||
name|FORMAT_MESSAGE_FROM_SYSTEM
argument_list|,
name|NULL
argument_list|,
name|GetLastError
argument_list|()
argument_list|,
name|MAKELANGID
argument_list|(
name|LANG_NEUTRAL
argument_list|,
name|SUBLANG_DEFAULT
argument_list|)
argument_list|,
operator|(
name|LPWSTR
operator|)
operator|&
name|string
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|QString
name|ret
init|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|LocalFree
argument_list|(
operator|(
name|HLOCAL
operator|)
name|string
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
endif|#
directive|endif
name|QStringList
DECL|function|doProjectExpand
name|QMakeProject
operator|::
name|doProjectExpand
parameter_list|(
name|QString
name|func
parameter_list|,
specifier|const
name|QString
modifier|&
name|params
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
return|return
name|doProjectExpand
argument_list|(
name|func
argument_list|,
name|split_arg_list
argument_list|(
name|params
argument_list|)
argument_list|,
name|place
argument_list|)
return|;
block|}
name|QStringList
DECL|function|doProjectExpand
name|QMakeProject
operator|::
name|doProjectExpand
parameter_list|(
name|QString
name|func
parameter_list|,
name|QStringList
name|args
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
name|QList
argument_list|<
name|QStringList
argument_list|>
name|args_list
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QStringList
name|arg
init|=
name|split_value_list
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arg
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|tmp
operator|+=
name|doVariableReplaceExpand
argument_list|(
name|arg
index|[
name|i
index|]
argument_list|,
name|place
argument_list|)
expr_stmt|;
empty_stmt|;
name|args_list
operator|+=
name|tmp
expr_stmt|;
block|}
return|return
name|doProjectExpand
argument_list|(
name|func
argument_list|,
name|args_list
argument_list|,
name|place
argument_list|)
return|;
block|}
specifier|static
name|void
DECL|function|populateDeps
name|populateDeps
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|deps
parameter_list|,
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QSet
argument_list|<
name|QString
argument_list|>
argument_list|>
modifier|&
name|dependencies
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|dependees
parameter_list|,
name|QStringList
modifier|&
name|rootSet
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|item
decl|,
name|deps
control|)
if|if
condition|(
operator|!
name|dependencies
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|dset
init|=
name|dependencies
index|[
name|item
index|]
decl_stmt|;
comment|// Always create entry
name|QStringList
name|depends
init|=
name|place
operator|.
name|value
argument_list|(
name|prefix
operator|+
name|item
operator|+
literal|".depends"
argument_list|)
decl_stmt|;
if|if
condition|(
name|depends
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|rootSet
operator|<<
name|item
expr_stmt|;
block|}
else|else
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|dep
decl|,
name|depends
control|)
block|{
name|dset
operator|.
name|insert
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|dependees
index|[
name|dep
index|]
operator|<<
name|item
expr_stmt|;
block|}
name|populateDeps
argument_list|(
name|depends
argument_list|,
name|prefix
argument_list|,
name|dependencies
argument_list|,
name|dependees
argument_list|,
name|rootSet
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|QStringList
DECL|function|doProjectExpand
name|QMakeProject
operator|::
name|doProjectExpand
parameter_list|(
name|QString
name|func
parameter_list|,
name|QList
argument_list|<
name|QStringList
argument_list|>
name|args_list
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
name|func
operator|=
name|func
operator|.
name|trimmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|replaceFunctions
operator|.
name|contains
argument_list|(
name|func
argument_list|)
condition|)
block|{
name|FunctionBlock
modifier|*
name|defined
init|=
name|replaceFunctions
index|[
name|func
index|]
decl_stmt|;
name|function_blocks
operator|.
name|push
argument_list|(
name|defined
argument_list|)
expr_stmt|;
name|QStringList
name|ret
decl_stmt|;
name|defined
operator|->
name|exec
argument_list|(
name|args_list
argument_list|,
name|this
argument_list|,
name|place
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|bool
name|correct
init|=
name|function_blocks
operator|.
name|pop
argument_list|()
operator|==
name|defined
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|correct
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|correct
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|QStringList
name|args
decl_stmt|;
comment|//why don't the builtin functions just use args_list? --Sam
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args_list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|args
operator|+=
name|args_list
index|[
name|i
index|]
operator|.
name|join
argument_list|(
name|QString
argument_list|(
name|Option
operator|::
name|field_sep
argument_list|)
argument_list|)
expr_stmt|;
name|ExpandFunc
name|func_t
init|=
name|qmake_expandFunctions
argument_list|()
operator|.
name|value
argument_list|(
name|func
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|func_t
operator|&&
operator|(
name|func_t
operator|=
name|qmake_expandFunctions
argument_list|()
operator|.
name|value
argument_list|(
name|func
operator|.
name|toLower
argument_list|()
argument_list|)
operator|)
condition|)
name|warn_msg
argument_list|(
name|WarnDeprecated
argument_list|,
literal|"%s:%d: Using uppercased builtin functions is deprecated."
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Running project expand: %s(%s) [%d]"
argument_list|,
name|func
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|args
operator|.
name|join
argument_list|(
literal|"::"
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|func_t
argument_list|)
expr_stmt|;
name|QStringList
name|ret
decl_stmt|;
switch|switch
condition|(
name|func_t
condition|)
block|{
case|case
name|E_MEMBER
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: member(var, start, end) requires three arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|ok
init|=
literal|true
decl_stmt|;
specifier|const
name|QStringList
modifier|&
name|var
init|=
name|values
argument_list|(
name|args
operator|.
name|first
argument_list|()
argument_list|,
name|place
argument_list|)
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|,
name|end
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|QString
name|start_str
init|=
name|args
index|[
literal|1
index|]
decl_stmt|;
name|start
operator|=
name|start_str
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|2
condition|)
block|{
name|int
name|dotdot
init|=
name|start_str
operator|.
name|indexOf
argument_list|(
literal|".."
argument_list|)
decl_stmt|;
if|if
condition|(
name|dotdot
operator|!=
operator|-
literal|1
condition|)
block|{
name|start
operator|=
name|start_str
operator|.
name|left
argument_list|(
name|dotdot
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
name|end
operator|=
name|start_str
operator|.
name|mid
argument_list|(
name|dotdot
operator|+
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: member() argument 2 (start) '%s' invalid.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|start_str
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|end
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|3
condition|)
name|end
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: member() argument 3 (end) '%s' invalid.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|args
index|[
literal|2
index|]
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|+=
name|var
operator|.
name|count
argument_list|()
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|+=
name|var
operator|.
name|count
argument_list|()
expr_stmt|;
if|if
condition|(
name|start
operator|<
literal|0
operator|||
name|start
operator|>=
name|var
operator|.
name|count
argument_list|()
operator|||
name|end
operator|<
literal|0
operator|||
name|end
operator|>=
name|var
operator|.
name|count
argument_list|()
condition|)
block|{
comment|//nothing
block|}
elseif|else
if|if
condition|(
name|start
operator|<
name|end
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<=
name|end
operator|&&
operator|(
name|int
operator|)
name|var
operator|.
name|count
argument_list|()
operator|>=
name|i
condition|;
name|i
operator|++
control|)
name|ret
operator|+=
name|var
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|>=
name|end
operator|&&
operator|(
name|int
operator|)
name|var
operator|.
name|count
argument_list|()
operator|>=
name|i
operator|&&
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|ret
operator|+=
name|var
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
case|case
name|E_FIRST
case|:
case|case
name|E_LAST
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: %s(var) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|func
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QStringList
modifier|&
name|var
init|=
name|values
argument_list|(
name|args
operator|.
name|first
argument_list|()
argument_list|,
name|place
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|var
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|func_t
operator|==
name|E_FIRST
condition|)
name|ret
operator|=
name|QStringList
argument_list|(
name|var
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|QStringList
argument_list|(
name|var
index|[
name|var
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|E_CAT
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: cat(file) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|file
init|=
name|Option
operator|::
name|normalizePath
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bool
name|blob
init|=
literal|false
decl_stmt|;
name|bool
name|lines
init|=
literal|false
decl_stmt|;
name|bool
name|singleLine
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"false"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|singleLine
operator|=
literal|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"blob"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|blob
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"lines"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|lines
operator|=
literal|true
expr_stmt|;
block|}
name|QFile
name|qfile
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|qfile
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|QTextStream
name|stream
argument_list|(
operator|&
name|qfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|blob
condition|)
block|{
name|ret
operator|+=
name|stream
operator|.
name|readAll
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|!
name|stream
operator|.
name|atEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|lines
condition|)
block|{
name|ret
operator|+=
name|stream
operator|.
name|readLine
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|+=
name|split_value_list
argument_list|(
name|stream
operator|.
name|readLine
argument_list|()
operator|.
name|trimmed
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|singleLine
condition|)
name|ret
operator|+=
literal|"\n"
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
break|break;
block|}
case|case
name|E_FROMFILE
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: fromfile(file, variable) requires two arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|seek_var
init|=
name|args
index|[
literal|1
index|]
decl_stmt|,
name|file
init|=
name|Option
operator|::
name|normalizePath
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
name|tmp
decl_stmt|;
if|if
condition|(
name|doProjectInclude
argument_list|(
name|file
argument_list|,
name|IncludeFlagNewParser
argument_list|,
name|tmp
argument_list|)
operator|==
name|IncludeSuccess
condition|)
block|{
if|if
condition|(
name|tmp
operator|.
name|contains
argument_list|(
literal|"QMAKE_INTERNAL_INCLUDED_FILES"
argument_list|)
condition|)
block|{
name|QStringList
modifier|&
name|out
init|=
name|place
index|[
literal|"QMAKE_INTERNAL_INCLUDED_FILES"
index|]
decl_stmt|;
specifier|const
name|QStringList
modifier|&
name|in
init|=
name|tmp
index|[
literal|"QMAKE_INTERNAL_INCLUDED_FILES"
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|in
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|out
operator|.
name|indexOf
argument_list|(
name|in
index|[
name|i
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|out
operator|+=
name|in
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|tmp
index|[
name|seek_var
index|]
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|E_EVAL
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: eval(variable) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|*
name|source
init|=
operator|&
name|place
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
literal|"Global"
condition|)
block|{
name|source
operator|=
operator|&
name|vars
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
literal|"Local"
condition|)
block|{
name|source
operator|=
operator|&
name|place
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: unexpected source to eval.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|+=
name|source
operator|->
name|value
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|E_LIST
case|:
block|{
specifier|static
name|int
name|x
init|=
literal|0
decl_stmt|;
name|QString
name|tmp
decl_stmt|;
name|tmp
operator|.
name|sprintf
argument_list|(
literal|".QMAKE_INTERNAL_TMP_VAR_%d"
argument_list|,
name|x
operator|++
argument_list|)
expr_stmt|;
name|ret
operator|=
name|QStringList
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|QStringList
modifier|&
name|lst
init|=
operator|(
operator|*
operator|(
operator|(
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
operator|*
operator|)
operator|&
name|place
operator|)
operator|)
index|[
name|tmp
index|]
decl_stmt|;
name|lst
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|QStringList
operator|::
name|ConstIterator
name|arg_it
init|=
name|args
operator|.
name|begin
argument_list|()
init|;
name|arg_it
operator|!=
name|args
operator|.
name|end
argument_list|()
condition|;
operator|++
name|arg_it
control|)
name|lst
operator|+=
name|split_value_list
argument_list|(
operator|(
operator|*
name|arg_it
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|E_SPRINTF
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: sprintf(format, ...) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|tmp
init|=
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|args
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|tmp
operator|=
name|tmp
operator|.
name|arg
argument_list|(
name|args
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|split_value_list
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|E_FORMAT_NUMBER
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: format_number(number[, options...]) requires one or two arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|ibase
init|=
literal|10
decl_stmt|;
name|int
name|obase
init|=
literal|10
decl_stmt|;
name|int
name|width
init|=
literal|0
decl_stmt|;
name|bool
name|zeropad
init|=
literal|false
decl_stmt|;
name|bool
name|leftalign
init|=
literal|false
decl_stmt|;
enum|enum
block|{
name|DefaultSign
block|,
name|PadSign
block|,
name|AlwaysSign
block|}
name|sign
init|=
name|DefaultSign
enum|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|2
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|opt
decl|,
name|split_value_list
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|opt
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"ibase="
argument_list|)
argument_list|)
condition|)
block|{
name|ibase
operator|=
name|opt
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"obase="
argument_list|)
argument_list|)
condition|)
block|{
name|obase
operator|=
name|opt
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"width="
argument_list|)
argument_list|)
condition|)
block|{
name|width
operator|=
name|opt
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|==
name|QLatin1String
argument_list|(
literal|"zeropad"
argument_list|)
condition|)
block|{
name|zeropad
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|==
name|QLatin1String
argument_list|(
literal|"padsign"
argument_list|)
condition|)
block|{
name|sign
operator|=
name|PadSign
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|==
name|QLatin1String
argument_list|(
literal|"alwayssign"
argument_list|)
condition|)
block|{
name|sign
operator|=
name|AlwaysSign
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|==
name|QLatin1String
argument_list|(
literal|"leftalign"
argument_list|)
condition|)
block|{
name|leftalign
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: format_number(): invalid format option %s.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|opt
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|formfail
goto|;
block|}
block|}
block|}
if|if
condition|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: format_number(): floats are currently not supported.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
break|break;
block|}
name|bool
name|ok
decl_stmt|;
name|qlonglong
name|num
init|=
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toLongLong
argument_list|(
operator|&
name|ok
argument_list|,
name|ibase
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: format_number(): malformed number %s for base %d.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|ibase
argument_list|)
expr_stmt|;
break|break;
block|}
name|QString
name|outstr
decl_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
block|{
name|num
operator|=
operator|-
name|num
expr_stmt|;
name|outstr
operator|=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sign
operator|==
name|AlwaysSign
condition|)
block|{
name|outstr
operator|=
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sign
operator|==
name|PadSign
condition|)
block|{
name|outstr
operator|=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|QString
name|numstr
init|=
name|QString
operator|::
name|number
argument_list|(
name|num
argument_list|,
name|obase
argument_list|)
decl_stmt|;
name|int
name|space
init|=
name|width
operator|-
name|outstr
operator|.
name|length
argument_list|()
operator|-
name|numstr
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|space
operator|<=
literal|0
condition|)
block|{
name|outstr
operator|+=
name|numstr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leftalign
condition|)
block|{
name|outstr
operator|+=
name|numstr
operator|+
name|QString
argument_list|(
name|space
argument_list|,
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zeropad
condition|)
block|{
name|outstr
operator|+=
name|QString
argument_list|(
name|space
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|+
name|numstr
expr_stmt|;
block|}
else|else
block|{
name|outstr
operator|.
name|prepend
argument_list|(
name|QString
argument_list|(
name|space
argument_list|,
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|outstr
operator|+=
name|numstr
expr_stmt|;
block|}
name|ret
operator|+=
name|outstr
expr_stmt|;
block|}
name|formfail
label|:
break|break;
case|case
name|E_JOIN
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|4
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: join(var, glue, before, after) requires four"
literal|"arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|glue
decl_stmt|,
name|before
decl_stmt|,
name|after
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|2
condition|)
name|glue
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|3
condition|)
name|before
operator|=
name|args
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|4
condition|)
name|after
operator|=
name|args
index|[
literal|3
index|]
expr_stmt|;
specifier|const
name|QStringList
modifier|&
name|var
init|=
name|values
argument_list|(
name|args
operator|.
name|first
argument_list|()
argument_list|,
name|place
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|var
operator|.
name|isEmpty
argument_list|()
condition|)
name|ret
operator|=
name|split_value_list
argument_list|(
name|before
operator|+
name|var
operator|.
name|join
argument_list|(
name|glue
argument_list|)
operator|+
name|after
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|E_SPLIT
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d split(var, sep) requires one or two arguments\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|sep
init|=
name|QString
argument_list|(
name|Option
operator|::
name|field_sep
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|2
condition|)
name|sep
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|QStringList
name|var
init|=
name|values
argument_list|(
name|args
operator|.
name|first
argument_list|()
argument_list|,
name|place
argument_list|)
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|ConstIterator
name|vit
init|=
name|var
operator|.
name|begin
argument_list|()
init|;
name|vit
operator|!=
name|var
operator|.
name|end
argument_list|()
condition|;
operator|++
name|vit
control|)
block|{
name|QStringList
name|lst
init|=
operator|(
operator|*
name|vit
operator|)
operator|.
name|split
argument_list|(
name|sep
argument_list|)
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|ConstIterator
name|spltit
init|=
name|lst
operator|.
name|begin
argument_list|()
init|;
name|spltit
operator|!=
name|lst
operator|.
name|end
argument_list|()
condition|;
operator|++
name|spltit
control|)
name|ret
operator|+=
operator|(
operator|*
name|spltit
operator|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|E_BASENAME
case|:
case|case
name|E_DIRNAME
case|:
case|case
name|E_SECTION
case|:
block|{
name|bool
name|regexp
init|=
literal|false
decl_stmt|;
name|QString
name|sep
decl_stmt|,
name|var
decl_stmt|;
name|int
name|beg
init|=
literal|0
decl_stmt|,
name|end
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|func_t
operator|==
name|E_SECTION
condition|)
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|3
operator|&&
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|4
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d section(var, sep, begin, end) requires three argument\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|var
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|sep
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|beg
operator|=
name|args
index|[
literal|2
index|]
operator|.
name|toInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|4
condition|)
name|end
operator|=
name|args
index|[
literal|3
index|]
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d %s(var) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|func
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|var
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|regexp
operator|=
literal|true
expr_stmt|;
name|sep
operator|=
literal|"["
operator|+
name|QRegExp
operator|::
name|escape
argument_list|(
name|Option
operator|::
name|dir_sep
argument_list|)
operator|+
literal|"/]"
expr_stmt|;
if|if
condition|(
name|func_t
operator|==
name|E_DIRNAME
condition|)
name|end
operator|=
operator|-
literal|2
expr_stmt|;
else|else
name|beg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|var
operator|.
name|isNull
argument_list|()
condition|)
block|{
specifier|const
name|QStringList
modifier|&
name|l
init|=
name|values
argument_list|(
name|var
argument_list|,
name|place
argument_list|)
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|ConstIterator
name|it
init|=
name|l
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|l
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QString
name|separator
init|=
name|sep
decl_stmt|;
if|if
condition|(
name|regexp
condition|)
name|ret
operator|+=
operator|(
operator|*
name|it
operator|)
operator|.
name|section
argument_list|(
name|QRegExp
argument_list|(
name|separator
argument_list|)
argument_list|,
name|beg
argument_list|,
name|end
argument_list|)
expr_stmt|;
else|else
name|ret
operator|+=
operator|(
operator|*
name|it
operator|)
operator|.
name|section
argument_list|(
name|separator
argument_list|,
name|beg
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|E_FIND
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d find(var, str) requires two arguments\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QRegExp
name|regx
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QStringList
modifier|&
name|var
init|=
name|values
argument_list|(
name|args
operator|.
name|first
argument_list|()
argument_list|,
name|place
argument_list|)
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|ConstIterator
name|vit
init|=
name|var
operator|.
name|begin
argument_list|()
init|;
name|vit
operator|!=
name|var
operator|.
name|end
argument_list|()
condition|;
operator|++
name|vit
control|)
block|{
if|if
condition|(
name|regx
operator|.
name|indexIn
argument_list|(
operator|*
name|vit
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|ret
operator|+=
operator|(
operator|*
name|vit
operator|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|E_SYSTEM
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d system(execut) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|blob
init|=
literal|false
decl_stmt|;
name|bool
name|lines
init|=
literal|false
decl_stmt|;
name|bool
name|singleLine
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"false"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|singleLine
operator|=
literal|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"blob"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|blob
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"lines"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|lines
operator|=
literal|true
expr_stmt|;
block|}
name|QByteArray
name|bytes
init|=
name|getCommandOutput
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lines
condition|)
block|{
name|QTextStream
name|stream
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|stream
operator|.
name|atEnd
argument_list|()
condition|)
name|ret
operator|+=
name|stream
operator|.
name|readLine
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QString
name|output
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|blob
condition|)
block|{
name|ret
operator|+=
name|output
expr_stmt|;
block|}
else|else
block|{
name|output
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\t'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|singleLine
condition|)
name|output
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|split_value_list
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
case|case
name|E_UNIQUE
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d unique(var) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QStringList
modifier|&
name|var
init|=
name|values
argument_list|(
name|args
operator|.
name|first
argument_list|()
argument_list|,
name|place
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|var
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ret
operator|.
name|contains
argument_list|(
name|var
index|[
name|i
index|]
argument_list|)
condition|)
name|ret
operator|.
name|append
argument_list|(
name|var
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|E_REVERSE
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d reverse(var) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QStringList
name|var
init|=
name|values
argument_list|(
name|args
operator|.
name|first
argument_list|()
argument_list|,
name|place
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|var
operator|.
name|size
argument_list|()
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|var
operator|.
name|swap
argument_list|(
name|i
argument_list|,
name|var
operator|.
name|size
argument_list|()
operator|-
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|var
expr_stmt|;
block|}
break|break;
case|case
name|E_QUOTE
case|:
name|ret
operator|=
name|args
expr_stmt|;
break|break;
case|case
name|E_ESCAPE_EXPAND
case|:
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QChar
modifier|*
name|i_data
init|=
name|args
index|[
name|i
index|]
operator|.
name|data
argument_list|()
decl_stmt|;
name|int
name|i_len
init|=
name|args
index|[
name|i
index|]
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|i_len
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|i_data
operator|+
name|x
operator|)
operator|==
literal|'\\'
operator|&&
name|x
operator|<
name|i_len
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|i_data
operator|+
name|x
operator|+
literal|1
operator|)
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|x
expr_stmt|;
block|}
else|else
block|{
struct|struct
block|{
name|char
name|in
decl_stmt|,
name|out
decl_stmt|;
block|}
name|mapped_quotes
index|[]
init|=
block|{
block|{
literal|'n'
block|,
literal|'\n'
block|}
block|,
block|{
literal|'t'
block|,
literal|'\t'
block|}
block|,
block|{
literal|'r'
block|,
literal|'\r'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|mapped_quotes
index|[
name|i
index|]
operator|.
name|in
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|i_data
operator|+
name|x
operator|+
literal|1
operator|)
operator|==
name|mapped_quotes
index|[
name|i
index|]
operator|.
name|in
condition|)
block|{
operator|*
operator|(
name|i_data
operator|+
name|x
operator|)
operator|=
name|mapped_quotes
index|[
name|i
index|]
operator|.
name|out
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|i_len
operator|-
literal|2
condition|)
name|memmove
argument_list|(
name|i_data
operator|+
name|x
operator|+
literal|1
argument_list|,
name|i_data
operator|+
name|x
operator|+
literal|2
argument_list|,
operator|(
name|i_len
operator|-
name|x
operator|-
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|i_len
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
name|ret
operator|.
name|append
argument_list|(
name|QString
argument_list|(
name|i_data
argument_list|,
name|i_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|E_RE_ESCAPE
case|:
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|ret
operator|+=
name|QRegExp
operator|::
name|escape
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|E_VAL_ESCAPE
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d val_escape(var) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QStringList
name|vals
init|=
name|values
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|,
name|place
argument_list|)
decl_stmt|;
name|ret
operator|.
name|reserve
argument_list|(
name|vals
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|str
decl|,
name|vals
control|)
name|ret
operator|+=
name|quoteValue
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|E_UPPER
case|:
case|case
name|E_LOWER
case|:
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|func_t
operator|==
name|E_UPPER
condition|)
name|ret
operator|+=
name|args
index|[
name|i
index|]
operator|.
name|toUpper
argument_list|()
expr_stmt|;
else|else
name|ret
operator|+=
name|args
index|[
name|i
index|]
operator|.
name|toLower
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
name|E_FILES
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
operator|&&
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d files(pattern) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|recursive
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|2
condition|)
name|recursive
operator|=
operator|(
name|args
index|[
literal|1
index|]
operator|.
name|toLower
argument_list|()
operator|==
literal|"true"
operator|||
name|args
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|()
operator|)
expr_stmt|;
name|QStringList
name|dirs
decl_stmt|;
name|QString
name|r
init|=
name|Option
operator|::
name|normalizePath
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|slash
init|=
name|r
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|slash
operator|!=
operator|-
literal|1
condition|)
block|{
name|dirs
operator|.
name|append
argument_list|(
name|r
operator|.
name|left
argument_list|(
name|slash
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|r
operator|.
name|mid
argument_list|(
name|slash
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dirs
operator|.
name|append
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|QRegExp
name|regex
argument_list|(
name|r
argument_list|,
name|Qt
operator|::
name|CaseSensitive
argument_list|,
name|QRegExp
operator|::
name|Wildcard
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|dirs
operator|.
name|count
argument_list|()
condition|;
name|d
operator|++
control|)
block|{
name|QString
name|dir
init|=
name|dirs
index|[
name|d
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|dir
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|dir
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|dir
operator|+=
literal|"/"
expr_stmt|;
name|QDir
name|qdir
argument_list|(
name|dir
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|qdir
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|qdir
index|[
name|i
index|]
operator|==
literal|"."
operator|||
name|qdir
index|[
name|i
index|]
operator|==
literal|".."
condition|)
continue|continue;
name|QString
name|fname
init|=
name|dir
operator|+
name|qdir
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|QFileInfo
argument_list|(
name|fname
argument_list|)
operator|.
name|isDir
argument_list|()
condition|)
block|{
if|if
condition|(
name|recursive
condition|)
name|dirs
operator|.
name|append
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regex
operator|.
name|exactMatch
argument_list|(
name|qdir
index|[
name|i
index|]
argument_list|)
condition|)
name|ret
operator|+=
name|fname
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
case|case
name|E_PROMPT
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d prompt(question) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pfile
operator|==
literal|"-"
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d prompt(question) cannot be used when '-o -' is used.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|msg
init|=
name|fixEnvVariables
argument_list|(
name|args
operator|.
name|first
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|msg
operator|.
name|endsWith
argument_list|(
literal|"?"
argument_list|)
condition|)
name|msg
operator|+=
literal|"?"
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Project %s: %s "
argument_list|,
name|func
operator|.
name|toUpper
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|msg
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|QFile
name|qfile
decl_stmt|;
if|if
condition|(
name|qfile
operator|.
name|open
argument_list|(
name|stdin
argument_list|,
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|QTextStream
name|t
argument_list|(
operator|&
name|qfile
argument_list|)
decl_stmt|;
name|ret
operator|=
name|split_value_list
argument_list|(
name|t
operator|.
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|E_REPLACE
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d replace(var, before, after) requires three arguments\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QRegExp
name|before
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|after
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|QStringList
name|var
init|=
name|values
argument_list|(
name|args
operator|.
name|first
argument_list|()
argument_list|,
name|place
argument_list|)
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|Iterator
name|it
init|=
name|var
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|var
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
name|ret
operator|+=
name|it
operator|->
name|replace
argument_list|(
name|before
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|E_SIZE
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: size(var) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|size
init|=
name|values
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
name|ret
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|E_SORT_DEPENDS
case|:
case|case
name|E_RESOLVE_DEPENDS
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: %s(var, prefix) requires one or two arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|func
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QHash
argument_list|<
name|QString
argument_list|,
name|QSet
argument_list|<
name|QString
argument_list|>
argument_list|>
name|dependencies
decl_stmt|;
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
name|dependees
decl_stmt|;
name|QStringList
name|rootSet
decl_stmt|;
name|QStringList
name|orgList
init|=
name|values
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
decl_stmt|;
name|populateDeps
argument_list|(
name|orgList
argument_list|,
operator|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|?
name|QString
argument_list|()
else|:
name|args
index|[
literal|1
index|]
operator|)
argument_list|,
name|dependencies
argument_list|,
name|dependees
argument_list|,
name|rootSet
argument_list|,
name|place
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rootSet
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
modifier|&
name|item
init|=
name|rootSet
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|func_t
operator|==
name|E_RESOLVE_DEPENDS
operator|)
operator|||
name|orgList
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
name|ret
operator|.
name|prepend
argument_list|(
name|item
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|dep
decl|,
name|dependees
index|[
name|item
index|]
control|)
block|{
name|QSet
argument_list|<
name|QString
argument_list|>
modifier|&
name|dset
init|=
name|dependencies
index|[
name|dep
index|]
decl_stmt|;
name|dset
operator|.
name|remove
argument_list|(
name|rootSet
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// *Don't* use 'item' - rootSet may have changed!
if|if
condition|(
name|dset
operator|.
name|isEmpty
argument_list|()
condition|)
name|rootSet
operator|<<
name|dep
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
case|case
name|E_ENUMERATE_VARS
case|:
name|ret
operator|+=
name|place
operator|.
name|keys
argument_list|()
expr_stmt|;
break|break;
case|case
name|E_SHADOWED
case|:
block|{
name|QString
name|val
init|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|QFileInfo
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Option
operator|::
name|mkfile
operator|::
name|source_root
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ret
operator|+=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|.
name|startsWith
argument_list|(
name|Option
operator|::
name|mkfile
operator|::
name|source_root
argument_list|)
operator|&&
operator|(
name|val
operator|.
name|length
argument_list|()
operator|==
name|Option
operator|::
name|mkfile
operator|::
name|source_root
operator|.
name|length
argument_list|()
operator|||
name|val
operator|.
name|at
argument_list|(
name|Option
operator|::
name|mkfile
operator|::
name|source_root
operator|.
name|length
argument_list|()
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|)
condition|)
block|{
name|ret
operator|+=
name|Option
operator|::
name|mkfile
operator|::
name|build_root
operator|+
name|val
operator|.
name|mid
argument_list|(
name|Option
operator|::
name|mkfile
operator|::
name|source_root
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|E_ABSOLUTE_PATH
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d absolute_path(path[, base]) requires one or two arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
else|else
name|ret
operator|+=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|QDir
argument_list|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|?
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
else|:
name|QString
argument_list|()
argument_list|)
operator|.
name|absoluteFilePath
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_RELATIVE_PATH
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d relative_path(path[, base]) requires one or two arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
else|else
name|ret
operator|+=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|QDir
argument_list|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|?
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
else|:
name|QString
argument_list|()
argument_list|)
operator|.
name|relativeFilePath
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_CLEAN_PATH
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d clean_path(path) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
else|else
name|ret
operator|+=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_NATIVE_PATH
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d native_path(path) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
else|else
name|ret
operator|+=
name|Option
operator|::
name|fixPathToTargetOS
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_SHELL_QUOTE
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d shell_quote(args) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
else|else
name|ret
operator|+=
name|shellQuote
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: Unknown replace function: %s\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|func
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|ret
return|;
block|}
name|bool
DECL|function|doProjectTest
name|QMakeProject
operator|::
name|doProjectTest
parameter_list|(
name|QString
name|func
parameter_list|,
name|QStringList
name|args
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
name|QList
argument_list|<
name|QStringList
argument_list|>
name|args_list
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QStringList
name|arg
init|=
name|split_value_list
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arg
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|tmp
operator|+=
name|doVariableReplaceExpand
argument_list|(
name|arg
index|[
name|i
index|]
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|args_list
operator|+=
name|tmp
expr_stmt|;
block|}
return|return
name|doProjectTest
argument_list|(
name|func
argument_list|,
name|args_list
argument_list|,
name|place
argument_list|)
return|;
block|}
name|bool
DECL|function|doProjectTest
name|QMakeProject
operator|::
name|doProjectTest
parameter_list|(
name|QString
name|func
parameter_list|,
name|QList
argument_list|<
name|QStringList
argument_list|>
name|args_list
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
name|func
operator|=
name|func
operator|.
name|trimmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|testFunctions
operator|.
name|contains
argument_list|(
name|func
argument_list|)
condition|)
block|{
name|FunctionBlock
modifier|*
name|defined
init|=
name|testFunctions
index|[
name|func
index|]
decl_stmt|;
name|QStringList
name|ret
decl_stmt|;
name|function_blocks
operator|.
name|push
argument_list|(
name|defined
argument_list|)
expr_stmt|;
name|defined
operator|->
name|exec
argument_list|(
name|args_list
argument_list|,
name|this
argument_list|,
name|place
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|bool
name|correct
init|=
name|function_blocks
operator|.
name|pop
argument_list|()
operator|==
name|defined
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|correct
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|correct
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|ret
operator|.
name|first
argument_list|()
operator|==
literal|"true"
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|.
name|first
argument_list|()
operator|==
literal|"false"
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|bool
name|ok
decl_stmt|;
name|int
name|val
init|=
name|ret
operator|.
name|first
argument_list|()
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
return|return
name|val
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d Unexpected return value from test %s [%s].\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|func
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|ret
operator|.
name|join
argument_list|(
literal|"::"
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
name|QStringList
name|args
decl_stmt|;
comment|//why don't the builtin functions just use args_list? --Sam
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args_list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|args
operator|+=
name|args_list
index|[
name|i
index|]
operator|.
name|join
argument_list|(
name|QString
argument_list|(
name|Option
operator|::
name|field_sep
argument_list|)
argument_list|)
expr_stmt|;
name|TestFunc
name|func_t
init|=
name|qmake_testFunctions
argument_list|()
operator|.
name|value
argument_list|(
name|func
argument_list|)
decl_stmt|;
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Running project test: %s(%s) [%d]"
argument_list|,
name|func
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|args
operator|.
name|join
argument_list|(
literal|"::"
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|func_t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|func_t
condition|)
block|{
case|case
name|T_REQUIRES
case|:
return|return
name|doProjectCheckReqs
argument_list|(
name|args
argument_list|,
name|place
argument_list|)
return|;
case|case
name|T_LESSTHAN
case|:
case|case
name|T_GREATERTHAN
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: %s(variable, value) requires two arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|func
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QString
name|rhs
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
decl_stmt|,
name|lhs
argument_list|(
name|values
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
operator|.
name|join
argument_list|(
name|QString
argument_list|(
name|Option
operator|::
name|field_sep
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|rhs_int
init|=
name|rhs
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
comment|// do integer compare
name|int
name|lhs_int
init|=
name|lhs
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|func_t
operator|==
name|T_GREATERTHAN
condition|)
return|return
name|lhs_int
operator|>
name|rhs_int
return|;
return|return
name|lhs_int
operator|<
name|rhs_int
return|;
block|}
block|}
if|if
condition|(
name|func_t
operator|==
name|T_GREATERTHAN
condition|)
return|return
name|lhs
operator|>
name|rhs
return|;
return|return
name|lhs
operator|<
name|rhs
return|;
block|}
case|case
name|T_IF
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: if(condition) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|QString
name|cond
init|=
name|args
operator|.
name|first
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|d
init|=
name|cond
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|QChar
name|quote
init|=
literal|0
decl_stmt|;
name|bool
name|ret
init|=
literal|true
decl_stmt|,
name|or_op
init|=
literal|false
decl_stmt|;
name|QString
name|test
decl_stmt|;
for|for
control|(
name|int
name|d_off
init|=
literal|0
init|,
name|parens
init|=
literal|0
init|,
name|d_len
init|=
name|cond
operator|.
name|size
argument_list|()
init|;
name|d_off
operator|<
name|d_len
condition|;
operator|++
name|d_off
control|)
block|{
if|if
condition|(
operator|!
name|quote
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|quote
condition|)
name|quote
operator|=
name|QChar
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
literal|'('
condition|)
block|{
operator|++
name|parens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
literal|')'
condition|)
block|{
operator|--
name|parens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
literal|'"'
comment|/*|| *(d+d_off) == '\''*/
condition|)
block|{
name|quote
operator|=
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parens
operator|&&
name|quote
operator|.
name|isNull
argument_list|()
operator|&&
operator|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|||
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
operator|||
name|d_off
operator|==
name|d_len
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|d_off
operator|==
name|d_len
operator|-
literal|1
condition|)
name|test
operator|+=
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|test
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|or_op
operator|!=
name|ret
condition|)
name|ret
operator|=
name|doProjectTest
argument_list|(
name|test
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|test
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
condition|)
block|{
name|or_op
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
condition|)
block|{
name|or_op
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|test
operator|+=
operator|*
operator|(
name|d
operator|+
name|d_off
operator|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
case|case
name|T_EQUALS
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: %s(variable, value) requires two arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|func
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|values
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
operator|.
name|join
argument_list|(
name|QString
argument_list|(
name|Option
operator|::
name|field_sep
argument_list|)
argument_list|)
operator|==
name|args
index|[
literal|1
index|]
return|;
case|case
name|T_EXISTS
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: exists(file) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QString
name|file
init|=
name|Option
operator|::
name|normalizePath
argument_list|(
name|args
operator|.
name|first
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|true
return|;
comment|//regular expression I guess
name|QString
name|dirstr
init|=
name|qmake_getpwd
argument_list|()
decl_stmt|;
name|int
name|slsh
init|=
name|file
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|slsh
operator|!=
operator|-
literal|1
condition|)
block|{
name|dirstr
operator|=
name|file
operator|.
name|left
argument_list|(
name|slsh
operator|+
literal|1
argument_list|)
expr_stmt|;
name|file
operator|=
name|file
operator|.
name|right
argument_list|(
name|file
operator|.
name|length
argument_list|()
operator|-
name|slsh
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|QDir
argument_list|(
name|dirstr
argument_list|)
operator|.
name|entryList
argument_list|(
name|QStringList
argument_list|(
name|file
argument_list|)
argument_list|)
operator|.
name|count
argument_list|()
return|;
block|}
case|case
name|T_EXPORT
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: export(variable) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|function_blocks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|FunctionBlock
modifier|*
name|f
init|=
name|function_blocks
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|f
operator|->
name|vars
index|[
name|args
index|[
literal|0
index|]
index|]
operator|=
name|values
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|&&
name|f
operator|->
name|calling_place
condition|)
operator|(
operator|*
name|f
operator|->
name|calling_place
operator|)
index|[
name|args
index|[
literal|0
index|]
index|]
operator|=
name|values
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|T_CLEAR
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: clear(variable) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|place
operator|.
name|contains
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|false
return|;
name|place
index|[
name|args
index|[
literal|0
index|]
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
case|case
name|T_UNSET
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: unset(variable) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|place
operator|.
name|contains
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|false
return|;
name|place
operator|.
name|remove
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|T_EVAL
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|&&
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: eval(project) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QString
name|project
init|=
name|args
operator|.
name|join
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|parser_info
name|pi
init|=
name|parser
decl_stmt|;
name|parser
operator|.
name|from_file
operator|=
literal|false
expr_stmt|;
name|parser
operator|.
name|file
operator|=
literal|"(eval)"
expr_stmt|;
name|parser
operator|.
name|line_no
operator|=
literal|0
expr_stmt|;
name|QTextStream
name|t
argument_list|(
operator|&
name|project
argument_list|,
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
decl_stmt|;
name|bool
name|ret
init|=
name|read
argument_list|(
name|t
argument_list|,
name|place
argument_list|)
decl_stmt|;
name|parser
operator|=
name|pi
expr_stmt|;
return|return
name|ret
return|;
block|}
case|case
name|T_CONFIG
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: CONFIG(config) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
return|return
name|isActiveConfig
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
return|;
specifier|const
name|QStringList
name|mutuals
init|=
name|args
index|[
literal|1
index|]
operator|.
name|split
argument_list|(
literal|'|'
argument_list|)
decl_stmt|;
specifier|const
name|QStringList
modifier|&
name|configs
init|=
name|values
argument_list|(
literal|"CONFIG"
argument_list|,
name|place
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|configs
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
for|for
control|(
name|int
name|mut
init|=
literal|0
init|;
name|mut
operator|<
name|mutuals
operator|.
name|count
argument_list|()
condition|;
name|mut
operator|++
control|)
block|{
if|if
condition|(
name|configs
index|[
name|i
index|]
operator|==
name|mutuals
index|[
name|mut
index|]
operator|.
name|trimmed
argument_list|()
condition|)
return|return
operator|(
name|configs
index|[
name|i
index|]
operator|==
name|args
index|[
literal|0
index|]
operator|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
case|case
name|T_SYSTEM
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: system(exec) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|2
condition|)
block|{
specifier|const
name|QString
name|sarg
init|=
name|args
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|sarg
operator|.
name|toLower
argument_list|()
operator|==
literal|"true"
operator|||
name|sarg
operator|.
name|toInt
argument_list|()
condition|)
name|warn_msg
argument_list|(
name|WarnParser
argument_list|,
literal|"%s:%d: system()'s second argument is now hard-wired to false.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
return|return
name|system
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
operator|==
literal|0
return|;
case|case
name|T_RETURN
case|:
if|if
condition|(
name|function_blocks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d unexpected return()\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FunctionBlock
modifier|*
name|f
init|=
name|function_blocks
operator|.
name|top
argument_list|()
decl_stmt|;
name|f
operator|->
name|cause_return
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|args_list
operator|.
name|count
argument_list|()
operator|>=
literal|1
condition|)
name|f
operator|->
name|return_value
operator|+=
name|args_list
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|T_BREAK
case|:
if|if
condition|(
name|iterator
condition|)
name|iterator
operator|->
name|cause_break
operator|=
literal|true
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d unexpected break()\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|T_NEXT
case|:
if|if
condition|(
name|iterator
condition|)
name|iterator
operator|->
name|cause_next
operator|=
literal|true
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d unexpected next()\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|T_DEFINED
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: defined(function) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|==
literal|"test"
condition|)
return|return
name|testFunctions
operator|.
name|contains
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
return|;
elseif|else
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|==
literal|"replace"
condition|)
return|return
name|replaceFunctions
operator|.
name|contains
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
return|;
elseif|else
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|==
literal|"var"
condition|)
return|return
name|place
operator|.
name|contains
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: defined(function, type): unexpected type [%s].\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|replaceFunctions
operator|.
name|contains
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
operator|||
name|testFunctions
operator|.
name|contains
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
case|case
name|T_CONTAINS
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|2
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: contains(var, val) requires at lesat 2 arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QRegExp
name|regx
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QStringList
modifier|&
name|l
init|=
name|values
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
name|val
init|=
name|l
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|regx
operator|.
name|exactMatch
argument_list|(
name|val
argument_list|)
operator|||
name|val
operator|==
name|args
index|[
literal|1
index|]
condition|)
return|return
literal|true
return|;
block|}
block|}
else|else
block|{
specifier|const
name|QStringList
name|mutuals
init|=
name|args
index|[
literal|2
index|]
operator|.
name|split
argument_list|(
literal|'|'
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|l
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|const
name|QString
name|val
init|=
name|l
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|int
name|mut
init|=
literal|0
init|;
name|mut
operator|<
name|mutuals
operator|.
name|count
argument_list|()
condition|;
name|mut
operator|++
control|)
block|{
if|if
condition|(
name|val
operator|==
name|mutuals
index|[
name|mut
index|]
operator|.
name|trimmed
argument_list|()
condition|)
return|return
operator|(
name|regx
operator|.
name|exactMatch
argument_list|(
name|val
argument_list|)
operator|||
name|val
operator|==
name|args
index|[
literal|1
index|]
operator|)
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
case|case
name|T_INFILE
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|2
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: infile(file, var, val) requires at least 2 arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|bool
name|ret
init|=
literal|false
decl_stmt|;
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
name|tmp
decl_stmt|;
if|if
condition|(
name|doProjectInclude
argument_list|(
name|Option
operator|::
name|normalizePath
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|IncludeFlagNewParser
argument_list|,
name|tmp
argument_list|)
operator|==
name|IncludeSuccess
condition|)
block|{
if|if
condition|(
name|tmp
operator|.
name|contains
argument_list|(
literal|"QMAKE_INTERNAL_INCLUDED_FILES"
argument_list|)
condition|)
block|{
name|QStringList
modifier|&
name|out
init|=
name|place
index|[
literal|"QMAKE_INTERNAL_INCLUDED_FILES"
index|]
decl_stmt|;
specifier|const
name|QStringList
modifier|&
name|in
init|=
name|tmp
index|[
literal|"QMAKE_INTERNAL_INCLUDED_FILES"
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|in
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|out
operator|.
name|indexOf
argument_list|(
name|in
index|[
name|i
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|out
operator|+=
name|in
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|2
condition|)
block|{
name|ret
operator|=
name|tmp
operator|.
name|contains
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QRegExp
name|regx
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
specifier|const
name|QStringList
modifier|&
name|l
init|=
name|tmp
index|[
name|args
index|[
literal|1
index|]
index|]
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|ConstIterator
name|it
init|=
name|l
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|l
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|regx
operator|.
name|exactMatch
argument_list|(
operator|(
operator|*
name|it
operator|)
argument_list|)
operator|||
operator|(
operator|*
name|it
operator|)
operator|==
name|args
index|[
literal|2
index|]
condition|)
block|{
name|ret
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
case|case
name|T_COUNT
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
operator|&&
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: count(var, count) requires two arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|3
condition|)
block|{
name|QString
name|comp
init|=
name|args
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|comp
operator|==
literal|">"
operator|||
name|comp
operator|==
literal|"greaterThan"
condition|)
return|return
name|values
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
operator|.
name|count
argument_list|()
operator|>
name|args
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|()
return|;
if|if
condition|(
name|comp
operator|==
literal|">="
condition|)
return|return
name|values
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
operator|.
name|count
argument_list|()
operator|>=
name|args
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|()
return|;
if|if
condition|(
name|comp
operator|==
literal|"<"
operator|||
name|comp
operator|==
literal|"lessThan"
condition|)
return|return
name|values
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
operator|.
name|count
argument_list|()
operator|<
name|args
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|()
return|;
if|if
condition|(
name|comp
operator|==
literal|"<="
condition|)
return|return
name|values
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
operator|.
name|count
argument_list|()
operator|<=
name|args
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|()
return|;
if|if
condition|(
name|comp
operator|==
literal|"equals"
operator|||
name|comp
operator|==
literal|"isEqual"
operator|||
name|comp
operator|==
literal|"="
operator|||
name|comp
operator|==
literal|"=="
condition|)
return|return
name|values
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
operator|.
name|count
argument_list|()
operator|==
name|args
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|()
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: unexpected modifier to count(%s)\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|comp
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|values
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
operator|.
name|count
argument_list|()
operator|==
name|args
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|()
return|;
case|case
name|T_ISEMPTY
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: isEmpty(var) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|values
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|place
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
case|case
name|T_INCLUDE
case|:
case|case
name|T_LOAD
case|:
block|{
name|QString
name|parseInto
decl_stmt|;
specifier|const
name|bool
name|include_statement
init|=
operator|(
name|func_t
operator|==
name|T_INCLUDE
operator|)
decl_stmt|;
name|bool
name|ignore_error
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|func_t
operator|==
name|T_INCLUDE
condition|)
block|{
name|parseInto
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|3
condition|)
block|{
name|QString
name|sarg
init|=
name|args
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|sarg
operator|.
name|toLower
argument_list|()
operator|==
literal|"true"
operator|||
name|sarg
operator|.
name|toInt
argument_list|()
condition|)
name|ignore_error
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|QString
name|sarg
init|=
name|args
index|[
literal|1
index|]
decl_stmt|;
name|ignore_error
operator|=
operator|(
name|sarg
operator|.
name|toLower
argument_list|()
operator|==
literal|"true"
operator|||
name|sarg
operator|.
name|toInt
argument_list|()
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|QString
name|func_desc
init|=
literal|"load(feature)"
decl_stmt|;
if|if
condition|(
name|include_statement
condition|)
name|func_desc
operator|=
literal|"include(file)"
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: %s requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|func_desc
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QString
name|file
init|=
name|Option
operator|::
name|normalizePath
argument_list|(
name|args
operator|.
name|first
argument_list|()
argument_list|)
decl_stmt|;
name|uchar
name|flags
init|=
name|IncludeFlagNone
decl_stmt|;
if|if
condition|(
operator|!
name|include_statement
condition|)
name|flags
operator||=
name|IncludeFlagFeature
expr_stmt|;
name|IncludeStatus
name|stat
init|=
name|IncludeFailure
decl_stmt|;
if|if
condition|(
operator|!
name|parseInto
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
name|symbols
decl_stmt|;
name|stat
operator|=
name|doProjectInclude
argument_list|(
name|file
argument_list|,
name|flags
operator||
name|IncludeFlagNewProject
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|IncludeSuccess
condition|)
block|{
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
name|out_place
decl_stmt|;
for|for
control|(
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|place
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|place
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QString
name|var
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
name|var
operator|!=
name|parseInto
operator|&&
operator|!
name|var
operator|.
name|startsWith
argument_list|(
name|parseInto
operator|+
literal|"."
argument_list|)
condition|)
name|out_place
operator|.
name|insert
argument_list|(
name|var
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|symbols
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|symbols
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QString
name|var
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|var
operator|.
name|startsWith
argument_list|(
literal|"."
argument_list|)
condition|)
name|out_place
operator|.
name|insert
argument_list|(
name|parseInto
operator|+
literal|"."
operator|+
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|place
operator|=
name|out_place
expr_stmt|;
block|}
block|}
else|else
block|{
name|stat
operator|=
name|doProjectInclude
argument_list|(
name|file
argument_list|,
name|flags
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|==
name|IncludeFeatureAlreadyLoaded
condition|)
block|{
name|warn_msg
argument_list|(
name|WarnParser
argument_list|,
literal|"%s:%d: Duplicate of loaded feature %s"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
operator|==
name|IncludeNoExist
operator|&&
operator|!
name|ignore_error
condition|)
block|{
name|warn_msg
argument_list|(
name|WarnAll
argument_list|,
literal|"%s:%d: Unable to find file for inclusion %s"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|stat
operator|>=
name|IncludeFailure
condition|)
block|{
if|if
condition|(
operator|!
name|ignore_error
condition|)
block|{
name|printf
argument_list|(
literal|"Project LOAD(): Feature %s cannot be found.\n"
argument_list|,
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignore_error
condition|)
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_QMAKE_LIBRARY
argument_list|)
return|return
literal|false
return|;
else|#
directive|else
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
case|case
name|T_DEBUG
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: debug(level, message) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QString
name|msg
init|=
name|fixEnvVariables
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|debug_msg
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|()
argument_list|,
literal|"Project DEBUG: %s"
argument_list|,
name|msg
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|T_LOG
case|:
case|case
name|T_ERROR
case|:
case|case
name|T_MESSAGE
case|:
case|case
name|T_WARNING
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: %s(message) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|func
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QString
name|msg
init|=
name|fixEnvVariables
argument_list|(
name|args
operator|.
name|first
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|func_t
operator|==
name|T_LOG
condition|)
block|{
name|fputs
argument_list|(
name|msg
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Project %s: %s\n"
argument_list|,
name|func
operator|.
name|toUpper
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|msg
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
literal|"error"
condition|)
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_QMAKE_LIBRARY
argument_list|)
return|return
literal|false
return|;
else|#
directive|else
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|true
return|;
block|}
case|case
name|T_OPTION
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: option() requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|args
operator|.
name|first
argument_list|()
operator|==
literal|"recursive"
condition|)
block|{
name|recursive
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
operator|.
name|first
argument_list|()
operator|==
literal|"host_build"
condition|)
block|{
if|if
condition|(
operator|!
name|host_build
operator|&&
name|isActiveConfig
argument_list|(
literal|"cross_compile"
argument_list|)
condition|)
block|{
name|host_build
operator|=
literal|true
expr_stmt|;
name|need_restart
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: unrecognized option() argument '%s'.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|args
operator|.
name|first
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
case|case
name|T_CACHE
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: cache(var, [set|add|sub] [transient] [super], [srcvar]) requires one to three arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|bool
name|persist
init|=
literal|true
decl_stmt|;
name|bool
name|super
init|=
literal|false
decl_stmt|;
enum|enum
block|{
name|CacheSet
block|,
name|CacheAdd
block|,
name|CacheSub
block|}
name|mode
init|=
name|CacheSet
enum|;
name|QString
name|srcvar
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|2
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|opt
decl|,
name|split_value_list
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|opt
operator|==
name|QLatin1String
argument_list|(
literal|"transient"
argument_list|)
condition|)
block|{
name|persist
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|==
name|QLatin1String
argument_list|(
literal|"super"
argument_list|)
condition|)
block|{
name|super
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|==
name|QLatin1String
argument_list|(
literal|"set"
argument_list|)
condition|)
block|{
name|mode
operator|=
name|CacheSet
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|==
name|QLatin1String
argument_list|(
literal|"add"
argument_list|)
condition|)
block|{
name|mode
operator|=
name|CacheAdd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|==
name|QLatin1String
argument_list|(
literal|"sub"
argument_list|)
condition|)
block|{
name|mode
operator|=
name|CacheSub
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: cache(): invalid flag %s.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|opt
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|3
condition|)
block|{
name|srcvar
operator|=
name|args
operator|.
name|at
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|!=
name|CacheSet
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: cache(): modes other than 'set' require a source variable.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|QString
name|varstr
decl_stmt|;
name|QString
name|dstvar
init|=
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dstvar
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|srcvar
operator|.
name|isEmpty
argument_list|()
condition|)
name|srcvar
operator|=
name|dstvar
expr_stmt|;
if|if
condition|(
operator|!
name|place
operator|.
name|contains
argument_list|(
name|srcvar
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: variable %s is not defined.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|srcvar
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// The current ("native") value can differ from the cached value, e.g., the current
comment|// CONFIG will typically have more values than the cached one. Therefore we deal with
comment|// them separately.
specifier|const
name|QStringList
name|diffval
init|=
name|values
argument_list|(
name|srcvar
argument_list|,
name|place
argument_list|)
decl_stmt|;
specifier|const
name|QStringList
name|oldval
init|=
name|base_vars
operator|.
name|value
argument_list|(
name|dstvar
argument_list|)
decl_stmt|;
name|QStringList
name|newval
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|CacheSet
condition|)
block|{
name|newval
operator|=
name|diffval
expr_stmt|;
block|}
else|else
block|{
name|newval
operator|=
name|oldval
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CacheAdd
condition|)
name|newval
operator|+=
name|diffval
expr_stmt|;
else|else
name|subAll
argument_list|(
operator|&
name|newval
argument_list|,
name|diffval
argument_list|)
expr_stmt|;
block|}
comment|// We assume that whatever got the cached value to be what it is now will do so
comment|// the next time as well, so it is OK that the early exit here will skip the
comment|// persisting as well.
if|if
condition|(
name|oldval
operator|==
name|newval
condition|)
return|return
literal|true
return|;
name|base_vars
index|[
name|dstvar
index|]
operator|=
name|newval
expr_stmt|;
do|do
block|{
if|if
condition|(
name|dstvar
operator|==
literal|"QMAKEPATH"
condition|)
name|cached_qmakepath
operator|=
name|newval
expr_stmt|;
elseif|else
if|if
condition|(
name|dstvar
operator|==
literal|"QMAKEFEATURES"
condition|)
name|cached_qmakefeatures
operator|=
name|newval
expr_stmt|;
else|else
break|break;
name|invalidateFeatureRoots
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
literal|false
condition|)
do|;
if|if
condition|(
operator|!
name|persist
condition|)
return|return
literal|true
return|;
name|varstr
operator|=
name|dstvar
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CacheAdd
condition|)
name|varstr
operator|+=
name|QLatin1String
argument_list|(
literal|" +="
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|CacheSub
condition|)
name|varstr
operator|+=
name|QLatin1String
argument_list|(
literal|" -="
argument_list|)
expr_stmt|;
else|else
name|varstr
operator|+=
name|QLatin1String
argument_list|(
literal|" ="
argument_list|)
expr_stmt|;
if|if
condition|(
name|diffval
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
name|varstr
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|varstr
operator|+=
name|quoteValue
argument_list|(
name|diffval
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|diffval
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|vval
decl|,
name|diffval
control|)
block|{
name|varstr
operator|+=
name|QLatin1String
argument_list|(
literal|" \\\n    "
argument_list|)
expr_stmt|;
name|varstr
operator|+=
name|quoteValue
argument_list|(
name|vval
argument_list|)
expr_stmt|;
block|}
block|}
name|varstr
operator|+=
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|QString
name|fn
decl_stmt|;
if|if
condition|(
name|super
condition|)
block|{
if|if
condition|(
name|superfile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|superfile
operator|=
name|Option
operator|::
name|output_dir
operator|+
name|QLatin1String
argument_list|(
literal|"/.qmake.super"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Info: creating super cache file %s\n"
argument_list|,
name|superfile
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fn
operator|=
name|superfile
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cachefile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cachefile
operator|=
name|Option
operator|::
name|output_dir
operator|+
name|QLatin1String
argument_list|(
literal|"/.qmake.cache"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Info: creating cache file %s\n"
argument_list|,
name|cachefile
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached_build_root
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cached_build_root
operator|=
name|Option
operator|::
name|output_dir
expr_stmt|;
name|cached_source_root
operator|=
name|values
argument_list|(
literal|"_PRO_FILE_PWD_"
argument_list|,
name|place
argument_list|)
operator|.
name|first
argument_list|()
expr_stmt|;
if|if
condition|(
name|cached_source_root
operator|==
name|cached_build_root
condition|)
name|cached_source_root
operator|.
name|clear
argument_list|()
expr_stmt|;
name|invalidateFeatureRoots
argument_list|()
expr_stmt|;
block|}
block|}
name|fn
operator|=
name|cachefile
expr_stmt|;
block|}
name|QFileInfo
name|qfi
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QDir
operator|::
name|current
argument_list|()
operator|.
name|mkpath
argument_list|(
name|qfi
operator|.
name|path
argument_list|()
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: ERROR creating cache directory %s\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|qfi
operator|.
name|path
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QString
name|errStr
decl_stmt|;
if|if
condition|(
operator|!
name|writeFile
argument_list|(
name|fn
argument_list|,
name|QIODevice
operator|::
name|Append
argument_list|,
name|varstr
argument_list|,
operator|&
name|errStr
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR writing cache file %s: %s\n"
argument_list|,
name|fn
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|errStr
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_QMAKE_LIBRARY
argument_list|)
return|return
literal|false
return|;
else|#
directive|else
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|true
return|;
block|}
case|case
name|T_MKPATH
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: mkpath(name) requires one argument.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|QDir
operator|::
name|current
argument_list|()
operator|.
name|mkpath
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: ERROR creating directory %s\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
case|case
name|T_WRITE_FILE
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: write_file(name, [content var, [append]]) requires one to three arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QIODevice
operator|::
name|OpenMode
name|mode
init|=
name|QIODevice
operator|::
name|Truncate
decl_stmt|;
name|QString
name|contents
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|QStringList
name|vals
init|=
name|values
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|,
name|place
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vals
operator|.
name|isEmpty
argument_list|()
condition|)
name|contents
operator|=
name|vals
operator|.
name|join
argument_list|(
name|QLatin1String
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|3
condition|)
if|if
condition|(
operator|!
name|args
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"append"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|mode
operator|=
name|QIODevice
operator|::
name|Append
expr_stmt|;
block|}
name|QFileInfo
name|qfi
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QDir
operator|::
name|current
argument_list|()
operator|.
name|mkpath
argument_list|(
name|qfi
operator|.
name|path
argument_list|()
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: ERROR creating directory %s\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|qfi
operator|.
name|path
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QString
name|errStr
decl_stmt|;
if|if
condition|(
operator|!
name|writeFile
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|contents
argument_list|,
operator|&
name|errStr
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d ERROR writing %s: %s\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|errStr
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
case|case
name|T_TOUCH
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: touch(file, reffile) requires two arguments.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: ERROR: cannot stat() reference file %s: %s.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|struct
name|utimbuf
name|utb
decl_stmt|;
name|utb
operator|.
name|actime
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|utb
operator|.
name|modtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
operator|&
name|utb
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: ERROR: cannot touch %s: %s.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|#
directive|else
name|HANDLE
name|rHand
init|=
name|CreateFile
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|,
name|GENERIC_READ
argument_list|,
name|FILE_SHARE_READ
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|rHand
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: ERROR: cannot open() reference file %s: %s.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|windowsErrorCode
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|FILETIME
name|ft
decl_stmt|;
name|GetFileTime
argument_list|(
name|rHand
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|ft
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|rHand
argument_list|)
expr_stmt|;
name|HANDLE
name|wHand
init|=
name|CreateFile
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|,
name|GENERIC_WRITE
argument_list|,
name|FILE_SHARE_READ
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|wHand
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: ERROR: cannot open %s: %s.\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|windowsErrorCode
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|SetFileTime
argument_list|(
name|wHand
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|ft
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|wHand
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: Unknown test function: %s\n"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
name|func
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
name|bool
DECL|function|doProjectCheckReqs
name|QMakeProject
operator|::
name|doProjectCheckReqs
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|deps
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
name|bool
name|ret
init|=
literal|false
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|ConstIterator
name|it
init|=
name|deps
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|deps
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|bool
name|test
init|=
name|doProjectTest
argument_list|(
operator|(
operator|*
name|it
operator|)
argument_list|,
name|place
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|test
condition|)
block|{
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Project Parser: %s:%d Failed test: REQUIRES = %s"
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|place
index|[
literal|"QMAKE_FAILED_REQUIREMENTS"
index|]
operator|.
name|append
argument_list|(
operator|(
operator|*
name|it
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
name|bool
DECL|function|test
name|QMakeProject
operator|::
name|test
parameter_list|(
specifier|const
name|QString
modifier|&
name|v
parameter_list|)
block|{
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
name|tmp
init|=
name|vars
decl_stmt|;
return|return
name|doProjectTest
argument_list|(
name|v
argument_list|,
name|tmp
argument_list|)
return|;
block|}
name|bool
DECL|function|test
name|QMakeProject
operator|::
name|test
parameter_list|(
specifier|const
name|QString
modifier|&
name|func
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QStringList
argument_list|>
modifier|&
name|args
parameter_list|)
block|{
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
name|tmp
init|=
name|vars
decl_stmt|;
return|return
name|doProjectTest
argument_list|(
name|func
argument_list|,
name|args
argument_list|,
name|tmp
argument_list|)
return|;
block|}
name|QStringList
DECL|function|expand
name|QMakeProject
operator|::
name|expand
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
name|tmp
init|=
name|vars
decl_stmt|;
specifier|const
name|QStringList
name|ret
init|=
name|doVariableReplaceExpand
argument_list|(
name|str
argument_list|,
name|tmp
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
return|return
name|ret
return|;
return|return
name|QStringList
argument_list|()
return|;
block|}
name|QString
DECL|function|expand
name|QMakeProject
operator|::
name|expand
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
specifier|const
name|QString
modifier|&
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|parser_info
name|pi
init|=
name|parser
decl_stmt|;
name|parser
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|parser
operator|.
name|line_no
operator|=
name|line
expr_stmt|;
name|parser
operator|.
name|from_file
operator|=
literal|false
expr_stmt|;
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
name|tmp
init|=
name|vars
decl_stmt|;
specifier|const
name|QStringList
name|ret
init|=
name|doVariableReplaceExpand
argument_list|(
name|str
argument_list|,
name|tmp
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
name|parser
operator|=
name|pi
expr_stmt|;
return|return
name|ok
condition|?
name|ret
operator|.
name|join
argument_list|(
name|QString
argument_list|(
name|Option
operator|::
name|field_sep
argument_list|)
argument_list|)
else|:
name|QString
argument_list|()
return|;
block|}
name|QStringList
DECL|function|expand
name|QMakeProject
operator|::
name|expand
parameter_list|(
specifier|const
name|QString
modifier|&
name|func
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QStringList
argument_list|>
modifier|&
name|args
parameter_list|)
block|{
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
name|tmp
init|=
name|vars
decl_stmt|;
return|return
name|doProjectExpand
argument_list|(
name|func
argument_list|,
name|args
argument_list|,
name|tmp
argument_list|)
return|;
block|}
name|bool
DECL|function|doVariableReplace
name|QMakeProject
operator|::
name|doVariableReplace
parameter_list|(
name|QString
modifier|&
name|str
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|str
operator|=
name|doVariableReplaceExpand
argument_list|(
name|str
argument_list|,
name|place
argument_list|,
operator|&
name|ret
argument_list|)
operator|.
name|join
argument_list|(
name|QString
argument_list|(
name|Option
operator|::
name|field_sep
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|QStringList
DECL|function|doVariableReplaceExpand
name|QMakeProject
operator|::
name|doVariableReplaceExpand
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
name|QStringList
name|ret
decl_stmt|;
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|ret
return|;
specifier|const
name|ushort
name|LSQUARE
init|=
literal|'['
decl_stmt|;
specifier|const
name|ushort
name|RSQUARE
init|=
literal|']'
decl_stmt|;
specifier|const
name|ushort
name|LCURLY
init|=
literal|'{'
decl_stmt|;
specifier|const
name|ushort
name|RCURLY
init|=
literal|'}'
decl_stmt|;
specifier|const
name|ushort
name|LPAREN
init|=
literal|'('
decl_stmt|;
specifier|const
name|ushort
name|RPAREN
init|=
literal|')'
decl_stmt|;
specifier|const
name|ushort
name|DOLLAR
init|=
literal|'$'
decl_stmt|;
specifier|const
name|ushort
name|SLASH
init|=
literal|'\\'
decl_stmt|;
specifier|const
name|ushort
name|UNDERSCORE
init|=
literal|'_'
decl_stmt|;
specifier|const
name|ushort
name|DOT
init|=
literal|'.'
decl_stmt|;
specifier|const
name|ushort
name|SPACE
init|=
literal|' '
decl_stmt|;
specifier|const
name|ushort
name|TAB
init|=
literal|'\t'
decl_stmt|;
specifier|const
name|ushort
name|SINGLEQUOTE
init|=
literal|'\''
decl_stmt|;
specifier|const
name|ushort
name|DOUBLEQUOTE
init|=
literal|'"'
decl_stmt|;
name|ushort
name|unicode
decl_stmt|,
name|quote
init|=
literal|0
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|str_data
init|=
name|str
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|int
name|str_len
init|=
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
name|ushort
name|term
decl_stmt|;
name|QString
name|var
decl_stmt|,
name|args
decl_stmt|;
name|int
name|replaced
init|=
literal|0
decl_stmt|;
name|QString
name|current
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|str_len
condition|;
operator|++
name|i
control|)
block|{
name|unicode
operator|=
name|str_data
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
expr_stmt|;
specifier|const
name|int
name|start_var
init|=
name|i
decl_stmt|;
if|if
condition|(
name|unicode
operator|==
name|DOLLAR
operator|&&
name|str_len
operator|>
name|i
operator|+
literal|2
condition|)
block|{
name|unicode
operator|=
name|str_data
index|[
operator|++
name|i
index|]
operator|.
name|unicode
argument_list|()
expr_stmt|;
if|if
condition|(
name|unicode
operator|==
name|DOLLAR
condition|)
block|{
name|term
operator|=
literal|0
expr_stmt|;
name|var
operator|.
name|clear
argument_list|()
expr_stmt|;
name|args
operator|.
name|clear
argument_list|()
expr_stmt|;
enum|enum
block|{
name|VAR
block|,
name|ENVIRON
block|,
name|FUNCTION
block|,
name|PROPERTY
block|}
name|var_type
init|=
name|VAR
enum|;
name|unicode
operator|=
name|str_data
index|[
operator|++
name|i
index|]
operator|.
name|unicode
argument_list|()
expr_stmt|;
if|if
condition|(
name|unicode
operator|==
name|LSQUARE
condition|)
block|{
name|unicode
operator|=
name|str_data
index|[
operator|++
name|i
index|]
operator|.
name|unicode
argument_list|()
expr_stmt|;
name|term
operator|=
name|RSQUARE
expr_stmt|;
name|var_type
operator|=
name|PROPERTY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unicode
operator|==
name|LCURLY
condition|)
block|{
name|unicode
operator|=
name|str_data
index|[
operator|++
name|i
index|]
operator|.
name|unicode
argument_list|()
expr_stmt|;
name|var_type
operator|=
name|VAR
expr_stmt|;
name|term
operator|=
name|RCURLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unicode
operator|==
name|LPAREN
condition|)
block|{
name|unicode
operator|=
name|str_data
index|[
operator|++
name|i
index|]
operator|.
name|unicode
argument_list|()
expr_stmt|;
name|var_type
operator|=
name|ENVIRON
expr_stmt|;
name|term
operator|=
name|RPAREN
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|unicode
operator|&
operator|(
literal|0xFF
operator|<<
literal|8
operator|)
operator|)
operator|&&
name|unicode
operator|!=
name|DOT
operator|&&
name|unicode
operator|!=
name|UNDERSCORE
operator|&&
comment|//unicode != SINGLEQUOTE&& unicode != DOUBLEQUOTE&&
operator|(
name|unicode
argument_list|<
literal|'a'
operator|||
name|unicode
argument_list|>
literal|'z'
operator|)
operator|&&
operator|(
name|unicode
argument_list|<
literal|'A'
operator|||
name|unicode
argument_list|>
literal|'Z'
operator|)
operator|&&
operator|(
name|unicode
argument_list|<
literal|'0'
operator|||
name|unicode
argument_list|>
literal|'9'
operator|)
operator|&&
operator|(
operator|!
name|term
operator|||
name|unicode
operator|!=
literal|'/'
operator|)
condition|)
break|break;
name|var
operator|.
name|append
argument_list|(
name|QChar
argument_list|(
name|unicode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|str_len
condition|)
break|break;
name|unicode
operator|=
name|str_data
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
expr_stmt|;
comment|// at this point, i points to either the 'term' or 'next' character (which is in unicode)
block|}
if|if
condition|(
name|var_type
operator|==
name|VAR
operator|&&
name|unicode
operator|==
name|LPAREN
condition|)
block|{
name|var_type
operator|=
name|FUNCTION
expr_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|str_len
condition|)
break|break;
name|unicode
operator|=
name|str_data
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
expr_stmt|;
if|if
condition|(
name|unicode
operator|==
name|LPAREN
condition|)
block|{
name|depth
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unicode
operator|==
name|RPAREN
condition|)
block|{
if|if
condition|(
operator|!
name|depth
condition|)
break|break;
operator|--
name|depth
expr_stmt|;
block|}
name|args
operator|.
name|append
argument_list|(
name|QChar
argument_list|(
name|unicode
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|i
operator|<
name|str_len
condition|)
name|unicode
operator|=
name|str_data
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
expr_stmt|;
else|else
name|unicode
operator|=
literal|0
expr_stmt|;
comment|// at this point i is pointing to the 'next' character (which is in unicode)
comment|// this might actually be a term character since you can do $${func()}
block|}
if|if
condition|(
name|term
condition|)
block|{
if|if
condition|(
name|unicode
operator|!=
name|term
condition|)
block|{
name|qmake_error_msg
argument_list|(
literal|"Missing "
operator|+
name|QString
argument_list|(
name|term
argument_list|)
operator|+
literal|" terminator [found "
operator|+
operator|(
name|unicode
condition|?
name|QString
argument_list|(
name|unicode
argument_list|)
else|:
name|QString
argument_list|(
literal|"end-of-line"
argument_list|)
operator|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QStringList
argument_list|()
return|;
block|}
block|}
else|else
block|{
comment|// move the 'cursor' back to the last char of the thing we were looking at
operator|--
name|i
expr_stmt|;
block|}
comment|// since i never points to the 'next' character, there is no reason for this to be set
name|unicode
operator|=
literal|0
expr_stmt|;
name|QStringList
name|replacement
decl_stmt|;
if|if
condition|(
name|var_type
operator|==
name|ENVIRON
condition|)
block|{
name|replacement
operator|=
name|split_value_list
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
name|var
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var_type
operator|==
name|PROPERTY
condition|)
block|{
if|if
condition|(
name|prop
condition|)
name|replacement
operator|=
name|split_value_list
argument_list|(
name|prop
operator|->
name|value
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var_type
operator|==
name|FUNCTION
condition|)
block|{
name|replacement
operator|=
name|doProjectExpand
argument_list|(
name|var
argument_list|,
name|args
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var_type
operator|==
name|VAR
condition|)
block|{
name|replacement
operator|=
name|values
argument_list|(
name|var
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|replaced
operator|++
operator|)
operator|&&
name|start_var
condition|)
name|current
operator|=
name|str
operator|.
name|left
argument_list|(
name|start_var
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|replacement
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|quote
condition|)
block|{
name|current
operator|+=
name|replacement
operator|.
name|join
argument_list|(
name|QString
argument_list|(
name|Option
operator|::
name|field_sep
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|+=
name|replacement
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|replacement
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|current
operator|.
name|isEmpty
argument_list|()
condition|)
name|ret
operator|.
name|append
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
name|replacement
operator|.
name|takeLast
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|replacement
operator|.
name|isEmpty
argument_list|()
condition|)
name|ret
operator|+=
name|replacement
expr_stmt|;
block|}
block|}
block|}
name|debug_msg
argument_list|(
literal|2
argument_list|,
literal|"Project Parser [var replace]: %s -> %s"
argument_list|,
name|str
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|var
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|replacement
operator|.
name|join
argument_list|(
literal|"::"
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|replaced
condition|)
name|current
operator|.
name|append
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quote
operator|&&
name|unicode
operator|==
name|quote
condition|)
block|{
name|unicode
operator|=
literal|0
expr_stmt|;
name|quote
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unicode
operator|==
name|SLASH
condition|)
block|{
name|bool
name|escape
init|=
literal|false
decl_stmt|;
specifier|const
name|char
modifier|*
name|symbols
init|=
literal|"[]{}()$\\'\""
decl_stmt|;
for|for
control|(
specifier|const
name|char
modifier|*
name|s
init|=
name|symbols
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
block|{
if|if
condition|(
name|str_data
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
operator|(
name|ushort
operator|)
operator|*
name|s
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|escape
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|replaced
operator|++
operator|)
condition|)
name|current
operator|=
name|str
operator|.
name|left
argument_list|(
name|start_var
argument_list|)
expr_stmt|;
name|current
operator|.
name|append
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|escape
operator|&&
operator|!
name|backslashWarned
condition|)
block|{
name|backslashWarned
operator|=
literal|true
expr_stmt|;
name|warn_msg
argument_list|(
name|WarnDeprecated
argument_list|,
literal|"%s:%d: Unescaped backslashes are deprecated."
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|escape
operator|||
operator|!
name|replaced
condition|)
name|unicode
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quote
operator|&&
operator|(
name|unicode
operator|==
name|SINGLEQUOTE
operator|||
name|unicode
operator|==
name|DOUBLEQUOTE
operator|)
condition|)
block|{
name|quote
operator|=
name|unicode
expr_stmt|;
name|unicode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|replaced
operator|++
operator|)
operator|&&
name|i
condition|)
name|current
operator|=
name|str
operator|.
name|left
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quote
operator|&&
operator|(
name|unicode
operator|==
name|SPACE
operator|||
name|unicode
operator|==
name|TAB
operator|)
condition|)
block|{
name|unicode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|current
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ret
operator|.
name|append
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|current
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|replaced
operator|&&
name|unicode
condition|)
name|current
operator|.
name|append
argument_list|(
name|QChar
argument_list|(
name|unicode
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|replaced
condition|)
name|ret
operator|=
name|QStringList
argument_list|(
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|current
operator|.
name|isEmpty
argument_list|()
condition|)
name|ret
operator|.
name|append
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|//qDebug()<< "REPLACE"<< str<< ret;
if|if
condition|(
name|quote
condition|)
name|warn_msg
argument_list|(
name|WarnDeprecated
argument_list|,
literal|"%s:%d: Unmatched quotes are deprecated."
argument_list|,
name|parser
operator|.
name|file
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|parser
operator|.
name|line_no
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|function|values
name|QStringList
modifier|&
name|QMakeProject
operator|::
name|values
parameter_list|(
specifier|const
name|QString
modifier|&
name|_var
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|place
parameter_list|)
block|{
name|QString
name|var
init|=
name|varMap
argument_list|(
name|_var
argument_list|)
decl_stmt|;
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"LITERAL_WHITESPACE"
argument_list|)
condition|)
block|{
comment|//a real space in a token)
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|QLatin1String
argument_list|(
literal|"\t"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"LITERAL_DOLLAR"
argument_list|)
condition|)
block|{
comment|//a real $
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|QLatin1String
argument_list|(
literal|"$"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"LITERAL_HASH"
argument_list|)
condition|)
block|{
comment|//a real #
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
literal|"#"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"OUT_PWD"
argument_list|)
condition|)
block|{
comment|//the out going dir
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|Option
operator|::
name|output_dir
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"PWD"
argument_list|)
operator|||
comment|//current working dir (of _FILE_)
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"IN_PWD"
argument_list|)
condition|)
block|{
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|qmake_getpwd
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"DIR_SEPARATOR"
argument_list|)
condition|)
block|{
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|Option
operator|::
name|dir_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"DIRLIST_SEPARATOR"
argument_list|)
condition|)
block|{
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|Option
operator|::
name|dirlist_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"_LINE_"
argument_list|)
condition|)
block|{
comment|//parser line number
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|parser
operator|.
name|line_no
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"_FILE_"
argument_list|)
condition|)
block|{
comment|//parser file
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|parser
operator|.
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"_DATE_"
argument_list|)
condition|)
block|{
comment|//current date/time
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"_PRO_FILE_"
argument_list|)
condition|)
block|{
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"_PRO_FILE_PWD_"
argument_list|)
condition|)
block|{
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|pfile
operator|.
name|isEmpty
argument_list|()
condition|?
name|qmake_getpwd
argument_list|()
else|:
name|QFileInfo
argument_list|(
name|pfile
argument_list|)
operator|.
name|absolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"_QMAKE_CACHE_"
argument_list|)
condition|)
block|{
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
if|if
condition|(
name|Option
operator|::
name|mkfile
operator|::
name|do_cache
condition|)
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|cachefile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"_QMAKE_SUPER_CACHE_"
argument_list|)
condition|)
block|{
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
if|if
condition|(
name|Option
operator|::
name|mkfile
operator|::
name|do_cache
operator|&&
operator|!
name|superfile
operator|.
name|isEmpty
argument_list|()
condition|)
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|superfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"TEMPLATE"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|Option
operator|::
name|user_template
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|var
operator|=
literal|".BUILTIN.USER."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|Option
operator|::
name|user_template
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|orig_template
decl_stmt|,
name|real_template
decl_stmt|;
if|if
condition|(
operator|!
name|place
index|[
name|var
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
name|orig_template
operator|=
name|place
index|[
name|var
index|]
operator|.
name|first
argument_list|()
expr_stmt|;
name|real_template
operator|=
name|orig_template
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"app"
else|:
name|orig_template
expr_stmt|;
if|if
condition|(
operator|!
name|Option
operator|::
name|user_template_prefix
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|orig_template
operator|.
name|startsWith
argument_list|(
name|Option
operator|::
name|user_template_prefix
argument_list|)
condition|)
name|real_template
operator|.
name|prepend
argument_list|(
name|Option
operator|::
name|user_template_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_template
operator|!=
name|orig_template
condition|)
block|{
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|real_template
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|var
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"QMAKE_HOST."
argument_list|)
argument_list|)
condition|)
block|{
name|QString
name|ret
decl_stmt|,
name|type
init|=
name|var
operator|.
name|mid
argument_list|(
literal|11
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
if|if
condition|(
name|type
operator|==
literal|"os"
condition|)
block|{
name|ret
operator|=
literal|"Windows"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|"name"
condition|)
block|{
name|DWORD
name|name_length
init|=
literal|1024
decl_stmt|;
name|wchar_t
name|name
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|GetComputerName
argument_list|(
name|name
argument_list|,
operator|&
name|name_length
argument_list|)
condition|)
name|ret
operator|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|"version"
operator|||
name|type
operator|==
literal|"version_string"
condition|)
block|{
name|QSysInfo
operator|::
name|WinVersion
name|ver
init|=
name|QSysInfo
operator|::
name|WindowsVersion
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|"version"
condition|)
name|ret
operator|=
name|QString
operator|::
name|number
argument_list|(
name|ver
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ver
operator|==
name|QSysInfo
operator|::
name|WV_Me
condition|)
name|ret
operator|=
literal|"WinMe"
expr_stmt|;
elseif|else
if|if
condition|(
name|ver
operator|==
name|QSysInfo
operator|::
name|WV_95
condition|)
name|ret
operator|=
literal|"Win95"
expr_stmt|;
elseif|else
if|if
condition|(
name|ver
operator|==
name|QSysInfo
operator|::
name|WV_98
condition|)
name|ret
operator|=
literal|"Win98"
expr_stmt|;
elseif|else
if|if
condition|(
name|ver
operator|==
name|QSysInfo
operator|::
name|WV_NT
condition|)
name|ret
operator|=
literal|"WinNT"
expr_stmt|;
elseif|else
if|if
condition|(
name|ver
operator|==
name|QSysInfo
operator|::
name|WV_2000
condition|)
name|ret
operator|=
literal|"Win2000"
expr_stmt|;
elseif|else
if|if
condition|(
name|ver
operator|==
name|QSysInfo
operator|::
name|WV_2000
condition|)
name|ret
operator|=
literal|"Win2003"
expr_stmt|;
elseif|else
if|if
condition|(
name|ver
operator|==
name|QSysInfo
operator|::
name|WV_XP
condition|)
name|ret
operator|=
literal|"WinXP"
expr_stmt|;
elseif|else
if|if
condition|(
name|ver
operator|==
name|QSysInfo
operator|::
name|WV_VISTA
condition|)
name|ret
operator|=
literal|"WinVista"
expr_stmt|;
else|else
name|ret
operator|=
literal|"Unknown"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|"arch"
condition|)
block|{
name|SYSTEM_INFO
name|info
decl_stmt|;
name|GetSystemInfo
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|info
operator|.
name|wProcessorArchitecture
condition|)
block|{
ifdef|#
directive|ifdef
name|PROCESSOR_ARCHITECTURE_AMD64
case|case
name|PROCESSOR_ARCHITECTURE_AMD64
case|:
name|ret
operator|=
literal|"x86_64"
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|PROCESSOR_ARCHITECTURE_INTEL
case|:
name|ret
operator|=
literal|"x86"
expr_stmt|;
break|break;
case|case
name|PROCESSOR_ARCHITECTURE_IA64
case|:
ifdef|#
directive|ifdef
name|PROCESSOR_ARCHITECTURE_IA32_ON_WIN64
case|case
name|PROCESSOR_ARCHITECTURE_IA32_ON_WIN64
case|:
endif|#
directive|endif
name|ret
operator|=
literal|"IA64"
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
literal|"Unknown"
expr_stmt|;
break|break;
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|struct
name|utsname
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|uname
argument_list|(
operator|&
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|"os"
condition|)
name|ret
operator|=
name|name
operator|.
name|sysname
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
literal|"name"
condition|)
name|ret
operator|=
name|name
operator|.
name|nodename
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
literal|"version"
condition|)
name|ret
operator|=
name|name
operator|.
name|release
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
literal|"version_string"
condition|)
name|ret
operator|=
name|name
operator|.
name|version
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
literal|"arch"
condition|)
name|ret
operator|=
name|name
operator|.
name|machine
expr_stmt|;
block|}
endif|#
directive|endif
name|var
operator|=
literal|".BUILTIN.HOST."
operator|+
name|type
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"QMAKE_DIR_SEP"
argument_list|)
condition|)
block|{
if|if
condition|(
name|place
index|[
name|var
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|values
argument_list|(
literal|"DIR_SEPARATOR"
argument_list|,
name|place
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"QMAKE_EXT_OBJ"
argument_list|)
condition|)
block|{
if|if
condition|(
name|place
index|[
name|var
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|var
operator|=
literal|".BUILTIN."
operator|+
name|var
expr_stmt|;
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|Option
operator|::
name|obj_ext
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|QLatin1String
argument_list|(
literal|"QMAKE_QMAKE"
argument_list|)
condition|)
block|{
if|if
condition|(
name|place
index|[
name|var
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
operator|!
name|Option
operator|::
name|qmake_abslocation
operator|.
name|isEmpty
argument_list|()
condition|?
name|Option
operator|::
name|qmake_abslocation
else|:
name|QLibraryInfo
operator|::
name|rawLocation
argument_list|(
name|QLibraryInfo
operator|::
name|HostBinariesPath
argument_list|,
name|QLibraryInfo
operator|::
name|EffectivePaths
argument_list|)
operator|+
literal|"/qmake"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
elseif|else
if|if
condition|(
name|var
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"QMAKE_TARGET."
argument_list|)
argument_list|)
condition|)
block|{
name|QString
name|ret
decl_stmt|,
name|type
init|=
name|var
operator|.
name|mid
argument_list|(
literal|13
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|"arch"
condition|)
block|{
name|QString
name|paths
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|vcBin64
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"VCINSTALLDIR"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vcBin64
operator|.
name|endsWith
argument_list|(
literal|'\\'
argument_list|)
condition|)
name|vcBin64
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|vcBin64
operator|.
name|append
argument_list|(
literal|"bin\\amd64"
argument_list|)
expr_stmt|;
name|QString
name|vcBinX86_64
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"VCINSTALLDIR"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vcBinX86_64
operator|.
name|endsWith
argument_list|(
literal|'\\'
argument_list|)
condition|)
name|vcBinX86_64
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|vcBinX86_64
operator|.
name|append
argument_list|(
literal|"bin\\x86_amd64"
argument_list|)
expr_stmt|;
if|if
condition|(
name|paths
operator|.
name|contains
argument_list|(
name|vcBin64
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|||
name|paths
operator|.
name|contains
argument_list|(
name|vcBinX86_64
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|ret
operator|=
literal|"x86_64"
expr_stmt|;
else|else
name|ret
operator|=
literal|"x86"
expr_stmt|;
block|}
name|place
index|[
name|var
index|]
operator|=
name|QStringList
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//qDebug("REPLACE [%s]->[%s]", qPrintable(var), qPrintable(place[var].join("::")));
return|return
name|place
index|[
name|var
index|]
return|;
block|}
DECL|function|isEmpty
name|bool
name|QMakeProject
operator|::
name|isEmpty
parameter_list|(
specifier|const
name|QString
modifier|&
name|v
parameter_list|)
block|{
name|QHash
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|vars
operator|.
name|constFind
argument_list|(
name|varMap
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|it
operator|==
name|vars
operator|.
name|constEnd
argument_list|()
operator|||
name|it
operator|->
name|isEmpty
argument_list|()
return|;
block|}
name|QT_END_NAMESPACE
end_function
end_unit
