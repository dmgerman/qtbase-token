begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the qmake application of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"msvc_vcproj.h"
end_include
begin_include
include|#
directive|include
file|"option.h"
end_include
begin_include
include|#
directive|include
file|"xmloutput.h"
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qdiriterator.h>
end_include
begin_include
include|#
directive|include
file|<qcryptographichash.h>
end_include
begin_include
include|#
directive|include
file|<qregexp.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<quuid.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<qlinkedlist.h>
end_include
begin_comment
comment|//#define DEBUG_SOLUTION_GEN
end_comment
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|// Filter GUIDs (Do NOT change these!) ------------------------------
DECL|variable|_GUIDSourceFiles
specifier|const
name|char
name|_GUIDSourceFiles
index|[]
init|=
literal|"{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_GUIDHeaderFiles
specifier|const
name|char
name|_GUIDHeaderFiles
index|[]
init|=
literal|"{93995380-89BD-4b04-88EB-625FBE52EBFB}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_GUIDGeneratedFiles
specifier|const
name|char
name|_GUIDGeneratedFiles
index|[]
init|=
literal|"{71ED8ED8-ACB9-4CE9-BBE1-E00B30144E11}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_GUIDResourceFiles
specifier|const
name|char
name|_GUIDResourceFiles
index|[]
init|=
literal|"{D9D6E242-F8AF-46E4-B9FD-80ECBC20BA3E}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_GUIDLexYaccFiles
specifier|const
name|char
name|_GUIDLexYaccFiles
index|[]
init|=
literal|"{E12AE0D2-192F-4d59-BD23-7D3FA58D3183}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_GUIDTranslationFiles
specifier|const
name|char
name|_GUIDTranslationFiles
index|[]
init|=
literal|"{639EADAA-A684-42e4-A9AD-28FC9BCB8F7C}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_GUIDFormFiles
specifier|const
name|char
name|_GUIDFormFiles
index|[]
init|=
literal|"{99349809-55BA-4b9d-BF79-8FDBB0286EB3}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_GUIDExtraCompilerFiles
specifier|const
name|char
name|_GUIDExtraCompilerFiles
index|[]
init|=
literal|"{E0D8C965-CC5F-43d7-AD63-FAEF0BBC0F85}"
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|QT_END_NAMESPACE
ifdef|#
directive|ifdef
name|Q_OS_WIN32
include|#
directive|include
file|<qt_windows.h>
include|#
directive|include
file|<windows/registry_p.h>
name|QT_BEGIN_NAMESPACE
expr|struct
DECL|struct|DotNetCombo
name|DotNetCombo
block|{
DECL|member|version
name|DotNET
name|version
block|;
DECL|member|versionStr
specifier|const
name|char
operator|*
name|versionStr
block|;
DECL|member|regKey
specifier|const
name|char
operator|*
name|regKey
block|; }
DECL|variable|dotNetCombo
name|dotNetCombo
index|[]
operator|=
block|{
ifdef|#
directive|ifdef
name|Q_OS_WIN64
block|{
name|NET2013
block|,
literal|"MSVC.NET 2013 (12.0)"
block|,
literal|"Software\\Wow6432Node\\Microsoft\\VisualStudio\\12.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2013
block|,
literal|"MSVC.NET 2013 Express Edition (12.0)"
block|,
literal|"Software\\Wow6432Node\\Microsoft\\VCExpress\\12.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2012
block|,
literal|"MSVC.NET 2012 (11.0)"
block|,
literal|"Software\\Wow6432Node\\Microsoft\\VisualStudio\\11.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2012
block|,
literal|"MSVC.NET 2012 Express Edition (11.0)"
block|,
literal|"Software\\Wow6432Node\\Microsoft\\VCExpress\\11.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2010
block|,
literal|"MSVC.NET 2010 (10.0)"
block|,
literal|"Software\\Wow6432Node\\Microsoft\\VisualStudio\\10.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2010
block|,
literal|"MSVC.NET 2010 Express Edition (10.0)"
block|,
literal|"Software\\Wow6432Node\\Microsoft\\VCExpress\\10.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2008
block|,
literal|"MSVC.NET 2008 (9.0)"
block|,
literal|"Software\\Wow6432Node\\Microsoft\\VisualStudio\\9.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2008
block|,
literal|"MSVC.NET 2008 Express Edition (9.0)"
block|,
literal|"Software\\Wow6432Node\\Microsoft\\VCExpress\\9.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2005
block|,
literal|"MSVC.NET 2005 (8.0)"
block|,
literal|"Software\\Wow6432Node\\Microsoft\\VisualStudio\\8.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2005
block|,
literal|"MSVC.NET 2005 Express Edition (8.0)"
block|,
literal|"Software\\Wow6432Node\\Microsoft\\VCExpress\\8.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2003
block|,
literal|"MSVC.NET 2003 (7.1)"
block|,
literal|"Software\\Wow6432Node\\Microsoft\\VisualStudio\\7.1\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2002
block|,
literal|"MSVC.NET 2002 (7.0)"
block|,
literal|"Software\\Wow6432Node\\Microsoft\\VisualStudio\\7.0\\Setup\\VC\\ProductDir"
block|}
block|,
else|#
directive|else
block|{
name|NET2013
block|,
literal|"MSVC.NET 2013 (12.0)"
block|,
literal|"Software\\Microsoft\\VisualStudio\\12.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2013
block|,
literal|"MSVC.NET 2013 Express Edition (12.0)"
block|,
literal|"Software\\Microsoft\\VCExpress\\12.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2012
block|,
literal|"MSVC.NET 2012 (11.0)"
block|,
literal|"Software\\Microsoft\\VisualStudio\\11.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2012
block|,
literal|"MSVC.NET 2012 Express Edition (11.0)"
block|,
literal|"Software\\Microsoft\\VCExpress\\11.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2010
block|,
literal|"MSVC.NET 2010 (10.0)"
block|,
literal|"Software\\Microsoft\\VisualStudio\\10.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2010
block|,
literal|"MSVC.NET 2010 Express Edition (10.0)"
block|,
literal|"Software\\Microsoft\\VCExpress\\10.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2008
block|,
literal|"MSVC.NET 2008 (9.0)"
block|,
literal|"Software\\Microsoft\\VisualStudio\\9.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2008
block|,
literal|"MSVC.NET 2008 Express Edition (9.0)"
block|,
literal|"Software\\Microsoft\\VCExpress\\9.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2005
block|,
literal|"MSVC.NET 2005 (8.0)"
block|,
literal|"Software\\Microsoft\\VisualStudio\\8.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2005
block|,
literal|"MSVC.NET 2005 Express Edition (8.0)"
block|,
literal|"Software\\Microsoft\\VCExpress\\8.0\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2003
block|,
literal|"MSVC.NET 2003 (7.1)"
block|,
literal|"Software\\Microsoft\\VisualStudio\\7.1\\Setup\\VC\\ProductDir"
block|}
block|,
block|{
name|NET2002
block|,
literal|"MSVC.NET 2002 (7.0)"
block|,
literal|"Software\\Microsoft\\VisualStudio\\7.0\\Setup\\VC\\ProductDir"
block|}
block|,
endif|#
directive|endif
block|{
name|NETUnknown
block|,
literal|""
block|,
literal|""
block|}
block|, }
expr_stmt|;
end_expr_stmt
begin_function
name|QT_END_NAMESPACE
endif|#
directive|endif
name|QT_BEGIN_NAMESPACE
DECL|function|which_dotnet_version
name|DotNET
name|which_dotnet_version
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_OS_WIN32
return|return
name|NET2002
return|;
comment|// Always generate 7.0 versions on other platforms
else|#
directive|else
comment|// Only search for the version once
specifier|static
name|DotNET
name|current_version
init|=
name|NETUnknown
decl_stmt|;
if|if
condition|(
name|current_version
operator|!=
name|NETUnknown
condition|)
return|return
name|current_version
return|;
comment|// Fallback to .NET 2002
name|current_version
operator|=
name|NET2002
expr_stmt|;
name|QStringList
name|warnPath
decl_stmt|;
name|QHash
argument_list|<
name|DotNET
argument_list|,
name|QString
argument_list|>
name|installPaths
decl_stmt|;
name|int
name|installed
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|dotNetCombo
index|[
name|i
index|]
operator|.
name|version
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|path
init|=
name|qt_readRegistryKey
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|dotNetCombo
index|[
name|i
index|]
operator|.
name|regKey
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
operator|&&
name|installPaths
operator|.
name|value
argument_list|(
name|dotNetCombo
index|[
name|i
index|]
operator|.
name|version
argument_list|)
operator|!=
name|path
condition|)
block|{
name|installPaths
operator|.
name|insert
argument_list|(
name|dotNetCombo
index|[
name|i
index|]
operator|.
name|version
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|++
name|installed
expr_stmt|;
name|current_version
operator|=
name|dotNetCombo
index|[
name|i
index|]
operator|.
name|version
expr_stmt|;
name|warnPath
operator|+=
name|QString
argument_list|(
literal|"%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|dotNetCombo
index|[
name|i
index|]
operator|.
name|versionStr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|installed
operator|<
literal|2
condition|)
return|return
name|current_version
return|;
comment|// More than one version installed, search directory path
name|QString
name|paths
init|=
name|qgetenv
argument_list|(
literal|"PATH"
argument_list|)
decl_stmt|;
name|QStringList
name|pathlist
init|=
name|paths
operator|.
name|toLower
argument_list|()
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
decl_stmt|;
name|i
operator|=
name|installed
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|dotNetCombo
index|[
name|i
index|]
operator|.
name|version
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|productPath
init|=
name|qt_readRegistryKey
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|dotNetCombo
index|[
name|i
index|]
operator|.
name|regKey
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|productPath
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QStringList
operator|::
name|iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|pathlist
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|pathlist
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|contains
argument_list|(
name|productPath
argument_list|)
condition|)
block|{
operator|++
name|installed
expr_stmt|;
name|current_version
operator|=
name|dotNetCombo
index|[
name|i
index|]
operator|.
name|version
expr_stmt|;
name|warnPath
operator|+=
name|QString
argument_list|(
literal|"%1 in path"
argument_list|)
operator|.
name|arg
argument_list|(
name|dotNetCombo
index|[
name|i
index|]
operator|.
name|versionStr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
switch|switch
condition|(
name|installed
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|0
case|:
name|warn_msg
argument_list|(
name|WarnLogic
argument_list|,
literal|"Generator: MSVC.NET: Found more than one version of Visual Studio, but"
literal|" none in your path! Fallback to lowest version (%s)"
argument_list|,
name|warnPath
operator|.
name|join
argument_list|(
literal|", "
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warn_msg
argument_list|(
name|WarnLogic
argument_list|,
literal|"Generator: MSVC.NET: Found more than one version of Visual Studio in"
literal|" your path! Fallback to lowest version (%s)"
argument_list|,
name|warnPath
operator|.
name|join
argument_list|(
literal|", "
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|current_version
return|;
endif|#
directive|endif
block|}
end_function
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|// Flatfile Tags ----------------------------------------------------
end_comment
begin_decl_stmt
DECL|variable|_slnHeader70
specifier|const
name|char
name|_slnHeader70
index|[]
init|=
literal|"Microsoft Visual Studio Solution File, Format Version 7.00"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnHeader71
specifier|const
name|char
name|_slnHeader71
index|[]
init|=
literal|"Microsoft Visual Studio Solution File, Format Version 8.00"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnHeader80
specifier|const
name|char
name|_slnHeader80
index|[]
init|=
literal|"Microsoft Visual Studio Solution File, Format Version 9.00"
literal|"\n# Visual Studio 2005"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnHeader90
specifier|const
name|char
name|_slnHeader90
index|[]
init|=
literal|"Microsoft Visual Studio Solution File, Format Version 10.00"
literal|"\n# Visual Studio 2008"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnHeader100
specifier|const
name|char
name|_slnHeader100
index|[]
init|=
literal|"Microsoft Visual Studio Solution File, Format Version 11.00"
literal|"\n# Visual Studio 2010"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnHeader110
specifier|const
name|char
name|_slnHeader110
index|[]
init|=
literal|"Microsoft Visual Studio Solution File, Format Version 12.00"
literal|"\n# Visual Studio 2012"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnHeader120
specifier|const
name|char
name|_slnHeader120
index|[]
init|=
literal|"Microsoft Visual Studio Solution File, Format Version 12.00"
literal|"\n# Visual Studio 2013"
decl_stmt|;
end_decl_stmt
begin_comment
comment|// The following UUID _may_ change for later servicepacks...
end_comment
begin_comment
comment|// If so we need to search through the registry at
end_comment
begin_comment
comment|// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\7.0\Projects
end_comment
begin_comment
comment|// to find the subkey that contains a "PossibleProjectExtension"
end_comment
begin_comment
comment|// containing "vcproj"...
end_comment
begin_comment
comment|// Use the hardcoded value for now so projects generated on other
end_comment
begin_comment
comment|// platforms are actually usable.
end_comment
begin_decl_stmt
DECL|variable|_slnMSVCvcprojGUID
specifier|const
name|char
name|_slnMSVCvcprojGUID
index|[]
init|=
literal|"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnProjectBeg
specifier|const
name|char
name|_slnProjectBeg
index|[]
init|=
literal|"\nProject(\""
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnProjectMid
specifier|const
name|char
name|_slnProjectMid
index|[]
init|=
literal|"\") = "
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnProjectEnd
specifier|const
name|char
name|_slnProjectEnd
index|[]
init|=
literal|"\nEndProject"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnGlobalBeg
specifier|const
name|char
name|_slnGlobalBeg
index|[]
init|=
literal|"\nGlobal"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnGlobalEnd
specifier|const
name|char
name|_slnGlobalEnd
index|[]
init|=
literal|"\nEndGlobal"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnSolutionConf
specifier|const
name|char
name|_slnSolutionConf
index|[]
init|=
literal|"\n\tGlobalSection(SolutionConfiguration) = preSolution"
literal|"\n\t\tConfigName.0 = Debug|Win32"
literal|"\n\t\tConfigName.1 = Release|Win32"
literal|"\n\tEndGlobalSection"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnProjDepBeg
specifier|const
name|char
name|_slnProjDepBeg
index|[]
init|=
literal|"\n\tProjectSection(ProjectDependencies) = postProject"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnProjDepEnd
specifier|const
name|char
name|_slnProjDepEnd
index|[]
init|=
literal|"\n\tEndProjectSection"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnProjConfBeg
specifier|const
name|char
name|_slnProjConfBeg
index|[]
init|=
literal|"\n\tGlobalSection(ProjectConfiguration) = postSolution"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnProjRelConfTag1
specifier|const
name|char
name|_slnProjRelConfTag1
index|[]
init|=
literal|".Release|%1.ActiveCfg = Release|"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnProjRelConfTag2
specifier|const
name|char
name|_slnProjRelConfTag2
index|[]
init|=
literal|".Release|%1.Build.0 = Release|"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnProjDbgConfTag1
specifier|const
name|char
name|_slnProjDbgConfTag1
index|[]
init|=
literal|".Debug|%1.ActiveCfg = Debug|"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnProjDbgConfTag2
specifier|const
name|char
name|_slnProjDbgConfTag2
index|[]
init|=
literal|".Debug|%1.Build.0 = Debug|"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnProjConfEnd
specifier|const
name|char
name|_slnProjConfEnd
index|[]
init|=
literal|"\n\tEndGlobalSection"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_slnExtSections
specifier|const
name|char
name|_slnExtSections
index|[]
init|=
literal|"\n\tGlobalSection(ExtensibilityGlobals) = postSolution"
literal|"\n\tEndGlobalSection"
literal|"\n\tGlobalSection(ExtensibilityAddIns) = postSolution"
literal|"\n\tEndGlobalSection"
decl_stmt|;
end_decl_stmt
begin_comment
comment|// ------------------------------------------------------------------
end_comment
begin_constructor
DECL|function|VcprojGenerator
name|VcprojGenerator
operator|::
name|VcprojGenerator
parameter_list|()
member_init_list|:
name|Win32MakefileGenerator
argument_list|()
member_init_list|,
name|init_flag
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|is64Bit
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|projectWriter
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~VcprojGenerator
name|VcprojGenerator
operator|::
name|~
name|VcprojGenerator
parameter_list|()
block|{
operator|delete
name|projectWriter
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|writeMakefile
name|bool
name|VcprojGenerator
operator|::
name|writeMakefile
parameter_list|(
name|QTextStream
modifier|&
name|t
parameter_list|)
block|{
name|initProject
argument_list|()
expr_stmt|;
comment|// Fills the whole project with proper data
comment|// Generate solution file
if|if
condition|(
name|project
operator|->
name|first
argument_list|(
literal|"TEMPLATE"
argument_list|)
operator|==
literal|"vcsubdirs"
condition|)
block|{
if|if
condition|(
operator|!
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"build_pass"
argument_list|)
condition|)
block|{
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Generator: MSVC.NET: Writing solution file"
argument_list|)
expr_stmt|;
name|writeSubDirs
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Generator: MSVC.NET: Not writing solution file for build_pass configs"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
elseif|else
comment|// Generate single configuration project file
if|if
condition|(
name|project
operator|->
name|first
argument_list|(
literal|"TEMPLATE"
argument_list|)
operator|==
literal|"vcapp"
operator|||
name|project
operator|->
name|first
argument_list|(
literal|"TEMPLATE"
argument_list|)
operator|==
literal|"vclib"
condition|)
block|{
if|if
condition|(
operator|!
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"build_pass"
argument_list|)
condition|)
block|{
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Generator: MSVC.NET: Writing single configuration project file"
argument_list|)
expr_stmt|;
name|XmlOutput
name|xmlOut
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|projectWriter
operator|->
name|write
argument_list|(
name|xmlOut
argument_list|,
name|vcProject
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"build_pass"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|writeProjectMakefile
name|bool
name|VcprojGenerator
operator|::
name|writeProjectMakefile
parameter_list|()
block|{
name|QTextStream
name|t
argument_list|(
operator|&
name|Option
operator|::
name|output
argument_list|)
decl_stmt|;
comment|// Check if all requirements are fulfilled
if|if
condition|(
operator|!
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_FAILED_REQUIREMENTS"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Project file not generated because all requirements not met:\n\t%s\n"
argument_list|,
name|var
argument_list|(
literal|"QMAKE_FAILED_REQUIREMENTS"
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Generate project file
if|if
condition|(
name|project
operator|->
name|first
argument_list|(
literal|"TEMPLATE"
argument_list|)
operator|==
literal|"vcapp"
operator|||
name|project
operator|->
name|first
argument_list|(
literal|"TEMPLATE"
argument_list|)
operator|==
literal|"vclib"
condition|)
block|{
if|if
condition|(
operator|!
name|mergedProjects
operator|.
name|count
argument_list|()
condition|)
block|{
name|warn_msg
argument_list|(
name|WarnLogic
argument_list|,
literal|"Generator: MSVC.NET: no single configuration created, cannot output project!"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Generator: MSVC.NET: Writing project file"
argument_list|)
expr_stmt|;
name|VCProject
name|mergedProject
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mergedProjects
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|VCProjectSingleConfig
modifier|*
name|singleProject
init|=
operator|&
operator|(
name|mergedProjects
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|vcProject
operator|)
decl_stmt|;
name|mergedProject
operator|.
name|SingleProjects
operator|+=
operator|*
name|singleProject
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|singleProject
operator|->
name|ExtraCompilersFiles
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|QString
modifier|&
name|compilerName
init|=
name|singleProject
operator|->
name|ExtraCompilersFiles
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|Name
decl_stmt|;
if|if
condition|(
operator|!
name|mergedProject
operator|.
name|ExtraCompilers
operator|.
name|contains
argument_list|(
name|compilerName
argument_list|)
condition|)
name|mergedProject
operator|.
name|ExtraCompilers
operator|+=
name|compilerName
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mergedProjects
operator|.
name|count
argument_list|()
operator|>
literal|1
operator|&&
name|mergedProjects
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|vcProject
operator|.
name|Name
operator|==
name|mergedProjects
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|->
name|vcProject
operator|.
name|Name
condition|)
name|mergedProjects
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|writePrlFile
argument_list|()
expr_stmt|;
name|mergedProject
operator|.
name|Name
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"QMAKE_PROJECT_NAME"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|mergedProject
operator|.
name|Version
operator|=
name|mergedProjects
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|vcProject
operator|.
name|Version
expr_stmt|;
name|mergedProject
operator|.
name|ProjectGUID
operator|=
name|project
operator|->
name|isEmpty
argument_list|(
literal|"QMAKE_UUID"
argument_list|)
condition|?
name|getProjectUUID
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|toUpper
argument_list|()
else|:
name|project
operator|->
name|first
argument_list|(
literal|"QMAKE_UUID"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|mergedProject
operator|.
name|Keyword
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"VCPROJ_KEYWORD"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|mergedProject
operator|.
name|SccProjectName
operator|=
name|mergedProjects
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|vcProject
operator|.
name|SccProjectName
expr_stmt|;
name|mergedProject
operator|.
name|SccLocalPath
operator|=
name|mergedProjects
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|vcProject
operator|.
name|SccLocalPath
expr_stmt|;
name|mergedProject
operator|.
name|PlatformName
operator|=
name|mergedProjects
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|vcProject
operator|.
name|PlatformName
expr_stmt|;
name|XmlOutput
name|xmlOut
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|projectWriter
operator|->
name|write
argument_list|(
name|xmlOut
argument_list|,
name|mergedProject
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|project
operator|->
name|first
argument_list|(
literal|"TEMPLATE"
argument_list|)
operator|==
literal|"vcsubdirs"
condition|)
block|{
return|return
name|writeMakefile
argument_list|(
name|t
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_struct
DECL|struct|VcsolutionDepend
struct|struct
name|VcsolutionDepend
block|{
DECL|member|uuid
name|QString
name|uuid
decl_stmt|;
DECL|member|vcprojFile
DECL|member|orig_target
DECL|member|target
name|QString
name|vcprojFile
decl_stmt|,
name|orig_target
decl_stmt|,
name|target
decl_stmt|;
DECL|member|targetType
name|Target
name|targetType
decl_stmt|;
DECL|member|dependencies
name|QStringList
name|dependencies
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Disable optimization in getProjectUUID() due to a compiler  * bug in MSVC 2010 that causes ASSERT: "&other != this" in the QString  * copy constructor for non-empty file names at:  * filename.isEmpty()?project->first("QMAKE_MAKEFILE"):filename */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_CC_MSVC
end_ifdef
begin_pragma
pragma|#
directive|pragma
name|optimize
name|(
literal|"g"
name|,
name|off
name|)
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4748
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|getProjectUUID
name|QUuid
name|VcprojGenerator
operator|::
name|getProjectUUID
parameter_list|(
specifier|const
name|QString
modifier|&
name|filename
parameter_list|)
block|{
name|bool
name|validUUID
init|=
literal|true
decl_stmt|;
comment|// Read GUID from variable-space
name|QUuid
name|uuid
init|=
name|project
operator|->
name|first
argument_list|(
literal|"GUID"
argument_list|)
operator|.
name|toQString
argument_list|()
decl_stmt|;
comment|// If none, create one based on the MD5 of absolute project path
if|if
condition|(
name|uuid
operator|.
name|isNull
argument_list|()
operator|||
operator|!
name|filename
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|abspath
init|=
name|Option
operator|::
name|fixPathToLocalOS
argument_list|(
name|filename
operator|.
name|isEmpty
argument_list|()
condition|?
name|project
operator|->
name|first
argument_list|(
literal|"QMAKE_MAKEFILE"
argument_list|)
operator|.
name|toQString
argument_list|()
else|:
name|filename
argument_list|)
decl_stmt|;
name|QByteArray
name|digest
init|=
name|QCryptographicHash
operator|::
name|hash
argument_list|(
name|abspath
operator|.
name|toUtf8
argument_list|()
argument_list|,
name|QCryptographicHash
operator|::
name|Md5
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|&
name|uuid
operator|)
argument_list|,
name|digest
operator|.
name|constData
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|QUuid
argument_list|)
argument_list|)
expr_stmt|;
name|validUUID
operator|=
operator|!
name|uuid
operator|.
name|isNull
argument_list|()
expr_stmt|;
name|uuid
operator|.
name|data4
index|[
literal|0
index|]
operator|=
operator|(
name|uuid
operator|.
name|data4
index|[
literal|0
index|]
operator|&
literal|0x3F
operator|)
operator||
literal|0x80
expr_stmt|;
comment|// UV_DCE variant
name|uuid
operator|.
name|data3
operator|=
operator|(
name|uuid
operator|.
name|data3
operator|&
literal|0x0FFF
operator|)
operator||
operator|(
name|QUuid
operator|::
name|Name
operator|<<
literal|12
operator|)
expr_stmt|;
block|}
comment|// If still not valid, generate new one, and suggest adding to .pro
if|if
condition|(
name|uuid
operator|.
name|isNull
argument_list|()
operator|||
operator|!
name|validUUID
condition|)
block|{
name|uuid
operator|=
name|QUuid
operator|::
name|createUuid
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"qmake couldn't create a GUID based on filepath, and we couldn't\nfind a valid GUID in the .pro file (Consider adding\n'GUID = %s'  to the .pro file)\n"
argument_list|,
name|uuid
operator|.
name|toString
argument_list|()
operator|.
name|toUpper
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Store GUID in variable-space
name|project
operator|->
name|values
argument_list|(
literal|"GUID"
argument_list|)
operator|=
name|ProStringList
argument_list|(
name|uuid
operator|.
name|toString
argument_list|()
operator|.
name|toUpper
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|uuid
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_CC_MSVC
end_ifdef
begin_pragma
pragma|#
directive|pragma
name|optimize
name|(
literal|"g"
name|,
name|on
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|increaseUUID
name|QUuid
name|VcprojGenerator
operator|::
name|increaseUUID
parameter_list|(
specifier|const
name|QUuid
modifier|&
name|id
parameter_list|)
block|{
name|QUuid
name|result
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|qint64
name|dataFirst
init|=
operator|(
name|result
operator|.
name|data4
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|result
operator|.
name|data4
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|result
operator|.
name|data4
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|result
operator|.
name|data4
index|[
literal|3
index|]
decl_stmt|;
name|qint64
name|dataLast
init|=
operator|(
name|result
operator|.
name|data4
index|[
literal|4
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|result
operator|.
name|data4
index|[
literal|5
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|result
operator|.
name|data4
index|[
literal|6
index|]
operator|<<
literal|8
operator|)
operator|+
name|result
operator|.
name|data4
index|[
literal|7
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dataLast
operator|++
operator|)
condition|)
name|dataFirst
operator|++
expr_stmt|;
name|result
operator|.
name|data4
index|[
literal|0
index|]
operator|=
name|uchar
argument_list|(
operator|(
name|dataFirst
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|result
operator|.
name|data4
index|[
literal|1
index|]
operator|=
name|uchar
argument_list|(
operator|(
name|dataFirst
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|result
operator|.
name|data4
index|[
literal|2
index|]
operator|=
name|uchar
argument_list|(
operator|(
name|dataFirst
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|result
operator|.
name|data4
index|[
literal|3
index|]
operator|=
name|uchar
argument_list|(
name|dataFirst
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|result
operator|.
name|data4
index|[
literal|4
index|]
operator|=
name|uchar
argument_list|(
operator|(
name|dataLast
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|result
operator|.
name|data4
index|[
literal|5
index|]
operator|=
name|uchar
argument_list|(
operator|(
name|dataLast
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|result
operator|.
name|data4
index|[
literal|6
index|]
operator|=
name|uchar
argument_list|(
operator|(
name|dataLast
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|result
operator|.
name|data4
index|[
literal|7
index|]
operator|=
name|uchar
argument_list|(
name|dataLast
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|collectDependencies
name|ProStringList
name|VcprojGenerator
operator|::
name|collectDependencies
parameter_list|(
name|QMakeProject
modifier|*
name|proj
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
modifier|&
name|projLookup
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
modifier|&
name|projGuids
parameter_list|,
name|QHash
argument_list|<
name|VcsolutionDepend
modifier|*
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|extraSubdirs
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|VcsolutionDepend
modifier|*
argument_list|>
modifier|&
name|solution_depends
parameter_list|,
name|QList
argument_list|<
name|VcsolutionDepend
modifier|*
argument_list|>
modifier|&
name|solution_cleanup
parameter_list|,
name|QTextStream
modifier|&
name|t
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|ProStringList
argument_list|>
modifier|&
name|subdirProjectLookup
parameter_list|,
specifier|const
name|ProStringList
modifier|&
name|allDependencies
parameter_list|)
block|{
name|QLinkedList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|ProStringList
argument_list|>
argument_list|>
name|collectedSubdirs
decl_stmt|;
name|ProStringList
name|tmp_proj_subdirs
init|=
name|proj
operator|->
name|values
argument_list|(
literal|"SUBDIRS"
argument_list|)
decl_stmt|;
name|ProStringList
name|projectsInProject
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|tmp_proj_subdirs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|x
control|)
block|{
name|ProString
name|tmpdir
init|=
name|tmp_proj_subdirs
operator|.
name|at
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|ProKey
name|tmpdirConfig
argument_list|(
name|tmpdir
operator|+
literal|".CONFIG"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|proj
operator|->
name|isEmpty
argument_list|(
name|tmpdirConfig
argument_list|)
condition|)
block|{
specifier|const
name|ProStringList
name|config
init|=
name|proj
operator|->
name|values
argument_list|(
name|tmpdirConfig
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|.
name|contains
argument_list|(
name|QStringLiteral
argument_list|(
literal|"no_default_target"
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|// Ignore this sub-dir
block|}
specifier|const
name|ProKey
name|fkey
argument_list|(
name|tmpdir
operator|+
literal|".file"
argument_list|)
decl_stmt|;
specifier|const
name|ProKey
name|skey
argument_list|(
name|tmpdir
operator|+
literal|".subdir"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|proj
operator|->
name|isEmpty
argument_list|(
name|fkey
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|proj
operator|->
name|isEmpty
argument_list|(
name|skey
argument_list|)
condition|)
name|warn_msg
argument_list|(
name|WarnLogic
argument_list|,
literal|"Cannot assign both file and subdir for subdir %s"
argument_list|,
name|tmpdir
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|tmpdir
operator|=
name|proj
operator|->
name|first
argument_list|(
name|fkey
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|proj
operator|->
name|isEmpty
argument_list|(
name|skey
argument_list|)
condition|)
block|{
name|tmpdir
operator|=
name|proj
operator|->
name|first
argument_list|(
name|skey
argument_list|)
expr_stmt|;
block|}
name|projectsInProject
operator|.
name|append
argument_list|(
name|tmpdir
argument_list|)
expr_stmt|;
name|collectedSubdirs
operator|.
name|append
argument_list|(
name|qMakePair
argument_list|(
name|tmpdir
operator|.
name|toQString
argument_list|()
argument_list|,
name|proj
operator|->
name|values
argument_list|(
name|ProKey
argument_list|(
name|tmp_proj_subdirs
operator|.
name|at
argument_list|(
name|x
argument_list|)
operator|+
literal|".depends"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|projLookup
operator|.
name|insert
argument_list|(
name|tmp_proj_subdirs
operator|.
name|at
argument_list|(
name|x
argument_list|)
operator|.
name|toQString
argument_list|()
argument_list|,
name|tmpdir
operator|.
name|toQString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QLinkedListIterator
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|ProStringList
argument_list|>
argument_list|>
name|collectedIt
argument_list|(
name|collectedSubdirs
argument_list|)
decl_stmt|;
while|while
condition|(
name|collectedIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|QPair
argument_list|<
name|QString
argument_list|,
name|ProStringList
argument_list|>
name|subdir
init|=
name|collectedIt
operator|.
name|next
argument_list|()
decl_stmt|;
name|QString
name|profile
init|=
name|subdir
operator|.
name|first
decl_stmt|;
name|QFileInfo
name|fi
argument_list|(
name|fileInfo
argument_list|(
name|Option
operator|::
name|fixPathToLocalOS
argument_list|(
name|profile
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|fi
operator|.
name|isDir
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|profile
operator|.
name|endsWith
argument_list|(
name|Option
operator|::
name|dir_sep
argument_list|)
condition|)
name|profile
operator|+=
name|Option
operator|::
name|dir_sep
expr_stmt|;
name|profile
operator|+=
name|fi
operator|.
name|baseName
argument_list|()
operator|+
name|Option
operator|::
name|pro_ext
expr_stmt|;
name|QString
name|profileKey
init|=
name|fi
operator|.
name|absoluteFilePath
argument_list|()
decl_stmt|;
name|fi
operator|=
name|QFileInfo
argument_list|(
name|fileInfo
argument_list|(
name|Option
operator|::
name|fixPathToLocalOS
argument_list|(
name|profile
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fi
operator|.
name|exists
argument_list|()
condition|)
continue|continue;
name|projLookup
operator|.
name|insert
argument_list|(
name|profileKey
argument_list|,
name|fi
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QString
name|oldpwd
init|=
name|qmake_getpwd
argument_list|()
decl_stmt|;
name|QString
name|oldoutpwd
init|=
name|Option
operator|::
name|output_dir
decl_stmt|;
name|QMakeProject
name|tmp_proj
decl_stmt|;
name|QString
name|dir
init|=
name|fi
operator|.
name|absolutePath
argument_list|()
decl_stmt|,
name|fn
init|=
name|fi
operator|.
name|fileName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dir
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|qmake_setpwd
argument_list|(
name|dir
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot find directory: %s"
argument_list|,
name|dir
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Option
operator|::
name|output_dir
operator|=
name|Option
operator|::
name|globals
operator|->
name|shadowedPath
argument_list|(
name|QDir
operator|::
name|cleanPath
argument_list|(
name|fi
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_proj
operator|.
name|read
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|// Check if all requirements are fulfilled
if|if
condition|(
operator|!
name|tmp_proj
operator|.
name|isEmpty
argument_list|(
literal|"QMAKE_FAILED_REQUIREMENTS"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Project file(%s) not added to Solution because all requirements not met:\n\t%s\n"
argument_list|,
name|fn
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|tmp_proj
operator|.
name|values
argument_list|(
literal|"QMAKE_FAILED_REQUIREMENTS"
argument_list|)
operator|.
name|join
argument_list|(
literal|" "
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|qmake_setpwd
argument_list|(
name|oldpwd
argument_list|)
expr_stmt|;
name|Option
operator|::
name|output_dir
operator|=
name|oldoutpwd
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tmp_proj
operator|.
name|first
argument_list|(
literal|"TEMPLATE"
argument_list|)
operator|==
literal|"vcsubdirs"
condition|)
block|{
name|ProStringList
name|tmpList
init|=
name|collectDependencies
argument_list|(
operator|&
name|tmp_proj
argument_list|,
name|projLookup
argument_list|,
name|projGuids
argument_list|,
name|extraSubdirs
argument_list|,
name|solution_depends
argument_list|,
name|solution_cleanup
argument_list|,
name|t
argument_list|,
name|subdirProjectLookup
argument_list|,
name|subdir
operator|.
name|second
argument_list|)
decl_stmt|;
name|subdirProjectLookup
operator|.
name|insert
argument_list|(
name|subdir
operator|.
name|first
argument_list|,
name|tmpList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ProStringList
name|tmpList
decl_stmt|;
name|tmpList
operator|+=
name|subdir
operator|.
name|second
expr_stmt|;
name|tmpList
operator|+=
name|allDependencies
expr_stmt|;
name|QPair
argument_list|<
name|QString
argument_list|,
name|ProStringList
argument_list|>
name|val
init|=
name|qMakePair
argument_list|(
name|fi
operator|.
name|absoluteFilePath
argument_list|()
argument_list|,
name|tmpList
argument_list|)
decl_stmt|;
comment|// Initialize a 'fake' project to get the correct variables
comment|// and to be able to extract all the dependencies
name|Option
operator|::
name|QMAKE_MODE
name|old_mode
init|=
name|Option
operator|::
name|qmake_mode
decl_stmt|;
name|Option
operator|::
name|qmake_mode
operator|=
name|Option
operator|::
name|QMAKE_GENERATE_NOTHING
expr_stmt|;
name|VcprojGenerator
name|tmp_vcproj
decl_stmt|;
name|tmp_vcproj
operator|.
name|setNoIO
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|tmp_vcproj
operator|.
name|setProjectFile
argument_list|(
operator|&
name|tmp_proj
argument_list|)
expr_stmt|;
name|Option
operator|::
name|qmake_mode
operator|=
name|old_mode
expr_stmt|;
comment|// We assume project filename is [QMAKE_PROJECT_NAME].vcproj
name|QString
name|vcproj
init|=
name|unescapeFilePath
argument_list|(
name|tmp_vcproj
operator|.
name|project
operator|->
name|first
argument_list|(
literal|"QMAKE_PROJECT_NAME"
argument_list|)
operator|+
name|project
operator|->
name|first
argument_list|(
literal|"VCPROJ_EXTENSION"
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|vcprojDir
init|=
name|qmake_getpwd
argument_list|()
decl_stmt|;
comment|// If file doesn't exsist, then maybe the users configuration
comment|// doesn't allow it to be created. Skip to next...
if|if
condition|(
operator|!
name|exists
argument_list|(
name|vcprojDir
operator|+
name|Option
operator|::
name|dir_sep
operator|+
name|vcproj
argument_list|)
condition|)
block|{
comment|// Try to find the directory which fits relative
comment|// to the output path, which represents the shadow
comment|// path in case we are shadow building
name|QStringList
name|list
init|=
name|fi
operator|.
name|path
argument_list|()
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|tmpDir
init|=
name|QFileInfo
argument_list|(
name|Option
operator|::
name|output
argument_list|)
operator|.
name|path
argument_list|()
operator|+
name|Option
operator|::
name|dir_sep
decl_stmt|;
name|bool
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QString
name|curr
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
name|curr
operator|+=
name|list
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|+
name|Option
operator|::
name|dir_sep
expr_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|tmpDir
operator|+
name|curr
operator|+
name|vcproj
argument_list|)
condition|)
block|{
name|vcprojDir
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|tmpDir
operator|+
name|curr
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|warn_msg
argument_list|(
name|WarnLogic
argument_list|,
literal|"Ignored (not found) '%s'"
argument_list|,
name|QString
argument_list|(
name|vcprojDir
operator|+
name|Option
operator|::
name|dir_sep
operator|+
name|vcproj
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|nextfile
goto|;
comment|// # Dirty!
block|}
block|}
name|VcsolutionDepend
modifier|*
name|newDep
init|=
operator|new
name|VcsolutionDepend
decl_stmt|;
name|newDep
operator|->
name|vcprojFile
operator|=
name|vcprojDir
operator|+
name|Option
operator|::
name|dir_sep
operator|+
name|vcproj
expr_stmt|;
name|newDep
operator|->
name|orig_target
operator|=
name|unescapeFilePath
argument_list|(
name|tmp_proj
operator|.
name|first
argument_list|(
literal|"QMAKE_ORIG_TARGET"
argument_list|)
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|newDep
operator|->
name|target
operator|=
name|tmp_proj
operator|.
name|first
argument_list|(
literal|"MSVCPROJ_TARGET"
argument_list|)
operator|.
name|toQString
argument_list|()
operator|.
name|section
argument_list|(
name|Option
operator|::
name|dir_sep
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newDep
operator|->
name|targetType
operator|=
name|tmp_vcproj
operator|.
name|projectTarget
expr_stmt|;
name|newDep
operator|->
name|uuid
operator|=
name|tmp_proj
operator|.
name|isEmpty
argument_list|(
literal|"QMAKE_UUID"
argument_list|)
condition|?
name|getProjectUUID
argument_list|(
name|Option
operator|::
name|fixPathToLocalOS
argument_list|(
name|vcprojDir
operator|+
name|QDir
operator|::
name|separator
argument_list|()
operator|+
name|vcproj
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|toUpper
argument_list|()
else|:
name|tmp_proj
operator|.
name|first
argument_list|(
literal|"QMAKE_UUID"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
comment|// We want to store it as the .lib name.
if|if
condition|(
name|newDep
operator|->
name|target
operator|.
name|endsWith
argument_list|(
literal|".dll"
argument_list|)
condition|)
name|newDep
operator|->
name|target
operator|=
name|newDep
operator|->
name|target
operator|.
name|left
argument_list|(
name|newDep
operator|->
name|target
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|)
operator|+
literal|"lib"
expr_stmt|;
name|projGuids
operator|.
name|insert
argument_list|(
name|val
operator|.
name|first
argument_list|,
name|newDep
operator|->
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|second
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|const
name|ProStringList
name|depends
init|=
name|val
operator|.
name|second
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|ProString
modifier|&
name|dep
decl|,
name|depends
control|)
block|{
name|QString
name|depend
init|=
name|dep
operator|.
name|toQString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|projGuids
index|[
name|depend
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newDep
operator|->
name|dependencies
operator|<<
name|projGuids
index|[
name|depend
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subdirProjectLookup
index|[
name|projLookup
index|[
name|depend
index|]
index|]
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ProStringList
name|tmpLst
init|=
name|subdirProjectLookup
index|[
name|projLookup
index|[
name|depend
index|]
index|]
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|ProString
modifier|&
name|tDep
decl|,
name|tmpLst
control|)
block|{
name|QString
name|tmpDep
init|=
name|tDep
operator|.
name|toQString
argument_list|()
decl_stmt|;
name|newDep
operator|->
name|dependencies
operator|<<
name|projGuids
index|[
name|projLookup
index|[
name|tmpDep
index|]
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|QStringList
name|dependencies
init|=
name|val
operator|.
name|second
operator|.
name|toQStringList
argument_list|()
decl_stmt|;
name|extraSubdirs
operator|.
name|insert
argument_list|(
name|newDep
argument_list|,
name|dependencies
argument_list|)
expr_stmt|;
name|newDep
operator|->
name|dependencies
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// All ActiveQt Server projects are dependent on idc.exe
if|if
condition|(
name|tmp_proj
operator|.
name|values
argument_list|(
literal|"CONFIG"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"qaxserver"
argument_list|)
condition|)
name|newDep
operator|->
name|dependencies
operator|<<
literal|"idc.exe"
expr_stmt|;
comment|// Add all unknown libs to the deps
name|QStringList
name|where
init|=
name|QStringList
argument_list|()
operator|<<
literal|"QMAKE_LIBS"
operator|<<
literal|"QMAKE_LIBS_PRIVATE"
decl_stmt|;
if|if
condition|(
operator|!
name|tmp_proj
operator|.
name|isEmpty
argument_list|(
literal|"QMAKE_INTERNAL_PRL_LIBS"
argument_list|)
condition|)
name|where
operator|=
name|tmp_proj
operator|.
name|values
argument_list|(
literal|"QMAKE_INTERNAL_PRL_LIBS"
argument_list|)
operator|.
name|toQStringList
argument_list|()
expr_stmt|;
for|for
control|(
name|QStringList
operator|::
name|ConstIterator
name|wit
init|=
name|where
operator|.
name|begin
argument_list|()
init|;
name|wit
operator|!=
name|where
operator|.
name|end
argument_list|()
condition|;
operator|++
name|wit
control|)
block|{
specifier|const
name|ProStringList
modifier|&
name|l
init|=
name|tmp_proj
operator|.
name|values
argument_list|(
name|ProKey
argument_list|(
operator|*
name|wit
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|ProStringList
operator|::
name|ConstIterator
name|it
init|=
name|l
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|l
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QString
name|opt
init|=
operator|(
operator|*
name|it
operator|)
operator|.
name|toQString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|opt
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
comment|// Not a switch
name|opt
operator|!=
name|newDep
operator|->
name|target
operator|&&
comment|// Not self
name|opt
operator|!=
literal|"opengl32.lib"
operator|&&
comment|// We don't care about these libs
name|opt
operator|!=
literal|"glu32.lib"
operator|&&
comment|// to make depgen alittle faster
name|opt
operator|!=
literal|"kernel32.lib"
operator|&&
name|opt
operator|!=
literal|"user32.lib"
operator|&&
name|opt
operator|!=
literal|"gdi32.lib"
operator|&&
name|opt
operator|!=
literal|"comdlg32.lib"
operator|&&
name|opt
operator|!=
literal|"advapi32.lib"
operator|&&
name|opt
operator|!=
literal|"shell32.lib"
operator|&&
name|opt
operator|!=
literal|"ole32.lib"
operator|&&
name|opt
operator|!=
literal|"oleaut32.lib"
operator|&&
name|opt
operator|!=
literal|"uuid.lib"
operator|&&
name|opt
operator|!=
literal|"imm32.lib"
operator|&&
name|opt
operator|!=
literal|"winmm.lib"
operator|&&
name|opt
operator|!=
literal|"wsock32.lib"
operator|&&
name|opt
operator|!=
literal|"ws2_32.lib"
operator|&&
name|opt
operator|!=
literal|"winspool.lib"
operator|&&
name|opt
operator|!=
literal|"delayimp.lib"
condition|)
block|{
name|newDep
operator|->
name|dependencies
operator|<<
name|opt
operator|.
name|section
argument_list|(
name|Option
operator|::
name|dir_sep
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_SOLUTION_GEN
name|qDebug
argument_list|(
literal|"Deps for %20s: [%s]"
argument_list|,
name|newDep
operator|->
name|target
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|newDep
operator|->
name|dependencies
operator|.
name|join
argument_list|(
literal|" :: "
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|solution_cleanup
operator|.
name|append
argument_list|(
name|newDep
argument_list|)
expr_stmt|;
name|solution_depends
operator|.
name|insert
argument_list|(
name|newDep
operator|->
name|target
argument_list|,
name|newDep
argument_list|)
expr_stmt|;
block|}
name|nextfile
label|:
name|qmake_setpwd
argument_list|(
name|oldpwd
argument_list|)
expr_stmt|;
name|Option
operator|::
name|output_dir
operator|=
name|oldoutpwd
expr_stmt|;
block|}
block|}
block|}
return|return
name|projectsInProject
return|;
block|}
end_function
begin_function
DECL|function|writeSubDirs
name|void
name|VcprojGenerator
operator|::
name|writeSubDirs
parameter_list|(
name|QTextStream
modifier|&
name|t
parameter_list|)
block|{
comment|// Check if all requirements are fulfilled
if|if
condition|(
operator|!
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_FAILED_REQUIREMENTS"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Project file not generated because all requirements not met:\n\t%s\n"
argument_list|,
name|var
argument_list|(
literal|"QMAKE_FAILED_REQUIREMENTS"
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|which_dotnet_version
argument_list|()
condition|)
block|{
case|case
name|NET2013
case|:
name|t
operator|<<
name|_slnHeader120
expr_stmt|;
break|break;
case|case
name|NET2012
case|:
name|t
operator|<<
name|_slnHeader110
expr_stmt|;
break|break;
case|case
name|NET2010
case|:
name|t
operator|<<
name|_slnHeader100
expr_stmt|;
break|break;
case|case
name|NET2008
case|:
name|t
operator|<<
name|_slnHeader90
expr_stmt|;
break|break;
case|case
name|NET2005
case|:
name|t
operator|<<
name|_slnHeader80
expr_stmt|;
break|break;
case|case
name|NET2003
case|:
name|t
operator|<<
name|_slnHeader71
expr_stmt|;
break|break;
case|case
name|NET2002
case|:
name|t
operator|<<
name|_slnHeader70
expr_stmt|;
break|break;
default|default:
name|t
operator|<<
name|_slnHeader70
expr_stmt|;
name|warn_msg
argument_list|(
name|WarnLogic
argument_list|,
literal|"Generator: MSVC.NET: Unknown version (%d) of MSVC detected for .sln"
argument_list|,
name|which_dotnet_version
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|QHash
argument_list|<
name|QString
argument_list|,
name|VcsolutionDepend
modifier|*
argument_list|>
name|solution_depends
decl_stmt|;
name|QList
argument_list|<
name|VcsolutionDepend
modifier|*
argument_list|>
name|solution_cleanup
decl_stmt|;
comment|// Make sure that all temp projects are configured
comment|// for release so that the depends are created
comment|// without the debug<lib>dxxx.lib name mangling
name|QString
name|old_after_vars
init|=
name|Option
operator|::
name|globals
operator|->
name|postcmds
decl_stmt|;
name|Option
operator|::
name|globals
operator|->
name|postcmds
operator|.
name|append
argument_list|(
literal|"\nCONFIG+=release"
argument_list|)
expr_stmt|;
name|QHash
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|profileLookup
decl_stmt|;
name|QHash
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|projGuids
decl_stmt|;
name|QHash
argument_list|<
name|VcsolutionDepend
modifier|*
argument_list|,
name|QStringList
argument_list|>
name|extraSubdirs
decl_stmt|;
name|QHash
argument_list|<
name|QString
argument_list|,
name|ProStringList
argument_list|>
name|subdirProjectLookup
decl_stmt|;
name|collectDependencies
argument_list|(
name|project
argument_list|,
name|profileLookup
argument_list|,
name|projGuids
argument_list|,
name|extraSubdirs
argument_list|,
name|solution_depends
argument_list|,
name|solution_cleanup
argument_list|,
name|t
argument_list|,
name|subdirProjectLookup
argument_list|)
expr_stmt|;
comment|// write out projects
for|for
control|(
name|QList
argument_list|<
name|VcsolutionDepend
operator|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|solution_cleanup
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|solution_cleanup
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|t
operator|<<
name|_slnProjectBeg
operator|<<
name|_slnMSVCvcprojGUID
operator|<<
name|_slnProjectMid
operator|<<
literal|"\""
operator|<<
operator|(
operator|*
name|it
operator|)
operator|->
name|orig_target
operator|<<
literal|"\", \""
operator|<<
operator|(
operator|*
name|it
operator|)
operator|->
name|vcprojFile
operator|<<
literal|"\", \""
operator|<<
operator|(
operator|*
name|it
operator|)
operator|->
name|uuid
operator|<<
literal|"\""
expr_stmt|;
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Project %s has dependencies: %s"
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|->
name|target
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|->
name|dependencies
operator|.
name|join
argument_list|(
literal|" "
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|bool
name|hasDependency
init|=
literal|false
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|iterator
name|dit
init|=
operator|(
operator|*
name|it
operator|)
operator|->
name|dependencies
operator|.
name|begin
argument_list|()
init|;
name|dit
operator|!=
operator|(
operator|*
name|it
operator|)
operator|->
name|dependencies
operator|.
name|end
argument_list|()
condition|;
operator|++
name|dit
control|)
block|{
if|if
condition|(
name|VcsolutionDepend
modifier|*
name|vc
init|=
name|solution_depends
index|[
operator|*
name|dit
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|hasDependency
condition|)
block|{
name|hasDependency
operator|=
literal|true
expr_stmt|;
name|t
operator|<<
name|_slnProjDepBeg
expr_stmt|;
block|}
name|t
operator|<<
literal|"\n\t\t"
operator|<<
name|vc
operator|->
name|uuid
operator|<<
literal|" = "
operator|<<
name|vc
operator|->
name|uuid
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasDependency
condition|)
name|t
operator|<<
name|_slnProjDepEnd
expr_stmt|;
name|t
operator|<<
name|_slnProjectEnd
expr_stmt|;
block|}
name|t
operator|<<
name|_slnGlobalBeg
expr_stmt|;
name|QHashIterator
argument_list|<
name|VcsolutionDepend
modifier|*
argument_list|,
name|QStringList
argument_list|>
name|extraIt
argument_list|(
name|extraSubdirs
argument_list|)
decl_stmt|;
while|while
condition|(
name|extraIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|extraIt
operator|.
name|next
argument_list|()
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|depend
decl|,
name|extraIt
operator|.
name|value
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|projGuids
index|[
name|depend
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|extraIt
operator|.
name|key
argument_list|()
operator|->
name|dependencies
operator|<<
name|projGuids
index|[
name|depend
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|profileLookup
index|[
name|depend
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|projGuids
index|[
name|profileLookup
index|[
name|depend
index|]
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
name|extraIt
operator|.
name|key
argument_list|()
operator|->
name|dependencies
operator|<<
name|projGuids
index|[
name|profileLookup
index|[
name|depend
index|]
index|]
expr_stmt|;
block|}
block|}
block|}
name|QString
name|slnConf
init|=
name|_slnSolutionConf
decl_stmt|;
if|if
condition|(
operator|!
name|project
operator|->
name|isEmpty
argument_list|(
literal|"CE_SDK"
argument_list|)
operator|&&
operator|!
name|project
operator|->
name|isEmpty
argument_list|(
literal|"CE_ARCH"
argument_list|)
condition|)
block|{
name|QString
name|slnPlatform
init|=
name|QString
argument_list|(
literal|"|"
argument_list|)
operator|+
name|project
operator|->
name|values
argument_list|(
literal|"CE_SDK"
argument_list|)
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
operator|+
literal|" ("
operator|+
name|project
operator|->
name|first
argument_list|(
literal|"CE_ARCH"
argument_list|)
operator|+
literal|")"
decl_stmt|;
name|slnConf
operator|.
name|replace
argument_list|(
name|QString
argument_list|(
literal|"|Win32"
argument_list|)
argument_list|,
name|slnPlatform
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is64Bit
condition|)
block|{
name|slnConf
operator|.
name|replace
argument_list|(
name|QString
argument_list|(
literal|"|Win32"
argument_list|)
argument_list|,
literal|"|x64"
argument_list|)
expr_stmt|;
block|}
name|t
operator|<<
name|slnConf
expr_stmt|;
comment|// Restore previous after_user_var options
name|Option
operator|::
name|globals
operator|->
name|postcmds
operator|=
name|old_after_vars
expr_stmt|;
name|t
operator|<<
name|_slnProjConfBeg
expr_stmt|;
for|for
control|(
name|QList
argument_list|<
name|VcsolutionDepend
operator|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|solution_cleanup
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|solution_cleanup
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QString
name|platform
init|=
name|is64Bit
condition|?
literal|"x64"
else|:
literal|"Win32"
decl_stmt|;
name|QString
name|xplatform
init|=
name|platform
decl_stmt|;
if|if
condition|(
operator|!
name|project
operator|->
name|isEmpty
argument_list|(
literal|"CE_SDK"
argument_list|)
operator|&&
operator|!
name|project
operator|->
name|isEmpty
argument_list|(
literal|"CE_ARCH"
argument_list|)
condition|)
name|xplatform
operator|=
name|project
operator|->
name|values
argument_list|(
literal|"CE_SDK"
argument_list|)
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
operator|+
literal|" ("
operator|+
name|project
operator|->
name|first
argument_list|(
literal|"CE_ARCH"
argument_list|)
operator|+
literal|")"
expr_stmt|;
if|if
condition|(
operator|!
name|project
operator|->
name|isHostBuild
argument_list|()
condition|)
name|platform
operator|=
name|xplatform
expr_stmt|;
name|t
operator|<<
literal|"\n\t\t"
operator|<<
operator|(
operator|*
name|it
operator|)
operator|->
name|uuid
operator|<<
name|QString
argument_list|(
name|_slnProjDbgConfTag1
argument_list|)
operator|.
name|arg
argument_list|(
name|xplatform
argument_list|)
operator|<<
name|platform
expr_stmt|;
name|t
operator|<<
literal|"\n\t\t"
operator|<<
operator|(
operator|*
name|it
operator|)
operator|->
name|uuid
operator|<<
name|QString
argument_list|(
name|_slnProjDbgConfTag2
argument_list|)
operator|.
name|arg
argument_list|(
name|xplatform
argument_list|)
operator|<<
name|platform
expr_stmt|;
name|t
operator|<<
literal|"\n\t\t"
operator|<<
operator|(
operator|*
name|it
operator|)
operator|->
name|uuid
operator|<<
name|QString
argument_list|(
name|_slnProjRelConfTag1
argument_list|)
operator|.
name|arg
argument_list|(
name|xplatform
argument_list|)
operator|<<
name|platform
expr_stmt|;
name|t
operator|<<
literal|"\n\t\t"
operator|<<
operator|(
operator|*
name|it
operator|)
operator|->
name|uuid
operator|<<
name|QString
argument_list|(
name|_slnProjRelConfTag2
argument_list|)
operator|.
name|arg
argument_list|(
name|xplatform
argument_list|)
operator|<<
name|platform
expr_stmt|;
block|}
name|t
operator|<<
name|_slnProjConfEnd
expr_stmt|;
name|t
operator|<<
name|_slnExtSections
expr_stmt|;
name|t
operator|<<
name|_slnGlobalEnd
expr_stmt|;
while|while
condition|(
operator|!
name|solution_cleanup
operator|.
name|isEmpty
argument_list|()
condition|)
operator|delete
name|solution_cleanup
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// ------------------------------------------------------------------------------------------------
end_comment
begin_comment
comment|// ------------------------------------------------------------------------------------------------
end_comment
begin_function
DECL|function|hasBuiltinCompiler
name|bool
name|VcprojGenerator
operator|::
name|hasBuiltinCompiler
parameter_list|(
specifier|const
name|QString
modifier|&
name|file
parameter_list|)
block|{
comment|// Source files
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Option
operator|::
name|cpp_ext
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|file
operator|.
name|endsWith
argument_list|(
name|Option
operator|::
name|cpp_ext
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|true
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Option
operator|::
name|c_ext
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|file
operator|.
name|endsWith
argument_list|(
name|Option
operator|::
name|c_ext
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|file
operator|.
name|endsWith
argument_list|(
literal|".rc"
argument_list|)
operator|||
name|file
operator|.
name|endsWith
argument_list|(
literal|".idl"
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|VcprojGenerator
operator|::
name|init
parameter_list|()
block|{
if|if
condition|(
name|init_flag
condition|)
return|return;
name|init_flag
operator|=
literal|true
expr_stmt|;
name|is64Bit
operator|=
operator|(
name|project
operator|->
name|first
argument_list|(
literal|"QMAKE_TARGET.arch"
argument_list|)
operator|==
literal|"x86_64"
operator|)
expr_stmt|;
name|projectWriter
operator|=
name|createProjectWriter
argument_list|()
expr_stmt|;
if|if
condition|(
name|project
operator|->
name|first
argument_list|(
literal|"TEMPLATE"
argument_list|)
operator|==
literal|"vcsubdirs"
condition|)
comment|//too much work for subdirs
return|return;
name|debug_msg
argument_list|(
literal|1
argument_list|,
literal|"Generator: MSVC.NET: Initializing variables"
argument_list|)
expr_stmt|;
comment|// this should probably not be here, but I'm using it to wrap the .t files
if|if
condition|(
name|project
operator|->
name|first
argument_list|(
literal|"TEMPLATE"
argument_list|)
operator|==
literal|"vcapp"
condition|)
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_APP_FLAG"
argument_list|)
operator|.
name|append
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|project
operator|->
name|first
argument_list|(
literal|"TEMPLATE"
argument_list|)
operator|==
literal|"vclib"
condition|)
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_LIB_FLAG"
argument_list|)
operator|.
name|append
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_L_FLAG"
argument_list|)
operator|<<
literal|"/LIBPATH:"
expr_stmt|;
name|processVars
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|project
operator|->
name|values
argument_list|(
literal|"VERSION"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|version
init|=
name|project
operator|->
name|values
argument_list|(
literal|"VERSION"
argument_list|)
index|[
literal|0
index|]
operator|.
name|toQString
argument_list|()
decl_stmt|;
name|int
name|firstDot
init|=
name|version
operator|.
name|indexOf
argument_list|(
literal|"."
argument_list|)
decl_stmt|;
name|QString
name|major
init|=
name|version
operator|.
name|left
argument_list|(
name|firstDot
argument_list|)
decl_stmt|;
name|QString
name|minor
init|=
name|version
operator|.
name|right
argument_list|(
name|version
operator|.
name|length
argument_list|()
operator|-
name|firstDot
operator|-
literal|1
argument_list|)
decl_stmt|;
name|minor
operator|.
name|replace
argument_list|(
name|QRegExp
argument_list|(
literal|"\\."
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_LFLAGS"
argument_list|)
operator|.
name|append
argument_list|(
literal|"/VERSION:"
operator|+
name|major
operator|+
literal|"."
operator|+
name|minor
argument_list|)
expr_stmt|;
block|}
name|MakefileGenerator
operator|::
name|init
argument_list|()
expr_stmt|;
name|initOld
argument_list|()
expr_stmt|;
comment|// Currently calling old DSP code to set variables. CLEAN UP!
comment|// Figure out what we're trying to build
if|if
condition|(
name|project
operator|->
name|first
argument_list|(
literal|"TEMPLATE"
argument_list|)
operator|==
literal|"vcapp"
condition|)
block|{
name|projectTarget
operator|=
name|Application
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|project
operator|->
name|first
argument_list|(
literal|"TEMPLATE"
argument_list|)
operator|==
literal|"vclib"
condition|)
block|{
if|if
condition|(
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"staticlib"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|project
operator|->
name|values
argument_list|(
literal|"RES_FILE"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_LIBS"
argument_list|)
operator|+=
name|escapeFilePaths
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"RES_FILE"
argument_list|)
argument_list|)
expr_stmt|;
name|projectTarget
operator|=
name|StaticLib
expr_stmt|;
block|}
else|else
name|projectTarget
operator|=
name|SharedLib
expr_stmt|;
block|}
comment|// Setup PCH variables
name|precompH
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"PRECOMPILED_HEADER"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|precompCPP
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"PRECOMPILED_SOURCE"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|usePCH
operator|=
operator|!
name|precompH
operator|.
name|isEmpty
argument_list|()
operator|&&
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"precompile_header"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usePCH
condition|)
block|{
name|precompHFilename
operator|=
name|fileInfo
argument_list|(
name|precompH
argument_list|)
operator|.
name|fileName
argument_list|()
expr_stmt|;
comment|// Created files
name|QString
name|origTarget
init|=
name|unescapeFilePath
argument_list|(
name|project
operator|->
name|first
argument_list|(
literal|"QMAKE_ORIG_TARGET"
argument_list|)
operator|.
name|toQString
argument_list|()
argument_list|)
decl_stmt|;
name|precompObj
operator|=
name|origTarget
operator|+
name|Option
operator|::
name|obj_ext
expr_stmt|;
name|precompPch
operator|=
name|origTarget
operator|+
literal|".pch"
expr_stmt|;
comment|// Add PRECOMPILED_HEADER to HEADERS
if|if
condition|(
operator|!
name|project
operator|->
name|values
argument_list|(
literal|"HEADERS"
argument_list|)
operator|.
name|contains
argument_list|(
name|precompH
argument_list|)
condition|)
name|project
operator|->
name|values
argument_list|(
literal|"HEADERS"
argument_list|)
operator|+=
name|precompH
expr_stmt|;
comment|// Return to variable pool
name|project
operator|->
name|values
argument_list|(
literal|"PRECOMPILED_OBJECT"
argument_list|)
operator|=
name|ProStringList
argument_list|(
name|precompObj
argument_list|)
expr_stmt|;
name|project
operator|->
name|values
argument_list|(
literal|"PRECOMPILED_PCH"
argument_list|)
operator|=
name|ProStringList
argument_list|(
name|precompPch
argument_list|)
expr_stmt|;
name|autogenPrecompCPP
operator|=
name|precompCPP
operator|.
name|isEmpty
argument_list|()
operator|&&
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"autogen_precompile_source"
argument_list|)
expr_stmt|;
if|if
condition|(
name|autogenPrecompCPP
condition|)
block|{
name|precompCPP
operator|=
name|precompH
operator|+
operator|(
name|Option
operator|::
name|cpp_ext
operator|.
name|count
argument_list|()
condition|?
name|Option
operator|::
name|cpp_ext
operator|.
name|at
argument_list|(
literal|0
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|".cpp"
argument_list|)
operator|)
expr_stmt|;
name|project
operator|->
name|values
argument_list|(
literal|"GENERATED_SOURCES"
argument_list|)
operator|+=
name|precompCPP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|precompCPP
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|project
operator|->
name|values
argument_list|(
literal|"SOURCES"
argument_list|)
operator|+=
name|precompCPP
expr_stmt|;
block|}
block|}
comment|// Add all input files for a custom compiler into a map for uniqueness,
comment|// unless the compiler is configure as a combined stage, then use the first one
foreach|foreach
control|(
specifier|const
name|ProString
modifier|&
name|quc
decl|,
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_EXTRA_COMPILERS"
argument_list|)
control|)
block|{
specifier|const
name|ProStringList
modifier|&
name|invar
init|=
name|project
operator|->
name|values
argument_list|(
name|ProKey
argument_list|(
name|quc
operator|+
literal|".input"
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|compiler_out
init|=
name|project
operator|->
name|first
argument_list|(
name|ProKey
argument_list|(
name|quc
operator|+
literal|".output"
argument_list|)
argument_list|)
operator|.
name|toQString
argument_list|()
decl_stmt|;
for|for
control|(
name|ProStringList
operator|::
name|ConstIterator
name|iit
init|=
name|invar
operator|.
name|constBegin
argument_list|()
init|;
name|iit
operator|!=
name|invar
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|iit
control|)
block|{
name|ProStringList
name|fileList
init|=
name|project
operator|->
name|values
argument_list|(
operator|(
operator|*
name|iit
operator|)
operator|.
name|toKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fileList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|project
operator|->
name|values
argument_list|(
name|ProKey
argument_list|(
name|quc
operator|+
literal|".CONFIG"
argument_list|)
argument_list|)
operator|.
name|indexOf
argument_list|(
literal|"combine"
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|fileList
operator|.
name|erase
argument_list|(
name|fileList
operator|.
name|begin
argument_list|()
operator|+
literal|1
argument_list|,
name|fileList
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ProStringList
operator|::
name|ConstIterator
name|fit
init|=
name|fileList
operator|.
name|constBegin
argument_list|()
init|;
name|fit
operator|!=
name|fileList
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|fit
control|)
block|{
name|QString
name|file
init|=
operator|(
operator|*
name|fit
operator|)
operator|.
name|toQString
argument_list|()
decl_stmt|;
if|if
condition|(
name|verifyExtraCompiler
argument_list|(
name|quc
argument_list|,
name|file
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|hasBuiltinCompiler
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|extraCompilerSources
index|[
name|file
index|]
operator|+=
name|quc
operator|.
name|toQString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QString
name|out
init|=
name|Option
operator|::
name|fixPathToTargetOS
argument_list|(
name|replaceExtraCompilerVariables
argument_list|(
name|compiler_out
argument_list|,
name|file
argument_list|,
name|QString
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|extraCompilerSources
index|[
name|out
index|]
operator|+=
name|quc
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|extraCompilerOutputs
index|[
name|out
index|]
operator|=
name|QStringList
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|// Can only have one
block|}
block|}
block|}
block|}
block|}
block|}
if|#
directive|if
literal|0
comment|// Debugging
block|Q_FOREACH(QString aKey, extraCompilerSources.keys()) {         qDebug("Extracompilers for %s are (%s)", aKey.toLatin1().constData(), extraCompilerSources.value(aKey).join(", ").toLatin1().constData());     }     Q_FOREACH(QString aKey, extraCompilerOutputs.keys()) {         qDebug("Object mapping for %s is (%s)", aKey.toLatin1().constData(), extraCompilerOutputs.value(aKey).join(", ").toLatin1().constData());     }     qDebug("");
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|mergeBuildProject
name|bool
name|VcprojGenerator
operator|::
name|mergeBuildProject
parameter_list|(
name|MakefileGenerator
modifier|*
name|other
parameter_list|)
block|{
if|if
condition|(
operator|!
name|other
operator|||
operator|!
name|other
operator|->
name|projectFile
argument_list|()
condition|)
block|{
name|warn_msg
argument_list|(
name|WarnLogic
argument_list|,
literal|"VcprojGenerator: Cannot merge null project."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|other
operator|->
name|projectFile
argument_list|()
operator|->
name|first
argument_list|(
literal|"MAKEFILE_GENERATOR"
argument_list|)
operator|!=
name|project
operator|->
name|first
argument_list|(
literal|"MAKEFILE_GENERATOR"
argument_list|)
condition|)
block|{
name|warn_msg
argument_list|(
name|WarnLogic
argument_list|,
literal|"VcprojGenerator: Cannot merge other types of projects! (ignored)"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|VcprojGenerator
modifier|*
name|otherVC
init|=
cast|static_cast
argument_list|<
name|VcprojGenerator
operator|*
argument_list|>
argument_list|(
name|other
argument_list|)
decl_stmt|;
name|mergedProjects
operator|+=
name|otherVC
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|initProject
name|void
name|VcprojGenerator
operator|::
name|initProject
parameter_list|()
block|{
comment|// Initialize XML sub elements
comment|// - Do this first since project elements may need
comment|// - to know of certain configuration options
name|initConfiguration
argument_list|()
expr_stmt|;
name|initRootFiles
argument_list|()
expr_stmt|;
name|initSourceFiles
argument_list|()
expr_stmt|;
name|initHeaderFiles
argument_list|()
expr_stmt|;
name|initGeneratedFiles
argument_list|()
expr_stmt|;
name|initLexYaccFiles
argument_list|()
expr_stmt|;
name|initTranslationFiles
argument_list|()
expr_stmt|;
name|initFormFiles
argument_list|()
expr_stmt|;
name|initResourceFiles
argument_list|()
expr_stmt|;
name|initExtraCompilerOutputs
argument_list|()
expr_stmt|;
comment|// Own elements -----------------------------
name|vcProject
operator|.
name|Name
operator|=
name|unescapeFilePath
argument_list|(
name|project
operator|->
name|first
argument_list|(
literal|"QMAKE_ORIG_TARGET"
argument_list|)
operator|.
name|toQString
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which_dotnet_version
argument_list|()
condition|)
block|{
case|case
name|NET2013
case|:
name|vcProject
operator|.
name|Version
operator|=
literal|"13.00"
expr_stmt|;
break|break;
case|case
name|NET2012
case|:
name|vcProject
operator|.
name|Version
operator|=
literal|"12.00"
expr_stmt|;
break|break;
case|case
name|NET2010
case|:
name|vcProject
operator|.
name|Version
operator|=
literal|"10.00"
expr_stmt|;
break|break;
case|case
name|NET2008
case|:
name|vcProject
operator|.
name|Version
operator|=
literal|"9,00"
expr_stmt|;
break|break;
case|case
name|NET2005
case|:
comment|//### using ',' because of a bug in 2005 B2
comment|//### VS uses '.' or ',' depending on the regional settings! Using ',' always works.
name|vcProject
operator|.
name|Version
operator|=
literal|"8,00"
expr_stmt|;
break|break;
case|case
name|NET2003
case|:
name|vcProject
operator|.
name|Version
operator|=
literal|"7.10"
expr_stmt|;
break|break;
case|case
name|NET2002
case|:
name|vcProject
operator|.
name|Version
operator|=
literal|"7.00"
expr_stmt|;
break|break;
default|default:
name|vcProject
operator|.
name|Version
operator|=
literal|"7.00"
expr_stmt|;
name|warn_msg
argument_list|(
name|WarnLogic
argument_list|,
literal|"Generator: MSVC.NET: Unknown version (%d) of MSVC detected for .vcproj"
argument_list|,
name|which_dotnet_version
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|vcProject
operator|.
name|Keyword
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"VCPROJ_KEYWORD"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
if|if
condition|(
name|project
operator|->
name|isHostBuild
argument_list|()
operator|||
name|project
operator|->
name|isEmpty
argument_list|(
literal|"CE_SDK"
argument_list|)
operator|||
name|project
operator|->
name|isEmpty
argument_list|(
literal|"CE_ARCH"
argument_list|)
condition|)
block|{
name|vcProject
operator|.
name|PlatformName
operator|=
operator|(
name|is64Bit
condition|?
literal|"x64"
else|:
literal|"Win32"
operator|)
expr_stmt|;
block|}
else|else
block|{
name|vcProject
operator|.
name|PlatformName
operator|=
name|project
operator|->
name|values
argument_list|(
literal|"CE_SDK"
argument_list|)
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
operator|+
literal|" ("
operator|+
name|project
operator|->
name|first
argument_list|(
literal|"CE_ARCH"
argument_list|)
operator|+
literal|")"
expr_stmt|;
block|}
comment|// These are not used by Qt, but may be used by customers
name|vcProject
operator|.
name|SccProjectName
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"SCCPROJECTNAME"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|vcProject
operator|.
name|SccLocalPath
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"SCCLOCALPATH"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|vcProject
operator|.
name|flat_files
operator|=
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"flat"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initConfiguration
name|void
name|VcprojGenerator
operator|::
name|initConfiguration
parameter_list|()
block|{
comment|// Initialize XML sub elements
comment|// - Do this first since main configuration elements may need
comment|// - to know of certain compiler/linker options
name|VCConfiguration
modifier|&
name|conf
init|=
name|vcProject
operator|.
name|Configuration
decl_stmt|;
name|conf
operator|.
name|CompilerVersion
operator|=
name|which_dotnet_version
argument_list|()
expr_stmt|;
name|initCompilerTool
argument_list|()
expr_stmt|;
comment|// Only on configuration per build
name|bool
name|isDebug
init|=
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"debug"
argument_list|)
decl_stmt|;
if|if
condition|(
name|projectTarget
operator|==
name|StaticLib
condition|)
name|initLibrarianTool
argument_list|()
expr_stmt|;
else|else
block|{
name|conf
operator|.
name|linker
operator|.
name|GenerateDebugInformation
operator|=
name|isDebug
condition|?
name|_True
else|:
name|_False
expr_stmt|;
name|initLinkerTool
argument_list|()
expr_stmt|;
block|}
name|initManifestTool
argument_list|()
expr_stmt|;
name|initResourceTool
argument_list|()
expr_stmt|;
name|initIDLTool
argument_list|()
expr_stmt|;
comment|// Own elements -----------------------------
name|ProString
name|temp
init|=
name|project
operator|->
name|first
argument_list|(
literal|"BuildBrowserInformation"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|projectTarget
condition|)
block|{
case|case
name|SharedLib
case|:
name|conf
operator|.
name|ConfigurationType
operator|=
name|typeDynamicLibrary
expr_stmt|;
break|break;
case|case
name|StaticLib
case|:
name|conf
operator|.
name|ConfigurationType
operator|=
name|typeStaticLibrary
expr_stmt|;
break|break;
case|case
name|Application
case|:
default|default:
name|conf
operator|.
name|ConfigurationType
operator|=
name|typeApplication
expr_stmt|;
break|break;
block|}
name|conf
operator|.
name|OutputDirectory
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"DESTDIR"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|OutputDirectory
operator|.
name|isEmpty
argument_list|()
condition|)
name|conf
operator|.
name|OutputDirectory
operator|=
literal|".\\"
expr_stmt|;
if|if
condition|(
operator|!
name|conf
operator|.
name|OutputDirectory
operator|.
name|endsWith
argument_list|(
literal|"\\"
argument_list|)
condition|)
name|conf
operator|.
name|OutputDirectory
operator|+=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|CompilerVersion
operator|>=
name|NET2010
condition|)
block|{
comment|// The target name could have been changed.
name|conf
operator|.
name|PrimaryOutput
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"TARGET"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|conf
operator|.
name|PrimaryOutput
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|project
operator|->
name|first
argument_list|(
literal|"TARGET_VERSION_EXT"
argument_list|)
operator|.
name|isEmpty
argument_list|()
operator|&&
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"shared"
argument_list|)
condition|)
name|conf
operator|.
name|PrimaryOutput
operator|.
name|append
argument_list|(
name|project
operator|->
name|first
argument_list|(
literal|"TARGET_VERSION_EXT"
argument_list|)
operator|.
name|toQString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|conf
operator|.
name|Name
operator|=
name|project
operator|->
name|values
argument_list|(
literal|"BUILD_NAME"
argument_list|)
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|Name
operator|.
name|isEmpty
argument_list|()
condition|)
name|conf
operator|.
name|Name
operator|=
name|isDebug
condition|?
literal|"Debug"
else|:
literal|"Release"
expr_stmt|;
name|conf
operator|.
name|ConfigurationName
operator|=
name|conf
operator|.
name|Name
expr_stmt|;
if|if
condition|(
name|project
operator|->
name|isHostBuild
argument_list|()
operator|||
name|project
operator|->
name|isEmpty
argument_list|(
literal|"CE_SDK"
argument_list|)
operator|||
name|project
operator|->
name|isEmpty
argument_list|(
literal|"CE_ARCH"
argument_list|)
condition|)
block|{
name|conf
operator|.
name|Name
operator|+=
operator|(
name|is64Bit
condition|?
literal|"|x64"
else|:
literal|"|Win32"
operator|)
expr_stmt|;
block|}
else|else
block|{
name|conf
operator|.
name|Name
operator|+=
literal|"|"
operator|+
name|project
operator|->
name|values
argument_list|(
literal|"CE_SDK"
argument_list|)
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
operator|+
literal|" ("
operator|+
name|project
operator|->
name|first
argument_list|(
literal|"CE_ARCH"
argument_list|)
operator|+
literal|")"
expr_stmt|;
block|}
name|conf
operator|.
name|ATLMinimizesCRunTimeLibraryUsage
operator|=
operator|(
name|project
operator|->
name|first
argument_list|(
literal|"ATLMinimizesCRunTimeLibraryUsage"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|?
name|_False
else|:
name|_True
operator|)
expr_stmt|;
name|conf
operator|.
name|BuildBrowserInformation
operator|=
name|triState
argument_list|(
name|temp
operator|.
name|isEmpty
argument_list|()
condition|?
operator|(
name|short
operator|)
name|unset
else|:
name|temp
operator|.
name|toShort
argument_list|()
argument_list|)
expr_stmt|;
name|temp
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"CharacterSet"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|CharacterSet
operator|=
name|charSet
argument_list|(
name|temp
operator|.
name|isEmpty
argument_list|()
condition|?
operator|(
name|short
operator|)
name|charSetNotSet
else|:
name|temp
operator|.
name|toShort
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|DeleteExtensionsOnClean
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"DeleteExtensionsOnClean"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|conf
operator|.
name|ImportLibrary
operator|=
name|conf
operator|.
name|linker
operator|.
name|ImportLibrary
expr_stmt|;
name|conf
operator|.
name|IntermediateDirectory
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"OBJECTS_DIR"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|conf
operator|.
name|WholeProgramOptimization
operator|=
name|conf
operator|.
name|compiler
operator|.
name|WholeProgramOptimization
expr_stmt|;
name|temp
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"UseOfATL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
operator|.
name|isEmpty
argument_list|()
condition|)
name|conf
operator|.
name|UseOfATL
operator|=
name|useOfATL
argument_list|(
name|temp
operator|.
name|toShort
argument_list|()
argument_list|)
expr_stmt|;
name|temp
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"UseOfMfc"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
operator|.
name|isEmpty
argument_list|()
condition|)
name|conf
operator|.
name|UseOfMfc
operator|=
name|useOfMfc
argument_list|(
name|temp
operator|.
name|toShort
argument_list|()
argument_list|)
expr_stmt|;
comment|// Configuration does not need parameters from
comment|// these sub XML items;
name|initCustomBuildTool
argument_list|()
expr_stmt|;
name|initPreBuildEventTools
argument_list|()
expr_stmt|;
name|initPostBuildEventTools
argument_list|()
expr_stmt|;
comment|// Only deploy for CE projects
if|if
condition|(
operator|!
name|project
operator|->
name|isHostBuild
argument_list|()
operator|&&
operator|!
name|project
operator|->
name|isEmpty
argument_list|(
literal|"CE_SDK"
argument_list|)
operator|&&
operator|!
name|project
operator|->
name|isEmpty
argument_list|(
literal|"CE_ARCH"
argument_list|)
condition|)
name|initDeploymentTool
argument_list|()
expr_stmt|;
name|initPreLinkEventTools
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isDebug
condition|)
name|conf
operator|.
name|compiler
operator|.
name|PreprocessorDefinitions
operator|+=
literal|"NDEBUG"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initCompilerTool
name|void
name|VcprojGenerator
operator|::
name|initCompilerTool
parameter_list|()
block|{
name|QString
name|placement
init|=
name|project
operator|->
name|first
argument_list|(
literal|"OBJECTS_DIR"
argument_list|)
operator|.
name|toQString
argument_list|()
decl_stmt|;
if|if
condition|(
name|placement
operator|.
name|isEmpty
argument_list|()
condition|)
name|placement
operator|=
literal|".\\"
expr_stmt|;
name|VCConfiguration
modifier|&
name|conf
init|=
name|vcProject
operator|.
name|Configuration
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|CompilerVersion
operator|>=
name|NET2010
condition|)
block|{
comment|// adjust compiler tool defaults for VS 2010 and above
name|conf
operator|.
name|compiler
operator|.
name|Optimization
operator|=
name|optimizeDisabled
expr_stmt|;
block|}
name|conf
operator|.
name|compiler
operator|.
name|AssemblerListingLocation
operator|=
name|placement
expr_stmt|;
name|conf
operator|.
name|compiler
operator|.
name|ObjectFile
operator|=
name|placement
expr_stmt|;
name|conf
operator|.
name|compiler
operator|.
name|ExceptionHandling
operator|=
name|ehNone
expr_stmt|;
comment|// PCH
if|if
condition|(
name|usePCH
condition|)
block|{
name|conf
operator|.
name|compiler
operator|.
name|UsePrecompiledHeader
operator|=
name|pchUseUsingSpecific
expr_stmt|;
name|conf
operator|.
name|compiler
operator|.
name|PrecompiledHeaderFile
operator|=
literal|"$(IntDir)\\"
operator|+
name|precompPch
expr_stmt|;
name|conf
operator|.
name|compiler
operator|.
name|PrecompiledHeaderThrough
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"PRECOMPILED_HEADER"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|conf
operator|.
name|compiler
operator|.
name|ForcedIncludeFiles
operator|=
name|project
operator|->
name|values
argument_list|(
literal|"PRECOMPILED_HEADER"
argument_list|)
operator|.
name|toQStringList
argument_list|()
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|CompilerVersion
operator|<=
name|NET2003
condition|)
block|{
comment|// Minimal build option triggers an Internal Compiler Error
comment|// when used in conjunction with /FI and /Yu, so remove it
comment|// ### work-around for a VS 2003 bug. Move to some prf file or remove completely.
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_CFLAGS_DEBUG"
argument_list|)
operator|.
name|removeAll
argument_list|(
literal|"-Gm"
argument_list|)
expr_stmt|;
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_CFLAGS_DEBUG"
argument_list|)
operator|.
name|removeAll
argument_list|(
literal|"/Gm"
argument_list|)
expr_stmt|;
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_CXXFLAGS_DEBUG"
argument_list|)
operator|.
name|removeAll
argument_list|(
literal|"-Gm"
argument_list|)
expr_stmt|;
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_CXXFLAGS_DEBUG"
argument_list|)
operator|.
name|removeAll
argument_list|(
literal|"/Gm"
argument_list|)
expr_stmt|;
block|}
block|}
name|conf
operator|.
name|compiler
operator|.
name|parseOptions
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_CXXFLAGS"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"windows"
argument_list|)
condition|)
name|conf
operator|.
name|compiler
operator|.
name|PreprocessorDefinitions
operator|+=
literal|"_WINDOWS"
expr_stmt|;
elseif|else
if|if
condition|(
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"console"
argument_list|)
condition|)
name|conf
operator|.
name|compiler
operator|.
name|PreprocessorDefinitions
operator|+=
literal|"_CONSOLE"
expr_stmt|;
name|conf
operator|.
name|compiler
operator|.
name|PreprocessorDefinitions
operator|+=
name|project
operator|->
name|values
argument_list|(
literal|"DEFINES"
argument_list|)
operator|.
name|toQStringList
argument_list|()
expr_stmt|;
name|conf
operator|.
name|compiler
operator|.
name|PreprocessorDefinitions
operator|+=
name|project
operator|->
name|values
argument_list|(
literal|"PRL_EXPORT_DEFINES"
argument_list|)
operator|.
name|toQStringList
argument_list|()
expr_stmt|;
name|conf
operator|.
name|compiler
operator|.
name|parseOptions
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"MSVCPROJ_INCPATH"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initLibrarianTool
name|void
name|VcprojGenerator
operator|::
name|initLibrarianTool
parameter_list|()
block|{
name|VCConfiguration
modifier|&
name|conf
init|=
name|vcProject
operator|.
name|Configuration
decl_stmt|;
name|conf
operator|.
name|librarian
operator|.
name|OutputFile
operator|=
literal|"$(OutDir)\\"
expr_stmt|;
name|conf
operator|.
name|librarian
operator|.
name|OutputFile
operator|+=
name|project
operator|->
name|first
argument_list|(
literal|"MSVCPROJ_TARGET"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|conf
operator|.
name|librarian
operator|.
name|AdditionalOptions
operator|+=
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_LIBFLAGS"
argument_list|)
operator|.
name|toQStringList
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initManifestTool
name|void
name|VcprojGenerator
operator|::
name|initManifestTool
parameter_list|()
block|{
name|VCManifestTool
modifier|&
name|tool
init|=
name|vcProject
operator|.
name|Configuration
operator|.
name|manifestTool
decl_stmt|;
specifier|const
name|ProString
name|tmplt
init|=
name|project
operator|->
name|first
argument_list|(
literal|"TEMPLATE"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|tmplt
operator|==
literal|"vclib"
operator|&&
operator|!
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"embed_manifest_dll"
argument_list|)
operator|&&
operator|!
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"static"
argument_list|)
operator|)
operator|||
operator|(
name|tmplt
operator|==
literal|"vcapp"
operator|&&
operator|!
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"embed_manifest_exe"
argument_list|)
operator|)
condition|)
block|{
name|tool
operator|.
name|EmbedManifest
operator|=
name|_False
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|initLinkerTool
name|void
name|VcprojGenerator
operator|::
name|initLinkerTool
parameter_list|()
block|{
name|VCConfiguration
modifier|&
name|conf
init|=
name|vcProject
operator|.
name|Configuration
decl_stmt|;
name|conf
operator|.
name|linker
operator|.
name|parseOptions
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_LFLAGS"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|project
operator|->
name|values
argument_list|(
literal|"DEF_FILE"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|conf
operator|.
name|linker
operator|.
name|ModuleDefinitionFile
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"DEF_FILE"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|ProString
modifier|&
name|libs
decl|,
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_LIBS"
argument_list|)
operator|+
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_LIBS_PRIVATE"
argument_list|)
control|)
block|{
if|if
condition|(
name|libs
operator|.
name|left
argument_list|(
literal|9
argument_list|)
operator|.
name|toQString
argument_list|()
operator|.
name|toUpper
argument_list|()
operator|==
literal|"/LIBPATH:"
condition|)
block|{
name|ProStringList
name|l
init|=
name|ProStringList
argument_list|(
name|libs
argument_list|)
decl_stmt|;
name|conf
operator|.
name|linker
operator|.
name|parseOptions
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|conf
operator|.
name|linker
operator|.
name|AdditionalDependencies
operator|+=
name|libs
operator|.
name|toQString
argument_list|()
expr_stmt|;
block|}
block|}
name|conf
operator|.
name|linker
operator|.
name|OutputFile
operator|=
literal|"$(OutDir)\\"
expr_stmt|;
name|conf
operator|.
name|linker
operator|.
name|OutputFile
operator|+=
name|project
operator|->
name|first
argument_list|(
literal|"MSVCPROJ_TARGET"
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initResourceTool
name|void
name|VcprojGenerator
operator|::
name|initResourceTool
parameter_list|()
block|{
name|VCConfiguration
modifier|&
name|conf
init|=
name|vcProject
operator|.
name|Configuration
decl_stmt|;
name|conf
operator|.
name|resource
operator|.
name|PreprocessorDefinitions
operator|=
name|conf
operator|.
name|compiler
operator|.
name|PreprocessorDefinitions
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|ProString
modifier|&
name|path
decl|,
name|project
operator|->
name|values
argument_list|(
literal|"RC_INCLUDEPATH"
argument_list|)
control|)
block|{
name|QString
name|fixedPath
init|=
name|fileFixify
argument_list|(
name|path
operator|.
name|toQString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileInfo
argument_list|(
name|fixedPath
argument_list|)
operator|.
name|isRelative
argument_list|()
condition|)
block|{
if|if
condition|(
name|fixedPath
operator|==
name|QStringLiteral
argument_list|(
literal|"."
argument_list|)
condition|)
name|fixedPath
operator|=
name|QStringLiteral
argument_list|(
literal|"$(ProjectDir)"
argument_list|)
expr_stmt|;
else|else
name|fixedPath
operator|.
name|prepend
argument_list|(
name|QStringLiteral
argument_list|(
literal|"$(ProjectDir)\\"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|conf
operator|.
name|resource
operator|.
name|AdditionalIncludeDirectories
operator|<<
name|escapeFilePath
argument_list|(
name|fixedPath
argument_list|)
expr_stmt|;
block|}
comment|// We need to add _DEBUG for the debug version of the project, since the normal compiler defines
comment|// do not contain it. (The compiler defines this symbol automatically, which is wy we don't need
comment|// to add it for the compiler) However, the resource tool does not do this.
if|if
condition|(
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"debug"
argument_list|)
condition|)
name|conf
operator|.
name|resource
operator|.
name|PreprocessorDefinitions
operator|+=
literal|"_DEBUG"
expr_stmt|;
if|if
condition|(
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"staticlib"
argument_list|)
condition|)
name|conf
operator|.
name|resource
operator|.
name|ResourceOutputFileName
operator|=
literal|"$(OutDir)\\$(InputName).res"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initIDLTool
name|void
name|VcprojGenerator
operator|::
name|initIDLTool
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|initCustomBuildTool
name|void
name|VcprojGenerator
operator|::
name|initCustomBuildTool
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|initPreBuildEventTools
name|void
name|VcprojGenerator
operator|::
name|initPreBuildEventTools
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|initPostBuildEventTools
name|void
name|VcprojGenerator
operator|::
name|initPostBuildEventTools
parameter_list|()
block|{
name|VCConfiguration
modifier|&
name|conf
init|=
name|vcProject
operator|.
name|Configuration
decl_stmt|;
if|if
condition|(
operator|!
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_POST_LINK"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
name|cmdline
init|=
name|VCToolBase
operator|::
name|fixCommandLine
argument_list|(
name|var
argument_list|(
literal|"QMAKE_POST_LINK"
argument_list|)
argument_list|)
decl_stmt|;
name|conf
operator|.
name|postBuild
operator|.
name|CommandLine
operator|=
name|cmdline
expr_stmt|;
name|conf
operator|.
name|postBuild
operator|.
name|Description
operator|=
name|cmdline
operator|.
name|join
argument_list|(
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
argument_list|)
expr_stmt|;
name|conf
operator|.
name|postBuild
operator|.
name|ExcludedFromBuild
operator|=
name|_False
expr_stmt|;
block|}
name|QString
name|signature
init|=
operator|!
name|project
operator|->
name|isEmpty
argument_list|(
literal|"SIGNATURE_FILE"
argument_list|)
condition|?
name|var
argument_list|(
literal|"SIGNATURE_FILE"
argument_list|)
else|:
name|var
argument_list|(
literal|"DEFAULT_SIGNATURE"
argument_list|)
decl_stmt|;
name|bool
name|useSignature
init|=
operator|!
name|signature
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"staticlib"
argument_list|)
operator|&&
operator|!
name|project
operator|->
name|isHostBuild
argument_list|()
operator|&&
operator|!
name|project
operator|->
name|isEmpty
argument_list|(
literal|"CE_SDK"
argument_list|)
operator|&&
operator|!
name|project
operator|->
name|isEmpty
argument_list|(
literal|"CE_ARCH"
argument_list|)
decl_stmt|;
if|if
condition|(
name|useSignature
condition|)
block|{
name|conf
operator|.
name|postBuild
operator|.
name|CommandLine
operator|.
name|prepend
argument_list|(
name|QLatin1String
argument_list|(
literal|"signtool sign /F "
argument_list|)
operator|+
name|signature
operator|+
name|QLatin1String
argument_list|(
literal|" \"$(TargetPath)\""
argument_list|)
argument_list|)
expr_stmt|;
name|conf
operator|.
name|postBuild
operator|.
name|ExcludedFromBuild
operator|=
name|_False
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|project
operator|->
name|values
argument_list|(
literal|"MSVCPROJ_COPY_DLL"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|conf
operator|.
name|postBuild
operator|.
name|Description
operator|+=
name|var
argument_list|(
literal|"MSVCPROJ_COPY_DLL_DESC"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|postBuild
operator|.
name|CommandLine
operator|+=
name|var
argument_list|(
literal|"MSVCPROJ_COPY_DLL"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|postBuild
operator|.
name|ExcludedFromBuild
operator|=
name|_False
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|initDeploymentTool
name|void
name|VcprojGenerator
operator|::
name|initDeploymentTool
parameter_list|()
block|{
name|VCConfiguration
modifier|&
name|conf
init|=
name|vcProject
operator|.
name|Configuration
decl_stmt|;
name|QString
name|targetPath
init|=
name|project
operator|->
name|values
argument_list|(
literal|"deploy.path"
argument_list|)
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetPath
operator|.
name|isEmpty
argument_list|()
condition|)
name|targetPath
operator|=
name|QString
argument_list|(
literal|"%CSIDL_PROGRAM_FILES%\\"
argument_list|)
operator|+
name|project
operator|->
name|first
argument_list|(
literal|"TARGET"
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetPath
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
operator|||
name|targetPath
operator|.
name|endsWith
argument_list|(
literal|"\\"
argument_list|)
condition|)
name|targetPath
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Only deploy Qt libs for shared build
if|if
condition|(
operator|!
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_QT_DLL"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// FIXME: This code should actually resolve the libraries from all Qt modules.
specifier|const
name|QString
modifier|&
name|qtdir
init|=
name|QLibraryInfo
operator|::
name|rawLocation
argument_list|(
name|QLibraryInfo
operator|::
name|LibrariesPath
argument_list|,
name|QLibraryInfo
operator|::
name|EffectivePaths
argument_list|)
decl_stmt|;
name|ProStringList
name|arg
init|=
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_LIBS"
argument_list|)
operator|+
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_LIBS_PRIVATE"
argument_list|)
decl_stmt|;
for|for
control|(
name|ProStringList
operator|::
name|ConstIterator
name|it
init|=
name|arg
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|arg
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|it
operator|->
name|contains
argument_list|(
name|qtdir
argument_list|)
condition|)
block|{
name|QString
name|dllName
init|=
operator|(
operator|*
name|it
operator|)
operator|.
name|toQString
argument_list|()
decl_stmt|;
if|if
condition|(
name|dllName
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"QAxContainer"
argument_list|)
argument_list|)
operator|||
name|dllName
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"qtmain"
argument_list|)
argument_list|)
operator|||
name|dllName
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"QtUiTools"
argument_list|)
argument_list|)
condition|)
continue|continue;
name|dllName
operator|.
name|replace
argument_list|(
name|QLatin1String
argument_list|(
literal|".lib"
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|".dll"
argument_list|)
argument_list|)
expr_stmt|;
name|QFileInfo
name|info
argument_list|(
name|dllName
argument_list|)
decl_stmt|;
name|conf
operator|.
name|deployment
operator|.
name|AdditionalFiles
operator|+=
name|info
operator|.
name|fileName
argument_list|()
operator|+
literal|"|"
operator|+
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|info
operator|.
name|absolutePath
argument_list|()
argument_list|)
operator|+
literal|"|"
operator|+
name|targetPath
operator|+
literal|"|0;"
expr_stmt|;
block|}
block|}
block|}
comment|// C-runtime deployment
name|QString
name|runtime
init|=
name|project
operator|->
name|values
argument_list|(
literal|"QT_CE_C_RUNTIME"
argument_list|)
operator|.
name|join
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|runtime
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|runtime
operator|!=
name|QLatin1String
argument_list|(
literal|"no"
argument_list|)
operator|)
condition|)
block|{
name|QString
name|runtimeVersion
init|=
name|QLatin1String
argument_list|(
literal|"msvcr"
argument_list|)
decl_stmt|;
name|ProString
name|mkspec
init|=
name|project
operator|->
name|first
argument_list|(
literal|"QMAKESPEC"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mkspec
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|mkspec
operator|.
name|endsWith
argument_list|(
literal|"2008"
argument_list|)
condition|)
name|runtimeVersion
operator|.
name|append
argument_list|(
literal|"90"
argument_list|)
expr_stmt|;
else|else
name|runtimeVersion
operator|.
name|append
argument_list|(
literal|"80"
argument_list|)
expr_stmt|;
if|if
condition|(
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"debug"
argument_list|)
condition|)
name|runtimeVersion
operator|.
name|append
argument_list|(
literal|"d"
argument_list|)
expr_stmt|;
name|runtimeVersion
operator|.
name|append
argument_list|(
literal|".dll"
argument_list|)
expr_stmt|;
if|if
condition|(
name|runtime
operator|==
literal|"yes"
condition|)
block|{
comment|// Auto-find C-runtime
name|QString
name|vcInstallDir
init|=
name|qgetenv
argument_list|(
literal|"VCINSTALLDIR"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vcInstallDir
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|vcInstallDir
operator|+=
literal|"\\ce\\dll\\"
expr_stmt|;
name|vcInstallDir
operator|+=
name|project
operator|->
name|values
argument_list|(
literal|"CE_ARCH"
argument_list|)
operator|.
name|join
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QFileInfo
argument_list|(
name|vcInstallDir
operator|+
name|QDir
operator|::
name|separator
argument_list|()
operator|+
name|runtimeVersion
argument_list|)
operator|.
name|exists
argument_list|()
condition|)
name|runtime
operator|.
name|clear
argument_list|()
expr_stmt|;
else|else
name|runtime
operator|=
name|vcInstallDir
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|runtime
operator|.
name|isEmpty
argument_list|()
operator|&&
name|runtime
operator|!=
name|QLatin1String
argument_list|(
literal|"yes"
argument_list|)
condition|)
block|{
name|conf
operator|.
name|deployment
operator|.
name|AdditionalFiles
operator|+=
name|runtimeVersion
operator|+
literal|"|"
operator|+
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|runtime
argument_list|)
operator|+
literal|"|"
operator|+
name|targetPath
operator|+
literal|"|0;"
expr_stmt|;
block|}
block|}
comment|// foreach item in DEPLOYMENT
foreach|foreach
control|(
specifier|const
name|ProString
modifier|&
name|item
decl|,
name|project
operator|->
name|values
argument_list|(
literal|"DEPLOYMENT"
argument_list|)
control|)
block|{
comment|// get item.path
name|QString
name|devicePath
init|=
name|project
operator|->
name|first
argument_list|(
name|ProKey
argument_list|(
name|item
operator|+
literal|".path"
argument_list|)
argument_list|)
operator|.
name|toQString
argument_list|()
decl_stmt|;
if|if
condition|(
name|devicePath
operator|.
name|isEmpty
argument_list|()
condition|)
name|devicePath
operator|=
name|targetPath
expr_stmt|;
comment|// check if item.path is relative (! either /,\ or %)
if|if
condition|(
operator|!
operator|(
name|devicePath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|||
name|devicePath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
operator|||
name|devicePath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
operator|)
condition|)
block|{
comment|// create output path
name|devicePath
operator|=
name|Option
operator|::
name|fixPathToLocalOS
argument_list|(
name|QDir
operator|::
name|cleanPath
argument_list|(
name|targetPath
operator|+
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
operator|+
name|devicePath
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// foreach d in item.files
foreach|foreach
control|(
specifier|const
name|ProString
modifier|&
name|src
decl|,
name|project
operator|->
name|values
argument_list|(
name|ProKey
argument_list|(
name|item
operator|+
literal|".files"
argument_list|)
argument_list|)
control|)
block|{
name|QString
name|itemDevicePath
init|=
name|devicePath
decl_stmt|;
name|QString
name|source
init|=
name|Option
operator|::
name|fixPathToLocalOS
argument_list|(
name|src
operator|.
name|toQString
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|nameFilter
decl_stmt|;
name|QFileInfo
name|info
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|QString
name|searchPath
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|isDir
argument_list|()
condition|)
block|{
name|nameFilter
operator|=
name|QLatin1String
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|itemDevicePath
operator|+=
literal|"\\"
operator|+
name|info
operator|.
name|fileName
argument_list|()
expr_stmt|;
name|searchPath
operator|=
name|info
operator|.
name|absoluteFilePath
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|nameFilter
operator|=
name|source
operator|.
name|split
argument_list|(
literal|'\\'
argument_list|)
operator|.
name|last
argument_list|()
expr_stmt|;
name|searchPath
operator|=
name|info
operator|.
name|absolutePath
argument_list|()
expr_stmt|;
block|}
name|int
name|pathSize
init|=
name|searchPath
operator|.
name|size
argument_list|()
decl_stmt|;
name|QDirIterator
name|iterator
argument_list|(
name|searchPath
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|nameFilter
argument_list|,
name|QDir
operator|::
name|Files
operator||
name|QDir
operator|::
name|NoDotAndDotDot
operator||
name|QDir
operator|::
name|NoSymLinks
argument_list|,
name|QDirIterator
operator|::
name|Subdirectories
argument_list|)
decl_stmt|;
comment|// foreach dirIterator-entry in d
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|QString
name|absoluteItemPath
init|=
name|Option
operator|::
name|fixPathToLocalOS
argument_list|(
name|QFileInfo
argument_list|(
name|iterator
operator|.
name|filePath
argument_list|()
argument_list|)
operator|.
name|absolutePath
argument_list|()
argument_list|)
decl_stmt|;
comment|// Identify if it is just another subdir
name|int
name|diffSize
init|=
name|absoluteItemPath
operator|.
name|size
argument_list|()
operator|-
name|pathSize
decl_stmt|;
comment|// write out rules
name|conf
operator|.
name|deployment
operator|.
name|AdditionalFiles
operator|+=
name|iterator
operator|.
name|fileName
argument_list|()
operator|+
literal|"|"
operator|+
name|absoluteItemPath
operator|+
literal|"|"
operator|+
name|itemDevicePath
operator|+
operator|(
name|diffSize
condition|?
operator|(
name|absoluteItemPath
operator|.
name|right
argument_list|(
name|diffSize
argument_list|)
operator|)
else|:
name|QLatin1String
argument_list|(
literal|""
argument_list|)
operator|)
operator|+
literal|"|0;"
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|initPreLinkEventTools
name|void
name|VcprojGenerator
operator|::
name|initPreLinkEventTools
parameter_list|()
block|{
name|VCConfiguration
modifier|&
name|conf
init|=
name|vcProject
operator|.
name|Configuration
decl_stmt|;
if|if
condition|(
operator|!
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_PRE_LINK"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
name|cmdline
init|=
name|VCToolBase
operator|::
name|fixCommandLine
argument_list|(
name|var
argument_list|(
literal|"QMAKE_PRE_LINK"
argument_list|)
argument_list|)
decl_stmt|;
name|conf
operator|.
name|preLink
operator|.
name|CommandLine
operator|=
name|cmdline
expr_stmt|;
name|conf
operator|.
name|preLink
operator|.
name|Description
operator|=
name|cmdline
operator|.
name|join
argument_list|(
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
argument_list|)
expr_stmt|;
name|conf
operator|.
name|preLink
operator|.
name|ExcludedFromBuild
operator|=
name|_False
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|initRootFiles
name|void
name|VcprojGenerator
operator|::
name|initRootFiles
parameter_list|()
block|{
comment|// Note: Root files do _not_ have any filter name, filter nor GUID!
name|vcProject
operator|.
name|RootFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"RC_FILE"
argument_list|)
argument_list|)
expr_stmt|;
name|vcProject
operator|.
name|RootFiles
operator|.
name|Project
operator|=
name|this
expr_stmt|;
name|vcProject
operator|.
name|RootFiles
operator|.
name|Config
operator|=
operator|&
operator|(
name|vcProject
operator|.
name|Configuration
operator|)
expr_stmt|;
name|vcProject
operator|.
name|RootFiles
operator|.
name|CustomBuild
operator|=
name|none
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initSourceFiles
name|void
name|VcprojGenerator
operator|::
name|initSourceFiles
parameter_list|()
block|{
name|vcProject
operator|.
name|SourceFiles
operator|.
name|Name
operator|=
literal|"Source Files"
expr_stmt|;
name|vcProject
operator|.
name|SourceFiles
operator|.
name|Filter
operator|=
literal|"cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
expr_stmt|;
name|vcProject
operator|.
name|SourceFiles
operator|.
name|Guid
operator|=
name|_GUIDSourceFiles
expr_stmt|;
name|vcProject
operator|.
name|SourceFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"SOURCES"
argument_list|)
argument_list|)
expr_stmt|;
name|vcProject
operator|.
name|SourceFiles
operator|.
name|Project
operator|=
name|this
expr_stmt|;
name|vcProject
operator|.
name|SourceFiles
operator|.
name|Config
operator|=
operator|&
operator|(
name|vcProject
operator|.
name|Configuration
operator|)
expr_stmt|;
name|vcProject
operator|.
name|SourceFiles
operator|.
name|CustomBuild
operator|=
name|none
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initHeaderFiles
name|void
name|VcprojGenerator
operator|::
name|initHeaderFiles
parameter_list|()
block|{
name|vcProject
operator|.
name|HeaderFiles
operator|.
name|Name
operator|=
literal|"Header Files"
expr_stmt|;
name|vcProject
operator|.
name|HeaderFiles
operator|.
name|Filter
operator|=
literal|"h;hpp;hxx;hm;inl;inc;xsd"
expr_stmt|;
name|vcProject
operator|.
name|HeaderFiles
operator|.
name|Guid
operator|=
name|_GUIDHeaderFiles
expr_stmt|;
name|vcProject
operator|.
name|HeaderFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"HEADERS"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|usePCH
condition|)
comment|// Generated PCH cpp file
name|vcProject
operator|.
name|HeaderFiles
operator|.
name|addFile
argument_list|(
name|precompH
argument_list|)
expr_stmt|;
name|vcProject
operator|.
name|HeaderFiles
operator|.
name|Project
operator|=
name|this
expr_stmt|;
name|vcProject
operator|.
name|HeaderFiles
operator|.
name|Config
operator|=
operator|&
operator|(
name|vcProject
operator|.
name|Configuration
operator|)
expr_stmt|;
comment|//    vcProject.HeaderFiles.CustomBuild = mocHdr;
comment|//    addMocArguments(vcProject.HeaderFiles);
block|}
end_function
begin_function
DECL|function|initGeneratedFiles
name|void
name|VcprojGenerator
operator|::
name|initGeneratedFiles
parameter_list|()
block|{
name|vcProject
operator|.
name|GeneratedFiles
operator|.
name|Name
operator|=
literal|"Generated Files"
expr_stmt|;
name|vcProject
operator|.
name|GeneratedFiles
operator|.
name|Filter
operator|=
literal|"cpp;c;cxx;moc;h;def;odl;idl;res;"
expr_stmt|;
name|vcProject
operator|.
name|GeneratedFiles
operator|.
name|Guid
operator|=
name|_GUIDGeneratedFiles
expr_stmt|;
comment|// ### These cannot have CustomBuild (mocSrc)!!
name|vcProject
operator|.
name|GeneratedFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"GENERATED_SOURCES"
argument_list|)
argument_list|)
expr_stmt|;
name|vcProject
operator|.
name|GeneratedFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"GENERATED_FILES"
argument_list|)
argument_list|)
expr_stmt|;
name|vcProject
operator|.
name|GeneratedFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"IDLSOURCES"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|project
operator|->
name|values
argument_list|(
literal|"RC_FILE"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|vcProject
operator|.
name|GeneratedFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"RES_FILE"
argument_list|)
argument_list|)
expr_stmt|;
name|vcProject
operator|.
name|GeneratedFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_IMAGE_COLLECTION"
argument_list|)
argument_list|)
expr_stmt|;
comment|// compat
if|if
condition|(
operator|!
name|extraCompilerOutputs
operator|.
name|isEmpty
argument_list|()
condition|)
name|vcProject
operator|.
name|GeneratedFiles
operator|.
name|addFiles
argument_list|(
name|extraCompilerOutputs
operator|.
name|keys
argument_list|()
argument_list|)
expr_stmt|;
name|vcProject
operator|.
name|GeneratedFiles
operator|.
name|Project
operator|=
name|this
expr_stmt|;
name|vcProject
operator|.
name|GeneratedFiles
operator|.
name|Config
operator|=
operator|&
operator|(
name|vcProject
operator|.
name|Configuration
operator|)
expr_stmt|;
comment|//    vcProject.GeneratedFiles.CustomBuild = mocSrc;
block|}
end_function
begin_function
DECL|function|initLexYaccFiles
name|void
name|VcprojGenerator
operator|::
name|initLexYaccFiles
parameter_list|()
block|{
name|vcProject
operator|.
name|LexYaccFiles
operator|.
name|Name
operator|=
literal|"Lex / Yacc Files"
expr_stmt|;
name|vcProject
operator|.
name|LexYaccFiles
operator|.
name|ParseFiles
operator|=
name|_False
expr_stmt|;
name|vcProject
operator|.
name|LexYaccFiles
operator|.
name|Filter
operator|=
literal|"l;y"
expr_stmt|;
name|vcProject
operator|.
name|LexYaccFiles
operator|.
name|Guid
operator|=
name|_GUIDLexYaccFiles
expr_stmt|;
name|vcProject
operator|.
name|LexYaccFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"LEXSOURCES"
argument_list|)
argument_list|)
expr_stmt|;
name|vcProject
operator|.
name|LexYaccFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"YACCSOURCES"
argument_list|)
argument_list|)
expr_stmt|;
name|vcProject
operator|.
name|LexYaccFiles
operator|.
name|Project
operator|=
name|this
expr_stmt|;
name|vcProject
operator|.
name|LexYaccFiles
operator|.
name|Config
operator|=
operator|&
operator|(
name|vcProject
operator|.
name|Configuration
operator|)
expr_stmt|;
name|vcProject
operator|.
name|LexYaccFiles
operator|.
name|CustomBuild
operator|=
name|lexyacc
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initTranslationFiles
name|void
name|VcprojGenerator
operator|::
name|initTranslationFiles
parameter_list|()
block|{
name|vcProject
operator|.
name|TranslationFiles
operator|.
name|Name
operator|=
literal|"Translation Files"
expr_stmt|;
name|vcProject
operator|.
name|TranslationFiles
operator|.
name|ParseFiles
operator|=
name|_False
expr_stmt|;
name|vcProject
operator|.
name|TranslationFiles
operator|.
name|Filter
operator|=
literal|"ts;xlf"
expr_stmt|;
name|vcProject
operator|.
name|TranslationFiles
operator|.
name|Guid
operator|=
name|_GUIDTranslationFiles
expr_stmt|;
name|vcProject
operator|.
name|TranslationFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"TRANSLATIONS"
argument_list|)
argument_list|)
expr_stmt|;
name|vcProject
operator|.
name|TranslationFiles
operator|.
name|Project
operator|=
name|this
expr_stmt|;
name|vcProject
operator|.
name|TranslationFiles
operator|.
name|Config
operator|=
operator|&
operator|(
name|vcProject
operator|.
name|Configuration
operator|)
expr_stmt|;
name|vcProject
operator|.
name|TranslationFiles
operator|.
name|CustomBuild
operator|=
name|none
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initFormFiles
name|void
name|VcprojGenerator
operator|::
name|initFormFiles
parameter_list|()
block|{
name|vcProject
operator|.
name|FormFiles
operator|.
name|Name
operator|=
literal|"Form Files"
expr_stmt|;
name|vcProject
operator|.
name|FormFiles
operator|.
name|ParseFiles
operator|=
name|_False
expr_stmt|;
name|vcProject
operator|.
name|FormFiles
operator|.
name|Filter
operator|=
literal|"ui"
expr_stmt|;
name|vcProject
operator|.
name|FormFiles
operator|.
name|Guid
operator|=
name|_GUIDFormFiles
expr_stmt|;
name|vcProject
operator|.
name|FormFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"FORMS"
argument_list|)
argument_list|)
expr_stmt|;
name|vcProject
operator|.
name|FormFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"FORMS3"
argument_list|)
argument_list|)
expr_stmt|;
name|vcProject
operator|.
name|FormFiles
operator|.
name|Project
operator|=
name|this
expr_stmt|;
name|vcProject
operator|.
name|FormFiles
operator|.
name|Config
operator|=
operator|&
operator|(
name|vcProject
operator|.
name|Configuration
operator|)
expr_stmt|;
name|vcProject
operator|.
name|FormFiles
operator|.
name|CustomBuild
operator|=
name|none
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initResourceFiles
name|void
name|VcprojGenerator
operator|::
name|initResourceFiles
parameter_list|()
block|{
name|vcProject
operator|.
name|ResourceFiles
operator|.
name|Name
operator|=
literal|"Resource Files"
expr_stmt|;
name|vcProject
operator|.
name|ResourceFiles
operator|.
name|ParseFiles
operator|=
name|_False
expr_stmt|;
name|vcProject
operator|.
name|ResourceFiles
operator|.
name|Filter
operator|=
literal|"qrc;*"
expr_stmt|;
comment|//"rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;ts;xlf;qrc";
name|vcProject
operator|.
name|ResourceFiles
operator|.
name|Guid
operator|=
name|_GUIDResourceFiles
expr_stmt|;
comment|// Bad hack, please look away -------------------------------------
name|QString
name|rcc_dep_cmd
init|=
name|project
operator|->
name|values
argument_list|(
literal|"rcc.depend_command"
argument_list|)
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rcc_dep_cmd
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ProStringList
name|qrc_files
init|=
name|project
operator|->
name|values
argument_list|(
literal|"RESOURCES"
argument_list|)
decl_stmt|;
name|QStringList
name|deps
decl_stmt|;
if|if
condition|(
operator|!
name|qrc_files
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|qrc_files
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|char
name|buff
index|[
literal|256
index|]
decl_stmt|;
name|QString
name|dep_cmd
init|=
name|replaceExtraCompilerVariables
argument_list|(
name|rcc_dep_cmd
argument_list|,
name|qrc_files
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toQString
argument_list|()
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|dep_cmd
operator|=
name|Option
operator|::
name|fixPathToLocalOS
argument_list|(
name|dep_cmd
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|canExecute
argument_list|(
name|dep_cmd
argument_list|)
condition|)
block|{
name|dep_cmd
operator|.
name|prepend
argument_list|(
name|QLatin1String
argument_list|(
literal|"cd "
argument_list|)
operator|+
name|escapeFilePath
argument_list|(
name|Option
operator|::
name|fixPathToLocalOS
argument_list|(
name|Option
operator|::
name|output_dir
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"&& "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FILE
modifier|*
name|proc
init|=
name|QT_POPEN
argument_list|(
name|dep_cmd
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
name|QString
name|indeps
decl_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|int
name|read_in
init|=
operator|(
name|int
operator|)
name|fread
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
literal|255
argument_list|,
name|proc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|read_in
condition|)
break|break;
name|indeps
operator|+=
name|QByteArray
argument_list|(
name|buff
argument_list|,
name|read_in
argument_list|)
expr_stmt|;
block|}
name|QT_PCLOSE
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indeps
operator|.
name|isEmpty
argument_list|()
condition|)
name|deps
operator|+=
name|fileFixify
argument_list|(
name|indeps
operator|.
name|replace
argument_list|(
literal|'\n'
argument_list|,
literal|' '
argument_list|)
operator|.
name|simplified
argument_list|()
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|,
name|Option
operator|::
name|output_dir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|vcProject
operator|.
name|ResourceFiles
operator|.
name|addFiles
argument_list|(
name|deps
argument_list|)
expr_stmt|;
block|}
block|}
comment|// You may look again --------------------------------------------
name|vcProject
operator|.
name|ResourceFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"RESOURCES"
argument_list|)
argument_list|)
expr_stmt|;
name|vcProject
operator|.
name|ResourceFiles
operator|.
name|addFiles
argument_list|(
name|project
operator|->
name|values
argument_list|(
literal|"IMAGES"
argument_list|)
argument_list|)
expr_stmt|;
name|vcProject
operator|.
name|ResourceFiles
operator|.
name|Project
operator|=
name|this
expr_stmt|;
name|vcProject
operator|.
name|ResourceFiles
operator|.
name|Config
operator|=
operator|&
operator|(
name|vcProject
operator|.
name|Configuration
operator|)
expr_stmt|;
name|vcProject
operator|.
name|ResourceFiles
operator|.
name|CustomBuild
operator|=
name|none
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initExtraCompilerOutputs
name|void
name|VcprojGenerator
operator|::
name|initExtraCompilerOutputs
parameter_list|()
block|{
name|ProStringList
name|otherFilters
decl_stmt|;
name|otherFilters
operator|<<
literal|"FORMS"
operator|<<
literal|"FORMS3"
operator|<<
literal|"GENERATED_FILES"
operator|<<
literal|"GENERATED_SOURCES"
operator|<<
literal|"HEADERS"
operator|<<
literal|"IDLSOURCES"
operator|<<
literal|"IMAGES"
operator|<<
literal|"LEXSOURCES"
operator|<<
literal|"QMAKE_IMAGE_COLLECTION"
operator|<<
literal|"RC_FILE"
operator|<<
literal|"RESOURCES"
operator|<<
literal|"RES_FILE"
operator|<<
literal|"SOURCES"
operator|<<
literal|"TRANSLATIONS"
operator|<<
literal|"YACCSOURCES"
expr_stmt|;
specifier|const
name|ProStringList
modifier|&
name|quc
init|=
name|project
operator|->
name|values
argument_list|(
literal|"QMAKE_EXTRA_COMPILERS"
argument_list|)
decl_stmt|;
for|for
control|(
name|ProStringList
operator|::
name|ConstIterator
name|it
init|=
name|quc
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|quc
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|ProString
name|extracompilerName
init|=
name|project
operator|->
name|first
argument_list|(
name|ProKey
argument_list|(
operator|*
name|it
operator|+
literal|".name"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|extracompilerName
operator|.
name|isEmpty
argument_list|()
condition|)
name|extracompilerName
operator|=
operator|(
operator|*
name|it
operator|)
expr_stmt|;
comment|// Create an extra compiler filter and add the files
name|VCFilter
name|extraCompile
decl_stmt|;
name|extraCompile
operator|.
name|Name
operator|=
name|extracompilerName
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|extraCompile
operator|.
name|ParseFiles
operator|=
name|_False
expr_stmt|;
name|extraCompile
operator|.
name|Filter
operator|=
literal|""
expr_stmt|;
name|extraCompile
operator|.
name|Guid
operator|=
name|QString
argument_list|(
name|_GUIDExtraCompilerFiles
argument_list|)
operator|+
literal|"-"
operator|+
operator|(
operator|*
name|it
operator|)
expr_stmt|;
comment|// If the extra compiler has a variable_out set the output file
comment|// is added to an other file list, and does not need its own..
name|bool
name|addOnInput
init|=
name|hasBuiltinCompiler
argument_list|(
name|project
operator|->
name|first
argument_list|(
name|ProKey
argument_list|(
operator|*
name|it
operator|+
literal|".output"
argument_list|)
argument_list|)
operator|.
name|toQString
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|ProString
modifier|&
name|tmp_other_out
init|=
name|project
operator|->
name|first
argument_list|(
name|ProKey
argument_list|(
operator|*
name|it
operator|+
literal|".variable_out"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmp_other_out
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|addOnInput
condition|)
continue|continue;
if|if
condition|(
operator|!
name|addOnInput
condition|)
block|{
name|QString
name|tmp_out
init|=
name|project
operator|->
name|first
argument_list|(
name|ProKey
argument_list|(
operator|*
name|it
operator|+
literal|".output"
argument_list|)
argument_list|)
operator|.
name|toQString
argument_list|()
decl_stmt|;
if|if
condition|(
name|project
operator|->
name|values
argument_list|(
name|ProKey
argument_list|(
operator|*
name|it
operator|+
literal|".CONFIG"
argument_list|)
argument_list|)
operator|.
name|indexOf
argument_list|(
literal|"combine"
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Combined output, only one file result
name|extraCompile
operator|.
name|addFile
argument_list|(
name|Option
operator|::
name|fixPathToTargetOS
argument_list|(
name|replaceExtraCompilerVariables
argument_list|(
name|tmp_out
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// One output file per input
specifier|const
name|ProStringList
modifier|&
name|tmp_in
init|=
name|project
operator|->
name|values
argument_list|(
name|project
operator|->
name|first
argument_list|(
name|ProKey
argument_list|(
operator|*
name|it
operator|+
literal|".input"
argument_list|)
argument_list|)
operator|.
name|toKey
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tmp_in
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
modifier|&
name|filename
init|=
name|tmp_in
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toQString
argument_list|()
decl_stmt|;
if|if
condition|(
name|extraCompilerSources
operator|.
name|contains
argument_list|(
name|filename
argument_list|)
condition|)
name|extraCompile
operator|.
name|addFile
argument_list|(
name|Option
operator|::
name|fixPathToTargetOS
argument_list|(
name|replaceExtraCompilerVariables
argument_list|(
name|filename
argument_list|,
name|tmp_out
argument_list|,
name|QString
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// In this case we the outputs have a built-in compiler, so we cannot add the custom
comment|// build steps there. So, we turn it around and add it to the input files instead,
comment|// provided that the input file variable is not handled already (those in otherFilters
comment|// are handled, so we avoid them).
specifier|const
name|ProStringList
modifier|&
name|inputVars
init|=
name|project
operator|->
name|values
argument_list|(
name|ProKey
argument_list|(
operator|*
name|it
operator|+
literal|".input"
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|ProString
modifier|&
name|inputVar
decl|,
name|inputVars
control|)
block|{
if|if
condition|(
operator|!
name|otherFilters
operator|.
name|contains
argument_list|(
name|inputVar
argument_list|)
condition|)
block|{
specifier|const
name|ProStringList
modifier|&
name|tmp_in
init|=
name|project
operator|->
name|values
argument_list|(
name|inputVar
operator|.
name|toKey
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tmp_in
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
modifier|&
name|filename
init|=
name|tmp_in
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toQString
argument_list|()
decl_stmt|;
if|if
condition|(
name|extraCompilerSources
operator|.
name|contains
argument_list|(
name|filename
argument_list|)
condition|)
name|extraCompile
operator|.
name|addFile
argument_list|(
name|Option
operator|::
name|fixPathToTargetOS
argument_list|(
name|replaceExtraCompilerVariables
argument_list|(
name|filename
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|extraCompile
operator|.
name|Project
operator|=
name|this
expr_stmt|;
name|extraCompile
operator|.
name|Config
operator|=
operator|&
operator|(
name|vcProject
operator|.
name|Configuration
operator|)
expr_stmt|;
name|extraCompile
operator|.
name|CustomBuild
operator|=
name|none
expr_stmt|;
name|vcProject
operator|.
name|ExtraCompilersFiles
operator|.
name|append
argument_list|(
name|extraCompile
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|initOld
name|void
name|VcprojGenerator
operator|::
name|initOld
parameter_list|()
block|{
comment|// $$QMAKE.. -> $$MSVCPROJ.. -------------------------------------
specifier|const
name|ProStringList
modifier|&
name|incs
init|=
name|project
operator|->
name|values
argument_list|(
literal|"INCLUDEPATH"
argument_list|)
decl_stmt|;
for|for
control|(
name|ProStringList
operator|::
name|ConstIterator
name|incit
init|=
name|incs
operator|.
name|begin
argument_list|()
init|;
name|incit
operator|!=
name|incs
operator|.
name|end
argument_list|()
condition|;
operator|++
name|incit
control|)
block|{
name|QString
name|inc
init|=
operator|(
operator|*
name|incit
operator|)
operator|.
name|toQString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|inc
operator|.
name|startsWith
argument_list|(
literal|'"'
argument_list|)
operator|&&
operator|!
name|inc
operator|.
name|endsWith
argument_list|(
literal|'"'
argument_list|)
condition|)
name|inc
operator|=
name|QString
argument_list|(
literal|"\"%1\""
argument_list|)
operator|.
name|arg
argument_list|(
name|inc
argument_list|)
expr_stmt|;
comment|// Quote all paths if not quoted already
name|project
operator|->
name|values
argument_list|(
literal|"MSVCPROJ_INCPATH"
argument_list|)
operator|.
name|append
argument_list|(
literal|"-I"
operator|+
name|inc
argument_list|)
expr_stmt|;
block|}
name|project
operator|->
name|values
argument_list|(
literal|"MSVCPROJ_INCPATH"
argument_list|)
operator|.
name|append
argument_list|(
literal|"-I"
operator|+
name|specdir
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|dest
init|=
name|Option
operator|::
name|fixPathToTargetOS
argument_list|(
name|project
operator|->
name|first
argument_list|(
literal|"TARGET"
argument_list|)
operator|.
name|toQString
argument_list|()
argument_list|)
operator|+
name|project
operator|->
name|first
argument_list|(
literal|"TARGET_EXT"
argument_list|)
decl_stmt|;
name|project
operator|->
name|values
argument_list|(
literal|"MSVCPROJ_TARGET"
argument_list|)
operator|=
name|ProStringList
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|// DLL COPY ------------------------------------------------------
if|if
condition|(
name|project
operator|->
name|isActiveConfig
argument_list|(
literal|"dll"
argument_list|)
operator|&&
operator|!
name|project
operator|->
name|values
argument_list|(
literal|"DLLDESTDIR"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|ProStringList
modifier|&
name|dlldirs
init|=
name|project
operator|->
name|values
argument_list|(
literal|"DLLDESTDIR"
argument_list|)
decl_stmt|;
name|QString
name|copydll
argument_list|(
literal|""
argument_list|)
decl_stmt|;
name|ProStringList
operator|::
name|ConstIterator
name|dlldir
decl_stmt|;
for|for
control|(
name|dlldir
operator|=
name|dlldirs
operator|.
name|begin
argument_list|()
init|;
name|dlldir
operator|!=
name|dlldirs
operator|.
name|end
argument_list|()
condition|;
operator|++
name|dlldir
control|)
block|{
if|if
condition|(
operator|!
name|copydll
operator|.
name|isEmpty
argument_list|()
condition|)
name|copydll
operator|+=
literal|"&& "
expr_stmt|;
name|copydll
operator|+=
literal|"copy  \"$(TargetPath)\" \""
operator|+
operator|*
name|dlldir
operator|+
literal|"\""
expr_stmt|;
block|}
name|QString
name|deststr
argument_list|(
literal|"Copy "
operator|+
name|dest
operator|+
literal|" to "
argument_list|)
decl_stmt|;
for|for
control|(
name|dlldir
operator|=
name|dlldirs
operator|.
name|begin
argument_list|()
init|;
name|dlldir
operator|!=
name|dlldirs
operator|.
name|end
argument_list|()
condition|;
control|)
block|{
name|deststr
operator|+=
operator|*
name|dlldir
expr_stmt|;
operator|++
name|dlldir
expr_stmt|;
if|if
condition|(
name|dlldir
operator|!=
name|dlldirs
operator|.
name|end
argument_list|()
condition|)
name|deststr
operator|+=
literal|", "
expr_stmt|;
block|}
name|project
operator|->
name|values
argument_list|(
literal|"MSVCPROJ_COPY_DLL"
argument_list|)
operator|.
name|append
argument_list|(
name|copydll
argument_list|)
expr_stmt|;
name|project
operator|->
name|values
argument_list|(
literal|"MSVCPROJ_COPY_DLL_DESC"
argument_list|)
operator|.
name|append
argument_list|(
name|deststr
argument_list|)
expr_stmt|;
block|}
comment|// Verbose output if "-d -d"...
name|outputVariables
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// ------------------------------------------------------------------------------------------------
end_comment
begin_comment
comment|// ------------------------------------------------------------------------------------------------
end_comment
begin_function
DECL|function|createProjectWriter
name|VCProjectWriter
modifier|*
name|VcprojGenerator
operator|::
name|createProjectWriter
parameter_list|()
block|{
return|return
operator|new
name|VCProjectWriter
return|;
block|}
end_function
begin_function
DECL|function|replaceExtraCompilerVariables
name|QString
name|VcprojGenerator
operator|::
name|replaceExtraCompilerVariables
parameter_list|(
specifier|const
name|QString
modifier|&
name|var
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|in
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|out
parameter_list|)
block|{
name|QString
name|ret
init|=
name|MakefileGenerator
operator|::
name|replaceExtraCompilerVariables
argument_list|(
name|var
argument_list|,
name|in
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|ProStringList
modifier|&
name|defines
init|=
name|project
operator|->
name|values
argument_list|(
literal|"VCPROJ_MAKEFILE_DEFINES"
argument_list|)
decl_stmt|;
if|if
condition|(
name|defines
operator|.
name|isEmpty
argument_list|()
condition|)
name|defines
operator|.
name|append
argument_list|(
name|varGlue
argument_list|(
literal|"PRL_EXPORT_DEFINES"
argument_list|,
literal|" -D"
argument_list|,
literal|" -D"
argument_list|,
literal|""
argument_list|)
operator|+
name|varGlue
argument_list|(
literal|"DEFINES"
argument_list|,
literal|" -D"
argument_list|,
literal|" -D"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|replace
argument_list|(
literal|"$(DEFINES)"
argument_list|,
name|defines
operator|.
name|first
argument_list|()
operator|.
name|toQString
argument_list|()
argument_list|)
expr_stmt|;
name|ProStringList
modifier|&
name|incpath
init|=
name|project
operator|->
name|values
argument_list|(
literal|"VCPROJ_MAKEFILE_INCPATH"
argument_list|)
decl_stmt|;
if|if
condition|(
name|incpath
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|this
operator|->
name|var
argument_list|(
literal|"MSVCPROJ_INCPATH"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|incpath
operator|.
name|append
argument_list|(
name|this
operator|->
name|var
argument_list|(
literal|"MSVCPROJ_INCPATH"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|replace
argument_list|(
literal|"$(INCPATH)"
argument_list|,
name|incpath
operator|.
name|join
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|openOutput
name|bool
name|VcprojGenerator
operator|::
name|openOutput
parameter_list|(
name|QFile
modifier|&
name|file
parameter_list|,
specifier|const
name|QString
modifier|&
comment|/*build*/
parameter_list|)
specifier|const
block|{
name|QString
name|outdir
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|fileName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QFileInfo
name|fi
argument_list|(
name|fileInfo
argument_list|(
name|file
operator|.
name|fileName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|isDir
argument_list|()
condition|)
name|outdir
operator|=
name|file
operator|.
name|fileName
argument_list|()
operator|+
name|QDir
operator|::
name|separator
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|outdir
operator|.
name|isEmpty
argument_list|()
operator|||
name|file
operator|.
name|fileName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ProString
name|ext
init|=
name|project
operator|->
name|first
argument_list|(
literal|"VCPROJ_EXTENSION"
argument_list|)
decl_stmt|;
if|if
condition|(
name|project
operator|->
name|first
argument_list|(
literal|"TEMPLATE"
argument_list|)
operator|==
literal|"vcsubdirs"
condition|)
name|ext
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"VCSOLUTION_EXTENSION"
argument_list|)
expr_stmt|;
name|ProString
name|outputName
init|=
name|unescapeFilePath
argument_list|(
name|project
operator|->
name|first
argument_list|(
literal|"TARGET"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|project
operator|->
name|first
argument_list|(
literal|"MAKEFILE"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|outputName
operator|=
name|project
operator|->
name|first
argument_list|(
literal|"MAKEFILE"
argument_list|)
expr_stmt|;
name|file
operator|.
name|setFileName
argument_list|(
name|outdir
operator|+
name|outputName
operator|+
name|ext
argument_list|)
expr_stmt|;
block|}
return|return
name|Win32MakefileGenerator
operator|::
name|openOutput
argument_list|(
name|file
argument_list|,
name|QString
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fixFilename
name|QString
name|VcprojGenerator
operator|::
name|fixFilename
parameter_list|(
name|QString
name|ofile
parameter_list|)
specifier|const
block|{
name|ofile
operator|=
name|Option
operator|::
name|fixPathToLocalOS
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
name|int
name|slashfind
init|=
name|ofile
operator|.
name|lastIndexOf
argument_list|(
name|Option
operator|::
name|dir_sep
argument_list|)
decl_stmt|;
if|if
condition|(
name|slashfind
operator|==
operator|-
literal|1
condition|)
block|{
name|ofile
operator|=
name|ofile
operator|.
name|replace
argument_list|(
literal|'-'
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|hyphenfind
init|=
name|ofile
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|,
name|slashfind
argument_list|)
decl_stmt|;
while|while
condition|(
name|hyphenfind
operator|!=
operator|-
literal|1
operator|&&
name|slashfind
operator|<
name|hyphenfind
condition|)
block|{
name|ofile
operator|=
name|ofile
operator|.
name|replace
argument_list|(
name|hyphenfind
argument_list|,
literal|1
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
name|hyphenfind
operator|=
name|ofile
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|,
name|hyphenfind
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ofile
return|;
block|}
end_function
begin_function
DECL|function|outputVariables
name|void
name|VcprojGenerator
operator|::
name|outputVariables
parameter_list|()
block|{
if|#
directive|if
literal|0
block|qDebug("Generator: MSVC.NET: List of current variables:");     for (ProValueMap::ConstIterator it = project->variables().begin(); it != project->variables().end(); ++it)         qDebug("Generator: MSVC.NET: %s => %s", qPrintable(it.key().toQString()), qPrintable(it.value().join(" | ")));
endif|#
directive|endif
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
