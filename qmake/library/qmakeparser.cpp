begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the qmake application of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qmakeparser.h"
end_include
begin_include
include|#
directive|include
file|"qmakevfs.h"
end_include
begin_include
include|#
directive|include
file|"ioutils.h"
end_include
begin_using
using|using
namespace|namespace
name|QMakeInternal
namespace|;
end_using
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|PROPARSER_THREAD_SAFE
end_ifdef
begin_include
include|#
directive|include
file|<qthreadpool.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|QT_BEGIN_NAMESPACE
comment|///////////////////////////////////////////////////////////////////////
comment|//
comment|// ProFileCache
comment|//
comment|///////////////////////////////////////////////////////////////////////
DECL|function|~ProFileCache
name|ProFileCache
operator|::
name|~
name|ProFileCache
operator|(
operator|)
block|{
foreach|foreach
control|(
specifier|const
name|Entry
modifier|&
name|ent
decl|,
name|parsed_files
control|)
if|if
condition|(
name|ent
operator|.
name|pro
condition|)
name|ent
operator|.
name|pro
operator|->
name|deref
argument_list|()
expr_stmt|;
block|}
end_expr_stmt
begin_function
DECL|function|discardFile
name|void
name|ProFileCache
operator|::
name|discardFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PROPARSER_THREAD_SAFE
name|QMutexLocker
name|lck
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|QHash
argument_list|<
name|QString
argument_list|,
name|Entry
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|parsed_files
operator|.
name|find
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|parsed_files
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|pro
condition|)
name|it
operator|->
name|pro
operator|->
name|deref
argument_list|()
expr_stmt|;
name|parsed_files
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|discardFiles
name|void
name|ProFileCache
operator|::
name|discardFiles
parameter_list|(
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PROPARSER_THREAD_SAFE
name|QMutexLocker
name|lck
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|QHash
argument_list|<
name|QString
argument_list|,
name|Entry
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|parsed_files
operator|.
name|begin
argument_list|()
decl_stmt|,
name|end
init|=
name|parsed_files
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|end
condition|)
if|if
condition|(
name|it
operator|.
name|key
argument_list|()
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|pro
condition|)
name|it
operator|->
name|pro
operator|->
name|deref
argument_list|()
expr_stmt|;
name|it
operator|=
name|parsed_files
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|////////// Parser ///////////
end_comment
begin_define
DECL|macro|fL1S
define|#
directive|define
name|fL1S
parameter_list|(
name|s
parameter_list|)
value|QString::fromLatin1(s)
end_define
begin_namespace
namespace|namespace
block|{
comment|// MSVC2010 doesn't seem to know the semantics of "static" ...
specifier|static
struct|struct
block|{
DECL|member|strelse
name|QString
name|strelse
decl_stmt|;
DECL|member|strfor
name|QString
name|strfor
decl_stmt|;
DECL|member|strdefineTest
name|QString
name|strdefineTest
decl_stmt|;
DECL|member|strdefineReplace
name|QString
name|strdefineReplace
decl_stmt|;
DECL|member|stroption
name|QString
name|stroption
decl_stmt|;
DECL|member|strreturn
name|QString
name|strreturn
decl_stmt|;
DECL|member|strnext
name|QString
name|strnext
decl_stmt|;
DECL|member|strbreak
name|QString
name|strbreak
decl_stmt|;
DECL|member|strhost_build
name|QString
name|strhost_build
decl_stmt|;
DECL|member|strLINE
name|QString
name|strLINE
decl_stmt|;
DECL|member|strFILE
name|QString
name|strFILE
decl_stmt|;
DECL|member|strLITERAL_HASH
name|QString
name|strLITERAL_HASH
decl_stmt|;
DECL|member|strLITERAL_DOLLAR
name|QString
name|strLITERAL_DOLLAR
decl_stmt|;
DECL|member|strLITERAL_WHITESPACE
name|QString
name|strLITERAL_WHITESPACE
decl_stmt|;
block|}
DECL|member|statics
name|statics
struct|;
block|}
end_namespace
begin_function
DECL|function|initialize
name|void
name|QMakeParser
operator|::
name|initialize
parameter_list|()
block|{
if|if
condition|(
operator|!
name|statics
operator|.
name|strelse
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|statics
operator|.
name|strelse
operator|=
name|QLatin1String
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strfor
operator|=
name|QLatin1String
argument_list|(
literal|"for"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strdefineTest
operator|=
name|QLatin1String
argument_list|(
literal|"defineTest"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strdefineReplace
operator|=
name|QLatin1String
argument_list|(
literal|"defineReplace"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|stroption
operator|=
name|QLatin1String
argument_list|(
literal|"option"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strreturn
operator|=
name|QLatin1String
argument_list|(
literal|"return"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strnext
operator|=
name|QLatin1String
argument_list|(
literal|"next"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strbreak
operator|=
name|QLatin1String
argument_list|(
literal|"break"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strhost_build
operator|=
name|QLatin1String
argument_list|(
literal|"host_build"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strLINE
operator|=
name|QLatin1String
argument_list|(
literal|"_LINE_"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strFILE
operator|=
name|QLatin1String
argument_list|(
literal|"_FILE_"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strLITERAL_HASH
operator|=
name|QLatin1String
argument_list|(
literal|"LITERAL_HASH"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strLITERAL_DOLLAR
operator|=
name|QLatin1String
argument_list|(
literal|"LITERAL_DOLLAR"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strLITERAL_WHITESPACE
operator|=
name|QLatin1String
argument_list|(
literal|"LITERAL_WHITESPACE"
argument_list|)
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QMakeParser
name|QMakeParser
operator|::
name|QMakeParser
parameter_list|(
name|ProFileCache
modifier|*
name|cache
parameter_list|,
name|QMakeVfs
modifier|*
name|vfs
parameter_list|,
name|QMakeParserHandler
modifier|*
name|handler
parameter_list|)
member_init_list|:
name|m_cache
argument_list|(
name|cache
argument_list|)
member_init_list|,
name|m_handler
argument_list|(
name|handler
argument_list|)
member_init_list|,
name|m_vfs
argument_list|(
name|vfs
argument_list|)
block|{
comment|// So that single-threaded apps don't have to call initialize() for now.
name|initialize
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|parsedProFile
name|ProFile
modifier|*
name|QMakeParser
operator|::
name|parsedProFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|ParseFlags
name|flags
parameter_list|)
block|{
name|ProFile
modifier|*
name|pro
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ParseUseCache
operator|)
operator|&&
name|m_cache
condition|)
block|{
name|ProFileCache
operator|::
name|Entry
modifier|*
name|ent
decl_stmt|;
ifdef|#
directive|ifdef
name|PROPARSER_THREAD_SAFE
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_cache
operator|->
name|mutex
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|QHash
argument_list|<
name|QString
argument_list|,
name|ProFileCache
operator|::
name|Entry
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|m_cache
operator|->
name|parsed_files
operator|.
name|find
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|m_cache
operator|->
name|parsed_files
operator|.
name|end
argument_list|()
condition|)
block|{
name|ent
operator|=
operator|&
operator|*
name|it
expr_stmt|;
ifdef|#
directive|ifdef
name|PROPARSER_THREAD_SAFE
if|if
condition|(
name|ent
operator|->
name|locker
operator|&&
operator|!
name|ent
operator|->
name|locker
operator|->
name|done
condition|)
block|{
operator|++
name|ent
operator|->
name|locker
operator|->
name|waiters
expr_stmt|;
name|QThreadPool
operator|::
name|globalInstance
argument_list|()
operator|->
name|releaseThread
argument_list|()
expr_stmt|;
name|ent
operator|->
name|locker
operator|->
name|cond
operator|.
name|wait
argument_list|(
name|locker
operator|.
name|mutex
argument_list|()
argument_list|)
expr_stmt|;
name|QThreadPool
operator|::
name|globalInstance
argument_list|()
operator|->
name|reserveThread
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|ent
operator|->
name|locker
operator|->
name|waiters
condition|)
block|{
operator|delete
name|ent
operator|->
name|locker
expr_stmt|;
name|ent
operator|->
name|locker
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|pro
operator|=
name|ent
operator|->
name|pro
operator|)
condition|)
name|pro
operator|->
name|ref
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ent
operator|=
operator|&
name|m_cache
operator|->
name|parsed_files
index|[
name|fileName
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|PROPARSER_THREAD_SAFE
name|ent
operator|->
name|locker
operator|=
operator|new
name|ProFileCache
operator|::
name|Entry
operator|::
name|Locker
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|pro
operator|=
operator|new
name|ProFile
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|read
argument_list|(
name|pro
argument_list|,
name|flags
argument_list|)
condition|)
block|{
operator|delete
name|pro
expr_stmt|;
name|pro
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pro
operator|->
name|itemsRef
argument_list|()
operator|->
name|squeeze
argument_list|()
expr_stmt|;
name|pro
operator|->
name|ref
argument_list|()
expr_stmt|;
block|}
name|ent
operator|->
name|pro
operator|=
name|pro
expr_stmt|;
ifdef|#
directive|ifdef
name|PROPARSER_THREAD_SAFE
name|locker
operator|.
name|relock
argument_list|()
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|locker
operator|->
name|waiters
condition|)
block|{
name|ent
operator|->
name|locker
operator|->
name|done
operator|=
literal|true
expr_stmt|;
name|ent
operator|->
name|locker
operator|->
name|cond
operator|.
name|wakeAll
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|delete
name|ent
operator|->
name|locker
expr_stmt|;
name|ent
operator|->
name|locker
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|pro
operator|=
operator|new
name|ProFile
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|read
argument_list|(
name|pro
argument_list|,
name|flags
argument_list|)
condition|)
block|{
operator|delete
name|pro
expr_stmt|;
name|pro
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|pro
return|;
block|}
end_function
begin_function
DECL|function|parsedProBlock
name|ProFile
modifier|*
name|QMakeParser
operator|::
name|parsedProBlock
parameter_list|(
specifier|const
name|QString
modifier|&
name|contents
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|int
name|line
parameter_list|,
name|SubGrammar
name|grammar
parameter_list|)
block|{
name|ProFile
modifier|*
name|pro
init|=
operator|new
name|ProFile
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|read
argument_list|(
name|pro
argument_list|,
name|contents
argument_list|,
name|line
argument_list|,
name|grammar
argument_list|)
condition|)
block|{
operator|delete
name|pro
expr_stmt|;
name|pro
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|pro
return|;
block|}
end_function
begin_function
DECL|function|discardFileFromCache
name|void
name|QMakeParser
operator|::
name|discardFileFromCache
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
if|if
condition|(
name|m_cache
condition|)
name|m_cache
operator|->
name|discardFile
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read
name|bool
name|QMakeParser
operator|::
name|read
parameter_list|(
name|ProFile
modifier|*
name|pro
parameter_list|,
name|ParseFlags
name|flags
parameter_list|)
block|{
name|QString
name|content
decl_stmt|;
name|QString
name|errStr
decl_stmt|;
if|if
condition|(
operator|!
name|m_vfs
operator|->
name|readFile
argument_list|(
name|pro
operator|->
name|fileName
argument_list|()
argument_list|,
operator|&
name|content
argument_list|,
operator|&
name|errStr
argument_list|)
condition|)
block|{
if|if
condition|(
name|m_handler
operator|&&
operator|(
operator|(
name|flags
operator|&
name|ParseReportMissing
operator|)
operator|||
name|m_vfs
operator|->
name|exists
argument_list|(
name|pro
operator|->
name|fileName
argument_list|()
argument_list|)
operator|)
condition|)
name|m_handler
operator|->
name|message
argument_list|(
name|QMakeParserHandler
operator|::
name|ParserIoError
argument_list|,
name|fL1S
argument_list|(
literal|"Cannot read %1: %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|pro
operator|->
name|fileName
argument_list|()
argument_list|,
name|errStr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|read
argument_list|(
name|pro
argument_list|,
name|content
argument_list|,
literal|1
argument_list|,
name|FullGrammar
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|putTok
name|void
name|QMakeParser
operator|::
name|putTok
parameter_list|(
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|,
name|ushort
name|tok
parameter_list|)
block|{
operator|*
name|tokPtr
operator|++
operator|=
name|tok
expr_stmt|;
block|}
end_function
begin_function
DECL|function|putBlockLen
name|void
name|QMakeParser
operator|::
name|putBlockLen
parameter_list|(
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
operator|*
name|tokPtr
operator|++
operator|=
operator|(
name|ushort
operator|)
name|len
expr_stmt|;
operator|*
name|tokPtr
operator|++
operator|=
call|(
name|ushort
call|)
argument_list|(
name|len
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|putBlock
name|void
name|QMakeParser
operator|::
name|putBlock
parameter_list|(
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|,
specifier|const
name|ushort
modifier|*
name|buf
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
name|memcpy
argument_list|(
name|tokPtr
argument_list|,
name|buf
argument_list|,
name|len
operator|*
literal|2
argument_list|)
expr_stmt|;
name|tokPtr
operator|+=
name|len
expr_stmt|;
block|}
end_function
begin_function
DECL|function|putHashStr
name|void
name|QMakeParser
operator|::
name|putHashStr
parameter_list|(
name|ushort
modifier|*
modifier|&
name|pTokPtr
parameter_list|,
specifier|const
name|ushort
modifier|*
name|buf
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
name|uint
name|hash
init|=
name|ProString
operator|::
name|hash
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|ushort
modifier|*
name|tokPtr
init|=
name|pTokPtr
decl_stmt|;
operator|*
name|tokPtr
operator|++
operator|=
operator|(
name|ushort
operator|)
name|hash
expr_stmt|;
operator|*
name|tokPtr
operator|++
operator|=
call|(
name|ushort
call|)
argument_list|(
name|hash
operator|>>
literal|16
argument_list|)
expr_stmt|;
operator|*
name|tokPtr
operator|++
operator|=
operator|(
name|ushort
operator|)
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|tokPtr
argument_list|,
name|buf
argument_list|,
name|len
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pTokPtr
operator|=
name|tokPtr
operator|+
name|len
expr_stmt|;
block|}
end_function
begin_function
DECL|function|finalizeHashStr
name|void
name|QMakeParser
operator|::
name|finalizeHashStr
parameter_list|(
name|ushort
modifier|*
name|buf
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
name|buf
index|[
operator|-
literal|4
index|]
operator|=
name|TokHashLiteral
expr_stmt|;
name|buf
index|[
operator|-
literal|1
index|]
operator|=
name|len
expr_stmt|;
name|uint
name|hash
init|=
name|ProString
operator|::
name|hash
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|buf
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|ushort
operator|)
name|hash
expr_stmt|;
name|buf
index|[
operator|-
literal|2
index|]
operator|=
call|(
name|ushort
call|)
argument_list|(
name|hash
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read
name|bool
name|QMakeParser
operator|::
name|read
parameter_list|(
name|ProFile
modifier|*
name|pro
parameter_list|,
specifier|const
name|QString
modifier|&
name|in
parameter_list|,
name|int
name|line
parameter_list|,
name|SubGrammar
name|grammar
parameter_list|)
block|{
name|m_proFile
operator|=
name|pro
expr_stmt|;
name|m_lineNo
operator|=
name|line
expr_stmt|;
comment|// Final precompiled token stream buffer
name|QString
name|tokBuff
decl_stmt|;
comment|// Worst-case size calculations:
comment|// - line marker adds 1 (2-nl) to 1st token of each line
comment|// - empty assignment "A=":2 =>
comment|//   TokHashLiteral(1) + hash(2) + len(1) + "A"(1) + TokAssign(1) + 0(1) +
comment|//   TokValueTerminator(1) == 8 (9)
comment|// - non-empty assignment "A=B C":5 =>
comment|//   TokHashLiteral(1) + hash(2) + len(1) + "A"(1) + TokAssign(1) + 2(1) +
comment|//   TokLiteral(1) + len(1) + "B"(1) +
comment|//   TokLiteral(1) + len(1) + "C"(1) + TokValueTerminator(1) == 14 (15)
comment|// - variable expansion: "$$f":3 =>
comment|//   TokVariable(1) + hash(2) + len(1) + "f"(1) = 5
comment|// - function expansion: "$$f()":5 =>
comment|//   TokFuncName(1) + hash(2) + len(1) + "f"(1) + TokFuncTerminator(1) = 6
comment|// - scope: "X:":2 =>
comment|//   TokHashLiteral(1) + hash(2) + len(1) + "A"(1) + TokCondition(1) +
comment|//   TokBranch(1) + len(2) + ... + len(2) + ... == 10
comment|// - test: "X():":4 =>
comment|//   TokHashLiteral(1) + hash(2) + len(1) + "A"(1) + TokTestCall(1) + TokFuncTerminator(1) +
comment|//   TokBranch(1) + len(2) + ... + len(2) + ... == 11
comment|// - "for(A,B):":9 =>
comment|//   TokForLoop(1) + hash(2) + len(1) + "A"(1) +
comment|//   len(2) + TokLiteral(1) + len(1) + "B"(1) + TokValueTerminator(1) +
comment|//   len(2) + ... + TokTerminator(1) == 14 (15)
name|tokBuff
operator|.
name|reserve
argument_list|(
operator|(
name|in
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|)
operator|*
literal|5
argument_list|)
expr_stmt|;
name|ushort
modifier|*
name|tokPtr
init|=
operator|(
name|ushort
operator|*
operator|)
name|tokBuff
operator|.
name|constData
argument_list|()
decl_stmt|;
comment|// Current writing position
comment|// Expression precompiler buffer.
name|QString
name|xprBuff
decl_stmt|;
name|xprBuff
operator|.
name|reserve
argument_list|(
name|tokBuff
operator|.
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
comment|// Excessive, but simple
name|ushort
modifier|*
name|buf
init|=
operator|(
name|ushort
operator|*
operator|)
name|xprBuff
operator|.
name|constData
argument_list|()
decl_stmt|;
comment|// Parser state
name|m_blockstack
operator|.
name|clear
argument_list|()
expr_stmt|;
name|m_blockstack
operator|.
name|resize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|QStack
argument_list|<
name|ParseCtx
argument_list|>
name|xprStack
decl_stmt|;
name|xprStack
operator|.
name|reserve
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|// We rely on QStrings being null-terminated, so don't maintain a global end pointer.
specifier|const
name|ushort
modifier|*
name|cur
init|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|in
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|m_canElse
operator|=
literal|false
expr_stmt|;
name|freshLine
label|:
name|m_state
operator|=
name|StNew
expr_stmt|;
name|m_invert
operator|=
literal|false
expr_stmt|;
name|m_operator
operator|=
name|NoOperator
expr_stmt|;
name|m_markLine
operator|=
name|m_lineNo
expr_stmt|;
name|m_inError
operator|=
literal|false
expr_stmt|;
name|int
name|parens
init|=
literal|0
decl_stmt|;
comment|// Braces in value context
name|int
name|argc
init|=
literal|0
decl_stmt|;
name|int
name|wordCount
init|=
literal|0
decl_stmt|;
comment|// Number of words in currently accumulated expression
name|int
name|lastIndent
init|=
literal|0
decl_stmt|;
comment|// Previous line's indentation, to detect accidental continuation abuse
name|bool
name|lineMarked
init|=
literal|true
decl_stmt|;
comment|// For in-expression markers
name|ushort
name|needSep
init|=
name|TokNewStr
decl_stmt|;
comment|// Met unquoted whitespace
name|ushort
name|quote
init|=
literal|0
decl_stmt|;
name|ushort
name|term
init|=
literal|0
decl_stmt|;
name|Context
name|context
decl_stmt|;
name|ushort
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|grammar
operator|==
name|ValueGrammar
condition|)
block|{
name|context
operator|=
name|CtxPureValue
expr_stmt|;
name|ptr
operator|=
name|tokPtr
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
name|context
operator|=
name|CtxTest
expr_stmt|;
name|ptr
operator|=
name|buf
operator|+
literal|4
expr_stmt|;
block|}
name|ushort
modifier|*
name|xprPtr
init|=
name|ptr
decl_stmt|;
DECL|macro|FLUSH_LHS_LITERAL
define|#
directive|define
name|FLUSH_LHS_LITERAL
parameter_list|()
define|\
value|do { \         if ((tlen = ptr - xprPtr)) { \             finalizeHashStr(xprPtr, tlen); \             if (needSep) { \                 wordCount++; \                 needSep = 0; \             } \         } else { \             ptr -= 4; \         } \     } while (0)
DECL|macro|FLUSH_RHS_LITERAL
define|#
directive|define
name|FLUSH_RHS_LITERAL
parameter_list|()
define|\
value|do { \         if ((tlen = ptr - xprPtr)) { \             xprPtr[-2] = TokLiteral | needSep; \             xprPtr[-1] = tlen; \             if (needSep) { \                 wordCount++; \                 needSep = 0; \             } \         } else { \             ptr -= 2; \         } \     } while (0)
DECL|macro|FLUSH_LITERAL
define|#
directive|define
name|FLUSH_LITERAL
parameter_list|()
define|\
value|do { \         if (context == CtxTest) \             FLUSH_LHS_LITERAL(); \         else \             FLUSH_RHS_LITERAL(); \     } while (0)
DECL|macro|FLUSH_VALUE_LIST
define|#
directive|define
name|FLUSH_VALUE_LIST
parameter_list|()
define|\
value|do { \         if (wordCount> 1) { \             xprPtr = tokPtr; \             if (*xprPtr == TokLine) \                 xprPtr += 2; \             tokPtr[-1] = ((*xprPtr& TokMask) == TokLiteral) ? wordCount : 0; \         } else { \             tokPtr[-1] = 0; \         } \         tokPtr = ptr; \         putTok(tokPtr, TokValueTerminator); \     } while (0)
specifier|const
name|ushort
modifier|*
name|end
decl_stmt|;
comment|// End of this line
specifier|const
name|ushort
modifier|*
name|cptr
decl_stmt|;
comment|// Start of next line
name|bool
name|lineCont
decl_stmt|;
name|int
name|indent
decl_stmt|;
if|if
condition|(
name|context
operator|==
name|CtxPureValue
condition|)
block|{
name|end
operator|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|in
operator|.
name|unicode
argument_list|()
operator|+
name|in
operator|.
name|length
argument_list|()
expr_stmt|;
name|cptr
operator|=
literal|0
expr_stmt|;
name|lineCont
operator|=
literal|false
expr_stmt|;
name|indent
operator|=
literal|0
expr_stmt|;
comment|// just gcc being stupid
goto|goto
name|nextChr
goto|;
block|}
forever|forever
block|{
name|ushort
name|c
decl_stmt|;
comment|// First, skip leading whitespace
for|for
control|(
name|indent
operator|=
literal|0
init|;
condition|;
operator|++
name|cur
operator|,
operator|++
name|indent
control|)
block|{
name|c
operator|=
operator|*
name|cur
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|cur
expr_stmt|;
goto|goto
name|flushLine
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|cur
operator|=
literal|0
expr_stmt|;
goto|goto
name|flushLine
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\r'
condition|)
block|{
break|break;
block|}
block|}
comment|// Then strip comments. Yep - no escaping is possible.
for|for
control|(
name|cptr
operator|=
name|cur
init|;
condition|;
operator|++
name|cptr
control|)
block|{
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
for|for
control|(
name|end
operator|=
name|cptr
init|;
operator|(
name|c
operator|=
operator|*
operator|++
name|cptr
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|end
operator|==
name|cur
condition|)
block|{
comment|// Line with only a comment (sans whitespace)
if|if
condition|(
name|m_markLine
operator|==
name|m_lineNo
condition|)
name|m_markLine
operator|++
expr_stmt|;
comment|// Qmake bizarreness: such lines do not affect line continuations
goto|goto
name|ignore
goto|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|end
operator|=
name|cptr
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|end
operator|=
name|cptr
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|// Then look for line continuations. Yep - no escaping here as well.
forever|forever
block|{
comment|// We don't have to check for underrun here, as we already determined
comment|// that the line is non-empty.
name|ushort
name|ec
init|=
operator|*
operator|(
name|end
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|ec
operator|==
literal|'\\'
condition|)
block|{
operator|--
name|end
expr_stmt|;
name|lineCont
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ec
operator|!=
literal|' '
operator|&&
name|ec
operator|!=
literal|'\t'
operator|&&
name|ec
operator|!=
literal|'\r'
condition|)
block|{
name|lineCont
operator|=
literal|false
expr_stmt|;
break|break;
block|}
operator|--
name|end
expr_stmt|;
block|}
comment|// Finally, do the tokenization
name|ushort
name|tok
decl_stmt|,
name|rtok
decl_stmt|;
name|int
name|tlen
decl_stmt|;
name|newWord
label|:
do|do
block|{
if|if
condition|(
name|cur
operator|==
name|end
condition|)
goto|goto
name|lineEnd
goto|;
name|c
operator|=
operator|*
name|cur
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
forever|forever
block|{
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
operator|*
name|cur
operator|==
literal|'$'
condition|)
block|{
comment|// may be EOF, EOL, WS, '#' or '\\' if past end
name|cur
operator|++
expr_stmt|;
name|FLUSH_LITERAL
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|lineMarked
condition|)
block|{
name|lineMarked
operator|=
literal|true
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|TokLine
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
operator|(
name|ushort
operator|)
name|m_lineNo
expr_stmt|;
block|}
name|term
operator|=
literal|0
expr_stmt|;
name|tok
operator|=
name|TokVariable
expr_stmt|;
name|c
operator|=
operator|*
name|cur
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
name|ptr
operator|+=
literal|4
expr_stmt|;
name|tok
operator|=
name|TokProperty
expr_stmt|;
name|term
operator|=
literal|']'
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|cur
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|ptr
operator|+=
literal|4
expr_stmt|;
name|term
operator|=
literal|'}'
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|cur
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|ptr
operator|+=
literal|2
expr_stmt|;
name|tok
operator|=
name|TokEnvVar
expr_stmt|;
name|term
operator|=
literal|')'
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|cur
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|+=
literal|4
expr_stmt|;
block|}
name|xprPtr
operator|=
name|ptr
expr_stmt|;
name|rtok
operator|=
name|tok
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|&
literal|0xFF00
operator|)
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'_'
operator|||
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'/'
operator|&&
name|term
operator|)
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|++
name|cur
operator|==
name|end
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
goto|goto
name|notfunc
goto|;
block|}
name|c
operator|=
operator|*
name|cur
expr_stmt|;
block|}
if|if
condition|(
name|tok
operator|==
name|TokVariable
operator|&&
name|c
operator|==
literal|'('
condition|)
name|tok
operator|=
name|TokFuncName
expr_stmt|;
name|notfunc
label|:
if|if
condition|(
name|ptr
operator|==
name|xprPtr
condition|)
name|languageWarning
argument_list|(
name|fL1S
argument_list|(
literal|"Missing name in expansion"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
condition|)
name|tok
operator||=
name|TokQuoted
expr_stmt|;
if|if
condition|(
name|needSep
condition|)
block|{
name|tok
operator||=
name|needSep
expr_stmt|;
name|wordCount
operator|++
expr_stmt|;
block|}
name|tlen
operator|=
name|ptr
operator|-
name|xprPtr
expr_stmt|;
if|if
condition|(
name|rtok
operator|!=
name|TokVariable
operator|||
operator|!
name|resolveVariable
argument_list|(
name|xprPtr
argument_list|,
name|tlen
argument_list|,
name|needSep
argument_list|,
operator|&
name|ptr
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|xprBuff
argument_list|,
operator|&
name|tokPtr
argument_list|,
operator|&
name|tokBuff
argument_list|,
name|cur
argument_list|,
name|in
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtok
operator|==
name|TokVariable
operator|||
name|rtok
operator|==
name|TokProperty
condition|)
block|{
name|xprPtr
index|[
operator|-
literal|4
index|]
operator|=
name|tok
expr_stmt|;
name|uint
name|hash
init|=
name|ProString
operator|::
name|hash
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|xprPtr
argument_list|,
name|tlen
argument_list|)
decl_stmt|;
name|xprPtr
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|ushort
operator|)
name|hash
expr_stmt|;
name|xprPtr
index|[
operator|-
literal|2
index|]
operator|=
call|(
name|ushort
call|)
argument_list|(
name|hash
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|xprPtr
index|[
operator|-
literal|1
index|]
operator|=
name|tlen
expr_stmt|;
block|}
else|else
block|{
name|xprPtr
index|[
operator|-
literal|2
index|]
operator|=
name|tok
expr_stmt|;
name|xprPtr
index|[
operator|-
literal|1
index|]
operator|=
name|tlen
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|tok
operator|&
name|TokMask
operator|)
operator|==
name|TokFuncName
condition|)
block|{
name|cur
operator|++
expr_stmt|;
name|funcCall
label|:
block|{
name|xprStack
operator|.
name|resize
argument_list|(
name|xprStack
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ParseCtx
modifier|&
name|top
init|=
name|xprStack
operator|.
name|top
argument_list|()
decl_stmt|;
name|top
operator|.
name|parens
operator|=
name|parens
expr_stmt|;
name|top
operator|.
name|quote
operator|=
name|quote
expr_stmt|;
name|top
operator|.
name|terminator
operator|=
name|term
expr_stmt|;
name|top
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|top
operator|.
name|argc
operator|=
name|argc
expr_stmt|;
name|top
operator|.
name|wordCount
operator|=
name|wordCount
expr_stmt|;
block|}
name|parens
operator|=
literal|0
expr_stmt|;
name|quote
operator|=
literal|0
expr_stmt|;
name|term
operator|=
literal|0
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
name|context
operator|=
name|CtxArgs
expr_stmt|;
name|nextToken
label|:
name|wordCount
operator|=
literal|0
expr_stmt|;
name|nextWord
label|:
name|ptr
operator|+=
operator|(
name|context
operator|==
name|CtxTest
operator|)
condition|?
literal|4
else|:
literal|2
expr_stmt|;
name|xprPtr
operator|=
name|ptr
expr_stmt|;
name|needSep
operator|=
name|TokNewStr
expr_stmt|;
goto|goto
name|newWord
goto|;
block|}
if|if
condition|(
name|term
condition|)
block|{
name|checkTerm
label|:
if|if
condition|(
name|c
operator|!=
name|term
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Missing %1 terminator [found %2]"
argument_list|)
operator|.
name|arg
argument_list|(
name|QChar
argument_list|(
name|term
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|c
condition|?
name|QString
argument_list|(
name|c
argument_list|)
else|:
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"end-of-line"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pro
operator|->
name|setOk
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|m_inError
operator|=
literal|true
expr_stmt|;
comment|// Just parse on, as if there was a terminator ...
block|}
else|else
block|{
name|cur
operator|++
expr_stmt|;
block|}
block|}
name|joinToken
label|:
name|ptr
operator|+=
operator|(
name|context
operator|==
name|CtxTest
operator|)
condition|?
literal|4
else|:
literal|2
expr_stmt|;
name|xprPtr
operator|=
name|ptr
expr_stmt|;
name|needSep
operator|=
literal|0
expr_stmt|;
goto|goto
name|nextChr
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
specifier|static
specifier|const
name|char
name|symbols
index|[]
init|=
literal|"[]{}()$\\'\""
decl_stmt|;
name|ushort
name|c2
decl_stmt|;
if|if
condition|(
name|cur
operator|!=
name|end
operator|&&
operator|!
operator|(
operator|(
name|c2
operator|=
operator|*
name|cur
operator|)
operator|&
literal|0xff00
operator|)
operator|&&
name|strchr
argument_list|(
name|symbols
argument_list|,
name|c2
argument_list|)
condition|)
block|{
name|c
operator|=
name|c2
expr_stmt|;
name|cur
operator|++
expr_stmt|;
block|}
else|else
block|{
name|deprecationWarning
argument_list|(
name|fL1S
argument_list|(
literal|"Unescaped backslashes are deprecated"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|quote
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|quote
condition|)
block|{
name|quote
operator|=
literal|0
expr_stmt|;
goto|goto
name|nextChr
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'!'
operator|&&
name|ptr
operator|==
name|xprPtr
operator|&&
name|context
operator|==
name|CtxTest
condition|)
block|{
name|m_invert
operator|^=
literal|true
expr_stmt|;
goto|goto
name|nextChr
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
block|{
name|quote
operator|=
name|c
expr_stmt|;
goto|goto
name|nextChr
goto|;
block|}
elseif|else
if|if
condition|(
name|context
operator|==
name|CtxArgs
condition|)
block|{
comment|// Function arg context
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
name|FLUSH_RHS_LITERAL
argument_list|()
expr_stmt|;
goto|goto
name|nextWord
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
operator|++
name|parens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
operator|--
name|parens
operator|<
literal|0
condition|)
block|{
name|FLUSH_RHS_LITERAL
argument_list|()
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|TokFuncTerminator
expr_stmt|;
name|int
name|theargc
init|=
name|argc
decl_stmt|;
block|{
name|ParseCtx
modifier|&
name|top
init|=
name|xprStack
operator|.
name|top
argument_list|()
decl_stmt|;
name|parens
operator|=
name|top
operator|.
name|parens
expr_stmt|;
name|quote
operator|=
name|top
operator|.
name|quote
expr_stmt|;
name|term
operator|=
name|top
operator|.
name|terminator
expr_stmt|;
name|context
operator|=
name|top
operator|.
name|context
expr_stmt|;
name|argc
operator|=
name|top
operator|.
name|argc
expr_stmt|;
name|wordCount
operator|=
name|top
operator|.
name|wordCount
expr_stmt|;
name|xprStack
operator|.
name|resize
argument_list|(
name|xprStack
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|term
operator|==
literal|':'
condition|)
block|{
name|finalizeCall
argument_list|(
name|tokPtr
argument_list|,
name|buf
argument_list|,
name|ptr
argument_list|,
name|theargc
argument_list|)
expr_stmt|;
goto|goto
name|nextItem
goto|;
block|}
elseif|else
if|if
condition|(
name|term
operator|==
literal|'}'
condition|)
block|{
name|c
operator|=
operator|(
name|cur
operator|==
name|end
operator|)
condition|?
literal|0
else|:
operator|*
name|cur
expr_stmt|;
goto|goto
name|checkTerm
goto|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|term
argument_list|)
expr_stmt|;
goto|goto
name|joinToken
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|parens
operator|&&
name|c
operator|==
literal|','
condition|)
block|{
name|FLUSH_RHS_LITERAL
argument_list|()
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|TokArgSeparator
expr_stmt|;
name|argc
operator|++
expr_stmt|;
goto|goto
name|nextToken
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|context
operator|==
name|CtxTest
condition|)
block|{
comment|// Test or LHS context
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
name|FLUSH_LHS_LITERAL
argument_list|()
expr_stmt|;
goto|goto
name|nextWord
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|FLUSH_LHS_LITERAL
argument_list|()
expr_stmt|;
if|if
condition|(
name|wordCount
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|wordCount
condition|)
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Extra characters after test expression."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Opening parenthesis without prior test name."
argument_list|)
argument_list|)
expr_stmt|;
name|pro
operator|->
name|setOk
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
comment|// Put empty function name
block|}
operator|*
name|ptr
operator|++
operator|=
name|TokTestCall
expr_stmt|;
name|term
operator|=
literal|':'
expr_stmt|;
goto|goto
name|funcCall
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'!'
operator|&&
name|ptr
operator|==
name|xprPtr
condition|)
block|{
name|m_invert
operator|^=
literal|true
expr_stmt|;
goto|goto
name|nextChr
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|FLUSH_LHS_LITERAL
argument_list|()
expr_stmt|;
name|finalizeCond
argument_list|(
name|tokPtr
argument_list|,
name|buf
argument_list|,
name|ptr
argument_list|,
name|wordCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_state
operator|==
name|StNew
condition|)
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"And operator without prior condition."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|m_operator
operator|=
name|AndOperator
expr_stmt|;
name|nextItem
label|:
name|ptr
operator|=
name|buf
expr_stmt|;
goto|goto
name|nextToken
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'|'
condition|)
block|{
name|FLUSH_LHS_LITERAL
argument_list|()
expr_stmt|;
name|finalizeCond
argument_list|(
name|tokPtr
argument_list|,
name|buf
argument_list|,
name|ptr
argument_list|,
name|wordCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_state
operator|!=
name|StCond
condition|)
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Or operator without prior condition."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|m_operator
operator|=
name|OrOperator
expr_stmt|;
goto|goto
name|nextItem
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|FLUSH_LHS_LITERAL
argument_list|()
expr_stmt|;
name|finalizeCond
argument_list|(
name|tokPtr
argument_list|,
name|buf
argument_list|,
name|ptr
argument_list|,
name|wordCount
argument_list|)
expr_stmt|;
name|flushCond
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
operator|++
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|braceLevel
expr_stmt|;
if|if
condition|(
name|grammar
operator|==
name|TestGrammar
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Opening scope not permitted in this context."
argument_list|)
argument_list|)
expr_stmt|;
name|pro
operator|->
name|setOk
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
goto|goto
name|nextItem
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
block|{
name|FLUSH_LHS_LITERAL
argument_list|()
expr_stmt|;
name|finalizeCond
argument_list|(
name|tokPtr
argument_list|,
name|buf
argument_list|,
name|ptr
argument_list|,
name|wordCount
argument_list|)
expr_stmt|;
name|flushScopes
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|closeScope
label|:
if|if
condition|(
operator|!
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|braceLevel
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Excess closing brace."
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|--
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|braceLevel
operator|&&
name|m_blockstack
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|leaveScope
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|m_state
operator|=
name|StNew
expr_stmt|;
name|m_canElse
operator|=
literal|false
expr_stmt|;
name|m_markLine
operator|=
name|m_lineNo
expr_stmt|;
block|}
goto|goto
name|nextItem
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
block|{
name|tok
operator|=
name|TokAppend
expr_stmt|;
goto|goto
name|do2Op
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|tok
operator|=
name|TokRemove
expr_stmt|;
goto|goto
name|do2Op
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|tok
operator|=
name|TokAppendUnique
expr_stmt|;
goto|goto
name|do2Op
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'~'
condition|)
block|{
name|tok
operator|=
name|TokReplace
expr_stmt|;
name|do2Op
label|:
if|if
condition|(
operator|*
name|cur
operator|==
literal|'='
condition|)
block|{
name|cur
operator|++
expr_stmt|;
goto|goto
name|doOp
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
name|tok
operator|=
name|TokAssign
expr_stmt|;
name|doOp
label|:
name|FLUSH_LHS_LITERAL
argument_list|()
expr_stmt|;
name|flushCond
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|putLineMarker
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|grammar
operator|==
name|TestGrammar
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Assignment not permitted in this context."
argument_list|)
argument_list|)
expr_stmt|;
name|pro
operator|->
name|setOk
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordCount
operator|!=
literal|1
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Assignment needs exactly one word on the left hand side."
argument_list|)
argument_list|)
expr_stmt|;
name|pro
operator|->
name|setOk
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Put empty variable name.
block|}
else|else
block|{
name|putBlock
argument_list|(
name|tokPtr
argument_list|,
name|buf
argument_list|,
name|ptr
operator|-
name|buf
argument_list|)
expr_stmt|;
block|}
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|context
operator|=
name|CtxValue
expr_stmt|;
name|ptr
operator|=
operator|++
name|tokPtr
expr_stmt|;
goto|goto
name|nextToken
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|context
operator|==
name|CtxValue
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
name|FLUSH_RHS_LITERAL
argument_list|()
expr_stmt|;
goto|goto
name|nextWord
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
operator|++
name|parens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
block|{
if|if
condition|(
operator|!
name|parens
condition|)
block|{
name|FLUSH_RHS_LITERAL
argument_list|()
expr_stmt|;
name|FLUSH_VALUE_LIST
argument_list|()
expr_stmt|;
name|context
operator|=
name|CtxTest
expr_stmt|;
goto|goto
name|closeScope
goto|;
block|}
operator|--
name|parens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|indent
operator|<
name|lastIndent
condition|)
name|languageWarning
argument_list|(
name|fL1S
argument_list|(
literal|"Possible accidental line continuation"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
name|nextChr
label|:
if|if
condition|(
name|cur
operator|==
name|end
condition|)
goto|goto
name|lineEnd
goto|;
name|c
operator|=
operator|*
name|cur
operator|++
expr_stmt|;
block|}
name|lineEnd
label|:
if|if
condition|(
name|lineCont
condition|)
block|{
if|if
condition|(
name|quote
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
name|FLUSH_LITERAL
argument_list|()
expr_stmt|;
name|needSep
operator|=
name|TokNewStr
expr_stmt|;
name|ptr
operator|+=
operator|(
name|context
operator|==
name|CtxTest
operator|)
condition|?
literal|4
else|:
literal|2
expr_stmt|;
name|xprPtr
operator|=
name|ptr
expr_stmt|;
block|}
block|}
else|else
block|{
name|cur
operator|=
name|cptr
expr_stmt|;
name|flushLine
label|:
name|FLUSH_LITERAL
argument_list|()
expr_stmt|;
if|if
condition|(
name|quote
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Missing closing %1 quote"
argument_list|)
operator|.
name|arg
argument_list|(
name|QChar
argument_list|(
name|quote
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xprStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|context
operator|=
name|xprStack
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|context
expr_stmt|;
name|xprStack
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
goto|goto
name|flErr
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|xprStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Missing closing parenthesis in function call"
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|=
name|xprStack
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|context
expr_stmt|;
name|xprStack
operator|.
name|clear
argument_list|()
expr_stmt|;
name|flErr
label|:
name|pro
operator|->
name|setOk
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|CtxValue
condition|)
block|{
name|tokPtr
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|// sizehint
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|TokValueTerminator
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|context
operator|==
name|CtxPureValue
condition|)
block|{
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|TokValueTerminator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bogusTest
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|context
operator|==
name|CtxValue
condition|)
block|{
name|FLUSH_VALUE_LIST
argument_list|()
expr_stmt|;
if|if
condition|(
name|parens
condition|)
name|languageWarning
argument_list|(
name|fL1S
argument_list|(
literal|"Possible braces mismatch"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|context
operator|==
name|CtxPureValue
condition|)
block|{
name|tokPtr
operator|=
name|ptr
expr_stmt|;
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|TokValueTerminator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|finalizeCond
argument_list|(
name|tokPtr
argument_list|,
name|buf
argument_list|,
name|ptr
argument_list|,
name|wordCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cur
condition|)
break|break;
operator|++
name|m_lineNo
expr_stmt|;
goto|goto
name|freshLine
goto|;
block|}
name|lastIndent
operator|=
name|indent
expr_stmt|;
name|lineMarked
operator|=
literal|false
expr_stmt|;
name|ignore
label|:
name|cur
operator|=
name|cptr
expr_stmt|;
operator|++
name|m_lineNo
expr_stmt|;
block|}
name|flushScopes
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_blockstack
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Missing closing brace(s)."
argument_list|)
argument_list|)
expr_stmt|;
name|pro
operator|->
name|setOk
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|m_blockstack
operator|.
name|size
argument_list|()
condition|)
name|leaveScope
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|tokBuff
operator|.
name|resize
argument_list|(
name|tokPtr
operator|-
operator|(
name|ushort
operator|*
operator|)
name|tokBuff
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
comment|// Reserved capacity stays
operator|*
name|pro
operator|->
name|itemsRef
argument_list|()
operator|=
name|tokBuff
expr_stmt|;
return|return
literal|true
return|;
DECL|macro|FLUSH_VALUE_LIST
undef|#
directive|undef
name|FLUSH_VALUE_LIST
DECL|macro|FLUSH_LITERAL
undef|#
directive|undef
name|FLUSH_LITERAL
DECL|macro|FLUSH_LHS_LITERAL
undef|#
directive|undef
name|FLUSH_LHS_LITERAL
DECL|macro|FLUSH_RHS_LITERAL
undef|#
directive|undef
name|FLUSH_RHS_LITERAL
block|}
end_function
begin_function
DECL|function|putLineMarker
name|void
name|QMakeParser
operator|::
name|putLineMarker
parameter_list|(
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
if|if
condition|(
name|m_markLine
condition|)
block|{
operator|*
name|tokPtr
operator|++
operator|=
name|TokLine
expr_stmt|;
operator|*
name|tokPtr
operator|++
operator|=
operator|(
name|ushort
operator|)
name|m_markLine
expr_stmt|;
name|m_markLine
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|enterScope
name|void
name|QMakeParser
operator|::
name|enterScope
parameter_list|(
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|,
name|bool
name|special
parameter_list|,
name|ScopeState
name|state
parameter_list|)
block|{
name|uchar
name|nest
init|=
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|nest
decl_stmt|;
name|m_blockstack
operator|.
name|resize
argument_list|(
name|m_blockstack
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|special
operator|=
name|special
expr_stmt|;
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|start
operator|=
name|tokPtr
expr_stmt|;
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|nest
operator|=
name|nest
expr_stmt|;
name|tokPtr
operator|+=
literal|2
expr_stmt|;
name|m_state
operator|=
name|state
expr_stmt|;
name|m_canElse
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|special
condition|)
name|m_markLine
operator|=
name|m_lineNo
expr_stmt|;
block|}
end_function
begin_function
DECL|function|leaveScope
name|void
name|QMakeParser
operator|::
name|leaveScope
parameter_list|(
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
if|if
condition|(
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|inBranch
condition|)
block|{
comment|// Put empty else block
name|putBlockLen
argument_list|(
name|tokPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ushort
modifier|*
name|start
init|=
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|start
condition|)
block|{
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|TokTerminator
argument_list|)
expr_stmt|;
name|uint
name|len
init|=
name|tokPtr
operator|-
name|start
operator|-
literal|2
decl_stmt|;
name|start
index|[
literal|0
index|]
operator|=
operator|(
name|ushort
operator|)
name|len
expr_stmt|;
name|start
index|[
literal|1
index|]
operator|=
call|(
name|ushort
call|)
argument_list|(
name|len
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
name|m_blockstack
operator|.
name|resize
argument_list|(
name|m_blockstack
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// If we are on a fresh line, close all open one-line scopes.
end_comment
begin_function
DECL|function|flushScopes
name|void
name|QMakeParser
operator|::
name|flushScopes
parameter_list|(
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
if|if
condition|(
name|m_state
operator|==
name|StNew
condition|)
block|{
while|while
condition|(
operator|!
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|braceLevel
operator|&&
name|m_blockstack
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
name|leaveScope
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|inBranch
condition|)
block|{
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|inBranch
operator|=
literal|false
expr_stmt|;
comment|// Put empty else block
name|putBlockLen
argument_list|(
name|tokPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|m_canElse
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// If there is a pending conditional, enter a new scope, otherwise flush scopes.
end_comment
begin_function
DECL|function|flushCond
name|void
name|QMakeParser
operator|::
name|flushCond
parameter_list|(
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
if|if
condition|(
name|m_state
operator|==
name|StCond
condition|)
block|{
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|TokBranch
argument_list|)
expr_stmt|;
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|inBranch
operator|=
literal|true
expr_stmt|;
name|enterScope
argument_list|(
name|tokPtr
argument_list|,
literal|false
argument_list|,
name|StNew
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flushScopes
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|finalizeTest
name|void
name|QMakeParser
operator|::
name|finalizeTest
parameter_list|(
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
name|flushScopes
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|putLineMarker
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_operator
operator|!=
name|NoOperator
condition|)
block|{
name|putTok
argument_list|(
name|tokPtr
argument_list|,
operator|(
name|m_operator
operator|==
name|AndOperator
operator|)
condition|?
name|TokAnd
else|:
name|TokOr
argument_list|)
expr_stmt|;
name|m_operator
operator|=
name|NoOperator
expr_stmt|;
block|}
if|if
condition|(
name|m_invert
condition|)
block|{
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|TokNot
argument_list|)
expr_stmt|;
name|m_invert
operator|=
literal|false
expr_stmt|;
block|}
name|m_state
operator|=
name|StCond
expr_stmt|;
name|m_canElse
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|bogusTest
name|void
name|QMakeParser
operator|::
name|bogusTest
parameter_list|(
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
name|flushScopes
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|m_operator
operator|=
name|NoOperator
expr_stmt|;
name|m_invert
operator|=
literal|false
expr_stmt|;
name|m_state
operator|=
name|StCond
expr_stmt|;
name|m_canElse
operator|=
literal|true
expr_stmt|;
name|m_proFile
operator|->
name|setOk
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|finalizeCond
name|void
name|QMakeParser
operator|::
name|finalizeCond
parameter_list|(
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|,
name|ushort
modifier|*
name|uc
parameter_list|,
name|ushort
modifier|*
name|ptr
parameter_list|,
name|int
name|wordCount
parameter_list|)
block|{
if|if
condition|(
name|wordCount
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|wordCount
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Extra characters after test expression."
argument_list|)
argument_list|)
expr_stmt|;
name|bogusTest
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Check for magic tokens
if|if
condition|(
operator|*
name|uc
operator|==
name|TokHashLiteral
condition|)
block|{
name|uint
name|nlen
init|=
name|uc
index|[
literal|3
index|]
decl_stmt|;
name|ushort
modifier|*
name|uce
init|=
name|uc
operator|+
literal|4
operator|+
name|nlen
decl_stmt|;
if|if
condition|(
name|uce
operator|==
name|ptr
condition|)
block|{
name|m_tmp
operator|.
name|setRawData
argument_list|(
operator|(
name|QChar
operator|*
operator|)
name|uc
operator|+
literal|4
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_tmp
operator|.
name|compare
argument_list|(
name|statics
operator|.
name|strelse
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
block|{
if|if
condition|(
name|m_invert
operator|||
name|m_operator
operator|!=
name|NoOperator
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Unexpected operator in front of else."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|BlockScope
modifier|&
name|top
init|=
name|m_blockstack
operator|.
name|top
argument_list|()
decl_stmt|;
if|if
condition|(
name|m_canElse
operator|&&
operator|(
operator|!
name|top
operator|.
name|special
operator|||
name|top
operator|.
name|braceLevel
operator|)
condition|)
block|{
comment|// A list of tests (the last one likely with side effects),
comment|// but no assignment, scope, etc.
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|TokBranch
argument_list|)
expr_stmt|;
comment|// Put empty then block
name|putBlockLen
argument_list|(
name|tokPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enterScope
argument_list|(
name|tokPtr
argument_list|,
literal|false
argument_list|,
name|StCtrl
argument_list|)
expr_stmt|;
return|return;
block|}
forever|forever
block|{
name|BlockScope
modifier|&
name|top
init|=
name|m_blockstack
operator|.
name|top
argument_list|()
decl_stmt|;
if|if
condition|(
name|top
operator|.
name|inBranch
operator|&&
operator|(
operator|!
name|top
operator|.
name|special
operator|||
name|top
operator|.
name|braceLevel
operator|)
condition|)
block|{
name|top
operator|.
name|inBranch
operator|=
literal|false
expr_stmt|;
name|enterScope
argument_list|(
name|tokPtr
argument_list|,
literal|false
argument_list|,
name|StCtrl
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|top
operator|.
name|braceLevel
operator|||
name|m_blockstack
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
break|break;
name|leaveScope
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
block|}
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Unexpected 'else'."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|finalizeTest
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|putBlock
argument_list|(
name|tokPtr
argument_list|,
name|uc
argument_list|,
name|ptr
operator|-
name|uc
argument_list|)
expr_stmt|;
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|TokCondition
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|finalizeCall
name|void
name|QMakeParser
operator|::
name|finalizeCall
parameter_list|(
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|,
name|ushort
modifier|*
name|uc
parameter_list|,
name|ushort
modifier|*
name|ptr
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
comment|// Check for magic tokens
if|if
condition|(
operator|*
name|uc
operator|==
name|TokHashLiteral
condition|)
block|{
name|uint
name|nlen
init|=
name|uc
index|[
literal|3
index|]
decl_stmt|;
name|ushort
modifier|*
name|uce
init|=
name|uc
operator|+
literal|4
operator|+
name|nlen
decl_stmt|;
if|if
condition|(
operator|*
name|uce
operator|==
name|TokTestCall
condition|)
block|{
name|uce
operator|++
expr_stmt|;
name|m_tmp
operator|.
name|setRawData
argument_list|(
operator|(
name|QChar
operator|*
operator|)
name|uc
operator|+
literal|4
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
specifier|const
name|QString
modifier|*
name|defName
decl_stmt|;
name|ushort
name|defType
decl_stmt|;
if|if
condition|(
name|m_tmp
operator|==
name|statics
operator|.
name|strfor
condition|)
block|{
if|if
condition|(
name|m_invert
operator|||
name|m_operator
operator|==
name|OrOperator
condition|)
block|{
comment|// '|' could actually work reasonably, but qmake does nonsense here.
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Unexpected operator in front of for()."
argument_list|)
argument_list|)
expr_stmt|;
name|bogusTest
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
return|return;
block|}
name|flushCond
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|putLineMarker
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|uce
operator|==
operator|(
name|TokLiteral
operator||
name|TokNewStr
operator|)
condition|)
block|{
name|nlen
operator|=
name|uce
index|[
literal|1
index|]
expr_stmt|;
name|uc
operator|=
name|uce
operator|+
literal|2
operator|+
name|nlen
expr_stmt|;
if|if
condition|(
operator|*
name|uc
operator|==
name|TokFuncTerminator
condition|)
block|{
comment|// for(literal) (only "ever" would be legal if qmake was sane)
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|TokForLoop
argument_list|)
expr_stmt|;
name|putHashStr
argument_list|(
name|tokPtr
argument_list|,
operator|(
name|ushort
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|uint
operator|)
literal|0
argument_list|)
expr_stmt|;
name|putBlockLen
argument_list|(
name|tokPtr
argument_list|,
literal|1
operator|+
literal|3
operator|+
name|nlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|TokHashLiteral
argument_list|)
expr_stmt|;
name|putHashStr
argument_list|(
name|tokPtr
argument_list|,
name|uce
operator|+
literal|2
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|didFor
label|:
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|TokValueTerminator
argument_list|)
expr_stmt|;
name|enterScope
argument_list|(
name|tokPtr
argument_list|,
literal|true
argument_list|,
name|StCtrl
argument_list|)
expr_stmt|;
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|nest
operator||=
name|NestLoop
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|uc
operator|==
name|TokArgSeparator
operator|&&
name|argc
operator|==
literal|2
condition|)
block|{
comment|// for(var, something)
name|uc
operator|++
expr_stmt|;
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|TokForLoop
argument_list|)
expr_stmt|;
name|putHashStr
argument_list|(
name|tokPtr
argument_list|,
name|uce
operator|+
literal|2
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|doFor
label|:
name|nlen
operator|=
name|ptr
operator|-
name|uc
expr_stmt|;
name|putBlockLen
argument_list|(
name|tokPtr
argument_list|,
name|nlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|putBlock
argument_list|(
name|tokPtr
argument_list|,
name|uc
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
goto|goto
name|didFor
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
comment|// for(non-literal) (this wouldn't be here if qmake was sane)
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|TokForLoop
argument_list|)
expr_stmt|;
name|putHashStr
argument_list|(
name|tokPtr
argument_list|,
operator|(
name|ushort
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|uint
operator|)
literal|0
argument_list|)
expr_stmt|;
name|uc
operator|=
name|uce
expr_stmt|;
goto|goto
name|doFor
goto|;
block|}
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Syntax is for(var, list), for(var, forever) or for(ever)."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|m_tmp
operator|==
name|statics
operator|.
name|strdefineReplace
condition|)
block|{
name|defName
operator|=
operator|&
name|statics
operator|.
name|strdefineReplace
expr_stmt|;
name|defType
operator|=
name|TokReplaceDef
expr_stmt|;
goto|goto
name|deffunc
goto|;
block|}
elseif|else
if|if
condition|(
name|m_tmp
operator|==
name|statics
operator|.
name|strdefineTest
condition|)
block|{
name|defName
operator|=
operator|&
name|statics
operator|.
name|strdefineTest
expr_stmt|;
name|defType
operator|=
name|TokTestDef
expr_stmt|;
name|deffunc
label|:
if|if
condition|(
name|m_invert
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Unexpected operator in front of function definition."
argument_list|)
argument_list|)
expr_stmt|;
name|bogusTest
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
return|return;
block|}
name|flushScopes
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|putLineMarker
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|uce
operator|==
operator|(
name|TokLiteral
operator||
name|TokNewStr
operator|)
condition|)
block|{
name|uint
name|nlen
init|=
name|uce
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|uce
index|[
name|nlen
operator|+
literal|2
index|]
operator|==
name|TokFuncTerminator
condition|)
block|{
if|if
condition|(
name|m_operator
operator|!=
name|NoOperator
condition|)
block|{
name|putTok
argument_list|(
name|tokPtr
argument_list|,
operator|(
name|m_operator
operator|==
name|AndOperator
operator|)
condition|?
name|TokAnd
else|:
name|TokOr
argument_list|)
expr_stmt|;
name|m_operator
operator|=
name|NoOperator
expr_stmt|;
block|}
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|defType
argument_list|)
expr_stmt|;
name|putHashStr
argument_list|(
name|tokPtr
argument_list|,
name|uce
operator|+
literal|2
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|enterScope
argument_list|(
name|tokPtr
argument_list|,
literal|true
argument_list|,
name|StCtrl
argument_list|)
expr_stmt|;
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|nest
operator|=
name|NestFunction
expr_stmt|;
return|return;
block|}
block|}
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"%1(function) requires one literal argument."
argument_list|)
operator|.
name|arg
argument_list|(
operator|*
name|defName
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|m_tmp
operator|==
name|statics
operator|.
name|strreturn
condition|)
block|{
if|if
condition|(
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|nest
operator|&
name|NestFunction
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"return() requires zero or one argument."
argument_list|)
argument_list|)
expr_stmt|;
name|bogusTest
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|uce
operator|!=
name|TokFuncTerminator
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Top-level return() requires zero arguments."
argument_list|)
argument_list|)
expr_stmt|;
name|bogusTest
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|defType
operator|=
name|TokReturn
expr_stmt|;
goto|goto
name|ctrlstm2
goto|;
block|}
elseif|else
if|if
condition|(
name|m_tmp
operator|==
name|statics
operator|.
name|strnext
condition|)
block|{
name|defType
operator|=
name|TokNext
expr_stmt|;
goto|goto
name|ctrlstm
goto|;
block|}
elseif|else
if|if
condition|(
name|m_tmp
operator|==
name|statics
operator|.
name|strbreak
condition|)
block|{
name|defType
operator|=
name|TokBreak
expr_stmt|;
name|ctrlstm
label|:
if|if
condition|(
operator|*
name|uce
operator|!=
name|TokFuncTerminator
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"%1() requires zero arguments."
argument_list|)
operator|.
name|arg
argument_list|(
name|m_tmp
argument_list|)
argument_list|)
expr_stmt|;
name|bogusTest
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|nest
operator|&
name|NestLoop
operator|)
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Unexpected %1()."
argument_list|)
operator|.
name|arg
argument_list|(
name|m_tmp
argument_list|)
argument_list|)
expr_stmt|;
name|bogusTest
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctrlstm2
label|:
if|if
condition|(
name|m_invert
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Unexpected NOT operator in front of %1()."
argument_list|)
operator|.
name|arg
argument_list|(
name|m_tmp
argument_list|)
argument_list|)
expr_stmt|;
name|bogusTest
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
return|return;
block|}
name|finalizeTest
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|putBlock
argument_list|(
name|tokPtr
argument_list|,
name|uce
argument_list|,
name|ptr
operator|-
name|uce
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Only for TokReturn
name|putTok
argument_list|(
name|tokPtr
argument_list|,
name|defType
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|m_tmp
operator|==
name|statics
operator|.
name|stroption
condition|)
block|{
if|if
condition|(
name|m_state
operator|!=
name|StNew
operator|||
name|m_blockstack
operator|.
name|top
argument_list|()
operator|.
name|braceLevel
operator|||
name|m_blockstack
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|m_invert
operator|||
name|m_operator
operator|!=
name|NoOperator
condition|)
block|{
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"option() must appear outside any control structures."
argument_list|)
argument_list|)
expr_stmt|;
name|bogusTest
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|uce
operator|==
operator|(
name|TokLiteral
operator||
name|TokNewStr
operator|)
condition|)
block|{
name|uint
name|nlen
init|=
name|uce
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|uce
index|[
name|nlen
operator|+
literal|2
index|]
operator|==
name|TokFuncTerminator
condition|)
block|{
name|m_tmp
operator|.
name|setRawData
argument_list|(
operator|(
name|QChar
operator|*
operator|)
name|uce
operator|+
literal|2
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_tmp
operator|==
name|statics
operator|.
name|strhost_build
condition|)
name|m_proFile
operator|->
name|setHostBuild
argument_list|(
literal|true
argument_list|)
expr_stmt|;
else|else
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"Unknown option() %1."
argument_list|)
operator|.
name|arg
argument_list|(
name|m_tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|parseError
argument_list|(
name|fL1S
argument_list|(
literal|"option() requires one literal argument."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|finalizeTest
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|putBlock
argument_list|(
name|tokPtr
argument_list|,
name|uc
argument_list|,
name|ptr
operator|-
name|uc
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resolveVariable
name|bool
name|QMakeParser
operator|::
name|resolveVariable
parameter_list|(
name|ushort
modifier|*
name|xprPtr
parameter_list|,
name|int
name|tlen
parameter_list|,
name|int
name|needSep
parameter_list|,
name|ushort
modifier|*
modifier|*
name|ptr
parameter_list|,
name|ushort
modifier|*
modifier|*
name|buf
parameter_list|,
name|QString
modifier|*
name|xprBuff
parameter_list|,
name|ushort
modifier|*
modifier|*
name|tokPtr
parameter_list|,
name|QString
modifier|*
name|tokBuff
parameter_list|,
specifier|const
name|ushort
modifier|*
name|cur
parameter_list|,
specifier|const
name|QString
modifier|&
name|in
parameter_list|)
block|{
name|QString
name|out
decl_stmt|;
name|m_tmp
operator|.
name|setRawData
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|xprPtr
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_tmp
operator|==
name|statics
operator|.
name|strLINE
condition|)
block|{
name|out
operator|.
name|setNum
argument_list|(
name|m_lineNo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp
operator|==
name|statics
operator|.
name|strFILE
condition|)
block|{
name|out
operator|=
name|m_proFile
operator|->
name|fileName
argument_list|()
expr_stmt|;
comment|// The string is typically longer than the variable reference, so we need
comment|// to ensure that there is enough space in the output buffer - as unlikely
comment|// as an overflow is to actually happen in practice.
name|int
name|need
init|=
operator|(
name|in
operator|.
name|length
argument_list|()
operator|-
operator|(
name|cur
operator|-
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|in
operator|.
name|constData
argument_list|()
operator|)
operator|+
literal|2
operator|)
operator|*
literal|5
operator|+
name|out
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|tused
init|=
operator|*
name|tokPtr
operator|-
operator|(
name|ushort
operator|*
operator|)
name|tokBuff
operator|->
name|constData
argument_list|()
decl_stmt|;
name|int
name|xused
decl_stmt|;
name|int
name|total
decl_stmt|;
name|bool
name|ptrFinal
init|=
name|xprPtr
operator|>=
operator|(
name|ushort
operator|*
operator|)
name|tokBuff
operator|->
name|constData
argument_list|()
operator|&&
name|xprPtr
operator|<
operator|(
name|ushort
operator|*
operator|)
name|tokBuff
operator|->
name|constData
argument_list|()
operator|+
name|tokBuff
operator|->
name|capacity
argument_list|()
decl_stmt|;
if|if
condition|(
name|ptrFinal
condition|)
block|{
name|xused
operator|=
name|xprPtr
operator|-
operator|(
name|ushort
operator|*
operator|)
name|tokBuff
operator|->
name|constData
argument_list|()
expr_stmt|;
name|total
operator|=
name|xused
operator|+
name|need
expr_stmt|;
block|}
else|else
block|{
name|xused
operator|=
name|xprPtr
operator|-
operator|*
name|buf
expr_stmt|;
name|total
operator|=
name|tused
operator|+
name|xused
operator|+
name|need
expr_stmt|;
block|}
if|if
condition|(
name|tokBuff
operator|->
name|capacity
argument_list|()
operator|<
name|total
condition|)
block|{
name|tokBuff
operator|->
name|reserve
argument_list|(
name|total
argument_list|)
expr_stmt|;
operator|*
name|tokPtr
operator|=
operator|(
name|ushort
operator|*
operator|)
name|tokBuff
operator|->
name|constData
argument_list|()
operator|+
name|tused
expr_stmt|;
name|xprBuff
operator|->
name|reserve
argument_list|(
name|total
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
operator|(
name|ushort
operator|*
operator|)
name|xprBuff
operator|->
name|constData
argument_list|()
expr_stmt|;
name|xprPtr
operator|=
operator|(
name|ptrFinal
condition|?
operator|(
name|ushort
operator|*
operator|)
name|tokBuff
operator|->
name|constData
argument_list|()
else|:
operator|*
name|buf
operator|)
operator|+
name|xused
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|m_tmp
operator|==
name|statics
operator|.
name|strLITERAL_HASH
condition|)
block|{
name|out
operator|=
name|QLatin1String
argument_list|(
literal|"#"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp
operator|==
name|statics
operator|.
name|strLITERAL_DOLLAR
condition|)
block|{
name|out
operator|=
name|QLatin1String
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp
operator|==
name|statics
operator|.
name|strLITERAL_WHITESPACE
condition|)
block|{
name|out
operator|=
name|QLatin1String
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
name|xprPtr
operator|-=
literal|2
expr_stmt|;
comment|// Was set up for variable reference
name|xprPtr
index|[
operator|-
literal|2
index|]
operator|=
name|TokLiteral
operator||
name|needSep
expr_stmt|;
name|xprPtr
index|[
operator|-
literal|1
index|]
operator|=
name|out
operator|.
name|length
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|xprPtr
argument_list|,
name|out
operator|.
name|constData
argument_list|()
argument_list|,
name|out
operator|.
name|length
argument_list|()
operator|*
literal|2
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|xprPtr
operator|+
name|out
operator|.
name|length
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|message
name|void
name|QMakeParser
operator|::
name|message
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|msg
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|m_inError
operator|&&
name|m_handler
condition|)
name|m_handler
operator|->
name|message
argument_list|(
name|type
argument_list|,
name|msg
argument_list|,
name|m_proFile
operator|->
name|fileName
argument_list|()
argument_list|,
name|m_lineNo
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
