begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the qmake application of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:GPL-EXCEPT$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3 as published by the Free Software ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qmakeevaluator.h"
end_include
begin_include
include|#
directive|include
file|"qmakeevaluator_p.h"
end_include
begin_include
include|#
directive|include
file|"qmakeglobals.h"
end_include
begin_include
include|#
directive|include
file|"qmakeparser.h"
end_include
begin_include
include|#
directive|include
file|"qmakevfs.h"
end_include
begin_include
include|#
directive|include
file|"ioutils.h"
end_include
begin_include
include|#
directive|include
file|<qbytearray.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qlist.h>
end_include
begin_include
include|#
directive|include
file|<qregexp.h>
end_include
begin_include
include|#
directive|include
file|<qset.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qtextstream.h>
end_include
begin_if
if|#
directive|if
name|QT_VERSION
operator|>=
name|QT_VERSION_CHECK
argument_list|(
literal|5
operator|,
literal|0
operator|,
literal|0
argument_list|)
end_if
begin_include
include|#
directive|include
file|<qjsondocument.h>
end_include
begin_include
include|#
directive|include
file|<qjsonobject.h>
end_include
begin_include
include|#
directive|include
file|<qjsonarray.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PROEVALUATOR_THREAD_SAFE
end_ifdef
begin_include
include|#
directive|include
file|<qthreadpool.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_include
include|#
directive|include
file|<utime.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_include
include|#
directive|include
file|<sys/stat.h>
end_include
begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|<windows.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN32
end_ifdef
begin_define
DECL|macro|QT_POPEN
define|#
directive|define
name|QT_POPEN
value|_popen
end_define
begin_define
DECL|macro|QT_PCLOSE
define|#
directive|define
name|QT_PCLOSE
value|_pclose
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_POPEN
define|#
directive|define
name|QT_POPEN
value|popen
end_define
begin_define
DECL|macro|QT_PCLOSE
define|#
directive|define
name|QT_PCLOSE
value|pclose
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_using
using|using
namespace|namespace
name|QMakeInternal
namespace|;
end_using
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|macro|fL1S
define|#
directive|define
name|fL1S
parameter_list|(
name|s
parameter_list|)
value|QString::fromLatin1(s)
DECL|enum|ExpandFunc
name|enum
name|ExpandFunc
argument_list|{
DECL|enumerator|E_INVALID
DECL|enumerator|E_MEMBER
DECL|enumerator|E_FIRST
DECL|enumerator|E_LAST
DECL|enumerator|E_SIZE
DECL|enumerator|E_CAT
DECL|enumerator|E_FROMFILE
DECL|enumerator|E_EVAL
DECL|enumerator|E_LIST
name|E_INVALID
operator|=
literal|0
argument_list|,
name|E_MEMBER
argument_list|,
name|E_FIRST
argument_list|,
name|E_LAST
argument_list|,
name|E_SIZE
argument_list|,
name|E_CAT
argument_list|,
name|E_FROMFILE
argument_list|,
name|E_EVAL
argument_list|,
name|E_LIST
argument_list|,
DECL|enumerator|E_SPRINTF
DECL|enumerator|E_FORMAT_NUMBER
DECL|enumerator|E_JOIN
DECL|enumerator|E_SPLIT
DECL|enumerator|E_BASENAME
DECL|enumerator|E_DIRNAME
DECL|enumerator|E_SECTION
name|E_SPRINTF
argument_list|,
name|E_FORMAT_NUMBER
argument_list|,
name|E_JOIN
argument_list|,
name|E_SPLIT
argument_list|,
name|E_BASENAME
argument_list|,
name|E_DIRNAME
argument_list|,
name|E_SECTION
argument_list|,
DECL|enumerator|E_FIND
DECL|enumerator|E_SYSTEM
DECL|enumerator|E_UNIQUE
DECL|enumerator|E_REVERSE
DECL|enumerator|E_QUOTE
DECL|enumerator|E_ESCAPE_EXPAND
name|E_FIND
argument_list|,
name|E_SYSTEM
argument_list|,
name|E_UNIQUE
argument_list|,
name|E_REVERSE
argument_list|,
name|E_QUOTE
argument_list|,
name|E_ESCAPE_EXPAND
argument_list|,
DECL|enumerator|E_UPPER
DECL|enumerator|E_LOWER
DECL|enumerator|E_TITLE
DECL|enumerator|E_FILES
DECL|enumerator|E_PROMPT
DECL|enumerator|E_RE_ESCAPE
DECL|enumerator|E_VAL_ESCAPE
name|E_UPPER
argument_list|,
name|E_LOWER
argument_list|,
name|E_TITLE
argument_list|,
name|E_FILES
argument_list|,
name|E_PROMPT
argument_list|,
name|E_RE_ESCAPE
argument_list|,
name|E_VAL_ESCAPE
argument_list|,
DECL|enumerator|E_REPLACE
DECL|enumerator|E_SORT_DEPENDS
DECL|enumerator|E_RESOLVE_DEPENDS
DECL|enumerator|E_ENUMERATE_VARS
name|E_REPLACE
argument_list|,
name|E_SORT_DEPENDS
argument_list|,
name|E_RESOLVE_DEPENDS
argument_list|,
name|E_ENUMERATE_VARS
argument_list|,
DECL|enumerator|E_SHADOWED
DECL|enumerator|E_ABSOLUTE_PATH
DECL|enumerator|E_RELATIVE_PATH
DECL|enumerator|E_CLEAN_PATH
name|E_SHADOWED
argument_list|,
name|E_ABSOLUTE_PATH
argument_list|,
name|E_RELATIVE_PATH
argument_list|,
name|E_CLEAN_PATH
argument_list|,
DECL|enumerator|E_SYSTEM_PATH
DECL|enumerator|E_SHELL_PATH
DECL|enumerator|E_SYSTEM_QUOTE
DECL|enumerator|E_SHELL_QUOTE
DECL|enumerator|E_GETENV
name|E_SYSTEM_PATH
argument_list|,
name|E_SHELL_PATH
argument_list|,
name|E_SYSTEM_QUOTE
argument_list|,
name|E_SHELL_QUOTE
argument_list|,
name|E_GETENV
argument_list|}
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|TestFunc
enum|enum
name|TestFunc
block|{
DECL|enumerator|T_INVALID
DECL|enumerator|T_REQUIRES
DECL|enumerator|T_GREATERTHAN
DECL|enumerator|T_LESSTHAN
DECL|enumerator|T_EQUALS
name|T_INVALID
init|=
literal|0
block|,
name|T_REQUIRES
block|,
name|T_GREATERTHAN
block|,
name|T_LESSTHAN
block|,
name|T_EQUALS
block|,
DECL|enumerator|T_EXISTS
DECL|enumerator|T_EXPORT
DECL|enumerator|T_CLEAR
DECL|enumerator|T_UNSET
DECL|enumerator|T_EVAL
DECL|enumerator|T_CONFIG
DECL|enumerator|T_SYSTEM
name|T_EXISTS
block|,
name|T_EXPORT
block|,
name|T_CLEAR
block|,
name|T_UNSET
block|,
name|T_EVAL
block|,
name|T_CONFIG
block|,
name|T_SYSTEM
block|,
DECL|enumerator|T_DEFINED
DECL|enumerator|T_CONTAINS
DECL|enumerator|T_INFILE
name|T_DEFINED
block|,
name|T_CONTAINS
block|,
name|T_INFILE
block|,
DECL|enumerator|T_COUNT
DECL|enumerator|T_ISEMPTY
DECL|enumerator|T_PARSE_JSON
DECL|enumerator|T_INCLUDE
DECL|enumerator|T_LOAD
DECL|enumerator|T_DEBUG
DECL|enumerator|T_LOG
DECL|enumerator|T_MESSAGE
DECL|enumerator|T_WARNING
DECL|enumerator|T_ERROR
DECL|enumerator|T_IF
name|T_COUNT
block|,
name|T_ISEMPTY
block|,
name|T_PARSE_JSON
block|,
name|T_INCLUDE
block|,
name|T_LOAD
block|,
name|T_DEBUG
block|,
name|T_LOG
block|,
name|T_MESSAGE
block|,
name|T_WARNING
block|,
name|T_ERROR
block|,
name|T_IF
block|,
DECL|enumerator|T_MKPATH
DECL|enumerator|T_WRITE_FILE
DECL|enumerator|T_TOUCH
DECL|enumerator|T_CACHE
name|T_MKPATH
block|,
name|T_WRITE_FILE
block|,
name|T_TOUCH
block|,
name|T_CACHE
block|}
enum|;
end_enum
begin_function
DECL|function|initFunctionStatics
name|void
name|QMakeEvaluator
operator|::
name|initFunctionStatics
parameter_list|()
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|ExpandFunc
name|func
decl_stmt|;
block|}
name|expandInits
index|[]
init|=
block|{
block|{
literal|"member"
block|,
name|E_MEMBER
block|}
block|,
block|{
literal|"first"
block|,
name|E_FIRST
block|}
block|,
block|{
literal|"last"
block|,
name|E_LAST
block|}
block|,
block|{
literal|"size"
block|,
name|E_SIZE
block|}
block|,
block|{
literal|"cat"
block|,
name|E_CAT
block|}
block|,
block|{
literal|"fromfile"
block|,
name|E_FROMFILE
block|}
block|,
block|{
literal|"eval"
block|,
name|E_EVAL
block|}
block|,
block|{
literal|"list"
block|,
name|E_LIST
block|}
block|,
block|{
literal|"sprintf"
block|,
name|E_SPRINTF
block|}
block|,
block|{
literal|"format_number"
block|,
name|E_FORMAT_NUMBER
block|}
block|,
block|{
literal|"join"
block|,
name|E_JOIN
block|}
block|,
block|{
literal|"split"
block|,
name|E_SPLIT
block|}
block|,
block|{
literal|"basename"
block|,
name|E_BASENAME
block|}
block|,
block|{
literal|"dirname"
block|,
name|E_DIRNAME
block|}
block|,
block|{
literal|"section"
block|,
name|E_SECTION
block|}
block|,
block|{
literal|"find"
block|,
name|E_FIND
block|}
block|,
block|{
literal|"system"
block|,
name|E_SYSTEM
block|}
block|,
block|{
literal|"unique"
block|,
name|E_UNIQUE
block|}
block|,
block|{
literal|"reverse"
block|,
name|E_REVERSE
block|}
block|,
block|{
literal|"quote"
block|,
name|E_QUOTE
block|}
block|,
block|{
literal|"escape_expand"
block|,
name|E_ESCAPE_EXPAND
block|}
block|,
block|{
literal|"upper"
block|,
name|E_UPPER
block|}
block|,
block|{
literal|"lower"
block|,
name|E_LOWER
block|}
block|,
block|{
literal|"title"
block|,
name|E_TITLE
block|}
block|,
block|{
literal|"re_escape"
block|,
name|E_RE_ESCAPE
block|}
block|,
block|{
literal|"val_escape"
block|,
name|E_VAL_ESCAPE
block|}
block|,
block|{
literal|"files"
block|,
name|E_FILES
block|}
block|,
block|{
literal|"prompt"
block|,
name|E_PROMPT
block|}
block|,
block|{
literal|"replace"
block|,
name|E_REPLACE
block|}
block|,
block|{
literal|"sort_depends"
block|,
name|E_SORT_DEPENDS
block|}
block|,
block|{
literal|"resolve_depends"
block|,
name|E_RESOLVE_DEPENDS
block|}
block|,
block|{
literal|"enumerate_vars"
block|,
name|E_ENUMERATE_VARS
block|}
block|,
block|{
literal|"shadowed"
block|,
name|E_SHADOWED
block|}
block|,
block|{
literal|"absolute_path"
block|,
name|E_ABSOLUTE_PATH
block|}
block|,
block|{
literal|"relative_path"
block|,
name|E_RELATIVE_PATH
block|}
block|,
block|{
literal|"clean_path"
block|,
name|E_CLEAN_PATH
block|}
block|,
block|{
literal|"system_path"
block|,
name|E_SYSTEM_PATH
block|}
block|,
block|{
literal|"shell_path"
block|,
name|E_SHELL_PATH
block|}
block|,
block|{
literal|"system_quote"
block|,
name|E_SYSTEM_QUOTE
block|}
block|,
block|{
literal|"shell_quote"
block|,
name|E_SHELL_QUOTE
block|}
block|,
block|{
literal|"getenv"
block|,
name|E_GETENV
block|}
block|,     }
struct|;
name|statics
operator|.
name|expands
operator|.
name|reserve
argument_list|(
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|expandInits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|expandInits
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|expandInits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|expandInits
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
name|statics
operator|.
name|expands
operator|.
name|insert
argument_list|(
name|ProKey
argument_list|(
name|expandInits
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|,
name|expandInits
index|[
name|i
index|]
operator|.
name|func
argument_list|)
expr_stmt|;
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|TestFunc
name|func
decl_stmt|;
block|}
name|testInits
index|[]
init|=
block|{
block|{
literal|"requires"
block|,
name|T_REQUIRES
block|}
block|,
block|{
literal|"greaterThan"
block|,
name|T_GREATERTHAN
block|}
block|,
block|{
literal|"lessThan"
block|,
name|T_LESSTHAN
block|}
block|,
block|{
literal|"equals"
block|,
name|T_EQUALS
block|}
block|,
block|{
literal|"isEqual"
block|,
name|T_EQUALS
block|}
block|,
block|{
literal|"exists"
block|,
name|T_EXISTS
block|}
block|,
block|{
literal|"export"
block|,
name|T_EXPORT
block|}
block|,
block|{
literal|"clear"
block|,
name|T_CLEAR
block|}
block|,
block|{
literal|"unset"
block|,
name|T_UNSET
block|}
block|,
block|{
literal|"eval"
block|,
name|T_EVAL
block|}
block|,
block|{
literal|"CONFIG"
block|,
name|T_CONFIG
block|}
block|,
block|{
literal|"if"
block|,
name|T_IF
block|}
block|,
block|{
literal|"isActiveConfig"
block|,
name|T_CONFIG
block|}
block|,
block|{
literal|"system"
block|,
name|T_SYSTEM
block|}
block|,
block|{
literal|"defined"
block|,
name|T_DEFINED
block|}
block|,
block|{
literal|"contains"
block|,
name|T_CONTAINS
block|}
block|,
block|{
literal|"infile"
block|,
name|T_INFILE
block|}
block|,
block|{
literal|"count"
block|,
name|T_COUNT
block|}
block|,
block|{
literal|"isEmpty"
block|,
name|T_ISEMPTY
block|}
block|,
if|#
directive|if
name|QT_VERSION
operator|>=
name|QT_VERSION_CHECK
argument_list|(
literal|5
operator|,
literal|0
operator|,
literal|0
argument_list|)
block|{
literal|"parseJson"
block|,
name|T_PARSE_JSON
block|}
block|,
endif|#
directive|endif
block|{
literal|"load"
block|,
name|T_LOAD
block|}
block|,
block|{
literal|"include"
block|,
name|T_INCLUDE
block|}
block|,
block|{
literal|"debug"
block|,
name|T_DEBUG
block|}
block|,
block|{
literal|"log"
block|,
name|T_LOG
block|}
block|,
block|{
literal|"message"
block|,
name|T_MESSAGE
block|}
block|,
block|{
literal|"warning"
block|,
name|T_WARNING
block|}
block|,
block|{
literal|"error"
block|,
name|T_ERROR
block|}
block|,
block|{
literal|"mkpath"
block|,
name|T_MKPATH
block|}
block|,
block|{
literal|"write_file"
block|,
name|T_WRITE_FILE
block|}
block|,
block|{
literal|"touch"
block|,
name|T_TOUCH
block|}
block|,
block|{
literal|"cache"
block|,
name|T_CACHE
block|}
block|,     }
struct|;
name|statics
operator|.
name|functions
operator|.
name|reserve
argument_list|(
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|testInits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|testInits
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|testInits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|testInits
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
name|statics
operator|.
name|functions
operator|.
name|insert
argument_list|(
name|ProKey
argument_list|(
name|testInits
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|,
name|testInits
index|[
name|i
index|]
operator|.
name|func
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isTrue
specifier|static
name|bool
name|isTrue
parameter_list|(
specifier|const
name|ProString
modifier|&
name|_str
parameter_list|,
name|QString
modifier|&
name|tmp
parameter_list|)
block|{
specifier|const
name|QString
modifier|&
name|str
init|=
name|_str
operator|.
name|toQString
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
return|return
operator|!
name|str
operator|.
name|compare
argument_list|(
name|statics
operator|.
name|strtrue
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|||
name|str
operator|.
name|toInt
argument_list|()
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|PROEVALUATOR_FULL
argument_list|)
end_if
begin_function
DECL|function|windowsErrorCode
specifier|static
name|QString
name|windowsErrorCode
parameter_list|()
block|{
name|wchar_t
modifier|*
name|string
init|=
literal|0
decl_stmt|;
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_ALLOCATE_BUFFER
operator||
name|FORMAT_MESSAGE_FROM_SYSTEM
argument_list|,
name|NULL
argument_list|,
name|GetLastError
argument_list|()
argument_list|,
name|MAKELANGID
argument_list|(
name|LANG_NEUTRAL
argument_list|,
name|SUBLANG_DEFAULT
argument_list|)
argument_list|,
operator|(
name|LPWSTR
operator|)
operator|&
name|string
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|QString
name|ret
init|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|LocalFree
argument_list|(
operator|(
name|HLOCAL
operator|)
name|string
argument_list|)
expr_stmt|;
return|return
name|ret
operator|.
name|trimmed
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QString
DECL|function|quoteValue
name|QMakeEvaluator
operator|::
name|quoteValue
parameter_list|(
specifier|const
name|ProString
modifier|&
name|val
parameter_list|)
block|{
name|QString
name|ret
decl_stmt|;
name|ret
operator|.
name|reserve
argument_list|(
name|val
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|QChar
modifier|*
name|chars
init|=
name|val
operator|.
name|constData
argument_list|()
decl_stmt|;
name|bool
name|quote
init|=
name|val
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|bool
name|escaping
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|l
init|=
name|val
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
name|QChar
name|c
init|=
name|chars
index|[
name|i
index|]
decl_stmt|;
name|ushort
name|uc
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|uc
operator|<
literal|32
condition|)
block|{
if|if
condition|(
operator|!
name|escaping
condition|)
block|{
name|escaping
operator|=
literal|true
expr_stmt|;
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"$$escape_expand("
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|uc
condition|)
block|{
case|case
literal|'\r'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\\t"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"\\\\x%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|uc
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|escaping
condition|)
block|{
name|escaping
operator|=
literal|false
expr_stmt|;
name|ret
operator|+=
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|uc
condition|)
block|{
case|case
literal|'\\'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\$"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"$${LITERAL_HASH}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|quote
operator|=
literal|true
expr_stmt|;
comment|// fallthrough
default|default:
name|ret
operator|+=
name|c
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|escaping
condition|)
name|ret
operator|+=
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
condition|)
block|{
name|ret
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_if
if|#
directive|if
name|QT_VERSION
operator|>=
name|QT_VERSION_CHECK
argument_list|(
literal|5
operator|,
literal|0
operator|,
literal|0
argument_list|)
end_if
begin_function_decl
specifier|static
name|void
name|addJsonValue
parameter_list|(
specifier|const
name|QJsonValue
modifier|&
name|value
parameter_list|,
specifier|const
name|QString
modifier|&
name|keyPrefix
parameter_list|,
name|ProValueMap
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|insertJsonKeyValue
specifier|static
name|void
name|insertJsonKeyValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|values
parameter_list|,
name|ProValueMap
modifier|*
name|map
parameter_list|)
block|{
name|map
operator|->
name|insert
argument_list|(
name|ProKey
argument_list|(
name|key
argument_list|)
argument_list|,
name|ProStringList
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addJsonArray
specifier|static
name|void
name|addJsonArray
parameter_list|(
specifier|const
name|QJsonArray
modifier|&
name|array
parameter_list|,
specifier|const
name|QString
modifier|&
name|keyPrefix
parameter_list|,
name|ProValueMap
modifier|*
name|map
parameter_list|)
block|{
name|QStringList
name|keys
decl_stmt|;
specifier|const
name|int
name|size
init|=
name|array
operator|.
name|count
argument_list|()
decl_stmt|;
name|keys
operator|.
name|reserve
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
name|number
init|=
name|QString
operator|::
name|number
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|keys
operator|.
name|append
argument_list|(
name|number
argument_list|)
expr_stmt|;
name|addJsonValue
argument_list|(
name|array
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|keyPrefix
operator|+
name|number
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
name|insertJsonKeyValue
argument_list|(
name|keyPrefix
operator|+
name|QLatin1String
argument_list|(
literal|"_KEYS_"
argument_list|)
argument_list|,
name|keys
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addJsonObject
specifier|static
name|void
name|addJsonObject
parameter_list|(
specifier|const
name|QJsonObject
modifier|&
name|object
parameter_list|,
specifier|const
name|QString
modifier|&
name|keyPrefix
parameter_list|,
name|ProValueMap
modifier|*
name|map
parameter_list|)
block|{
name|QStringList
name|keys
decl_stmt|;
name|keys
operator|.
name|reserve
argument_list|(
name|object
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
name|it
init|=
name|object
operator|.
name|begin
argument_list|()
init|,
name|end
init|=
name|object
operator|.
name|end
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QString
name|key
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
name|keys
operator|.
name|append
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|addJsonValue
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|,
name|keyPrefix
operator|+
name|key
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
name|insertJsonKeyValue
argument_list|(
name|keyPrefix
operator|+
name|QLatin1String
argument_list|(
literal|"_KEYS_"
argument_list|)
argument_list|,
name|keys
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addJsonValue
specifier|static
name|void
name|addJsonValue
parameter_list|(
specifier|const
name|QJsonValue
modifier|&
name|value
parameter_list|,
specifier|const
name|QString
modifier|&
name|keyPrefix
parameter_list|,
name|ProValueMap
modifier|*
name|map
parameter_list|)
block|{
switch|switch
condition|(
name|value
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|QJsonValue
operator|::
name|Bool
case|:
name|insertJsonKeyValue
argument_list|(
name|keyPrefix
argument_list|,
name|QStringList
argument_list|()
operator|<<
operator|(
name|value
operator|.
name|toBool
argument_list|()
condition|?
name|QLatin1String
argument_list|(
literal|"true"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"false"
argument_list|)
operator|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
break|break;
case|case
name|QJsonValue
operator|::
name|Double
case|:
name|insertJsonKeyValue
argument_list|(
name|keyPrefix
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|QString
operator|::
name|number
argument_list|(
name|value
operator|.
name|toDouble
argument_list|()
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
break|break;
case|case
name|QJsonValue
operator|::
name|String
case|:
name|insertJsonKeyValue
argument_list|(
name|keyPrefix
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
break|break;
case|case
name|QJsonValue
operator|::
name|Array
case|:
name|addJsonArray
argument_list|(
name|value
operator|.
name|toArray
argument_list|()
argument_list|,
name|keyPrefix
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
break|break;
case|case
name|QJsonValue
operator|::
name|Object
case|:
name|addJsonObject
argument_list|(
name|value
operator|.
name|toObject
argument_list|()
argument_list|,
name|keyPrefix
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_function
DECL|function|parseJsonInto
specifier|static
name|QMakeEvaluator
operator|::
name|VisitReturn
name|parseJsonInto
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|json
parameter_list|,
specifier|const
name|QString
modifier|&
name|into
parameter_list|,
name|ProValueMap
modifier|*
name|value
parameter_list|)
block|{
name|QJsonDocument
name|document
init|=
name|QJsonDocument
operator|::
name|fromJson
argument_list|(
name|json
argument_list|)
decl_stmt|;
if|if
condition|(
name|document
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QMakeEvaluator
operator|::
name|ReturnFalse
return|;
name|QString
name|currentKey
init|=
name|into
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
comment|// top-level item is either an array or object
if|if
condition|(
name|document
operator|.
name|isArray
argument_list|()
condition|)
name|addJsonArray
argument_list|(
name|document
operator|.
name|array
argument_list|()
argument_list|,
name|currentKey
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|document
operator|.
name|isObject
argument_list|()
condition|)
name|addJsonObject
argument_list|(
name|document
operator|.
name|object
argument_list|()
argument_list|,
name|currentKey
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
return|return
name|QMakeEvaluator
operator|::
name|ReturnFalse
return|;
return|return
name|QMakeEvaluator
operator|::
name|ReturnTrue
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QMakeEvaluator
operator|::
name|VisitReturn
DECL|function|writeFile
name|QMakeEvaluator
operator|::
name|writeFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|ctx
parameter_list|,
specifier|const
name|QString
modifier|&
name|fn
parameter_list|,
name|QIODevice
operator|::
name|OpenMode
name|mode
parameter_list|,
name|bool
name|exe
parameter_list|,
specifier|const
name|QString
modifier|&
name|contents
parameter_list|)
block|{
name|QString
name|errStr
decl_stmt|;
if|if
condition|(
operator|!
name|m_vfs
operator|->
name|writeFile
argument_list|(
name|fn
argument_list|,
name|mode
argument_list|,
name|exe
argument_list|,
name|contents
argument_list|,
operator|&
name|errStr
argument_list|)
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Cannot write %1file %2: %3"
argument_list|)
operator|.
name|arg
argument_list|(
name|ctx
argument_list|,
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|fn
argument_list|)
argument_list|,
name|errStr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|m_parser
operator|->
name|discardFileFromCache
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|ReturnTrue
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_function
DECL|function|runProcess
name|void
name|QMakeEvaluator
operator|::
name|runProcess
parameter_list|(
name|QProcess
modifier|*
name|proc
parameter_list|,
specifier|const
name|QString
modifier|&
name|command
parameter_list|)
specifier|const
block|{
name|proc
operator|->
name|setWorkingDirectory
argument_list|(
name|currentDirectory
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROEVALUATOR_SETENV
if|if
condition|(
operator|!
name|m_option
operator|->
name|environment
operator|.
name|isEmpty
argument_list|()
condition|)
name|proc
operator|->
name|setProcessEnvironment
argument_list|(
name|m_option
operator|->
name|environment
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|proc
operator|->
name|setNativeArguments
argument_list|(
name|QLatin1String
argument_list|(
literal|"/v:off /s /c \""
argument_list|)
operator|+
name|command
operator|+
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
name|proc
operator|->
name|start
argument_list|(
name|m_option
operator|->
name|getEnv
argument_list|(
name|QLatin1String
argument_list|(
literal|"COMSPEC"
argument_list|)
argument_list|)
argument_list|,
name|QStringList
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|proc
operator|->
name|start
argument_list|(
name|QLatin1String
argument_list|(
literal|"/bin/sh"
argument_list|)
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|QLatin1String
argument_list|(
literal|"-c"
argument_list|)
operator|<<
name|command
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|proc
operator|->
name|waitForFinished
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|getCommandOutput
name|QByteArray
name|QMakeEvaluator
operator|::
name|getCommandOutput
parameter_list|(
specifier|const
name|QString
modifier|&
name|args
parameter_list|)
specifier|const
block|{
name|QByteArray
name|out
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QProcess
name|proc
decl_stmt|;
name|runProcess
argument_list|(
operator|&
name|proc
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|QByteArray
name|errout
init|=
name|proc
operator|.
name|readAllStandardError
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|PROEVALUATOR_FULL
comment|// FIXME: Qt really should have the option to set forwarding per channel
name|fputs
argument_list|(
name|errout
operator|.
name|constData
argument_list|()
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|errout
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|errout
operator|.
name|endsWith
argument_list|(
literal|'\n'
argument_list|)
condition|)
name|errout
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|m_handler
operator|->
name|message
argument_list|(
name|QMakeHandler
operator|::
name|EvalError
argument_list|,
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|errout
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|out
operator|=
name|proc
operator|.
name|readAllStandardOutput
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// FIXME: Qt's line end conversion on sequential files should really be fixed
name|out
operator|.
name|replace
argument_list|(
literal|"\r\n"
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
name|FILE
modifier|*
name|proc
init|=
name|QT_POPEN
argument_list|(
name|QString
argument_list|(
name|QLatin1String
argument_list|(
literal|"cd "
argument_list|)
operator|+
name|IoUtils
operator|::
name|shellQuote
argument_list|(
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|currentDirectory
argument_list|()
argument_list|)
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"&& "
argument_list|)
operator|+
name|args
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|feof
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|char
name|buff
index|[
literal|10
operator|*
literal|1024
index|]
decl_stmt|;
name|int
name|read_in
init|=
name|int
argument_list|(
name|fread
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|proc
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|read_in
condition|)
break|break;
name|out
operator|+=
name|QByteArray
argument_list|(
name|buff
argument_list|,
name|read_in
argument_list|)
expr_stmt|;
block|}
name|QT_PCLOSE
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|populateDeps
name|void
name|QMakeEvaluator
operator|::
name|populateDeps
parameter_list|(
specifier|const
name|ProStringList
modifier|&
name|deps
parameter_list|,
specifier|const
name|ProString
modifier|&
name|prefix
parameter_list|,
specifier|const
name|ProStringList
modifier|&
name|suffixes
parameter_list|,
specifier|const
name|ProString
modifier|&
name|priosfx
parameter_list|,
name|QHash
argument_list|<
name|ProKey
argument_list|,
name|QSet
argument_list|<
name|ProKey
argument_list|>
argument_list|>
modifier|&
name|dependencies
parameter_list|,
name|ProValueMap
modifier|&
name|dependees
parameter_list|,
name|QMultiMap
argument_list|<
name|int
argument_list|,
name|ProString
argument_list|>
modifier|&
name|rootSet
parameter_list|)
specifier|const
block|{
for|for
control|(
specifier|const
name|ProString
modifier|&
name|item
range|:
name|deps
control|)
if|if
condition|(
operator|!
name|dependencies
operator|.
name|contains
argument_list|(
name|item
operator|.
name|toKey
argument_list|()
argument_list|)
condition|)
block|{
name|QSet
argument_list|<
name|ProKey
argument_list|>
modifier|&
name|dset
init|=
name|dependencies
index|[
name|item
operator|.
name|toKey
argument_list|()
index|]
decl_stmt|;
comment|// Always create entry
name|ProStringList
name|depends
decl_stmt|;
for|for
control|(
specifier|const
name|ProString
modifier|&
name|suffix
range|:
name|suffixes
control|)
name|depends
operator|+=
name|values
argument_list|(
name|ProKey
argument_list|(
name|prefix
operator|+
name|item
operator|+
name|suffix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|depends
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|rootSet
operator|.
name|insert
argument_list|(
name|first
argument_list|(
name|ProKey
argument_list|(
name|prefix
operator|+
name|item
operator|+
name|priosfx
argument_list|)
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
specifier|const
name|ProString
modifier|&
name|dep
range|:
name|qAsConst
argument_list|(
name|depends
argument_list|)
control|)
block|{
name|dset
operator|.
name|insert
argument_list|(
name|dep
operator|.
name|toKey
argument_list|()
argument_list|)
expr_stmt|;
name|dependees
index|[
name|dep
operator|.
name|toKey
argument_list|()
index|]
operator|<<
name|item
expr_stmt|;
block|}
name|populateDeps
argument_list|(
name|depends
argument_list|,
name|prefix
argument_list|,
name|suffixes
argument_list|,
name|priosfx
argument_list|,
name|dependencies
argument_list|,
name|dependees
argument_list|,
name|rootSet
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|evaluateBuiltinExpand
name|ProStringList
name|QMakeEvaluator
operator|::
name|evaluateBuiltinExpand
parameter_list|(
name|int
name|func_t
parameter_list|,
specifier|const
name|ProKey
modifier|&
name|func
parameter_list|,
specifier|const
name|ProStringList
modifier|&
name|args
parameter_list|)
block|{
name|ProStringList
name|ret
decl_stmt|;
name|traceMsg
argument_list|(
literal|"calling built-in $$%s(%s)"
argument_list|,
name|dbgKey
argument_list|(
name|func
argument_list|)
argument_list|,
name|dbgSepStrList
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|func_t
condition|)
block|{
case|case
name|E_BASENAME
case|:
case|case
name|E_DIRNAME
case|:
case|case
name|E_SECTION
case|:
block|{
name|bool
name|regexp
init|=
literal|false
decl_stmt|;
name|QString
name|sep
decl_stmt|;
name|ProString
name|var
decl_stmt|;
name|int
name|beg
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|func_t
operator|==
name|E_SECTION
condition|)
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|3
operator|&&
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|4
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"%1(var) section(var, sep, begin, end) requires"
literal|" three or four arguments."
argument_list|)
operator|.
name|arg
argument_list|(
name|func
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|var
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|sep
operator|=
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|beg
operator|=
name|args
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|4
condition|)
name|end
operator|=
name|args
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"%1(var) requires one argument."
argument_list|)
operator|.
name|arg
argument_list|(
name|func
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|var
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|regexp
operator|=
literal|true
expr_stmt|;
name|sep
operator|=
name|QLatin1String
argument_list|(
literal|"[\\\\/]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|func_t
operator|==
name|E_DIRNAME
condition|)
name|end
operator|=
operator|-
literal|2
expr_stmt|;
else|else
name|beg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|var
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
specifier|auto
name|strings
init|=
name|values
argument_list|(
name|map
argument_list|(
name|var
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regexp
condition|)
block|{
name|QRegExp
name|sepRx
argument_list|(
name|sep
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
name|ProString
modifier|&
name|str
range|:
name|strings
control|)
block|{
specifier|const
name|QString
modifier|&
name|rstr
init|=
name|str
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
operator|.
name|section
argument_list|(
name|sepRx
argument_list|,
name|beg
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|ret
operator|<<
operator|(
name|rstr
operator|.
name|isSharedWith
argument_list|(
name|m_tmp1
argument_list|)
condition|?
name|str
else|:
name|ProString
argument_list|(
name|rstr
argument_list|)
operator|.
name|setSource
argument_list|(
name|str
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
specifier|const
name|ProString
modifier|&
name|str
range|:
name|strings
control|)
block|{
specifier|const
name|QString
modifier|&
name|rstr
init|=
name|str
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
operator|.
name|section
argument_list|(
name|sep
argument_list|,
name|beg
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|ret
operator|<<
operator|(
name|rstr
operator|.
name|isSharedWith
argument_list|(
name|m_tmp1
argument_list|)
condition|?
name|str
else|:
name|ProString
argument_list|(
name|rstr
argument_list|)
operator|.
name|setSource
argument_list|(
name|str
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
case|case
name|E_SPRINTF
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"sprintf(format, ...) requires at least one argument."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|tmp
init|=
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|args
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|tmp
operator|=
name|tmp
operator|.
name|arg
argument_list|(
name|args
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|<<
operator|(
name|tmp
operator|.
name|isSharedWith
argument_list|(
name|m_tmp1
argument_list|)
condition|?
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
else|:
name|ProString
argument_list|(
name|tmp
argument_list|)
operator|.
name|setSource
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|E_FORMAT_NUMBER
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"format_number(number[, options...]) requires one or two arguments."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|ibase
init|=
literal|10
decl_stmt|;
name|int
name|obase
init|=
literal|10
decl_stmt|;
name|int
name|width
init|=
literal|0
decl_stmt|;
name|bool
name|zeropad
init|=
literal|false
decl_stmt|;
name|bool
name|leftalign
init|=
literal|false
decl_stmt|;
enum|enum
block|{
name|DefaultSign
block|,
name|PadSign
block|,
name|AlwaysSign
block|}
name|sign
init|=
name|DefaultSign
enum|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|2
condition|)
block|{
specifier|const
specifier|auto
name|opts
init|=
name|split_value_list
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
name|ProString
modifier|&
name|opt
range|:
name|opts
control|)
block|{
name|opt
operator|.
name|toQString
argument_list|(
name|m_tmp3
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_tmp3
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"ibase="
argument_list|)
argument_list|)
condition|)
block|{
name|ibase
operator|=
name|m_tmp3
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp3
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"obase="
argument_list|)
argument_list|)
condition|)
block|{
name|obase
operator|=
name|m_tmp3
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp3
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"width="
argument_list|)
argument_list|)
condition|)
block|{
name|width
operator|=
name|m_tmp3
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp3
operator|==
name|QLatin1String
argument_list|(
literal|"zeropad"
argument_list|)
condition|)
block|{
name|zeropad
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp3
operator|==
name|QLatin1String
argument_list|(
literal|"padsign"
argument_list|)
condition|)
block|{
name|sign
operator|=
name|PadSign
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp3
operator|==
name|QLatin1String
argument_list|(
literal|"alwayssign"
argument_list|)
condition|)
block|{
name|sign
operator|=
name|AlwaysSign
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp3
operator|==
name|QLatin1String
argument_list|(
literal|"leftalign"
argument_list|)
condition|)
block|{
name|leftalign
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"format_number(): invalid format option %1."
argument_list|)
operator|.
name|arg
argument_list|(
name|m_tmp3
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|formfail
goto|;
block|}
block|}
block|}
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp3
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_tmp3
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"format_number(): floats are currently not supported."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|bool
name|ok
decl_stmt|;
name|qlonglong
name|num
init|=
name|m_tmp3
operator|.
name|toLongLong
argument_list|(
operator|&
name|ok
argument_list|,
name|ibase
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"format_number(): malformed number %2 for base %1."
argument_list|)
operator|.
name|arg
argument_list|(
name|ibase
argument_list|)
operator|.
name|arg
argument_list|(
name|m_tmp3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|QString
name|outstr
decl_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
block|{
name|num
operator|=
operator|-
name|num
expr_stmt|;
name|outstr
operator|=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sign
operator|==
name|AlwaysSign
condition|)
block|{
name|outstr
operator|=
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sign
operator|==
name|PadSign
condition|)
block|{
name|outstr
operator|=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|QString
name|numstr
init|=
name|QString
operator|::
name|number
argument_list|(
name|num
argument_list|,
name|obase
argument_list|)
decl_stmt|;
name|int
name|space
init|=
name|width
operator|-
name|outstr
operator|.
name|length
argument_list|()
operator|-
name|numstr
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|space
operator|<=
literal|0
condition|)
block|{
name|outstr
operator|+=
name|numstr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leftalign
condition|)
block|{
name|outstr
operator|+=
name|numstr
operator|+
name|QString
argument_list|(
name|space
argument_list|,
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zeropad
condition|)
block|{
name|outstr
operator|+=
name|QString
argument_list|(
name|space
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|+
name|numstr
expr_stmt|;
block|}
else|else
block|{
name|outstr
operator|.
name|prepend
argument_list|(
name|QString
argument_list|(
name|space
argument_list|,
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|outstr
operator|+=
name|numstr
expr_stmt|;
block|}
name|ret
operator|+=
name|ProString
argument_list|(
name|outstr
argument_list|)
expr_stmt|;
block|}
name|formfail
label|:
break|break;
case|case
name|E_JOIN
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|4
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"join(var, glue, before, after) requires one to four arguments."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|glue
decl_stmt|;
name|ProString
name|before
decl_stmt|,
name|after
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|2
condition|)
name|glue
operator|=
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|3
condition|)
name|before
operator|=
name|args
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|4
condition|)
name|after
operator|=
name|args
index|[
literal|3
index|]
expr_stmt|;
specifier|const
name|ProStringList
modifier|&
name|var
init|=
name|values
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|var
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|ProFile
modifier|*
name|src
init|=
name|currentProFile
argument_list|()
decl_stmt|;
for|for
control|(
specifier|const
name|ProString
modifier|&
name|v
range|:
name|var
control|)
if|if
condition|(
specifier|const
name|ProFile
modifier|*
name|s
init|=
name|v
operator|.
name|sourceFile
argument_list|()
condition|)
block|{
name|src
operator|=
name|s
expr_stmt|;
break|break;
block|}
name|ret
operator|<<
name|ProString
argument_list|(
name|before
operator|+
name|var
operator|.
name|join
argument_list|(
name|glue
argument_list|)
operator|+
name|after
argument_list|)
operator|.
name|setSource
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|E_SPLIT
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"split(var, sep) requires one or two arguments."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QString
modifier|&
name|sep
init|=
operator|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|2
operator|)
condition|?
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
else|:
name|statics
operator|.
name|field_sep
decl_stmt|;
specifier|const
specifier|auto
name|vars
init|=
name|values
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
name|ProString
modifier|&
name|var
range|:
name|vars
control|)
block|{
specifier|const
specifier|auto
name|splits
init|=
name|var
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
operator|.
name|split
argument_list|(
name|sep
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
name|QString
modifier|&
name|splt
range|:
name|splits
control|)
name|ret
operator|<<
operator|(
name|splt
operator|.
name|isSharedWith
argument_list|(
name|m_tmp2
argument_list|)
condition|?
name|var
else|:
name|ProString
argument_list|(
name|splt
argument_list|)
operator|.
name|setSource
argument_list|(
name|var
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|E_MEMBER
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|3
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"member(var, start, end) requires one to three arguments."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|ok
init|=
literal|true
decl_stmt|;
specifier|const
name|ProStringList
modifier|&
name|var
init|=
name|values
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|,
name|end
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|2
condition|)
block|{
specifier|const
name|QString
modifier|&
name|start_str
init|=
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
name|start
operator|=
name|start_str
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|2
condition|)
block|{
name|int
name|dotdot
init|=
name|start_str
operator|.
name|indexOf
argument_list|(
name|statics
operator|.
name|strDotDot
argument_list|)
decl_stmt|;
if|if
condition|(
name|dotdot
operator|!=
operator|-
literal|1
condition|)
block|{
name|start
operator|=
name|start_str
operator|.
name|left
argument_list|(
name|dotdot
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
name|end
operator|=
name|start_str
operator|.
name|mid
argument_list|(
name|dotdot
operator|+
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"member() argument 2 (start) '%2' invalid."
argument_list|)
operator|.
name|arg
argument_list|(
name|start_str
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|end
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|3
condition|)
name|end
operator|=
name|args
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"member() argument 3 (end) '%2' invalid."
argument_list|)
operator|.
name|arg
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|+=
name|var
operator|.
name|count
argument_list|()
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|+=
name|var
operator|.
name|count
argument_list|()
expr_stmt|;
if|if
condition|(
name|start
operator|<
literal|0
operator|||
name|start
operator|>=
name|var
operator|.
name|count
argument_list|()
operator|||
name|end
operator|<
literal|0
operator|||
name|end
operator|>=
name|var
operator|.
name|count
argument_list|()
condition|)
block|{
comment|//nothing
block|}
elseif|else
if|if
condition|(
name|start
operator|<
name|end
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<=
name|end
operator|&&
name|var
operator|.
name|count
argument_list|()
operator|>=
name|i
condition|;
name|i
operator|++
control|)
name|ret
operator|.
name|append
argument_list|(
name|var
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|>=
name|end
operator|&&
name|var
operator|.
name|count
argument_list|()
operator|>=
name|i
operator|&&
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|ret
operator|+=
name|var
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|E_FIRST
case|:
case|case
name|E_LAST
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"%1(var) requires one argument."
argument_list|)
operator|.
name|arg
argument_list|(
name|func
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|ProStringList
modifier|&
name|var
init|=
name|values
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|var
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|func_t
operator|==
name|E_FIRST
condition|)
name|ret
operator|.
name|append
argument_list|(
name|var
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|ret
operator|.
name|append
argument_list|(
name|var
operator|.
name|last
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|E_SIZE
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"size(var) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ret
operator|.
name|append
argument_list|(
name|ProString
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|values
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_CAT
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"cat(file, singleline=true) requires one or two arguments."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QString
modifier|&
name|file
init|=
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
name|bool
name|blob
init|=
literal|false
decl_stmt|;
name|bool
name|lines
init|=
literal|false
decl_stmt|;
name|bool
name|singleLine
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
block|{
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_tmp2
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"false"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|singleLine
operator|=
literal|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|m_tmp2
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"blob"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|blob
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|m_tmp2
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"lines"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|lines
operator|=
literal|true
expr_stmt|;
block|}
name|QFile
name|qfile
argument_list|(
name|resolvePath
argument_list|(
name|m_option
operator|->
name|expandEnvVars
argument_list|(
name|file
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|qfile
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|QTextStream
name|stream
argument_list|(
operator|&
name|qfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|blob
condition|)
block|{
name|ret
operator|+=
name|ProString
argument_list|(
name|stream
operator|.
name|readAll
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|!
name|stream
operator|.
name|atEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|lines
condition|)
block|{
name|ret
operator|+=
name|ProString
argument_list|(
name|stream
operator|.
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|+=
name|split_value_list
argument_list|(
name|stream
operator|.
name|readLine
argument_list|()
operator|.
name|trimmed
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|singleLine
condition|)
name|ret
operator|+=
name|ProString
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
break|break;
case|case
name|E_FROMFILE
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"fromfile(file, variable) requires two arguments."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ProValueMap
name|vars
decl_stmt|;
name|QString
name|fn
init|=
name|resolvePath
argument_list|(
name|m_option
operator|->
name|expandEnvVars
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|fn
operator|.
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|evaluateFileInto
argument_list|(
name|fn
argument_list|,
operator|&
name|vars
argument_list|,
name|LoadProOnly
argument_list|)
operator|==
name|ReturnTrue
condition|)
name|ret
operator|=
name|vars
operator|.
name|value
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|E_EVAL
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"eval(variable) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ret
operator|+=
name|values
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_LIST
case|:
block|{
name|QString
name|tmp
decl_stmt|;
name|tmp
operator|.
name|sprintf
argument_list|(
literal|".QMAKE_INTERNAL_TMP_variableName_%d"
argument_list|,
name|m_listCount
operator|++
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ProStringList
argument_list|(
name|ProString
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|ProStringList
name|lst
decl_stmt|;
for|for
control|(
specifier|const
name|ProString
modifier|&
name|arg
range|:
name|args
control|)
name|lst
operator|+=
name|split_value_list
argument_list|(
name|arg
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|,
name|arg
operator|.
name|sourceFile
argument_list|()
argument_list|)
expr_stmt|;
comment|// Relies on deep copy
name|m_valuemapStack
operator|.
name|top
argument_list|()
index|[
name|ret
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toKey
argument_list|()
index|]
operator|=
name|lst
expr_stmt|;
break|break;
block|}
case|case
name|E_FIND
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"find(var, str) requires two arguments."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QRegExp
name|regx
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|t
init|=
literal|0
decl_stmt|;
specifier|const
specifier|auto
name|vals
init|=
name|values
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
name|ProString
modifier|&
name|val
range|:
name|vals
control|)
block|{
if|if
condition|(
name|regx
operator|.
name|indexIn
argument_list|(
name|val
operator|.
name|toQString
argument_list|(
name|m_tmp
index|[
name|t
index|]
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|ret
operator|+=
name|val
expr_stmt|;
name|t
operator|^=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|E_SYSTEM
case|:
if|if
condition|(
operator|!
name|m_skipLevel
condition|)
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"system(execute) requires one or two arguments."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|blob
init|=
literal|false
decl_stmt|;
name|bool
name|lines
init|=
literal|false
decl_stmt|;
name|bool
name|singleLine
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
block|{
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_tmp2
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"false"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|singleLine
operator|=
literal|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|m_tmp2
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"blob"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|blob
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|m_tmp2
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"lines"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|lines
operator|=
literal|true
expr_stmt|;
block|}
name|QByteArray
name|bytes
init|=
name|getCommandOutput
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lines
condition|)
block|{
name|QTextStream
name|stream
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|stream
operator|.
name|atEnd
argument_list|()
condition|)
name|ret
operator|+=
name|ProString
argument_list|(
name|stream
operator|.
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|output
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|blob
condition|)
block|{
name|ret
operator|+=
name|ProString
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\t'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|singleLine
condition|)
name|output
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|split_value_list
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|E_UNIQUE
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"unique(var) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|values
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|removeDuplicates
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|E_REVERSE
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"reverse(var) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ProStringList
name|var
init|=
name|values
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toKey
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|var
operator|.
name|size
argument_list|()
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|qSwap
argument_list|(
name|var
index|[
name|i
index|]
argument_list|,
name|var
index|[
name|var
operator|.
name|size
argument_list|()
operator|-
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|var
expr_stmt|;
block|}
break|break;
case|case
name|E_QUOTE
case|:
name|ret
operator|+=
name|args
expr_stmt|;
break|break;
case|case
name|E_ESCAPE_EXPAND
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|str
init|=
name|args
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toQString
argument_list|()
decl_stmt|;
name|QChar
modifier|*
name|i_data
init|=
name|str
operator|.
name|data
argument_list|()
decl_stmt|;
name|int
name|i_len
init|=
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|i_len
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|i_data
operator|+
name|x
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
operator|&&
name|x
operator|<
name|i_len
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|i_data
operator|+
name|x
operator|+
literal|1
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
condition|)
block|{
operator|++
name|x
expr_stmt|;
block|}
else|else
block|{
struct|struct
block|{
name|char
name|in
decl_stmt|,
name|out
decl_stmt|;
block|}
name|mapped_quotes
index|[]
init|=
block|{
block|{
literal|'n'
block|,
literal|'\n'
block|}
block|,
block|{
literal|'t'
block|,
literal|'\t'
block|}
block|,
block|{
literal|'r'
block|,
literal|'\r'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|mapped_quotes
index|[
name|i
index|]
operator|.
name|in
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|i_data
operator|+
name|x
operator|+
literal|1
operator|)
operator|==
name|QLatin1Char
argument_list|(
name|mapped_quotes
index|[
name|i
index|]
operator|.
name|in
argument_list|)
condition|)
block|{
operator|*
operator|(
name|i_data
operator|+
name|x
operator|)
operator|=
name|QLatin1Char
argument_list|(
name|mapped_quotes
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|i_len
operator|-
literal|2
condition|)
name|memmove
argument_list|(
name|i_data
operator|+
name|x
operator|+
literal|1
argument_list|,
name|i_data
operator|+
name|x
operator|+
literal|2
argument_list|,
operator|(
name|i_len
operator|-
name|x
operator|-
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|i_len
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
name|ret
operator|.
name|append
argument_list|(
name|ProString
argument_list|(
name|QString
argument_list|(
name|i_data
argument_list|,
name|i_len
argument_list|)
argument_list|)
operator|.
name|setSource
argument_list|(
name|args
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|E_RE_ESCAPE
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
modifier|&
name|rstr
init|=
name|QRegExp
operator|::
name|escape
argument_list|(
name|args
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
decl_stmt|;
name|ret
operator|<<
operator|(
name|rstr
operator|.
name|isSharedWith
argument_list|(
name|m_tmp1
argument_list|)
condition|?
name|args
operator|.
name|at
argument_list|(
name|i
argument_list|)
else|:
name|ProString
argument_list|(
name|rstr
argument_list|)
operator|.
name|setSource
argument_list|(
name|args
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|E_VAL_ESCAPE
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"val_escape(var) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|ProStringList
modifier|&
name|vals
init|=
name|values
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toKey
argument_list|()
argument_list|)
decl_stmt|;
name|ret
operator|.
name|reserve
argument_list|(
name|vals
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|ProString
modifier|&
name|str
range|:
name|vals
control|)
name|ret
operator|+=
name|ProString
argument_list|(
name|quoteValue
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|E_UPPER
case|:
case|case
name|E_LOWER
case|:
case|case
name|E_TITLE
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|rstr
init|=
name|args
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
if|if
condition|(
name|func_t
operator|==
name|E_UPPER
condition|)
block|{
name|rstr
operator|=
name|rstr
operator|.
name|toUpper
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rstr
operator|=
name|rstr
operator|.
name|toLower
argument_list|()
expr_stmt|;
if|if
condition|(
name|func_t
operator|==
name|E_TITLE
operator|&&
name|rstr
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|rstr
index|[
literal|0
index|]
operator|=
name|rstr
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toTitleCase
argument_list|()
expr_stmt|;
block|}
name|ret
operator|<<
operator|(
name|rstr
operator|.
name|isSharedWith
argument_list|(
name|m_tmp1
argument_list|)
condition|?
name|args
operator|.
name|at
argument_list|(
name|i
argument_list|)
else|:
name|ProString
argument_list|(
name|rstr
argument_list|)
operator|.
name|setSource
argument_list|(
name|args
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|E_FILES
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
operator|&&
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"files(pattern, recursive=false) requires one or two arguments."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|recursive
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|2
condition|)
name|recursive
operator|=
name|isTrue
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|,
name|m_tmp2
argument_list|)
expr_stmt|;
name|QStringList
name|dirs
decl_stmt|;
name|QString
name|r
init|=
name|m_option
operator|->
name|expandEnvVars
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|pfx
decl_stmt|;
if|if
condition|(
name|IoUtils
operator|::
name|isRelativePath
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|pfx
operator|=
name|currentDirectory
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pfx
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|pfx
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|int
name|slash
init|=
name|r
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|slash
operator|!=
operator|-
literal|1
condition|)
block|{
name|dirs
operator|.
name|append
argument_list|(
name|r
operator|.
name|left
argument_list|(
name|slash
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|r
operator|.
name|mid
argument_list|(
name|slash
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dirs
operator|.
name|append
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|r
operator|.
name|detach
argument_list|()
expr_stmt|;
comment|// Keep m_tmp out of QRegExp's cache
name|QRegExp
name|regex
argument_list|(
name|r
argument_list|,
name|Qt
operator|::
name|CaseSensitive
argument_list|,
name|QRegExp
operator|::
name|Wildcard
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|dirs
operator|.
name|count
argument_list|()
condition|;
name|d
operator|++
control|)
block|{
name|QString
name|dir
init|=
name|dirs
index|[
name|d
index|]
decl_stmt|;
name|QDir
name|qdir
argument_list|(
name|pfx
operator|+
name|dir
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|qdir
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|qdir
index|[
name|i
index|]
operator|==
name|statics
operator|.
name|strDot
operator|||
name|qdir
index|[
name|i
index|]
operator|==
name|statics
operator|.
name|strDotDot
condition|)
continue|continue;
name|QString
name|fname
init|=
name|dir
operator|+
name|qdir
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|IoUtils
operator|::
name|fileType
argument_list|(
name|pfx
operator|+
name|fname
argument_list|)
operator|==
name|IoUtils
operator|::
name|FileIsDir
condition|)
block|{
if|if
condition|(
name|recursive
condition|)
name|dirs
operator|.
name|append
argument_list|(
name|fname
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regex
operator|.
name|exactMatch
argument_list|(
name|qdir
index|[
name|i
index|]
argument_list|)
condition|)
name|ret
operator|+=
name|ProString
argument_list|(
name|fname
argument_list|)
operator|.
name|setSource
argument_list|(
name|currentProFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|PROEVALUATOR_FULL
case|case
name|E_PROMPT
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"prompt(question) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
comment|//        } else if (currentFileName() == QLatin1String("-")) {
comment|//            evalError(fL1S("prompt(question) cannot be used when '-o -' is used"));
block|}
else|else
block|{
name|QString
name|msg
init|=
name|m_option
operator|->
name|expandEnvVars
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|msg
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
argument_list|)
condition|)
name|msg
operator|+=
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Project PROMPT: %s "
argument_list|,
name|qPrintable
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|QFile
name|qfile
decl_stmt|;
if|if
condition|(
name|qfile
operator|.
name|open
argument_list|(
name|stdin
argument_list|,
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|QTextStream
name|t
argument_list|(
operator|&
name|qfile
argument_list|)
decl_stmt|;
name|ret
operator|=
name|split_value_list
argument_list|(
name|t
operator|.
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
endif|#
directive|endif
case|case
name|E_REPLACE
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|3
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"replace(var, before, after) requires three arguments."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QRegExp
name|before
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QString
modifier|&
name|after
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
specifier|auto
name|vals
init|=
name|values
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
name|ProString
modifier|&
name|val
range|:
name|vals
control|)
block|{
name|QString
name|rstr
init|=
name|val
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
name|QString
name|copy
init|=
name|rstr
decl_stmt|;
comment|// Force a detach on modify
name|rstr
operator|.
name|replace
argument_list|(
name|before
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|ret
operator|<<
operator|(
name|rstr
operator|.
name|isSharedWith
argument_list|(
name|m_tmp1
argument_list|)
condition|?
name|val
else|:
name|ProString
argument_list|(
name|rstr
argument_list|)
operator|.
name|setSource
argument_list|(
name|val
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|E_SORT_DEPENDS
case|:
case|case
name|E_RESOLVE_DEPENDS
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|4
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"%1(var, [prefix, [suffixes, [prio-suffix]]]) requires one to four arguments."
argument_list|)
operator|.
name|arg
argument_list|(
name|func
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QHash
argument_list|<
name|ProKey
argument_list|,
name|QSet
argument_list|<
name|ProKey
argument_list|>
argument_list|>
name|dependencies
decl_stmt|;
name|ProValueMap
name|dependees
decl_stmt|;
name|QMultiMap
argument_list|<
name|int
argument_list|,
name|ProString
argument_list|>
name|rootSet
decl_stmt|;
name|ProStringList
name|orgList
init|=
name|values
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toKey
argument_list|()
argument_list|)
decl_stmt|;
name|ProString
name|prefix
init|=
name|args
operator|.
name|count
argument_list|()
operator|<
literal|2
condition|?
name|ProString
argument_list|()
else|:
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ProString
name|priosfx
init|=
name|args
operator|.
name|count
argument_list|()
operator|<
literal|4
condition|?
name|ProString
argument_list|(
literal|".priority"
argument_list|)
else|:
name|args
operator|.
name|at
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|populateDeps
argument_list|(
name|orgList
argument_list|,
name|prefix
argument_list|,
name|args
operator|.
name|count
argument_list|()
operator|<
literal|3
condition|?
name|ProStringList
argument_list|(
name|ProString
argument_list|(
literal|".depends"
argument_list|)
argument_list|)
else|:
name|split_value_list
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
argument_list|)
argument_list|,
name|priosfx
argument_list|,
name|dependencies
argument_list|,
name|dependees
argument_list|,
name|rootSet
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|rootSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QMultiMap
argument_list|<
name|int
argument_list|,
name|ProString
argument_list|>
operator|::
name|iterator
name|it
init|=
name|rootSet
operator|.
name|begin
argument_list|()
decl_stmt|;
specifier|const
name|ProString
name|item
init|=
operator|*
name|it
decl_stmt|;
name|rootSet
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|func_t
operator|==
name|E_RESOLVE_DEPENDS
operator|)
operator|||
name|orgList
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
name|ret
operator|.
name|prepend
argument_list|(
name|item
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|ProString
modifier|&
name|dep
range|:
name|qAsConst
argument_list|(
name|dependees
index|[
name|item
operator|.
name|toKey
argument_list|()
index|]
argument_list|)
control|)
block|{
name|QSet
argument_list|<
name|ProKey
argument_list|>
modifier|&
name|dset
init|=
name|dependencies
index|[
name|dep
operator|.
name|toKey
argument_list|()
index|]
decl_stmt|;
name|dset
operator|.
name|remove
argument_list|(
name|item
operator|.
name|toKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|dset
operator|.
name|isEmpty
argument_list|()
condition|)
name|rootSet
operator|.
name|insert
argument_list|(
name|first
argument_list|(
name|ProKey
argument_list|(
name|prefix
operator|+
name|dep
operator|+
name|priosfx
argument_list|)
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|,
name|dep
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|E_ENUMERATE_VARS
case|:
block|{
name|QSet
argument_list|<
name|ProString
argument_list|>
name|keys
decl_stmt|;
for|for
control|(
specifier|const
name|ProValueMap
modifier|&
name|vmap
range|:
name|qAsConst
argument_list|(
name|m_valuemapStack
argument_list|)
control|)
for|for
control|(
name|ProValueMap
operator|::
name|ConstIterator
name|it
init|=
name|vmap
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|vmap
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|keys
operator|.
name|insert
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
name|ret
operator|.
name|reserve
argument_list|(
name|keys
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|ProString
modifier|&
name|key
range|:
name|qAsConst
argument_list|(
name|keys
argument_list|)
control|)
name|ret
operator|<<
name|key
expr_stmt|;
break|break;
block|}
case|case
name|E_SHADOWED
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"shadowed(path) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|rstr
init|=
name|m_option
operator|->
name|shadowedPath
argument_list|(
name|resolvePath
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rstr
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
name|ret
operator|<<
operator|(
name|rstr
operator|.
name|isSharedWith
argument_list|(
name|m_tmp1
argument_list|)
condition|?
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
else|:
name|ProString
argument_list|(
name|rstr
argument_list|)
operator|.
name|setSource
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|E_ABSOLUTE_PATH
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"absolute_path(path[, base]) requires one or two arguments."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|rstr
init|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|QDir
argument_list|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|?
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
else|:
name|currentDirectory
argument_list|()
argument_list|)
operator|.
name|absoluteFilePath
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ret
operator|<<
operator|(
name|rstr
operator|.
name|isSharedWith
argument_list|(
name|m_tmp1
argument_list|)
condition|?
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
else|:
name|ProString
argument_list|(
name|rstr
argument_list|)
operator|.
name|setSource
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|E_RELATIVE_PATH
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"relative_path(path[, base]) requires one or two arguments."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QDir
name|baseDir
argument_list|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|?
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
else|:
name|currentDirectory
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|rstr
init|=
name|baseDir
operator|.
name|relativeFilePath
argument_list|(
name|baseDir
operator|.
name|absoluteFilePath
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ret
operator|<<
operator|(
name|rstr
operator|.
name|isSharedWith
argument_list|(
name|m_tmp1
argument_list|)
condition|?
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
else|:
name|ProString
argument_list|(
name|rstr
argument_list|)
operator|.
name|setSource
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|E_CLEAN_PATH
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"clean_path(path) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|rstr
init|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
decl_stmt|;
name|ret
operator|<<
operator|(
name|rstr
operator|.
name|isSharedWith
argument_list|(
name|m_tmp1
argument_list|)
condition|?
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
else|:
name|ProString
argument_list|(
name|rstr
argument_list|)
operator|.
name|setSource
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|E_SYSTEM_PATH
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"system_path(path) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|rstr
init|=
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|rstr
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|rstr
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|<<
operator|(
name|rstr
operator|.
name|isSharedWith
argument_list|(
name|m_tmp1
argument_list|)
condition|?
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
else|:
name|ProString
argument_list|(
name|rstr
argument_list|)
operator|.
name|setSource
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|E_SHELL_PATH
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"shell_path(path) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|rstr
init|=
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
if|if
condition|(
name|m_dirSep
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
condition|)
block|{
name|rstr
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rstr
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// Convert d:/foo/bar to msys-style /d/foo/bar.
if|if
condition|(
name|rstr
operator|.
name|length
argument_list|()
operator|>
literal|2
operator|&&
name|rstr
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|&&
name|rstr
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
name|rstr
index|[
literal|1
index|]
operator|=
name|rstr
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rstr
index|[
literal|0
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|ret
operator|<<
operator|(
name|rstr
operator|.
name|isSharedWith
argument_list|(
name|m_tmp1
argument_list|)
condition|?
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
else|:
name|ProString
argument_list|(
name|rstr
argument_list|)
operator|.
name|setSource
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|E_SYSTEM_QUOTE
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"system_quote(arg) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|rstr
init|=
name|IoUtils
operator|::
name|shellQuote
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
decl_stmt|;
name|ret
operator|<<
operator|(
name|rstr
operator|.
name|isSharedWith
argument_list|(
name|m_tmp1
argument_list|)
condition|?
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
else|:
name|ProString
argument_list|(
name|rstr
argument_list|)
operator|.
name|setSource
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|E_SHELL_QUOTE
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"shell_quote(arg) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|rstr
init|=
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
if|if
condition|(
name|m_dirSep
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
condition|)
name|rstr
operator|=
name|IoUtils
operator|::
name|shellQuoteWin
argument_list|(
name|rstr
argument_list|)
expr_stmt|;
else|else
name|rstr
operator|=
name|IoUtils
operator|::
name|shellQuoteUnix
argument_list|(
name|rstr
argument_list|)
expr_stmt|;
name|ret
operator|<<
operator|(
name|rstr
operator|.
name|isSharedWith
argument_list|(
name|m_tmp1
argument_list|)
condition|?
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
else|:
name|ProString
argument_list|(
name|rstr
argument_list|)
operator|.
name|setSource
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|E_GETENV
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"getenv(arg) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|ProString
modifier|&
name|var
init|=
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|ProString
modifier|&
name|val
init|=
name|ProString
argument_list|(
name|m_option
operator|->
name|getEnv
argument_list|(
name|var
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ret
operator|<<
name|val
expr_stmt|;
block|}
break|break;
default|default:
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Function '%1' is not implemented."
argument_list|)
operator|.
name|arg
argument_list|(
name|func
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|evaluateBuiltinConditional
name|QMakeEvaluator
operator|::
name|VisitReturn
name|QMakeEvaluator
operator|::
name|evaluateBuiltinConditional
parameter_list|(
name|int
name|func_t
parameter_list|,
specifier|const
name|ProKey
modifier|&
name|function
parameter_list|,
specifier|const
name|ProStringList
modifier|&
name|args
parameter_list|)
block|{
name|traceMsg
argument_list|(
literal|"calling built-in %s(%s)"
argument_list|,
name|dbgKey
argument_list|(
name|function
argument_list|)
argument_list|,
name|dbgSepStrList
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|func_t
condition|)
block|{
case|case
name|T_DEFINED
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"defined(function, [\"test\"|\"replace\"|\"var\"])"
literal|" requires one or two arguments."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
specifier|const
name|ProKey
modifier|&
name|var
init|=
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|==
name|QLatin1String
argument_list|(
literal|"test"
argument_list|)
condition|)
block|{
return|return
name|returnBool
argument_list|(
name|m_functionDefs
operator|.
name|testFunctions
operator|.
name|contains
argument_list|(
name|var
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|==
name|QLatin1String
argument_list|(
literal|"replace"
argument_list|)
condition|)
block|{
return|return
name|returnBool
argument_list|(
name|m_functionDefs
operator|.
name|replaceFunctions
operator|.
name|contains
argument_list|(
name|var
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|==
name|QLatin1String
argument_list|(
literal|"var"
argument_list|)
condition|)
block|{
name|ProValueMap
operator|::
name|Iterator
name|it
decl_stmt|;
return|return
name|returnBool
argument_list|(
name|findValues
argument_list|(
name|var
argument_list|,
operator|&
name|it
argument_list|)
argument_list|)
return|;
block|}
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"defined(function, type): unexpected type [%1]."
argument_list|)
operator|.
name|arg
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
return|return
name|returnBool
argument_list|(
name|m_functionDefs
operator|.
name|replaceFunctions
operator|.
name|contains
argument_list|(
name|var
argument_list|)
operator|||
name|m_functionDefs
operator|.
name|testFunctions
operator|.
name|contains
argument_list|(
name|var
argument_list|)
argument_list|)
return|;
block|}
case|case
name|T_EXPORT
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"export(variable) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
specifier|const
name|ProKey
modifier|&
name|var
init|=
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|ProValueMapStack
operator|::
name|Iterator
name|vmi
init|=
name|m_valuemapStack
operator|.
name|end
argument_list|()
init|;
operator|--
name|vmi
operator|!=
name|m_valuemapStack
operator|.
name|begin
argument_list|()
condition|;
control|)
block|{
name|ProValueMap
operator|::
name|Iterator
name|it
init|=
operator|(
operator|*
name|vmi
operator|)
operator|.
name|find
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
operator|(
operator|*
name|vmi
operator|)
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|constBegin
argument_list|()
operator|==
name|statics
operator|.
name|fakeValue
operator|.
name|constBegin
argument_list|()
condition|)
block|{
comment|// This is stupid, but qmake doesn't propagate deletions
name|m_valuemapStack
operator|.
name|first
argument_list|()
index|[
name|var
index|]
operator|=
name|ProStringList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|m_valuemapStack
operator|.
name|first
argument_list|()
index|[
name|var
index|]
operator|=
operator|*
name|it
expr_stmt|;
block|}
operator|(
operator|*
name|vmi
operator|)
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|vmi
operator|!=
name|m_valuemapStack
operator|.
name|begin
argument_list|()
condition|)
operator|(
operator|*
name|vmi
operator|)
operator|.
name|remove
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|ReturnTrue
return|;
block|}
case|case
name|T_INFILE
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|2
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|3
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"infile(file, var, [values]) requires two or three arguments."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ProValueMap
name|vars
decl_stmt|;
name|QString
name|fn
init|=
name|resolvePath
argument_list|(
name|m_option
operator|->
name|expandEnvVars
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|fn
operator|.
name|detach
argument_list|()
expr_stmt|;
name|VisitReturn
name|ok
init|=
name|evaluateFileInto
argument_list|(
name|fn
argument_list|,
operator|&
name|vars
argument_list|,
name|LoadProOnly
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
operator|!=
name|ReturnTrue
condition|)
return|return
name|ok
return|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|2
condition|)
return|return
name|returnBool
argument_list|(
name|vars
operator|.
name|contains
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
name|QRegExp
name|regx
decl_stmt|;
specifier|const
name|QString
modifier|&
name|qry
init|=
name|args
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
if|if
condition|(
name|qry
operator|!=
name|QRegExp
operator|::
name|escape
argument_list|(
name|qry
argument_list|)
condition|)
block|{
name|QString
name|copy
init|=
name|qry
decl_stmt|;
name|copy
operator|.
name|detach
argument_list|()
expr_stmt|;
name|regx
operator|.
name|setPattern
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
name|int
name|t
init|=
literal|0
decl_stmt|;
specifier|const
specifier|auto
name|strings
init|=
name|vars
operator|.
name|value
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
name|ProString
modifier|&
name|s
range|:
name|strings
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|regx
operator|.
name|isEmpty
argument_list|()
operator|&&
name|regx
operator|.
name|exactMatch
argument_list|(
name|s
operator|.
name|toQString
argument_list|(
name|m_tmp
index|[
name|t
index|]
argument_list|)
argument_list|)
operator|)
operator|||
name|s
operator|==
name|qry
condition|)
return|return
name|ReturnTrue
return|;
name|t
operator|^=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|ReturnFalse
return|;
case|case
name|T_REQUIRES
case|:
ifdef|#
directive|ifdef
name|PROEVALUATOR_FULL
name|checkRequirements
argument_list|(
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ReturnFalse
return|;
comment|// Another qmake breakage
case|case
name|T_EVAL
case|:
block|{
name|VisitReturn
name|ret
init|=
name|ReturnFalse
decl_stmt|;
name|ProFile
modifier|*
name|pro
init|=
name|m_parser
operator|->
name|parsedProBlock
argument_list|(
name|args
operator|.
name|join
argument_list|(
name|statics
operator|.
name|field_sep
argument_list|)
argument_list|,
name|m_current
operator|.
name|pro
operator|->
name|fileName
argument_list|()
argument_list|,
name|m_current
operator|.
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|m_cumulative
operator|||
name|pro
operator|->
name|isOk
argument_list|()
condition|)
block|{
name|m_locationStack
operator|.
name|push
argument_list|(
name|m_current
argument_list|)
expr_stmt|;
name|visitProBlock
argument_list|(
name|pro
argument_list|,
name|pro
operator|->
name|tokPtr
argument_list|()
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ReturnTrue
expr_stmt|;
comment|// This return value is not too useful, but that's qmake
name|m_current
operator|=
name|m_locationStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
name|pro
operator|->
name|deref
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
case|case
name|T_IF
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"if(condition) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
return|return
name|returnBool
argument_list|(
name|evaluateConditional
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|()
argument_list|,
name|m_current
operator|.
name|pro
operator|->
name|fileName
argument_list|()
argument_list|,
name|m_current
operator|.
name|line
argument_list|)
argument_list|)
return|;
block|}
case|case
name|T_CONFIG
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"CONFIG(config) requires one or two arguments."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
return|return
name|returnBool
argument_list|(
name|isActiveConfig
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
argument_list|)
argument_list|)
return|;
specifier|const
name|QStringList
modifier|&
name|mutuals
init|=
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|ProStringList
modifier|&
name|configs
init|=
name|values
argument_list|(
name|statics
operator|.
name|strCONFIG
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|configs
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
for|for
control|(
name|int
name|mut
init|=
literal|0
init|;
name|mut
operator|<
name|mutuals
operator|.
name|count
argument_list|()
condition|;
name|mut
operator|++
control|)
block|{
if|if
condition|(
name|configs
index|[
name|i
index|]
operator|==
name|mutuals
index|[
name|mut
index|]
operator|.
name|trimmed
argument_list|()
condition|)
return|return
name|returnBool
argument_list|(
name|configs
index|[
name|i
index|]
operator|==
name|args
index|[
literal|0
index|]
argument_list|)
return|;
block|}
block|}
return|return
name|ReturnFalse
return|;
block|}
case|case
name|T_CONTAINS
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|2
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|3
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"contains(var, val) requires two or three arguments."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
specifier|const
name|QString
modifier|&
name|qry
init|=
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
name|QRegExp
name|regx
decl_stmt|;
if|if
condition|(
name|qry
operator|!=
name|QRegExp
operator|::
name|escape
argument_list|(
name|qry
argument_list|)
condition|)
block|{
name|QString
name|copy
init|=
name|qry
decl_stmt|;
name|copy
operator|.
name|detach
argument_list|()
expr_stmt|;
name|regx
operator|.
name|setPattern
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
specifier|const
name|ProStringList
modifier|&
name|l
init|=
name|values
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|2
condition|)
block|{
name|int
name|t
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|ProString
modifier|&
name|val
init|=
name|l
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|regx
operator|.
name|isEmpty
argument_list|()
operator|&&
name|regx
operator|.
name|exactMatch
argument_list|(
name|val
operator|.
name|toQString
argument_list|(
name|m_tmp
index|[
name|t
index|]
argument_list|)
argument_list|)
operator|)
operator|||
name|val
operator|==
name|qry
condition|)
return|return
name|ReturnTrue
return|;
name|t
operator|^=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|QStringList
modifier|&
name|mutuals
init|=
name|args
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp3
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|l
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|const
name|ProString
name|val
init|=
name|l
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|int
name|mut
init|=
literal|0
init|;
name|mut
operator|<
name|mutuals
operator|.
name|count
argument_list|()
condition|;
name|mut
operator|++
control|)
block|{
if|if
condition|(
name|val
operator|==
name|mutuals
index|[
name|mut
index|]
operator|.
name|trimmed
argument_list|()
condition|)
block|{
return|return
name|returnBool
argument_list|(
operator|(
operator|!
name|regx
operator|.
name|isEmpty
argument_list|()
operator|&&
name|regx
operator|.
name|exactMatch
argument_list|(
name|val
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
argument_list|)
operator|)
operator|||
name|val
operator|==
name|qry
argument_list|)
return|;
block|}
block|}
block|}
block|}
return|return
name|ReturnFalse
return|;
block|}
case|case
name|T_COUNT
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
operator|&&
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|3
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"count(var, count, op=\"equals\") requires two or three arguments."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|int
name|cnt
init|=
name|values
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|count
argument_list|()
decl_stmt|;
name|int
name|val
init|=
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|3
condition|)
block|{
specifier|const
name|ProString
modifier|&
name|comp
init|=
name|args
operator|.
name|at
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|==
name|QLatin1String
argument_list|(
literal|">"
argument_list|)
operator|||
name|comp
operator|==
name|QLatin1String
argument_list|(
literal|"greaterThan"
argument_list|)
condition|)
block|{
return|return
name|returnBool
argument_list|(
name|cnt
operator|>
name|val
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|comp
operator|==
name|QLatin1String
argument_list|(
literal|">="
argument_list|)
condition|)
block|{
return|return
name|returnBool
argument_list|(
name|cnt
operator|>=
name|val
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|comp
operator|==
name|QLatin1String
argument_list|(
literal|"<"
argument_list|)
operator|||
name|comp
operator|==
name|QLatin1String
argument_list|(
literal|"lessThan"
argument_list|)
condition|)
block|{
return|return
name|returnBool
argument_list|(
name|cnt
operator|<
name|val
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|comp
operator|==
name|QLatin1String
argument_list|(
literal|"<="
argument_list|)
condition|)
block|{
return|return
name|returnBool
argument_list|(
name|cnt
operator|<=
name|val
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|comp
operator|==
name|QLatin1String
argument_list|(
literal|"equals"
argument_list|)
operator|||
name|comp
operator|==
name|QLatin1String
argument_list|(
literal|"isEqual"
argument_list|)
operator|||
name|comp
operator|==
name|QLatin1String
argument_list|(
literal|"="
argument_list|)
operator|||
name|comp
operator|==
name|QLatin1String
argument_list|(
literal|"=="
argument_list|)
condition|)
block|{
comment|// fallthrough
block|}
else|else
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Unexpected modifier to count(%2)."
argument_list|)
operator|.
name|arg
argument_list|(
name|comp
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
block|}
return|return
name|returnBool
argument_list|(
name|cnt
operator|==
name|val
argument_list|)
return|;
block|}
case|case
name|T_GREATERTHAN
case|:
case|case
name|T_LESSTHAN
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"%1(variable, value) requires two arguments."
argument_list|)
operator|.
name|arg
argument_list|(
name|function
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
specifier|const
name|QString
modifier|&
name|rhs
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
decl_stmt|,
modifier|&
name|lhs
argument_list|(
name|values
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|join
argument_list|(
name|statics
operator|.
name|field_sep
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|int
name|rhs_int
init|=
name|rhs
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
comment|// do integer compare
name|int
name|lhs_int
init|=
name|lhs
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|func_t
operator|==
name|T_GREATERTHAN
condition|)
return|return
name|returnBool
argument_list|(
name|lhs_int
operator|>
name|rhs_int
argument_list|)
return|;
return|return
name|returnBool
argument_list|(
name|lhs_int
operator|<
name|rhs_int
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|func_t
operator|==
name|T_GREATERTHAN
condition|)
return|return
name|returnBool
argument_list|(
name|lhs
operator|>
name|rhs
argument_list|)
return|;
return|return
name|returnBool
argument_list|(
name|lhs
operator|<
name|rhs
argument_list|)
return|;
block|}
case|case
name|T_EQUALS
case|:
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"%1(variable, value) requires two arguments."
argument_list|)
operator|.
name|arg
argument_list|(
name|function
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
return|return
name|returnBool
argument_list|(
name|values
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|join
argument_list|(
name|statics
operator|.
name|field_sep
argument_list|)
operator|==
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
return|;
case|case
name|T_CLEAR
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"%1(variable) requires one argument."
argument_list|)
operator|.
name|arg
argument_list|(
name|function
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|ProValueMap
modifier|*
name|hsh
decl_stmt|;
name|ProValueMap
operator|::
name|Iterator
name|it
decl_stmt|;
specifier|const
name|ProKey
modifier|&
name|var
init|=
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|hsh
operator|=
name|findValues
argument_list|(
name|var
argument_list|,
operator|&
name|it
argument_list|)
operator|)
condition|)
return|return
name|ReturnFalse
return|;
if|if
condition|(
name|hsh
operator|==
operator|&
name|m_valuemapStack
operator|.
name|top
argument_list|()
condition|)
name|it
operator|->
name|clear
argument_list|()
expr_stmt|;
else|else
name|m_valuemapStack
operator|.
name|top
argument_list|()
index|[
name|var
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|ReturnTrue
return|;
block|}
case|case
name|T_UNSET
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"%1(variable) requires one argument."
argument_list|)
operator|.
name|arg
argument_list|(
name|function
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|ProValueMap
modifier|*
name|hsh
decl_stmt|;
name|ProValueMap
operator|::
name|Iterator
name|it
decl_stmt|;
specifier|const
name|ProKey
modifier|&
name|var
init|=
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|hsh
operator|=
name|findValues
argument_list|(
name|var
argument_list|,
operator|&
name|it
argument_list|)
operator|)
condition|)
return|return
name|ReturnFalse
return|;
if|if
condition|(
name|m_valuemapStack
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
name|hsh
operator|->
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hsh
operator|==
operator|&
name|m_valuemapStack
operator|.
name|top
argument_list|()
condition|)
operator|*
name|it
operator|=
name|statics
operator|.
name|fakeValue
expr_stmt|;
else|else
name|m_valuemapStack
operator|.
name|top
argument_list|()
index|[
name|var
index|]
operator|=
name|statics
operator|.
name|fakeValue
expr_stmt|;
return|return
name|ReturnTrue
return|;
block|}
if|#
directive|if
name|QT_VERSION
operator|>=
name|QT_VERSION_CHECK
argument_list|(
literal|5
operator|,
literal|0
operator|,
literal|0
argument_list|)
case|case
name|T_PARSE_JSON
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"parseJson(variable, into) requires two arguments."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|QByteArray
name|json
init|=
name|values
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toKey
argument_list|()
argument_list|)
operator|.
name|join
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
name|QString
name|parseInto
init|=
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
decl_stmt|;
return|return
name|parseJsonInto
argument_list|(
name|json
argument_list|,
name|parseInto
argument_list|,
operator|&
name|m_valuemapStack
operator|.
name|top
argument_list|()
argument_list|)
return|;
block|}
endif|#
directive|endif
case|case
name|T_INCLUDE
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|<
literal|1
operator|||
name|args
operator|.
name|count
argument_list|()
operator|>
literal|3
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"include(file, [into, [silent]]) requires one, two or three arguments."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|QString
name|parseInto
decl_stmt|;
name|LoadFlags
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m_cumulative
condition|)
name|flags
operator|=
name|LoadSilent
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|parseInto
operator|=
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|3
operator|&&
name|isTrue
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|2
argument_list|)
argument_list|,
name|m_tmp3
argument_list|)
condition|)
name|flags
operator|=
name|LoadSilent
expr_stmt|;
block|}
name|QString
name|fn
init|=
name|resolvePath
argument_list|(
name|m_option
operator|->
name|expandEnvVars
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|fn
operator|.
name|detach
argument_list|()
expr_stmt|;
name|VisitReturn
name|ok
decl_stmt|;
if|if
condition|(
name|parseInto
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ok
operator|=
name|evaluateFileChecked
argument_list|(
name|fn
argument_list|,
name|QMakeHandler
operator|::
name|EvalIncludeFile
argument_list|,
name|LoadProOnly
operator||
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ProValueMap
name|symbols
decl_stmt|;
if|if
condition|(
operator|(
name|ok
operator|=
name|evaluateFileInto
argument_list|(
name|fn
argument_list|,
operator|&
name|symbols
argument_list|,
name|LoadAll
operator||
name|flags
argument_list|)
operator|)
operator|==
name|ReturnTrue
condition|)
block|{
name|ProValueMap
name|newMap
decl_stmt|;
for|for
control|(
name|ProValueMap
operator|::
name|ConstIterator
name|it
init|=
name|m_valuemapStack
operator|.
name|top
argument_list|()
operator|.
name|constBegin
argument_list|()
init|,
name|end
init|=
name|m_valuemapStack
operator|.
name|top
argument_list|()
operator|.
name|constEnd
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QString
modifier|&
name|ky
init|=
name|it
operator|.
name|key
argument_list|()
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ky
operator|.
name|startsWith
argument_list|(
name|parseInto
argument_list|)
operator|&&
operator|(
name|ky
operator|.
name|length
argument_list|()
operator|==
name|parseInto
operator|.
name|length
argument_list|()
operator|||
name|ky
operator|.
name|at
argument_list|(
name|parseInto
operator|.
name|length
argument_list|()
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|)
operator|)
condition|)
name|newMap
index|[
name|it
operator|.
name|key
argument_list|()
index|]
operator|=
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|ProValueMap
operator|::
name|ConstIterator
name|it
init|=
name|symbols
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|symbols
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QString
modifier|&
name|ky
init|=
name|it
operator|.
name|key
argument_list|()
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ky
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
name|newMap
operator|.
name|insert
argument_list|(
name|ProKey
argument_list|(
name|parseInto
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|ky
argument_list|)
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|m_valuemapStack
operator|.
name|top
argument_list|()
operator|=
name|newMap
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ok
operator|==
name|ReturnFalse
operator|&&
operator|(
name|flags
operator|&
name|LoadSilent
operator|)
condition|)
name|ok
operator|=
name|ReturnTrue
expr_stmt|;
return|return
name|ok
return|;
block|}
case|case
name|T_LOAD
case|:
block|{
name|bool
name|ignore_error
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|==
literal|2
condition|)
block|{
name|ignore_error
operator|=
name|isTrue
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|,
name|m_tmp2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"load(feature) requires one or two arguments."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|VisitReturn
name|ok
init|=
name|evaluateFeatureFile
argument_list|(
name|m_option
operator|->
name|expandEnvVars
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|()
argument_list|)
argument_list|,
name|ignore_error
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
operator|==
name|ReturnFalse
operator|&&
name|ignore_error
condition|)
name|ok
operator|=
name|ReturnTrue
expr_stmt|;
return|return
name|ok
return|;
block|}
case|case
name|T_DEBUG
case|:
block|{
ifdef|#
directive|ifdef
name|PROEVALUATOR_DEBUG
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"debug(level, message) requires two arguments."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|int
name|level
init|=
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|level
operator|<=
name|m_debugLevel
condition|)
block|{
specifier|const
name|QString
modifier|&
name|msg
init|=
name|m_option
operator|->
name|expandEnvVars
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
argument_list|)
decl_stmt|;
name|debugMsg
argument_list|(
name|level
argument_list|,
literal|"Project DEBUG: %s"
argument_list|,
name|qPrintable
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|ReturnTrue
return|;
block|}
case|case
name|T_LOG
case|:
case|case
name|T_ERROR
case|:
case|case
name|T_WARNING
case|:
case|case
name|T_MESSAGE
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"%1(message) requires one argument."
argument_list|)
operator|.
name|arg
argument_list|(
name|function
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
specifier|const
name|QString
modifier|&
name|msg
init|=
name|m_option
operator|->
name|expandEnvVars
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m_skipLevel
condition|)
block|{
if|if
condition|(
name|func_t
operator|==
name|T_LOG
condition|)
block|{
ifdef|#
directive|ifdef
name|PROEVALUATOR_FULL
name|fputs
argument_list|(
name|msg
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|m_handler
operator|->
name|fileMessage
argument_list|(
operator|(
name|func_t
operator|==
name|T_ERROR
condition|?
name|QMakeHandler
operator|::
name|ErrorMessage
else|:
name|func_t
operator|==
name|T_WARNING
condition|?
name|QMakeHandler
operator|::
name|WarningMessage
else|:
name|QMakeHandler
operator|::
name|InfoMessage
operator|)
operator||
operator|(
name|m_cumulative
condition|?
name|QMakeHandler
operator|::
name|CumulativeEvalMessage
else|:
literal|0
operator|)
argument_list|,
name|fL1S
argument_list|(
literal|"Project %1: %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|function
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
operator|.
name|toUpper
argument_list|()
argument_list|,
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|func_t
operator|==
name|T_ERROR
operator|&&
operator|!
name|m_cumulative
operator|)
condition|?
name|ReturnError
else|:
name|ReturnTrue
return|;
block|}
case|case
name|T_SYSTEM
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"system(exec) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
ifdef|#
directive|ifdef
name|PROEVALUATOR_FULL
if|if
condition|(
name|m_cumulative
condition|)
comment|// Anything else would be insanity
return|return
name|ReturnFalse
return|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QProcess
name|proc
decl_stmt|;
name|proc
operator|.
name|setProcessChannelMode
argument_list|(
name|QProcess
operator|::
name|ForwardedChannels
argument_list|)
expr_stmt|;
name|runProcess
argument_list|(
operator|&
name|proc
argument_list|,
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|returnBool
argument_list|(
name|proc
operator|.
name|exitStatus
argument_list|()
operator|==
name|QProcess
operator|::
name|NormalExit
operator|&&
name|proc
operator|.
name|exitCode
argument_list|()
operator|==
literal|0
argument_list|)
return|;
else|#
directive|else
return|return
name|returnBool
argument_list|(
name|system
argument_list|(
operator|(
name|QLatin1String
argument_list|(
literal|"cd "
argument_list|)
operator|+
name|IoUtils
operator|::
name|shellQuote
argument_list|(
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|currentDirectory
argument_list|()
argument_list|)
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"&& "
argument_list|)
operator|+
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
operator|==
literal|0
argument_list|)
return|;
endif|#
directive|endif
else|#
directive|else
return|return
name|ReturnTrue
return|;
endif|#
directive|endif
block|}
case|case
name|T_ISEMPTY
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"isEmpty(var) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
return|return
name|returnBool
argument_list|(
name|values
argument_list|(
name|map
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|isEmpty
argument_list|()
argument_list|)
return|;
block|}
case|case
name|T_EXISTS
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"exists(file) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
specifier|const
name|QString
modifier|&
name|file
init|=
name|resolvePath
argument_list|(
name|m_option
operator|->
name|expandEnvVars
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// Don't use VFS here:
comment|// - it supports neither listing nor even directories
comment|// - it's unlikely that somebody would test for files they created themselves
if|if
condition|(
name|IoUtils
operator|::
name|exists
argument_list|(
name|file
argument_list|)
condition|)
return|return
name|ReturnTrue
return|;
name|int
name|slsh
init|=
name|file
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|fn
init|=
name|file
operator|.
name|mid
argument_list|(
name|slsh
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
argument_list|)
operator|||
name|fn
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
argument_list|)
condition|)
block|{
name|QString
name|dirstr
init|=
name|file
operator|.
name|left
argument_list|(
name|slsh
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QDir
argument_list|(
name|dirstr
argument_list|)
operator|.
name|entryList
argument_list|(
name|QStringList
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|ReturnTrue
return|;
block|}
return|return
name|ReturnFalse
return|;
block|}
case|case
name|T_MKPATH
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"mkpath(file) requires one argument."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
ifdef|#
directive|ifdef
name|PROEVALUATOR_FULL
specifier|const
name|QString
modifier|&
name|fn
init|=
name|resolvePath
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QDir
operator|::
name|current
argument_list|()
operator|.
name|mkpath
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Cannot create directory %1."
argument_list|)
operator|.
name|arg
argument_list|(
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
endif|#
directive|endif
return|return
name|ReturnTrue
return|;
block|}
case|case
name|T_WRITE_FILE
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|3
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"write_file(name, [content var, [append] [exe]]) requires one to three arguments."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|QIODevice
operator|::
name|OpenMode
name|mode
init|=
name|QIODevice
operator|::
name|Truncate
decl_stmt|;
name|bool
name|exe
init|=
literal|false
decl_stmt|;
name|QString
name|contents
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|2
condition|)
block|{
specifier|const
name|ProStringList
modifier|&
name|vals
init|=
name|values
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vals
operator|.
name|isEmpty
argument_list|()
condition|)
name|contents
operator|=
name|vals
operator|.
name|join
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|3
condition|)
block|{
specifier|const
specifier|auto
name|opts
init|=
name|split_value_list
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
name|ProString
modifier|&
name|opt
range|:
name|opts
control|)
block|{
name|opt
operator|.
name|toQString
argument_list|(
name|m_tmp3
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_tmp3
operator|==
name|QLatin1String
argument_list|(
literal|"append"
argument_list|)
condition|)
block|{
name|mode
operator|=
name|QIODevice
operator|::
name|Append
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp3
operator|==
name|QLatin1String
argument_list|(
literal|"exe"
argument_list|)
condition|)
block|{
name|exe
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"write_file(): invalid flag %1."
argument_list|)
operator|.
name|arg
argument_list|(
name|m_tmp3
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
block|}
block|}
block|}
name|QString
name|path
init|=
name|resolvePath
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
decl_stmt|;
name|path
operator|.
name|detach
argument_list|()
expr_stmt|;
comment|// make sure to not leak m_tmp1 into the map of written files.
return|return
name|writeFile
argument_list|(
name|QString
argument_list|()
argument_list|,
name|path
argument_list|,
name|mode
argument_list|,
name|exe
argument_list|,
name|contents
argument_list|)
return|;
block|}
case|case
name|T_TOUCH
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"touch(file, reffile) requires two arguments."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
ifdef|#
directive|ifdef
name|PROEVALUATOR_FULL
specifier|const
name|QString
modifier|&
name|tfn
init|=
name|resolvePath
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QString
modifier|&
name|rfn
init|=
name|resolvePath
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|rfn
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Cannot stat() reference file %1: %2."
argument_list|)
operator|.
name|arg
argument_list|(
name|rfn
argument_list|,
name|fL1S
argument_list|(
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|struct
name|utimbuf
name|utb
decl_stmt|;
name|utb
operator|.
name|actime
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|utb
operator|.
name|modtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|tfn
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
operator|&
name|utb
argument_list|)
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Cannot touch %1: %2."
argument_list|)
operator|.
name|arg
argument_list|(
name|tfn
argument_list|,
name|fL1S
argument_list|(
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
else|#
directive|else
name|HANDLE
name|rHand
init|=
name|CreateFile
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|rfn
operator|.
name|utf16
argument_list|()
argument_list|,
name|GENERIC_READ
argument_list|,
name|FILE_SHARE_READ
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|rHand
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Cannot open reference file %1: %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|rfn
argument_list|,
name|windowsErrorCode
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|FILETIME
name|ft
decl_stmt|;
name|GetFileTime
argument_list|(
name|rHand
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|ft
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|rHand
argument_list|)
expr_stmt|;
name|HANDLE
name|wHand
init|=
name|CreateFile
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|tfn
operator|.
name|utf16
argument_list|()
argument_list|,
name|GENERIC_WRITE
argument_list|,
name|FILE_SHARE_READ
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|wHand
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Cannot open %1: %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|tfn
argument_list|,
name|windowsErrorCode
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|SetFileTime
argument_list|(
name|wHand
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|ft
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|wHand
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|ReturnTrue
return|;
block|}
case|case
name|T_CACHE
case|:
block|{
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>
literal|3
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"cache(var, [set|add|sub] [transient] [super|stash], [srcvar]) requires one to three arguments."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|bool
name|persist
init|=
literal|true
decl_stmt|;
enum|enum
block|{
name|TargetStash
block|,
name|TargetCache
block|,
name|TargetSuper
block|}
name|target
init|=
name|TargetCache
enum|;
enum|enum
block|{
name|CacheSet
block|,
name|CacheAdd
block|,
name|CacheSub
block|}
name|mode
init|=
name|CacheSet
enum|;
name|ProKey
name|srcvar
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|2
condition|)
block|{
specifier|const
specifier|auto
name|opts
init|=
name|split_value_list
argument_list|(
name|args
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
name|ProString
modifier|&
name|opt
range|:
name|opts
control|)
block|{
name|opt
operator|.
name|toQString
argument_list|(
name|m_tmp3
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_tmp3
operator|==
name|QLatin1String
argument_list|(
literal|"transient"
argument_list|)
condition|)
block|{
name|persist
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp3
operator|==
name|QLatin1String
argument_list|(
literal|"super"
argument_list|)
condition|)
block|{
name|target
operator|=
name|TargetSuper
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp3
operator|==
name|QLatin1String
argument_list|(
literal|"stash"
argument_list|)
condition|)
block|{
name|target
operator|=
name|TargetStash
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp3
operator|==
name|QLatin1String
argument_list|(
literal|"set"
argument_list|)
condition|)
block|{
name|mode
operator|=
name|CacheSet
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp3
operator|==
name|QLatin1String
argument_list|(
literal|"add"
argument_list|)
condition|)
block|{
name|mode
operator|=
name|CacheAdd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_tmp3
operator|==
name|QLatin1String
argument_list|(
literal|"sub"
argument_list|)
condition|)
block|{
name|mode
operator|=
name|CacheSub
expr_stmt|;
block|}
else|else
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"cache(): invalid flag %1."
argument_list|)
operator|.
name|arg
argument_list|(
name|m_tmp3
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
block|}
if|if
condition|(
name|args
operator|.
name|count
argument_list|()
operator|>=
literal|3
condition|)
block|{
name|srcvar
operator|=
name|args
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toKey
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|!=
name|CacheSet
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"cache(): modes other than 'set' require a source variable."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
block|}
name|QString
name|varstr
decl_stmt|;
name|ProKey
name|dstvar
init|=
name|args
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dstvar
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|srcvar
operator|.
name|isEmpty
argument_list|()
condition|)
name|srcvar
operator|=
name|dstvar
expr_stmt|;
name|ProValueMap
operator|::
name|Iterator
name|srcvarIt
decl_stmt|;
if|if
condition|(
operator|!
name|findValues
argument_list|(
name|srcvar
argument_list|,
operator|&
name|srcvarIt
argument_list|)
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Variable %1 is not defined."
argument_list|)
operator|.
name|arg
argument_list|(
name|srcvar
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
comment|// The caches for the host and target may differ (e.g., when we are manipulating
comment|// CONFIG), so we cannot compute a common new value for both.
specifier|const
name|ProStringList
modifier|&
name|diffval
init|=
operator|*
name|srcvarIt
decl_stmt|;
name|ProStringList
name|newval
decl_stmt|;
name|bool
name|changed
init|=
literal|false
decl_stmt|;
for|for
control|(
name|bool
name|hostBuild
init|=
literal|false
init|;
condition|;
name|hostBuild
operator|=
literal|true
control|)
block|{
ifdef|#
directive|ifdef
name|PROEVALUATOR_THREAD_SAFE
name|m_option
operator|->
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QMakeBaseEnv
modifier|*
name|baseEnv
init|=
name|m_option
operator|->
name|baseEnvs
operator|.
name|value
argument_list|(
name|QMakeBaseKey
argument_list|(
name|m_buildRoot
argument_list|,
name|m_stashfile
argument_list|,
name|hostBuild
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PROEVALUATOR_THREAD_SAFE
comment|// It's ok to unlock this before locking baseEnv,
comment|// as we have no intention to initialize the env.
name|m_option
operator|->
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
endif|#
directive|endif
do|do
block|{
if|if
condition|(
operator|!
name|baseEnv
condition|)
break|break;
ifdef|#
directive|ifdef
name|PROEVALUATOR_THREAD_SAFE
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|baseEnv
operator|->
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|baseEnv
operator|->
name|inProgress
operator|&&
name|baseEnv
operator|->
name|evaluator
operator|!=
name|this
condition|)
block|{
comment|// The env is still in the works, but it may be already past the cache
comment|// loading. So we need to wait for completion and amend it as usual.
name|QThreadPool
operator|::
name|globalInstance
argument_list|()
operator|->
name|releaseThread
argument_list|()
expr_stmt|;
name|baseEnv
operator|->
name|cond
operator|.
name|wait
argument_list|(
operator|&
name|baseEnv
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|QThreadPool
operator|::
name|globalInstance
argument_list|()
operator|->
name|reserveThread
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|baseEnv
operator|->
name|isOk
condition|)
break|break;
endif|#
directive|endif
name|QMakeEvaluator
modifier|*
name|baseEval
init|=
name|baseEnv
operator|->
name|evaluator
decl_stmt|;
specifier|const
name|ProStringList
modifier|&
name|oldval
init|=
name|baseEval
operator|->
name|values
argument_list|(
name|dstvar
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|CacheSet
condition|)
block|{
name|newval
operator|=
name|diffval
expr_stmt|;
block|}
else|else
block|{
name|newval
operator|=
name|oldval
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CacheAdd
condition|)
name|newval
operator|+=
name|diffval
expr_stmt|;
else|else
name|newval
operator|.
name|removeEach
argument_list|(
name|diffval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldval
operator|!=
name|newval
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|TargetStash
operator|||
operator|!
name|m_stashfile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|baseEval
operator|->
name|valuesRef
argument_list|(
name|dstvar
argument_list|)
operator|=
name|newval
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|TargetSuper
condition|)
block|{
do|do
block|{
if|if
condition|(
name|dstvar
operator|==
name|QLatin1String
argument_list|(
literal|"QMAKEPATH"
argument_list|)
condition|)
block|{
name|baseEval
operator|->
name|m_qmakepath
operator|=
name|newval
operator|.
name|toQStringList
argument_list|()
expr_stmt|;
name|baseEval
operator|->
name|updateMkspecPaths
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dstvar
operator|==
name|QLatin1String
argument_list|(
literal|"QMAKEFEATURES"
argument_list|)
condition|)
block|{
name|baseEval
operator|->
name|m_qmakefeatures
operator|=
name|newval
operator|.
name|toQStringList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|baseEval
operator|->
name|updateFeaturePaths
argument_list|()
expr_stmt|;
if|if
condition|(
name|hostBuild
operator|==
name|m_hostBuild
condition|)
name|m_featureRoots
operator|=
name|baseEval
operator|->
name|m_featureRoots
expr_stmt|;
block|}
do|while
condition|(
literal|false
condition|)
do|;
block|}
block|}
name|changed
operator|=
literal|true
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|false
condition|)
do|;
if|if
condition|(
name|hostBuild
condition|)
break|break;
block|}
comment|// We assume that whatever got the cached value to be what it is now will do so
comment|// the next time as well, so we just skip the persisting if nothing changed.
if|if
condition|(
operator|!
name|persist
operator|||
operator|!
name|changed
condition|)
return|return
name|ReturnTrue
return|;
name|varstr
operator|=
name|dstvar
operator|.
name|toQString
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CacheAdd
condition|)
name|varstr
operator|+=
name|QLatin1String
argument_list|(
literal|" +="
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|CacheSub
condition|)
name|varstr
operator|+=
name|QLatin1String
argument_list|(
literal|" -="
argument_list|)
expr_stmt|;
else|else
name|varstr
operator|+=
name|QLatin1String
argument_list|(
literal|" ="
argument_list|)
expr_stmt|;
if|if
condition|(
name|diffval
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
name|varstr
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|varstr
operator|+=
name|quoteValue
argument_list|(
name|diffval
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|diffval
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
specifier|const
name|ProString
modifier|&
name|vval
range|:
name|diffval
control|)
block|{
name|varstr
operator|+=
name|QLatin1String
argument_list|(
literal|" \\\n    "
argument_list|)
expr_stmt|;
name|varstr
operator|+=
name|quoteValue
argument_list|(
name|vval
argument_list|)
expr_stmt|;
block|}
block|}
name|varstr
operator|+=
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|QString
name|fn
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|TargetSuper
condition|)
block|{
if|if
condition|(
name|m_superfile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|m_superfile
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|m_outputDir
operator|+
name|QLatin1String
argument_list|(
literal|"/.qmake.super"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Info: creating super cache file %s\n"
argument_list|,
name|qPrintable
argument_list|(
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|m_superfile
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|valuesRef
argument_list|(
name|ProKey
argument_list|(
literal|"_QMAKE_SUPER_CACHE_"
argument_list|)
argument_list|)
operator|<<
name|ProString
argument_list|(
name|m_superfile
argument_list|)
expr_stmt|;
block|}
name|fn
operator|=
name|m_superfile
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|==
name|TargetCache
condition|)
block|{
if|if
condition|(
name|m_cachefile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|m_cachefile
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|m_outputDir
operator|+
name|QLatin1String
argument_list|(
literal|"/.qmake.cache"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Info: creating cache file %s\n"
argument_list|,
name|qPrintable
argument_list|(
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|m_cachefile
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|valuesRef
argument_list|(
name|ProKey
argument_list|(
literal|"_QMAKE_CACHE_"
argument_list|)
argument_list|)
operator|<<
name|ProString
argument_list|(
name|m_cachefile
argument_list|)
expr_stmt|;
comment|// We could update m_{source,build}Root and m_featureRoots here, or even
comment|// "re-home" our rootEnv, but this doesn't sound too useful - if somebody
comment|// wanted qmake to find something in the build directory, he could have
comment|// done so "from the outside".
comment|// The sub-projects will find the new cache all by themselves.
block|}
name|fn
operator|=
name|m_cachefile
expr_stmt|;
block|}
else|else
block|{
name|fn
operator|=
name|m_stashfile
expr_stmt|;
if|if
condition|(
name|fn
operator|.
name|isEmpty
argument_list|()
condition|)
name|fn
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|m_outputDir
operator|+
name|QLatin1String
argument_list|(
literal|"/.qmake.stash"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_vfs
operator|->
name|exists
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Info: creating stash file %s\n"
argument_list|,
name|qPrintable
argument_list|(
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|valuesRef
argument_list|(
name|ProKey
argument_list|(
literal|"_QMAKE_STASH_"
argument_list|)
argument_list|)
operator|<<
name|ProString
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|writeFile
argument_list|(
name|fL1S
argument_list|(
literal|"cache "
argument_list|)
argument_list|,
name|fn
argument_list|,
name|QIODevice
operator|::
name|Append
argument_list|,
literal|false
argument_list|,
name|varstr
argument_list|)
return|;
block|}
default|default:
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Function '%1' is not implemented."
argument_list|)
operator|.
name|arg
argument_list|(
name|function
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
