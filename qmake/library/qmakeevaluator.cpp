begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the qmake application of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qmakeevaluator.h"
end_include
begin_include
include|#
directive|include
file|"qmakeevaluator_p.h"
end_include
begin_include
include|#
directive|include
file|"qmakeglobals.h"
end_include
begin_include
include|#
directive|include
file|"qmakeparser.h"
end_include
begin_include
include|#
directive|include
file|"qmakevfs.h"
end_include
begin_include
include|#
directive|include
file|"ioutils.h"
end_include
begin_include
include|#
directive|include
file|<qbytearray.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qlist.h>
end_include
begin_include
include|#
directive|include
file|<qregexp.h>
end_include
begin_include
include|#
directive|include
file|<qset.h>
end_include
begin_include
include|#
directive|include
file|<qstack.h>
end_include
begin_include
include|#
directive|include
file|<qstring.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|PROEVALUATOR_THREAD_SAFE
end_ifdef
begin_include
include|#
directive|include
file|<qthreadpool.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_BSD4
end_ifdef
begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|<windows.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_using
using|using
namespace|namespace
name|QMakeInternal
namespace|;
end_using
begin_function
name|QT_BEGIN_NAMESPACE
DECL|macro|fL1S
define|#
directive|define
name|fL1S
parameter_list|(
name|s
parameter_list|)
value|QString::fromLatin1(s)
comment|// we can't use QThread in qmake
comment|// this function is a merger of QThread::idealThreadCount from qthread_win.cpp and qthread_unix.cpp
DECL|function|idealThreadCount
specifier|static
name|int
name|idealThreadCount
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|PROEVALUATOR_THREAD_SAFE
return|return
name|QThread
operator|::
name|idealThreadCount
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|SYSTEM_INFO
name|sysinfo
decl_stmt|;
name|GetSystemInfo
argument_list|(
operator|&
name|sysinfo
argument_list|)
expr_stmt|;
return|return
name|sysinfo
operator|.
name|dwNumberOfProcessors
return|;
else|#
directive|else
comment|// there are a couple more definitions in the Unix QThread::idealThreadCount, but
comment|// we don't need them all here
name|int
name|cores
init|=
literal|1
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_BSD4
argument_list|)
comment|// FreeBSD, OpenBSD, NetBSD, BSD/OS, Mac OS X
name|size_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|cores
argument_list|)
decl_stmt|;
name|int
name|mib
index|[
literal|2
index|]
decl_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_HW
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|HW_NCPU
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
operator|&
name|cores
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"sysctl"
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|_SC_NPROCESSORS_ONLN
argument_list|)
comment|// the rest: Linux, Solaris, AIX, Tru64
name|cores
operator|=
operator|(
name|int
operator|)
name|sysconf
argument_list|(
name|_SC_NPROCESSORS_ONLN
argument_list|)
expr_stmt|;
if|if
condition|(
name|cores
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
name|cores
return|;
endif|#
directive|endif
block|}
end_function
begin_constructor
DECL|function|QMakeBaseKey
name|QMakeBaseKey
operator|::
name|QMakeBaseKey
parameter_list|(
specifier|const
name|QString
modifier|&
name|_root
parameter_list|,
specifier|const
name|QString
modifier|&
name|_stash
parameter_list|,
name|bool
name|_hostBuild
parameter_list|)
member_init_list|:
name|root
argument_list|(
name|_root
argument_list|)
member_init_list|,
name|stash
argument_list|(
name|_stash
argument_list|)
member_init_list|,
name|hostBuild
argument_list|(
name|_hostBuild
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|qHash
name|uint
name|qHash
parameter_list|(
specifier|const
name|QMakeBaseKey
modifier|&
name|key
parameter_list|)
block|{
return|return
name|qHash
argument_list|(
name|key
operator|.
name|root
argument_list|)
operator|^
name|qHash
argument_list|(
name|key
operator|.
name|stash
argument_list|)
operator|^
operator|(
name|uint
operator|)
name|key
operator|.
name|hostBuild
return|;
block|}
end_function
begin_function
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QMakeBaseKey
modifier|&
name|one
parameter_list|,
specifier|const
name|QMakeBaseKey
modifier|&
name|two
parameter_list|)
block|{
return|return
name|one
operator|.
name|root
operator|==
name|two
operator|.
name|root
operator|&&
name|one
operator|.
name|stash
operator|==
name|two
operator|.
name|stash
operator|&&
name|one
operator|.
name|hostBuild
operator|==
name|two
operator|.
name|hostBuild
return|;
block|}
end_function
begin_constructor
DECL|function|QMakeBaseEnv
name|QMakeBaseEnv
operator|::
name|QMakeBaseEnv
parameter_list|()
member_init_list|:
name|evaluator
argument_list|(
literal|0
argument_list|)
block|{
ifdef|#
directive|ifdef
name|PROEVALUATOR_THREAD_SAFE
name|inProgress
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_destructor
DECL|function|~QMakeBaseEnv
name|QMakeBaseEnv
operator|::
name|~
name|QMakeBaseEnv
parameter_list|()
block|{
operator|delete
name|evaluator
expr_stmt|;
block|}
end_destructor
begin_namespace
DECL|namespace|QMakeInternal
namespace|namespace
name|QMakeInternal
block|{
DECL|member|statics
name|QMakeStatics
name|statics
decl_stmt|;
block|}
end_namespace
begin_function
DECL|function|initStatics
name|void
name|QMakeEvaluator
operator|::
name|initStatics
parameter_list|()
block|{
if|if
condition|(
operator|!
name|statics
operator|.
name|field_sep
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|statics
operator|.
name|field_sep
operator|=
name|QLatin1String
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strtrue
operator|=
name|QLatin1String
argument_list|(
literal|"true"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strfalse
operator|=
name|QLatin1String
argument_list|(
literal|"false"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strCONFIG
operator|=
name|ProKey
argument_list|(
literal|"CONFIG"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strARGS
operator|=
name|ProKey
argument_list|(
literal|"ARGS"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strARGC
operator|=
name|ProKey
argument_list|(
literal|"ARGC"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strDot
operator|=
name|QLatin1String
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strDotDot
operator|=
name|QLatin1String
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strever
operator|=
name|QLatin1String
argument_list|(
literal|"ever"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strforever
operator|=
name|QLatin1String
argument_list|(
literal|"forever"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strhost_build
operator|=
name|QLatin1String
argument_list|(
literal|"host_build"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strTEMPLATE
operator|=
name|ProKey
argument_list|(
literal|"TEMPLATE"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strQMAKE_PLATFORM
operator|=
name|ProKey
argument_list|(
literal|"QMAKE_PLATFORM"
argument_list|)
expr_stmt|;
name|statics
operator|.
name|strQMAKESPEC
operator|=
name|ProKey
argument_list|(
literal|"QMAKESPEC"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROEVALUATOR_FULL
name|statics
operator|.
name|strREQUIRES
operator|=
name|ProKey
argument_list|(
literal|"REQUIRES"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|statics
operator|.
name|fakeValue
operator|=
name|ProStringList
argument_list|(
name|ProString
argument_list|(
literal|"_FAKE_"
argument_list|)
argument_list|)
expr_stmt|;
comment|// It has to have a unique begin() value
name|initFunctionStatics
argument_list|()
expr_stmt|;
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|oldname
decl_stmt|,
modifier|*
decl_stmt|const
name|newname
decl_stmt|;
block|}
name|mapInits
index|[]
init|=
block|{
block|{
literal|"INTERFACES"
block|,
literal|"FORMS"
block|}
block|,
block|{
literal|"QMAKE_POST_BUILD"
block|,
literal|"QMAKE_POST_LINK"
block|}
block|,
block|{
literal|"TARGETDEPS"
block|,
literal|"POST_TARGETDEPS"
block|}
block|,
block|{
literal|"LIBPATH"
block|,
literal|"QMAKE_LIBDIR"
block|}
block|,
block|{
literal|"QMAKE_EXT_MOC"
block|,
literal|"QMAKE_EXT_CPP_MOC"
block|}
block|,
block|{
literal|"QMAKE_MOD_MOC"
block|,
literal|"QMAKE_H_MOD_MOC"
block|}
block|,
block|{
literal|"QMAKE_LFLAGS_SHAPP"
block|,
literal|"QMAKE_LFLAGS_APP"
block|}
block|,
block|{
literal|"PRECOMPH"
block|,
literal|"PRECOMPILED_HEADER"
block|}
block|,
block|{
literal|"PRECOMPCPP"
block|,
literal|"PRECOMPILED_SOURCE"
block|}
block|,
block|{
literal|"INCPATH"
block|,
literal|"INCLUDEPATH"
block|}
block|,
block|{
literal|"QMAKE_EXTRA_WIN_COMPILERS"
block|,
literal|"QMAKE_EXTRA_COMPILERS"
block|}
block|,
block|{
literal|"QMAKE_EXTRA_UNIX_COMPILERS"
block|,
literal|"QMAKE_EXTRA_COMPILERS"
block|}
block|,
block|{
literal|"QMAKE_EXTRA_WIN_TARGETS"
block|,
literal|"QMAKE_EXTRA_TARGETS"
block|}
block|,
block|{
literal|"QMAKE_EXTRA_UNIX_TARGETS"
block|,
literal|"QMAKE_EXTRA_TARGETS"
block|}
block|,
block|{
literal|"QMAKE_EXTRA_UNIX_INCLUDES"
block|,
literal|"QMAKE_EXTRA_INCLUDES"
block|}
block|,
block|{
literal|"QMAKE_EXTRA_UNIX_VARIABLES"
block|,
literal|"QMAKE_EXTRA_VARIABLES"
block|}
block|,
block|{
literal|"QMAKE_RPATH"
block|,
literal|"QMAKE_LFLAGS_RPATH"
block|}
block|,
block|{
literal|"QMAKE_FRAMEWORKDIR"
block|,
literal|"QMAKE_FRAMEWORKPATH"
block|}
block|,
block|{
literal|"QMAKE_FRAMEWORKDIR_FLAGS"
block|,
literal|"QMAKE_FRAMEWORKPATH_FLAGS"
block|}
block|,
block|{
literal|"IN_PWD"
block|,
literal|"PWD"
block|}
block|}
struct|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mapInits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mapInits
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
name|statics
operator|.
name|varMap
operator|.
name|insert
argument_list|(
name|ProKey
argument_list|(
name|mapInits
index|[
name|i
index|]
operator|.
name|oldname
argument_list|)
argument_list|,
name|ProKey
argument_list|(
name|mapInits
index|[
name|i
index|]
operator|.
name|newname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|map
specifier|const
name|ProKey
modifier|&
name|QMakeEvaluator
operator|::
name|map
parameter_list|(
specifier|const
name|ProKey
modifier|&
name|var
parameter_list|)
block|{
name|QHash
argument_list|<
name|ProKey
argument_list|,
name|ProKey
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|statics
operator|.
name|varMap
operator|.
name|constFind
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|statics
operator|.
name|varMap
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|var
return|;
name|deprecationWarning
argument_list|(
name|fL1S
argument_list|(
literal|"Variable %1 is deprecated; use %2 instead."
argument_list|)
operator|.
name|arg
argument_list|(
name|var
operator|.
name|toQString
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
operator|.
name|toQString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|it
operator|.
name|value
argument_list|()
return|;
block|}
end_function
begin_constructor
DECL|function|QMakeEvaluator
name|QMakeEvaluator
operator|::
name|QMakeEvaluator
parameter_list|(
name|QMakeGlobals
modifier|*
name|option
parameter_list|,
name|QMakeParser
modifier|*
name|parser
parameter_list|,
name|QMakeVfs
modifier|*
name|vfs
parameter_list|,
name|QMakeHandler
modifier|*
name|handler
parameter_list|)
member_init_list|:
ifdef|#
directive|ifdef
name|PROEVALUATOR_DEBUG
name|m_debugLevel
argument_list|(
name|option
operator|->
name|debugLevel
argument_list|)
member_init_list|,
endif|#
directive|endif
name|m_option
argument_list|(
name|option
argument_list|)
member_init_list|,
name|m_parser
argument_list|(
name|parser
argument_list|)
member_init_list|,
name|m_handler
argument_list|(
name|handler
argument_list|)
member_init_list|,
name|m_vfs
argument_list|(
name|vfs
argument_list|)
block|{
comment|// So that single-threaded apps don't have to call initialize() for now.
name|initStatics
argument_list|()
expr_stmt|;
comment|// Configuration, more or less
name|m_caller
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PROEVALUATOR_CUMULATIVE
name|m_cumulative
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
name|m_hostBuild
operator|=
literal|false
expr_stmt|;
comment|// Evaluator state
ifdef|#
directive|ifdef
name|PROEVALUATOR_CUMULATIVE
name|m_skipLevel
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|m_listCount
operator|=
literal|0
expr_stmt|;
name|m_valuemapStack
operator|.
name|push
argument_list|(
name|ProValueMap
argument_list|()
argument_list|)
expr_stmt|;
name|m_valuemapInited
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QMakeEvaluator
name|QMakeEvaluator
operator|::
name|~
name|QMakeEvaluator
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|initFrom
name|void
name|QMakeEvaluator
operator|::
name|initFrom
parameter_list|(
specifier|const
name|QMakeEvaluator
modifier|*
name|other
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
name|other
argument_list|,
literal|"QMakeEvaluator::visitProFile"
argument_list|,
literal|"Project not prepared"
argument_list|)
expr_stmt|;
name|m_functionDefs
operator|=
name|other
operator|->
name|m_functionDefs
expr_stmt|;
name|m_valuemapStack
operator|=
name|other
operator|->
name|m_valuemapStack
expr_stmt|;
name|m_valuemapInited
operator|=
literal|true
expr_stmt|;
name|m_qmakespec
operator|=
name|other
operator|->
name|m_qmakespec
expr_stmt|;
name|m_qmakespecName
operator|=
name|other
operator|->
name|m_qmakespecName
expr_stmt|;
name|m_mkspecPaths
operator|=
name|other
operator|->
name|m_mkspecPaths
expr_stmt|;
name|m_featureRoots
operator|=
name|other
operator|->
name|m_featureRoots
expr_stmt|;
name|m_dirSep
operator|=
name|other
operator|->
name|m_dirSep
expr_stmt|;
block|}
end_function
begin_comment
comment|//////// Evaluator tools /////////
end_comment
begin_function
DECL|function|getBlockLen
name|uint
name|QMakeEvaluator
operator|::
name|getBlockLen
parameter_list|(
specifier|const
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
name|uint
name|len
init|=
operator|*
name|tokPtr
operator|++
decl_stmt|;
name|len
operator||=
operator|(
name|uint
operator|)
operator|*
name|tokPtr
operator|++
operator|<<
literal|16
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_function
DECL|function|getStr
name|ProString
name|QMakeEvaluator
operator|::
name|getStr
parameter_list|(
specifier|const
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
name|uint
name|len
init|=
operator|*
name|tokPtr
operator|++
decl_stmt|;
name|ProString
name|ret
argument_list|(
name|m_current
operator|.
name|pro
operator|->
name|items
argument_list|()
argument_list|,
name|tokPtr
operator|-
name|m_current
operator|.
name|pro
operator|->
name|tokPtr
argument_list|()
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|ret
operator|.
name|setSource
argument_list|(
name|m_current
operator|.
name|pro
argument_list|)
expr_stmt|;
name|tokPtr
operator|+=
name|len
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|getHashStr
name|ProKey
name|QMakeEvaluator
operator|::
name|getHashStr
parameter_list|(
specifier|const
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
name|uint
name|hash
init|=
name|getBlockLen
argument_list|(
name|tokPtr
argument_list|)
decl_stmt|;
name|uint
name|len
init|=
operator|*
name|tokPtr
operator|++
decl_stmt|;
name|ProKey
name|ret
argument_list|(
name|m_current
operator|.
name|pro
operator|->
name|items
argument_list|()
argument_list|,
name|tokPtr
operator|-
name|m_current
operator|.
name|pro
operator|->
name|tokPtr
argument_list|()
argument_list|,
name|len
argument_list|,
name|hash
argument_list|)
decl_stmt|;
name|tokPtr
operator|+=
name|len
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|skipStr
name|void
name|QMakeEvaluator
operator|::
name|skipStr
parameter_list|(
specifier|const
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
name|uint
name|len
init|=
operator|*
name|tokPtr
operator|++
decl_stmt|;
name|tokPtr
operator|+=
name|len
expr_stmt|;
block|}
end_function
begin_function
DECL|function|skipHashStr
name|void
name|QMakeEvaluator
operator|::
name|skipHashStr
parameter_list|(
specifier|const
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
name|tokPtr
operator|+=
literal|2
expr_stmt|;
name|uint
name|len
init|=
operator|*
name|tokPtr
operator|++
decl_stmt|;
name|tokPtr
operator|+=
name|len
expr_stmt|;
block|}
end_function
begin_comment
comment|// FIXME: this should not build new strings for direct sections.
end_comment
begin_comment
comment|// Note that the E_SPRINTF and E_LIST implementations rely on the deep copy.
end_comment
begin_function
DECL|function|split_value_list
name|ProStringList
name|QMakeEvaluator
operator|::
name|split_value_list
parameter_list|(
specifier|const
name|QString
modifier|&
name|vals
parameter_list|,
specifier|const
name|ProFile
modifier|*
name|source
parameter_list|)
block|{
name|QString
name|build
decl_stmt|;
name|ProStringList
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|source
condition|)
name|source
operator|=
name|currentProFile
argument_list|()
expr_stmt|;
specifier|const
name|QChar
modifier|*
name|vals_data
init|=
name|vals
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|int
name|vals_len
init|=
name|vals
operator|.
name|length
argument_list|()
decl_stmt|;
name|ushort
name|quote
init|=
literal|0
decl_stmt|;
name|bool
name|hadWord
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|vals_len
condition|;
name|x
operator|++
control|)
block|{
name|ushort
name|unicode
init|=
name|vals_data
index|[
name|x
index|]
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|unicode
operator|==
name|quote
condition|)
block|{
name|quote
operator|=
literal|0
expr_stmt|;
name|hadWord
operator|=
literal|true
expr_stmt|;
name|build
operator|+=
name|QChar
argument_list|(
name|unicode
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|unicode
condition|)
block|{
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
if|if
condition|(
operator|!
name|quote
condition|)
name|quote
operator|=
name|unicode
expr_stmt|;
name|hadWord
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
if|if
condition|(
operator|!
name|quote
condition|)
block|{
if|if
condition|(
name|hadWord
condition|)
block|{
name|ret
operator|<<
name|ProString
argument_list|(
name|build
argument_list|)
operator|.
name|setSource
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|build
operator|.
name|clear
argument_list|()
expr_stmt|;
name|hadWord
operator|=
literal|false
expr_stmt|;
block|}
continue|continue;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|x
operator|+
literal|1
operator|!=
name|vals_len
condition|)
block|{
name|ushort
name|next
init|=
name|vals_data
index|[
operator|++
name|x
index|]
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|==
literal|'\''
operator|||
name|next
operator|==
literal|'"'
operator|||
name|next
operator|==
literal|'\\'
condition|)
block|{
name|build
operator|+=
name|QChar
argument_list|(
name|unicode
argument_list|)
expr_stmt|;
name|unicode
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
operator|--
name|x
expr_stmt|;
block|}
block|}
comment|// fallthrough
default|default:
name|hadWord
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|build
operator|+=
name|QChar
argument_list|(
name|unicode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hadWord
condition|)
name|ret
operator|<<
name|ProString
argument_list|(
name|build
argument_list|)
operator|.
name|setSource
argument_list|(
name|source
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|replaceInList
specifier|static
name|void
name|replaceInList
parameter_list|(
name|ProStringList
modifier|*
name|varlist
parameter_list|,
specifier|const
name|QRegExp
modifier|&
name|regexp
parameter_list|,
specifier|const
name|QString
modifier|&
name|replace
parameter_list|,
name|bool
name|global
parameter_list|,
name|QString
modifier|&
name|tmp
parameter_list|)
block|{
for|for
control|(
name|ProStringList
operator|::
name|Iterator
name|varit
init|=
name|varlist
operator|->
name|begin
argument_list|()
init|;
name|varit
operator|!=
name|varlist
operator|->
name|end
argument_list|()
condition|;
control|)
block|{
name|QString
name|val
init|=
name|varit
operator|->
name|toQString
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
name|QString
name|copy
init|=
name|val
decl_stmt|;
comment|// Force detach and have a reference value
name|val
operator|.
name|replace
argument_list|(
name|regexp
argument_list|,
name|replace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
operator|.
name|isSharedWith
argument_list|(
name|copy
argument_list|)
operator|&&
name|val
operator|!=
name|copy
condition|)
block|{
if|if
condition|(
name|val
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|varit
operator|=
name|varlist
operator|->
name|erase
argument_list|(
name|varit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|varit
operator|)
operator|.
name|setValue
argument_list|(
name|val
argument_list|)
expr_stmt|;
operator|++
name|varit
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|global
condition|)
break|break;
block|}
else|else
block|{
operator|++
name|varit
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|//////// Evaluator /////////
end_comment
begin_function
DECL|function|addStr
specifier|static
name|ALWAYS_INLINE
name|void
name|addStr
parameter_list|(
specifier|const
name|ProString
modifier|&
name|str
parameter_list|,
name|ProStringList
modifier|*
name|ret
parameter_list|,
name|bool
modifier|&
name|pending
parameter_list|,
name|bool
name|joined
parameter_list|)
block|{
if|if
condition|(
name|joined
condition|)
block|{
name|ret
operator|->
name|last
argument_list|()
operator|.
name|append
argument_list|(
name|str
argument_list|,
operator|&
name|pending
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|pending
condition|)
block|{
name|pending
operator|=
literal|true
expr_stmt|;
operator|*
name|ret
operator|<<
name|str
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|->
name|last
argument_list|()
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|addStrList
specifier|static
name|ALWAYS_INLINE
name|void
name|addStrList
parameter_list|(
specifier|const
name|ProStringList
modifier|&
name|list
parameter_list|,
name|ushort
name|tok
parameter_list|,
name|ProStringList
modifier|*
name|ret
parameter_list|,
name|bool
modifier|&
name|pending
parameter_list|,
name|bool
name|joined
parameter_list|)
block|{
if|if
condition|(
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|joined
condition|)
block|{
name|ret
operator|->
name|last
argument_list|()
operator|.
name|append
argument_list|(
name|list
argument_list|,
operator|&
name|pending
argument_list|,
operator|!
operator|(
name|tok
operator|&
name|TokQuoted
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tok
operator|&
name|TokQuoted
condition|)
block|{
if|if
condition|(
operator|!
name|pending
condition|)
block|{
name|pending
operator|=
literal|true
expr_stmt|;
operator|*
name|ret
operator|<<
name|ProString
argument_list|()
expr_stmt|;
block|}
name|ret
operator|->
name|last
argument_list|()
operator|.
name|append
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|pending
condition|)
block|{
comment|// Another qmake bizzarity: if nothing is pending and the
comment|// first element is empty, it will be eaten
if|if
condition|(
operator|!
name|list
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// The common case
name|pending
operator|=
literal|true
expr_stmt|;
operator|*
name|ret
operator|+=
name|list
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|ret
operator|->
name|last
argument_list|()
operator|.
name|append
argument_list|(
name|list
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// This is somewhat slow, but a corner case
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|pending
operator|=
literal|true
expr_stmt|;
operator|*
name|ret
operator|<<
name|list
operator|.
name|at
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|evaluateExpression
name|void
name|QMakeEvaluator
operator|::
name|evaluateExpression
parameter_list|(
specifier|const
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|,
name|ProStringList
modifier|*
name|ret
parameter_list|,
name|bool
name|joined
parameter_list|)
block|{
name|debugMsg
argument_list|(
literal|2
argument_list|,
name|joined
condition|?
literal|"evaluating joined expression"
else|:
literal|"evaluating expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|joined
condition|)
operator|*
name|ret
operator|<<
name|ProString
argument_list|()
expr_stmt|;
name|bool
name|pending
init|=
literal|false
decl_stmt|;
forever|forever
block|{
name|ushort
name|tok
init|=
operator|*
name|tokPtr
operator|++
decl_stmt|;
if|if
condition|(
name|tok
operator|&
name|TokNewStr
condition|)
block|{
name|debugMsg
argument_list|(
literal|2
argument_list|,
literal|"new string"
argument_list|)
expr_stmt|;
name|pending
operator|=
literal|false
expr_stmt|;
block|}
name|ushort
name|maskedTok
init|=
name|tok
operator|&
name|TokMask
decl_stmt|;
switch|switch
condition|(
name|maskedTok
condition|)
block|{
case|case
name|TokLine
case|:
name|m_current
operator|.
name|line
operator|=
operator|*
name|tokPtr
operator|++
expr_stmt|;
break|break;
case|case
name|TokLiteral
case|:
block|{
specifier|const
name|ProString
modifier|&
name|val
init|=
name|getStr
argument_list|(
name|tokPtr
argument_list|)
decl_stmt|;
name|debugMsg
argument_list|(
literal|2
argument_list|,
literal|"literal %s"
argument_list|,
name|dbgStr
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|addStr
argument_list|(
name|val
argument_list|,
name|ret
argument_list|,
name|pending
argument_list|,
name|joined
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TokHashLiteral
case|:
block|{
specifier|const
name|ProKey
modifier|&
name|val
init|=
name|getHashStr
argument_list|(
name|tokPtr
argument_list|)
decl_stmt|;
name|debugMsg
argument_list|(
literal|2
argument_list|,
literal|"hashed literal %s"
argument_list|,
name|dbgStr
argument_list|(
name|val
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|addStr
argument_list|(
name|val
argument_list|,
name|ret
argument_list|,
name|pending
argument_list|,
name|joined
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TokVariable
case|:
block|{
specifier|const
name|ProKey
modifier|&
name|var
init|=
name|getHashStr
argument_list|(
name|tokPtr
argument_list|)
decl_stmt|;
specifier|const
name|ProStringList
modifier|&
name|val
init|=
name|values
argument_list|(
name|map
argument_list|(
name|var
argument_list|)
argument_list|)
decl_stmt|;
name|debugMsg
argument_list|(
literal|2
argument_list|,
literal|"variable %s => %s"
argument_list|,
name|dbgKey
argument_list|(
name|var
argument_list|)
argument_list|,
name|dbgStrList
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|addStrList
argument_list|(
name|val
argument_list|,
name|tok
argument_list|,
name|ret
argument_list|,
name|pending
argument_list|,
name|joined
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TokProperty
case|:
block|{
specifier|const
name|ProKey
modifier|&
name|var
init|=
name|getHashStr
argument_list|(
name|tokPtr
argument_list|)
decl_stmt|;
specifier|const
name|ProString
modifier|&
name|val
init|=
name|propertyValue
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|debugMsg
argument_list|(
literal|2
argument_list|,
literal|"property %s => %s"
argument_list|,
name|dbgKey
argument_list|(
name|var
argument_list|)
argument_list|,
name|dbgStr
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|addStr
argument_list|(
name|val
argument_list|,
name|ret
argument_list|,
name|pending
argument_list|,
name|joined
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TokEnvVar
case|:
block|{
specifier|const
name|ProString
modifier|&
name|var
init|=
name|getStr
argument_list|(
name|tokPtr
argument_list|)
decl_stmt|;
specifier|const
name|ProString
modifier|&
name|val
init|=
name|ProString
argument_list|(
name|m_option
operator|->
name|getEnv
argument_list|(
name|var
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|debugMsg
argument_list|(
literal|2
argument_list|,
literal|"env var %s => %s"
argument_list|,
name|dbgStr
argument_list|(
name|var
argument_list|)
argument_list|,
name|dbgStr
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|addStr
argument_list|(
name|val
argument_list|,
name|ret
argument_list|,
name|pending
argument_list|,
name|joined
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TokFuncName
case|:
block|{
specifier|const
name|ProKey
modifier|&
name|func
init|=
name|getHashStr
argument_list|(
name|tokPtr
argument_list|)
decl_stmt|;
name|debugMsg
argument_list|(
literal|2
argument_list|,
literal|"function %s"
argument_list|,
name|dbgKey
argument_list|(
name|func
argument_list|)
argument_list|)
expr_stmt|;
name|addStrList
argument_list|(
name|evaluateExpandFunction
argument_list|(
name|func
argument_list|,
name|tokPtr
argument_list|)
argument_list|,
name|tok
argument_list|,
name|ret
argument_list|,
name|pending
argument_list|,
name|joined
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|debugMsg
argument_list|(
literal|2
argument_list|,
literal|"evaluated expression => %s"
argument_list|,
name|dbgStrList
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|tokPtr
operator|--
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_function
DECL|function|skipExpression
name|void
name|QMakeEvaluator
operator|::
name|skipExpression
parameter_list|(
specifier|const
name|ushort
modifier|*
modifier|&
name|pTokPtr
parameter_list|)
block|{
specifier|const
name|ushort
modifier|*
name|tokPtr
init|=
name|pTokPtr
decl_stmt|;
forever|forever
block|{
name|ushort
name|tok
init|=
operator|*
name|tokPtr
operator|++
decl_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|TokLine
case|:
name|m_current
operator|.
name|line
operator|=
operator|*
name|tokPtr
operator|++
expr_stmt|;
break|break;
case|case
name|TokValueTerminator
case|:
case|case
name|TokFuncTerminator
case|:
name|pTokPtr
operator|=
name|tokPtr
expr_stmt|;
return|return;
case|case
name|TokArgSeparator
case|:
break|break;
default|default:
switch|switch
condition|(
name|tok
operator|&
name|TokMask
condition|)
block|{
case|case
name|TokLiteral
case|:
case|case
name|TokEnvVar
case|:
name|skipStr
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TokHashLiteral
case|:
case|case
name|TokVariable
case|:
case|case
name|TokProperty
case|:
name|skipHashStr
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TokFuncName
case|:
name|skipHashStr
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|pTokPtr
operator|=
name|tokPtr
expr_stmt|;
name|skipExpression
argument_list|(
name|pTokPtr
argument_list|)
expr_stmt|;
name|tokPtr
operator|=
name|pTokPtr
expr_stmt|;
break|break;
default|default:
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"skipExpression"
argument_list|,
literal|"Unrecognized token"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|visitProBlock
name|QMakeEvaluator
operator|::
name|VisitReturn
name|QMakeEvaluator
operator|::
name|visitProBlock
parameter_list|(
name|ProFile
modifier|*
name|pro
parameter_list|,
specifier|const
name|ushort
modifier|*
name|tokPtr
parameter_list|)
block|{
name|m_current
operator|.
name|pro
operator|=
name|pro
expr_stmt|;
name|m_current
operator|.
name|line
operator|=
literal|0
expr_stmt|;
return|return
name|visitProBlock
argument_list|(
name|tokPtr
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|visitProBlock
name|QMakeEvaluator
operator|::
name|VisitReturn
name|QMakeEvaluator
operator|::
name|visitProBlock
parameter_list|(
specifier|const
name|ushort
modifier|*
name|tokPtr
parameter_list|)
block|{
name|traceMsg
argument_list|(
literal|"entering block"
argument_list|)
expr_stmt|;
name|ProStringList
name|curr
decl_stmt|;
name|bool
name|okey
init|=
literal|true
decl_stmt|,
name|or_op
init|=
literal|false
decl_stmt|,
name|invert
init|=
literal|false
decl_stmt|;
name|uint
name|blockLen
decl_stmt|;
while|while
condition|(
name|ushort
name|tok
init|=
operator|*
name|tokPtr
operator|++
condition|)
block|{
name|VisitReturn
name|ret
decl_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|TokLine
case|:
name|m_current
operator|.
name|line
operator|=
operator|*
name|tokPtr
operator|++
expr_stmt|;
continue|continue;
case|case
name|TokAssign
case|:
case|case
name|TokAppend
case|:
case|case
name|TokAppendUnique
case|:
case|case
name|TokRemove
case|:
case|case
name|TokReplace
case|:
name|visitProVariable
argument_list|(
name|tok
argument_list|,
name|curr
argument_list|,
name|tokPtr
argument_list|)
expr_stmt|;
name|curr
operator|.
name|clear
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|TokBranch
case|:
name|blockLen
operator|=
name|getBlockLen
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_cumulative
condition|)
block|{
ifdef|#
directive|ifdef
name|PROEVALUATOR_CUMULATIVE
if|if
condition|(
operator|!
name|okey
condition|)
name|m_skipLevel
operator|++
expr_stmt|;
name|ret
operator|=
name|blockLen
condition|?
name|visitProBlock
argument_list|(
name|tokPtr
argument_list|)
else|:
name|ReturnTrue
expr_stmt|;
name|tokPtr
operator|+=
name|blockLen
expr_stmt|;
name|blockLen
operator|=
name|getBlockLen
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|okey
condition|)
name|m_skipLevel
operator|--
expr_stmt|;
else|else
name|m_skipLevel
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|==
name|ReturnTrue
operator|||
name|ret
operator|==
name|ReturnFalse
operator|)
operator|&&
name|blockLen
condition|)
name|ret
operator|=
name|visitProBlock
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|okey
condition|)
name|m_skipLevel
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|okey
condition|)
block|{
name|traceMsg
argument_list|(
literal|"taking 'then' branch"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|blockLen
condition|?
name|visitProBlock
argument_list|(
name|tokPtr
argument_list|)
else|:
name|ReturnTrue
expr_stmt|;
name|traceMsg
argument_list|(
literal|"finished 'then' branch"
argument_list|)
expr_stmt|;
block|}
name|tokPtr
operator|+=
name|blockLen
expr_stmt|;
name|blockLen
operator|=
name|getBlockLen
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|okey
condition|)
block|{
name|traceMsg
argument_list|(
literal|"taking 'else' branch"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|blockLen
condition|?
name|visitProBlock
argument_list|(
name|tokPtr
argument_list|)
else|:
name|ReturnTrue
expr_stmt|;
name|traceMsg
argument_list|(
literal|"finished 'else' branch"
argument_list|)
expr_stmt|;
block|}
block|}
name|tokPtr
operator|+=
name|blockLen
expr_stmt|;
name|okey
operator|=
literal|true
operator|,
name|or_op
operator|=
literal|false
expr_stmt|;
comment|// force next evaluation
break|break;
case|case
name|TokForLoop
case|:
if|if
condition|(
name|m_cumulative
condition|)
block|{
comment|// This is a no-win situation, so just pretend it's no loop
name|skipHashStr
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|uint
name|exprLen
init|=
name|getBlockLen
argument_list|(
name|tokPtr
argument_list|)
decl_stmt|;
name|tokPtr
operator|+=
name|exprLen
expr_stmt|;
name|blockLen
operator|=
name|getBlockLen
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|visitProBlock
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|okey
operator|!=
name|or_op
condition|)
block|{
specifier|const
name|ProKey
modifier|&
name|variable
init|=
name|getHashStr
argument_list|(
name|tokPtr
argument_list|)
decl_stmt|;
name|uint
name|exprLen
init|=
name|getBlockLen
argument_list|(
name|tokPtr
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|exprPtr
init|=
name|tokPtr
decl_stmt|;
name|tokPtr
operator|+=
name|exprLen
expr_stmt|;
name|blockLen
operator|=
name|getBlockLen
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|visitProLoop
argument_list|(
name|variable
argument_list|,
name|exprPtr
argument_list|,
name|tokPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|skipHashStr
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|uint
name|exprLen
init|=
name|getBlockLen
argument_list|(
name|tokPtr
argument_list|)
decl_stmt|;
name|tokPtr
operator|+=
name|exprLen
expr_stmt|;
name|blockLen
operator|=
name|getBlockLen
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|traceMsg
argument_list|(
literal|"skipped loop"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ReturnTrue
expr_stmt|;
block|}
name|tokPtr
operator|+=
name|blockLen
expr_stmt|;
name|okey
operator|=
literal|true
operator|,
name|or_op
operator|=
literal|false
expr_stmt|;
comment|// force next evaluation
break|break;
case|case
name|TokTestDef
case|:
case|case
name|TokReplaceDef
case|:
if|if
condition|(
name|m_cumulative
operator|||
name|okey
operator|!=
name|or_op
condition|)
block|{
specifier|const
name|ProKey
modifier|&
name|name
init|=
name|getHashStr
argument_list|(
name|tokPtr
argument_list|)
decl_stmt|;
name|blockLen
operator|=
name|getBlockLen
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|visitProFunctionDef
argument_list|(
name|tok
argument_list|,
name|name
argument_list|,
name|tokPtr
argument_list|)
expr_stmt|;
name|traceMsg
argument_list|(
literal|"defined %s function %s"
argument_list|,
name|tok
operator|==
name|TokTestDef
condition|?
literal|"test"
else|:
literal|"replace"
argument_list|,
name|dbgKey
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|traceMsg
argument_list|(
literal|"skipped function definition"
argument_list|)
expr_stmt|;
name|skipHashStr
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|blockLen
operator|=
name|getBlockLen
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
block|}
name|tokPtr
operator|+=
name|blockLen
expr_stmt|;
name|okey
operator|=
literal|true
operator|,
name|or_op
operator|=
literal|false
expr_stmt|;
comment|// force next evaluation
continue|continue;
case|case
name|TokNot
case|:
name|traceMsg
argument_list|(
literal|"NOT"
argument_list|)
expr_stmt|;
name|invert
operator|^=
literal|true
expr_stmt|;
continue|continue;
case|case
name|TokAnd
case|:
name|traceMsg
argument_list|(
literal|"AND"
argument_list|)
expr_stmt|;
name|or_op
operator|=
literal|false
expr_stmt|;
continue|continue;
case|case
name|TokOr
case|:
name|traceMsg
argument_list|(
literal|"OR"
argument_list|)
expr_stmt|;
name|or_op
operator|=
literal|true
expr_stmt|;
continue|continue;
case|case
name|TokCondition
case|:
if|if
condition|(
operator|!
name|m_skipLevel
operator|&&
name|okey
operator|!=
name|or_op
condition|)
block|{
if|if
condition|(
name|curr
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|m_cumulative
operator|||
operator|!
name|curr
operator|.
name|isEmpty
argument_list|()
condition|)
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Conditional must expand to exactly one word."
argument_list|)
argument_list|)
expr_stmt|;
name|okey
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|okey
operator|=
name|isActiveConfig
argument_list|(
name|curr
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp2
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|traceMsg
argument_list|(
literal|"condition %s is %s"
argument_list|,
name|dbgStr
argument_list|(
name|curr
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|dbgBool
argument_list|(
name|okey
argument_list|)
argument_list|)
expr_stmt|;
name|okey
operator|^=
name|invert
expr_stmt|;
block|}
block|}
else|else
block|{
name|traceMsg
argument_list|(
literal|"skipped condition %s"
argument_list|,
name|curr
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|?
name|dbgStr
argument_list|(
name|curr
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
else|:
literal|"<invalid>"
argument_list|)
expr_stmt|;
block|}
name|or_op
operator|=
operator|!
name|okey
expr_stmt|;
comment|// tentatively force next evaluation
name|invert
operator|=
literal|false
expr_stmt|;
name|curr
operator|.
name|clear
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|TokTestCall
case|:
if|if
condition|(
operator|!
name|m_skipLevel
operator|&&
name|okey
operator|!=
name|or_op
condition|)
block|{
if|if
condition|(
name|curr
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|m_cumulative
operator|||
operator|!
name|curr
operator|.
name|isEmpty
argument_list|()
condition|)
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Test name must expand to exactly one word."
argument_list|)
argument_list|)
expr_stmt|;
name|skipExpression
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|okey
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|traceMsg
argument_list|(
literal|"evaluating test function %s"
argument_list|,
name|dbgStr
argument_list|(
name|curr
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|evaluateConditionalFunction
argument_list|(
name|curr
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toKey
argument_list|()
argument_list|,
name|tokPtr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|ReturnTrue
case|:
name|okey
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|ReturnFalse
case|:
name|okey
operator|=
literal|false
expr_stmt|;
break|break;
default|default:
name|traceMsg
argument_list|(
literal|"aborting block, function status: %s"
argument_list|,
name|dbgReturn
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|traceMsg
argument_list|(
literal|"test function returned %s"
argument_list|,
name|dbgBool
argument_list|(
name|okey
argument_list|)
argument_list|)
expr_stmt|;
name|okey
operator|^=
name|invert
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|m_cumulative
condition|)
block|{
ifdef|#
directive|ifdef
name|PROEVALUATOR_CUMULATIVE
name|m_skipLevel
operator|++
expr_stmt|;
if|if
condition|(
name|curr
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
name|skipExpression
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
else|else
name|evaluateConditionalFunction
argument_list|(
name|curr
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toKey
argument_list|()
argument_list|,
name|tokPtr
argument_list|)
expr_stmt|;
name|m_skipLevel
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|skipExpression
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|traceMsg
argument_list|(
literal|"skipped test function %s"
argument_list|,
name|curr
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|?
name|dbgStr
argument_list|(
name|curr
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
else|:
literal|"<invalid>"
argument_list|)
expr_stmt|;
block|}
name|or_op
operator|=
operator|!
name|okey
expr_stmt|;
comment|// tentatively force next evaluation
name|invert
operator|=
literal|false
expr_stmt|;
name|curr
operator|.
name|clear
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|TokReturn
case|:
name|m_returnValue
operator|=
name|curr
expr_stmt|;
name|curr
operator|.
name|clear
argument_list|()
expr_stmt|;
name|ret
operator|=
name|ReturnReturn
expr_stmt|;
goto|goto
name|ctrlstm
goto|;
case|case
name|TokBreak
case|:
name|ret
operator|=
name|ReturnBreak
expr_stmt|;
goto|goto
name|ctrlstm
goto|;
case|case
name|TokNext
case|:
name|ret
operator|=
name|ReturnNext
expr_stmt|;
name|ctrlstm
label|:
if|if
condition|(
operator|!
name|m_skipLevel
operator|&&
name|okey
operator|!=
name|or_op
condition|)
block|{
name|traceMsg
argument_list|(
literal|"flow control statement '%s', aborting block"
argument_list|,
name|dbgReturn
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|traceMsg
argument_list|(
literal|"skipped flow control statement '%s'"
argument_list|,
name|dbgReturn
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|okey
operator|=
literal|false
operator|,
name|or_op
operator|=
literal|true
expr_stmt|;
comment|// force next evaluation
continue|continue;
default|default:
block|{
specifier|const
name|ushort
modifier|*
name|oTokPtr
init|=
operator|--
name|tokPtr
decl_stmt|;
name|evaluateExpression
argument_list|(
name|tokPtr
argument_list|,
operator|&
name|curr
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokPtr
operator|!=
name|oTokPtr
condition|)
continue|continue;
block|}
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"visitProBlock"
argument_list|,
literal|"unexpected item type"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ret
operator|!=
name|ReturnTrue
operator|&&
name|ret
operator|!=
name|ReturnFalse
condition|)
block|{
name|traceMsg
argument_list|(
literal|"aborting block, status: %s"
argument_list|,
name|dbgReturn
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|traceMsg
argument_list|(
literal|"leaving block, okey=%s"
argument_list|,
name|dbgBool
argument_list|(
name|okey
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|returnBool
argument_list|(
name|okey
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|visitProFunctionDef
name|void
name|QMakeEvaluator
operator|::
name|visitProFunctionDef
parameter_list|(
name|ushort
name|tok
parameter_list|,
specifier|const
name|ProKey
modifier|&
name|name
parameter_list|,
specifier|const
name|ushort
modifier|*
name|tokPtr
parameter_list|)
block|{
name|QHash
argument_list|<
name|ProKey
argument_list|,
name|ProFunctionDef
argument_list|>
modifier|*
name|hash
init|=
operator|(
name|tok
operator|==
name|TokTestDef
condition|?
operator|&
name|m_functionDefs
operator|.
name|testFunctions
else|:
operator|&
name|m_functionDefs
operator|.
name|replaceFunctions
operator|)
decl_stmt|;
name|hash
operator|->
name|insert
argument_list|(
name|name
argument_list|,
name|ProFunctionDef
argument_list|(
name|m_current
operator|.
name|pro
argument_list|,
name|tokPtr
operator|-
name|m_current
operator|.
name|pro
operator|->
name|tokPtr
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|visitProLoop
name|QMakeEvaluator
operator|::
name|VisitReturn
name|QMakeEvaluator
operator|::
name|visitProLoop
parameter_list|(
specifier|const
name|ProKey
modifier|&
name|_variable
parameter_list|,
specifier|const
name|ushort
modifier|*
name|exprPtr
parameter_list|,
specifier|const
name|ushort
modifier|*
name|tokPtr
parameter_list|)
block|{
name|VisitReturn
name|ret
init|=
name|ReturnTrue
decl_stmt|;
name|bool
name|infinite
init|=
literal|false
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|ProKey
name|variable
decl_stmt|;
name|ProStringList
name|oldVarVal
decl_stmt|;
name|ProString
name|it_list
init|=
name|expandVariableReferences
argument_list|(
name|exprPtr
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|_variable
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|it_list
operator|!=
name|statics
operator|.
name|strever
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Invalid loop expression."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|it_list
operator|=
name|ProString
argument_list|(
name|statics
operator|.
name|strforever
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|variable
operator|=
name|map
argument_list|(
name|_variable
argument_list|)
expr_stmt|;
name|oldVarVal
operator|=
name|values
argument_list|(
name|variable
argument_list|)
expr_stmt|;
block|}
name|ProStringList
name|list
init|=
name|values
argument_list|(
name|it_list
operator|.
name|toKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|it_list
operator|==
name|statics
operator|.
name|strforever
condition|)
block|{
name|infinite
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QString
modifier|&
name|itl
init|=
name|it_list
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
name|int
name|dotdot
init|=
name|itl
operator|.
name|indexOf
argument_list|(
name|statics
operator|.
name|strDotDot
argument_list|)
decl_stmt|;
if|if
condition|(
name|dotdot
operator|!=
operator|-
literal|1
condition|)
block|{
name|bool
name|ok
decl_stmt|;
name|int
name|start
init|=
name|itl
operator|.
name|left
argument_list|(
name|dotdot
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|int
name|end
init|=
name|itl
operator|.
name|mid
argument_list|(
name|dotdot
operator|+
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|start
operator|<
name|end
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
control|)
name|list
operator|<<
name|ProString
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|>=
name|end
condition|;
name|i
operator|--
control|)
name|list
operator|<<
name|ProString
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|infinite
condition|)
name|traceMsg
argument_list|(
literal|"entering infinite loop for %s"
argument_list|,
name|dbgKey
argument_list|(
name|variable
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|traceMsg
argument_list|(
literal|"entering loop for %s over %s"
argument_list|,
name|dbgKey
argument_list|(
name|variable
argument_list|)
argument_list|,
name|dbgStrList
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
forever|forever
block|{
if|if
condition|(
name|infinite
condition|)
block|{
if|if
condition|(
operator|!
name|variable
operator|.
name|isEmpty
argument_list|()
condition|)
name|m_valuemapStack
operator|.
name|top
argument_list|()
index|[
name|variable
index|]
operator|=
name|ProStringList
argument_list|(
name|ProString
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|index
operator|>
literal|1000
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Ran into infinite loop (> 1000 iterations)."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|traceMsg
argument_list|(
literal|"loop iteration %d"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ProString
name|val
decl_stmt|;
do|do
block|{
if|if
condition|(
name|index
operator|>=
name|list
operator|.
name|count
argument_list|()
condition|)
goto|goto
name|do_break
goto|;
name|val
operator|=
name|list
operator|.
name|at
argument_list|(
name|index
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|val
operator|.
name|isEmpty
argument_list|()
condition|)
do|;
comment|// stupid, but qmake is like that
name|traceMsg
argument_list|(
literal|"loop iteration %s"
argument_list|,
name|dbgStr
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|m_valuemapStack
operator|.
name|top
argument_list|()
index|[
name|variable
index|]
operator|=
name|ProStringList
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|visitProBlock
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|ReturnTrue
case|:
case|case
name|ReturnFalse
case|:
break|break;
case|case
name|ReturnNext
case|:
name|ret
operator|=
name|ReturnTrue
expr_stmt|;
break|break;
case|case
name|ReturnBreak
case|:
name|ret
operator|=
name|ReturnTrue
expr_stmt|;
goto|goto
name|do_break
goto|;
default|default:
goto|goto
name|do_break
goto|;
block|}
block|}
name|do_break
label|:
name|traceMsg
argument_list|(
literal|"done looping"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|variable
operator|.
name|isEmpty
argument_list|()
condition|)
name|m_valuemapStack
operator|.
name|top
argument_list|()
index|[
name|variable
index|]
operator|=
name|oldVarVal
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|visitProVariable
name|void
name|QMakeEvaluator
operator|::
name|visitProVariable
parameter_list|(
name|ushort
name|tok
parameter_list|,
specifier|const
name|ProStringList
modifier|&
name|curr
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
name|int
name|sizeHint
init|=
operator|*
name|tokPtr
operator|++
decl_stmt|;
if|if
condition|(
name|curr
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|skipExpression
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_cumulative
operator|||
operator|!
name|curr
operator|.
name|isEmpty
argument_list|()
condition|)
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Left hand side of assignment must expand to exactly one word."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|ProKey
modifier|&
name|varName
init|=
name|map
argument_list|(
name|curr
operator|.
name|first
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|tok
operator|==
name|TokReplace
condition|)
block|{
comment|// ~=
comment|// DEFINES ~= s/a/b/?[gqi]
specifier|const
name|ProStringList
modifier|&
name|varVal
init|=
name|expandVariableReferences
argument_list|(
name|tokPtr
argument_list|,
name|sizeHint
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|const
name|QString
modifier|&
name|val
init|=
name|varVal
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|.
name|length
argument_list|()
operator|<
literal|4
operator|||
name|val
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'s'
argument_list|)
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"The ~= operator can handle only the s/// function."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|QChar
name|sep
init|=
name|val
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|QStringList
name|func
init|=
name|val
operator|.
name|split
argument_list|(
name|sep
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|.
name|count
argument_list|()
operator|<
literal|3
operator|||
name|func
operator|.
name|count
argument_list|()
operator|>
literal|4
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"The s/// function expects 3 or 4 arguments."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|bool
name|global
init|=
literal|false
decl_stmt|,
name|quote
init|=
literal|false
decl_stmt|,
name|case_sense
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|func
operator|.
name|count
argument_list|()
operator|==
literal|4
condition|)
block|{
name|global
operator|=
name|func
index|[
literal|3
index|]
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'g'
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
expr_stmt|;
name|case_sense
operator|=
name|func
index|[
literal|3
index|]
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'i'
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
expr_stmt|;
name|quote
operator|=
name|func
index|[
literal|3
index|]
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'q'
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
expr_stmt|;
block|}
name|QString
name|pattern
init|=
name|func
index|[
literal|1
index|]
decl_stmt|;
name|QString
name|replace
init|=
name|func
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|quote
condition|)
name|pattern
operator|=
name|QRegExp
operator|::
name|escape
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|QRegExp
name|regexp
argument_list|(
name|pattern
argument_list|,
name|case_sense
condition|?
name|Qt
operator|::
name|CaseSensitive
else|:
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
decl_stmt|;
comment|// We could make a union of modified and unmodified values,
comment|// but this will break just as much as it fixes, so leave it as is.
name|replaceInList
argument_list|(
operator|&
name|valuesRef
argument_list|(
name|varName
argument_list|)
argument_list|,
name|regexp
argument_list|,
name|replace
argument_list|,
name|global
argument_list|,
name|m_tmp2
argument_list|)
expr_stmt|;
name|debugMsg
argument_list|(
literal|2
argument_list|,
literal|"replaced %s with %s"
argument_list|,
name|dbgQStr
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|dbgQStr
argument_list|(
name|replace
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ProStringList
name|varVal
init|=
name|expandVariableReferences
argument_list|(
name|tokPtr
argument_list|,
name|sizeHint
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
default|default:
comment|// whatever - cannot happen
case|case
name|TokAssign
case|:
comment|// =
name|varVal
operator|.
name|removeEmpty
argument_list|()
expr_stmt|;
comment|// FIXME: add check+warning about accidental value removal.
comment|// This may be a bit too noisy, though.
name|m_valuemapStack
operator|.
name|top
argument_list|()
index|[
name|varName
index|]
operator|=
name|varVal
expr_stmt|;
name|debugMsg
argument_list|(
literal|2
argument_list|,
literal|"assigning"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TokAppendUnique
case|:
comment|// *=
name|valuesRef
argument_list|(
name|varName
argument_list|)
operator|.
name|insertUnique
argument_list|(
name|varVal
argument_list|)
expr_stmt|;
name|debugMsg
argument_list|(
literal|2
argument_list|,
literal|"appending unique"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TokAppend
case|:
comment|// +=
name|varVal
operator|.
name|removeEmpty
argument_list|()
expr_stmt|;
name|valuesRef
argument_list|(
name|varName
argument_list|)
operator|+=
name|varVal
expr_stmt|;
name|debugMsg
argument_list|(
literal|2
argument_list|,
literal|"appending"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TokRemove
case|:
comment|// -=
if|if
condition|(
operator|!
name|m_cumulative
condition|)
block|{
name|valuesRef
argument_list|(
name|varName
argument_list|)
operator|.
name|removeEach
argument_list|(
name|varVal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We are stingy with our values.
block|}
name|debugMsg
argument_list|(
literal|2
argument_list|,
literal|"removing"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|traceMsg
argument_list|(
literal|"%s := %s"
argument_list|,
name|dbgKey
argument_list|(
name|varName
argument_list|)
argument_list|,
name|dbgStrList
argument_list|(
name|values
argument_list|(
name|varName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|varName
operator|==
name|statics
operator|.
name|strTEMPLATE
condition|)
name|setTemplate
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|varName
operator|==
name|statics
operator|.
name|strQMAKE_PLATFORM
condition|)
name|m_featureRoots
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|varName
operator|==
name|statics
operator|.
name|strQMAKESPEC
condition|)
block|{
if|if
condition|(
operator|!
name|values
argument_list|(
name|varName
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|m_qmakespec
operator|=
name|values
argument_list|(
name|varName
argument_list|)
operator|.
name|first
argument_list|()
operator|.
name|toQString
argument_list|()
expr_stmt|;
name|m_featureRoots
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PROEVALUATOR_FULL
elseif|else
if|if
condition|(
name|varName
operator|==
name|statics
operator|.
name|strREQUIRES
condition|)
name|checkRequirements
argument_list|(
name|values
argument_list|(
name|varName
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|setTemplate
name|void
name|QMakeEvaluator
operator|::
name|setTemplate
parameter_list|()
block|{
name|ProStringList
modifier|&
name|values
init|=
name|valuesRef
argument_list|(
name|statics
operator|.
name|strTEMPLATE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m_option
operator|->
name|user_template
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Don't allow override
name|values
operator|=
name|ProStringList
argument_list|(
name|ProString
argument_list|(
name|m_option
operator|->
name|user_template
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
name|values
operator|.
name|append
argument_list|(
name|ProString
argument_list|(
literal|"app"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|values
operator|.
name|erase
argument_list|(
name|values
operator|.
name|begin
argument_list|()
operator|+
literal|1
argument_list|,
name|values
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|m_option
operator|->
name|user_template_prefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|val
init|=
name|values
operator|.
name|first
argument_list|()
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|val
operator|.
name|startsWith
argument_list|(
name|m_option
operator|->
name|user_template_prefix
argument_list|)
condition|)
block|{
name|val
operator|.
name|prepend
argument_list|(
name|m_option
operator|->
name|user_template_prefix
argument_list|)
expr_stmt|;
name|values
operator|=
name|ProStringList
argument_list|(
name|ProString
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
end_if
begin_function
DECL|function|msvcBinDirToQMakeArch
specifier|static
name|ProString
name|msvcBinDirToQMakeArch
parameter_list|(
name|QString
name|subdir
parameter_list|)
block|{
name|int
name|idx
init|=
name|subdir
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
return|return
name|ProString
argument_list|(
literal|"x86"
argument_list|)
return|;
name|subdir
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|idx
operator|=
name|subdir
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
name|subdir
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|subdir
operator|=
name|subdir
operator|.
name|toLower
argument_list|()
expr_stmt|;
if|if
condition|(
name|subdir
operator|==
name|QStringLiteral
argument_list|(
literal|"amd64"
argument_list|)
condition|)
return|return
name|ProString
argument_list|(
literal|"x86_64"
argument_list|)
return|;
return|return
name|ProString
argument_list|(
name|subdir
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|defaultMsvcArchitecture
specifier|static
name|ProString
name|defaultMsvcArchitecture
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN64
argument_list|)
return|return
name|ProString
argument_list|(
literal|"x86_64"
argument_list|)
return|;
else|#
directive|else
return|return
name|ProString
argument_list|(
literal|"x86"
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|msvcArchitecture
specifier|static
name|ProString
name|msvcArchitecture
parameter_list|(
specifier|const
name|QString
modifier|&
name|vcInstallDir
parameter_list|,
specifier|const
name|QString
modifier|&
name|pathVar
parameter_list|)
block|{
if|if
condition|(
name|vcInstallDir
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|defaultMsvcArchitecture
argument_list|()
return|;
name|QString
name|vcBinDir
init|=
name|vcInstallDir
decl_stmt|;
if|if
condition|(
name|vcBinDir
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
condition|)
name|vcBinDir
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|dir
decl|,
name|pathVar
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|dir
operator|.
name|startsWith
argument_list|(
name|vcBinDir
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
continue|continue;
specifier|const
name|ProString
name|arch
init|=
name|msvcBinDirToQMakeArch
argument_list|(
name|dir
operator|.
name|mid
argument_list|(
name|vcBinDir
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|arch
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|arch
return|;
block|}
return|return
name|defaultMsvcArchitecture
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// defined(Q_CC_MSVC)
end_comment
begin_function
DECL|function|loadDefaults
name|void
name|QMakeEvaluator
operator|::
name|loadDefaults
parameter_list|()
block|{
name|ProValueMap
modifier|&
name|vars
init|=
name|m_valuemapStack
operator|.
name|top
argument_list|()
decl_stmt|;
name|vars
index|[
name|ProKey
argument_list|(
literal|"DIR_SEPARATOR"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|m_option
operator|->
name|dir_sep
argument_list|)
expr_stmt|;
name|vars
index|[
name|ProKey
argument_list|(
literal|"DIRLIST_SEPARATOR"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|m_option
operator|->
name|dirlist_sep
argument_list|)
expr_stmt|;
name|vars
index|[
name|ProKey
argument_list|(
literal|"_DATE_"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_option
operator|->
name|qmake_abslocation
operator|.
name|isEmpty
argument_list|()
condition|)
name|vars
index|[
name|ProKey
argument_list|(
literal|"QMAKE_QMAKE"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|m_option
operator|->
name|qmake_abslocation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_option
operator|->
name|qmake_args
operator|.
name|isEmpty
argument_list|()
condition|)
name|vars
index|[
name|ProKey
argument_list|(
literal|"QMAKE_ARGS"
argument_list|)
index|]
operator|=
name|ProStringList
argument_list|(
name|m_option
operator|->
name|qmake_args
argument_list|)
expr_stmt|;
name|vars
index|[
name|ProKey
argument_list|(
literal|"QMAKE_HOST.cpu_count"
argument_list|)
index|]
operator|=
name|ProString
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|idealThreadCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
name|vars
index|[
name|ProKey
argument_list|(
literal|"QMAKE_HOST.os"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
literal|"Windows"
argument_list|)
expr_stmt|;
name|DWORD
name|name_length
init|=
literal|1024
decl_stmt|;
name|wchar_t
name|name
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|GetComputerName
argument_list|(
name|name
argument_list|,
operator|&
name|name_length
argument_list|)
condition|)
name|vars
index|[
name|ProKey
argument_list|(
literal|"QMAKE_HOST.name"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|QSysInfo
operator|::
name|WinVersion
name|ver
init|=
name|QSysInfo
operator|::
name|WindowsVersion
decl_stmt|;
name|vars
index|[
name|ProKey
argument_list|(
literal|"QMAKE_HOST.version"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|ver
argument_list|)
argument_list|)
expr_stmt|;
name|ProString
name|verStr
decl_stmt|;
switch|switch
condition|(
name|ver
condition|)
block|{
case|case
name|QSysInfo
operator|::
name|WV_Me
case|:
name|verStr
operator|=
name|ProString
argument_list|(
literal|"WinMe"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSysInfo
operator|::
name|WV_95
case|:
name|verStr
operator|=
name|ProString
argument_list|(
literal|"Win95"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSysInfo
operator|::
name|WV_98
case|:
name|verStr
operator|=
name|ProString
argument_list|(
literal|"Win98"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSysInfo
operator|::
name|WV_NT
case|:
name|verStr
operator|=
name|ProString
argument_list|(
literal|"WinNT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSysInfo
operator|::
name|WV_2000
case|:
name|verStr
operator|=
name|ProString
argument_list|(
literal|"Win2000"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSysInfo
operator|::
name|WV_2003
case|:
name|verStr
operator|=
name|ProString
argument_list|(
literal|"Win2003"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSysInfo
operator|::
name|WV_XP
case|:
name|verStr
operator|=
name|ProString
argument_list|(
literal|"WinXP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSysInfo
operator|::
name|WV_VISTA
case|:
name|verStr
operator|=
name|ProString
argument_list|(
literal|"WinVista"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|verStr
operator|=
name|ProString
argument_list|(
literal|"Unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
name|vars
index|[
name|ProKey
argument_list|(
literal|"QMAKE_HOST.version_string"
argument_list|)
index|]
operator|<<
name|verStr
expr_stmt|;
name|SYSTEM_INFO
name|info
decl_stmt|;
name|GetSystemInfo
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|ProString
name|archStr
decl_stmt|;
switch|switch
condition|(
name|info
operator|.
name|wProcessorArchitecture
condition|)
block|{
ifdef|#
directive|ifdef
name|PROCESSOR_ARCHITECTURE_AMD64
case|case
name|PROCESSOR_ARCHITECTURE_AMD64
case|:
name|archStr
operator|=
name|ProString
argument_list|(
literal|"x86_64"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|PROCESSOR_ARCHITECTURE_INTEL
case|:
name|archStr
operator|=
name|ProString
argument_list|(
literal|"x86"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROCESSOR_ARCHITECTURE_IA64
case|:
ifdef|#
directive|ifdef
name|PROCESSOR_ARCHITECTURE_IA32_ON_WIN64
case|case
name|PROCESSOR_ARCHITECTURE_IA32_ON_WIN64
case|:
endif|#
directive|endif
name|archStr
operator|=
name|ProString
argument_list|(
literal|"IA64"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|archStr
operator|=
name|ProString
argument_list|(
literal|"Unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
name|vars
index|[
name|ProKey
argument_list|(
literal|"QMAKE_HOST.arch"
argument_list|)
index|]
operator|<<
name|archStr
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
comment|// ### bogus condition, but nobody x-builds for msvc with a different qmake
name|vars
index|[
name|ProKey
argument_list|(
literal|"QMAKE_TARGET.arch"
argument_list|)
index|]
operator|=
name|msvcArchitecture
argument_list|(
name|m_option
operator|->
name|getEnv
argument_list|(
name|QLatin1String
argument_list|(
literal|"VCINSTALLDIR"
argument_list|)
argument_list|)
argument_list|,
name|m_option
operator|->
name|getEnv
argument_list|(
name|QLatin1String
argument_list|(
literal|"PATH"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|struct
name|utsname
name|name
decl_stmt|;
if|if
condition|(
name|uname
argument_list|(
operator|&
name|name
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|vars
index|[
name|ProKey
argument_list|(
literal|"QMAKE_HOST.os"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|name
operator|.
name|sysname
argument_list|)
expr_stmt|;
name|vars
index|[
name|ProKey
argument_list|(
literal|"QMAKE_HOST.name"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|name
operator|.
name|nodename
argument_list|)
argument_list|)
expr_stmt|;
name|vars
index|[
name|ProKey
argument_list|(
literal|"QMAKE_HOST.version"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|name
operator|.
name|release
argument_list|)
expr_stmt|;
name|vars
index|[
name|ProKey
argument_list|(
literal|"QMAKE_HOST.version_string"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|name
operator|.
name|version
argument_list|)
expr_stmt|;
name|vars
index|[
name|ProKey
argument_list|(
literal|"QMAKE_HOST.arch"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|name
operator|.
name|machine
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m_valuemapInited
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepareProject
name|bool
name|QMakeEvaluator
operator|::
name|prepareProject
parameter_list|(
specifier|const
name|QString
modifier|&
name|inDir
parameter_list|)
block|{
name|QString
name|superdir
decl_stmt|;
if|if
condition|(
name|m_option
operator|->
name|do_cache
condition|)
block|{
name|QString
name|conffile
decl_stmt|;
name|QString
name|cachefile
init|=
name|m_option
operator|->
name|cachefile
decl_stmt|;
if|if
condition|(
name|cachefile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//find it as it has not been specified
if|if
condition|(
name|m_outputDir
operator|.
name|isEmpty
argument_list|()
condition|)
goto|goto
name|no_cache
goto|;
name|superdir
operator|=
name|m_outputDir
expr_stmt|;
forever|forever
block|{
name|QString
name|superfile
init|=
name|superdir
operator|+
name|QLatin1String
argument_list|(
literal|"/.qmake.super"
argument_list|)
decl_stmt|;
if|if
condition|(
name|m_vfs
operator|->
name|exists
argument_list|(
name|superfile
argument_list|)
condition|)
block|{
name|m_superfile
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|superfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|QFileInfo
name|qdfi
argument_list|(
name|superdir
argument_list|)
decl_stmt|;
if|if
condition|(
name|qdfi
operator|.
name|isRoot
argument_list|()
condition|)
block|{
name|superdir
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
block|}
name|superdir
operator|=
name|qdfi
operator|.
name|path
argument_list|()
expr_stmt|;
block|}
name|QString
name|sdir
init|=
name|inDir
decl_stmt|;
name|QString
name|dir
init|=
name|m_outputDir
decl_stmt|;
forever|forever
block|{
name|conffile
operator|=
name|sdir
operator|+
name|QLatin1String
argument_list|(
literal|"/.qmake.conf"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_vfs
operator|->
name|exists
argument_list|(
name|conffile
argument_list|)
condition|)
name|conffile
operator|.
name|clear
argument_list|()
expr_stmt|;
name|cachefile
operator|=
name|dir
operator|+
name|QLatin1String
argument_list|(
literal|"/.qmake.cache"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_vfs
operator|->
name|exists
argument_list|(
name|cachefile
argument_list|)
condition|)
name|cachefile
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|conffile
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|cachefile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|dir
operator|!=
name|sdir
condition|)
name|m_sourceRoot
operator|=
name|sdir
expr_stmt|;
name|m_buildRoot
operator|=
name|dir
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dir
operator|==
name|superdir
condition|)
goto|goto
name|no_cache
goto|;
name|QFileInfo
name|qsdfi
argument_list|(
name|sdir
argument_list|)
decl_stmt|;
name|QFileInfo
name|qdfi
argument_list|(
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|qsdfi
operator|.
name|isRoot
argument_list|()
operator|||
name|qdfi
operator|.
name|isRoot
argument_list|()
condition|)
goto|goto
name|no_cache
goto|;
name|sdir
operator|=
name|qsdfi
operator|.
name|path
argument_list|()
expr_stmt|;
name|dir
operator|=
name|qdfi
operator|.
name|path
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|m_buildRoot
operator|=
name|QFileInfo
argument_list|(
name|cachefile
argument_list|)
operator|.
name|path
argument_list|()
expr_stmt|;
block|}
name|m_conffile
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|conffile
argument_list|)
expr_stmt|;
name|m_cachefile
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|cachefile
argument_list|)
expr_stmt|;
block|}
name|no_cache
label|:
name|QString
name|dir
init|=
name|m_outputDir
decl_stmt|;
forever|forever
block|{
name|QString
name|stashfile
init|=
name|dir
operator|+
name|QLatin1String
argument_list|(
literal|"/.qmake.stash"
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|==
operator|(
operator|!
name|superdir
operator|.
name|isEmpty
argument_list|()
condition|?
name|superdir
else|:
name|m_buildRoot
operator|)
operator|||
name|m_vfs
operator|->
name|exists
argument_list|(
name|stashfile
argument_list|)
condition|)
block|{
name|m_stashfile
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|stashfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|QFileInfo
name|qdfi
argument_list|(
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|qdfi
operator|.
name|isRoot
argument_list|()
condition|)
break|break;
name|dir
operator|=
name|qdfi
operator|.
name|path
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|loadSpecInternal
name|bool
name|QMakeEvaluator
operator|::
name|loadSpecInternal
parameter_list|()
block|{
if|if
condition|(
name|evaluateFeatureFile
argument_list|(
name|QLatin1String
argument_list|(
literal|"spec_pre.prf"
argument_list|)
argument_list|)
operator|!=
name|ReturnTrue
condition|)
return|return
literal|false
return|;
name|QString
name|spec
init|=
name|m_qmakespec
operator|+
name|QLatin1String
argument_list|(
literal|"/qmake.conf"
argument_list|)
decl_stmt|;
if|if
condition|(
name|evaluateFile
argument_list|(
name|spec
argument_list|,
name|QMakeHandler
operator|::
name|EvalConfigFile
argument_list|,
name|LoadProOnly
argument_list|)
operator|!=
name|ReturnTrue
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Could not read qmake configuration file %1."
argument_list|)
operator|.
name|arg
argument_list|(
name|spec
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
ifndef|#
directive|ifndef
name|QT_BUILD_QMAKE
comment|// Legacy support for Qt4 default specs
ifdef|#
directive|ifdef
name|Q_OS_UNIX
if|if
condition|(
name|m_qmakespec
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"/default-host"
argument_list|)
argument_list|)
operator|||
name|m_qmakespec
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"/default"
argument_list|)
argument_list|)
condition|)
block|{
name|QString
name|rspec
init|=
name|QFileInfo
argument_list|(
name|m_qmakespec
argument_list|)
operator|.
name|readLink
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|rspec
operator|.
name|isEmpty
argument_list|()
condition|)
name|m_qmakespec
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|QDir
argument_list|(
name|m_qmakespec
argument_list|)
operator|.
name|absoluteFilePath
argument_list|(
name|rspec
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|// We can't resolve symlinks as they do on Unix, so configure.exe puts
comment|// the source of the qmake.conf at the end of the default/qmake.conf in
comment|// the QMAKESPEC_ORIGINAL variable.
specifier|const
name|ProString
modifier|&
name|orig_spec
init|=
name|first
argument_list|(
name|ProKey
argument_list|(
literal|"QMAKESPEC_ORIGINAL"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|orig_spec
operator|.
name|isEmpty
argument_list|()
condition|)
name|m_qmakespec
operator|=
name|orig_spec
operator|.
name|toQString
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|valuesRef
argument_list|(
name|ProKey
argument_list|(
literal|"QMAKESPEC"
argument_list|)
argument_list|)
operator|=
name|ProString
argument_list|(
name|m_qmakespec
argument_list|)
expr_stmt|;
name|m_qmakespecName
operator|=
name|IoUtils
operator|::
name|fileName
argument_list|(
name|m_qmakespec
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
comment|// This also ensures that m_featureRoots is valid.
if|if
condition|(
name|evaluateFeatureFile
argument_list|(
name|QLatin1String
argument_list|(
literal|"spec_post.prf"
argument_list|)
argument_list|)
operator|!=
name|ReturnTrue
condition|)
return|return
literal|false
return|;
comment|// The MinGW and x-build specs may change the separator; $$shell_{path,quote}() need it
name|m_dirSep
operator|=
name|first
argument_list|(
name|ProKey
argument_list|(
literal|"QMAKE_DIR_SEP"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|loadSpec
name|bool
name|QMakeEvaluator
operator|::
name|loadSpec
parameter_list|()
block|{
name|QString
name|qmakespec
init|=
name|m_option
operator|->
name|expandEnvVars
argument_list|(
name|m_hostBuild
condition|?
name|m_option
operator|->
name|qmakespec
else|:
name|m_option
operator|->
name|xqmakespec
argument_list|)
decl_stmt|;
block|{
name|QMakeEvaluator
name|evaluator
argument_list|(
name|m_option
argument_list|,
name|m_parser
argument_list|,
name|m_vfs
argument_list|,
name|m_handler
argument_list|)
decl_stmt|;
name|evaluator
operator|.
name|m_sourceRoot
operator|=
name|m_sourceRoot
expr_stmt|;
name|evaluator
operator|.
name|m_buildRoot
operator|=
name|m_buildRoot
expr_stmt|;
if|if
condition|(
operator|!
name|m_superfile
operator|.
name|isEmpty
argument_list|()
operator|&&
name|evaluator
operator|.
name|evaluateFile
argument_list|(
name|m_superfile
argument_list|,
name|QMakeHandler
operator|::
name|EvalConfigFile
argument_list|,
name|LoadProOnly
operator||
name|LoadHidden
argument_list|)
operator|!=
name|ReturnTrue
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|m_conffile
operator|.
name|isEmpty
argument_list|()
operator|&&
name|evaluator
operator|.
name|evaluateFile
argument_list|(
name|m_conffile
argument_list|,
name|QMakeHandler
operator|::
name|EvalConfigFile
argument_list|,
name|LoadProOnly
operator||
name|LoadHidden
argument_list|)
operator|!=
name|ReturnTrue
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|m_cachefile
operator|.
name|isEmpty
argument_list|()
operator|&&
name|evaluator
operator|.
name|evaluateFile
argument_list|(
name|m_cachefile
argument_list|,
name|QMakeHandler
operator|::
name|EvalConfigFile
argument_list|,
name|LoadProOnly
operator||
name|LoadHidden
argument_list|)
operator|!=
name|ReturnTrue
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|qmakespec
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|m_hostBuild
condition|)
name|qmakespec
operator|=
name|evaluator
operator|.
name|first
argument_list|(
name|ProKey
argument_list|(
literal|"XQMAKESPEC"
argument_list|)
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
if|if
condition|(
name|qmakespec
operator|.
name|isEmpty
argument_list|()
condition|)
name|qmakespec
operator|=
name|evaluator
operator|.
name|first
argument_list|(
name|ProKey
argument_list|(
literal|"QMAKESPEC"
argument_list|)
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
block|}
name|m_qmakepath
operator|=
name|evaluator
operator|.
name|values
argument_list|(
name|ProKey
argument_list|(
literal|"QMAKEPATH"
argument_list|)
argument_list|)
operator|.
name|toQStringList
argument_list|()
expr_stmt|;
name|m_qmakefeatures
operator|=
name|evaluator
operator|.
name|values
argument_list|(
name|ProKey
argument_list|(
literal|"QMAKEFEATURES"
argument_list|)
argument_list|)
operator|.
name|toQStringList
argument_list|()
expr_stmt|;
block|}
name|updateMkspecPaths
argument_list|()
expr_stmt|;
if|if
condition|(
name|qmakespec
operator|.
name|isEmpty
argument_list|()
condition|)
name|qmakespec
operator|=
name|propertyValue
argument_list|(
name|ProKey
argument_list|(
name|m_hostBuild
condition|?
literal|"QMAKE_SPEC"
else|:
literal|"QMAKE_XSPEC"
argument_list|)
argument_list|)
operator|.
name|toQString
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_BUILD_QMAKE
comment|// Legacy support for Qt4 qmake in Qt Creator, etc.
if|if
condition|(
name|qmakespec
operator|.
name|isEmpty
argument_list|()
condition|)
name|qmakespec
operator|=
name|m_hostBuild
condition|?
name|QLatin1String
argument_list|(
literal|"default-host"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|IoUtils
operator|::
name|isRelativePath
argument_list|(
name|qmakespec
argument_list|)
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|root
decl|,
name|m_mkspecPaths
control|)
block|{
name|QString
name|mkspec
init|=
name|root
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|qmakespec
decl_stmt|;
if|if
condition|(
name|IoUtils
operator|::
name|exists
argument_list|(
name|mkspec
argument_list|)
condition|)
block|{
name|qmakespec
operator|=
name|mkspec
expr_stmt|;
goto|goto
name|cool
goto|;
block|}
block|}
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Could not find qmake configuration file %1."
argument_list|)
operator|.
name|arg
argument_list|(
name|qmakespec
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|cool
label|:
name|m_qmakespec
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|qmakespec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_superfile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|valuesRef
argument_list|(
name|ProKey
argument_list|(
literal|"_QMAKE_SUPER_CACHE_"
argument_list|)
argument_list|)
operator|<<
name|ProString
argument_list|(
name|m_superfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|evaluateFile
argument_list|(
name|m_superfile
argument_list|,
name|QMakeHandler
operator|::
name|EvalConfigFile
argument_list|,
name|LoadProOnly
operator||
name|LoadHidden
argument_list|)
operator|!=
name|ReturnTrue
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|loadSpecInternal
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|m_conffile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|valuesRef
argument_list|(
name|ProKey
argument_list|(
literal|"_QMAKE_CONF_"
argument_list|)
argument_list|)
operator|<<
name|ProString
argument_list|(
name|m_conffile
argument_list|)
expr_stmt|;
if|if
condition|(
name|evaluateFile
argument_list|(
name|m_conffile
argument_list|,
name|QMakeHandler
operator|::
name|EvalConfigFile
argument_list|,
name|LoadProOnly
argument_list|)
operator|!=
name|ReturnTrue
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|m_cachefile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|valuesRef
argument_list|(
name|ProKey
argument_list|(
literal|"_QMAKE_CACHE_"
argument_list|)
argument_list|)
operator|<<
name|ProString
argument_list|(
name|m_cachefile
argument_list|)
expr_stmt|;
if|if
condition|(
name|evaluateFile
argument_list|(
name|m_cachefile
argument_list|,
name|QMakeHandler
operator|::
name|EvalConfigFile
argument_list|,
name|LoadProOnly
argument_list|)
operator|!=
name|ReturnTrue
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|m_stashfile
operator|.
name|isEmpty
argument_list|()
operator|&&
name|m_vfs
operator|->
name|exists
argument_list|(
name|m_stashfile
argument_list|)
condition|)
block|{
name|valuesRef
argument_list|(
name|ProKey
argument_list|(
literal|"_QMAKE_STASH_"
argument_list|)
argument_list|)
operator|<<
name|ProString
argument_list|(
name|m_stashfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|evaluateFile
argument_list|(
name|m_stashfile
argument_list|,
name|QMakeHandler
operator|::
name|EvalConfigFile
argument_list|,
name|LoadProOnly
argument_list|)
operator|!=
name|ReturnTrue
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setupProject
name|void
name|QMakeEvaluator
operator|::
name|setupProject
parameter_list|()
block|{
name|setTemplate
argument_list|()
expr_stmt|;
name|ProValueMap
modifier|&
name|vars
init|=
name|m_valuemapStack
operator|.
name|top
argument_list|()
decl_stmt|;
name|ProFile
modifier|*
name|proFile
init|=
name|currentProFile
argument_list|()
decl_stmt|;
name|vars
index|[
name|ProKey
argument_list|(
literal|"TARGET"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|QFileInfo
argument_list|(
name|currentFileName
argument_list|()
argument_list|)
operator|.
name|baseName
argument_list|()
argument_list|)
operator|.
name|setSource
argument_list|(
name|proFile
argument_list|)
expr_stmt|;
name|vars
index|[
name|ProKey
argument_list|(
literal|"_PRO_FILE_"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|currentFileName
argument_list|()
argument_list|)
operator|.
name|setSource
argument_list|(
name|proFile
argument_list|)
expr_stmt|;
name|vars
index|[
name|ProKey
argument_list|(
literal|"_PRO_FILE_PWD_"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|currentDirectory
argument_list|()
argument_list|)
operator|.
name|setSource
argument_list|(
name|proFile
argument_list|)
expr_stmt|;
name|vars
index|[
name|ProKey
argument_list|(
literal|"OUT_PWD"
argument_list|)
index|]
operator|<<
name|ProString
argument_list|(
name|m_outputDir
argument_list|)
operator|.
name|setSource
argument_list|(
name|proFile
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|evaluateCommand
name|void
name|QMakeEvaluator
operator|::
name|evaluateCommand
parameter_list|(
specifier|const
name|QString
modifier|&
name|cmds
parameter_list|,
specifier|const
name|QString
modifier|&
name|where
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cmds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ProFile
modifier|*
name|pro
init|=
name|m_parser
operator|->
name|parsedProBlock
argument_list|(
name|cmds
argument_list|,
name|where
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pro
operator|->
name|isOk
argument_list|()
condition|)
block|{
name|m_locationStack
operator|.
name|push
argument_list|(
name|m_current
argument_list|)
expr_stmt|;
name|visitProBlock
argument_list|(
name|pro
argument_list|,
name|pro
operator|->
name|tokPtr
argument_list|()
argument_list|)
expr_stmt|;
name|m_current
operator|=
name|m_locationStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
name|pro
operator|->
name|deref
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|applyExtraConfigs
name|void
name|QMakeEvaluator
operator|::
name|applyExtraConfigs
parameter_list|()
block|{
if|if
condition|(
name|m_extraConfigs
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|evaluateCommand
argument_list|(
name|fL1S
argument_list|(
literal|"CONFIG += "
argument_list|)
operator|+
name|m_extraConfigs
operator|.
name|join
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
argument_list|,
name|fL1S
argument_list|(
literal|"(extra configs)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|evaluateConfigFeatures
name|QMakeEvaluator
operator|::
name|VisitReturn
name|QMakeEvaluator
operator|::
name|evaluateConfigFeatures
parameter_list|()
block|{
name|QSet
argument_list|<
name|QString
argument_list|>
name|processed
decl_stmt|;
forever|forever
block|{
name|bool
name|finished
init|=
literal|true
decl_stmt|;
name|ProStringList
name|configs
init|=
name|values
argument_list|(
name|statics
operator|.
name|strCONFIG
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|configs
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QString
name|config
init|=
name|configs
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|processed
operator|.
name|contains
argument_list|(
name|config
argument_list|)
condition|)
block|{
name|config
operator|.
name|detach
argument_list|()
expr_stmt|;
name|processed
operator|.
name|insert
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|VisitReturn
name|vr
init|=
name|evaluateFeatureFile
argument_list|(
name|config
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|vr
operator|==
name|ReturnError
condition|)
return|return
name|vr
return|;
if|if
condition|(
name|vr
operator|==
name|ReturnTrue
condition|)
block|{
name|finished
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|finished
condition|)
break|break;
block|}
return|return
name|ReturnTrue
return|;
block|}
end_function
begin_function
DECL|function|visitProFile
name|QMakeEvaluator
operator|::
name|VisitReturn
name|QMakeEvaluator
operator|::
name|visitProFile
parameter_list|(
name|ProFile
modifier|*
name|pro
parameter_list|,
name|QMakeHandler
operator|::
name|EvalFileType
name|type
parameter_list|,
name|LoadFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|m_cumulative
operator|&&
operator|!
name|pro
operator|->
name|isOk
argument_list|()
condition|)
return|return
name|ReturnFalse
return|;
if|if
condition|(
name|flags
operator|&
name|LoadPreFiles
condition|)
block|{
if|if
condition|(
operator|!
name|prepareProject
argument_list|(
name|pro
operator|->
name|directoryName
argument_list|()
argument_list|)
condition|)
return|return
name|ReturnFalse
return|;
name|m_hostBuild
operator|=
name|pro
operator|->
name|isHostBuild
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PROEVALUATOR_THREAD_SAFE
name|m_option
operator|->
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QMakeBaseEnv
modifier|*
modifier|*
name|baseEnvPtr
init|=
operator|&
name|m_option
operator|->
name|baseEnvs
index|[
name|QMakeBaseKey
argument_list|(
name|m_buildRoot
argument_list|,
name|m_stashfile
argument_list|,
name|m_hostBuild
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|baseEnvPtr
condition|)
operator|*
name|baseEnvPtr
operator|=
operator|new
name|QMakeBaseEnv
expr_stmt|;
name|QMakeBaseEnv
modifier|*
name|baseEnv
init|=
operator|*
name|baseEnvPtr
decl_stmt|;
ifdef|#
directive|ifdef
name|PROEVALUATOR_THREAD_SAFE
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|baseEnv
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|m_option
operator|->
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|baseEnv
operator|->
name|inProgress
condition|)
block|{
name|QThreadPool
operator|::
name|globalInstance
argument_list|()
operator|->
name|releaseThread
argument_list|()
expr_stmt|;
name|baseEnv
operator|->
name|cond
operator|.
name|wait
argument_list|(
operator|&
name|baseEnv
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|QThreadPool
operator|::
name|globalInstance
argument_list|()
operator|->
name|reserveThread
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|baseEnv
operator|->
name|isOk
condition|)
return|return
name|ReturnFalse
return|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|!
name|baseEnv
operator|->
name|evaluator
condition|)
block|{
ifdef|#
directive|ifdef
name|PROEVALUATOR_THREAD_SAFE
name|baseEnv
operator|->
name|inProgress
operator|=
literal|true
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QMakeEvaluator
modifier|*
name|baseEval
init|=
operator|new
name|QMakeEvaluator
argument_list|(
name|m_option
argument_list|,
name|m_parser
argument_list|,
name|m_vfs
argument_list|,
name|m_handler
argument_list|)
decl_stmt|;
name|baseEnv
operator|->
name|evaluator
operator|=
name|baseEval
expr_stmt|;
name|baseEval
operator|->
name|m_superfile
operator|=
name|m_superfile
expr_stmt|;
name|baseEval
operator|->
name|m_conffile
operator|=
name|m_conffile
expr_stmt|;
name|baseEval
operator|->
name|m_cachefile
operator|=
name|m_cachefile
expr_stmt|;
name|baseEval
operator|->
name|m_stashfile
operator|=
name|m_stashfile
expr_stmt|;
name|baseEval
operator|->
name|m_sourceRoot
operator|=
name|m_sourceRoot
expr_stmt|;
name|baseEval
operator|->
name|m_buildRoot
operator|=
name|m_buildRoot
expr_stmt|;
name|baseEval
operator|->
name|m_hostBuild
operator|=
name|m_hostBuild
expr_stmt|;
name|bool
name|ok
init|=
name|baseEval
operator|->
name|loadSpec
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|PROEVALUATOR_THREAD_SAFE
name|locker
operator|.
name|relock
argument_list|()
expr_stmt|;
name|baseEnv
operator|->
name|isOk
operator|=
name|ok
expr_stmt|;
name|baseEnv
operator|->
name|inProgress
operator|=
literal|false
expr_stmt|;
name|baseEnv
operator|->
name|cond
operator|.
name|wakeAll
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|ReturnFalse
return|;
block|}
ifdef|#
directive|ifdef
name|PROEVALUATOR_THREAD_SAFE
elseif|else
if|if
condition|(
operator|!
name|baseEnv
operator|->
name|isOk
condition|)
return|return
name|ReturnFalse
return|;
endif|#
directive|endif
name|initFrom
argument_list|(
name|baseEnv
operator|->
name|evaluator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|m_valuemapInited
condition|)
name|loadDefaults
argument_list|()
expr_stmt|;
block|}
name|VisitReturn
name|vr
decl_stmt|;
name|m_handler
operator|->
name|aboutToEval
argument_list|(
name|currentProFile
argument_list|()
argument_list|,
name|pro
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|m_profileStack
operator|.
name|push
argument_list|(
name|pro
argument_list|)
expr_stmt|;
name|valuesRef
argument_list|(
name|ProKey
argument_list|(
literal|"PWD"
argument_list|)
argument_list|)
operator|=
name|ProStringList
argument_list|(
name|ProString
argument_list|(
name|currentDirectory
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LoadPreFiles
condition|)
block|{
name|setupProject
argument_list|()
expr_stmt|;
for|for
control|(
name|ProValueMap
operator|::
name|ConstIterator
name|it
init|=
name|m_extraVars
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|m_extraVars
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|m_valuemapStack
operator|.
name|first
argument_list|()
operator|.
name|insert
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
comment|// In case default_pre needs to make decisions based on the current
comment|// build pass configuration.
name|applyExtraConfigs
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|vr
operator|=
name|evaluateFeatureFile
argument_list|(
name|QLatin1String
argument_list|(
literal|"default_pre.prf"
argument_list|)
argument_list|)
operator|)
operator|==
name|ReturnError
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
operator|!
name|m_option
operator|->
name|precmds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|evaluateCommand
argument_list|(
name|m_option
operator|->
name|precmds
argument_list|,
name|fL1S
argument_list|(
literal|"(command line)"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Again, after user configs, to override them
name|applyExtraConfigs
argument_list|()
expr_stmt|;
block|}
block|}
name|debugMsg
argument_list|(
literal|1
argument_list|,
literal|"visiting file %s"
argument_list|,
name|qPrintable
argument_list|(
name|pro
operator|->
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vr
operator|=
name|visitProBlock
argument_list|(
name|pro
argument_list|,
name|pro
operator|->
name|tokPtr
argument_list|()
argument_list|)
operator|)
operator|==
name|ReturnError
condition|)
goto|goto
name|failed
goto|;
name|debugMsg
argument_list|(
literal|1
argument_list|,
literal|"done visiting file %s"
argument_list|,
name|qPrintable
argument_list|(
name|pro
operator|->
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LoadPostFiles
condition|)
block|{
name|evaluateCommand
argument_list|(
name|m_option
operator|->
name|postcmds
argument_list|,
name|fL1S
argument_list|(
literal|"(command line -after)"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Again, to ensure the project does not mess with us.
comment|// Specifically, do not allow a project to override debug/release within a
comment|// debug_and_release build pass - it's too late for that at this point anyway.
name|applyExtraConfigs
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|vr
operator|=
name|evaluateFeatureFile
argument_list|(
name|QLatin1String
argument_list|(
literal|"default_post.prf"
argument_list|)
argument_list|)
operator|)
operator|==
name|ReturnError
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
operator|(
name|vr
operator|=
name|evaluateConfigFeatures
argument_list|()
operator|)
operator|==
name|ReturnError
condition|)
goto|goto
name|failed
goto|;
block|}
name|vr
operator|=
name|ReturnTrue
expr_stmt|;
name|failed
label|:
name|m_profileStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|valuesRef
argument_list|(
name|ProKey
argument_list|(
literal|"PWD"
argument_list|)
argument_list|)
operator|=
name|ProStringList
argument_list|(
name|ProString
argument_list|(
name|currentDirectory
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|m_handler
operator|->
name|doneWithEval
argument_list|(
name|currentProFile
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vr
return|;
block|}
end_function
begin_function
DECL|function|updateMkspecPaths
name|void
name|QMakeEvaluator
operator|::
name|updateMkspecPaths
parameter_list|()
block|{
name|QStringList
name|ret
decl_stmt|;
specifier|const
name|QString
name|concat
init|=
name|QLatin1String
argument_list|(
literal|"/mkspecs"
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|it
decl|,
name|m_option
operator|->
name|getPathListEnv
argument_list|(
name|QLatin1String
argument_list|(
literal|"QMAKEPATH"
argument_list|)
argument_list|)
control|)
name|ret
operator|<<
name|it
operator|+
name|concat
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|it
decl|,
name|m_qmakepath
control|)
name|ret
operator|<<
name|it
operator|+
name|concat
expr_stmt|;
if|if
condition|(
operator|!
name|m_buildRoot
operator|.
name|isEmpty
argument_list|()
condition|)
name|ret
operator|<<
name|m_buildRoot
operator|+
name|concat
expr_stmt|;
if|if
condition|(
operator|!
name|m_sourceRoot
operator|.
name|isEmpty
argument_list|()
condition|)
name|ret
operator|<<
name|m_sourceRoot
operator|+
name|concat
expr_stmt|;
name|ret
operator|<<
name|m_option
operator|->
name|propertyValue
argument_list|(
name|ProKey
argument_list|(
literal|"QT_HOST_DATA/get"
argument_list|)
argument_list|)
operator|+
name|concat
expr_stmt|;
name|ret
operator|<<
name|m_option
operator|->
name|propertyValue
argument_list|(
name|ProKey
argument_list|(
literal|"QT_HOST_DATA/src"
argument_list|)
argument_list|)
operator|+
name|concat
expr_stmt|;
name|ret
operator|.
name|removeDuplicates
argument_list|()
expr_stmt|;
name|m_mkspecPaths
operator|=
name|ret
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateFeaturePaths
name|void
name|QMakeEvaluator
operator|::
name|updateFeaturePaths
parameter_list|()
block|{
name|QString
name|mkspecs_concat
init|=
name|QLatin1String
argument_list|(
literal|"/mkspecs"
argument_list|)
decl_stmt|;
name|QString
name|features_concat
init|=
name|QLatin1String
argument_list|(
literal|"/features/"
argument_list|)
decl_stmt|;
name|QStringList
name|feature_roots
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|f
decl|,
name|m_option
operator|->
name|getPathListEnv
argument_list|(
name|QLatin1String
argument_list|(
literal|"QMAKEFEATURES"
argument_list|)
argument_list|)
control|)
name|feature_roots
operator|+=
name|f
expr_stmt|;
name|feature_roots
operator|+=
name|m_qmakefeatures
expr_stmt|;
name|feature_roots
operator|+=
name|m_option
operator|->
name|splitPathList
argument_list|(
name|m_option
operator|->
name|propertyValue
argument_list|(
name|ProKey
argument_list|(
literal|"QMAKEFEATURES"
argument_list|)
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_mtmp
argument_list|)
argument_list|)
expr_stmt|;
name|QStringList
name|feature_bases
decl_stmt|;
if|if
condition|(
operator|!
name|m_buildRoot
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|feature_bases
operator|<<
name|m_buildRoot
operator|+
name|mkspecs_concat
expr_stmt|;
name|feature_bases
operator|<<
name|m_buildRoot
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|m_sourceRoot
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|feature_bases
operator|<<
name|m_sourceRoot
operator|+
name|mkspecs_concat
expr_stmt|;
name|feature_bases
operator|<<
name|m_sourceRoot
expr_stmt|;
block|}
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|item
decl|,
name|m_option
operator|->
name|getPathListEnv
argument_list|(
name|QLatin1String
argument_list|(
literal|"QMAKEPATH"
argument_list|)
argument_list|)
control|)
name|feature_bases
operator|<<
operator|(
name|item
operator|+
name|mkspecs_concat
operator|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|item
decl|,
name|m_qmakepath
control|)
name|feature_bases
operator|<<
operator|(
name|item
operator|+
name|mkspecs_concat
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_qmakespec
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// The spec is already platform-dependent, so no subdirs here.
name|feature_roots
operator|<<
operator|(
name|m_qmakespec
operator|+
name|features_concat
operator|)
expr_stmt|;
comment|// Also check directly under the root directory of the mkspecs collection
name|QDir
name|specdir
argument_list|(
name|m_qmakespec
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|specdir
operator|.
name|isRoot
argument_list|()
operator|&&
name|specdir
operator|.
name|cdUp
argument_list|()
condition|)
block|{
specifier|const
name|QString
name|specpath
init|=
name|specdir
operator|.
name|path
argument_list|()
decl_stmt|;
if|if
condition|(
name|specpath
operator|.
name|endsWith
argument_list|(
name|mkspecs_concat
argument_list|)
condition|)
block|{
if|if
condition|(
name|IoUtils
operator|::
name|exists
argument_list|(
name|specpath
operator|+
name|features_concat
argument_list|)
condition|)
name|feature_bases
operator|<<
name|specpath
expr_stmt|;
break|break;
block|}
block|}
block|}
name|feature_bases
operator|<<
operator|(
name|m_option
operator|->
name|propertyValue
argument_list|(
name|ProKey
argument_list|(
literal|"QT_HOST_DATA/get"
argument_list|)
argument_list|)
operator|+
name|mkspecs_concat
operator|)
expr_stmt|;
name|feature_bases
operator|<<
operator|(
name|m_option
operator|->
name|propertyValue
argument_list|(
name|ProKey
argument_list|(
literal|"QT_HOST_DATA/src"
argument_list|)
argument_list|)
operator|+
name|mkspecs_concat
operator|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|fb
decl|,
name|feature_bases
control|)
block|{
foreach|foreach
control|(
specifier|const
name|ProString
modifier|&
name|sfx
decl|,
name|values
argument_list|(
name|ProKey
argument_list|(
literal|"QMAKE_PLATFORM"
argument_list|)
argument_list|)
control|)
name|feature_roots
operator|<<
operator|(
name|fb
operator|+
name|features_concat
operator|+
name|sfx
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|)
expr_stmt|;
name|feature_roots
operator|<<
operator|(
name|fb
operator|+
name|features_concat
operator|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|feature_roots
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|feature_roots
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|endsWith
argument_list|(
operator|(
name|ushort
operator|)
literal|'/'
argument_list|)
condition|)
name|feature_roots
index|[
name|i
index|]
operator|.
name|append
argument_list|(
operator|(
name|ushort
operator|)
literal|'/'
argument_list|)
expr_stmt|;
name|feature_roots
operator|.
name|removeDuplicates
argument_list|()
expr_stmt|;
name|QStringList
name|ret
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|root
decl|,
name|feature_roots
control|)
if|if
condition|(
name|IoUtils
operator|::
name|exists
argument_list|(
name|root
argument_list|)
condition|)
name|ret
operator|<<
name|root
expr_stmt|;
name|m_featureRoots
operator|=
operator|new
name|QMakeFeatureRoots
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|propertyValue
name|ProString
name|QMakeEvaluator
operator|::
name|propertyValue
parameter_list|(
specifier|const
name|ProKey
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"QMAKE_MKSPECS"
argument_list|)
condition|)
return|return
name|ProString
argument_list|(
name|m_mkspecPaths
operator|.
name|join
argument_list|(
name|m_option
operator|->
name|dirlist_sep
argument_list|)
argument_list|)
return|;
name|ProString
name|ret
init|=
name|m_option
operator|->
name|propertyValue
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|//    if (ret.isNull())
comment|//        evalError(fL1S("Querying unknown property %1").arg(name.toQString(m_mtmp)));
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|currentProFile
name|ProFile
modifier|*
name|QMakeEvaluator
operator|::
name|currentProFile
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|m_profileStack
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
return|return
name|m_profileStack
operator|.
name|top
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|currentFileName
name|QString
name|QMakeEvaluator
operator|::
name|currentFileName
parameter_list|()
specifier|const
block|{
name|ProFile
modifier|*
name|pro
init|=
name|currentProFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|pro
condition|)
return|return
name|pro
operator|->
name|fileName
argument_list|()
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|currentDirectory
name|QString
name|QMakeEvaluator
operator|::
name|currentDirectory
parameter_list|()
specifier|const
block|{
name|ProFile
modifier|*
name|pro
init|=
name|currentProFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|pro
condition|)
return|return
name|pro
operator|->
name|directoryName
argument_list|()
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|isActiveConfig
name|bool
name|QMakeEvaluator
operator|::
name|isActiveConfig
parameter_list|(
specifier|const
name|QString
modifier|&
name|config
parameter_list|,
name|bool
name|regex
parameter_list|)
block|{
comment|// magic types for easy flipping
if|if
condition|(
name|config
operator|==
name|statics
operator|.
name|strtrue
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|config
operator|==
name|statics
operator|.
name|strfalse
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|config
operator|==
name|statics
operator|.
name|strhost_build
condition|)
return|return
name|m_hostBuild
return|;
if|if
condition|(
name|regex
operator|&&
operator|(
name|config
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
argument_list|)
operator|||
name|config
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|QString
name|cfg
init|=
name|config
decl_stmt|;
name|cfg
operator|.
name|detach
argument_list|()
expr_stmt|;
comment|// Keep m_tmp out of QRegExp's cache
name|QRegExp
name|re
argument_list|(
name|cfg
argument_list|,
name|Qt
operator|::
name|CaseSensitive
argument_list|,
name|QRegExp
operator|::
name|Wildcard
argument_list|)
decl_stmt|;
comment|// mkspecs
if|if
condition|(
name|re
operator|.
name|exactMatch
argument_list|(
name|m_qmakespecName
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// CONFIG variable
name|int
name|t
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|ProString
modifier|&
name|configValue
decl|,
name|values
argument_list|(
name|statics
operator|.
name|strCONFIG
argument_list|)
control|)
block|{
if|if
condition|(
name|re
operator|.
name|exactMatch
argument_list|(
name|configValue
operator|.
name|toQString
argument_list|(
name|m_tmp
index|[
name|t
index|]
argument_list|)
argument_list|)
condition|)
return|return
literal|true
return|;
name|t
operator|^=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// mkspecs
if|if
condition|(
name|m_qmakespecName
operator|==
name|config
condition|)
return|return
literal|true
return|;
comment|// CONFIG variable
if|if
condition|(
name|values
argument_list|(
name|statics
operator|.
name|strCONFIG
argument_list|)
operator|.
name|contains
argument_list|(
name|ProString
argument_list|(
name|config
argument_list|)
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|expandVariableReferences
name|ProStringList
name|QMakeEvaluator
operator|::
name|expandVariableReferences
parameter_list|(
specifier|const
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|,
name|int
name|sizeHint
parameter_list|,
name|bool
name|joined
parameter_list|)
block|{
name|ProStringList
name|ret
decl_stmt|;
name|ret
operator|.
name|reserve
argument_list|(
name|sizeHint
argument_list|)
expr_stmt|;
forever|forever
block|{
name|evaluateExpression
argument_list|(
name|tokPtr
argument_list|,
operator|&
name|ret
argument_list|,
name|joined
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|tokPtr
condition|)
block|{
case|case
name|TokValueTerminator
case|:
case|case
name|TokFuncTerminator
case|:
name|tokPtr
operator|++
expr_stmt|;
return|return
name|ret
return|;
case|case
name|TokArgSeparator
case|:
if|if
condition|(
name|joined
condition|)
block|{
name|tokPtr
operator|++
expr_stmt|;
continue|continue;
block|}
comment|// fallthrough
default|default:
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"expandVariableReferences"
argument_list|,
literal|"Unrecognized token"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_function
DECL|function|prepareFunctionArgs
name|QList
argument_list|<
name|ProStringList
argument_list|>
name|QMakeEvaluator
operator|::
name|prepareFunctionArgs
parameter_list|(
specifier|const
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
name|QList
argument_list|<
name|ProStringList
argument_list|>
name|args_list
decl_stmt|;
if|if
condition|(
operator|*
name|tokPtr
operator|!=
name|TokFuncTerminator
condition|)
block|{
for|for
control|(
init|;
condition|;
name|tokPtr
operator|++
control|)
block|{
name|ProStringList
name|arg
decl_stmt|;
name|evaluateExpression
argument_list|(
name|tokPtr
argument_list|,
operator|&
name|arg
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|args_list
operator|<<
name|arg
expr_stmt|;
if|if
condition|(
operator|*
name|tokPtr
operator|==
name|TokFuncTerminator
condition|)
break|break;
name|Q_ASSERT
argument_list|(
operator|*
name|tokPtr
operator|==
name|TokArgSeparator
argument_list|)
expr_stmt|;
block|}
block|}
name|tokPtr
operator|++
expr_stmt|;
return|return
name|args_list
return|;
block|}
end_function
begin_function
DECL|function|evaluateFunction
name|ProStringList
name|QMakeEvaluator
operator|::
name|evaluateFunction
parameter_list|(
specifier|const
name|ProFunctionDef
modifier|&
name|func
parameter_list|,
specifier|const
name|QList
argument_list|<
name|ProStringList
argument_list|>
modifier|&
name|argumentsList
parameter_list|,
name|VisitReturn
modifier|*
name|ok
parameter_list|)
block|{
name|VisitReturn
name|vr
decl_stmt|;
name|ProStringList
name|ret
decl_stmt|;
if|if
condition|(
name|m_valuemapStack
operator|.
name|count
argument_list|()
operator|>=
literal|100
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Ran into infinite recursion (depth> 100)."
argument_list|)
argument_list|)
expr_stmt|;
name|vr
operator|=
name|ReturnFalse
expr_stmt|;
block|}
else|else
block|{
name|m_valuemapStack
operator|.
name|push
argument_list|(
name|ProValueMap
argument_list|()
argument_list|)
expr_stmt|;
name|m_locationStack
operator|.
name|push
argument_list|(
name|m_current
argument_list|)
expr_stmt|;
name|ProStringList
name|args
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argumentsList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|args
operator|+=
name|argumentsList
index|[
name|i
index|]
expr_stmt|;
name|m_valuemapStack
operator|.
name|top
argument_list|()
index|[
name|ProKey
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
index|]
operator|=
name|argumentsList
index|[
name|i
index|]
expr_stmt|;
block|}
name|m_valuemapStack
operator|.
name|top
argument_list|()
index|[
name|statics
operator|.
name|strARGS
index|]
operator|=
name|args
expr_stmt|;
name|m_valuemapStack
operator|.
name|top
argument_list|()
index|[
name|statics
operator|.
name|strARGC
index|]
operator|=
name|ProStringList
argument_list|(
name|ProString
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|argumentsList
operator|.
name|count
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|vr
operator|=
name|visitProBlock
argument_list|(
name|func
operator|.
name|pro
argument_list|()
argument_list|,
name|func
operator|.
name|tokPtr
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|vr
operator|==
name|ReturnReturn
condition|)
name|vr
operator|=
name|ReturnTrue
expr_stmt|;
name|ret
operator|=
name|m_returnValue
expr_stmt|;
name|m_returnValue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|m_current
operator|=
name|m_locationStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|m_valuemapStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
name|vr
expr_stmt|;
if|if
condition|(
name|vr
operator|==
name|ReturnTrue
condition|)
return|return
name|ret
return|;
return|return
name|ProStringList
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|evaluateBoolFunction
name|QMakeEvaluator
operator|::
name|VisitReturn
name|QMakeEvaluator
operator|::
name|evaluateBoolFunction
parameter_list|(
specifier|const
name|ProFunctionDef
modifier|&
name|func
parameter_list|,
specifier|const
name|QList
argument_list|<
name|ProStringList
argument_list|>
modifier|&
name|argumentsList
parameter_list|,
specifier|const
name|ProString
modifier|&
name|function
parameter_list|)
block|{
name|VisitReturn
name|vr
decl_stmt|;
name|ProStringList
name|ret
init|=
name|evaluateFunction
argument_list|(
name|func
argument_list|,
name|argumentsList
argument_list|,
operator|&
name|vr
argument_list|)
decl_stmt|;
if|if
condition|(
name|vr
operator|==
name|ReturnTrue
condition|)
block|{
if|if
condition|(
name|ret
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|ReturnTrue
return|;
if|if
condition|(
name|ret
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
name|statics
operator|.
name|strfalse
condition|)
block|{
if|if
condition|(
name|ret
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|statics
operator|.
name|strtrue
condition|)
return|return
name|ReturnTrue
return|;
name|bool
name|ok
decl_stmt|;
name|int
name|val
init|=
name|ret
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|val
condition|)
return|return
name|ReturnTrue
return|;
block|}
else|else
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Unexpected return value from test '%1': %2."
argument_list|)
operator|.
name|arg
argument_list|(
name|function
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|ret
operator|.
name|join
argument_list|(
name|QLatin1String
argument_list|(
literal|" :: "
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ReturnFalse
return|;
block|}
return|return
name|vr
return|;
block|}
end_function
begin_function
DECL|function|evaluateConditionalFunction
name|QMakeEvaluator
operator|::
name|VisitReturn
name|QMakeEvaluator
operator|::
name|evaluateConditionalFunction
parameter_list|(
specifier|const
name|ProKey
modifier|&
name|func
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
if|if
condition|(
name|int
name|func_t
init|=
name|statics
operator|.
name|functions
operator|.
name|value
argument_list|(
name|func
argument_list|)
condition|)
block|{
comment|//why don't the builtin functions just use args_list? --Sam
return|return
name|evaluateBuiltinConditional
argument_list|(
name|func_t
argument_list|,
name|func
argument_list|,
name|expandVariableReferences
argument_list|(
name|tokPtr
argument_list|,
literal|5
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
name|QHash
argument_list|<
name|ProKey
argument_list|,
name|ProFunctionDef
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|m_functionDefs
operator|.
name|testFunctions
operator|.
name|constFind
argument_list|(
name|func
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|m_functionDefs
operator|.
name|testFunctions
operator|.
name|constEnd
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|ProStringList
argument_list|>
name|args
init|=
name|prepareFunctionArgs
argument_list|(
name|tokPtr
argument_list|)
decl_stmt|;
name|traceMsg
argument_list|(
literal|"calling %s(%s)"
argument_list|,
name|dbgKey
argument_list|(
name|func
argument_list|)
argument_list|,
name|dbgStrListList
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|evaluateBoolFunction
argument_list|(
operator|*
name|it
argument_list|,
name|args
argument_list|,
name|func
argument_list|)
return|;
block|}
name|skipExpression
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"'%1' is not a recognized test function."
argument_list|)
operator|.
name|arg
argument_list|(
name|func
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
end_function
begin_function
DECL|function|evaluateExpandFunction
name|ProStringList
name|QMakeEvaluator
operator|::
name|evaluateExpandFunction
parameter_list|(
specifier|const
name|ProKey
modifier|&
name|func
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|tokPtr
parameter_list|)
block|{
if|if
condition|(
name|int
name|func_t
init|=
name|statics
operator|.
name|expands
operator|.
name|value
argument_list|(
name|func
argument_list|)
condition|)
block|{
comment|//why don't the builtin functions just use args_list? --Sam
return|return
name|evaluateBuiltinExpand
argument_list|(
name|func_t
argument_list|,
name|func
argument_list|,
name|expandVariableReferences
argument_list|(
name|tokPtr
argument_list|,
literal|5
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
name|QHash
argument_list|<
name|ProKey
argument_list|,
name|ProFunctionDef
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|m_functionDefs
operator|.
name|replaceFunctions
operator|.
name|constFind
argument_list|(
name|func
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|m_functionDefs
operator|.
name|replaceFunctions
operator|.
name|constEnd
argument_list|()
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|ProStringList
argument_list|>
name|args
init|=
name|prepareFunctionArgs
argument_list|(
name|tokPtr
argument_list|)
decl_stmt|;
name|traceMsg
argument_list|(
literal|"calling $$%s(%s)"
argument_list|,
name|dbgKey
argument_list|(
name|func
argument_list|)
argument_list|,
name|dbgStrListList
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|evaluateFunction
argument_list|(
operator|*
name|it
argument_list|,
name|args
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|skipExpression
argument_list|(
name|tokPtr
argument_list|)
expr_stmt|;
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"'%1' is not a recognized replace function."
argument_list|)
operator|.
name|arg
argument_list|(
name|func
operator|.
name|toQString
argument_list|(
name|m_tmp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ProStringList
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|evaluateConditional
name|bool
name|QMakeEvaluator
operator|::
name|evaluateConditional
parameter_list|(
specifier|const
name|QString
modifier|&
name|cond
parameter_list|,
specifier|const
name|QString
modifier|&
name|where
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|bool
name|ret
init|=
literal|false
decl_stmt|;
name|ProFile
modifier|*
name|pro
init|=
name|m_parser
operator|->
name|parsedProBlock
argument_list|(
name|cond
argument_list|,
name|where
argument_list|,
name|line
argument_list|,
name|QMakeParser
operator|::
name|TestGrammar
argument_list|)
decl_stmt|;
if|if
condition|(
name|pro
operator|->
name|isOk
argument_list|()
condition|)
block|{
name|m_locationStack
operator|.
name|push
argument_list|(
name|m_current
argument_list|)
expr_stmt|;
name|ret
operator|=
name|visitProBlock
argument_list|(
name|pro
argument_list|,
name|pro
operator|->
name|tokPtr
argument_list|()
argument_list|)
operator|==
name|ReturnTrue
expr_stmt|;
name|m_current
operator|=
name|m_locationStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
name|pro
operator|->
name|deref
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PROEVALUATOR_FULL
end_ifdef
begin_function
DECL|function|checkRequirements
name|void
name|QMakeEvaluator
operator|::
name|checkRequirements
parameter_list|(
specifier|const
name|ProStringList
modifier|&
name|deps
parameter_list|)
block|{
name|ProStringList
modifier|&
name|failed
init|=
name|valuesRef
argument_list|(
name|ProKey
argument_list|(
literal|"QMAKE_FAILED_REQUIREMENTS"
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|ProString
modifier|&
name|dep
decl|,
name|deps
control|)
if|if
condition|(
operator|!
name|evaluateConditional
argument_list|(
name|dep
operator|.
name|toQString
argument_list|()
argument_list|,
name|m_current
operator|.
name|pro
operator|->
name|fileName
argument_list|()
argument_list|,
name|m_current
operator|.
name|line
argument_list|)
condition|)
name|failed
operator|<<
name|dep
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|findValues
name|ProValueMap
modifier|*
name|QMakeEvaluator
operator|::
name|findValues
parameter_list|(
specifier|const
name|ProKey
modifier|&
name|variableName
parameter_list|,
name|ProValueMap
operator|::
name|Iterator
modifier|*
name|rit
parameter_list|)
block|{
name|ProValueMapStack
operator|::
name|Iterator
name|vmi
init|=
name|m_valuemapStack
operator|.
name|end
argument_list|()
decl_stmt|;
do|do
block|{
operator|--
name|vmi
expr_stmt|;
name|ProValueMap
operator|::
name|Iterator
name|it
init|=
operator|(
operator|*
name|vmi
operator|)
operator|.
name|find
argument_list|(
name|variableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
operator|(
operator|*
name|vmi
operator|)
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|constBegin
argument_list|()
operator|==
name|statics
operator|.
name|fakeValue
operator|.
name|constBegin
argument_list|()
condition|)
return|return
literal|0
return|;
operator|*
name|rit
operator|=
name|it
expr_stmt|;
return|return
operator|&
operator|(
operator|*
name|vmi
operator|)
return|;
block|}
block|}
do|while
condition|(
name|vmi
operator|!=
name|m_valuemapStack
operator|.
name|begin
argument_list|()
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|valuesRef
name|ProStringList
modifier|&
name|QMakeEvaluator
operator|::
name|valuesRef
parameter_list|(
specifier|const
name|ProKey
modifier|&
name|variableName
parameter_list|)
block|{
name|ProValueMap
operator|::
name|Iterator
name|it
init|=
name|m_valuemapStack
operator|.
name|top
argument_list|()
operator|.
name|find
argument_list|(
name|variableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|m_valuemapStack
operator|.
name|top
argument_list|()
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|constBegin
argument_list|()
operator|==
name|statics
operator|.
name|fakeValue
operator|.
name|constBegin
argument_list|()
condition|)
name|it
operator|->
name|clear
argument_list|()
expr_stmt|;
return|return
operator|*
name|it
return|;
block|}
name|ProValueMapStack
operator|::
name|Iterator
name|vmi
init|=
name|m_valuemapStack
operator|.
name|end
argument_list|()
decl_stmt|;
if|if
condition|(
operator|--
name|vmi
operator|!=
name|m_valuemapStack
operator|.
name|begin
argument_list|()
condition|)
block|{
do|do
block|{
operator|--
name|vmi
expr_stmt|;
name|ProValueMap
operator|::
name|ConstIterator
name|it
init|=
operator|(
operator|*
name|vmi
operator|)
operator|.
name|constFind
argument_list|(
name|variableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
operator|(
operator|*
name|vmi
operator|)
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|ProStringList
modifier|&
name|ret
init|=
name|m_valuemapStack
operator|.
name|top
argument_list|()
index|[
name|variableName
index|]
decl_stmt|;
if|if
condition|(
name|it
operator|->
name|constBegin
argument_list|()
operator|!=
name|statics
operator|.
name|fakeValue
operator|.
name|constBegin
argument_list|()
condition|)
name|ret
operator|=
operator|*
name|it
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
do|while
condition|(
name|vmi
operator|!=
name|m_valuemapStack
operator|.
name|begin
argument_list|()
condition|)
do|;
block|}
return|return
name|m_valuemapStack
operator|.
name|top
argument_list|()
index|[
name|variableName
index|]
return|;
block|}
end_function
begin_function
DECL|function|values
name|ProStringList
name|QMakeEvaluator
operator|::
name|values
parameter_list|(
specifier|const
name|ProKey
modifier|&
name|variableName
parameter_list|)
specifier|const
block|{
name|ProValueMapStack
operator|::
name|ConstIterator
name|vmi
init|=
name|m_valuemapStack
operator|.
name|constEnd
argument_list|()
decl_stmt|;
do|do
block|{
operator|--
name|vmi
expr_stmt|;
name|ProValueMap
operator|::
name|ConstIterator
name|it
init|=
operator|(
operator|*
name|vmi
operator|)
operator|.
name|constFind
argument_list|(
name|variableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
operator|(
operator|*
name|vmi
operator|)
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|constBegin
argument_list|()
operator|==
name|statics
operator|.
name|fakeValue
operator|.
name|constBegin
argument_list|()
condition|)
break|break;
return|return
operator|*
name|it
return|;
block|}
block|}
do|while
condition|(
name|vmi
operator|!=
name|m_valuemapStack
operator|.
name|constBegin
argument_list|()
condition|)
do|;
return|return
name|ProStringList
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|first
name|ProString
name|QMakeEvaluator
operator|::
name|first
parameter_list|(
specifier|const
name|ProKey
modifier|&
name|variableName
parameter_list|)
specifier|const
block|{
specifier|const
name|ProStringList
modifier|&
name|vals
init|=
name|values
argument_list|(
name|variableName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vals
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|vals
operator|.
name|first
argument_list|()
return|;
return|return
name|ProString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|evaluateFile
name|QMakeEvaluator
operator|::
name|VisitReturn
name|QMakeEvaluator
operator|::
name|evaluateFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QMakeHandler
operator|::
name|EvalFileType
name|type
parameter_list|,
name|LoadFlags
name|flags
parameter_list|)
block|{
name|QMakeParser
operator|::
name|ParseFlags
name|pflags
init|=
name|QMakeParser
operator|::
name|ParseUseCache
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LoadSilent
operator|)
condition|)
name|pflags
operator||=
name|QMakeParser
operator|::
name|ParseReportMissing
expr_stmt|;
if|if
condition|(
name|ProFile
modifier|*
name|pro
init|=
name|m_parser
operator|->
name|parsedProFile
argument_list|(
name|fileName
argument_list|,
name|pflags
argument_list|)
condition|)
block|{
name|m_locationStack
operator|.
name|push
argument_list|(
name|m_current
argument_list|)
expr_stmt|;
name|VisitReturn
name|ok
init|=
name|visitProFile
argument_list|(
name|pro
argument_list|,
name|type
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|m_current
operator|=
name|m_locationStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|pro
operator|->
name|deref
argument_list|()
expr_stmt|;
if|if
condition|(
name|ok
operator|==
name|ReturnTrue
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LoadHidden
operator|)
condition|)
block|{
name|ProStringList
modifier|&
name|iif
init|=
name|m_valuemapStack
operator|.
name|first
argument_list|()
index|[
name|ProKey
argument_list|(
literal|"QMAKE_INTERNAL_INCLUDED_FILES"
argument_list|)
index|]
decl_stmt|;
name|ProString
name|ifn
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|iif
operator|.
name|contains
argument_list|(
name|ifn
argument_list|)
condition|)
name|iif
operator|<<
name|ifn
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
else|else
block|{
return|return
name|ReturnFalse
return|;
block|}
block|}
end_function
begin_function
DECL|function|evaluateFileChecked
name|QMakeEvaluator
operator|::
name|VisitReturn
name|QMakeEvaluator
operator|::
name|evaluateFileChecked
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QMakeHandler
operator|::
name|EvalFileType
name|type
parameter_list|,
name|LoadFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|ReturnFalse
return|;
name|QMakeEvaluator
modifier|*
name|ref
init|=
name|this
decl_stmt|;
do|do
block|{
foreach|foreach
control|(
specifier|const
name|ProFile
modifier|*
name|pf
decl|,
name|ref
operator|->
name|m_profileStack
control|)
if|if
condition|(
name|pf
operator|->
name|fileName
argument_list|()
operator|==
name|fileName
condition|)
block|{
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Circular inclusion of %1."
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
block|}
do|while
condition|(
operator|(
name|ref
operator|=
name|ref
operator|->
name|m_caller
operator|)
condition|)
do|;
return|return
name|evaluateFile
argument_list|(
name|fileName
argument_list|,
name|type
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|evaluateFeatureFile
name|QMakeEvaluator
operator|::
name|VisitReturn
name|QMakeEvaluator
operator|::
name|evaluateFeatureFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|bool
name|silent
parameter_list|)
block|{
name|QString
name|fn
init|=
name|fileName
decl_stmt|;
if|if
condition|(
operator|!
name|fn
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|".prf"
argument_list|)
argument_list|)
condition|)
name|fn
operator|+=
name|QLatin1String
argument_list|(
literal|".prf"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_featureRoots
condition|)
name|updateFeaturePaths
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PROEVALUATOR_THREAD_SAFE
name|m_featureRoots
operator|->
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QString
name|currFn
init|=
name|currentFileName
argument_list|()
decl_stmt|;
if|if
condition|(
name|IoUtils
operator|::
name|fileName
argument_list|(
name|currFn
argument_list|)
operator|!=
name|IoUtils
operator|::
name|fileName
argument_list|(
name|fn
argument_list|)
condition|)
name|currFn
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Null values cannot regularly exist in the hash, so they indicate that the value still
comment|// needs to be determined. Failed lookups are represented via non-null empty strings.
name|QString
modifier|*
name|fnp
init|=
operator|&
name|m_featureRoots
operator|->
name|cache
index|[
name|qMakePair
argument_list|(
name|fn
argument_list|,
name|currFn
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|fnp
operator|->
name|isNull
argument_list|()
condition|)
block|{
name|int
name|start_root
init|=
literal|0
decl_stmt|;
specifier|const
name|QStringList
modifier|&
name|paths
init|=
name|m_featureRoots
operator|->
name|paths
decl_stmt|;
if|if
condition|(
operator|!
name|currFn
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringRef
name|currPath
init|=
name|IoUtils
operator|::
name|pathName
argument_list|(
name|currFn
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|root
init|=
literal|0
init|;
name|root
operator|<
name|paths
operator|.
name|size
argument_list|()
condition|;
operator|++
name|root
control|)
if|if
condition|(
name|currPath
operator|==
name|paths
operator|.
name|at
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|start_root
operator|=
name|root
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|int
name|root
init|=
name|start_root
init|;
name|root
operator|<
name|paths
operator|.
name|size
argument_list|()
condition|;
operator|++
name|root
control|)
block|{
name|QString
name|fname
init|=
name|paths
operator|.
name|at
argument_list|(
name|root
argument_list|)
operator|+
name|fn
decl_stmt|;
if|if
condition|(
name|IoUtils
operator|::
name|exists
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|fn
operator|=
name|fname
expr_stmt|;
goto|goto
name|cool
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|QMAKE_BUILTIN_PRFS
name|fn
operator|.
name|prepend
argument_list|(
name|QLatin1String
argument_list|(
literal|":/qmake/features/"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|QFileInfo
argument_list|(
name|fn
argument_list|)
operator|.
name|exists
argument_list|()
condition|)
goto|goto
name|cool
goto|;
endif|#
directive|endif
name|fn
operator|=
name|QLatin1String
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// Indicate failed lookup. See comment above.
name|cool
label|:
operator|*
name|fnp
operator|=
name|fn
expr_stmt|;
block|}
else|else
block|{
name|fn
operator|=
operator|*
name|fnp
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PROEVALUATOR_THREAD_SAFE
name|m_featureRoots
operator|->
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fn
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
name|evalError
argument_list|(
name|fL1S
argument_list|(
literal|"Cannot find feature %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnFalse
return|;
block|}
name|ProStringList
modifier|&
name|already
init|=
name|valuesRef
argument_list|(
name|ProKey
argument_list|(
literal|"QMAKE_INTERNAL_INCLUDED_FEATURES"
argument_list|)
argument_list|)
decl_stmt|;
name|ProString
name|afn
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
name|already
operator|.
name|contains
argument_list|(
name|afn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
name|languageWarning
argument_list|(
name|fL1S
argument_list|(
literal|"Feature %1 already included"
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ReturnTrue
return|;
block|}
name|already
operator|.
name|append
argument_list|(
name|afn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROEVALUATOR_CUMULATIVE
name|bool
name|cumulative
init|=
name|m_cumulative
decl_stmt|;
name|m_cumulative
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
comment|// The path is fully normalized already.
name|VisitReturn
name|ok
init|=
name|evaluateFile
argument_list|(
name|fn
argument_list|,
name|QMakeHandler
operator|::
name|EvalFeatureFile
argument_list|,
name|LoadProOnly
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PROEVALUATOR_CUMULATIVE
name|m_cumulative
operator|=
name|cumulative
expr_stmt|;
endif|#
directive|endif
return|return
name|ok
return|;
block|}
end_function
begin_function
DECL|function|evaluateFileInto
name|QMakeEvaluator
operator|::
name|VisitReturn
name|QMakeEvaluator
operator|::
name|evaluateFileInto
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|ProValueMap
modifier|*
name|values
parameter_list|,
name|LoadFlags
name|flags
parameter_list|)
block|{
name|QMakeEvaluator
name|visitor
argument_list|(
name|m_option
argument_list|,
name|m_parser
argument_list|,
name|m_vfs
argument_list|,
name|m_handler
argument_list|)
decl_stmt|;
name|visitor
operator|.
name|m_caller
operator|=
name|this
expr_stmt|;
name|visitor
operator|.
name|m_outputDir
operator|=
name|m_outputDir
expr_stmt|;
name|visitor
operator|.
name|m_featureRoots
operator|=
name|m_featureRoots
expr_stmt|;
name|VisitReturn
name|ret
init|=
name|visitor
operator|.
name|evaluateFileChecked
argument_list|(
name|fileName
argument_list|,
name|QMakeHandler
operator|::
name|EvalAuxFile
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ReturnTrue
condition|)
return|return
name|ret
return|;
operator|*
name|values
operator|=
name|visitor
operator|.
name|m_valuemapStack
operator|.
name|top
argument_list|()
expr_stmt|;
name|ProKey
name|qiif
argument_list|(
literal|"QMAKE_INTERNAL_INCLUDED_FILES"
argument_list|)
decl_stmt|;
name|ProStringList
modifier|&
name|iif
init|=
name|m_valuemapStack
operator|.
name|first
argument_list|()
index|[
name|qiif
index|]
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|ProString
modifier|&
name|ifn
decl|,
name|values
operator|->
name|value
argument_list|(
name|qiif
argument_list|)
control|)
if|if
condition|(
operator|!
name|iif
operator|.
name|contains
argument_list|(
name|ifn
argument_list|)
condition|)
name|iif
operator|<<
name|ifn
expr_stmt|;
return|return
name|ReturnTrue
return|;
block|}
end_function
begin_function
DECL|function|message
name|void
name|QMakeEvaluator
operator|::
name|message
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|msg
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|m_skipLevel
condition|)
name|m_handler
operator|->
name|message
argument_list|(
name|type
argument_list|,
name|msg
argument_list|,
name|m_current
operator|.
name|line
condition|?
name|m_current
operator|.
name|pro
operator|->
name|fileName
argument_list|()
else|:
name|QString
argument_list|()
argument_list|,
name|m_current
operator|.
name|line
operator|!=
literal|0xffff
condition|?
name|m_current
operator|.
name|line
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PROEVALUATOR_DEBUG
end_ifdef
begin_function
DECL|function|debugMsgInternal
name|void
name|QMakeEvaluator
operator|::
name|debugMsgInternal
parameter_list|(
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|level
operator|<=
name|m_debugLevel
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG %d: "
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|traceMsgInternal
name|void
name|QMakeEvaluator
operator|::
name|traceMsgInternal
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|m_current
operator|.
name|pro
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG 1: "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m_current
operator|.
name|line
operator|<=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG 1: %s: "
argument_list|,
name|qPrintable
argument_list|(
name|m_current
operator|.
name|pro
operator|->
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG 1: %s:%d: "
argument_list|,
name|qPrintable
argument_list|(
name|m_current
operator|.
name|pro
operator|->
name|fileName
argument_list|()
argument_list|)
argument_list|,
name|m_current
operator|.
name|line
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|formatValue
name|QString
name|QMakeEvaluator
operator|::
name|formatValue
parameter_list|(
specifier|const
name|ProString
modifier|&
name|val
parameter_list|,
name|bool
name|forceQuote
parameter_list|)
block|{
name|QString
name|ret
decl_stmt|;
name|ret
operator|.
name|reserve
argument_list|(
name|val
operator|.
name|size
argument_list|()
operator|+
literal|2
argument_list|)
expr_stmt|;
specifier|const
name|QChar
modifier|*
name|chars
init|=
name|val
operator|.
name|constData
argument_list|()
decl_stmt|;
name|bool
name|quote
init|=
name|forceQuote
operator|||
name|val
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|l
init|=
name|val
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
name|QChar
name|c
init|=
name|chars
index|[
name|i
index|]
decl_stmt|;
name|ushort
name|uc
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|uc
operator|<
literal|32
condition|)
block|{
switch|switch
condition|(
name|uc
condition|)
block|{
case|case
literal|'\r'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"\\x%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|uc
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|uc
condition|)
block|{
case|case
literal|'\\'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|"\\'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|quote
operator|=
literal|true
expr_stmt|;
comment|// fallthrough
default|default:
name|ret
operator|+=
name|c
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|quote
condition|)
block|{
name|ret
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|formatValueList
name|QString
name|QMakeEvaluator
operator|::
name|formatValueList
parameter_list|(
specifier|const
name|ProStringList
modifier|&
name|vals
parameter_list|,
name|bool
name|commas
parameter_list|)
block|{
name|QString
name|ret
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|ProString
modifier|&
name|str
decl|,
name|vals
control|)
block|{
if|if
condition|(
operator|!
name|ret
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|commas
condition|)
name|ret
operator|+=
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|ret
operator|+=
name|formatValue
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|formatValueListList
name|QString
name|QMakeEvaluator
operator|::
name|formatValueListList
parameter_list|(
specifier|const
name|QList
argument_list|<
name|ProStringList
argument_list|>
modifier|&
name|lists
parameter_list|)
block|{
name|QString
name|ret
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|ProStringList
modifier|&
name|list
decl|,
name|lists
control|)
block|{
if|if
condition|(
operator|!
name|ret
operator|.
name|isEmpty
argument_list|()
condition|)
name|ret
operator|+=
name|QLatin1String
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|formatValueList
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
