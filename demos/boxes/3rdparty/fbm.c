begin_unit
begin_comment
comment|/*****************************************************************    Implementation of the fractional Brownian motion algorithm. These   functions were originally the work of F. Kenton Musgrave.   For documentation of the different functions please refer to the   book:    "Texturing and modeling: a procedural approach"   by David S. Ebert et. al.  ******************************************************************/
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_include
include|#
directive|include
file|<qglobal.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|"fbm.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4244
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Definitions used by the noise2() functions */
end_comment
begin_comment
comment|//#define B 0x100
end_comment
begin_comment
comment|//#define BM 0xff
end_comment
begin_define
DECL|macro|B
define|#
directive|define
name|B
value|0x20
end_define
begin_define
DECL|macro|BM
define|#
directive|define
name|BM
value|0x1f
end_define
begin_define
DECL|macro|N
define|#
directive|define
name|N
value|0x1000
end_define
begin_define
DECL|macro|NP
define|#
directive|define
name|NP
value|12
end_define
begin_comment
DECL|macro|NP
comment|/* 2^N */
end_comment
begin_define
DECL|macro|NM
define|#
directive|define
name|NM
value|0xfff
end_define
begin_decl_stmt
DECL|variable|p
specifier|static
name|int
name|p
index|[
name|B
operator|+
name|B
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|g3
specifier|static
name|float
name|g3
index|[
name|B
operator|+
name|B
operator|+
literal|2
index|]
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|g2
specifier|static
name|float
name|g2
index|[
name|B
operator|+
name|B
operator|+
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|g1
specifier|static
name|float
name|g1
index|[
name|B
operator|+
name|B
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|start
specifier|static
name|int
name|start
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
name|void
name|init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|s_curve
define|#
directive|define
name|s_curve
parameter_list|(
name|t
parameter_list|)
value|( t * t * (3. - 2. * t) )
end_define
begin_define
DECL|macro|lerp
define|#
directive|define
name|lerp
parameter_list|(
name|t
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|( a + t * (b - a) )
end_define
begin_define
DECL|macro|setup
define|#
directive|define
name|setup
parameter_list|(
name|i
parameter_list|,
name|b0
parameter_list|,
name|b1
parameter_list|,
name|r0
parameter_list|,
name|r1
parameter_list|)
define|\
value|t = vec[i] + N;\ 	b0 = ((int)t)& BM;\ 	b1 = (b0+1)& BM;\ 	r0 = t - (int)t;\ 	r1 = r0 - 1.;
end_define
begin_define
DECL|macro|at3
define|#
directive|define
name|at3
parameter_list|(
name|rx
parameter_list|,
name|ry
parameter_list|,
name|rz
parameter_list|)
value|( rx * q[0] + ry * q[1] + rz * q[2] )
end_define
begin_comment
comment|/* Fractional Brownian Motion function */
end_comment
begin_function
DECL|function|fBm
name|double
name|fBm
parameter_list|(
name|Vector
name|point
parameter_list|,
name|double
name|H
parameter_list|,
name|double
name|lacunarity
parameter_list|,
name|double
name|octaves
parameter_list|,
name|int
name|init
parameter_list|)
block|{
name|double
name|value
decl_stmt|,
name|frequency
decl_stmt|,
name|remainder
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|double
name|exponent_array
index|[
literal|10
index|]
decl_stmt|;
name|float
name|vec
index|[
literal|3
index|]
decl_stmt|;
comment|/* precompute and store spectral weights */
if|if
condition|(
name|init
condition|)
block|{
name|start
operator|=
literal|1
expr_stmt|;
name|srand
argument_list|(
name|time
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* seize required memory for exponent_array */
name|frequency
operator|=
literal|1.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|octaves
condition|;
name|i
operator|++
control|)
block|{
comment|/* compute weight for each frequency */
name|exponent_array
index|[
name|i
index|]
operator|=
name|pow
argument_list|(
name|frequency
argument_list|,
operator|-
name|H
argument_list|)
expr_stmt|;
name|frequency
operator|*=
name|lacunarity
expr_stmt|;
block|}
block|}
name|value
operator|=
literal|0.0
expr_stmt|;
comment|/* initialize vars to proper values */
name|frequency
operator|=
literal|1.0
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
name|point
operator|.
name|x
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
name|point
operator|.
name|y
expr_stmt|;
name|vec
index|[
literal|2
index|]
operator|=
name|point
operator|.
name|z
expr_stmt|;
comment|/* inner loop of spectral construction */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|octaves
condition|;
name|i
operator|++
control|)
block|{
comment|/* value += noise3( vec ) * exponent_array[i];*/
name|value
operator|+=
name|noise3
argument_list|(
name|vec
argument_list|)
operator|*
name|exponent_array
index|[
name|i
index|]
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|*=
name|lacunarity
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|*=
name|lacunarity
expr_stmt|;
name|vec
index|[
literal|2
index|]
operator|*=
name|lacunarity
expr_stmt|;
block|}
comment|/* for */
name|remainder
operator|=
name|octaves
operator|-
operator|(
name|int
operator|)
name|octaves
expr_stmt|;
if|if
condition|(
name|remainder
condition|)
comment|/* add in ``octaves''  remainder */
comment|/* ``i''  and spatial freq. are preset in loop above */
name|value
operator|+=
name|remainder
operator|*
name|noise3
argument_list|(
name|vec
argument_list|)
operator|*
name|exponent_array
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function
begin_comment
comment|/* fBm() */
end_comment
begin_function
DECL|function|noise3
name|float
name|noise3
parameter_list|(
name|float
name|vec
index|[
literal|3
index|]
parameter_list|)
block|{
name|int
name|bx0
decl_stmt|,
name|bx1
decl_stmt|,
name|by0
decl_stmt|,
name|by1
decl_stmt|,
name|bz0
decl_stmt|,
name|bz1
decl_stmt|,
name|b00
decl_stmt|,
name|b10
decl_stmt|,
name|b01
decl_stmt|,
name|b11
decl_stmt|;
name|float
name|rx0
decl_stmt|,
name|rx1
decl_stmt|,
name|ry0
decl_stmt|,
name|ry1
decl_stmt|,
name|rz0
decl_stmt|,
name|rz1
decl_stmt|,
modifier|*
name|q
decl_stmt|,
name|sy
decl_stmt|,
name|sz
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|t
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|start
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
block|}
name|setup
argument_list|(
literal|0
argument_list|,
name|bx0
argument_list|,
name|bx1
argument_list|,
name|rx0
argument_list|,
name|rx1
argument_list|)
expr_stmt|;
name|setup
argument_list|(
literal|1
argument_list|,
name|by0
argument_list|,
name|by1
argument_list|,
name|ry0
argument_list|,
name|ry1
argument_list|)
expr_stmt|;
name|setup
argument_list|(
literal|2
argument_list|,
name|bz0
argument_list|,
name|bz1
argument_list|,
name|rz0
argument_list|,
name|rz1
argument_list|)
expr_stmt|;
name|i
operator|=
name|p
index|[
name|bx0
index|]
expr_stmt|;
name|j
operator|=
name|p
index|[
name|bx1
index|]
expr_stmt|;
name|b00
operator|=
name|p
index|[
name|i
operator|+
name|by0
index|]
expr_stmt|;
name|b10
operator|=
name|p
index|[
name|j
operator|+
name|by0
index|]
expr_stmt|;
name|b01
operator|=
name|p
index|[
name|i
operator|+
name|by1
index|]
expr_stmt|;
name|b11
operator|=
name|p
index|[
name|j
operator|+
name|by1
index|]
expr_stmt|;
name|t
operator|=
name|s_curve
argument_list|(
name|rx0
argument_list|)
expr_stmt|;
name|sy
operator|=
name|s_curve
argument_list|(
name|ry0
argument_list|)
expr_stmt|;
name|sz
operator|=
name|s_curve
argument_list|(
name|rz0
argument_list|)
expr_stmt|;
name|q
operator|=
name|g3
index|[
name|b00
operator|+
name|bz0
index|]
expr_stmt|;
name|u
operator|=
name|at3
argument_list|(
name|rx0
argument_list|,
name|ry0
argument_list|,
name|rz0
argument_list|)
expr_stmt|;
name|q
operator|=
name|g3
index|[
name|b10
operator|+
name|bz0
index|]
expr_stmt|;
name|v
operator|=
name|at3
argument_list|(
name|rx1
argument_list|,
name|ry0
argument_list|,
name|rz0
argument_list|)
expr_stmt|;
name|a
operator|=
name|lerp
argument_list|(
name|t
argument_list|,
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|q
operator|=
name|g3
index|[
name|b01
operator|+
name|bz0
index|]
expr_stmt|;
name|u
operator|=
name|at3
argument_list|(
name|rx0
argument_list|,
name|ry1
argument_list|,
name|rz0
argument_list|)
expr_stmt|;
name|q
operator|=
name|g3
index|[
name|b11
operator|+
name|bz0
index|]
expr_stmt|;
name|v
operator|=
name|at3
argument_list|(
name|rx1
argument_list|,
name|ry1
argument_list|,
name|rz0
argument_list|)
expr_stmt|;
name|b
operator|=
name|lerp
argument_list|(
name|t
argument_list|,
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|c
operator|=
name|lerp
argument_list|(
name|sy
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|q
operator|=
name|g3
index|[
name|b00
operator|+
name|bz1
index|]
expr_stmt|;
name|u
operator|=
name|at3
argument_list|(
name|rx0
argument_list|,
name|ry0
argument_list|,
name|rz1
argument_list|)
expr_stmt|;
name|q
operator|=
name|g3
index|[
name|b10
operator|+
name|bz1
index|]
expr_stmt|;
name|v
operator|=
name|at3
argument_list|(
name|rx1
argument_list|,
name|ry0
argument_list|,
name|rz1
argument_list|)
expr_stmt|;
name|a
operator|=
name|lerp
argument_list|(
name|t
argument_list|,
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|q
operator|=
name|g3
index|[
name|b01
operator|+
name|bz1
index|]
expr_stmt|;
name|u
operator|=
name|at3
argument_list|(
name|rx0
argument_list|,
name|ry1
argument_list|,
name|rz1
argument_list|)
expr_stmt|;
name|q
operator|=
name|g3
index|[
name|b11
operator|+
name|bz1
index|]
expr_stmt|;
name|v
operator|=
name|at3
argument_list|(
name|rx1
argument_list|,
name|ry1
argument_list|,
name|rz1
argument_list|)
expr_stmt|;
name|b
operator|=
name|lerp
argument_list|(
name|t
argument_list|,
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|d
operator|=
name|lerp
argument_list|(
name|sy
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
name|lerp
argument_list|(
name|sz
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|normalize2
specifier|static
name|void
name|normalize2
parameter_list|(
name|float
name|v
index|[
literal|2
index|]
parameter_list|)
block|{
name|float
name|s
decl_stmt|;
name|s
operator|=
name|sqrt
argument_list|(
name|v
index|[
literal|0
index|]
operator|*
name|v
index|[
literal|0
index|]
operator|+
name|v
index|[
literal|1
index|]
operator|*
name|v
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
operator|/
name|s
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
operator|/
name|s
expr_stmt|;
block|}
end_function
begin_function
DECL|function|normalize3
specifier|static
name|void
name|normalize3
parameter_list|(
name|float
name|v
index|[
literal|3
index|]
parameter_list|)
block|{
name|float
name|s
decl_stmt|;
name|s
operator|=
name|sqrt
argument_list|(
name|v
index|[
literal|0
index|]
operator|*
name|v
index|[
literal|0
index|]
operator|+
name|v
index|[
literal|1
index|]
operator|*
name|v
index|[
literal|1
index|]
operator|+
name|v
index|[
literal|2
index|]
operator|*
name|v
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
operator|/
name|s
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
operator|/
name|s
expr_stmt|;
name|v
index|[
literal|2
index|]
operator|=
name|v
index|[
literal|2
index|]
operator|/
name|s
expr_stmt|;
block|}
end_function
begin_function
DECL|function|init
specifier|static
name|void
name|init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|B
condition|;
name|i
operator|++
control|)
block|{
name|p
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|g1
index|[
name|i
index|]
operator|=
call|(
name|float
call|)
argument_list|(
operator|(
name|rand
argument_list|()
operator|%
operator|(
name|B
operator|+
name|B
operator|)
operator|)
operator|-
name|B
argument_list|)
operator|/
name|B
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
name|g2
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
call|(
name|float
call|)
argument_list|(
operator|(
name|rand
argument_list|()
operator|%
operator|(
name|B
operator|+
name|B
operator|)
operator|)
operator|-
name|B
argument_list|)
operator|/
name|B
expr_stmt|;
name|normalize2
argument_list|(
name|g2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
name|g3
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
call|(
name|float
call|)
argument_list|(
operator|(
name|rand
argument_list|()
operator|%
operator|(
name|B
operator|+
name|B
operator|)
operator|)
operator|-
name|B
argument_list|)
operator|/
name|B
expr_stmt|;
name|normalize3
argument_list|(
name|g3
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|i
condition|)
block|{
name|k
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
name|p
index|[
name|i
index|]
operator|=
name|p
index|[
name|j
operator|=
name|rand
argument_list|()
operator|%
name|B
index|]
expr_stmt|;
name|p
index|[
name|j
index|]
operator|=
name|k
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|B
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|p
index|[
name|B
operator|+
name|i
index|]
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
name|g1
index|[
name|B
operator|+
name|i
index|]
operator|=
name|g1
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
name|g2
index|[
name|B
operator|+
name|i
index|]
index|[
name|j
index|]
operator|=
name|g2
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
name|g3
index|[
name|B
operator|+
name|i
index|]
index|[
name|j
index|]
operator|=
name|g3
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
end_function
end_unit
