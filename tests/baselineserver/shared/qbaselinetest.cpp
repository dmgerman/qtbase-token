begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the test suite of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qbaselinetest.h"
end_include
begin_include
include|#
directive|include
file|"baselineprotocol.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/QProcess>
end_include
begin_include
include|#
directive|include
file|<QtCore/QDir>
end_include
begin_define
DECL|macro|MAXCMDLINEARGS
define|#
directive|define
name|MAXCMDLINEARGS
value|128
end_define
begin_namespace
DECL|namespace|QBaselineTest
namespace|namespace
name|QBaselineTest
block|{
DECL|member|fargv
specifier|static
name|char
modifier|*
name|fargv
index|[
name|MAXCMDLINEARGS
index|]
decl_stmt|;
DECL|member|simfail
specifier|static
name|bool
name|simfail
init|=
literal|false
decl_stmt|;
DECL|member|customInfo
specifier|static
name|PlatformInfo
name|customInfo
decl_stmt|;
DECL|member|customAutoModeSet
specifier|static
name|bool
name|customAutoModeSet
init|=
literal|false
decl_stmt|;
DECL|member|proto
specifier|static
name|BaselineProtocol
name|proto
decl_stmt|;
DECL|member|connected
specifier|static
name|bool
name|connected
init|=
literal|false
decl_stmt|;
DECL|member|triedConnecting
specifier|static
name|bool
name|triedConnecting
init|=
literal|false
decl_stmt|;
DECL|member|dryRunMode
specifier|static
name|bool
name|dryRunMode
init|=
literal|false
decl_stmt|;
DECL|member|curFunction
specifier|static
name|QByteArray
name|curFunction
decl_stmt|;
DECL|member|itemList
specifier|static
name|ImageItemList
name|itemList
decl_stmt|;
DECL|member|gotBaselines
specifier|static
name|bool
name|gotBaselines
decl_stmt|;
DECL|member|definedTestProject
specifier|static
name|QString
name|definedTestProject
decl_stmt|;
DECL|member|definedTestCase
specifier|static
name|QString
name|definedTestCase
decl_stmt|;
DECL|function|handleCmdLineArgs
name|void
name|handleCmdLineArgs
parameter_list|(
name|int
modifier|*
name|argcp
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|argvp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|argcp
operator|||
operator|!
name|argvp
condition|)
return|return;
name|bool
name|showHelp
init|=
literal|false
decl_stmt|;
name|int
name|fargc
init|=
literal|0
decl_stmt|;
name|int
name|numArgs
init|=
operator|*
name|argcp
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numArgs
condition|;
name|i
operator|++
control|)
block|{
name|QByteArray
name|arg
init|=
operator|(
operator|*
name|argvp
operator|)
index|[
name|i
index|]
decl_stmt|;
name|QByteArray
name|nextArg
init|=
operator|(
name|i
operator|+
literal|1
operator|<
name|numArgs
operator|)
condition|?
operator|(
operator|*
name|argvp
operator|)
index|[
name|i
operator|+
literal|1
index|]
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|"-simfail"
condition|)
block|{
name|simfail
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-auto"
condition|)
block|{
name|customAutoModeSet
operator|=
literal|true
expr_stmt|;
name|customInfo
operator|.
name|setAdHocRun
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-adhoc"
condition|)
block|{
name|customAutoModeSet
operator|=
literal|true
expr_stmt|;
name|customInfo
operator|.
name|setAdHocRun
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-compareto"
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|int
name|split
init|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|nextArg
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
argument_list|)
decl_stmt|;
name|QByteArray
name|key
init|=
name|nextArg
operator|.
name|left
argument_list|(
name|split
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|QByteArray
name|value
init|=
name|nextArg
operator|.
name|mid
argument_list|(
name|split
operator|+
literal|1
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|isEmpty
argument_list|()
operator|||
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"-compareto requires parameter of the form<key>=<value>"
expr_stmt|;
name|showHelp
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|customInfo
operator|.
name|addOverride
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|arg
operator|==
literal|"-help"
operator|)
operator|||
operator|(
name|arg
operator|==
literal|"--help"
operator|)
condition|)
name|showHelp
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|fargc
operator|>=
name|MAXCMDLINEARGS
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Too many command line arguments!"
expr_stmt|;
break|break;
block|}
name|fargv
index|[
name|fargc
operator|++
index|]
operator|=
operator|(
operator|*
name|argvp
operator|)
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
operator|*
name|argcp
operator|=
name|fargc
expr_stmt|;
operator|*
name|argvp
operator|=
name|fargv
expr_stmt|;
if|if
condition|(
name|showHelp
condition|)
block|{
comment|// TBD: arrange for this to be printed *after* QTest's help
name|QTextStream
name|out
argument_list|(
name|stdout
argument_list|)
decl_stmt|;
name|out
operator|<<
literal|"\n Baseline testing (lancelot) options:\n"
expr_stmt|;
name|out
operator|<<
literal|" -simfail            : Force an image comparison mismatch. For testing purposes.\n"
expr_stmt|;
name|out
operator|<<
literal|" -auto               : Inform server that this run is done by a daemon, CI system or similar.\n"
expr_stmt|;
name|out
operator|<<
literal|" -adhoc (default)    : The inverse of -auto; this run is done by human, e.g. for testing.\n"
expr_stmt|;
name|out
operator|<<
literal|" -compareto KEY=VAL  : Force comparison to baselines from a different client,\n"
expr_stmt|;
name|out
operator|<<
literal|"                       for example: -compareto QtVersion=4.8.0\n"
expr_stmt|;
name|out
operator|<<
literal|"                       Multiple -compareto client specifications may be given.\n"
expr_stmt|;
name|out
operator|<<
literal|"\n"
expr_stmt|;
block|}
block|}
DECL|function|addClientProperty
name|void
name|addClientProperty
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|customInfo
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/*   If a client property script is present, run it and accept its output   in the form of one 'key: value' property per line */
DECL|function|fetchCustomClientProperties
name|void
name|fetchCustomClientProperties
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_NO_PROCESS
name|QSKIP
argument_list|(
literal|"This test requires QProcess support"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QString
name|script
init|=
literal|"hostinfo.sh"
decl_stmt|;
comment|//### TBD: Windows implementation (hostinfo.bat)
name|QProcess
name|runScript
decl_stmt|;
name|runScript
operator|.
name|setWorkingDirectory
argument_list|(
name|QCoreApplication
operator|::
name|applicationDirPath
argument_list|()
argument_list|)
expr_stmt|;
name|runScript
operator|.
name|start
argument_list|(
literal|"sh"
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|script
argument_list|,
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|runScript
operator|.
name|waitForFinished
argument_list|(
literal|5000
argument_list|)
operator|||
name|runScript
operator|.
name|error
argument_list|()
operator|!=
name|QProcess
operator|::
name|UnknownError
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QBaselineTest: Error running script"
operator|<<
name|runScript
operator|.
name|workingDirectory
argument_list|()
operator|+
name|QDir
operator|::
name|separator
argument_list|()
operator|+
name|script
operator|<<
literal|":"
operator|<<
name|runScript
operator|.
name|errorString
argument_list|()
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"  stderr:"
operator|<<
name|runScript
operator|.
name|readAllStandardError
argument_list|()
operator|.
name|trimmed
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|runScript
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
init|=
name|runScript
operator|.
name|readLine
argument_list|()
operator|.
name|trimmed
argument_list|()
decl_stmt|;
comment|// ###local8bit? utf8?
name|QString
name|key
decl_stmt|,
name|val
decl_stmt|;
name|int
name|colonPos
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|colonPos
operator|>
literal|0
condition|)
block|{
name|key
operator|=
name|line
operator|.
name|left
argument_list|(
name|colonPos
argument_list|)
operator|.
name|simplified
argument_list|()
operator|.
name|replace
argument_list|(
literal|' '
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
name|val
operator|=
name|line
operator|.
name|mid
argument_list|(
name|colonPos
operator|+
literal|1
argument_list|)
operator|.
name|trimmed
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|key
operator|.
name|isEmpty
argument_list|()
operator|&&
name|key
operator|.
name|length
argument_list|()
operator|<
literal|64
operator|&&
name|val
operator|.
name|length
argument_list|()
operator|<
literal|256
condition|)
comment|// ###TBD: maximum 256 chars in value?
name|addClientProperty
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|qDebug
argument_list|()
operator|<<
literal|"Unparseable script output ignored:"
operator|<<
name|line
expr_stmt|;
block|}
endif|#
directive|endif
comment|// !QT_NO_PROCESS
block|}
DECL|function|connect
name|bool
name|connect
parameter_list|(
name|QByteArray
modifier|*
name|msg
parameter_list|,
name|bool
modifier|*
name|error
parameter_list|)
block|{
if|if
condition|(
name|connected
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|triedConnecting
condition|)
block|{
comment|// Avoid repeated connection attempts, to avoid the program using Timeout * #testItems seconds before giving up
operator|*
name|msg
operator|=
literal|"Not connected to baseline server."
expr_stmt|;
operator|*
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
name|triedConnecting
operator|=
literal|true
expr_stmt|;
name|fetchCustomClientProperties
argument_list|()
expr_stmt|;
comment|// Merge the platform info set by the program with the protocols default info
name|PlatformInfo
name|clientInfo
init|=
name|customInfo
decl_stmt|;
name|PlatformInfo
name|defaultInfo
init|=
name|PlatformInfo
operator|::
name|localHostInfo
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|QString
name|key
decl|,
name|defaultInfo
operator|.
name|keys
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|clientInfo
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
name|clientInfo
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|defaultInfo
operator|.
name|value
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|customAutoModeSet
condition|)
name|clientInfo
operator|.
name|setAdHocRun
argument_list|(
name|defaultInfo
operator|.
name|isAdHocRun
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|definedTestProject
operator|.
name|isEmpty
argument_list|()
condition|)
name|clientInfo
operator|.
name|insert
argument_list|(
name|PI_Project
argument_list|,
name|definedTestProject
argument_list|)
expr_stmt|;
name|QString
name|testCase
init|=
name|definedTestCase
decl_stmt|;
if|if
condition|(
name|testCase
operator|.
name|isEmpty
argument_list|()
operator|&&
name|QTest
operator|::
name|testObject
argument_list|()
operator|&&
name|QTest
operator|::
name|testObject
argument_list|()
operator|->
name|metaObject
argument_list|()
condition|)
block|{
comment|//qDebug()<< "Trying to Read TestCaseName from Testlib!";
name|testCase
operator|=
name|QTest
operator|::
name|testObject
argument_list|()
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|testCase
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QBaselineTest::connect: No test case name specified, cannot connect."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|proto
operator|.
name|connect
argument_list|(
name|testCase
argument_list|,
operator|&
name|dryRunMode
argument_list|,
name|clientInfo
argument_list|)
condition|)
block|{
operator|*
name|msg
operator|+=
literal|"Failed to connect to baseline server: "
operator|+
name|proto
operator|.
name|errorMessage
argument_list|()
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
operator|*
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
name|connected
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|disconnectFromBaselineServer
name|bool
name|disconnectFromBaselineServer
parameter_list|()
block|{
if|if
condition|(
name|proto
operator|.
name|disconnect
argument_list|()
condition|)
block|{
name|connected
operator|=
literal|false
expr_stmt|;
name|triedConnecting
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|connectToBaselineServer
name|bool
name|connectToBaselineServer
parameter_list|(
name|QByteArray
modifier|*
name|msg
parameter_list|,
specifier|const
name|QString
modifier|&
name|testProject
parameter_list|,
specifier|const
name|QString
modifier|&
name|testCase
parameter_list|)
block|{
name|bool
name|dummy
decl_stmt|;
name|QByteArray
name|dummyMsg
decl_stmt|;
name|definedTestProject
operator|=
name|testProject
expr_stmt|;
name|definedTestCase
operator|=
name|testCase
expr_stmt|;
return|return
name|connect
argument_list|(
name|msg
condition|?
name|msg
else|:
operator|&
name|dummyMsg
argument_list|,
operator|&
name|dummy
argument_list|)
return|;
block|}
DECL|function|setAutoMode
name|void
name|setAutoMode
parameter_list|(
name|bool
name|mode
parameter_list|)
block|{
name|customInfo
operator|.
name|setAdHocRun
argument_list|(
operator|!
name|mode
argument_list|)
expr_stmt|;
name|customAutoModeSet
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|setSimFail
name|void
name|setSimFail
parameter_list|(
name|bool
name|fail
parameter_list|)
block|{
name|simfail
operator|=
name|fail
expr_stmt|;
block|}
DECL|function|modifyImage
name|void
name|modifyImage
parameter_list|(
name|QImage
modifier|*
name|img
parameter_list|)
block|{
name|uint
name|c0
init|=
literal|0x0000ff00
decl_stmt|;
name|uint
name|c1
init|=
literal|0x0080ff00
decl_stmt|;
name|img
operator|->
name|setPixel
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|c0
argument_list|)
expr_stmt|;
name|img
operator|->
name|setPixel
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|img
operator|->
name|setPixel
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|,
name|c0
argument_list|)
expr_stmt|;
name|img
operator|->
name|setPixel
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|img
operator|->
name|setPixel
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|,
name|c0
argument_list|)
expr_stmt|;
name|img
operator|->
name|setPixel
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|img
operator|->
name|setPixel
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|,
name|c0
argument_list|)
expr_stmt|;
name|img
operator|->
name|setPixel
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|img
operator|->
name|setPixel
argument_list|(
literal|1
argument_list|,
literal|5
argument_list|,
name|c0
argument_list|)
expr_stmt|;
block|}
DECL|function|compareItem
name|bool
name|compareItem
parameter_list|(
specifier|const
name|ImageItem
modifier|&
name|baseline
parameter_list|,
specifier|const
name|QImage
modifier|&
name|img
parameter_list|,
name|QByteArray
modifier|*
name|msg
parameter_list|,
name|bool
modifier|*
name|error
parameter_list|)
block|{
name|ImageItem
name|item
init|=
name|baseline
decl_stmt|;
if|if
condition|(
name|simfail
condition|)
block|{
comment|// Simulate test failure by forcing image mismatch; for testing purposes
name|QImage
name|misImg
init|=
name|img
decl_stmt|;
name|modifyImage
argument_list|(
operator|&
name|misImg
argument_list|)
expr_stmt|;
name|item
operator|.
name|image
operator|=
name|misImg
expr_stmt|;
name|simfail
operator|=
literal|false
expr_stmt|;
comment|// One failure is typically enough
block|}
else|else
block|{
name|item
operator|.
name|image
operator|=
name|img
expr_stmt|;
block|}
name|item
operator|.
name|imageChecksums
operator|.
name|clear
argument_list|()
expr_stmt|;
name|item
operator|.
name|imageChecksums
operator|.
name|prepend
argument_list|(
name|ImageItem
operator|::
name|computeChecksum
argument_list|(
name|item
operator|.
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|QByteArray
name|srvMsg
decl_stmt|;
switch|switch
condition|(
name|baseline
operator|.
name|status
condition|)
block|{
case|case
name|ImageItem
operator|::
name|Ok
case|:
break|break;
case|case
name|ImageItem
operator|::
name|IgnoreItem
case|:
name|qDebug
argument_list|()
operator|<<
name|msg
operator|->
name|constData
argument_list|()
operator|<<
literal|"Ignored, blacklisted on server."
expr_stmt|;
return|return
literal|true
return|;
break|break;
case|case
name|ImageItem
operator|::
name|BaselineNotFound
case|:
if|if
condition|(
operator|!
name|customInfo
operator|.
name|overrides
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Cannot compare to other system's baseline: No such baseline found on server."
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|proto
operator|.
name|submitNewBaseline
argument_list|(
name|item
argument_list|,
operator|&
name|srvMsg
argument_list|)
condition|)
name|qDebug
argument_list|()
operator|<<
name|msg
operator|->
name|constData
argument_list|()
operator|<<
literal|"Baseline not found on server. New baseline uploaded."
expr_stmt|;
else|else
name|qDebug
argument_list|()
operator|<<
name|msg
operator|->
name|constData
argument_list|()
operator|<<
literal|"Baseline not found on server. Uploading of new baseline failed:"
operator|<<
name|srvMsg
expr_stmt|;
return|return
literal|true
return|;
break|break;
default|default:
name|qWarning
argument_list|()
operator|<<
literal|"Unexpected reply from baseline server."
expr_stmt|;
return|return
literal|true
return|;
break|break;
block|}
operator|*
name|error
operator|=
literal|false
expr_stmt|;
comment|// The actual comparison of the given image with the baseline:
if|if
condition|(
name|baseline
operator|.
name|imageChecksums
operator|.
name|contains
argument_list|(
name|item
operator|.
name|imageChecksums
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|proto
operator|.
name|submitMatch
argument_list|(
name|item
argument_list|,
operator|&
name|srvMsg
argument_list|)
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"Failed to report image match to server:"
operator|<<
name|srvMsg
expr_stmt|;
return|return
literal|true
return|;
block|}
name|bool
name|fuzzyMatch
init|=
literal|false
decl_stmt|;
name|bool
name|res
init|=
name|proto
operator|.
name|submitMismatch
argument_list|(
name|item
argument_list|,
operator|&
name|srvMsg
argument_list|,
operator|&
name|fuzzyMatch
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|&&
name|fuzzyMatch
condition|)
block|{
operator|*
name|error
operator|=
literal|true
expr_stmt|;
comment|// To force a QSKIP/debug output; somewhat kludgy
operator|*
name|msg
operator|+=
name|srvMsg
expr_stmt|;
return|return
literal|true
return|;
comment|// The server decides: a fuzzy match means no mismatch
block|}
operator|*
name|msg
operator|+=
literal|"Mismatch. See report:\n   "
operator|+
name|srvMsg
expr_stmt|;
if|if
condition|(
name|dryRunMode
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"Dryrun, so ignoring"
operator|<<
operator|*
name|msg
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|checkImage
name|bool
name|checkImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|img
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|quint16
name|checksum
parameter_list|,
name|QByteArray
modifier|*
name|msg
parameter_list|,
name|bool
modifier|*
name|error
parameter_list|,
name|int
name|manualdatatag
parameter_list|)
block|{
if|if
condition|(
operator|!
name|connected
operator|&&
operator|!
name|connect
argument_list|(
name|msg
argument_list|,
name|error
argument_list|)
condition|)
return|return
literal|true
return|;
name|QByteArray
name|itemName
decl_stmt|;
name|bool
name|hasName
init|=
name|qstrlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
init|=
name|QTest
operator|::
name|currentDataTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|qstrlen
argument_list|(
name|tag
argument_list|)
condition|)
block|{
name|itemName
operator|=
name|tag
expr_stmt|;
if|if
condition|(
name|hasName
condition|)
name|itemName
operator|.
name|append
argument_list|(
literal|'_'
argument_list|)
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|itemName
operator|=
name|hasName
condition|?
name|name
else|:
literal|"default_name"
expr_stmt|;
block|}
if|if
condition|(
name|manualdatatag
operator|>
literal|0
condition|)
block|{
name|itemName
operator|.
name|prepend
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|itemName
operator|.
name|prepend
argument_list|(
name|QByteArray
operator|::
name|number
argument_list|(
name|manualdatatag
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|msg
operator|=
literal|"Baseline check of image '"
operator|+
name|itemName
operator|+
literal|"': "
expr_stmt|;
name|ImageItem
name|item
decl_stmt|;
name|item
operator|.
name|itemName
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|itemName
argument_list|)
expr_stmt|;
name|item
operator|.
name|itemChecksum
operator|=
name|checksum
expr_stmt|;
name|item
operator|.
name|testFunction
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QTest
operator|::
name|currentTestFunction
argument_list|()
argument_list|)
expr_stmt|;
name|ImageItemList
name|list
decl_stmt|;
name|list
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proto
operator|.
name|requestBaselineChecksums
argument_list|(
name|QLatin1String
argument_list|(
name|QTest
operator|::
name|currentTestFunction
argument_list|()
argument_list|)
argument_list|,
operator|&
name|list
argument_list|)
operator|||
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|msg
operator|=
literal|"Communication with baseline server failed: "
operator|+
name|proto
operator|.
name|errorMessage
argument_list|()
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
operator|*
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|compareItem
argument_list|(
name|list
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|,
name|img
argument_list|,
name|msg
argument_list|,
name|error
argument_list|)
return|;
block|}
DECL|function|newRow
name|QTestData
modifier|&
name|newRow
parameter_list|(
specifier|const
name|char
modifier|*
name|dataTag
parameter_list|,
name|quint16
name|checksum
parameter_list|)
block|{
if|if
condition|(
name|QTest
operator|::
name|currentTestFunction
argument_list|()
operator|!=
name|curFunction
condition|)
block|{
name|curFunction
operator|=
name|QTest
operator|::
name|currentTestFunction
argument_list|()
expr_stmt|;
name|itemList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|gotBaselines
operator|=
literal|false
expr_stmt|;
block|}
name|ImageItem
name|item
decl_stmt|;
name|item
operator|.
name|itemName
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|dataTag
argument_list|)
expr_stmt|;
name|item
operator|.
name|itemChecksum
operator|=
name|checksum
expr_stmt|;
name|item
operator|.
name|testFunction
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QTest
operator|::
name|currentTestFunction
argument_list|()
argument_list|)
expr_stmt|;
name|itemList
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
name|QTest
operator|::
name|newRow
argument_list|(
name|dataTag
argument_list|)
return|;
block|}
DECL|function|testImage
name|bool
name|testImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|img
parameter_list|,
name|QByteArray
modifier|*
name|msg
parameter_list|,
name|bool
modifier|*
name|error
parameter_list|)
block|{
if|if
condition|(
operator|!
name|connected
operator|&&
operator|!
name|connect
argument_list|(
name|msg
argument_list|,
name|error
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|QTest
operator|::
name|currentTestFunction
argument_list|()
operator|!=
name|curFunction
operator|||
name|itemList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Usage error: QBASELINE_TEST used without corresponding QBaselineTest::newRow()"
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|gotBaselines
condition|)
block|{
if|if
condition|(
operator|!
name|proto
operator|.
name|requestBaselineChecksums
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QTest
operator|::
name|currentTestFunction
argument_list|()
argument_list|)
argument_list|,
operator|&
name|itemList
argument_list|)
operator|||
name|itemList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|msg
operator|=
literal|"Communication with baseline server failed: "
operator|+
name|proto
operator|.
name|errorMessage
argument_list|()
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
operator|*
name|error
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
name|gotBaselines
operator|=
literal|true
expr_stmt|;
block|}
name|QString
name|curTag
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QTest
operator|::
name|currentDataTag
argument_list|()
argument_list|)
decl_stmt|;
name|ImageItemList
operator|::
name|const_iterator
name|it
init|=
name|itemList
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|itemList
operator|.
name|constEnd
argument_list|()
operator|&&
name|it
operator|->
name|itemName
operator|!=
name|curTag
condition|)
operator|++
name|it
expr_stmt|;
if|if
condition|(
name|it
operator|==
name|itemList
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Usage error: QBASELINE_TEST used without corresponding QBaselineTest::newRow() for row"
operator|<<
name|curTag
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|compareItem
argument_list|(
operator|*
name|it
argument_list|,
name|img
argument_list|,
name|msg
argument_list|,
name|error
argument_list|)
return|;
block|}
block|}
end_namespace
end_unit
