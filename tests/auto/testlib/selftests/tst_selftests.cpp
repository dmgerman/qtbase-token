begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the test suite of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtCore/QCoreApplication>
end_include
begin_include
include|#
directive|include
file|<QtCore/QXmlStreamReader>
end_include
begin_include
include|#
directive|include
file|<QtCore/QFileInfo>
end_include
begin_include
include|#
directive|include
file|<QtCore/QDir>
end_include
begin_include
include|#
directive|include
file|<QtCore/QTemporaryDir>
end_include
begin_include
include|#
directive|include
file|<QtTest/QtTest>
end_include
begin_include
include|#
directive|include
file|<private/cycle_p.h>
end_include
begin_struct_decl
struct_decl|struct
name|LoggerSet
struct_decl|;
end_struct_decl
begin_class
DECL|class|tst_Selftests
class|class
name|tst_Selftests
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
name|tst_Selftests
parameter_list|()
constructor_decl|;
private|private
name|slots
private|:
name|void
name|initTestCase
parameter_list|()
function_decl|;
name|void
name|runSubTest_data
parameter_list|()
function_decl|;
name|void
name|runSubTest
parameter_list|()
function_decl|;
name|void
name|cleanup
parameter_list|()
function_decl|;
private|private:
name|void
name|doRunSubTest
parameter_list|(
name|QString
specifier|const
modifier|&
name|subdir
parameter_list|,
name|QStringList
specifier|const
modifier|&
name|loggers
parameter_list|,
name|QStringList
specifier|const
modifier|&
name|arguments
parameter_list|)
function_decl|;
name|QString
name|logName
parameter_list|(
specifier|const
name|QString
modifier|&
name|logger
parameter_list|)
specifier|const
function_decl|;
name|QList
argument_list|<
name|LoggerSet
argument_list|>
name|allLoggerSets
parameter_list|()
specifier|const
function_decl|;
DECL|member|tempDir
name|QTemporaryDir
name|tempDir
decl_stmt|;
block|}
class|;
end_class
begin_struct
DECL|struct|BenchmarkResult
struct|struct
name|BenchmarkResult
block|{
DECL|member|total
name|qint64
name|total
decl_stmt|;
DECL|member|iterations
name|qint64
name|iterations
decl_stmt|;
DECL|member|unit
name|QString
name|unit
decl_stmt|;
DECL|function|toString
specifier|inline
name|QString
name|toString
parameter_list|()
specifier|const
block|{
return|return
name|QString
argument_list|(
literal|"total:%1, unit:%2, iterations:%3"
argument_list|)
operator|.
name|arg
argument_list|(
name|total
argument_list|)
operator|.
name|arg
argument_list|(
name|unit
argument_list|)
operator|.
name|arg
argument_list|(
name|iterations
argument_list|)
return|;
block|}
specifier|static
name|BenchmarkResult
name|parse
parameter_list|(
name|QString
specifier|const
modifier|&
parameter_list|,
name|QString
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_namespace
DECL|namespace|QTest
namespace|namespace
name|QTest
block|{
template|template
parameter_list|<>
DECL|function|qCompare
specifier|inline
name|bool
name|qCompare
parameter_list|(
name|BenchmarkResult
specifier|const
modifier|&
name|r1
parameter_list|,
name|BenchmarkResult
specifier|const
modifier|&
name|r2
parameter_list|,
specifier|const
name|char
modifier|*
name|actual
parameter_list|,
specifier|const
name|char
modifier|*
name|expected
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
comment|// First make sure the iterations and unit match.
if|if
condition|(
name|r1
operator|.
name|iterations
operator|!=
name|r2
operator|.
name|iterations
operator|||
name|r1
operator|.
name|unit
operator|!=
name|r2
operator|.
name|unit
condition|)
block|{
comment|// Nope - compare whole string for best failure message
return|return
name|qCompare
argument_list|(
name|r1
operator|.
name|toString
argument_list|()
argument_list|,
name|r2
operator|.
name|toString
argument_list|()
argument_list|,
name|actual
argument_list|,
name|expected
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
comment|// Now check the value.  Some variance is allowed, and how much depends on
comment|// the measured unit.
name|qreal
name|variance
init|=
literal|0.
decl_stmt|;
if|if
condition|(
name|r1
operator|.
name|unit
operator|==
literal|"msec"
condition|)
block|{
name|variance
operator|=
literal|0.1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|.
name|unit
operator|==
literal|"instruction reads"
condition|)
block|{
name|variance
operator|=
literal|0.001
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|.
name|unit
operator|==
literal|"ticks"
condition|)
block|{
name|variance
operator|=
literal|0.001
expr_stmt|;
block|}
if|if
condition|(
name|variance
operator|==
literal|0.
condition|)
block|{
comment|// No variance allowed - compare whole string
return|return
name|qCompare
argument_list|(
name|r1
operator|.
name|toString
argument_list|()
argument_list|,
name|r2
operator|.
name|toString
argument_list|()
argument_list|,
name|actual
argument_list|,
name|expected
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
if|if
condition|(
name|qAbs
argument_list|(
name|qreal
argument_list|(
name|r1
operator|.
name|total
argument_list|)
operator|-
name|qreal
argument_list|(
name|r2
operator|.
name|total
argument_list|)
argument_list|)
operator|<=
name|qreal
argument_list|(
name|r1
operator|.
name|total
argument_list|)
operator|*
name|variance
condition|)
block|{
return|return
name|compare_helper
argument_list|(
literal|true
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|actual
argument_list|,
name|expected
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
comment|// Whoops, didn't match.  Compare the whole string for the most useful failure message.
return|return
name|qCompare
argument_list|(
name|r1
operator|.
name|toString
argument_list|()
argument_list|,
name|r2
operator|.
name|toString
argument_list|()
argument_list|,
name|actual
argument_list|,
name|expected
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
block|}
end_namespace
begin_function
name|QT_END_NAMESPACE
comment|// Split the passed block of text into an array of lines, replacing any
comment|// filenames and line numbers with generic markers to avoid failing the test
comment|// due to compiler-specific behaviour.
DECL|function|splitLines
specifier|static
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|splitLines
parameter_list|(
name|QByteArray
name|ba
parameter_list|)
block|{
name|ba
operator|.
name|replace
argument_list|(
literal|'\r'
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|out
init|=
name|ba
operator|.
name|split
argument_list|(
literal|'\n'
argument_list|)
decl_stmt|;
comment|// Replace any ` file="..."' or ` line="..."'  in XML with a generic location.
specifier|static
specifier|const
name|char
modifier|*
name|markers
index|[]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|" file=\""
block|,
literal|" file=\"__FILE__\""
block|}
block|,
block|{
literal|" line=\""
block|,
literal|" line=\"__LINE__\""
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|markerCount
init|=
sizeof|sizeof
name|markers
operator|/
sizeof|sizeof
name|markers
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|out
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QByteArray
modifier|&
name|line
init|=
name|out
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|markerCount
condition|;
operator|++
name|j
control|)
block|{
name|int
name|index
init|=
name|line
operator|.
name|indexOf
argument_list|(
name|markers
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
specifier|const
name|int
name|end
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|,
name|index
operator|+
name|int
argument_list|(
name|strlen
argument_list|(
name|markers
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
name|line
operator|.
name|replace
argument_list|(
name|index
argument_list|,
name|end
operator|-
name|index
operator|+
literal|1
argument_list|,
name|markers
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|// Return the log format, e.g. for both "stdout txt" and "txt", return "txt'.
end_comment
begin_function
DECL|function|logFormat
specifier|static
specifier|inline
name|QString
name|logFormat
parameter_list|(
specifier|const
name|QString
modifier|&
name|logger
parameter_list|)
block|{
return|return
operator|(
name|logger
operator|.
name|startsWith
argument_list|(
literal|"stdout"
argument_list|)
condition|?
name|logger
operator|.
name|mid
argument_list|(
literal|7
argument_list|)
else|:
name|logger
operator|)
return|;
block|}
end_function
begin_comment
comment|// Return the log file name, or an empty string if the log goes to stdout.
end_comment
begin_function
DECL|function|logName
name|QString
name|tst_Selftests
operator|::
name|logName
parameter_list|(
specifier|const
name|QString
modifier|&
name|logger
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|logger
operator|.
name|startsWith
argument_list|(
literal|"stdout"
argument_list|)
condition|?
literal|""
else|:
name|QString
argument_list|(
name|tempDir
operator|.
name|path
argument_list|()
operator|+
literal|"/test_output."
operator|+
name|logger
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|// Load the expected test output for the nominated test (subdir) and logger
end_comment
begin_comment
comment|// as an array of lines.  If there is no expected output file, return an
end_comment
begin_comment
comment|// empty array.
end_comment
begin_function
DECL|function|expectedResult
specifier|static
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|expectedResult
parameter_list|(
specifier|const
name|QString
modifier|&
name|subdir
parameter_list|,
specifier|const
name|QString
modifier|&
name|logger
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
literal|":/expected_"
operator|+
name|subdir
operator|+
literal|"."
operator|+
name|logFormat
argument_list|(
name|logger
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
return|return
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
return|return
name|splitLines
argument_list|(
name|file
operator|.
name|readAll
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// Each test is run with a set of one or more test output loggers.
end_comment
begin_comment
comment|// This struct holds information about one such test.
end_comment
begin_struct
DECL|struct|LoggerSet
struct|struct
name|LoggerSet
block|{
DECL|function|LoggerSet
name|LoggerSet
parameter_list|(
name|QString
specifier|const
modifier|&
name|_name
parameter_list|,
name|QStringList
specifier|const
modifier|&
name|_loggers
parameter_list|,
name|QStringList
specifier|const
modifier|&
name|_arguments
parameter_list|)
member_init_list|:
name|name
argument_list|(
name|_name
argument_list|)
member_init_list|,
name|loggers
argument_list|(
name|_loggers
argument_list|)
member_init_list|,
name|arguments
argument_list|(
name|_arguments
argument_list|)
block|{ }
DECL|member|name
name|QString
name|name
decl_stmt|;
DECL|member|loggers
name|QStringList
name|loggers
decl_stmt|;
DECL|member|arguments
name|QStringList
name|arguments
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|// This function returns a list of all sets of loggers to be used for
end_comment
begin_comment
comment|// running each subtest.
end_comment
begin_function
DECL|function|allLoggerSets
name|QList
argument_list|<
name|LoggerSet
argument_list|>
name|tst_Selftests
operator|::
name|allLoggerSets
parameter_list|()
specifier|const
block|{
comment|// Note that in order to test XML output to standard output, the subtests
comment|// must not send output directly to stdout, bypassing Qt's output mechanisms
comment|// (e.g. via printf), otherwise the output may not be well-formed XML.
return|return
name|QList
argument_list|<
name|LoggerSet
argument_list|>
argument_list|()
comment|// Test with old-style options for a single logger
operator|<<
name|LoggerSet
argument_list|(
literal|"old stdout txt"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"stdout txt"
argument_list|,
name|QStringList
argument_list|()
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"old txt"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"txt"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"txt"
argument_list|)
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"old stdout xml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"stdout xml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-xml"
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"old xml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"xml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-xml"
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"xml"
argument_list|)
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"old stdout xunitxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"stdout xunitxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-xunitxml"
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"old xunitxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"xunitxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-xunitxml"
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"xunitxml"
argument_list|)
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"old stdout lightxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"stdout lightxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-lightxml"
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"old lightxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"lightxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-lightxml"
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"lightxml"
argument_list|)
argument_list|)
comment|// Test with new-style options for a single logger
operator|<<
name|LoggerSet
argument_list|(
literal|"new stdout txt"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"stdout txt"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-o"
operator|<<
literal|"-,txt"
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"new txt"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"txt"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"txt"
argument_list|)
operator|+
literal|",txt"
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"new stdout xml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"stdout xml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-o"
operator|<<
literal|"-,xml"
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"new xml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"xml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"xml"
argument_list|)
operator|+
literal|",xml"
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"new stdout xunitxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"stdout xunitxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-o"
operator|<<
literal|"-,xunitxml"
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"new xunitxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"xunitxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"xunitxml"
argument_list|)
operator|+
literal|",xunitxml"
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"new stdout lightxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"stdout lightxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-o"
operator|<<
literal|"-,lightxml"
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"new lightxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"lightxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"lightxml"
argument_list|)
operator|+
literal|",lightxml"
argument_list|)
comment|// Test with two loggers (don't test all 32 combinations, just a sample)
operator|<<
name|LoggerSet
argument_list|(
literal|"stdout txt + txt"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"stdout txt"
operator|<<
literal|"txt"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-o"
operator|<<
literal|"-,txt"
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"txt"
argument_list|)
operator|+
literal|",txt"
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"xml + stdout txt"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"xml"
operator|<<
literal|"stdout txt"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"xml"
argument_list|)
operator|+
literal|",xml"
operator|<<
literal|"-o"
operator|<<
literal|"-,txt"
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"txt + xunitxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"txt"
operator|<<
literal|"xunitxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"txt"
argument_list|)
operator|+
literal|",txt"
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"xunitxml"
argument_list|)
operator|+
literal|",xunitxml"
argument_list|)
operator|<<
name|LoggerSet
argument_list|(
literal|"lightxml + stdout xunitxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"lightxml"
operator|<<
literal|"stdout xunitxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"lightxml"
argument_list|)
operator|+
literal|",lightxml"
operator|<<
literal|"-o"
operator|<<
literal|"-,xunitxml"
argument_list|)
comment|// All loggers at the same time
operator|<<
name|LoggerSet
argument_list|(
literal|"all loggers"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"txt"
operator|<<
literal|"xml"
operator|<<
literal|"lightxml"
operator|<<
literal|"stdout txt"
operator|<<
literal|"xunitxml"
argument_list|,
name|QStringList
argument_list|()
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"txt"
argument_list|)
operator|+
literal|",txt"
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"xml"
argument_list|)
operator|+
literal|",xml"
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"lightxml"
argument_list|)
operator|+
literal|",lightxml"
operator|<<
literal|"-o"
operator|<<
literal|"-,txt"
operator|<<
literal|"-o"
operator|<<
name|logName
argument_list|(
literal|"xunitxml"
argument_list|)
operator|+
literal|",xunitxml"
argument_list|)
return|;
block|}
end_function
begin_constructor
DECL|function|tst_Selftests
name|tst_Selftests
operator|::
name|tst_Selftests
parameter_list|()
member_init_list|:
name|tempDir
argument_list|(
name|QDir
operator|::
name|tempPath
argument_list|()
operator|+
literal|"/tst_selftests.XXXXXX"
argument_list|)
block|{}
end_constructor
begin_function
DECL|function|initTestCase
name|void
name|tst_Selftests
operator|::
name|initTestCase
parameter_list|()
block|{
comment|//Detect the location of the sub programs
name|QString
name|subProgram
init|=
name|QLatin1String
argument_list|(
literal|"float/float"
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|subProgram
operator|=
name|QLatin1String
argument_list|(
literal|"float/float.exe"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QString
name|testdataDir
init|=
name|QFINDTESTDATA
argument_list|(
name|subProgram
argument_list|)
decl_stmt|;
if|if
condition|(
name|testdataDir
operator|.
name|lastIndexOf
argument_list|(
name|subProgram
argument_list|)
operator|>
literal|0
condition|)
name|testdataDir
operator|=
name|testdataDir
operator|.
name|left
argument_list|(
name|testdataDir
operator|.
name|lastIndexOf
argument_list|(
name|subProgram
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|testdataDir
operator|=
name|QCoreApplication
operator|::
name|applicationDirPath
argument_list|()
expr_stmt|;
comment|// chdir to our testdata path and execute helper apps relative to that.
name|QVERIFY2
argument_list|(
name|QDir
operator|::
name|setCurrent
argument_list|(
name|testdataDir
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
literal|"Could not chdir to "
operator|+
name|testdataDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|runSubTest_data
name|void
name|tst_Selftests
operator|::
name|runSubTest_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"subdir"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|QStringList
argument_list|>
argument_list|(
literal|"loggers"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|QStringList
argument_list|>
argument_list|(
literal|"arguments"
argument_list|)
expr_stmt|;
name|QStringList
name|tests
init|=
name|QStringList
argument_list|()
comment|//<< "alive"    // timer dependent
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
comment|// On windows, assert does nothing in release mode and blocks execution
comment|// with a popup window in debug mode.
operator|<<
literal|"assert"
endif|#
directive|endif
operator|<<
literal|"badxml"
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
comment|// Only run on platforms where callgrind is available.
operator|<<
literal|"benchlibcallgrind"
endif|#
directive|endif
operator|<<
literal|"benchlibcounting"
operator|<<
literal|"benchlibeventcounter"
operator|<<
literal|"benchliboptions"
operator|<<
literal|"cmptest"
operator|<<
literal|"commandlinedata"
operator|<<
literal|"counting"
operator|<<
literal|"crashes"
operator|<<
literal|"datatable"
operator|<<
literal|"datetime"
operator|<<
literal|"differentexec"
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_EXCEPTIONS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
comment|// Disable this test on Windows and for intel compiler, as the run-times
comment|// will popup dialogs with warnings that uncaught exceptions were thrown
operator|<<
literal|"exceptionthrow"
endif|#
directive|endif
operator|<<
literal|"expectfail"
operator|<<
literal|"failcleanup"
operator|<<
literal|"failinit"
operator|<<
literal|"failinitdata"
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
comment|// Disable this test on Windows, as the run-time will popup dialogs with warnings
operator|<<
literal|"fetchbogus"
endif|#
directive|endif
operator|<<
literal|"findtestdata"
operator|<<
literal|"float"
operator|<<
literal|"globaldata"
operator|<<
literal|"longstring"
operator|<<
literal|"maxwarnings"
operator|<<
literal|"multiexec"
operator|<<
literal|"printdatatags"
operator|<<
literal|"printdatatagswithglobaltags"
operator|<<
literal|"qexecstringlist"
operator|<<
literal|"silent"
operator|<<
literal|"singleskip"
operator|<<
literal|"skip"
operator|<<
literal|"skipcleanup"
operator|<<
literal|"skipinit"
operator|<<
literal|"skipinitdata"
operator|<<
literal|"sleep"
operator|<<
literal|"strcmp"
operator|<<
literal|"subtest"
operator|<<
literal|"verbose1"
operator|<<
literal|"verbose2"
operator|<<
literal|"warnings"
operator|<<
literal|"xunit"
decl_stmt|;
comment|// These tests are affected by timing and whether the CPU tick counter
comment|// is monotonically increasing.  They won't work on some machines so
comment|// leave them off by default.  Feel free to enable them for your own
comment|// testing by setting the QTEST_ENABLE_EXTRA_SELFTESTS environment
comment|// variable to something non-empty.
if|if
condition|(
operator|!
name|qgetenv
argument_list|(
literal|"QTEST_ENABLE_EXTRA_SELFTESTS"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|tests
operator|<<
literal|"benchlibtickcounter"
operator|<<
literal|"benchlibwalltime"
expr_stmt|;
foreach|foreach
control|(
name|LoggerSet
specifier|const
modifier|&
name|loggerSet
decl|,
name|allLoggerSets
argument_list|()
control|)
block|{
name|QStringList
name|loggers
init|=
name|loggerSet
operator|.
name|loggers
decl_stmt|;
foreach|foreach
control|(
name|QString
specifier|const
modifier|&
name|subtest
decl|,
name|tests
control|)
block|{
name|QStringList
name|arguments
init|=
name|loggerSet
operator|.
name|arguments
decl_stmt|;
if|if
condition|(
name|subtest
operator|==
literal|"commandlinedata"
condition|)
block|{
name|arguments
operator|<<
name|QString
argument_list|(
literal|"fiveTablePasses fiveTablePasses:fiveTablePasses_data1 -v2"
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtest
operator|==
literal|"benchlibcallgrind"
condition|)
block|{
name|arguments
operator|<<
literal|"-callgrind"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtest
operator|==
literal|"benchlibeventcounter"
condition|)
block|{
name|arguments
operator|<<
literal|"-eventcounter"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtest
operator|==
literal|"benchliboptions"
condition|)
block|{
name|arguments
operator|<<
literal|"-eventcounter"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtest
operator|==
literal|"benchlibtickcounter"
condition|)
block|{
name|arguments
operator|<<
literal|"-tickcounter"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtest
operator|==
literal|"badxml"
condition|)
block|{
name|arguments
operator|<<
literal|"-eventcounter"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtest
operator|==
literal|"benchlibcounting"
condition|)
block|{
name|arguments
operator|<<
literal|"-eventcounter"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtest
operator|==
literal|"printdatatags"
condition|)
block|{
name|arguments
operator|<<
literal|"-datatags"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtest
operator|==
literal|"printdatatagswithglobaltags"
condition|)
block|{
name|arguments
operator|<<
literal|"-datatags"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtest
operator|==
literal|"silent"
condition|)
block|{
name|arguments
operator|<<
literal|"-silent"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtest
operator|==
literal|"verbose1"
condition|)
block|{
name|arguments
operator|<<
literal|"-v1"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtest
operator|==
literal|"verbose2"
condition|)
block|{
name|arguments
operator|<<
literal|"-v2"
expr_stmt|;
block|}
comment|// These tests don't work right unless logging plain text to
comment|// standard output, either because they execute multiple test
comment|// objects or because they internally supply arguments to
comment|// themselves.
if|if
condition|(
name|loggerSet
operator|.
name|name
operator|!=
literal|"old stdout txt"
operator|&&
name|loggerSet
operator|.
name|name
operator|!=
literal|"new stdout txt"
condition|)
block|{
if|if
condition|(
name|subtest
operator|==
literal|"differentexec"
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|subtest
operator|==
literal|"multiexec"
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|subtest
operator|==
literal|"qexecstringlist"
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|subtest
operator|==
literal|"benchliboptions"
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|subtest
operator|==
literal|"printdatatags"
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|subtest
operator|==
literal|"printdatatagswithglobaltags"
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|subtest
operator|==
literal|"silent"
condition|)
block|{
continue|continue;
block|}
comment|// `crashes' will not output valid XML on platforms without a crash handler
if|if
condition|(
name|subtest
operator|==
literal|"crashes"
condition|)
block|{
continue|continue;
block|}
comment|// this test prints out some floats in the testlog and the formatting is
comment|// platform-specific and hard to predict.
if|if
condition|(
name|subtest
operator|==
literal|"float"
condition|)
block|{
continue|continue;
block|}
comment|// these tests are quite slow, and running them for all the loggers significantly
comment|// increases the overall test time.  They do not really relate to logging, so it
comment|// should be safe to run them just for the stdout loggers.
if|if
condition|(
name|subtest
operator|==
literal|"benchlibcallgrind"
operator|||
name|subtest
operator|==
literal|"sleep"
condition|)
block|{
continue|continue;
block|}
block|}
name|QTest
operator|::
name|newRow
argument_list|(
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"%1 %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|subtest
argument_list|)
operator|.
name|arg
argument_list|(
name|loggerSet
operator|.
name|name
argument_list|)
argument_list|)
argument_list|)
operator|<<
name|subtest
operator|<<
name|loggers
operator|<<
name|arguments
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|insertEnvironmentVariable
specifier|static
name|void
name|insertEnvironmentVariable
parameter_list|(
name|QString
specifier|const
modifier|&
name|name
parameter_list|,
name|QProcessEnvironment
modifier|&
name|result
parameter_list|)
block|{
specifier|const
name|QProcessEnvironment
name|systemEnvironment
init|=
name|QProcessEnvironment
operator|::
name|systemEnvironment
argument_list|()
decl_stmt|;
specifier|const
name|QString
name|value
init|=
name|systemEnvironment
operator|.
name|value
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|processEnvironment
specifier|static
specifier|inline
name|QProcessEnvironment
name|processEnvironment
parameter_list|()
block|{
name|QProcessEnvironment
name|result
decl_stmt|;
name|insertEnvironmentVariable
argument_list|(
name|QStringLiteral
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|// Preserve DISPLAY for X11 as some tests use Qt GUI.
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
name|insertEnvironmentVariable
argument_list|(
name|QStringLiteral
argument_list|(
literal|"DISPLAY"
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|insertEnvironmentVariable
argument_list|(
name|QStringLiteral
argument_list|(
literal|"QT_QPA_PLATFORM"
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__COVERAGESCANNER__
name|insertEnvironmentVariable
argument_list|(
name|QStringLiteral
argument_list|(
literal|"QT_TESTCOCOON_ACTIVE"
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|doRunSubTest
name|void
name|tst_Selftests
operator|::
name|doRunSubTest
parameter_list|(
name|QString
specifier|const
modifier|&
name|subdir
parameter_list|,
name|QStringList
specifier|const
modifier|&
name|loggers
parameter_list|,
name|QStringList
specifier|const
modifier|&
name|arguments
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
if|if
condition|(
name|arguments
operator|.
name|contains
argument_list|(
literal|"-callgrind"
argument_list|)
condition|)
block|{
name|QProcess
name|checkProcess
decl_stmt|;
name|QStringList
name|args
decl_stmt|;
name|args
operator|<<
name|QLatin1String
argument_list|(
literal|"--version"
argument_list|)
expr_stmt|;
name|checkProcess
operator|.
name|start
argument_list|(
name|QLatin1String
argument_list|(
literal|"valgrind"
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkProcess
operator|.
name|waitForFinished
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|QSKIP
argument_list|(
name|QString
argument_list|(
literal|"Valgrind broken or not available. Not running %1 test!"
argument_list|)
operator|.
name|arg
argument_list|(
name|subdir
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|QProcess
name|proc
decl_stmt|;
specifier|static
specifier|const
name|QProcessEnvironment
name|environment
init|=
name|processEnvironment
argument_list|()
decl_stmt|;
name|proc
operator|.
name|setProcessEnvironment
argument_list|(
name|environment
argument_list|)
expr_stmt|;
specifier|const
name|QString
name|path
init|=
name|subdir
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|subdir
decl_stmt|;
name|proc
operator|.
name|start
argument_list|(
name|path
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
name|QVERIFY2
argument_list|(
name|proc
operator|.
name|waitForStarted
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Cannot start '%1': %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|path
argument_list|,
name|proc
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY2
argument_list|(
name|proc
operator|.
name|waitForFinished
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|proc
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|actualOutputs
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|loggers
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|logFile
init|=
name|logName
argument_list|(
name|loggers
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|QByteArray
name|out
decl_stmt|;
if|if
condition|(
name|logFile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
operator|=
name|proc
operator|.
name|readAllStandardOutput
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QFile
name|file
argument_list|(
name|logFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
name|out
operator|=
name|file
operator|.
name|readAll
argument_list|()
expr_stmt|;
block|}
name|actualOutputs
operator|<<
name|out
expr_stmt|;
block|}
specifier|const
name|QByteArray
name|err
argument_list|(
name|proc
operator|.
name|readAllStandardError
argument_list|()
argument_list|)
decl_stmt|;
comment|// Some tests may output unpredictable strings to stderr, which we'll ignore.
comment|//
comment|// For instance, uncaught exceptions on Windows might say (depending on Windows
comment|// version and JIT debugger settings):
comment|// "This application has requested the Runtime to terminate it in an unusual way.
comment|// Please contact the application's support team for more information."
comment|//
comment|// Also, tests which use valgrind may generate warnings if the toolchain is
comment|// newer than the valgrind version, such that valgrind can't understand the
comment|// debug information on the binary.
if|if
condition|(
name|subdir
operator|!=
name|QLatin1String
argument_list|(
literal|"exceptionthrow"
argument_list|)
operator|&&
name|subdir
operator|!=
name|QLatin1String
argument_list|(
literal|"cmptest"
argument_list|)
comment|// QImage comparison requires QGuiApplication
operator|&&
name|subdir
operator|!=
name|QLatin1String
argument_list|(
literal|"fetchbogus"
argument_list|)
operator|&&
name|subdir
operator|!=
name|QLatin1String
argument_list|(
literal|"xunit"
argument_list|)
operator|&&
name|subdir
operator|!=
name|QLatin1String
argument_list|(
literal|"benchlibcallgrind"
argument_list|)
condition|)
name|QVERIFY2
argument_list|(
name|err
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|err
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|loggers
operator|.
name|count
argument_list|()
condition|;
operator|++
name|n
control|)
block|{
name|QString
name|logger
init|=
name|loggers
index|[
name|n
index|]
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|res
init|=
name|splitLines
argument_list|(
name|actualOutputs
index|[
name|n
index|]
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|exp
init|=
name|expectedResult
argument_list|(
name|subdir
argument_list|,
name|logger
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_CC_MSVC
comment|// MSVC formats double numbers differently
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
name|subdir
operator|==
name|QStringLiteral
argument_list|(
literal|"float"
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exp
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|exp
index|[
name|i
index|]
operator|.
name|replace
argument_list|(
literal|"e-07"
argument_list|,
literal|"e-007"
argument_list|)
expr_stmt|;
name|exp
index|[
name|i
index|]
operator|.
name|replace
argument_list|(
literal|"e+07"
argument_list|,
literal|"e+007"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// For the "crashes" test, there are multiple versions of the
comment|// expected output.  Load the one with the same line count as
comment|// the actual output.
if|if
condition|(
name|exp
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
block|{
name|QList
argument_list|<
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|>
name|expArr
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|tmp
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
do|do
block|{
name|tmp
operator|=
name|expectedResult
argument_list|(
name|subdir
operator|+
name|QString
argument_list|(
literal|"_%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|i
operator|++
argument_list|)
argument_list|,
name|logger
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|count
argument_list|()
condition|)
name|expArr
operator|+=
name|tmp
expr_stmt|;
block|}
do|while
condition|(
name|tmp
operator|.
name|count
argument_list|()
condition|)
do|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|expArr
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|res
operator|.
name|count
argument_list|()
operator|==
name|expArr
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|count
argument_list|()
condition|)
block|{
name|exp
operator|=
name|expArr
operator|.
name|at
argument_list|(
name|j
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|expArr
operator|.
name|count
argument_list|()
condition|)
block|{
name|QVERIFY2
argument_list|(
name|exp
operator|.
name|count
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"None of the expected output files for "
literal|"%1 format has matching line count."
argument_list|)
operator|.
name|arg
argument_list|(
name|loggers
operator|.
name|at
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|QVERIFY2
argument_list|(
name|res
operator|.
name|count
argument_list|()
operator|==
name|exp
operator|.
name|count
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Mismatch in line count: %1 != %2 (%3)."
argument_list|)
operator|.
name|arg
argument_list|(
name|res
operator|.
name|count
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|exp
operator|.
name|count
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|loggers
operator|.
name|at
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// By this point, we should have loaded a non-empty expected data file.
name|QVERIFY2
argument_list|(
name|exp
operator|.
name|count
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Expected test data for %1 format is empty or not found."
argument_list|)
operator|.
name|arg
argument_list|(
name|loggers
operator|.
name|at
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// For xml output formats, verify that the log is valid XML.
if|if
condition|(
name|logFormat
argument_list|(
name|logger
argument_list|)
operator|==
literal|"xunitxml"
operator|||
name|logFormat
argument_list|(
name|logger
argument_list|)
operator|==
literal|"xml"
operator|||
name|logFormat
argument_list|(
name|logger
argument_list|)
operator|==
literal|"lightxml"
condition|)
block|{
name|QByteArray
name|xml
argument_list|(
name|actualOutputs
index|[
name|n
index|]
argument_list|)
decl_stmt|;
comment|// lightxml intentionally skips the root element, which technically makes it
comment|// not valid XML.
comment|// We'll add that ourselves for the purpose of validation.
if|if
condition|(
name|logFormat
argument_list|(
name|logger
argument_list|)
operator|==
literal|"lightxml"
condition|)
block|{
name|xml
operator|.
name|prepend
argument_list|(
literal|"<root>"
argument_list|)
expr_stmt|;
name|xml
operator|.
name|append
argument_list|(
literal|"</root>"
argument_list|)
expr_stmt|;
block|}
name|QXmlStreamReader
name|reader
argument_list|(
name|xml
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|reader
operator|.
name|atEnd
argument_list|()
condition|)
name|reader
operator|.
name|readNext
argument_list|()
expr_stmt|;
name|QVERIFY2
argument_list|(
operator|!
name|reader
operator|.
name|error
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"line %1, col %2: %3"
argument_list|)
operator|.
name|arg
argument_list|(
name|reader
operator|.
name|lineNumber
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|reader
operator|.
name|columnNumber
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|reader
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Verify that the actual output is an acceptable match for the
comment|// expected output.
name|bool
name|benchmark
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QByteArray
name|line
init|=
name|res
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// the __FILE__ __LINE__ output is compiler dependent, skip it
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"   Loc: ["
argument_list|)
operator|&&
name|line
operator|.
name|endsWith
argument_list|(
literal|")]"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|line
operator|.
name|endsWith
argument_list|(
literal|" : failure location"
argument_list|)
condition|)
continue|continue;
specifier|const
name|QString
name|output
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|line
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|expected
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|exp
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|replace
argument_list|(
literal|"@INSERT_QT_VERSION_HERE@"
argument_list|,
name|QT_VERSION_STR
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|subdir
operator|==
literal|"assert"
operator|&&
name|output
operator|.
name|contains
argument_list|(
literal|"ASSERT: "
argument_list|)
operator|&&
name|expected
operator|.
name|contains
argument_list|(
literal|"ASSERT: "
argument_list|)
operator|&&
name|output
operator|!=
name|expected
condition|)
comment|// Q_ASSERT uses __FILE__, the exact contents of which are
comment|// undefined.  If we something that looks like a Q_ASSERT and we
comment|// were expecting to see a Q_ASSERT, we'll skip the line.
continue|continue;
elseif|else
if|if
condition|(
name|expected
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"FAIL!  : tst_Exception::throwException() Caught unhandled exce"
argument_list|)
argument_list|)
operator|&&
name|expected
operator|!=
name|output
condition|)
comment|// On some platforms we compile without RTTI, and as a result we never throw an exception.
name|QCOMPARE
argument_list|(
name|output
operator|.
name|simplified
argument_list|()
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"tst_Exception::throwException()"
argument_list|)
operator|.
name|simplified
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|benchmark
operator|||
name|line
operator|.
name|startsWith
argument_list|(
literal|"<BenchmarkResult"
argument_list|)
condition|)
block|{
comment|// Don't do a literal comparison for benchmark results, since
comment|// results have some natural variance.
name|QString
name|error
decl_stmt|;
name|BenchmarkResult
name|actualResult
init|=
name|BenchmarkResult
operator|::
name|parse
argument_list|(
name|output
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
name|QVERIFY2
argument_list|(
name|error
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"Actual line didn't parse as benchmark result: %1\nLine: %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|error
argument_list|)
operator|.
name|arg
argument_list|(
name|output
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|BenchmarkResult
name|expectedResult
init|=
name|BenchmarkResult
operator|::
name|parse
argument_list|(
name|expected
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
name|QVERIFY2
argument_list|(
name|error
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"Expected line didn't parse as benchmark result: %1\nLine: %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|error
argument_list|)
operator|.
name|arg
argument_list|(
name|expected
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|actualResult
argument_list|,
name|expectedResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QVERIFY2
argument_list|(
name|output
operator|==
name|expected
argument_list|,
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Mismatch at line %1 (%2): '%3' != '%4'"
argument_list|)
operator|.
name|arg
argument_list|(
name|i
argument_list|)
operator|.
name|arg
argument_list|(
name|loggers
operator|.
name|at
argument_list|(
name|n
argument_list|)
argument_list|,
name|output
argument_list|,
name|expected
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|benchmark
operator|=
name|line
operator|.
name|startsWith
argument_list|(
literal|"RESULT : "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|runSubTest
name|void
name|tst_Selftests
operator|::
name|runSubTest
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|subdir
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|QStringList
argument_list|,
name|loggers
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|QStringList
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
name|doRunSubTest
argument_list|(
name|subdir
argument_list|,
name|loggers
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// attribute must contain ="
end_comment
begin_function
DECL|function|extractXmlAttribute
name|QString
name|extractXmlAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|attribute
parameter_list|)
block|{
name|int
name|index
init|=
name|line
operator|.
name|indexOf
argument_list|(
name|attribute
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
return|return
name|QString
argument_list|()
return|;
specifier|const
name|int
name|attributeLength
init|=
name|int
argument_list|(
name|strlen
argument_list|(
name|attribute
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|int
name|end
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|,
name|index
operator|+
name|attributeLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
operator|-
literal|1
condition|)
return|return
name|QString
argument_list|()
return|;
specifier|const
name|QString
name|result
init|=
name|line
operator|.
name|mid
argument_list|(
name|index
operator|+
name|attributeLength
argument_list|,
name|end
operator|-
name|index
operator|-
name|attributeLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|""
return|;
comment|// ensure empty but not null
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|// Parse line into the BenchmarkResult it represents.
end_comment
begin_function
DECL|function|parse
name|BenchmarkResult
name|BenchmarkResult
operator|::
name|parse
parameter_list|(
name|QString
specifier|const
modifier|&
name|line
parameter_list|,
name|QString
modifier|*
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
name|QString
argument_list|()
expr_stmt|;
name|BenchmarkResult
name|out
decl_stmt|;
name|QString
name|remaining
init|=
name|line
operator|.
name|trimmed
argument_list|()
decl_stmt|;
if|if
condition|(
name|remaining
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
literal|"Line is empty"
expr_stmt|;
return|return
name|out
return|;
block|}
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"<BenchmarkResult "
argument_list|)
condition|)
block|{
comment|// XML result
comment|// format:
comment|//<BenchmarkResult metric="$unit" tag="$tag" value="$total" iterations="$iterations" />
if|if
condition|(
operator|!
name|line
operator|.
name|endsWith
argument_list|(
literal|"/>"
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
literal|"unterminated XML"
expr_stmt|;
return|return
name|out
return|;
block|}
name|QString
name|unit
init|=
name|extractXmlAttribute
argument_list|(
name|line
argument_list|,
literal|" metric=\""
argument_list|)
decl_stmt|;
name|QString
name|sTotal
init|=
name|extractXmlAttribute
argument_list|(
name|line
argument_list|,
literal|" value=\""
argument_list|)
decl_stmt|;
name|QString
name|sIterations
init|=
name|extractXmlAttribute
argument_list|(
name|line
argument_list|,
literal|" iterations=\""
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|.
name|isNull
argument_list|()
operator|||
name|sTotal
operator|.
name|isNull
argument_list|()
operator|||
name|sIterations
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
literal|"XML snippet did not contain all required values"
expr_stmt|;
return|return
name|out
return|;
block|}
name|bool
name|ok
decl_stmt|;
name|double
name|total
init|=
name|sTotal
operator|.
name|toDouble
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
name|sTotal
operator|+
literal|" is not a valid number"
expr_stmt|;
return|return
name|out
return|;
block|}
name|double
name|iterations
init|=
name|sIterations
operator|.
name|toDouble
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
name|sIterations
operator|+
literal|" is not a valid number"
expr_stmt|;
return|return
name|out
return|;
block|}
name|out
operator|.
name|unit
operator|=
name|unit
expr_stmt|;
name|out
operator|.
name|total
operator|=
name|total
expr_stmt|;
name|out
operator|.
name|iterations
operator|=
name|iterations
expr_stmt|;
return|return
name|out
return|;
block|}
comment|// Text result
comment|// This code avoids using a QRegExp because QRegExp might be broken.
comment|// Sample format: 4,000 msec per iteration (total: 4,000, iterations: 1)
name|QString
name|sFirstNumber
decl_stmt|;
while|while
condition|(
operator|!
name|remaining
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|remaining
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|sFirstNumber
operator|+=
name|remaining
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|remaining
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|remaining
operator|=
name|remaining
operator|.
name|trimmed
argument_list|()
expr_stmt|;
comment|// 4,000 -> 4000
name|sFirstNumber
operator|.
name|remove
argument_list|(
literal|','
argument_list|)
expr_stmt|;
comment|// Should now be parseable as floating point
name|bool
name|ok
decl_stmt|;
name|double
name|firstNumber
init|=
name|sFirstNumber
operator|.
name|toDouble
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
name|sFirstNumber
operator|+
literal|" (at beginning of line) is not a valid number"
expr_stmt|;
return|return
name|out
return|;
block|}
comment|// Remaining: msec per iteration (total: 4000, iterations: 1)
specifier|static
specifier|const
name|char
name|periterbit
index|[]
init|=
literal|" per iteration (total: "
decl_stmt|;
name|QString
name|unit
decl_stmt|;
while|while
condition|(
operator|!
name|remaining
operator|.
name|startsWith
argument_list|(
name|periterbit
argument_list|)
operator|&&
operator|!
name|remaining
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|unit
operator|+=
name|remaining
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|remaining
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remaining
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
literal|"Could not find pattern: '<unit> per iteration (total: '"
expr_stmt|;
return|return
name|out
return|;
block|}
name|remaining
operator|=
name|remaining
operator|.
name|mid
argument_list|(
sizeof|sizeof
argument_list|(
name|periterbit
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Remaining: 4,000, iterations: 1)
specifier|static
specifier|const
name|char
name|itersbit
index|[]
init|=
literal|", iterations: "
decl_stmt|;
name|QString
name|sTotal
decl_stmt|;
while|while
condition|(
operator|!
name|remaining
operator|.
name|startsWith
argument_list|(
name|itersbit
argument_list|)
operator|&&
operator|!
name|remaining
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sTotal
operator|+=
name|remaining
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|remaining
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remaining
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
literal|"Could not find pattern: '<number>, iterations: '"
expr_stmt|;
return|return
name|out
return|;
block|}
name|remaining
operator|=
name|remaining
operator|.
name|mid
argument_list|(
sizeof|sizeof
argument_list|(
name|itersbit
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// 4,000 -> 4000
name|sTotal
operator|.
name|remove
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|double
name|total
init|=
name|sTotal
operator|.
name|toDouble
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
name|sTotal
operator|+
literal|" (total) is not a valid number"
expr_stmt|;
return|return
name|out
return|;
block|}
comment|// Remaining: 1)
name|QString
name|sIters
decl_stmt|;
while|while
condition|(
name|remaining
operator|!=
name|QLatin1String
argument_list|(
literal|")"
argument_list|)
operator|&&
operator|!
name|remaining
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sIters
operator|+=
name|remaining
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|remaining
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remaining
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
literal|"Could not find pattern: '<num>)'"
expr_stmt|;
return|return
name|out
return|;
block|}
name|qint64
name|iters
init|=
name|sIters
operator|.
name|toLongLong
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
name|sIters
operator|+
literal|" (iterations) is not a valid integer"
expr_stmt|;
return|return
name|out
return|;
block|}
name|double
name|calcFirstNumber
init|=
name|double
argument_list|(
name|total
argument_list|)
operator|/
name|double
argument_list|(
name|iters
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qFuzzyCompare
argument_list|(
name|firstNumber
argument_list|,
name|calcFirstNumber
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
name|QString
argument_list|(
literal|"total/iters is %1, but benchlib output result as %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|calcFirstNumber
argument_list|)
operator|.
name|arg
argument_list|(
name|firstNumber
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
name|out
operator|.
name|total
operator|=
name|total
expr_stmt|;
name|out
operator|.
name|unit
operator|=
name|unit
expr_stmt|;
name|out
operator|.
name|iterations
operator|=
name|iters
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|cleanup
name|void
name|tst_Selftests
operator|::
name|cleanup
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QStringList
argument_list|,
name|loggers
argument_list|)
expr_stmt|;
comment|// Remove the test output files
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|loggers
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|logFileName
init|=
name|logName
argument_list|(
name|loggers
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|logFileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QFile
name|logFile
argument_list|(
name|logFileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|logFile
operator|.
name|exists
argument_list|()
condition|)
name|QVERIFY2
argument_list|(
name|logFile
operator|.
name|remove
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Cannot remove file '%1': %2: "
argument_list|)
operator|.
name|arg
argument_list|(
name|logFileName
argument_list|,
name|logFile
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_macro
name|QTEST_MAIN
argument_list|(
argument|tst_Selftests
argument_list|)
end_macro
begin_include
include|#
directive|include
file|"tst_selftests.moc"
end_include
end_unit
