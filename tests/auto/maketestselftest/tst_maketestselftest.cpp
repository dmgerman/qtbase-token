begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the test suite of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QDir>
end_include
begin_include
include|#
directive|include
file|<QFile>
end_include
begin_include
include|#
directive|include
file|<QRegExp>
end_include
begin_include
include|#
directive|include
file|<QStringList>
end_include
begin_include
include|#
directive|include
file|<QTest>
end_include
begin_include
include|#
directive|include
file|<QSet>
end_include
begin_include
include|#
directive|include
file|<QProcess>
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_enum
DECL|enum|FindSubdirsMode
enum|enum
name|FindSubdirsMode
block|{
DECL|enumerator|Flat
name|Flat
init|=
literal|0
block|,
DECL|enumerator|Recursive
name|Recursive
block|}
enum|;
end_enum
begin_class
DECL|class|tst_MakeTestSelfTest
class|class
name|tst_MakeTestSelfTest
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
private|private
name|slots
private|:
name|void
name|tests_auto_pro
parameter_list|()
function_decl|;
name|void
name|tests_pro_files
parameter_list|()
function_decl|;
name|void
name|tests_pro_files_data
parameter_list|()
function_decl|;
name|void
name|naming_convention
parameter_list|()
function_decl|;
name|void
name|naming_convention_data
parameter_list|()
function_decl|;
name|void
name|make_check
parameter_list|()
function_decl|;
private|private:
name|QStringList
name|find_subdirs
parameter_list|(
name|QString
specifier|const
modifier|&
parameter_list|,
name|FindSubdirsMode
parameter_list|,
name|QString
specifier|const
modifier|&
init|=
name|QString
argument_list|()
parameter_list|)
function_decl|;
DECL|member|all_test_classes
name|QSet
argument_list|<
name|QString
argument_list|>
name|all_test_classes
decl_stmt|;
block|}
class|;
end_class
begin_function_decl
name|bool
name|looks_like_testcase
parameter_list|(
name|QString
specifier|const
modifier|&
parameter_list|,
name|QString
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|bool
name|looks_like_subdirs
parameter_list|(
name|QString
specifier|const
modifier|&
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|QStringList
name|find_test_class
parameter_list|(
name|QString
specifier|const
modifier|&
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*     Verify that auto.pro only contains other .pro files (and not directories).     We enforce this so that we can process every .pro file other than auto.pro     independently and get all the tests.     If tests were allowed to appear directly in auto.pro, we'd have the problem     that we need to somehow run these tests from auto.pro while preventing     recursion into the other .pro files. */
end_comment
begin_function
DECL|function|tests_auto_pro
name|void
name|tst_MakeTestSelfTest
operator|::
name|tests_auto_pro
parameter_list|()
block|{
name|QStringList
name|subdirsList
init|=
name|find_subdirs
argument_list|(
name|SRCDIR
literal|"/../auto.pro"
argument_list|,
name|Flat
argument_list|)
decl_stmt|;
if|if
condition|(
name|QTest
operator|::
name|currentTestFailed
argument_list|()
condition|)
block|{
return|return;
block|}
foreach|foreach
control|(
name|QString
specifier|const
modifier|&
name|subdir
decl|,
name|subdirsList
control|)
block|{
name|QVERIFY2
argument_list|(
name|subdir
operator|.
name|endsWith
argument_list|(
literal|".pro"
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"auto.pro contains a subdir `%1'.\n"
literal|"auto.pro must _only_ contain other .pro files, not actual subdirs.\n"
literal|"Please move `%1' into some other .pro file referenced by auto.pro."
argument_list|)
operator|.
name|arg
argument_list|(
name|subdir
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Verify that all tests are listed somewhere in one of the autotest .pro files */
end_comment
begin_function
DECL|function|tests_pro_files
name|void
name|tst_MakeTestSelfTest
operator|::
name|tests_pro_files
parameter_list|()
block|{
specifier|static
name|QStringList
name|lines
decl_stmt|;
if|if
condition|(
name|lines
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QDir
name|dir
argument_list|(
name|SRCDIR
literal|"/.."
argument_list|)
decl_stmt|;
name|QStringList
name|proFiles
init|=
name|dir
operator|.
name|entryList
argument_list|(
name|QStringList
argument_list|()
operator|<<
literal|"*.pro"
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|QString
specifier|const
modifier|&
name|proFile
decl|,
name|proFiles
control|)
block|{
name|QString
name|filename
init|=
name|QString
argument_list|(
literal|"%1/../%2"
argument_list|)
operator|.
name|arg
argument_list|(
name|SRCDIR
argument_list|)
operator|.
name|arg
argument_list|(
name|proFile
argument_list|)
decl_stmt|;
name|QFile
name|file
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|QFAIL
argument_list|(
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"open %1: %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|filename
argument_list|)
operator|.
name|arg
argument_list|(
name|file
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|file
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|lines
operator|<<
name|file
operator|.
name|readLine
argument_list|()
operator|.
name|trimmed
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|subdir
argument_list|)
expr_stmt|;
name|QRegExp
name|re
argument_list|(
name|QString
argument_list|(
literal|"( |=|^|#)%1( |\\\\|$)"
argument_list|)
operator|.
name|arg
argument_list|(
name|QRegExp
operator|::
name|escape
argument_list|(
name|subdir
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|line
decl|,
name|lines
control|)
block|{
if|if
condition|(
name|re
operator|.
name|indexIn
argument_list|(
name|line
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
return|return;
block|}
block|}
name|QFAIL
argument_list|(
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"Subdir `%1' is missing from tests/auto/*.pro\n"
literal|"This means the test won't be compiled or run on any platform.\n"
literal|"If this is intentional, please put the test name in a comment in one of the .pro files."
argument_list|)
operator|.
name|arg
argument_list|(
name|subdir
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|tests_pro_files_data
name|void
name|tst_MakeTestSelfTest
operator|::
name|tests_pro_files_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"subdir"
argument_list|)
expr_stmt|;
name|QDir
name|dir
argument_list|(
name|SRCDIR
literal|"/.."
argument_list|)
decl_stmt|;
name|QStringList
name|subdirs
init|=
name|dir
operator|.
name|entryList
argument_list|(
name|QDir
operator|::
name|AllDirs
operator||
name|QDir
operator|::
name|NoDotAndDotDot
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|subdir
decl|,
name|subdirs
control|)
block|{
if|if
condition|(
name|subdir
operator|==
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"tmp"
argument_list|)
operator|||
name|subdir
operator|.
name|startsWith
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|QTest
operator|::
name|newRow
argument_list|(
name|qPrintable
argument_list|(
name|subdir
argument_list|)
argument_list|)
operator|<<
name|subdir
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|format_list
name|QString
name|format_list
parameter_list|(
name|QStringList
specifier|const
modifier|&
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|list
operator|.
name|at
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
name|QString
argument_list|(
literal|"one of (%1)"
argument_list|)
operator|.
name|arg
argument_list|(
name|list
operator|.
name|join
argument_list|(
literal|", "
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|naming_convention
name|void
name|tst_MakeTestSelfTest
operator|::
name|naming_convention
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|subdir
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|QDir
name|dir
argument_list|(
name|SRCDIR
literal|"/../"
operator|+
name|subdir
argument_list|)
decl_stmt|;
name|QStringList
name|cppfiles
init|=
name|dir
operator|.
name|entryList
argument_list|(
name|QStringList
argument_list|()
operator|<<
literal|"*.h"
operator|<<
literal|"*.cpp"
argument_list|)
decl_stmt|;
if|if
condition|(
name|cppfiles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Common convention is to have test/test.pro and source files in parent dir
if|if
condition|(
name|dir
operator|.
name|dirName
argument_list|()
operator|==
literal|"test"
condition|)
block|{
name|dir
operator|.
name|cdUp
argument_list|()
expr_stmt|;
name|cppfiles
operator|=
name|dir
operator|.
name|entryList
argument_list|(
name|QStringList
argument_list|()
operator|<<
literal|"*.h"
operator|<<
literal|"*.cpp"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cppfiles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QSKIP
argument_list|(
literal|"Couldn't locate source files for test"
argument_list|,
name|SkipSingle
argument_list|)
expr_stmt|;
block|}
block|}
name|QStringList
name|possible_test_classes
decl_stmt|;
foreach|foreach
control|(
name|QString
specifier|const
modifier|&
name|file
decl|,
name|cppfiles
control|)
block|{
name|possible_test_classes
operator|<<
name|find_test_class
argument_list|(
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/"
operator|+
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|possible_test_classes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QSKIP
argument_list|(
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"Couldn't locate test class in %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|format_list
argument_list|(
name|cppfiles
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|SkipSingle
argument_list|)
expr_stmt|;
block|}
name|QVERIFY2
argument_list|(
name|possible_test_classes
operator|.
name|contains
argument_list|(
name|target
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"TARGET is %1, while test class appears to be %2.\n"
literal|"TARGET and test class _must_ match so that all testcase names can be accurately "
literal|"determined even if a test fails to compile or run."
argument_list|)
operator|.
name|arg
argument_list|(
name|target
argument_list|)
operator|.
name|arg
argument_list|(
name|format_list
argument_list|(
name|possible_test_classes
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY2
argument_list|(
operator|!
name|all_test_classes
operator|.
name|contains
argument_list|(
name|target
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"It looks like there are multiple tests named %1.\n"
literal|"This makes it impossible to separate results for these tests.\n"
literal|"Please ensure all tests are uniquely named."
argument_list|)
operator|.
name|arg
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|all_test_classes
operator|<<
name|target
expr_stmt|;
block|}
end_function
begin_function
DECL|function|naming_convention_data
name|void
name|tst_MakeTestSelfTest
operator|::
name|naming_convention_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"subdir"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"target"
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|subdir
decl|,
name|find_subdirs
argument_list|(
name|SRCDIR
literal|"/../auto.pro"
argument_list|,
name|Recursive
argument_list|)
control|)
block|{
if|if
condition|(
name|QFileInfo
argument_list|(
name|SRCDIR
literal|"/../"
operator|+
name|subdir
argument_list|)
operator|.
name|isDir
argument_list|()
condition|)
block|{
name|QString
name|target
decl_stmt|;
if|if
condition|(
name|looks_like_testcase
argument_list|(
name|SRCDIR
literal|"/../"
operator|+
name|subdir
operator|+
literal|"/"
operator|+
name|QFileInfo
argument_list|(
name|subdir
argument_list|)
operator|.
name|baseName
argument_list|()
operator|+
literal|".pro"
argument_list|,
operator|&
name|target
argument_list|)
condition|)
block|{
name|QTest
operator|::
name|newRow
argument_list|(
name|qPrintable
argument_list|(
name|subdir
argument_list|)
argument_list|)
operator|<<
name|subdir
operator|<<
name|target
operator|.
name|toLower
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*     Returns true if a .pro file seems to be for an autotest.     Running qmake to figure this out takes too long. */
end_comment
begin_function
DECL|function|looks_like_testcase
name|bool
name|looks_like_testcase
parameter_list|(
name|QString
specifier|const
modifier|&
name|pro_file
parameter_list|,
name|QString
modifier|*
name|target
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|pro_file
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|target
operator|=
name|QString
argument_list|()
expr_stmt|;
name|bool
name|loaded_qttest
init|=
literal|false
decl_stmt|;
do|do
block|{
name|QByteArray
name|line
init|=
name|file
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
break|break;
block|}
name|line
operator|=
name|line
operator|.
name|trimmed
argument_list|()
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|' '
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|"load(qttest_p4)"
condition|)
block|{
name|loaded_qttest
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"TARGET="
argument_list|)
condition|)
block|{
operator|*
name|target
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|line
operator|.
name|mid
argument_list|(
sizeof|sizeof
argument_list|(
literal|"TARGET="
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|contains
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
operator|*
name|target
operator|=
name|target
operator|->
name|right
argument_list|(
name|target
operator|->
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|loaded_qttest
operator|&&
operator|!
name|target
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
if|if
condition|(
operator|!
name|loaded_qttest
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|target
operator|->
name|isEmpty
argument_list|()
operator|&&
operator|!
name|target
operator|->
name|startsWith
argument_list|(
literal|"tst_"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// If no target was set, default to tst_<dirname>
if|if
condition|(
name|target
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|target
operator|=
literal|"tst_"
operator|+
name|QFileInfo
argument_list|(
name|pro_file
argument_list|)
operator|.
name|baseName
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*     Returns true if a .pro file seems to be a subdirs project.     Running qmake to figure this out takes too long. */
end_comment
begin_function
DECL|function|looks_like_subdirs
name|bool
name|looks_like_subdirs
parameter_list|(
name|QString
specifier|const
modifier|&
name|pro_file
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|pro_file
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
do|do
block|{
name|QByteArray
name|line
init|=
name|file
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
break|break;
block|}
name|line
operator|=
name|line
operator|.
name|trimmed
argument_list|()
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|' '
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|"TEMPLATE=subdirs"
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*     Returns a list of all subdirs in a given .pro file */
end_comment
begin_function
DECL|function|find_subdirs
name|QStringList
name|tst_MakeTestSelfTest
operator|::
name|find_subdirs
parameter_list|(
name|QString
specifier|const
modifier|&
name|pro_file
parameter_list|,
name|FindSubdirsMode
name|mode
parameter_list|,
name|QString
specifier|const
modifier|&
name|prefix
parameter_list|)
block|{
name|QStringList
name|out
decl_stmt|;
name|QByteArray
name|features
init|=
name|qgetenv
argument_list|(
literal|"QMAKEFEATURES"
argument_list|)
decl_stmt|;
if|if
condition|(
name|features
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|features
operator|=
name|SRCDIR
literal|"/features"
expr_stmt|;
block|}
else|else
block|{
name|features
operator|.
name|prepend
argument_list|(
name|SRCDIR
literal|"/features"
ifdef|#
directive|ifdef
name|Q_OS_WIN32
literal|";"
else|#
directive|else
literal|":"
endif|#
directive|endif
argument_list|)
expr_stmt|;
block|}
name|QStringList
name|args
decl_stmt|;
name|args
operator|<<
name|pro_file
operator|<<
literal|"-o"
operator|<<
name|SRCDIR
literal|"/dummy_output"
operator|<<
literal|"CONFIG+=dump_subdirs"
expr_stmt|;
comment|/* Turn on every option there is, to ensure we process every single directory */
name|args
operator|<<
literal|"QT_CONFIG+=dbus"
operator|<<
literal|"QT_CONFIG+=declarative"
operator|<<
literal|"QT_CONFIG+=egl"
operator|<<
literal|"QT_CONFIG+=multimedia"
operator|<<
literal|"QT_CONFIG+=OdfWriter"
operator|<<
literal|"QT_CONFIG+=opengl"
operator|<<
literal|"QT_CONFIG+=openvg"
operator|<<
literal|"QT_CONFIG+=phonon"
operator|<<
literal|"QT_CONFIG+=private_tests"
operator|<<
literal|"QT_CONFIG+=pulseaudio"
operator|<<
literal|"QT_CONFIG+=qt3support"
operator|<<
literal|"QT_CONFIG+=script"
operator|<<
literal|"QT_CONFIG+=svg"
operator|<<
literal|"QT_CONFIG+=webkit"
operator|<<
literal|"QT_CONFIG+=xmlpatterns"
operator|<<
literal|"CONFIG+=mac"
operator|<<
literal|"CONFIG+=embedded"
operator|<<
literal|"CONFIG+=symbian"
expr_stmt|;
name|QString
name|cmd_with_args
init|=
name|QString
argument_list|(
literal|"qmake %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|args
operator|.
name|join
argument_list|(
literal|" "
argument_list|)
argument_list|)
decl_stmt|;
name|QProcess
name|proc
decl_stmt|;
name|proc
operator|.
name|setProcessChannelMode
argument_list|(
name|QProcess
operator|::
name|MergedChannels
argument_list|)
expr_stmt|;
name|QProcessEnvironment
name|env
init|=
name|QProcessEnvironment
operator|::
name|systemEnvironment
argument_list|()
decl_stmt|;
name|env
operator|.
name|insert
argument_list|(
literal|"QMAKEFEATURES"
argument_list|,
name|features
argument_list|)
expr_stmt|;
name|proc
operator|.
name|setProcessEnvironment
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|proc
operator|.
name|start
argument_list|(
literal|"qmake"
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc
operator|.
name|waitForStarted
argument_list|(
literal|10000
argument_list|)
condition|)
block|{
name|QTest
operator|::
name|qFail
argument_list|(
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"Failed to run qmake: %1\nCommand: %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|proc
operator|.
name|errorString
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|cmd_with_args
argument_list|)
argument_list|)
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
if|if
condition|(
operator|!
name|proc
operator|.
name|waitForFinished
argument_list|(
literal|30000
argument_list|)
condition|)
block|{
name|QTest
operator|::
name|qFail
argument_list|(
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"qmake did not finish within 30 seconds\nCommand: %1\nOutput: %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|proc
operator|.
name|errorString
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|cmd_with_args
argument_list|)
operator|.
name|arg
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|proc
operator|.
name|readAll
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
if|if
condition|(
name|proc
operator|.
name|exitStatus
argument_list|()
operator|!=
name|QProcess
operator|::
name|NormalExit
condition|)
block|{
name|QTest
operator|::
name|qFail
argument_list|(
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"qmake crashed\nCommand: %1\nOutput: %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmd_with_args
argument_list|)
operator|.
name|arg
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|proc
operator|.
name|readAll
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
if|if
condition|(
name|proc
operator|.
name|exitCode
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|QTest
operator|::
name|qFail
argument_list|(
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"qmake exited with code %1\nCommand: %2\nOutput: %3"
argument_list|)
operator|.
name|arg
argument_list|(
name|proc
operator|.
name|exitCode
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|cmd_with_args
argument_list|)
operator|.
name|arg
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|proc
operator|.
name|readAll
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|lines
init|=
name|proc
operator|.
name|readAll
argument_list|()
operator|.
name|split
argument_list|(
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lines
operator|.
name|count
argument_list|()
condition|)
block|{
name|QTest
operator|::
name|qFail
argument_list|(
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"qmake seems to have not output anything\nCommand: %1\n"
argument_list|)
operator|.
name|arg
argument_list|(
name|cmd_with_args
argument_list|)
argument_list|)
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
foreach|foreach
control|(
name|QByteArray
specifier|const
modifier|&
name|line
decl|,
name|lines
control|)
block|{
specifier|static
specifier|const
name|QByteArray
name|marker
init|=
literal|"Project MESSAGE: subdir: "
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|marker
argument_list|)
condition|)
block|{
name|QString
name|subdir
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|line
operator|.
name|mid
argument_list|(
name|marker
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|trimmed
argument_list|()
argument_list|)
decl_stmt|;
name|out
operator|<<
name|prefix
operator|+
name|subdir
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|Flat
condition|)
block|{
continue|continue;
block|}
comment|// Need full path to subdir
name|QString
name|subdir_filepath
init|=
name|subdir
decl_stmt|;
name|subdir_filepath
operator|.
name|prepend
argument_list|(
name|QFileInfo
argument_list|(
name|pro_file
argument_list|)
operator|.
name|path
argument_list|()
operator|+
literal|"/"
argument_list|)
expr_stmt|;
comment|// Add subdirs recursively
if|if
condition|(
name|subdir
operator|.
name|endsWith
argument_list|(
literal|".pro"
argument_list|)
operator|&&
name|looks_like_subdirs
argument_list|(
name|subdir_filepath
argument_list|)
condition|)
block|{
comment|// Need full path to .pro file
name|out
operator|<<
name|find_subdirs
argument_list|(
name|subdir_filepath
argument_list|,
name|mode
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QFileInfo
argument_list|(
name|subdir_filepath
argument_list|)
operator|.
name|isDir
argument_list|()
condition|)
block|{
name|subdir_filepath
operator|+=
literal|"/"
operator|+
name|subdir
operator|+
literal|".pro"
expr_stmt|;
if|if
condition|(
name|looks_like_subdirs
argument_list|(
name|subdir_filepath
argument_list|)
condition|)
block|{
name|out
operator|<<
name|find_subdirs
argument_list|(
name|subdir_filepath
argument_list|,
name|mode
argument_list|,
name|prefix
operator|+
name|subdir
operator|+
literal|"/"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|make_check
name|void
name|tst_MakeTestSelfTest
operator|::
name|make_check
parameter_list|()
block|{
comment|/*         Run `make check' over the whole tests tree with a custom TESTRUNNER,         to verify that the TESTRUNNER mechanism works right.     */
name|QString
name|testsDir
argument_list|(
name|SRCDIR
literal|"/.."
argument_list|)
decl_stmt|;
name|QString
name|checktest
argument_list|(
name|SRCDIR
literal|"/checktest/checktest"
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
if|if
condition|(
name|qgetenv
argument_list|(
literal|"RUN_SLOW_TESTS"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QSKIP
argument_list|(
literal|"This test is too slow to run by default on this OS. Set RUN_SLOW_TESTS=1 to run it."
argument_list|,
name|SkipAll
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_WIN32
name|checktest
operator|.
name|replace
argument_list|(
literal|"/"
argument_list|,
literal|"\\"
argument_list|)
expr_stmt|;
name|checktest
operator|+=
literal|".exe"
expr_stmt|;
endif|#
directive|endif
name|QProcess
name|make
decl_stmt|;
name|make
operator|.
name|setWorkingDirectory
argument_list|(
name|testsDir
argument_list|)
expr_stmt|;
name|QStringList
name|arguments
decl_stmt|;
name|arguments
operator|<<
literal|"-k"
expr_stmt|;
name|arguments
operator|<<
literal|"check"
expr_stmt|;
name|arguments
operator|<<
name|QString
argument_list|(
literal|"TESTRUNNER=%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|checktest
argument_list|)
expr_stmt|;
comment|// find the right make; from externaltests.cpp
specifier|static
specifier|const
name|char
name|makes
index|[]
init|=
literal|"nmake.exe\0"
literal|"mingw32-make.exe\0"
literal|"gmake\0"
literal|"make\0"
decl_stmt|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
for|for
control|(
specifier|const
name|char
modifier|*
name|p
init|=
name|makes
init|;
operator|*
name|p
condition|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
control|)
block|{
name|make
operator|.
name|start
argument_list|(
name|p
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
if|if
condition|(
name|make
operator|.
name|waitForStarted
argument_list|()
condition|)
block|{
name|ok
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|QFAIL
argument_list|(
literal|"Could not find the right make tool in PATH"
argument_list|)
expr_stmt|;
block|}
name|QVERIFY
argument_list|(
name|make
operator|.
name|waitForFinished
argument_list|(
literal|1000
operator|*
literal|60
operator|*
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|make
operator|.
name|exitStatus
argument_list|()
argument_list|,
name|QProcess
operator|::
name|NormalExit
argument_list|)
expr_stmt|;
name|int
name|pass
init|=
literal|0
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|out
init|=
name|make
operator|.
name|readAllStandardOutput
argument_list|()
operator|.
name|split
argument_list|(
literal|'\n'
argument_list|)
decl_stmt|;
name|QStringList
name|fails
decl_stmt|;
foreach|foreach
control|(
name|QByteArray
name|line
decl|,
name|out
control|)
block|{
while|while
condition|(
name|line
operator|.
name|endsWith
argument_list|(
literal|"\r"
argument_list|)
condition|)
block|{
name|line
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"CHECKTEST FAIL"
argument_list|)
condition|)
block|{
name|fails
operator|<<
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"CHECKTEST PASS"
argument_list|)
condition|)
block|{
operator|++
name|pass
expr_stmt|;
block|}
block|}
comment|// We can't check that the exit code of make is 0, because some tests
comment|// may have failed to compile, but that doesn't mean `make check' is broken.
comment|// We do assume there are at least this many unbroken tests, though.
name|QVERIFY2
argument_list|(
name|fails
operator|.
name|count
argument_list|()
operator|==
literal|0
argument_list|,
name|qPrintable
argument_list|(
name|QString
argument_list|(
literal|"`make check' doesn't work for %1 tests:\n%2"
argument_list|)
operator|.
name|arg
argument_list|(
name|fails
operator|.
name|count
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|fails
operator|.
name|join
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|pass
operator|>
literal|50
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|find_test_class
name|QStringList
name|find_test_class
parameter_list|(
name|QString
specifier|const
modifier|&
name|filename
parameter_list|)
block|{
name|QStringList
name|out
decl_stmt|;
name|QFile
name|file
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
return|return
name|out
return|;
block|}
specifier|static
name|char
specifier|const
modifier|*
name|klass_indicators
index|[]
init|=
block|{
literal|"QTEST_MAIN("
block|,
literal|"QTEST_APPLESS_MAIN("
block|,
literal|"class"
block|,
literal|"staticconstcharklass[]=\""
block|,
comment|/* hax0r tests which define their own metaobject */
literal|0
block|}
decl_stmt|;
do|do
block|{
name|QByteArray
name|line
init|=
name|file
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
break|break;
block|}
name|line
operator|=
name|line
operator|.
name|trimmed
argument_list|()
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
literal|' '
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|klass_indicators
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
name|char
specifier|const
modifier|*
name|prefix
init|=
name|klass_indicators
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|line
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|QByteArray
name|klass
init|=
name|line
operator|.
name|mid
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|klass
operator|.
name|startsWith
argument_list|(
literal|"tst_"
argument_list|)
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|klass
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|char
name|c
init|=
name|klass
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'_'
operator|||
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|klass
operator|.
name|truncate
argument_list|(
name|j
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|QString
name|klass_str
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|klass
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|out
operator|.
name|contains
argument_list|(
name|klass_str
argument_list|)
condition|)
name|out
operator|<<
name|klass_str
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
return|return
name|out
return|;
block|}
end_function
begin_macro
name|QTEST_MAIN
argument_list|(
argument|tst_MakeTestSelfTest
argument_list|)
end_macro
begin_include
include|#
directive|include
file|"tst_maketestselftest.moc"
end_include
end_unit
