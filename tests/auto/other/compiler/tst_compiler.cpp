begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Copyright (C) 2014 Intel Corporation ** Contact: http://www.qt-project.org/legal ** ** This file is part of the test suite of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtCore/QtCore>
end_include
begin_include
include|#
directive|include
file|<QtTest/QtTest>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_define
DECL|macro|BASECLASS_NOT_ABSTRACT
define|#
directive|define
name|BASECLASS_NOT_ABSTRACT
end_define
begin_include
include|#
directive|include
file|"baseclass.h"
end_include
begin_include
include|#
directive|include
file|"derivedclass.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_ATOMICS
end_ifdef
begin_include
include|#
directive|include
file|<atomic>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_USE_NAMESPACE
end_macro
begin_class
DECL|class|tst_Compiler
class|class
name|tst_Compiler
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
private|private
name|slots
private|:
comment|/* C++98& C++03 base functionality */
name|void
name|template_methods
parameter_list|()
function_decl|;
name|void
name|template_constructors
parameter_list|()
function_decl|;
name|void
name|template_subclasses
parameter_list|()
function_decl|;
name|void
name|methodSpecialization
parameter_list|()
function_decl|;
name|void
name|constructorSpecialization
parameter_list|()
function_decl|;
name|void
name|staticTemplateMethods
parameter_list|()
function_decl|;
name|void
name|staticTemplateMethodSpecialization
parameter_list|()
function_decl|;
name|void
name|detectDataStream
parameter_list|()
function_decl|;
name|void
name|detectEnums
parameter_list|()
function_decl|;
name|void
name|overrideCFunction
parameter_list|()
function_decl|;
name|void
name|stdSortQList
parameter_list|()
function_decl|;
name|void
name|stdSortQVector
parameter_list|()
function_decl|;
name|void
name|templateCallOrder
parameter_list|()
function_decl|;
name|void
name|virtualFunctionNoLongerPureVirtual
parameter_list|()
function_decl|;
name|void
name|charSignedness
parameter_list|()
specifier|const
function_decl|;
name|void
name|privateStaticTemplateMember
parameter_list|()
specifier|const
function_decl|;
name|void
name|staticConstUnionWithInitializerList
parameter_list|()
specifier|const
function_decl|;
name|void
name|templateFriends
parameter_list|()
function_decl|;
comment|/* C++11 features */
name|void
name|cxx11_alignas
parameter_list|()
function_decl|;
name|void
name|cxx11_alignof
parameter_list|()
function_decl|;
name|void
name|cxx11_alignas_alignof
parameter_list|()
function_decl|;
name|void
name|cxx11_atomics
parameter_list|()
function_decl|;
name|void
name|cxx11_attributes
parameter_list|()
function_decl|;
name|void
name|cxx11_auto_function
parameter_list|()
function_decl|;
name|void
name|cxx11_auto_type
parameter_list|()
function_decl|;
name|void
name|cxx11_class_enum
parameter_list|()
function_decl|;
name|void
name|cxx11_constexpr
parameter_list|()
function_decl|;
name|void
name|cxx11_decltype
parameter_list|()
function_decl|;
name|void
name|cxx11_default_members
parameter_list|()
function_decl|;
name|void
name|cxx11_delete_members
parameter_list|()
function_decl|;
name|void
name|cxx11_delegating_constructors
parameter_list|()
function_decl|;
name|void
name|cxx11_explicit_conversions
parameter_list|()
function_decl|;
name|void
name|cxx11_explicit_overrides
parameter_list|()
function_decl|;
name|void
name|cxx11_extern_templates
parameter_list|()
function_decl|;
name|void
name|cxx11_inheriting_constructors
parameter_list|()
function_decl|;
name|void
name|cxx11_initializer_lists
parameter_list|()
function_decl|;
name|void
name|cxx11_lambda
parameter_list|()
function_decl|;
name|void
name|cxx11_nonstatic_member_init
parameter_list|()
function_decl|;
name|void
name|cxx11_noexcept
parameter_list|()
function_decl|;
name|void
name|cxx11_nullptr
parameter_list|()
function_decl|;
name|void
name|cxx11_range_for
parameter_list|()
function_decl|;
name|void
name|cxx11_raw_strings
parameter_list|()
function_decl|;
name|void
name|cxx11_ref_qualifiers
parameter_list|()
function_decl|;
name|void
name|cxx11_rvalue_refs
parameter_list|()
function_decl|;
name|void
name|cxx11_static_assert
parameter_list|()
function_decl|;
name|void
name|cxx11_template_alias
parameter_list|()
function_decl|;
name|void
name|cxx11_thread_local
parameter_list|()
function_decl|;
name|void
name|cxx11_udl
parameter_list|()
function_decl|;
name|void
name|cxx11_unicode_strings
parameter_list|()
function_decl|;
name|void
name|cxx11_uniform_init
parameter_list|()
function_decl|;
name|void
name|cxx11_unrestricted_unions
parameter_list|()
function_decl|;
name|void
name|cxx11_variadic_macros
parameter_list|()
function_decl|;
name|void
name|cxx11_variadic_templates
parameter_list|()
function_decl|;
comment|/* C++14 compiler features */
name|void
name|cxx14_binary_literals
parameter_list|()
function_decl|;
name|void
name|cxx14_init_captures
parameter_list|()
function_decl|;
name|void
name|cxx14_generic_lambdas
parameter_list|()
function_decl|;
name|void
name|cxx14_constexpr
parameter_list|()
function_decl|;
name|void
name|cxx14_decltype_auto
parameter_list|()
function_decl|;
name|void
name|cxx14_return_type_deduction
parameter_list|()
function_decl|;
name|void
name|cxx14_aggregate_nsdmi
parameter_list|()
function_decl|;
name|void
name|cxx14_variable_templates
parameter_list|()
function_decl|;
comment|/* Future / Technical specification compiler features */
name|void
name|runtimeArrays
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_HPACC
argument_list|)
end_if
begin_define
DECL|macro|DONT_TEST_TEMPLATE_CONSTRUCTORS
define|#
directive|define
name|DONT_TEST_TEMPLATE_CONSTRUCTORS
end_define
begin_define
DECL|macro|DONT_TEST_CONSTRUCTOR_SPECIALIZATION
define|#
directive|define
name|DONT_TEST_CONSTRUCTOR_SPECIALIZATION
end_define
begin_define
DECL|macro|DONT_TEST_DATASTREAM_DETECTION
define|#
directive|define
name|DONT_TEST_DATASTREAM_DETECTION
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_SUN
argument_list|)
end_if
begin_define
DECL|macro|DONT_TEST_STL_SORTING
define|#
directive|define
name|DONT_TEST_STL_SORTING
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_class
DECL|class|TemplateMethodClass
class|class
name|TemplateMethodClass
block|{
public|public:
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|foo
name|T
name|foo
parameter_list|()
block|{
return|return
literal|42
return|;
block|}
block|}
class|;
end_class
begin_function
DECL|function|template_methods
name|void
name|tst_Compiler
operator|::
name|template_methods
parameter_list|()
block|{
name|TemplateMethodClass
name|t
decl_stmt|;
name|QCOMPARE
argument_list|(
name|t
operator|.
name|foo
argument_list|<
name|int
argument_list|>
argument_list|()
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t
operator|.
name|foo
argument_list|<
name|long
argument_list|>
argument_list|()
argument_list|,
literal|42l
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t
operator|.
name|foo
argument_list|<
name|double
argument_list|>
argument_list|()
argument_list|,
literal|42.0
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|DONT_TEST_TEMPLATE_CONSTRUCTORS
end_ifndef
begin_class
DECL|class|TemplateConstructorClass
class|class
name|TemplateConstructorClass
block|{
public|public:
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|TemplateConstructorClass
name|TemplateConstructorClass
parameter_list|(
specifier|const
name|T
modifier|&
name|t
parameter_list|)
block|{
name|i
operator|=
name|int
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
DECL|member|i
name|int
name|i
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|template_constructors
name|void
name|tst_Compiler
operator|::
name|template_constructors
parameter_list|()
block|{
name|TemplateConstructorClass
name|t1
argument_list|(
literal|42
argument_list|)
decl_stmt|;
name|TemplateConstructorClass
name|t2
argument_list|(
literal|42l
argument_list|)
decl_stmt|;
name|TemplateConstructorClass
name|t3
argument_list|(
literal|42.0
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|t1
operator|.
name|i
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t2
operator|.
name|i
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t3
operator|.
name|i
argument_list|,
literal|42
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|template_constructors
name|void
name|tst_Compiler
operator|::
name|template_constructors
parameter_list|()
block|{
name|QSKIP
argument_list|(
literal|"Compiler doesn't do template constructors"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_struct
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|OuterClass
name|OuterClass
block|{
template|template
parameter_list|<
name|typename
name|U
parameter_list|>
struct|struct
DECL|struct|InnerClass
name|InnerClass
block|{
DECL|function|convert
name|U
name|convert
parameter_list|(
specifier|const
name|T
modifier|&
name|t
parameter_list|)
block|{
return|return
cast|static_cast
argument_list|<
name|U
argument_list|>
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
struct|;
block|}
struct|;
end_struct
begin_function
DECL|function|template_subclasses
name|void
name|tst_Compiler
operator|::
name|template_subclasses
parameter_list|()
block|{
name|OuterClass
argument_list|<
name|char
argument_list|>
operator|::
name|InnerClass
argument_list|<
name|int
argument_list|>
name|c1
decl_stmt|;
name|QCOMPARE
argument_list|(
name|c1
operator|.
name|convert
argument_list|(
literal|'a'
argument_list|)
argument_list|,
name|int
argument_list|(
literal|'a'
argument_list|)
argument_list|)
expr_stmt|;
name|OuterClass
argument_list|<
name|QRect
argument_list|>
operator|::
name|InnerClass
argument_list|<
name|QRectF
argument_list|>
name|c2
decl_stmt|;
name|QCOMPARE
argument_list|(
name|c2
operator|.
name|convert
argument_list|(
name|QRect
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|,
name|QRectF
argument_list|(
name|QRect
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_class
DECL|class|TemplateMethodClass2
class|class
name|TemplateMethodClass2
block|{
public|public:
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|foo
name|T
name|foo
parameter_list|()
block|{
return|return
literal|42
return|;
block|}
block|}
class|;
end_class
begin_function
template|template
parameter_list|<>
DECL|function|foo
name|int
name|TemplateMethodClass2
operator|::
name|foo
argument_list|<
name|int
argument_list|>
parameter_list|()
block|{
return|return
literal|43
return|;
block|}
end_function
begin_function
DECL|function|methodSpecialization
name|void
name|tst_Compiler
operator|::
name|methodSpecialization
parameter_list|()
block|{
name|TemplateMethodClass2
name|t
decl_stmt|;
name|QCOMPARE
argument_list|(
name|t
operator|.
name|foo
argument_list|<
name|int
argument_list|>
argument_list|()
argument_list|,
literal|43
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t
operator|.
name|foo
argument_list|<
name|long
argument_list|>
argument_list|()
argument_list|,
literal|42l
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t
operator|.
name|foo
argument_list|<
name|double
argument_list|>
argument_list|()
argument_list|,
literal|42.0
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|DONT_TEST_CONSTRUCTOR_SPECIALIZATION
end_ifndef
begin_class
DECL|class|TemplateConstructorClass2
class|class
name|TemplateConstructorClass2
block|{
public|public:
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|TemplateConstructorClass2
name|TemplateConstructorClass2
parameter_list|(
specifier|const
name|T
modifier|&
name|t
parameter_list|)
block|{
name|i
operator|=
name|int
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
DECL|member|i
name|int
name|i
decl_stmt|;
block|}
class|;
end_class
begin_constructor
template|template
parameter_list|<>
DECL|function|TemplateConstructorClass2
name|TemplateConstructorClass2
operator|::
name|TemplateConstructorClass2
parameter_list|(
specifier|const
name|int
modifier|&
name|t
parameter_list|)
block|{
name|i
operator|=
name|t
operator|+
literal|1
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|constructorSpecialization
name|void
name|tst_Compiler
operator|::
name|constructorSpecialization
parameter_list|()
block|{
name|TemplateConstructorClass2
name|t1
argument_list|(
literal|42
argument_list|)
decl_stmt|;
name|TemplateConstructorClass2
name|t2
argument_list|(
literal|42l
argument_list|)
decl_stmt|;
name|TemplateConstructorClass2
name|t3
argument_list|(
literal|42.0
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|t1
operator|.
name|i
argument_list|,
literal|43
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t2
operator|.
name|i
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t3
operator|.
name|i
argument_list|,
literal|42
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|constructorSpecialization
name|void
name|tst_Compiler
operator|::
name|constructorSpecialization
parameter_list|()
block|{
name|QSKIP
argument_list|(
literal|"Compiler doesn't do constructor specialization"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_class
DECL|class|StaticTemplateClass
class|class
name|StaticTemplateClass
block|{
public|public:
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|foo
specifier|static
name|T
name|foo
parameter_list|()
block|{
return|return
literal|42
return|;
block|}
block|}
class|;
end_class
begin_function
DECL|function|staticTemplateMethods
name|void
name|tst_Compiler
operator|::
name|staticTemplateMethods
parameter_list|()
block|{
name|QCOMPARE
argument_list|(
name|StaticTemplateClass
operator|::
name|foo
argument_list|<
name|int
argument_list|>
argument_list|()
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|StaticTemplateClass
operator|::
name|foo
argument_list|<
name|uint
argument_list|>
argument_list|()
argument_list|,
literal|42u
argument_list|)
expr_stmt|;
block|}
end_function
begin_class
DECL|class|StaticTemplateClass2
class|class
name|StaticTemplateClass2
block|{
public|public:
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|foo
specifier|static
name|T
name|foo
parameter_list|()
block|{
return|return
literal|42
return|;
block|}
block|}
class|;
end_class
begin_function
template|template
parameter_list|<>
DECL|function|foo
name|double
name|StaticTemplateClass2
operator|::
name|foo
argument_list|<
name|double
argument_list|>
parameter_list|()
block|{
return|return
literal|18.5
return|;
block|}
end_function
begin_function
DECL|function|staticTemplateMethodSpecialization
name|void
name|tst_Compiler
operator|::
name|staticTemplateMethodSpecialization
parameter_list|()
block|{
name|QCOMPARE
argument_list|(
name|StaticTemplateClass2
operator|::
name|foo
argument_list|<
name|int
argument_list|>
argument_list|()
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|StaticTemplateClass2
operator|::
name|foo
argument_list|<
name|uint
argument_list|>
argument_list|()
argument_list|,
literal|42u
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|StaticTemplateClass2
operator|::
name|foo
argument_list|<
name|double
argument_list|>
argument_list|()
argument_list|,
literal|18.5
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|DONT_TEST_DATASTREAM_DETECTION
end_ifndef
begin_comment
comment|/******* DataStream tester *********/
end_comment
begin_namespace
DECL|namespace|QtTestInternal
namespace|namespace
name|QtTestInternal
block|{
DECL|struct|EmptyStruct
struct|struct
name|EmptyStruct
block|{
block|}
struct|;
DECL|struct|LowPreferenceStruct
struct|struct
name|LowPreferenceStruct
block|{
name|LowPreferenceStruct
parameter_list|(
modifier|...
parameter_list|)
constructor_decl|;
block|}
struct|;
name|EmptyStruct
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
parameter_list|,
specifier|const
name|LowPreferenceStruct
modifier|&
parameter_list|)
function_decl|;
name|EmptyStruct
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
parameter_list|,
specifier|const
name|LowPreferenceStruct
modifier|&
parameter_list|)
function_decl|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|DataStreamChecker
name|DataStreamChecker
block|{
specifier|static
name|EmptyStruct
name|hasStreamHelper
parameter_list|(
specifier|const
name|EmptyStruct
modifier|&
parameter_list|)
function_decl|;
specifier|static
name|QDataStream
name|hasStreamHelper
parameter_list|(
specifier|const
name|QDataStream
modifier|&
parameter_list|)
function_decl|;
specifier|static
name|QDataStream
modifier|&
name|dsDummy
parameter_list|()
function_decl|;
specifier|static
name|T
modifier|&
name|dummy
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|BROKEN_COMPILER
DECL|member|HasDataStream
specifier|static
specifier|const
name|bool
name|HasDataStream
init|=
sizeof|sizeof
argument_list|(
name|hasStreamHelper
argument_list|(
name|dsDummy
argument_list|()
operator|<<
name|dummy
argument_list|()
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QDataStream
argument_list|)
operator|&&
sizeof|sizeof
argument_list|(
name|hasStreamHelper
argument_list|(
name|dsDummy
argument_list|()
operator|>>
name|dummy
argument_list|()
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QDataStream
argument_list|)
decl_stmt|;
else|#
directive|else
enum|enum
block|{
DECL|enumerator|HasOutDataStream
name|HasOutDataStream
init|=
sizeof|sizeof
argument_list|(
name|hasStreamHelper
argument_list|(
name|dsDummy
argument_list|()
operator|>>
name|dummy
argument_list|()
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QDataStream
argument_list|)
block|,
DECL|enumerator|HasInDataStream
name|HasInDataStream
init|=
sizeof|sizeof
argument_list|(
name|hasStreamHelper
argument_list|(
name|dsDummy
argument_list|()
operator|<<
name|dummy
argument_list|()
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QDataStream
argument_list|)
block|,
DECL|enumerator|HasDataStream
name|HasDataStream
init|=
name|HasOutDataStream
operator|&
name|HasInDataStream
block|}
enum|;
endif|#
directive|endif
block|}
struct|;
template|template
parameter_list|<
name|bool
parameter_list|>
struct|struct
DECL|struct|DataStreamOpHelper
name|DataStreamOpHelper
block|{
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|Getter
name|Getter
block|{
DECL|function|saveOp
specifier|static
name|QMetaType
operator|::
name|SaveOperator
name|saveOp
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
struct|;
block|}
struct|;
template|template
parameter_list|<>
struct|struct
DECL|struct|DataStreamOpHelper
name|DataStreamOpHelper
argument_list|<
literal|true
argument_list|>
block|{
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|Getter
name|Getter
block|{
DECL|function|saveOp
specifier|static
name|QMetaType
operator|::
name|SaveOperator
name|saveOp
parameter_list|()
block|{
return|return
operator|::
name|QtMetaTypePrivate
operator|::
name|QMetaTypeFunctionHelper
argument_list|<
name|T
argument_list|>
operator|::
name|Save
return|;
block|}
block|}
struct|;
block|}
struct|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|getSaveOperator
specifier|inline
name|QMetaType
operator|::
name|SaveOperator
name|getSaveOperator
parameter_list|(
name|T
modifier|*
init|=
literal|0
parameter_list|)
block|{
typedef|typedef
typename|typename
name|DataStreamOpHelper
argument_list|<
name|DataStreamChecker
argument_list|<
name|T
argument_list|>
operator|::
name|HasDataStream
argument_list|>
operator|::
specifier|template
name|Getter
argument_list|<
name|T
argument_list|>
name|GetterHelper
typedef|;
return|return
name|GetterHelper
operator|::
name|saveOp
argument_list|()
return|;
block|}
block|}
end_namespace
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_struct
DECL|struct|MyString
struct|struct
name|MyString
super|:
specifier|public
name|QString
block|{
block|}
struct|;
end_struct
begin_struct
DECL|struct|Qxxx
struct|struct
name|Qxxx
block|{
block|}
struct|;
end_struct
begin_function
DECL|function|detectDataStream
name|void
name|tst_Compiler
operator|::
name|detectDataStream
parameter_list|()
block|{
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
name|int
argument_list|>
operator|::
name|HasDataStream
operator|==
literal|true
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
name|uint
argument_list|>
operator|::
name|HasDataStream
operator|==
literal|true
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
name|char
operator|*
argument_list|>
operator|::
name|HasDataStream
operator|==
literal|true
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
specifier|const
name|int
argument_list|>
operator|::
name|HasInDataStream
operator|==
literal|true
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
specifier|const
name|int
argument_list|>
operator|::
name|HasOutDataStream
operator|==
literal|false
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
specifier|const
name|int
argument_list|>
operator|::
name|HasDataStream
operator|==
literal|false
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
name|double
argument_list|>
operator|::
name|HasDataStream
operator|==
literal|true
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
name|QString
argument_list|>
operator|::
name|HasDataStream
operator|==
literal|true
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
name|MyString
argument_list|>
operator|::
name|HasDataStream
operator|==
literal|true
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
name|Qxxx
argument_list|>
operator|::
name|HasDataStream
operator|==
literal|false
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|getSaveOperator
argument_list|<
name|int
argument_list|>
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|getSaveOperator
argument_list|<
name|uint
argument_list|>
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|getSaveOperator
argument_list|<
name|char
operator|*
argument_list|>
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|getSaveOperator
argument_list|<
name|double
argument_list|>
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|getSaveOperator
argument_list|<
name|QString
argument_list|>
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|getSaveOperator
argument_list|<
name|MyString
argument_list|>
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|getSaveOperator
argument_list|<
name|Qxxx
argument_list|>
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|detectDataStream
name|void
name|tst_Compiler
operator|::
name|detectDataStream
parameter_list|()
block|{
name|QSKIP
argument_list|(
literal|"Compiler doesn't evaluate templates correctly"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_enum
DECL|enum|Enum1
DECL|enumerator|Foo
DECL|enumerator|Bar
enum|enum
name|Enum1
block|{
name|Foo
init|=
literal|0
block|,
name|Bar
init|=
literal|1
block|}
enum|;
end_enum
begin_enum
DECL|enum|Enum2
enum|enum
name|Enum2
block|{}
enum|;
end_enum
begin_enum
DECL|enum|Enum3
DECL|enumerator|Something
enum|enum
name|Enum3
block|{
name|Something
init|=
literal|1
block|}
enum|;
end_enum
begin_function_decl
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
name|char
name|QTypeInfoEnumHelper
parameter_list|(
name|T
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
name|void
modifier|*
name|QTypeInfoEnumHelper
parameter_list|(
modifier|...
parameter_list|)
function_decl|;
end_function_decl
begin_struct
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|QTestTypeInfo
name|QTestTypeInfo
block|{
DECL|enumerator|IsEnum
enum|enum
block|{
name|IsEnum
init|=
sizeof|sizeof
argument_list|(
name|QTypeInfoEnumHelper
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|==
expr|sizeof
operator|(
name|void
operator|*
operator|)
block|}
enum|;
block|}
struct|;
end_struct
begin_function
DECL|function|detectEnums
name|void
name|tst_Compiler
operator|::
name|detectEnums
parameter_list|()
block|{
name|QVERIFY
argument_list|(
name|QTestTypeInfo
argument_list|<
name|Enum1
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QTestTypeInfo
argument_list|<
name|Enum2
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QTestTypeInfo
argument_list|<
name|Enum3
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|int
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|char
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|uint
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|short
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|ushort
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|void
operator|*
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|QString
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QTestTypeInfo
argument_list|<
name|Qt
operator|::
name|Key
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QTestTypeInfo
argument_list|<
name|Qt
operator|::
name|ToolBarArea
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|Qt
operator|::
name|ToolBarAreas
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QTestTypeInfo
argument_list|<
name|Qt
operator|::
name|MatchFlag
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|Qt
operator|::
name|MatchFlags
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|indicator
specifier|static
name|int
name|indicator
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|// this is a silly C function
end_comment
begin_extern
extern|extern
literal|"C"
block|{
DECL|function|someCFunc
name|void
name|someCFunc
parameter_list|(
name|void
modifier|*
parameter_list|)
block|{
name|indicator
operator|=
literal|42
expr_stmt|;
block|}
block|}
end_extern
begin_comment
comment|// this is the catch-template that will be called if the C function doesn't exist
end_comment
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|someCFunc
name|void
name|someCFunc
parameter_list|(
name|T
modifier|*
parameter_list|)
block|{
name|indicator
operator|=
literal|10
expr_stmt|;
block|}
end_function
begin_function
DECL|function|overrideCFunction
name|void
name|tst_Compiler
operator|::
name|overrideCFunction
parameter_list|()
block|{
name|someCFunc
argument_list|(
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|indicator
argument_list|,
literal|42
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|DONT_TEST_STL_SORTING
end_ifndef
begin_function
DECL|function|stdSortQList
name|void
name|tst_Compiler
operator|::
name|stdSortQList
parameter_list|()
block|{
name|QList
argument_list|<
name|int
argument_list|>
name|list
decl_stmt|;
name|list
operator|<<
literal|4
operator|<<
literal|2
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|list
operator|.
name|begin
argument_list|()
argument_list|,
name|list
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|list
operator|.
name|value
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|list
operator|.
name|value
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QString
argument_list|>
name|slist
decl_stmt|;
name|slist
operator|<<
literal|"b"
operator|<<
literal|"a"
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|slist
operator|.
name|begin
argument_list|()
argument_list|,
name|slist
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|slist
operator|.
name|value
argument_list|(
literal|0
argument_list|)
argument_list|,
name|QString
argument_list|(
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|slist
operator|.
name|value
argument_list|(
literal|1
argument_list|)
argument_list|,
name|QString
argument_list|(
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stdSortQVector
name|void
name|tst_Compiler
operator|::
name|stdSortQVector
parameter_list|()
block|{
name|QVector
argument_list|<
name|int
argument_list|>
name|vector
decl_stmt|;
name|vector
operator|<<
literal|4
operator|<<
literal|2
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|vector
operator|.
name|begin
argument_list|()
argument_list|,
name|vector
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|vector
operator|.
name|value
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|vector
operator|.
name|value
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QString
argument_list|>
name|strvec
decl_stmt|;
name|strvec
operator|<<
literal|"b"
operator|<<
literal|"a"
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|strvec
operator|.
name|begin
argument_list|()
argument_list|,
name|strvec
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|strvec
operator|.
name|value
argument_list|(
literal|0
argument_list|)
argument_list|,
name|QString
argument_list|(
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|strvec
operator|.
name|value
argument_list|(
literal|1
argument_list|)
argument_list|,
name|QString
argument_list|(
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|stdSortQList
name|void
name|tst_Compiler
operator|::
name|stdSortQList
parameter_list|()
block|{
name|QSKIP
argument_list|(
literal|"Compiler's STL broken"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stdSortQVector
name|void
name|tst_Compiler
operator|::
name|stdSortQVector
parameter_list|()
block|{
name|QSKIP
argument_list|(
literal|"Compiler's STL broken"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// the C func will set it to 1, the template to 2
end_comment
begin_decl_stmt
DECL|variable|whatWasCalled
specifier|static
name|int
name|whatWasCalled
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|callOrderFunc
name|void
name|callOrderFunc
parameter_list|(
name|void
modifier|*
parameter_list|)
block|{
name|whatWasCalled
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|callOrderFunc
name|void
name|callOrderFunc
parameter_list|(
name|T
modifier|*
parameter_list|)
block|{
name|whatWasCalled
operator|=
literal|2
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|callOrderNoCFunc
name|void
name|callOrderNoCFunc
parameter_list|(
name|T
modifier|*
parameter_list|)
block|{
name|whatWasCalled
operator|=
literal|3
expr_stmt|;
block|}
end_function
begin_comment
comment|/*    This test will check what will get precendence - the C function    or the template.     It also makes sure this template "override" will compile on all systems    and not result in ambiguities. */
end_comment
begin_function
DECL|function|templateCallOrder
name|void
name|tst_Compiler
operator|::
name|templateCallOrder
parameter_list|()
block|{
name|QCOMPARE
argument_list|(
name|whatWasCalled
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// call it with a void *
name|void
modifier|*
name|f
init|=
literal|0
decl_stmt|;
name|callOrderFunc
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|whatWasCalled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|whatWasCalled
operator|=
literal|0
expr_stmt|;
name|char
modifier|*
name|c
init|=
literal|0
decl_stmt|;
comment|/* call it with a char * - AMBIGOUS, fails on several compilers     callOrderFunc(c);     QCOMPARE(whatWasCalled, 1);     whatWasCalled = 0;     */
comment|// now try the case when there is no C function
name|callOrderNoCFunc
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|whatWasCalled
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|whatWasCalled
operator|=
literal|0
expr_stmt|;
name|callOrderNoCFunc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|whatWasCalled
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|whatWasCalled
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|// test to see if removing =0 from a pure virtual function is BC
end_comment
begin_function
DECL|function|virtualFunctionNoLongerPureVirtual
name|void
name|tst_Compiler
operator|::
name|virtualFunctionNoLongerPureVirtual
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|BASECLASS_NOT_ABSTRACT
comment|// has a single virtual function, not pure virtual, can call it
name|BaseClass
name|baseClass
decl_stmt|;
name|QTest
operator|::
name|ignoreMessage
argument_list|(
name|QtDebugMsg
argument_list|,
literal|"BaseClass::wasAPureVirtualFunction()"
argument_list|)
expr_stmt|;
name|baseClass
operator|.
name|wasAPureVirtualFunction
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// DerivedClass inherits from BaseClass, and function is declared
comment|// pure virtual, make sure we can still call it
name|DerivedClass
name|derivedClass
decl_stmt|;
name|QTest
operator|::
name|ignoreMessage
argument_list|(
name|QtDebugMsg
argument_list|,
literal|"DerivedClass::wasAPureVirtualFunction()"
argument_list|)
expr_stmt|;
name|derivedClass
operator|.
name|wasAPureVirtualFunction
argument_list|()
expr_stmt|;
block|}
end_function
begin_function_decl
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
specifier|const
name|char
modifier|*
name|resolveCharSignedness
parameter_list|()
function_decl|;
end_function_decl
begin_function
template|template
parameter_list|<>
DECL|function|resolveCharSignedness
specifier|const
name|char
modifier|*
name|resolveCharSignedness
argument_list|<
name|char
argument_list|>
parameter_list|()
block|{
return|return
literal|"char"
return|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|resolveCharSignedness
specifier|const
name|char
modifier|*
name|resolveCharSignedness
argument_list|<
name|unsigned
name|char
argument_list|>
parameter_list|()
block|{
return|return
literal|"unsigned char"
return|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|resolveCharSignedness
specifier|const
name|char
modifier|*
name|resolveCharSignedness
argument_list|<
name|signed
name|char
argument_list|>
parameter_list|()
block|{
return|return
literal|"signed char"
return|;
block|}
end_function
begin_function
DECL|function|charSignedness
name|void
name|tst_Compiler
operator|::
name|charSignedness
parameter_list|()
specifier|const
block|{
name|QCOMPARE
argument_list|(
literal|"char"
argument_list|,
name|resolveCharSignedness
argument_list|<
name|char
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
literal|"unsigned char"
argument_list|,
argument|resolveCharSignedness<unsigned char>()
argument_list|)
empty_stmt|;
name|QCOMPARE
argument_list|(
literal|"signed char"
argument_list|,
argument|resolveCharSignedness<signed char>()
argument_list|)
empty_stmt|;
block|}
end_function
begin_class
DECL|class|PrivateStaticTemplateMember
class|class
name|PrivateStaticTemplateMember
block|{
public|public:
DECL|function|regularMember
name|long
name|regularMember
parameter_list|()
block|{
return|return
name|helper
argument_list|<
name|long
argument_list|,
name|int
argument_list|>
argument_list|(
literal|3
argument_list|)
return|;
block|}
private|private:
template|template
parameter_list|<
name|typename
name|A
parameter_list|,
name|typename
name|B
parameter_list|>
DECL|function|helper
specifier|static
name|A
name|helper
parameter_list|(
specifier|const
name|B
name|b
parameter_list|)
block|{
return|return
name|A
argument_list|(
name|b
argument_list|)
return|;
block|}
block|}
class|;
end_class
begin_function
DECL|function|privateStaticTemplateMember
name|void
name|tst_Compiler
operator|::
name|privateStaticTemplateMember
parameter_list|()
specifier|const
block|{
name|PrivateStaticTemplateMember
name|v
decl_stmt|;
name|QCOMPARE
argument_list|(
name|long
argument_list|(
literal|3
argument_list|)
argument_list|,
name|v
operator|.
name|regularMember
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_CC_MIPS
argument_list|)
end_if
begin_comment
comment|// make sure we can use a static initializer with a union and then use
end_comment
begin_comment
comment|// the second member of the union
end_comment
begin_union
DECL|member|c
DECL|member|d
DECL|variable|qt_be_inf_bytes
specifier|static
specifier|const
union|union
block|{
name|unsigned
name|char
name|c
index|[
literal|8
index|]
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
name|qt_be_inf_bytes
init|=
block|{
block|{
literal|0x7f
block|,
literal|0xf0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
union|;
end_union
begin_union
DECL|member|c
DECL|member|d
DECL|variable|qt_le_inf_bytes
specifier|static
specifier|const
union|union
block|{
name|unsigned
name|char
name|c
index|[
literal|8
index|]
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
name|qt_le_inf_bytes
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0xf0
block|,
literal|0x7f
block|}
block|}
union|;
end_union
begin_function
DECL|function|qt_inf
specifier|static
specifier|inline
name|double
name|qt_inf
parameter_list|()
block|{
return|return
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|?
name|qt_be_inf_bytes
operator|.
name|d
else|:
name|qt_le_inf_bytes
operator|.
name|d
operator|)
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|variable|qt_be_inf_bytes
specifier|static
specifier|const
name|unsigned
name|char
name|qt_be_inf_bytes
index|[]
init|=
block|{
literal|0x7f
block|,
literal|0xf0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qt_le_inf_bytes
specifier|static
specifier|const
name|unsigned
name|char
name|qt_le_inf_bytes
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0xf0
block|,
literal|0x7f
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_inf
specifier|static
specifier|inline
name|double
name|qt_inf
parameter_list|()
block|{
specifier|const
name|uchar
modifier|*
name|bytes
decl_stmt|;
name|bytes
operator|=
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|?
name|qt_be_inf_bytes
else|:
name|qt_le_inf_bytes
operator|)
expr_stmt|;
union|union
block|{
name|uchar
name|c
index|[
literal|8
index|]
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
name|returnValue
union|;
name|memcpy
argument_list|(
name|returnValue
operator|.
name|c
argument_list|,
name|bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|returnValue
operator|.
name|c
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|returnValue
operator|.
name|d
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|staticConstUnionWithInitializerList
name|void
name|tst_Compiler
operator|::
name|staticConstUnionWithInitializerList
parameter_list|()
specifier|const
block|{
name|double
name|d
init|=
name|qt_inf
argument_list|()
decl_stmt|;
name|QVERIFY
argument_list|(
name|qIsInf
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|Q_NO_TEMPLATE_FRIENDS
end_ifndef
begin_class
DECL|class|TemplateFriends
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
class|class
name|TemplateFriends
block|{
DECL|member|value
name|T
name|value
decl_stmt|;
public|public:
DECL|function|TemplateFriends
name|TemplateFriends
parameter_list|(
name|T
name|value
parameter_list|)
member_init_list|:
name|value
argument_list|(
name|value
argument_list|)
block|{}
DECL|function|copy
template|template
parameter_list|<
name|typename
name|X
parameter_list|>
name|void
name|copy
parameter_list|(
name|TemplateFriends
argument_list|<
name|X
argument_list|>
name|other
parameter_list|)
block|{
name|value
operator|=
name|other
operator|.
name|value
expr_stmt|;
block|}
template|template
parameter_list|<
name|typename
name|X
parameter_list|>
friend|friend
class_decl|class
name|TemplateFriends
class_decl|;
block|}
class|;
end_class
begin_function
DECL|function|templateFriends
name|void
name|tst_Compiler
operator|::
name|templateFriends
parameter_list|()
block|{
name|TemplateFriends
argument_list|<
name|int
argument_list|>
name|ti
argument_list|(
literal|42
argument_list|)
decl_stmt|;
name|TemplateFriends
argument_list|<
name|long
argument_list|>
name|tl
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|tl
operator|.
name|copy
argument_list|(
name|ti
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|templateFriends
name|void
name|tst_Compiler
operator|::
name|templateFriends
parameter_list|()
block|{
name|QSKIP
argument_list|(
literal|"Compiler does not support template friends"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_alignas
name|void
name|tst_Compiler
operator|::
name|cxx11_alignas
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_ALIGNAS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
alignas|alignas
argument_list|(
name|double
argument_list|)
name|char
name|c
decl_stmt|;
name|QVERIFY
argument_list|(
name|Q_ALIGNOF
argument_list|(
name|c
argument_list|)
operator|==
name|Q_ALIGNOF
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_alignof
name|void
name|tst_Compiler
operator|::
name|cxx11_alignof
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_ALIGNOF
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|size_t
name|alignchar
init|=
alignof|alignof
argument_list|(
name|char
argument_list|)
decl_stmt|;
name|size_t
name|aligndouble
init|=
alignof|alignof
argument_list|(
name|double
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|alignchar
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|alignchar
operator|<=
name|aligndouble
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_alignas_alignof
name|void
name|tst_Compiler
operator|::
name|cxx11_alignas_alignof
parameter_list|()
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_COMPILER_ALIGNAS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_COMPILER_ALIGNOF
argument_list|)
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
alignas|alignas
argument_list|(
alignof|alignof
argument_list|(
name|double
argument_list|)
argument_list|)
name|char
name|c
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_atomics
name|void
name|tst_Compiler
operator|::
name|cxx11_atomics
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_ATOMICS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|std
operator|::
name|atomic
argument_list|<
name|int
argument_list|>
name|i
decl_stmt|;
name|i
operator|.
name|store
argument_list|(
literal|42
argument_list|,
name|std
operator|::
name|memory_order_seq_cst
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|i
operator|.
name|load
argument_list|(
name|std
operator|::
name|memory_order_acquire
argument_list|)
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|std
operator|::
name|atomic
argument_list|<
name|short
argument_list|>
name|s
decl_stmt|;
name|s
operator|.
name|store
argument_list|(
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|s
operator|.
name|load
argument_list|()
argument_list|,
name|short
argument_list|(
literal|42
argument_list|)
argument_list|)
expr_stmt|;
name|std
operator|::
name|atomic_flag
name|flag
decl_stmt|;
name|flag
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|flag
operator|.
name|test_and_set
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|flag
operator|.
name|test_and_set
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_attributes
name|void
name|tst_Compiler
operator|::
name|cxx11_attributes
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_ATTRIBUTES
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
attribute|[[
name|deprecated
attribute|]]
name|C
block|{
block|}
struct|;
attribute|[[
name|gnu
operator|::
name|unused
attribute|]]
struct|struct
name|D
block|{
block|}
name|d
struct|;
attribute|[[
name|noreturn
attribute|]]
name|void
name|f
argument_list|()
decl_stmt|;
name|struct
name|D
name|e
attribute|[[
name|gnu
operator|::
name|used
attribute|,
name|gnu
operator|::
name|unused
attribute|]]
decl_stmt|;
attribute|[[
name|gnu
operator|::
name|aligned
argument_list|(
literal|8
argument_list|)
attribute|]]
name|int
name|i
decl_stmt|;
attribute|[[
name|gnu
operator|::
name|unused
attribute|]]
name|end
range|:
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_AUTO_FUNCTION
end_ifdef
begin_function
name|auto
name|autoFunction
parameter_list|()
function|->
name|unsigned
block|{
return|return
literal|1
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_auto_function
name|void
name|tst_Compiler
operator|::
name|cxx11_auto_function
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_AUTO_FUNCTION
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QCOMPARE
argument_list|(
name|autoFunction
argument_list|()
argument_list|,
literal|1u
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_auto_type
name|void
name|tst_Compiler
operator|::
name|cxx11_auto_type
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_AUTO_TYPE
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|auto
name|i
init|=
literal|1
decl_stmt|;
name|auto
name|x
init|=
name|qrand
argument_list|()
decl_stmt|;
name|auto
name|l
init|=
literal|1L
decl_stmt|;
name|auto
name|s
init|=
name|QStringLiteral
argument_list|(
literal|"Hello World"
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|l
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|s
operator|.
name|toLower
argument_list|()
argument_list|,
name|QString
argument_list|(
literal|"hello world"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_class_enum
name|void
name|tst_Compiler
operator|::
name|cxx11_class_enum
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_CLASS_ENUM
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
enum|enum class
name|X
block|{
name|EnumValue
block|}
enum|;
name|X
name|x
init|=
name|X
operator|::
name|EnumValue
decl_stmt|;
name|QCOMPARE
argument_list|(
name|x
argument_list|,
name|X
operator|::
name|EnumValue
argument_list|)
expr_stmt|;
enum|enum class
name|Y
enum|:
name|short
block|{
name|Val
init|=
literal|2
block|}
enum|;
enum|enum
name|Z
enum|:
name|long
block|{
name|ValLong
init|=
name|LONG_MAX
block|}
enum|;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_CONSTEXPR
end_ifdef
begin_function
DECL|function|constexprValue
specifier|constexpr
name|int
name|constexprValue
parameter_list|()
block|{
return|return
literal|42
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_constexpr
name|void
name|tst_Compiler
operator|::
name|cxx11_constexpr
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_CONSTEXPR
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|static
specifier|constexpr
name|QBasicAtomicInt
name|atomic
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|static
specifier|constexpr
name|int
name|i
init|=
name|constexprValue
argument_list|()
decl_stmt|;
name|QCOMPARE
argument_list|(
name|i
argument_list|,
name|constexprValue
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|atomic
operator|.
name|load
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_decltype
name|void
name|tst_Compiler
operator|::
name|cxx11_decltype
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_DECLTYPE
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
decltype|decltype
argument_list|(
name|qrand
argument_list|()
argument_list|)
name|i
init|=
literal|0
decl_stmt|;
name|QCOMPARE
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_default_members
name|void
name|tst_Compiler
operator|::
name|cxx11_default_members
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_DEFAULT_MEMBERS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|DefaultMembers
block|{
name|DefaultMembers
parameter_list|()
constructor_decl|=
specifier|default
constructor_decl|;
name|DefaultMembers
parameter_list|(
name|int
parameter_list|)
block|{}
block|}
struct|;
name|DefaultMembers
name|dm
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|dm
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_delete_members
name|void
name|tst_Compiler
operator|::
name|cxx11_delete_members
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_DELETE_MEMBERS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|DeleteMembers
block|{
name|DeleteMembers
parameter_list|()
constructor_decl|=
specifier|delete
constructor_decl|;
name|DeleteMembers
parameter_list|(
specifier|const
name|DeleteMembers
modifier|&
parameter_list|)
constructor_decl|=
specifier|delete
constructor_decl|;
name|~
name|DeleteMembers
argument_list|()
operator|=
operator|delete
expr_stmt|;
block|}
struct|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_delegating_constructors
name|void
name|tst_Compiler
operator|::
name|cxx11_delegating_constructors
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_DELEGATING_CONSTRUCTORS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|DC
block|{
name|DC
parameter_list|(
name|int
name|i
parameter_list|)
member_init_list|:
name|i
argument_list|(
name|i
argument_list|)
block|{}
name|DC
parameter_list|()
member_init_list|:
name|DC
argument_list|(
literal|0
argument_list|)
block|{}
name|int
name|i
decl_stmt|;
block|}
struct|;
name|DC
name|dc
decl_stmt|;
name|QCOMPARE
argument_list|(
name|dc
operator|.
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_explicit_conversions
name|void
name|tst_Compiler
operator|::
name|cxx11_explicit_conversions
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_EXPLICIT_CONVERSIONS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|EC
block|{
specifier|explicit
name|operator
name|int
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
name|operator
name|long long
parameter_list|()
specifier|const
block|{
return|return
literal|1
return|;
block|}
block|}
struct|;
name|EC
name|ec
decl_stmt|;
name|int
name|i
argument_list|(
name|ec
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int
name|i2
init|=
name|ec
decl_stmt|;
name|QCOMPARE
argument_list|(
name|i2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_explicit_overrides
name|void
name|tst_Compiler
operator|::
name|cxx11_explicit_overrides
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_EXPLICIT_OVERRIDES
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|Base
block|{
specifier|virtual
name|~
name|Base
parameter_list|()
block|{}
specifier|virtual
name|void
name|f
parameter_list|()
block|{}
block|}
struct|;
struct|struct
name|Derived
specifier|final
super|:
specifier|public
name|Base
block|{
specifier|virtual
name|void
name|f
parameter_list|()
name|final
name|override
decl_stmt|{
block|}
block|}
end_function
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|Q_COMPILER_EXTERN_TEMPLATES
end_ifdef
begin_expr_stmt
unit|template
DECL|function|externTemplate
operator|<
typename|typename
name|T
operator|>
name|T
name|externTemplate
argument_list|()
block|{
return|return
name|T
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_expr_stmt
begin_function_decl
specifier|extern
specifier|template
name|int
name|externTemplate
argument_list|<
name|int
argument_list|>
parameter_list|()
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_extern_templates
name|void
name|tst_Compiler
operator|::
name|cxx11_extern_templates
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_EXTERN_TEMPLATES
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QCOMPARE
argument_list|(
name|externTemplate
argument_list|<
name|int
argument_list|>
argument_list|()
argument_list|,
literal|42
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_inheriting_constructors
name|void
name|tst_Compiler
operator|::
name|cxx11_inheriting_constructors
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_INHERITING_CONSTRUCTORS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|Base
block|{
name|int
name|i
decl_stmt|;
name|Base
parameter_list|()
member_init_list|:
name|i
argument_list|(
literal|0
argument_list|)
block|{}
name|Base
parameter_list|(
name|int
name|i
parameter_list|)
member_init_list|:
name|i
argument_list|(
name|i
argument_list|)
block|{}
block|}
struct|;
struct|struct
name|Derived
super|:
specifier|public
name|Base
block|{
using|using
name|Base
operator|::
name|Base
using|;
block|}
struct|;
name|Derived
name|d
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|d
operator|.
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_initializer_lists
name|void
name|tst_Compiler
operator|::
name|cxx11_initializer_lists
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_INITIALIZER_LISTS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QList
argument_list|<
name|int
argument_list|>
name|l
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
name|QCOMPARE
argument_list|(
name|l
operator|.
name|length
argument_list|()
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|l
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|l
operator|.
name|at
argument_list|(
literal|4
argument_list|)
argument_list|,
literal|5
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_struct
DECL|struct|CallFunctor
struct|struct
name|CallFunctor
block|{
DECL|function|f
template|template
parameter_list|<
name|typename
name|Functor
parameter_list|>
specifier|static
name|int
name|f
parameter_list|(
name|Functor
name|f
parameter_list|)
block|{
return|return
name|f
argument_list|()
return|;
block|}
block|}
struct|;
end_struct
begin_function
DECL|function|cxx11_lambda
name|void
name|tst_Compiler
operator|::
name|cxx11_lambda
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_LAMBDA
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QCOMPARE
argument_list|(
name|CallFunctor
operator|::
name|f
argument_list|(
capture|[]
parameter_list|()
block|{
return|return
literal|42
return|;
block|}
argument_list|)
argument_list|,
literal|42
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_nonstatic_member_init
name|void
name|tst_Compiler
operator|::
name|cxx11_nonstatic_member_init
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_NONSTATIC_MEMBER_INIT
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|S
block|{
name|int
name|i
init|=
literal|42
decl_stmt|;
name|long
name|l
init|=
literal|47
decl_stmt|;
name|char
name|c
decl_stmt|;
name|S
parameter_list|()
member_init_list|:
name|l
argument_list|(
operator|-
literal|47
argument_list|)
member_init_list|,
name|c
argument_list|(
literal|0
argument_list|)
block|{}
block|}
struct|;
name|S
name|s
decl_stmt|;
name|QCOMPARE
argument_list|(
name|s
operator|.
name|i
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|s
operator|.
name|l
argument_list|,
operator|-
literal|47L
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|s
operator|.
name|c
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_noexcept
name|void
name|tst_Compiler
operator|::
name|cxx11_noexcept
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_NOEXCEPT
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|extern
name|void
name|noexcept_f
argument_list|()
noexcept|noexcept
decl_stmt|;
specifier|extern
name|void
name|g
argument_list|()
noexcept|noexcept
argument_list|(
noexcept|noexcept
argument_list|(
name|noexcept_f
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
noexcept|noexcept
argument_list|(
name|cxx11_noexcept
argument_list|()
argument_list|)
operator|,
literal|false
block|)
function|;
end_function
begin_expr_stmt
name|QCOMPARE
argument_list|(
noexcept|noexcept
argument_list|(
name|noexcept_f
argument_list|)
operator|,
literal|true
end_expr_stmt
begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|QCOMPARE
argument_list|(
noexcept|noexcept
argument_list|(
name|g
argument_list|)
operator|,
literal|true
end_expr_stmt
begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_macro
unit|}  void
DECL|function|cxx11_nullptr
name|tst_Compiler
end_macro
begin_expr_stmt
DECL|function|cxx11_nullptr
operator|::
name|cxx11_nullptr
operator|(
operator|)
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_NULLPTR
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
block|;
else|#
directive|else
name|void
operator|*
name|v
operator|=
literal|nullptr
block|;
name|char
operator|*
name|c
operator|=
literal|nullptr
block|;
specifier|const
name|char
operator|*
name|cc
operator|=
literal|nullptr
block|;
specifier|volatile
name|char
operator|*
name|vc
operator|=
literal|nullptr
block|;
name|std
operator|::
name|nullptr_t
name|np
operator|=
literal|nullptr
block|;
name|v
operator|=
name|np
block|;
name|Q_UNUSED
argument_list|(
name|v
argument_list|)
block|;
name|Q_UNUSED
argument_list|(
name|c
argument_list|)
block|;
name|Q_UNUSED
argument_list|(
name|cc
argument_list|)
block|;
name|Q_UNUSED
argument_list|(
name|vc
argument_list|)
block|;
endif|#
directive|endif
block|}
DECL|function|cxx11_range_for
name|void
name|tst_Compiler
operator|::
name|cxx11_range_for
operator|(
operator|)
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_RANGE_FOR
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
block|;
else|#
directive|else
name|QList
argument_list|<
name|int
argument_list|>
name|l
block|;
name|l
operator|<<
literal|1
operator|<<
literal|2
operator|<<
literal|3
block|;
for|for
control|(
name|int
name|i
range|:
name|l
control|)
name|Q_UNUSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|l
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|l
operator|<<
literal|1
expr_stmt|;
end_expr_stmt
begin_for
for|for
control|(
name|int
name|i
range|:
name|l
control|)
name|QCOMPARE
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_for
begin_decl_stmt
name|QList
argument_list|<
name|long
argument_list|>
name|ll
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|l
operator|<<
literal|2
expr_stmt|;
end_expr_stmt
begin_for
for|for
control|(
name|int
name|i
range|:
name|ll
control|)
name|QCOMPARE
argument_list|(
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_for
begin_endif
endif|#
directive|endif
end_endif
begin_macro
unit|}  void
DECL|function|cxx11_raw_strings
name|tst_Compiler
end_macro
begin_expr_stmt
DECL|function|cxx11_raw_strings
operator|::
name|cxx11_raw_strings
operator|(
operator|)
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_RAW_STRINGS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
block|;
else|#
directive|else
specifier|static
specifier|const
name|char
name|xml
index|[]
operator|=
literal|R"(<?xml version="1.0" encoding="UTF-8" ?>)"
block|;
specifier|static
specifier|const
name|char
name|raw
index|[]
operator|=
literal|R"***(*"*)***"
block|;
name|QCOMPARE
argument_list|(
name|strlen
argument_list|(
name|raw
argument_list|)
argument_list|,
name|size_t
argument_list|(
literal|3
argument_list|)
argument_list|)
block|;
name|QCOMPARE
argument_list|(
name|raw
index|[
literal|1
index|]
argument_list|,
literal|'"'
argument_list|)
block|;
name|Q_UNUSED
argument_list|(
name|xml
argument_list|)
block|;
endif|#
directive|endif
block|}
DECL|function|cxx11_ref_qualifiers
name|void
name|tst_Compiler
operator|::
name|cxx11_ref_qualifiers
operator|(
operator|)
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_REF_QUALIFIERS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
block|;
else|#
directive|else
ifndef|#
directive|ifndef
name|Q_COMPILER_RVALUE_REFS
error|#
directive|error
literal|"Impossible condition: ref qualifiers are supported but not rvalue refs"
endif|#
directive|endif
comment|// also applies to function pointers
name|QByteArray
argument_list|(
argument|QString:: *lvalueref
argument_list|)
operator|(
operator|)
specifier|const
operator|&
operator|=
operator|&
name|QString
operator|::
name|toLatin1
block|;
name|QByteArray
argument_list|(
name|QString
operator|::
modifier|*
name|rvalueref
argument_list|)
argument_list|()
operator|&&
operator|=
operator|&
name|QString
operator|::
name|toLatin1
block|;
name|QString
name|s
argument_list|(
literal|"Hello"
argument_list|)
block|;
name|QCOMPARE
argument_list|(
call|(
name|s
operator|.*
name|lvalueref
call|)
argument_list|()
argument_list|,
name|QByteArray
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
block|;
name|QCOMPARE
argument_list|(
operator|(
name|std
operator|::
name|move
argument_list|(
name|s
argument_list|)
operator|.*
name|rvalueref
operator|)
operator|(
operator|)
argument_list|,
name|QByteArray
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
block|;
comment|// tests internal behavior:
name|QVERIFY
argument_list|(
name|s
operator|.
name|isEmpty
argument_list|()
argument_list|)
block|;
endif|#
directive|endif
block|}
DECL|function|cxx11_rvalue_refs
name|void
name|tst_Compiler
operator|::
name|cxx11_rvalue_refs
operator|(
operator|)
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_RVALUE_REFS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
block|;
else|#
directive|else
name|int
name|i
operator|=
literal|1
block|;
name|i
operator|=
name|std
operator|::
name|move
argument_list|(
name|i
argument_list|)
block|;
name|QString
name|s
operator|=
literal|"Hello"
block|;
name|QString
name|t
operator|=
name|std
operator|::
name|move
argument_list|(
name|s
argument_list|)
block|;
name|QCOMPARE
argument_list|(
name|t
argument_list|,
name|QString
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
block|;
name|s
operator|=
name|t
block|;
name|t
operator|=
name|std
operator|::
name|move
argument_list|(
name|s
argument_list|)
block|;
name|QCOMPARE
argument_list|(
name|t
argument_list|,
name|QString
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
block|;
name|QString
operator|&&
name|r
operator|=
name|std
operator|::
name|move
argument_list|(
name|s
argument_list|)
block|;
name|QCOMPARE
argument_list|(
name|r
argument_list|,
name|QString
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
block|;
endif|#
directive|endif
block|}
DECL|function|cxx11_static_assert
name|void
name|tst_Compiler
operator|::
name|cxx11_static_assert
operator|(
operator|)
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_STATIC_ASSERT
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
block|;
else|#
directive|else
assert|static_assert
argument_list|(
literal|true
argument_list|,
literal|"Message"
argument_list|)
assert|;
endif|#
directive|endif
block|}
end_expr_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_TEMPLATE_ALIAS
end_ifdef
begin_using
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
using|using
name|Map
init|=
name|QMap
argument_list|<
name|QString
argument_list|,
name|T
argument_list|>
using|;
end_using
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_template_alias
name|void
name|tst_Compiler
operator|::
name|cxx11_template_alias
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_TEMPLATE_ALIAS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|Map
argument_list|<
name|QVariant
argument_list|>
name|m
decl_stmt|;
name|m
operator|.
name|insert
argument_list|(
literal|"Hello"
argument_list|,
literal|"World"
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|m
operator|.
name|value
argument_list|(
literal|"Hello"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|QString
argument_list|(
literal|"World"
argument_list|)
argument_list|)
expr_stmt|;
using|using
name|X
init|=
name|int
using|;
name|X
name|i
init|=
literal|0
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_THREAD_LOCAL
end_ifdef
begin_decl_stmt
DECL|variable|stl
specifier|static
specifier|thread_local
name|int
name|stl
init|=
literal|42
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|gtl
specifier|thread_local
name|int
name|gtl
init|=
literal|42
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_thread_local
name|void
name|tst_Compiler
operator|::
name|cxx11_thread_local
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_THREAD_LOCAL
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|thread_local
name|int
name|v
init|=
literal|1
decl_stmt|;
name|QVERIFY
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|stl
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|gtl
argument_list|)
expr_stmt|;
specifier|thread_local
name|QString
name|s
init|=
literal|"Hello"
decl_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_UDL
end_ifdef
begin_function
DECL|function|_tstqstring
name|QString
name|operator
name|"" _tstqstring
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
operator|+
literal|" UDL"
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_udl
name|void
name|tst_Compiler
operator|::
name|cxx11_udl
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_UDL
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QString
name|s
init|=
literal|"Hello World"
name|_tstqstring
decl_stmt|;
name|QCOMPARE
argument_list|(
name|s
argument_list|,
name|QString
argument_list|(
literal|"Hello World UDL"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_unicode_strings
name|void
name|tst_Compiler
operator|::
name|cxx11_unicode_strings
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_UNICODE_STRINGS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|static
specifier|const
name|char16_t
name|u
index|[]
init|=
literal|u"\u200BHello\u00A0World"
decl_stmt|;
name|QCOMPARE
argument_list|(
name|u
index|[
literal|0
index|]
argument_list|,
name|char16_t
argument_list|(
literal|0x200B
argument_list|)
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|char32_t
name|U
index|[]
init|=
literal|U"\ufffe"
decl_stmt|;
name|QCOMPARE
argument_list|(
name|U
index|[
literal|0
index|]
argument_list|,
name|char32_t
argument_list|(
literal|0xfffe
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
literal|u"\U00010000"
index|[
literal|0
index|]
argument_list|,
name|char16_t
argument_list|(
literal|0xD800
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
literal|u"\U00010000"
index|[
literal|1
index|]
argument_list|,
name|char16_t
argument_list|(
literal|0xDC00
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|noop
specifier|static
name|void
name|noop
parameter_list|(
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
parameter_list|)
block|{}
end_function
begin_function
DECL|function|cxx11_uniform_init
name|void
name|tst_Compiler
operator|::
name|cxx11_uniform_init
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_UNIFORM_INIT
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
name|noop
argument_list|(
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|QString
name|s
argument_list|{
literal|"Hello"
argument_list|}
decl_stmt|;
name|int
name|i
argument_list|{}
decl_stmt|;
name|noop
argument_list|(
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
block|{
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|noop
argument_list|(
block|{
name|i
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_unrestricted_unions
name|void
name|tst_Compiler
operator|::
name|cxx11_unrestricted_unions
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_UNRESTRICTED_UNIONS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
union|union
name|U
block|{
name|QString
name|s
decl_stmt|;
name|U
parameter_list|()
block|{}
name|U
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
member_init_list|:
name|s
argument_list|(
name|s
argument_list|)
block|{}
name|~
name|U
parameter_list|()
block|{}
block|}
union|;
name|U
name|u
decl_stmt|;
name|std
operator|::
name|aligned_storage
operator|<
sizeof|sizeof
argument_list|(
name|QString
argument_list|)
operator|,
name|Q_ALIGNOF
argument_list|(
name|QString
argument_list|)
operator|>
name|as
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|U
name|u2
argument_list|(
literal|"hello"
argument_list|)
decl_stmt|;
name|u2
operator|.
name|s
operator|.
name|~
name|QString
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_variadic_macros
name|void
name|tst_Compiler
operator|::
name|cxx11_variadic_macros
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_VARIADIC_MACROS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|TEST_VARARG
parameter_list|(
name|x
parameter_list|,
modifier|...
parameter_list|)
value|__VA_ARGS__
name|QCOMPARE
argument_list|(
name|TEST_VARARG
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_VARIADIC_TEMPLATES
end_ifdef
begin_struct
DECL|struct|VariadicTemplate
template|template
parameter_list|<
name|typename
modifier|...
name|Args
parameter_list|>
struct|struct
name|VariadicTemplate
block|{
block|}
struct|;
end_struct
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_variadic_templates
name|void
name|tst_Compiler
operator|::
name|cxx11_variadic_templates
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_VARIADIC_TEMPLATES
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|VariadicTemplate
argument_list|<>
name|v0
decl_stmt|;
name|VariadicTemplate
argument_list|<
name|int
argument_list|>
name|v1
decl_stmt|;
name|VariadicTemplate
argument_list|<
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|>
name|v8
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|v0
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|v1
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|v8
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx14_binary_literals
name|void
name|tst_Compiler
operator|::
name|cxx14_binary_literals
parameter_list|()
block|{
if|#
directive|if
name|__cpp_binary_literals
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|i
init|=
literal|0b11001001
decl_stmt|;
name|QCOMPARE
argument_list|(
name|i
argument_list|,
literal|0xC9
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx14_init_captures
name|void
name|tst_Compiler
operator|::
name|cxx14_init_captures
parameter_list|()
block|{
if|#
directive|if
name|__cpp_init_captures
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QCOMPARE
argument_list|(
capture|[
name|x
init|=
literal|42
capture|]
parameter_list|()
block|{
return|return
name|x
return|;
block|}
argument_list|()
argument_list|,
literal|42
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx14_generic_lambdas
name|void
name|tst_Compiler
operator|::
name|cxx14_generic_lambdas
parameter_list|()
block|{
if|#
directive|if
name|__cpp_generic_lambdas
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|auto
name|identity
init|=
capture|[]
parameter_list|(
name|auto
name|x
parameter_list|)
block|{
return|return
name|x
return|;
block|}
decl_stmt|;
name|QCOMPARE
argument_list|(
name|identity
argument_list|(
literal|42
argument_list|)
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|identity
argument_list|(
literal|42U
argument_list|)
argument_list|,
literal|42U
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|identity
argument_list|(
literal|42L
argument_list|)
argument_list|,
literal|42L
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|__cpp_constexpr
operator|-
literal|0
operator|>=
literal|201304
end_if
begin_function
DECL|function|relaxedConstexpr
specifier|constexpr
name|int
name|relaxedConstexpr
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|i
operator|*=
literal|2
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx14_constexpr
name|void
name|tst_Compiler
operator|::
name|cxx14_constexpr
parameter_list|()
block|{
if|#
directive|if
name|__cpp_constexpr
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QCOMPARE
argument_list|(
name|relaxedConstexpr
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|relaxedConstexpr
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx14_decltype_auto
name|void
name|tst_Compiler
operator|::
name|cxx14_decltype_auto
parameter_list|()
block|{
if|#
directive|if
name|__cpp_decltype_auto
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QList
argument_list|<
name|int
argument_list|>
name|l
decl_stmt|;
name|l
operator|<<
literal|1
expr_stmt|;
decltype|decltype
argument_list|(
name|auto
argument_list|)
name|value
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
name|QCOMPARE
argument_list|(
name|l
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|__cpp_return_type_deduction
operator|>=
literal|201304
end_if
begin_function
DECL|function|returnTypeDeduction
name|auto
name|returnTypeDeduction
parameter_list|()
block|{
return|return
literal|1U
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx14_return_type_deduction
name|void
name|tst_Compiler
operator|::
name|cxx14_return_type_deduction
parameter_list|()
block|{
if|#
directive|if
name|__cpp_return_type_deduction
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QCOMPARE
argument_list|(
name|returnTypeDeduction
argument_list|()
argument_list|,
literal|1U
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx14_aggregate_nsdmi
name|void
name|tst_Compiler
operator|::
name|cxx14_aggregate_nsdmi
parameter_list|()
block|{
if|#
directive|if
name|__cpp_aggregate_nsdmi
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|S
block|{
name|int
name|i
decl_stmt|,
name|j
init|=
name|i
decl_stmt|;
block|}
struct|;
name|S
name|s
init|=
block|{
literal|1
block|}
decl_stmt|;
name|QCOMPARE
argument_list|(
name|s
operator|.
name|j
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|__cpp_variable_templates
operator|>=
literal|201304
end_if
begin_decl_stmt
DECL|variable|variableTemplate
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
specifier|constexpr
name|T
name|variableTemplate
init|=
name|T
argument_list|(
literal|42
argument_list|)
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx14_variable_templates
name|void
name|tst_Compiler
operator|::
name|cxx14_variable_templates
parameter_list|()
block|{
if|#
directive|if
name|__cpp_variable_templates
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QCOMPARE
argument_list|(
name|variableTemplate
argument_list|<
name|int
argument_list|>
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|variableTemplate
argument_list|<
name|long
argument_list|>
argument_list|,
literal|42L
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|variableTemplate
argument_list|<
name|unsigned
argument_list|>
argument_list|,
literal|42U
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
argument|variableTemplate<unsigned long long>
argument_list|,
literal|42ULL
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|runtimeArrays
name|void
name|tst_Compiler
operator|::
name|runtimeArrays
parameter_list|()
block|{
if|#
directive|if
name|__cpp_runtime_arrays
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|i
index|[
name|qrand
argument_list|()
operator|&
literal|0x1f
index|]
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_macro
name|QTEST_MAIN
argument_list|(
argument|tst_Compiler
argument_list|)
end_macro
begin_include
include|#
directive|include
file|"tst_compiler.moc"
end_include
end_unit
