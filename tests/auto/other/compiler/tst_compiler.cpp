begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Copyright (C) 2016 Intel Corporation. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the test suite of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:GPL-EXCEPT$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3 as published by the Free Software ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtCore/QtCore>
end_include
begin_include
include|#
directive|include
file|<QtTest/QtTest>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_define
DECL|macro|BASECLASS_NOT_ABSTRACT
define|#
directive|define
name|BASECLASS_NOT_ABSTRACT
end_define
begin_include
include|#
directive|include
file|"baseclass.h"
end_include
begin_include
include|#
directive|include
file|"derivedclass.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_ATOMICS
end_ifdef
begin_include
include|#
directive|include
file|<atomic>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_USE_NAMESPACE
end_macro
begin_class
DECL|class|tst_Compiler
class|class
name|tst_Compiler
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
private|private
name|slots
private|:
comment|/* C++98& C++03 base functionality */
name|void
name|template_methods
parameter_list|()
function_decl|;
name|void
name|template_constructors
parameter_list|()
function_decl|;
name|void
name|template_subclasses
parameter_list|()
function_decl|;
name|void
name|methodSpecialization
parameter_list|()
function_decl|;
name|void
name|constructorSpecialization
parameter_list|()
function_decl|;
name|void
name|staticTemplateMethods
parameter_list|()
function_decl|;
name|void
name|staticTemplateMethodSpecialization
parameter_list|()
function_decl|;
name|void
name|detectDataStream
parameter_list|()
function_decl|;
name|void
name|detectEnums
parameter_list|()
function_decl|;
name|void
name|overrideCFunction
parameter_list|()
function_decl|;
name|void
name|stdSortQList
parameter_list|()
function_decl|;
name|void
name|stdSortQVector
parameter_list|()
function_decl|;
name|void
name|templateCallOrder
parameter_list|()
function_decl|;
name|void
name|virtualFunctionNoLongerPureVirtual
parameter_list|()
function_decl|;
name|void
name|charSignedness
parameter_list|()
specifier|const
function_decl|;
name|void
name|privateStaticTemplateMember
parameter_list|()
specifier|const
function_decl|;
name|void
name|staticConstUnionWithInitializerList
parameter_list|()
specifier|const
function_decl|;
name|void
name|templateFriends
parameter_list|()
function_decl|;
comment|/* C++11 features */
name|void
name|cxx11_alignas
parameter_list|()
function_decl|;
name|void
name|cxx11_alignof
parameter_list|()
function_decl|;
name|void
name|cxx11_alignas_alignof
parameter_list|()
function_decl|;
name|void
name|cxx11_atomics
parameter_list|()
function_decl|;
name|void
name|cxx11_attributes
parameter_list|()
function_decl|;
name|void
name|cxx11_auto_function
parameter_list|()
function_decl|;
name|void
name|cxx11_auto_type
parameter_list|()
function_decl|;
name|void
name|cxx11_class_enum
parameter_list|()
function_decl|;
name|void
name|cxx11_constexpr
parameter_list|()
function_decl|;
name|void
name|cxx11_decltype
parameter_list|()
function_decl|;
name|void
name|cxx11_default_members
parameter_list|()
function_decl|;
name|void
name|cxx11_delete_members
parameter_list|()
function_decl|;
name|void
name|cxx11_delegating_constructors
parameter_list|()
function_decl|;
name|void
name|cxx11_explicit_conversions
parameter_list|()
function_decl|;
name|void
name|cxx11_explicit_overrides
parameter_list|()
function_decl|;
name|void
name|cxx11_extern_templates
parameter_list|()
function_decl|;
name|void
name|cxx11_inheriting_constructors
parameter_list|()
function_decl|;
name|void
name|cxx11_initializer_lists
parameter_list|()
function_decl|;
name|void
name|cxx11_lambda
parameter_list|()
function_decl|;
name|void
name|cxx11_nonstatic_member_init
parameter_list|()
function_decl|;
name|void
name|cxx11_noexcept
parameter_list|()
function_decl|;
name|void
name|cxx11_nullptr
parameter_list|()
function_decl|;
name|void
name|cxx11_range_for
parameter_list|()
function_decl|;
name|void
name|cxx11_raw_strings
parameter_list|()
function_decl|;
name|void
name|cxx11_ref_qualifiers
parameter_list|()
function_decl|;
name|void
name|cxx11_rvalue_refs
parameter_list|()
function_decl|;
name|void
name|cxx11_static_assert
parameter_list|()
function_decl|;
name|void
name|cxx11_template_alias
parameter_list|()
function_decl|;
name|void
name|cxx11_thread_local
parameter_list|()
function_decl|;
name|void
name|cxx11_udl
parameter_list|()
function_decl|;
name|void
name|cxx11_unicode_strings
parameter_list|()
function_decl|;
name|void
name|cxx11_uniform_init
parameter_list|()
function_decl|;
name|void
name|cxx11_unrestricted_unions
parameter_list|()
function_decl|;
name|void
name|cxx11_variadic_macros
parameter_list|()
function_decl|;
name|void
name|cxx11_variadic_templates
parameter_list|()
function_decl|;
comment|/* C++14 compiler features */
name|void
name|cxx14_binary_literals
parameter_list|()
function_decl|;
name|void
name|cxx14_init_captures
parameter_list|()
function_decl|;
name|void
name|cxx14_generic_lambdas
parameter_list|()
function_decl|;
name|void
name|cxx14_constexpr
parameter_list|()
function_decl|;
name|void
name|cxx14_decltype_auto
parameter_list|()
function_decl|;
name|void
name|cxx14_return_type_deduction
parameter_list|()
function_decl|;
name|void
name|cxx14_aggregate_nsdmi
parameter_list|()
function_decl|;
name|void
name|cxx14_variable_templates
parameter_list|()
function_decl|;
comment|/* Future / Technical specification compiler features */
name|void
name|runtimeArrays
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_HPACC
argument_list|)
end_if
begin_define
DECL|macro|DONT_TEST_TEMPLATE_CONSTRUCTORS
define|#
directive|define
name|DONT_TEST_TEMPLATE_CONSTRUCTORS
end_define
begin_define
DECL|macro|DONT_TEST_CONSTRUCTOR_SPECIALIZATION
define|#
directive|define
name|DONT_TEST_CONSTRUCTOR_SPECIALIZATION
end_define
begin_define
DECL|macro|DONT_TEST_DATASTREAM_DETECTION
define|#
directive|define
name|DONT_TEST_DATASTREAM_DETECTION
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_SUN
argument_list|)
end_if
begin_define
DECL|macro|DONT_TEST_STL_SORTING
define|#
directive|define
name|DONT_TEST_STL_SORTING
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_class
DECL|class|TemplateMethodClass
class|class
name|TemplateMethodClass
block|{
public|public:
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|foo
name|T
name|foo
parameter_list|()
block|{
return|return
literal|42
return|;
block|}
block|}
class|;
end_class
begin_function
DECL|function|template_methods
name|void
name|tst_Compiler
operator|::
name|template_methods
parameter_list|()
block|{
name|TemplateMethodClass
name|t
decl_stmt|;
name|QCOMPARE
argument_list|(
name|t
operator|.
name|foo
argument_list|<
name|int
argument_list|>
argument_list|()
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t
operator|.
name|foo
argument_list|<
name|long
argument_list|>
argument_list|()
argument_list|,
literal|42l
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t
operator|.
name|foo
argument_list|<
name|double
argument_list|>
argument_list|()
argument_list|,
literal|42.0
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|DONT_TEST_TEMPLATE_CONSTRUCTORS
end_ifndef
begin_class
DECL|class|TemplateConstructorClass
class|class
name|TemplateConstructorClass
block|{
public|public:
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|TemplateConstructorClass
name|TemplateConstructorClass
parameter_list|(
specifier|const
name|T
modifier|&
name|t
parameter_list|)
block|{
name|i
operator|=
name|int
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
DECL|member|i
name|int
name|i
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|template_constructors
name|void
name|tst_Compiler
operator|::
name|template_constructors
parameter_list|()
block|{
name|TemplateConstructorClass
name|t1
argument_list|(
literal|42
argument_list|)
decl_stmt|;
name|TemplateConstructorClass
name|t2
argument_list|(
literal|42l
argument_list|)
decl_stmt|;
name|TemplateConstructorClass
name|t3
argument_list|(
literal|42.0
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|t1
operator|.
name|i
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t2
operator|.
name|i
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t3
operator|.
name|i
argument_list|,
literal|42
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|template_constructors
name|void
name|tst_Compiler
operator|::
name|template_constructors
parameter_list|()
block|{
name|QSKIP
argument_list|(
literal|"Compiler doesn't do template constructors"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_struct
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|OuterClass
name|OuterClass
block|{
template|template
parameter_list|<
name|typename
name|U
parameter_list|>
struct|struct
DECL|struct|InnerClass
name|InnerClass
block|{
DECL|function|convert
name|U
name|convert
parameter_list|(
specifier|const
name|T
modifier|&
name|t
parameter_list|)
block|{
return|return
cast|static_cast
argument_list|<
name|U
argument_list|>
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
struct|;
block|}
struct|;
end_struct
begin_function
DECL|function|template_subclasses
name|void
name|tst_Compiler
operator|::
name|template_subclasses
parameter_list|()
block|{
name|OuterClass
argument_list|<
name|char
argument_list|>
operator|::
name|InnerClass
argument_list|<
name|int
argument_list|>
name|c1
decl_stmt|;
name|QCOMPARE
argument_list|(
name|c1
operator|.
name|convert
argument_list|(
literal|'a'
argument_list|)
argument_list|,
name|int
argument_list|(
literal|'a'
argument_list|)
argument_list|)
expr_stmt|;
name|OuterClass
argument_list|<
name|QRect
argument_list|>
operator|::
name|InnerClass
argument_list|<
name|QRectF
argument_list|>
name|c2
decl_stmt|;
name|QCOMPARE
argument_list|(
name|c2
operator|.
name|convert
argument_list|(
name|QRect
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|,
name|QRectF
argument_list|(
name|QRect
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_class
DECL|class|TemplateMethodClass2
class|class
name|TemplateMethodClass2
block|{
public|public:
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|foo
name|T
name|foo
parameter_list|()
block|{
return|return
literal|42
return|;
block|}
block|}
class|;
end_class
begin_function
template|template
parameter_list|<>
DECL|function|foo
name|int
name|TemplateMethodClass2
operator|::
name|foo
argument_list|<
name|int
argument_list|>
parameter_list|()
block|{
return|return
literal|43
return|;
block|}
end_function
begin_function
DECL|function|methodSpecialization
name|void
name|tst_Compiler
operator|::
name|methodSpecialization
parameter_list|()
block|{
name|TemplateMethodClass2
name|t
decl_stmt|;
name|QCOMPARE
argument_list|(
name|t
operator|.
name|foo
argument_list|<
name|int
argument_list|>
argument_list|()
argument_list|,
literal|43
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t
operator|.
name|foo
argument_list|<
name|long
argument_list|>
argument_list|()
argument_list|,
literal|42l
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t
operator|.
name|foo
argument_list|<
name|double
argument_list|>
argument_list|()
argument_list|,
literal|42.0
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|DONT_TEST_CONSTRUCTOR_SPECIALIZATION
end_ifndef
begin_class
DECL|class|TemplateConstructorClass2
class|class
name|TemplateConstructorClass2
block|{
public|public:
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|TemplateConstructorClass2
name|TemplateConstructorClass2
parameter_list|(
specifier|const
name|T
modifier|&
name|t
parameter_list|)
block|{
name|i
operator|=
name|int
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
DECL|member|i
name|int
name|i
decl_stmt|;
block|}
class|;
end_class
begin_constructor
template|template
parameter_list|<>
DECL|function|TemplateConstructorClass2
name|TemplateConstructorClass2
operator|::
name|TemplateConstructorClass2
parameter_list|(
specifier|const
name|int
modifier|&
name|t
parameter_list|)
block|{
name|i
operator|=
name|t
operator|+
literal|1
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|constructorSpecialization
name|void
name|tst_Compiler
operator|::
name|constructorSpecialization
parameter_list|()
block|{
name|TemplateConstructorClass2
name|t1
argument_list|(
literal|42
argument_list|)
decl_stmt|;
name|TemplateConstructorClass2
name|t2
argument_list|(
literal|42l
argument_list|)
decl_stmt|;
name|TemplateConstructorClass2
name|t3
argument_list|(
literal|42.0
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|t1
operator|.
name|i
argument_list|,
literal|43
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t2
operator|.
name|i
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t3
operator|.
name|i
argument_list|,
literal|42
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|constructorSpecialization
name|void
name|tst_Compiler
operator|::
name|constructorSpecialization
parameter_list|()
block|{
name|QSKIP
argument_list|(
literal|"Compiler doesn't do constructor specialization"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_class
DECL|class|StaticTemplateClass
class|class
name|StaticTemplateClass
block|{
public|public:
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|foo
specifier|static
name|T
name|foo
parameter_list|()
block|{
return|return
literal|42
return|;
block|}
block|}
class|;
end_class
begin_function
DECL|function|staticTemplateMethods
name|void
name|tst_Compiler
operator|::
name|staticTemplateMethods
parameter_list|()
block|{
name|QCOMPARE
argument_list|(
name|StaticTemplateClass
operator|::
name|foo
argument_list|<
name|int
argument_list|>
argument_list|()
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|StaticTemplateClass
operator|::
name|foo
argument_list|<
name|uint
argument_list|>
argument_list|()
argument_list|,
literal|42u
argument_list|)
expr_stmt|;
block|}
end_function
begin_class
DECL|class|StaticTemplateClass2
class|class
name|StaticTemplateClass2
block|{
public|public:
template|template
parameter_list|<
name|class
name|T
parameter_list|>
DECL|function|foo
specifier|static
name|T
name|foo
parameter_list|()
block|{
return|return
literal|42
return|;
block|}
block|}
class|;
end_class
begin_function
template|template
parameter_list|<>
DECL|function|foo
name|double
name|StaticTemplateClass2
operator|::
name|foo
argument_list|<
name|double
argument_list|>
parameter_list|()
block|{
return|return
literal|18.5
return|;
block|}
end_function
begin_function
DECL|function|staticTemplateMethodSpecialization
name|void
name|tst_Compiler
operator|::
name|staticTemplateMethodSpecialization
parameter_list|()
block|{
name|QCOMPARE
argument_list|(
name|StaticTemplateClass2
operator|::
name|foo
argument_list|<
name|int
argument_list|>
argument_list|()
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|StaticTemplateClass2
operator|::
name|foo
argument_list|<
name|uint
argument_list|>
argument_list|()
argument_list|,
literal|42u
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|StaticTemplateClass2
operator|::
name|foo
argument_list|<
name|double
argument_list|>
argument_list|()
argument_list|,
literal|18.5
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|DONT_TEST_DATASTREAM_DETECTION
end_ifndef
begin_comment
comment|/******* DataStream tester *********/
end_comment
begin_namespace
DECL|namespace|QtTestInternal
namespace|namespace
name|QtTestInternal
block|{
DECL|struct|EmptyStruct
struct|struct
name|EmptyStruct
block|{
block|}
struct|;
DECL|struct|LowPreferenceStruct
struct|struct
name|LowPreferenceStruct
block|{
name|LowPreferenceStruct
parameter_list|(
modifier|...
parameter_list|)
constructor_decl|;
block|}
struct|;
name|EmptyStruct
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
parameter_list|,
specifier|const
name|LowPreferenceStruct
modifier|&
parameter_list|)
function_decl|;
name|EmptyStruct
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
parameter_list|,
specifier|const
name|LowPreferenceStruct
modifier|&
parameter_list|)
function_decl|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|DataStreamChecker
name|DataStreamChecker
block|{
specifier|static
name|EmptyStruct
name|hasStreamHelper
parameter_list|(
specifier|const
name|EmptyStruct
modifier|&
parameter_list|)
function_decl|;
specifier|static
name|QDataStream
name|hasStreamHelper
parameter_list|(
specifier|const
name|QDataStream
modifier|&
parameter_list|)
function_decl|;
specifier|static
name|QDataStream
modifier|&
name|dsDummy
parameter_list|()
function_decl|;
specifier|static
name|T
modifier|&
name|dummy
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|BROKEN_COMPILER
DECL|member|HasDataStream
specifier|static
specifier|const
name|bool
name|HasDataStream
init|=
sizeof|sizeof
argument_list|(
name|hasStreamHelper
argument_list|(
name|dsDummy
argument_list|()
operator|<<
name|dummy
argument_list|()
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QDataStream
argument_list|)
operator|&&
sizeof|sizeof
argument_list|(
name|hasStreamHelper
argument_list|(
name|dsDummy
argument_list|()
operator|>>
name|dummy
argument_list|()
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QDataStream
argument_list|)
decl_stmt|;
else|#
directive|else
enum|enum
block|{
DECL|enumerator|HasOutDataStream
name|HasOutDataStream
init|=
sizeof|sizeof
argument_list|(
name|hasStreamHelper
argument_list|(
name|dsDummy
argument_list|()
operator|>>
name|dummy
argument_list|()
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QDataStream
argument_list|)
block|,
DECL|enumerator|HasInDataStream
name|HasInDataStream
init|=
sizeof|sizeof
argument_list|(
name|hasStreamHelper
argument_list|(
name|dsDummy
argument_list|()
operator|<<
name|dummy
argument_list|()
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QDataStream
argument_list|)
block|,
DECL|enumerator|HasDataStream
name|HasDataStream
init|=
name|HasOutDataStream
operator|&
name|HasInDataStream
block|}
enum|;
endif|#
directive|endif
block|}
struct|;
template|template
parameter_list|<
name|bool
parameter_list|>
struct|struct
DECL|struct|DataStreamOpHelper
name|DataStreamOpHelper
block|{
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|Getter
name|Getter
block|{
DECL|function|saveOp
specifier|static
name|QMetaType
operator|::
name|SaveOperator
name|saveOp
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
struct|;
block|}
struct|;
template|template
parameter_list|<>
struct|struct
DECL|struct|DataStreamOpHelper
name|DataStreamOpHelper
argument_list|<
literal|true
argument_list|>
block|{
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|Getter
name|Getter
block|{
DECL|function|saveOp
specifier|static
name|QMetaType
operator|::
name|SaveOperator
name|saveOp
parameter_list|()
block|{
return|return
operator|::
name|QtMetaTypePrivate
operator|::
name|QMetaTypeFunctionHelper
argument_list|<
name|T
argument_list|>
operator|::
name|Save
return|;
block|}
block|}
struct|;
block|}
struct|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|getSaveOperator
specifier|inline
name|QMetaType
operator|::
name|SaveOperator
name|getSaveOperator
parameter_list|(
name|T
modifier|*
init|=
literal|0
parameter_list|)
block|{
typedef|typedef
typename|typename
name|DataStreamOpHelper
argument_list|<
name|DataStreamChecker
argument_list|<
name|T
argument_list|>
operator|::
name|HasDataStream
argument_list|>
operator|::
specifier|template
name|Getter
argument_list|<
name|T
argument_list|>
name|GetterHelper
typedef|;
return|return
name|GetterHelper
operator|::
name|saveOp
argument_list|()
return|;
block|}
block|}
end_namespace
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_struct
DECL|struct|MyString
struct|struct
name|MyString
super|:
specifier|public
name|QString
block|{
block|}
struct|;
end_struct
begin_struct
DECL|struct|Qxxx
struct|struct
name|Qxxx
block|{
block|}
struct|;
end_struct
begin_function
DECL|function|detectDataStream
name|void
name|tst_Compiler
operator|::
name|detectDataStream
parameter_list|()
block|{
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
name|int
argument_list|>
operator|::
name|HasDataStream
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
name|uint
argument_list|>
operator|::
name|HasDataStream
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
name|char
operator|*
argument_list|>
operator|::
name|HasDataStream
operator|==
literal|true
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
specifier|const
name|int
argument_list|>
operator|::
name|HasInDataStream
operator|==
literal|true
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
specifier|const
name|int
argument_list|>
operator|::
name|HasOutDataStream
operator|==
literal|false
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
specifier|const
name|int
argument_list|>
operator|::
name|HasDataStream
operator|==
literal|false
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
name|double
argument_list|>
operator|::
name|HasDataStream
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
name|QString
argument_list|>
operator|::
name|HasDataStream
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
name|MyString
argument_list|>
operator|::
name|HasDataStream
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QtTestInternal
operator|::
name|DataStreamChecker
argument_list|<
name|Qxxx
argument_list|>
operator|::
name|HasDataStream
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|getSaveOperator
argument_list|<
name|int
argument_list|>
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|getSaveOperator
argument_list|<
name|uint
argument_list|>
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|getSaveOperator
argument_list|<
name|char
operator|*
argument_list|>
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|getSaveOperator
argument_list|<
name|double
argument_list|>
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|getSaveOperator
argument_list|<
name|QString
argument_list|>
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QtTestInternal
operator|::
name|getSaveOperator
argument_list|<
name|MyString
argument_list|>
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QtTestInternal
operator|::
name|getSaveOperator
argument_list|<
name|Qxxx
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|detectDataStream
name|void
name|tst_Compiler
operator|::
name|detectDataStream
parameter_list|()
block|{
name|QSKIP
argument_list|(
literal|"Compiler doesn't evaluate templates correctly"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_enum
DECL|enum|Enum1
DECL|enumerator|Foo
DECL|enumerator|Bar
enum|enum
name|Enum1
block|{
name|Foo
init|=
literal|0
block|,
name|Bar
init|=
literal|1
block|}
enum|;
end_enum
begin_enum
DECL|enum|Enum2
enum|enum
name|Enum2
block|{}
enum|;
end_enum
begin_enum
DECL|enum|Enum3
DECL|enumerator|Something
enum|enum
name|Enum3
block|{
name|Something
init|=
literal|1
block|}
enum|;
end_enum
begin_function_decl
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
name|char
name|QTypeInfoEnumHelper
parameter_list|(
name|T
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
name|void
modifier|*
name|QTypeInfoEnumHelper
parameter_list|(
modifier|...
parameter_list|)
function_decl|;
end_function_decl
begin_struct
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|QTestTypeInfo
name|QTestTypeInfo
block|{
DECL|enumerator|IsEnum
enum|enum
block|{
name|IsEnum
init|=
sizeof|sizeof
argument_list|(
name|QTypeInfoEnumHelper
argument_list|<
name|T
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|==
expr|sizeof
operator|(
name|void
operator|*
operator|)
block|}
enum|;
block|}
struct|;
end_struct
begin_function
DECL|function|detectEnums
name|void
name|tst_Compiler
operator|::
name|detectEnums
parameter_list|()
block|{
name|QVERIFY
argument_list|(
name|QTestTypeInfo
argument_list|<
name|Enum1
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QTestTypeInfo
argument_list|<
name|Enum2
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QTestTypeInfo
argument_list|<
name|Enum3
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|int
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|char
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|uint
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|short
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|ushort
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|void
operator|*
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|QString
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QTestTypeInfo
argument_list|<
name|Qt
operator|::
name|Key
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QTestTypeInfo
argument_list|<
name|Qt
operator|::
name|ToolBarArea
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|Qt
operator|::
name|ToolBarAreas
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QTestTypeInfo
argument_list|<
name|Qt
operator|::
name|MatchFlag
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QTestTypeInfo
argument_list|<
name|Qt
operator|::
name|MatchFlags
argument_list|>
operator|::
name|IsEnum
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|indicator
specifier|static
name|int
name|indicator
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|// this is a silly C function
end_comment
begin_extern
extern|extern
literal|"C"
block|{
DECL|function|someCFunc
name|void
name|someCFunc
parameter_list|(
name|void
modifier|*
parameter_list|)
block|{
name|indicator
operator|=
literal|42
expr_stmt|;
block|}
block|}
end_extern
begin_comment
comment|// this is the catch-template that will be called if the C function doesn't exist
end_comment
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|someCFunc
name|void
name|someCFunc
parameter_list|(
name|T
modifier|*
parameter_list|)
block|{
name|indicator
operator|=
literal|10
expr_stmt|;
block|}
end_function
begin_function
DECL|function|overrideCFunction
name|void
name|tst_Compiler
operator|::
name|overrideCFunction
parameter_list|()
block|{
name|someCFunc
argument_list|(
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|indicator
argument_list|,
literal|42
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|DONT_TEST_STL_SORTING
end_ifndef
begin_function
DECL|function|stdSortQList
name|void
name|tst_Compiler
operator|::
name|stdSortQList
parameter_list|()
block|{
name|QList
argument_list|<
name|int
argument_list|>
name|list
decl_stmt|;
name|list
operator|<<
literal|4
operator|<<
literal|2
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|list
operator|.
name|begin
argument_list|()
argument_list|,
name|list
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|list
operator|.
name|value
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|list
operator|.
name|value
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QString
argument_list|>
name|slist
decl_stmt|;
name|slist
operator|<<
literal|"b"
operator|<<
literal|"a"
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|slist
operator|.
name|begin
argument_list|()
argument_list|,
name|slist
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|slist
operator|.
name|value
argument_list|(
literal|0
argument_list|)
argument_list|,
name|QString
argument_list|(
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|slist
operator|.
name|value
argument_list|(
literal|1
argument_list|)
argument_list|,
name|QString
argument_list|(
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stdSortQVector
name|void
name|tst_Compiler
operator|::
name|stdSortQVector
parameter_list|()
block|{
name|QVector
argument_list|<
name|int
argument_list|>
name|vector
decl_stmt|;
name|vector
operator|<<
literal|4
operator|<<
literal|2
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|vector
operator|.
name|begin
argument_list|()
argument_list|,
name|vector
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|vector
operator|.
name|value
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|vector
operator|.
name|value
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QString
argument_list|>
name|strvec
decl_stmt|;
name|strvec
operator|<<
literal|"b"
operator|<<
literal|"a"
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|strvec
operator|.
name|begin
argument_list|()
argument_list|,
name|strvec
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|strvec
operator|.
name|value
argument_list|(
literal|0
argument_list|)
argument_list|,
name|QString
argument_list|(
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|strvec
operator|.
name|value
argument_list|(
literal|1
argument_list|)
argument_list|,
name|QString
argument_list|(
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|stdSortQList
name|void
name|tst_Compiler
operator|::
name|stdSortQList
parameter_list|()
block|{
name|QSKIP
argument_list|(
literal|"Compiler's STL broken"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stdSortQVector
name|void
name|tst_Compiler
operator|::
name|stdSortQVector
parameter_list|()
block|{
name|QSKIP
argument_list|(
literal|"Compiler's STL broken"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// the C func will set it to 1, the template to 2
end_comment
begin_decl_stmt
DECL|variable|whatWasCalled
specifier|static
name|int
name|whatWasCalled
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|callOrderFunc
name|void
name|callOrderFunc
parameter_list|(
name|void
modifier|*
parameter_list|)
block|{
name|whatWasCalled
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|callOrderFunc
name|void
name|callOrderFunc
parameter_list|(
name|T
modifier|*
parameter_list|)
block|{
name|whatWasCalled
operator|=
literal|2
expr_stmt|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|callOrderNoCFunc
name|void
name|callOrderNoCFunc
parameter_list|(
name|T
modifier|*
parameter_list|)
block|{
name|whatWasCalled
operator|=
literal|3
expr_stmt|;
block|}
end_function
begin_comment
comment|/*    This test will check what will get precendence - the C function    or the template.     It also makes sure this template "override" will compile on all systems    and not result in ambiguities. */
end_comment
begin_function
DECL|function|templateCallOrder
name|void
name|tst_Compiler
operator|::
name|templateCallOrder
parameter_list|()
block|{
name|QCOMPARE
argument_list|(
name|whatWasCalled
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// call it with a void *
name|void
modifier|*
name|f
init|=
literal|0
decl_stmt|;
name|callOrderFunc
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|whatWasCalled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|whatWasCalled
operator|=
literal|0
expr_stmt|;
name|char
modifier|*
name|c
init|=
literal|0
decl_stmt|;
comment|/* call it with a char * - AMBIGOUS, fails on several compilers     callOrderFunc(c);     QCOMPARE(whatWasCalled, 1);     whatWasCalled = 0;     */
comment|// now try the case when there is no C function
name|callOrderNoCFunc
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|whatWasCalled
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|whatWasCalled
operator|=
literal|0
expr_stmt|;
name|callOrderNoCFunc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|whatWasCalled
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|whatWasCalled
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|// test to see if removing =0 from a pure virtual function is BC
end_comment
begin_function
DECL|function|virtualFunctionNoLongerPureVirtual
name|void
name|tst_Compiler
operator|::
name|virtualFunctionNoLongerPureVirtual
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|BASECLASS_NOT_ABSTRACT
comment|// has a single virtual function, not pure virtual, can call it
name|BaseClass
name|baseClass
decl_stmt|;
name|QTest
operator|::
name|ignoreMessage
argument_list|(
name|QtDebugMsg
argument_list|,
literal|"BaseClass::wasAPureVirtualFunction()"
argument_list|)
expr_stmt|;
name|baseClass
operator|.
name|wasAPureVirtualFunction
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// DerivedClass inherits from BaseClass, and function is declared
comment|// pure virtual, make sure we can still call it
name|DerivedClass
name|derivedClass
decl_stmt|;
name|QTest
operator|::
name|ignoreMessage
argument_list|(
name|QtDebugMsg
argument_list|,
literal|"DerivedClass::wasAPureVirtualFunction()"
argument_list|)
expr_stmt|;
name|derivedClass
operator|.
name|wasAPureVirtualFunction
argument_list|()
expr_stmt|;
block|}
end_function
begin_function_decl
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
specifier|const
name|char
modifier|*
name|resolveCharSignedness
parameter_list|()
function_decl|;
end_function_decl
begin_function
template|template
parameter_list|<>
DECL|function|resolveCharSignedness
specifier|const
name|char
modifier|*
name|resolveCharSignedness
argument_list|<
name|char
argument_list|>
parameter_list|()
block|{
return|return
literal|"char"
return|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|resolveCharSignedness
specifier|const
name|char
modifier|*
name|resolveCharSignedness
argument_list|<
name|unsigned
name|char
argument_list|>
parameter_list|()
block|{
return|return
literal|"unsigned char"
return|;
block|}
end_function
begin_function
template|template
parameter_list|<>
DECL|function|resolveCharSignedness
specifier|const
name|char
modifier|*
name|resolveCharSignedness
argument_list|<
name|signed
name|char
argument_list|>
parameter_list|()
block|{
return|return
literal|"signed char"
return|;
block|}
end_function
begin_function
DECL|function|charSignedness
name|void
name|tst_Compiler
operator|::
name|charSignedness
parameter_list|()
specifier|const
block|{
name|QCOMPARE
argument_list|(
literal|"char"
argument_list|,
name|resolveCharSignedness
argument_list|<
name|char
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
literal|"unsigned char"
argument_list|,
argument|resolveCharSignedness<unsigned char>()
argument_list|)
empty_stmt|;
name|QCOMPARE
argument_list|(
literal|"signed char"
argument_list|,
argument|resolveCharSignedness<signed char>()
argument_list|)
empty_stmt|;
block|}
end_function
begin_class
DECL|class|PrivateStaticTemplateMember
class|class
name|PrivateStaticTemplateMember
block|{
public|public:
DECL|function|regularMember
name|long
name|regularMember
parameter_list|()
block|{
return|return
name|helper
argument_list|<
name|long
argument_list|,
name|int
argument_list|>
argument_list|(
literal|3
argument_list|)
return|;
block|}
private|private:
template|template
parameter_list|<
name|typename
name|A
parameter_list|,
name|typename
name|B
parameter_list|>
DECL|function|helper
specifier|static
name|A
name|helper
parameter_list|(
specifier|const
name|B
name|b
parameter_list|)
block|{
return|return
name|A
argument_list|(
name|b
argument_list|)
return|;
block|}
block|}
class|;
end_class
begin_function
DECL|function|privateStaticTemplateMember
name|void
name|tst_Compiler
operator|::
name|privateStaticTemplateMember
parameter_list|()
specifier|const
block|{
name|PrivateStaticTemplateMember
name|v
decl_stmt|;
name|QCOMPARE
argument_list|(
name|long
argument_list|(
literal|3
argument_list|)
argument_list|,
name|v
operator|.
name|regularMember
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_CC_MIPS
argument_list|)
end_if
begin_comment
comment|// make sure we can use a static initializer with a union and then use
end_comment
begin_comment
comment|// the second member of the union
end_comment
begin_union
DECL|member|c
DECL|member|d
DECL|variable|qt_be_inf_bytes
specifier|static
specifier|const
union|union
block|{
name|unsigned
name|char
name|c
index|[
literal|8
index|]
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
name|qt_be_inf_bytes
init|=
block|{
block|{
literal|0x7f
block|,
literal|0xf0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
union|;
end_union
begin_union
DECL|member|c
DECL|member|d
DECL|variable|qt_le_inf_bytes
specifier|static
specifier|const
union|union
block|{
name|unsigned
name|char
name|c
index|[
literal|8
index|]
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
name|qt_le_inf_bytes
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0xf0
block|,
literal|0x7f
block|}
block|}
union|;
end_union
begin_function
DECL|function|qt_inf
specifier|static
specifier|inline
name|double
name|qt_inf
parameter_list|()
block|{
return|return
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|?
name|qt_be_inf_bytes
operator|.
name|d
else|:
name|qt_le_inf_bytes
operator|.
name|d
operator|)
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|variable|qt_be_inf_bytes
specifier|static
specifier|const
name|unsigned
name|char
name|qt_be_inf_bytes
index|[]
init|=
block|{
literal|0x7f
block|,
literal|0xf0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qt_le_inf_bytes
specifier|static
specifier|const
name|unsigned
name|char
name|qt_le_inf_bytes
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0xf0
block|,
literal|0x7f
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_inf
specifier|static
specifier|inline
name|double
name|qt_inf
parameter_list|()
block|{
specifier|const
name|uchar
modifier|*
name|bytes
decl_stmt|;
name|bytes
operator|=
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|?
name|qt_be_inf_bytes
else|:
name|qt_le_inf_bytes
operator|)
expr_stmt|;
union|union
block|{
name|uchar
name|c
index|[
literal|8
index|]
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
name|returnValue
union|;
name|memcpy
argument_list|(
name|returnValue
operator|.
name|c
argument_list|,
name|bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|returnValue
operator|.
name|c
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|returnValue
operator|.
name|d
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|staticConstUnionWithInitializerList
name|void
name|tst_Compiler
operator|::
name|staticConstUnionWithInitializerList
parameter_list|()
specifier|const
block|{
name|double
name|d
init|=
name|qt_inf
argument_list|()
decl_stmt|;
name|QVERIFY
argument_list|(
name|qIsInf
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|Q_NO_TEMPLATE_FRIENDS
end_ifndef
begin_class
DECL|class|TemplateFriends
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
class|class
name|TemplateFriends
block|{
DECL|member|value
name|T
name|value
decl_stmt|;
public|public:
DECL|function|TemplateFriends
name|TemplateFriends
parameter_list|(
name|T
name|value
parameter_list|)
member_init_list|:
name|value
argument_list|(
name|value
argument_list|)
block|{}
DECL|function|copy
template|template
parameter_list|<
name|typename
name|X
parameter_list|>
name|void
name|copy
parameter_list|(
name|TemplateFriends
argument_list|<
name|X
argument_list|>
name|other
parameter_list|)
block|{
name|value
operator|=
name|other
operator|.
name|value
expr_stmt|;
block|}
template|template
parameter_list|<
name|typename
name|X
parameter_list|>
friend|friend
class_decl|class
name|TemplateFriends
class_decl|;
block|}
class|;
end_class
begin_function
DECL|function|templateFriends
name|void
name|tst_Compiler
operator|::
name|templateFriends
parameter_list|()
block|{
name|TemplateFriends
argument_list|<
name|int
argument_list|>
name|ti
argument_list|(
literal|42
argument_list|)
decl_stmt|;
name|TemplateFriends
argument_list|<
name|long
argument_list|>
name|tl
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|tl
operator|.
name|copy
argument_list|(
name|ti
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|templateFriends
name|void
name|tst_Compiler
operator|::
name|templateFriends
parameter_list|()
block|{
name|QSKIP
argument_list|(
literal|"Compiler does not support template friends"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_alignas
name|void
name|tst_Compiler
operator|::
name|cxx11_alignas
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_ALIGNAS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|S
block|{
alignas|alignas
argument_list|(
name|double
argument_list|)
name|char
name|c
decl_stmt|;
block|}
struct|;
name|QCOMPARE
argument_list|(
name|Q_ALIGNOF
argument_list|(
name|S
argument_list|)
argument_list|,
name|Q_ALIGNOF
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_alignof
name|void
name|tst_Compiler
operator|::
name|cxx11_alignof
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_ALIGNOF
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|size_t
name|alignchar
init|=
alignof|alignof
argument_list|(
name|char
argument_list|)
decl_stmt|;
name|size_t
name|aligndouble
init|=
alignof|alignof
argument_list|(
name|double
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|alignchar
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|alignchar
operator|<=
name|aligndouble
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_alignas_alignof
name|void
name|tst_Compiler
operator|::
name|cxx11_alignas_alignof
parameter_list|()
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_COMPILER_ALIGNAS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_COMPILER_ALIGNOF
argument_list|)
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
alignas|alignas
argument_list|(
alignof|alignof
argument_list|(
name|double
argument_list|)
argument_list|)
name|char
name|c
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_atomics
name|void
name|tst_Compiler
operator|::
name|cxx11_atomics
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_ATOMICS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|std
operator|::
name|atomic
argument_list|<
name|int
argument_list|>
name|i
decl_stmt|;
name|i
operator|.
name|store
argument_list|(
literal|42
argument_list|,
name|std
operator|::
name|memory_order_seq_cst
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|i
operator|.
name|load
argument_list|(
name|std
operator|::
name|memory_order_acquire
argument_list|)
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|std
operator|::
name|atomic
argument_list|<
name|short
argument_list|>
name|s
decl_stmt|;
name|s
operator|.
name|store
argument_list|(
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|s
operator|.
name|load
argument_list|()
argument_list|,
name|short
argument_list|(
literal|42
argument_list|)
argument_list|)
expr_stmt|;
name|std
operator|::
name|atomic_flag
name|flag
decl_stmt|;
name|flag
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|flag
operator|.
name|test_and_set
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|flag
operator|.
name|test_and_set
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_decl_stmt
name|QT_WARNING_PUSH
name|QT_WARNING_DISABLE_CLANG
argument_list|(
literal|"-Wignored-attributes"
argument_list|)
name|QT_WARNING_DISABLE_CLANG
argument_list|(
literal|"-Wunused-local-typedefs"
argument_list|)
name|QT_WARNING_DISABLE_GCC
argument_list|(
literal|"-Wattributes"
argument_list|)
name|QT_WARNING_DISABLE_GCC
argument_list|(
literal|"-Wunused-local-typedefs"
argument_list|)
ifndef|#
directive|ifndef
name|__has_cpp_attribute
DECL|macro|__has_cpp_attribute
define|#
directive|define
name|__has_cpp_attribute
parameter_list|(
name|x
parameter_list|)
value|0
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_COMPILER_ATTRIBUTES
decl|[[
name|noreturn
decl|]]
name|void
name|attribute_f1
argument_list|()
decl_stmt|;
end_decl_stmt
begin_function_decl
name|void
name|attribute_f2
attribute|[[
name|noreturn
attribute|]]
parameter_list|()
function_decl|;
end_function_decl
begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__cpp_namespace_attributes
argument_list|)
operator|&&
name|__cpp_namespace_attributes
operator|>=
literal|201411
operator|)
operator|&&
name|__has_cpp_attribute
argument_list|(
name|deprecated
argument_list|)
end_if
begin_namespace
DECL|namespace|NS
namespace|namespace
name|NS
attribute|[[
name|deprecated
attribute|]]
block|{ }
end_namespace
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_attributes
name|void
name|tst_Compiler
operator|::
name|cxx11_attributes
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_ATTRIBUTES
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// Attributes in function parameters and using clauses cause MSVC 2015 to crash
comment|// https://connect.microsoft.com/VisualStudio/feedback/details/2011594
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
operator|||
name|_MSC_FULL_VER
operator|>=
literal|190023811
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
name|void
name|f
argument_list|(
attribute|[[ ]]
name|int
argument_list|)
decl_stmt|;
index|[
index|[ ]
index|]
expr|using
namespace|namespace
name|QtPrivate
namespace|;
attribute|[[ ]]
name|try
argument_list|{     }
name|catch
argument_list|(
attribute|[[]]
name|int
argument_list|)
argument_list|{     }
endif|#
directive|endif
decl|struct
attribute|[[ ]]
name|A
argument_list|{ }
decl_stmt|;
struct|struct
name|B
super|:
name|A
block|{
attribute|[[ ]]
name|int
name|m_i
range|:
literal|32
decl_stmt|;
attribute|[[
name|noreturn
attribute|]]
name|void
name|f
parameter_list|()
specifier|const
block|{
operator|::
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Q_COMPILER_DEFAULT_DELETE_MEMBERS
index|[
index|[ ]
index|]
name|~
name|B
argument_list|()
operator|=
expr|default
expr_stmt|;
attribute|[[ ]]
name|B
argument_list|(
specifier|const
name|B
operator|&
argument_list|)
init|=
operator|delete
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
if|#
directive|if
name|__has_cpp_attribute
argument_list|(
name|deprecated
argument_list|)
struct|struct
attribute|[[
name|deprecated
attribute|]]
name|C
block|{
block|}
struct|;
endif|#
directive|endif
enum|enum
attribute|[[ ]]
name|E
block|{ }
enum|;
attribute|[[ ]]
name|void
attribute|[[ ]]
modifier|*
attribute|[[ ]]
modifier|*
attribute|[[ ]]
name|ptr
init|=
literal|0
decl_stmt|;
name|int
name|B
operator|::
modifier|*
attribute|[[ ]]
name|pmm
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|__has_cpp_attribute
argument_list|(
name|deprecated
argument_list|)
enum|enum
attribute|[[
name|deprecated
attribute|]]
name|E2
block|{
if|#
directive|if
name|defined
argument_list|(
name|__cpp_enumerator_attributes
argument_list|)
operator|&&
name|__cpp_enumerator_attributes
operator|>=
literal|201411
name|value
attribute|[[
name|deprecated
attribute|]]
init|=
literal|0
endif|#
directive|endif
block|}
enum|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_COMPILER_LAMBDA
capture|[]
parameter_list|()
attribute|[[ ]]
block|{}
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_COMPILER_TEMPLATE_ALIAS
using|using
name|B2
attribute|[[ ]]
init|=
name|B
using|;
endif|#
directive|endif
attribute|[[ ]]
goto|goto
name|end
goto|;
ifdef|#
directive|ifdef
name|Q_CC_GNU
comment|// Attributes in gnu:: namespace
attribute|[[
name|gnu
operator|::
name|unused
attribute|]]
name|end
range|:
decl_stmt|;
attribute|[[
name|gnu
operator|::
name|unused
attribute|]]
struct|struct
name|D
block|{
block|}
name|d
struct|;
name|struct
name|D
name|e
attribute|[[
name|gnu
operator|::
name|used
attribute|,
name|gnu
operator|::
name|unused
attribute|]]
decl_stmt|;
attribute|[[
name|gnu
operator|::
name|aligned
argument_list|(
literal|8
argument_list|)
attribute|]]
name|int
name|i
attribute|[[ ]]
decl_stmt|;
name|int
name|array
index|[]
attribute|[[]]
init|=
block|{
literal|1
block|}
decl_stmt|;
else|#
directive|else
comment|// Non GNU, so use an empty attribute
attribute|[[ ]]
name|end
range|:
decl_stmt|;
attribute|[[ ]]
struct|struct
name|D
block|{
block|}
name|d
struct|;
name|struct
name|D
name|e
attribute|[[ ]]
decl_stmt|;
attribute|[[ ]]
name|int
name|i
attribute|[[ ]]
decl_stmt|;
name|int
name|array
index|[]
attribute|[[]]
init|=
block|{
literal|1
block|}
decl_stmt|;
endif|#
directive|endif
name|int
modifier|&
attribute|[[ ]]
name|lref
init|=
name|i
decl_stmt|;
name|int
modifier|&&
attribute|[[ ]]
name|rref
init|=
literal|1
decl_stmt|;
attribute|[[ ]]
operator|(
name|void
operator|)
literal|1
expr_stmt|;
attribute|[[ ]]
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
empty_stmt|;
name|Q_UNUSED
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|pmm
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|lref
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|rref
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
name|QT_WARNING_POP
ifdef|#
directive|ifdef
name|Q_COMPILER_AUTO_FUNCTION
specifier|auto
name|autoFunction
parameter_list|()
function|->
name|unsigned
block|{
return|return
literal|1
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_auto_function
name|void
name|tst_Compiler
operator|::
name|cxx11_auto_function
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_AUTO_FUNCTION
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QCOMPARE
argument_list|(
name|autoFunction
argument_list|()
argument_list|,
literal|1u
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_auto_type
name|void
name|tst_Compiler
operator|::
name|cxx11_auto_type
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_AUTO_TYPE
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|auto
name|i
init|=
literal|1
decl_stmt|;
name|auto
name|x
init|=
name|qrand
argument_list|()
decl_stmt|;
name|auto
name|l
init|=
literal|1L
decl_stmt|;
name|auto
name|s
init|=
name|QStringLiteral
argument_list|(
literal|"Hello World"
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|l
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|s
operator|.
name|toLower
argument_list|()
argument_list|,
name|QString
argument_list|(
literal|"hello world"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_class_enum
name|void
name|tst_Compiler
operator|::
name|cxx11_class_enum
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_CLASS_ENUM
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
enum|enum class
name|X
block|{
name|EnumValue
block|}
enum|;
name|X
name|x
init|=
name|X
operator|::
name|EnumValue
decl_stmt|;
name|QCOMPARE
argument_list|(
name|x
argument_list|,
name|X
operator|::
name|EnumValue
argument_list|)
expr_stmt|;
enum|enum class
name|Y
enum|:
name|short
block|{
name|Val
init|=
literal|2
block|}
enum|;
enum|enum
name|Z
enum|:
name|long
block|{
name|ValLong
init|=
name|LONG_MAX
block|}
enum|;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_CONSTEXPR
end_ifdef
begin_function
DECL|function|constexprValue
specifier|constexpr
name|int
name|constexprValue
parameter_list|()
block|{
return|return
literal|42
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_constexpr
name|void
name|tst_Compiler
operator|::
name|cxx11_constexpr
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_CONSTEXPR
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|static
specifier|constexpr
name|QBasicAtomicInt
name|atomic
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|static
specifier|constexpr
name|int
name|i
init|=
name|constexprValue
argument_list|()
decl_stmt|;
name|QCOMPARE
argument_list|(
name|i
argument_list|,
name|constexprValue
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|atomic
operator|.
name|load
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_decltype
name|void
name|tst_Compiler
operator|::
name|cxx11_decltype
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_DECLTYPE
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
decltype|decltype
argument_list|(
name|qrand
argument_list|()
argument_list|)
name|i
init|=
literal|0
decl_stmt|;
name|QCOMPARE
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_default_members
name|void
name|tst_Compiler
operator|::
name|cxx11_default_members
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_DEFAULT_MEMBERS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
class|class
name|DefaultMembers
block|{
protected|protected:
name|DefaultMembers
parameter_list|()
constructor_decl|=
specifier|default
constructor_decl|;
public|public:
name|DefaultMembers
parameter_list|(
name|int
parameter_list|)
block|{}
block|}
class|;
class|class
name|DefaultMembersChild
super|:
specifier|public
name|DefaultMembers
block|{
public|public:
name|DefaultMembersChild
parameter_list|()
member_init_list|:
name|DefaultMembers
argument_list|()
block|{}
empty_stmt|;
block|}
class|;
name|DefaultMembersChild
name|dm
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|dm
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_delete_members
name|void
name|tst_Compiler
operator|::
name|cxx11_delete_members
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_DELETE_MEMBERS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
class|class
name|DeleteMembers
block|{
protected|protected:
name|DeleteMembers
parameter_list|()
constructor_decl|=
specifier|delete
constructor_decl|;
public|public:
name|DeleteMembers
parameter_list|(
specifier|const
name|DeleteMembers
modifier|&
parameter_list|)
constructor_decl|=
specifier|delete
constructor_decl|;
name|~
name|DeleteMembers
argument_list|()
operator|=
operator|delete
expr_stmt|;
block|}
class|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_delegating_constructors
name|void
name|tst_Compiler
operator|::
name|cxx11_delegating_constructors
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_DELEGATING_CONSTRUCTORS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|DC
block|{
name|DC
parameter_list|(
name|int
name|i
parameter_list|)
member_init_list|:
name|i
argument_list|(
name|i
argument_list|)
block|{}
name|DC
parameter_list|()
member_init_list|:
name|DC
argument_list|(
literal|0
argument_list|)
block|{}
name|int
name|i
decl_stmt|;
block|}
struct|;
name|DC
name|dc
decl_stmt|;
name|QCOMPARE
argument_list|(
name|dc
operator|.
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_explicit_conversions
name|void
name|tst_Compiler
operator|::
name|cxx11_explicit_conversions
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_EXPLICIT_CONVERSIONS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|EC
block|{
specifier|explicit
name|operator
name|int
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
name|operator
name|long long
parameter_list|()
specifier|const
block|{
return|return
literal|1
return|;
block|}
block|}
struct|;
name|EC
name|ec
decl_stmt|;
name|int
name|i
argument_list|(
name|ec
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int
name|i2
init|=
name|ec
decl_stmt|;
name|QCOMPARE
argument_list|(
name|i2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_explicit_overrides
name|void
name|tst_Compiler
operator|::
name|cxx11_explicit_overrides
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_EXPLICIT_OVERRIDES
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|Base
block|{
specifier|virtual
name|~
name|Base
parameter_list|()
block|{}
specifier|virtual
name|void
name|f
parameter_list|()
block|{}
block|}
struct|;
struct|struct
name|Derived
specifier|final
super|:
specifier|public
name|Base
block|{
specifier|virtual
name|void
name|f
parameter_list|()
name|final
name|override
decl_stmt|{
block|}
block|}
end_function
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|Q_COMPILER_EXTERN_TEMPLATES
end_ifdef
begin_expr_stmt
unit|template
DECL|function|externTemplate
operator|<
typename|typename
name|T
operator|>
name|T
name|externTemplate
argument_list|()
block|{
return|return
name|T
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_expr_stmt
begin_function_decl
specifier|extern
specifier|template
name|int
name|externTemplate
argument_list|<
name|int
argument_list|>
parameter_list|()
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_extern_templates
name|void
name|tst_Compiler
operator|::
name|cxx11_extern_templates
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_EXTERN_TEMPLATES
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QCOMPARE
argument_list|(
name|externTemplate
argument_list|<
name|int
argument_list|>
argument_list|()
argument_list|,
literal|42
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_inheriting_constructors
name|void
name|tst_Compiler
operator|::
name|cxx11_inheriting_constructors
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_INHERITING_CONSTRUCTORS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|Base
block|{
name|int
name|i
decl_stmt|;
name|Base
parameter_list|()
member_init_list|:
name|i
argument_list|(
literal|0
argument_list|)
block|{}
name|Base
parameter_list|(
name|int
name|i
parameter_list|)
member_init_list|:
name|i
argument_list|(
name|i
argument_list|)
block|{}
block|}
struct|;
struct|struct
name|Derived
super|:
specifier|public
name|Base
block|{
using|using
name|Base
operator|::
name|Base
using|;
block|}
struct|;
name|Derived
name|d
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|d
operator|.
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_initializer_lists
name|void
name|tst_Compiler
operator|::
name|cxx11_initializer_lists
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_INITIALIZER_LISTS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QList
argument_list|<
name|int
argument_list|>
name|l
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
name|QCOMPARE
argument_list|(
name|l
operator|.
name|length
argument_list|()
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|l
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|l
operator|.
name|at
argument_list|(
literal|4
argument_list|)
argument_list|,
literal|5
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_struct
DECL|struct|CallFunctor
struct|struct
name|CallFunctor
block|{
DECL|function|f
template|template
parameter_list|<
name|typename
name|Functor
parameter_list|>
specifier|static
name|int
name|f
parameter_list|(
name|Functor
name|f
parameter_list|)
block|{
return|return
name|f
argument_list|()
return|;
block|}
block|}
struct|;
end_struct
begin_function
DECL|function|cxx11_lambda
name|void
name|tst_Compiler
operator|::
name|cxx11_lambda
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_LAMBDA
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QCOMPARE
argument_list|(
name|CallFunctor
operator|::
name|f
argument_list|(
capture|[]
parameter_list|()
block|{
return|return
literal|42
return|;
block|}
argument_list|)
argument_list|,
literal|42
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_nonstatic_member_init
name|void
name|tst_Compiler
operator|::
name|cxx11_nonstatic_member_init
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_NONSTATIC_MEMBER_INIT
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|S
block|{
name|int
name|i
init|=
literal|42
decl_stmt|;
name|long
name|l
init|=
literal|47
decl_stmt|;
name|char
name|c
decl_stmt|;
name|S
parameter_list|()
member_init_list|:
name|l
argument_list|(
operator|-
literal|47
argument_list|)
member_init_list|,
name|c
argument_list|(
literal|0
argument_list|)
block|{}
block|}
struct|;
name|S
name|s
decl_stmt|;
name|QCOMPARE
argument_list|(
name|s
operator|.
name|i
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|s
operator|.
name|l
argument_list|,
operator|-
literal|47L
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|s
operator|.
name|c
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_noexcept
name|void
name|tst_Compiler
operator|::
name|cxx11_noexcept
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_NOEXCEPT
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|extern
name|void
name|noexcept_f
argument_list|()
noexcept|noexcept
decl_stmt|;
specifier|extern
name|void
name|g
argument_list|()
noexcept|noexcept
argument_list|(
noexcept|noexcept
argument_list|(
name|noexcept_f
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
noexcept|noexcept
argument_list|(
name|cxx11_noexcept
argument_list|()
argument_list|)
operator|,
literal|false
block|)
function|;
end_function
begin_expr_stmt
name|QCOMPARE
argument_list|(
noexcept|noexcept
argument_list|(
name|noexcept_f
argument_list|)
operator|,
literal|true
end_expr_stmt
begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|QCOMPARE
argument_list|(
noexcept|noexcept
argument_list|(
name|g
argument_list|)
operator|,
literal|true
end_expr_stmt
begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_macro
unit|}  void
DECL|function|cxx11_nullptr
name|tst_Compiler
end_macro
begin_expr_stmt
DECL|function|cxx11_nullptr
operator|::
name|cxx11_nullptr
operator|(
operator|)
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_NULLPTR
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
block|;
else|#
directive|else
name|void
operator|*
name|v
operator|=
literal|nullptr
block|;
name|char
operator|*
name|c
operator|=
literal|nullptr
block|;
specifier|const
name|char
operator|*
name|cc
operator|=
literal|nullptr
block|;
specifier|volatile
name|char
operator|*
name|vc
operator|=
literal|nullptr
block|;
name|std
operator|::
name|nullptr_t
name|np
operator|=
literal|nullptr
block|;
name|v
operator|=
name|np
block|;
name|Q_UNUSED
argument_list|(
name|v
argument_list|)
block|;
name|Q_UNUSED
argument_list|(
name|c
argument_list|)
block|;
name|Q_UNUSED
argument_list|(
name|cc
argument_list|)
block|;
name|Q_UNUSED
argument_list|(
name|vc
argument_list|)
block|;
endif|#
directive|endif
block|}
end_expr_stmt
begin_namespace
DECL|namespace|SomeNamespace
namespace|namespace
name|SomeNamespace
block|{
DECL|class|AdlOnly
class|class
name|AdlOnly
block|{
DECL|member|v
name|QVector
argument_list|<
name|int
argument_list|>
name|v
decl_stmt|;
public|public:
DECL|function|AdlOnly
name|AdlOnly
parameter_list|()
member_init_list|:
name|v
argument_list|(
literal|5
argument_list|)
block|{
name|std
operator|::
name|fill_n
argument_list|(
name|v
operator|.
name|begin
argument_list|()
argument_list|,
name|v
operator|.
name|size
argument_list|()
argument_list|,
literal|42
argument_list|)
expr_stmt|;
block|}
private|private:
DECL|function|begin
friend|friend
name|QVector
argument_list|<
name|int
argument_list|>
operator|::
name|const_iterator
name|begin
parameter_list|(
specifier|const
name|AdlOnly
modifier|&
name|x
parameter_list|)
block|{
return|return
name|x
operator|.
name|v
operator|.
name|begin
argument_list|()
return|;
block|}
DECL|function|end
friend|friend
name|QVector
argument_list|<
name|int
argument_list|>
operator|::
name|const_iterator
name|end
parameter_list|(
specifier|const
name|AdlOnly
modifier|&
name|x
parameter_list|)
block|{
return|return
name|x
operator|.
name|v
operator|.
name|end
argument_list|()
return|;
block|}
DECL|function|begin
friend|friend
name|QVector
argument_list|<
name|int
argument_list|>
operator|::
name|iterator
name|begin
parameter_list|(
name|AdlOnly
modifier|&
name|x
parameter_list|)
block|{
return|return
name|x
operator|.
name|v
operator|.
name|begin
argument_list|()
return|;
block|}
DECL|function|end
friend|friend
name|QVector
argument_list|<
name|int
argument_list|>
operator|::
name|iterator
name|end
parameter_list|(
name|AdlOnly
modifier|&
name|x
parameter_list|)
block|{
return|return
name|x
operator|.
name|v
operator|.
name|end
argument_list|()
return|;
block|}
block|}
class|;
block|}
end_namespace
begin_function
DECL|function|cxx11_range_for
name|void
name|tst_Compiler
operator|::
name|cxx11_range_for
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_RANGE_FOR
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QList
argument_list|<
name|int
argument_list|>
name|l
decl_stmt|;
name|l
operator|<<
literal|1
operator|<<
literal|2
operator|<<
literal|3
expr_stmt|;
for|for
control|(
name|int
name|i
range|:
name|l
control|)
name|Q_UNUSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|l
operator|.
name|clear
argument_list|()
expr_stmt|;
name|l
operator|<<
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
range|:
name|l
control|)
name|QCOMPARE
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|long
argument_list|>
name|ll
decl_stmt|;
name|l
operator|<<
literal|2
expr_stmt|;
for|for
control|(
name|int
name|i
range|:
name|ll
control|)
name|QCOMPARE
argument_list|(
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|{
specifier|const
name|int
name|array
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|}
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|const
name|int
modifier|&
name|e
range|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|e
range|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
specifier|const
name|int
name|e
range|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_COMPILER_AUTO_TYPE
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|e
range|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|e
operator|:
name|array
control|)
comment|// auto deducing const
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|auto
name|e
range|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
name|e
range|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|{
name|int
name|array
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|}
decl_stmt|;
specifier|const
name|int
name|array2
index|[]
init|=
block|{
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|}
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|const
name|int
modifier|&
name|e
range|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
modifier|&
name|e
range|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|e
range|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
specifier|const
name|int
name|e
range|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_COMPILER_AUTO_TYPE
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|e
range|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|e
operator|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|auto
name|e
range|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
name|e
range|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
modifier|&
name|e
range|:
name|array
control|)
name|e
operator|+=
literal|10
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
specifier|const
name|int
modifier|&
name|e
range|:
name|array
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
name|array2
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|{
specifier|const
name|SomeNamespace
operator|::
name|AdlOnly
name|x
decl_stmt|;
for|for
control|(
specifier|const
name|int
modifier|&
name|e
range|:
name|x
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
literal|42
argument_list|)
expr_stmt|;
block|}
block|{
name|SomeNamespace
operator|::
name|AdlOnly
name|x
decl_stmt|;
for|for
control|(
specifier|const
name|int
modifier|&
name|e
range|:
name|x
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
literal|42
argument_list|)
expr_stmt|;
for|for
control|(
name|int
modifier|&
name|e
range|:
name|x
control|)
name|e
operator|+=
literal|10
expr_stmt|;
for|for
control|(
specifier|const
name|int
modifier|&
name|e
range|:
name|x
control|)
name|QCOMPARE
argument_list|(
name|e
argument_list|,
literal|52
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_raw_strings
name|void
name|tst_Compiler
operator|::
name|cxx11_raw_strings
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_RAW_STRINGS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|static
specifier|const
name|char
name|xml
index|[]
init|=
literal|R"(<?xml version="1.0" encoding="UTF-8" ?>)"
decl_stmt|;
specifier|static
specifier|const
name|char
name|raw
index|[]
init|=
literal|R"***(*"*)***"
decl_stmt|;
name|QCOMPARE
argument_list|(
name|strlen
argument_list|(
name|raw
argument_list|)
argument_list|,
name|size_t
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|raw
index|[
literal|1
index|]
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|xml
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_ref_qualifiers
name|void
name|tst_Compiler
operator|::
name|cxx11_ref_qualifiers
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_REF_QUALIFIERS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|Q_COMPILER_RVALUE_REFS
error|#
directive|error
literal|"Impossible condition: ref qualifiers are supported but not rvalue refs"
endif|#
directive|endif
comment|// also applies to function pointers
name|QByteArray
function_decl|(
name|QString
operator|::
modifier|*
name|lvalueref
function_decl|)
parameter_list|()
specifier|const
ref_qualifier|&
init|=
operator|&
name|QString
operator|::
name|toLatin1
function_decl|;
name|QByteArray
function_decl|(
name|QString
operator|::
modifier|*
name|rvalueref
function_decl|)
parameter_list|()
ref_qualifier|&&
init|=
operator|&
name|QString
operator|::
name|toLatin1
function_decl|;
name|QString
name|s
argument_list|(
literal|"Hello"
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
call|(
name|s
operator|.*
name|lvalueref
call|)
argument_list|()
argument_list|,
name|QByteArray
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
operator|(
name|std
operator|::
name|move
argument_list|(
name|s
argument_list|)
operator|.*
name|rvalueref
operator|)
operator|(
operator|)
argument_list|,
name|QByteArray
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
expr_stmt|;
comment|// tests internal behavior:
name|QVERIFY
argument_list|(
name|s
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_class
DECL|class|MoveDefinedQString
class|class
name|MoveDefinedQString
block|{
DECL|member|s
name|QString
name|s
decl_stmt|;
public|public:
DECL|function|MoveDefinedQString
name|MoveDefinedQString
parameter_list|()
member_init_list|:
name|s
argument_list|()
block|{}
DECL|function|MoveDefinedQString
specifier|explicit
name|MoveDefinedQString
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
member_init_list|:
name|s
argument_list|(
name|s
argument_list|)
block|{}
DECL|function|MoveDefinedQString
name|MoveDefinedQString
parameter_list|(
specifier|const
name|MoveDefinedQString
modifier|&
name|other
parameter_list|)
member_init_list|:
name|s
argument_list|(
name|other
operator|.
name|s
argument_list|)
block|{}
ifdef|#
directive|ifdef
name|Q_COMPILER_RVALUE_REFS
DECL|function|MoveDefinedQString
name|MoveDefinedQString
parameter_list|(
name|MoveDefinedQString
modifier|&&
name|other
parameter_list|)
member_init_list|:
name|s
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|other
operator|.
name|s
argument_list|)
argument_list|)
block|{
name|other
operator|.
name|s
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|function|operator =
name|MoveDefinedQString
modifier|&
name|operator
name|=
parameter_list|(
name|MoveDefinedQString
modifier|&&
name|other
parameter_list|)
block|{
name|s
operator|=
name|std
operator|::
name|move
argument_list|(
name|other
operator|.
name|s
argument_list|)
expr_stmt|;
name|other
operator|.
name|s
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
endif|#
directive|endif
DECL|function|operator =
name|MoveDefinedQString
modifier|&
name|operator
name|=
parameter_list|(
specifier|const
name|MoveDefinedQString
modifier|&
name|other
parameter_list|)
block|{
name|s
operator|=
name|other
operator|.
name|s
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
private|private:
DECL|function|operator ==
friend|friend
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|MoveDefinedQString
modifier|&
name|lhs
parameter_list|,
specifier|const
name|MoveDefinedQString
modifier|&
name|rhs
parameter_list|)
block|{
return|return
name|lhs
operator|.
name|s
operator|==
name|rhs
operator|.
name|s
return|;
block|}
DECL|function|operator !=
friend|friend
name|bool
name|operator
name|!=
parameter_list|(
specifier|const
name|MoveDefinedQString
modifier|&
name|lhs
parameter_list|,
specifier|const
name|MoveDefinedQString
modifier|&
name|rhs
parameter_list|)
block|{
return|return
operator|!
name|operator
name|==
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
DECL|function|toString
friend|friend
name|char
modifier|*
name|toString
parameter_list|(
specifier|const
name|MoveDefinedQString
modifier|&
name|mds
parameter_list|)
block|{
using|using
namespace|namespace
name|QTest
namespace|;
return|return
name|toString
argument_list|(
name|mds
operator|.
name|s
argument_list|)
return|;
block|}
block|}
class|;
end_class
begin_function
DECL|function|cxx11_rvalue_refs
name|void
name|tst_Compiler
operator|::
name|cxx11_rvalue_refs
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_RVALUE_REFS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// we require std::move:
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
name|i
operator|=
name|std
operator|::
name|move
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|MoveDefinedQString
name|s
argument_list|(
literal|"Hello"
argument_list|)
decl_stmt|;
name|MoveDefinedQString
name|t
init|=
name|std
operator|::
name|move
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|t
argument_list|,
name|MoveDefinedQString
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|s
argument_list|,
name|MoveDefinedQString
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|std
operator|::
name|move
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t
argument_list|,
name|MoveDefinedQString
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|s
argument_list|,
name|MoveDefinedQString
argument_list|()
argument_list|)
expr_stmt|;
name|MoveDefinedQString
modifier|&&
name|r
init|=
name|std
operator|::
name|move
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|// no actual move!
name|QCOMPARE
argument_list|(
name|r
argument_list|,
name|MoveDefinedQString
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|t
argument_list|,
name|MoveDefinedQString
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
expr_stmt|;
comment|// so 't' is unchanged
block|}
comment|// we require std::forward:
block|{
name|MoveDefinedQString
name|s
argument_list|(
literal|"Hello"
argument_list|)
decl_stmt|;
name|MoveDefinedQString
name|s2
init|=
name|std
operator|::
name|forward
argument_list|<
name|MoveDefinedQString
argument_list|>
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|// forward as rvalue
name|QCOMPARE
argument_list|(
name|s2
argument_list|,
name|MoveDefinedQString
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|s
argument_list|,
name|MoveDefinedQString
argument_list|()
argument_list|)
expr_stmt|;
name|MoveDefinedQString
name|s3
init|=
name|std
operator|::
name|forward
argument_list|<
name|MoveDefinedQString
operator|&
argument_list|>
argument_list|(
name|s2
argument_list|)
decl_stmt|;
comment|// forward as lvalue
name|QCOMPARE
argument_list|(
name|s2
argument_list|,
name|MoveDefinedQString
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|s3
argument_list|,
name|MoveDefinedQString
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// supported by MSVC only from November 2013 CTP, but only check for VC2015:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|||
name|_MSC_VER
operator|>=
literal|1900
comment|// VS14 == VC2015
comment|// we require automatic generation of move special member functions:
block|{
struct|struct
name|M
block|{
name|MoveDefinedQString
name|s1
decl_stmt|,
name|s2
decl_stmt|;
block|}
struct|;
name|M
name|m1
init|=
block|{
name|MoveDefinedQString
argument_list|(
literal|"Hello"
argument_list|)
block|,
name|MoveDefinedQString
argument_list|(
literal|"World"
argument_list|)
block|}
decl_stmt|;
name|QCOMPARE
argument_list|(
name|m1
operator|.
name|s1
argument_list|,
name|MoveDefinedQString
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|m1
operator|.
name|s2
argument_list|,
name|MoveDefinedQString
argument_list|(
literal|"World"
argument_list|)
argument_list|)
expr_stmt|;
name|M
name|m2
init|=
name|std
operator|::
name|move
argument_list|(
name|m1
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|m1
operator|.
name|s1
argument_list|,
name|MoveDefinedQString
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|m1
operator|.
name|s2
argument_list|,
name|MoveDefinedQString
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|m2
operator|.
name|s1
argument_list|,
name|MoveDefinedQString
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|m2
operator|.
name|s2
argument_list|,
name|MoveDefinedQString
argument_list|(
literal|"World"
argument_list|)
argument_list|)
expr_stmt|;
name|M
name|m3
decl_stmt|;
name|QCOMPARE
argument_list|(
name|m3
operator|.
name|s1
argument_list|,
name|MoveDefinedQString
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|m3
operator|.
name|s2
argument_list|,
name|MoveDefinedQString
argument_list|()
argument_list|)
expr_stmt|;
name|m3
operator|=
name|std
operator|::
name|move
argument_list|(
name|m2
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|m2
operator|.
name|s1
argument_list|,
name|MoveDefinedQString
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|m2
operator|.
name|s2
argument_list|,
name|MoveDefinedQString
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|m3
operator|.
name|s1
argument_list|,
name|MoveDefinedQString
argument_list|(
literal|"Hello"
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|m3
operator|.
name|s2
argument_list|,
name|MoveDefinedQString
argument_list|(
literal|"World"
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// MSVC< 2015
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_static_assert
name|void
name|tst_Compiler
operator|::
name|cxx11_static_assert
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_STATIC_ASSERT
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
assert|static_assert
argument_list|(
literal|true
argument_list|,
literal|"Message"
argument_list|)
assert|;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_TEMPLATE_ALIAS
end_ifdef
begin_using
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
using|using
name|Map
init|=
name|QMap
argument_list|<
name|QString
argument_list|,
name|T
argument_list|>
using|;
end_using
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_template_alias
name|void
name|tst_Compiler
operator|::
name|cxx11_template_alias
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_TEMPLATE_ALIAS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|Map
argument_list|<
name|QVariant
argument_list|>
name|m
decl_stmt|;
name|m
operator|.
name|insert
argument_list|(
literal|"Hello"
argument_list|,
literal|"World"
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|m
operator|.
name|value
argument_list|(
literal|"Hello"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|QString
argument_list|(
literal|"World"
argument_list|)
argument_list|)
expr_stmt|;
using|using
name|X
init|=
name|int
using|;
name|X
name|i
init|=
literal|0
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_THREAD_LOCAL
end_ifdef
begin_decl_stmt
DECL|variable|stl
specifier|static
specifier|thread_local
name|int
name|stl
init|=
literal|42
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|gtl
specifier|thread_local
name|int
name|gtl
init|=
literal|42
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_thread_local
name|void
name|tst_Compiler
operator|::
name|cxx11_thread_local
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_THREAD_LOCAL
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|thread_local
name|int
name|v
init|=
literal|1
decl_stmt|;
name|QVERIFY
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|stl
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|gtl
argument_list|)
expr_stmt|;
specifier|thread_local
name|QString
name|s
init|=
literal|"Hello"
decl_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_UDL
end_ifdef
begin_function
DECL|function|_tstqstring
name|QString
name|operator
name|"" _tstqstring
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
operator|+
literal|" UDL"
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_udl
name|void
name|tst_Compiler
operator|::
name|cxx11_udl
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_UDL
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QString
name|s
init|=
literal|"Hello World"
name|_tstqstring
decl_stmt|;
name|QCOMPARE
argument_list|(
name|s
argument_list|,
name|QString
argument_list|(
literal|"Hello World UDL"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_unicode_strings
name|void
name|tst_Compiler
operator|::
name|cxx11_unicode_strings
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_UNICODE_STRINGS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|static
specifier|const
name|char16_t
name|u
index|[]
init|=
literal|u"\u200BHello\u00A0World"
decl_stmt|;
name|QCOMPARE
argument_list|(
name|u
index|[
literal|0
index|]
argument_list|,
name|char16_t
argument_list|(
literal|0x200B
argument_list|)
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|char32_t
name|U
index|[]
init|=
literal|U"\ufffe"
decl_stmt|;
name|QCOMPARE
argument_list|(
name|U
index|[
literal|0
index|]
argument_list|,
name|char32_t
argument_list|(
literal|0xfffe
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
literal|u"\U00010000"
index|[
literal|0
index|]
argument_list|,
name|char16_t
argument_list|(
literal|0xD800
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
literal|u"\U00010000"
index|[
literal|1
index|]
argument_list|,
name|char16_t
argument_list|(
literal|0xDC00
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|noop
specifier|static
name|void
name|noop
parameter_list|(
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
parameter_list|)
block|{}
end_function
begin_function
DECL|function|cxx11_uniform_init
name|void
name|tst_Compiler
operator|::
name|cxx11_uniform_init
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_UNIFORM_INIT
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
name|noop
argument_list|(
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|QString
name|s
argument_list|{
literal|"Hello"
argument_list|}
decl_stmt|;
name|int
name|i
argument_list|{}
decl_stmt|;
name|noop
argument_list|(
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
block|{
literal|1
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|noop
argument_list|(
block|{
name|i
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_unrestricted_unions
name|void
name|tst_Compiler
operator|::
name|cxx11_unrestricted_unions
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_UNRESTRICTED_UNIONS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
union|union
name|U
block|{
name|QString
name|s
decl_stmt|;
name|U
parameter_list|()
block|{}
name|U
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
member_init_list|:
name|s
argument_list|(
name|s
argument_list|)
block|{}
name|~
name|U
parameter_list|()
block|{}
block|}
union|;
name|U
name|u
decl_stmt|;
name|std
operator|::
name|aligned_storage
operator|<
sizeof|sizeof
argument_list|(
name|QString
argument_list|)
operator|,
name|Q_ALIGNOF
argument_list|(
name|QString
argument_list|)
operator|>
name|as
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|U
name|u2
argument_list|(
literal|"hello"
argument_list|)
decl_stmt|;
name|u2
operator|.
name|s
operator|.
name|~
name|QString
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx11_variadic_macros
name|void
name|tst_Compiler
operator|::
name|cxx11_variadic_macros
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_VARIADIC_MACROS
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|TEST_VARARG
parameter_list|(
name|x
parameter_list|,
modifier|...
parameter_list|)
value|__VA_ARGS__
name|QCOMPARE
argument_list|(
name|TEST_VARARG
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_VARIADIC_TEMPLATES
end_ifdef
begin_struct
DECL|struct|VariadicTemplate
template|template
parameter_list|<
name|typename
modifier|...
name|Args
parameter_list|>
struct|struct
name|VariadicTemplate
block|{
block|}
struct|;
end_struct
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx11_variadic_templates
name|void
name|tst_Compiler
operator|::
name|cxx11_variadic_templates
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_COMPILER_VARIADIC_TEMPLATES
name|QSKIP
argument_list|(
literal|"Compiler does not support C++11 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|VariadicTemplate
argument_list|<>
name|v0
decl_stmt|;
name|VariadicTemplate
argument_list|<
name|int
argument_list|>
name|v1
decl_stmt|;
name|VariadicTemplate
argument_list|<
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|>
name|v8
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|v0
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|v1
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|v8
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx14_binary_literals
name|void
name|tst_Compiler
operator|::
name|cxx14_binary_literals
parameter_list|()
block|{
if|#
directive|if
name|__cpp_binary_literals
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|i
init|=
literal|0b11001001
decl_stmt|;
name|QCOMPARE
argument_list|(
name|i
argument_list|,
literal|0xC9
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx14_init_captures
name|void
name|tst_Compiler
operator|::
name|cxx14_init_captures
parameter_list|()
block|{
if|#
directive|if
name|__cpp_init_captures
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QCOMPARE
argument_list|(
capture|[
name|x
init|=
literal|42
capture|]
parameter_list|()
block|{
return|return
name|x
return|;
block|}
argument_list|()
argument_list|,
literal|42
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx14_generic_lambdas
name|void
name|tst_Compiler
operator|::
name|cxx14_generic_lambdas
parameter_list|()
block|{
if|#
directive|if
name|__cpp_generic_lambdas
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|auto
name|identity
init|=
capture|[]
parameter_list|(
name|auto
name|x
parameter_list|)
block|{
return|return
name|x
return|;
block|}
decl_stmt|;
name|QCOMPARE
argument_list|(
name|identity
argument_list|(
literal|42
argument_list|)
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|identity
argument_list|(
literal|42U
argument_list|)
argument_list|,
literal|42U
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|identity
argument_list|(
literal|42L
argument_list|)
argument_list|,
literal|42L
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|__cpp_constexpr
operator|-
literal|0
operator|>=
literal|201304
end_if
begin_function
DECL|function|relaxedConstexpr
specifier|constexpr
name|int
name|relaxedConstexpr
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|i
operator|*=
literal|2
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx14_constexpr
name|void
name|tst_Compiler
operator|::
name|cxx14_constexpr
parameter_list|()
block|{
if|#
directive|if
name|__cpp_constexpr
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QCOMPARE
argument_list|(
name|relaxedConstexpr
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|relaxedConstexpr
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx14_decltype_auto
name|void
name|tst_Compiler
operator|::
name|cxx14_decltype_auto
parameter_list|()
block|{
if|#
directive|if
name|__cpp_decltype_auto
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QList
argument_list|<
name|int
argument_list|>
name|l
decl_stmt|;
name|l
operator|<<
literal|1
expr_stmt|;
decltype|decltype
argument_list|(
name|auto
argument_list|)
name|value
init|=
name|l
index|[
literal|0
index|]
decl_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
name|QCOMPARE
argument_list|(
name|l
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|__cpp_return_type_deduction
operator|>=
literal|201304
end_if
begin_function
DECL|function|returnTypeDeduction
name|auto
name|returnTypeDeduction
parameter_list|(
name|bool
name|choice
parameter_list|)
block|{
if|if
condition|(
name|choice
condition|)
return|return
literal|1U
return|;
return|return
name|returnTypeDeduction
argument_list|(
operator|!
name|choice
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx14_return_type_deduction
name|void
name|tst_Compiler
operator|::
name|cxx14_return_type_deduction
parameter_list|()
block|{
if|#
directive|if
name|__cpp_return_type_deduction
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QCOMPARE
argument_list|(
name|returnTypeDeduction
argument_list|(
literal|false
argument_list|)
argument_list|,
literal|1U
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cxx14_aggregate_nsdmi
name|void
name|tst_Compiler
operator|::
name|cxx14_aggregate_nsdmi
parameter_list|()
block|{
if|#
directive|if
name|__cpp_aggregate_nsdmi
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
name|S
block|{
name|int
name|i
decl_stmt|,
name|j
init|=
name|i
decl_stmt|;
block|}
struct|;
name|S
name|s
init|=
block|{
literal|1
block|}
decl_stmt|;
name|QCOMPARE
argument_list|(
name|s
operator|.
name|j
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|__cpp_variable_templates
operator|>=
literal|201304
end_if
begin_decl_stmt
DECL|variable|variableTemplate
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
specifier|constexpr
name|T
name|variableTemplate
init|=
name|T
argument_list|(
literal|42
argument_list|)
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cxx14_variable_templates
name|void
name|tst_Compiler
operator|::
name|cxx14_variable_templates
parameter_list|()
block|{
if|#
directive|if
name|__cpp_variable_templates
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QCOMPARE
argument_list|(
name|variableTemplate
argument_list|<
name|int
argument_list|>
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|variableTemplate
argument_list|<
name|long
argument_list|>
argument_list|,
literal|42L
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|variableTemplate
argument_list|<
name|unsigned
argument_list|>
argument_list|,
literal|42U
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
argument|variableTemplate<unsigned long long>
argument_list|,
literal|42ULL
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|runtimeArrays
name|void
name|tst_Compiler
operator|::
name|runtimeArrays
parameter_list|()
block|{
if|#
directive|if
name|__cpp_runtime_arrays
operator|-
literal|0
operator|<
literal|201304
name|QSKIP
argument_list|(
literal|"Compiler does not support this C++14 feature"
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|i
index|[
name|qrand
argument_list|()
operator|&
literal|0x1f
index|]
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_macro
name|QTEST_MAIN
argument_list|(
argument|tst_Compiler
argument_list|)
end_macro
begin_include
include|#
directive|include
file|"tst_compiler.moc"
end_include
end_unit
