begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the test suite of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtTest/QtTest>
end_include
begin_include
include|#
directive|include
file|<QtCore/QtCore>
end_include
begin_include
include|#
directive|include
file|<QtGui/QtGui>
end_include
begin_include
include|#
directive|include
file|<private/qguiapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformintegration.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/QApplication>
end_include
begin_include
include|#
directive|include
file|<QtOpenGL/QtOpenGL>
end_include
begin_include
include|#
directive|include
file|"tst_qglthreads.h"
end_include
begin_define
DECL|macro|RUNNING_TIME
define|#
directive|define
name|RUNNING_TIME
value|5000
end_define
begin_constructor
DECL|function|tst_QGLThreads
name|tst_QGLThreads
operator|::
name|tst_QGLThreads
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*     swapInThread     The purpose of this testcase is to verify that it is possible to do rendering into    a GL context from the GUI thread, then swap the contents in from a background thread.     The usecase for this is to have the background thread do the waiting for vertical    sync while the GUI thread is idle.     Currently the locking is handled directly in the paintEvent(). For the actual usecase    in Qt, the locking is done in the windowsurface before starting any drawing while    unlocking is done after all drawing has been done.  */
end_comment
begin_class
DECL|class|SwapThread
class|class
name|SwapThread
super|:
specifier|public
name|QThread
block|{
name|Q_OBJECT
public|public:
DECL|function|SwapThread
name|SwapThread
parameter_list|(
name|QGLWidget
modifier|*
name|widget
parameter_list|)
member_init_list|:
name|m_context
argument_list|(
name|widget
operator|->
name|context
argument_list|()
argument_list|)
member_init_list|,
name|m_swapTriggered
argument_list|(
literal|false
argument_list|)
block|{
name|moveToThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|QTime
name|time
decl_stmt|;
name|time
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|time
operator|.
name|elapsed
argument_list|()
operator|<
name|RUNNING_TIME
condition|)
block|{
name|lock
argument_list|()
expr_stmt|;
name|waitForReadyToSwap
argument_list|()
expr_stmt|;
name|m_context
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
name|m_context
operator|->
name|swapBuffers
argument_list|()
expr_stmt|;
name|m_context
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
name|m_context
operator|->
name|moveToThread
argument_list|(
name|qApp
operator|->
name|thread
argument_list|()
argument_list|)
expr_stmt|;
name|signalSwapDone
argument_list|()
expr_stmt|;
name|unlock
argument_list|()
expr_stmt|;
block|}
name|m_swapTriggered
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|lock
name|void
name|lock
parameter_list|()
block|{
name|m_mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
DECL|function|unlock
name|void
name|unlock
parameter_list|()
block|{
name|m_mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|function|waitForSwapDone
name|void
name|waitForSwapDone
parameter_list|()
block|{
if|if
condition|(
name|m_swapTriggered
condition|)
name|m_swapDone
operator|.
name|wait
argument_list|(
operator|&
name|m_mutex
argument_list|)
expr_stmt|;
block|}
DECL|function|waitForReadyToSwap
name|void
name|waitForReadyToSwap
parameter_list|()
block|{
if|if
condition|(
operator|!
name|m_swapTriggered
condition|)
name|m_readyToSwap
operator|.
name|wait
argument_list|(
operator|&
name|m_mutex
argument_list|)
expr_stmt|;
block|}
DECL|function|signalReadyToSwap
name|void
name|signalReadyToSwap
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
return|return;
name|m_readyToSwap
operator|.
name|wakeAll
argument_list|()
expr_stmt|;
name|m_swapTriggered
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|signalSwapDone
name|void
name|signalSwapDone
parameter_list|()
block|{
name|m_swapTriggered
operator|=
literal|false
expr_stmt|;
name|m_swapDone
operator|.
name|wakeAll
argument_list|()
expr_stmt|;
block|}
private|private:
DECL|member|m_context
name|QGLContext
modifier|*
name|m_context
decl_stmt|;
DECL|member|m_mutex
name|QMutex
name|m_mutex
decl_stmt|;
DECL|member|m_readyToSwap
name|QWaitCondition
name|m_readyToSwap
decl_stmt|;
DECL|member|m_swapDone
name|QWaitCondition
name|m_swapDone
decl_stmt|;
DECL|member|m_swapTriggered
name|bool
name|m_swapTriggered
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|ForegroundWidget
class|class
name|ForegroundWidget
super|:
specifier|public
name|QGLWidget
block|{
public|public:
DECL|function|ForegroundWidget
name|ForegroundWidget
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|format
parameter_list|)
member_init_list|:
name|QGLWidget
argument_list|(
name|format
argument_list|)
member_init_list|,
name|m_thread
argument_list|(
literal|0
argument_list|)
block|{
name|setAutoBufferSwap
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|function|paintEvent
name|void
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
block|{
name|m_thread
operator|->
name|lock
argument_list|()
expr_stmt|;
name|m_thread
operator|->
name|waitForSwapDone
argument_list|()
expr_stmt|;
name|makeCurrent
argument_list|()
expr_stmt|;
name|QPainter
name|p
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|p
operator|.
name|fillRect
argument_list|(
name|rect
argument_list|()
argument_list|,
name|QColor
argument_list|(
name|rand
argument_list|()
operator|%
literal|256
argument_list|,
name|rand
argument_list|()
operator|%
literal|256
argument_list|,
name|rand
argument_list|()
operator|%
literal|256
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|setPen
argument_list|(
name|Qt
operator|::
name|red
argument_list|)
expr_stmt|;
name|p
operator|.
name|setFont
argument_list|(
name|QFont
argument_list|(
literal|"SansSerif"
argument_list|,
literal|24
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|drawText
argument_list|(
name|rect
argument_list|()
argument_list|,
name|Qt
operator|::
name|AlignCenter
argument_list|,
literal|"This is an autotest"
argument_list|)
expr_stmt|;
name|p
operator|.
name|end
argument_list|()
expr_stmt|;
name|doneCurrent
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_thread
operator|->
name|isRunning
argument_list|()
condition|)
block|{
name|context
argument_list|()
operator|->
name|moveToThread
argument_list|(
name|m_thread
argument_list|)
expr_stmt|;
name|m_thread
operator|->
name|signalReadyToSwap
argument_list|()
expr_stmt|;
block|}
name|m_thread
operator|->
name|unlock
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
DECL|function|setThread
name|void
name|setThread
parameter_list|(
name|SwapThread
modifier|*
name|thread
parameter_list|)
block|{
name|m_thread
operator|=
name|thread
expr_stmt|;
block|}
DECL|member|m_thread
name|SwapThread
modifier|*
name|m_thread
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|swapInThread
name|void
name|tst_QGLThreads
operator|::
name|swapInThread
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|ThreadedOpenGL
argument_list|)
condition|)
name|QSKIP
argument_list|(
literal|"No platformsupport for ThreadedOpenGL"
argument_list|)
expr_stmt|;
name|QGLFormat
name|format
decl_stmt|;
name|format
operator|.
name|setSwapInterval
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ForegroundWidget
name|widget
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|SwapThread
name|thread
argument_list|(
operator|&
name|widget
argument_list|)
decl_stmt|;
name|widget
operator|.
name|setThread
argument_list|(
operator|&
name|thread
argument_list|)
expr_stmt|;
name|widget
operator|.
name|show
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|QTest
operator|::
name|qWaitForWindowExposed
argument_list|(
operator|&
name|widget
argument_list|)
argument_list|)
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|thread
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|qApp
operator|->
name|processEvents
argument_list|()
expr_stmt|;
block|}
name|widget
operator|.
name|hide
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*    textureUploadInThread     The purpose of this testcase is to verify that doing texture uploads in a background    thread is possible and that it works.  */
end_comment
begin_class
DECL|class|CreateAndUploadThread
class|class
name|CreateAndUploadThread
super|:
specifier|public
name|QThread
block|{
name|Q_OBJECT
public|public:
DECL|function|CreateAndUploadThread
name|CreateAndUploadThread
parameter_list|(
name|QGLWidget
modifier|*
name|shareWidget
parameter_list|,
name|QSemaphore
modifier|*
name|semaphore
parameter_list|)
member_init_list|:
name|m_semaphore
argument_list|(
name|semaphore
argument_list|)
block|{
name|m_gl
operator|=
operator|new
name|QGLWidget
argument_list|(
literal|0
argument_list|,
name|shareWidget
argument_list|)
expr_stmt|;
name|moveToThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|m_gl
operator|->
name|context
argument_list|()
operator|->
name|moveToThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|function|~CreateAndUploadThread
name|~
name|CreateAndUploadThread
parameter_list|()
block|{
operator|delete
name|m_gl
expr_stmt|;
block|}
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|m_gl
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
name|QTime
name|time
decl_stmt|;
name|time
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|time
operator|.
name|elapsed
argument_list|()
operator|<
name|RUNNING_TIME
condition|)
block|{
name|int
name|width
init|=
literal|400
decl_stmt|;
name|int
name|height
init|=
literal|300
decl_stmt|;
name|QImage
name|image
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|QImage
operator|::
name|Format_RGB32
argument_list|)
decl_stmt|;
name|QPainter
name|p
argument_list|(
operator|&
name|image
argument_list|)
decl_stmt|;
name|p
operator|.
name|fillRect
argument_list|(
name|image
operator|.
name|rect
argument_list|()
argument_list|,
name|QColor
argument_list|(
name|rand
argument_list|()
operator|%
literal|256
argument_list|,
name|rand
argument_list|()
operator|%
literal|256
argument_list|,
name|rand
argument_list|()
operator|%
literal|256
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|setPen
argument_list|(
name|Qt
operator|::
name|red
argument_list|)
expr_stmt|;
name|p
operator|.
name|setFont
argument_list|(
name|QFont
argument_list|(
literal|"SansSerif"
argument_list|,
literal|24
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|drawText
argument_list|(
name|image
operator|.
name|rect
argument_list|()
argument_list|,
name|Qt
operator|::
name|AlignCenter
argument_list|,
literal|"This is an autotest"
argument_list|)
expr_stmt|;
name|p
operator|.
name|end
argument_list|()
expr_stmt|;
name|m_gl
operator|->
name|bindTexture
argument_list|(
name|image
argument_list|,
name|GL_TEXTURE_2D
argument_list|,
name|GL_RGBA
argument_list|,
name|QGLContext
operator|::
name|InternalBindOption
argument_list|)
expr_stmt|;
name|m_semaphore
operator|->
name|acquire
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|createdAndUploaded
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
block|}
signals|signals:
name|void
name|createdAndUploaded
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
function_decl|;
private|private:
DECL|member|m_gl
name|QGLWidget
modifier|*
name|m_gl
decl_stmt|;
DECL|member|m_semaphore
name|QSemaphore
modifier|*
name|m_semaphore
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|TextureDisplay
class|class
name|TextureDisplay
super|:
specifier|public
name|QGLWidget
block|{
name|Q_OBJECT
public|public:
DECL|function|TextureDisplay
name|TextureDisplay
parameter_list|(
name|QSemaphore
modifier|*
name|semaphore
parameter_list|)
member_init_list|:
name|m_semaphore
argument_list|(
name|semaphore
argument_list|)
block|{     }
DECL|function|paintEvent
name|void
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
block|{
name|QPainter
name|p
argument_list|(
name|this
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_images
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|.
name|drawImage
argument_list|(
name|m_positions
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|m_images
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|m_positions
index|[
name|i
index|]
operator|+=
name|QPoint
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|update
argument_list|()
expr_stmt|;
block|}
public|public
name|slots
public|:
DECL|function|receiveImage
name|void
name|receiveImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
name|m_images
operator|<<
name|image
expr_stmt|;
name|m_positions
operator|<<
name|QPoint
argument_list|(
operator|-
name|rand
argument_list|()
operator|%
name|width
argument_list|()
operator|/
literal|2
argument_list|,
operator|-
name|rand
argument_list|()
operator|%
name|height
argument_list|()
operator|/
literal|2
argument_list|)
expr_stmt|;
name|m_semaphore
operator|->
name|release
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_images
operator|.
name|size
argument_list|()
operator|>
literal|100
condition|)
block|{
name|m_images
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
name|m_positions
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
block|}
block|}
private|private:
DECL|member|m_images
name|QList
argument_list|<
name|QImage
argument_list|>
name|m_images
decl_stmt|;
DECL|member|m_positions
name|QList
argument_list|<
name|QPoint
argument_list|>
name|m_positions
decl_stmt|;
DECL|member|m_semaphore
name|QSemaphore
modifier|*
name|m_semaphore
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|textureUploadInThread
name|void
name|tst_QGLThreads
operator|::
name|textureUploadInThread
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|ThreadedOpenGL
argument_list|)
condition|)
name|QSKIP
argument_list|(
literal|"No platformsupport for ThreadedOpenGL"
argument_list|)
expr_stmt|;
comment|// prevent producer thread from queuing up too many images
name|QSemaphore
name|semaphore
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|TextureDisplay
name|display
argument_list|(
operator|&
name|semaphore
argument_list|)
decl_stmt|;
name|CreateAndUploadThread
name|thread
argument_list|(
operator|&
name|display
argument_list|,
operator|&
name|semaphore
argument_list|)
decl_stmt|;
name|connect
argument_list|(
operator|&
name|thread
argument_list|,
name|SIGNAL
argument_list|(
name|createdAndUploaded
argument_list|(
name|QImage
argument_list|)
argument_list|)
argument_list|,
operator|&
name|display
argument_list|,
name|SLOT
argument_list|(
name|receiveImage
argument_list|(
name|QImage
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|display
operator|.
name|show
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|QTest
operator|::
name|qWaitForWindowActive
argument_list|(
operator|&
name|display
argument_list|)
argument_list|)
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|thread
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|qApp
operator|->
name|processEvents
argument_list|()
expr_stmt|;
block|}
name|QVERIFY
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*    renderInThread     This test sets up a scene and renders it in a different thread.    For simplicity, the scene is simply a bunch of rectangles, but    if that works, we're in good shape..  */
end_comment
begin_function
DECL|function|qrandom
specifier|static
specifier|inline
name|float
name|qrandom
parameter_list|()
block|{
return|return
operator|(
name|rand
argument_list|()
operator|%
literal|100
operator|)
operator|/
literal|100.f
return|;
block|}
end_function
begin_function
DECL|function|renderAScene
name|void
name|renderAScene
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES_2
name|QGLShaderProgram
name|program
decl_stmt|;
name|program
operator|.
name|addShaderFromSourceCode
argument_list|(
name|QGLShader
operator|::
name|Vertex
argument_list|,
literal|"attribute highp vec2 pos; void main() { gl_Position = vec4(pos.xy, 1.0, 1.0); }"
argument_list|)
expr_stmt|;
name|program
operator|.
name|addShaderFromSourceCode
argument_list|(
name|QGLShader
operator|::
name|Fragment
argument_list|,
literal|"uniform lowp vec4 color; void main() { gl_FragColor = color; }"
argument_list|)
expr_stmt|;
name|program
operator|.
name|bindAttributeLocation
argument_list|(
literal|"pos"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|program
operator|.
name|bind
argument_list|()
expr_stmt|;
name|int
name|colorId
init|=
name|program
operator|.
name|uniformLocation
argument_list|(
literal|"color"
argument_list|)
decl_stmt|;
name|glEnableVertexAttribArray
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
operator|++
name|i
control|)
block|{
name|GLfloat
name|pos
index|[]
init|=
block|{
operator|(
name|rand
argument_list|()
operator|%
literal|100
operator|)
operator|/
literal|100.
block|,
operator|(
name|rand
argument_list|()
operator|%
literal|100
operator|)
operator|/
literal|100.
block|,
operator|(
name|rand
argument_list|()
operator|%
literal|100
operator|)
operator|/
literal|100.
block|,
operator|(
name|rand
argument_list|()
operator|%
literal|100
operator|)
operator|/
literal|100.
block|,
operator|(
name|rand
argument_list|()
operator|%
literal|100
operator|)
operator|/
literal|100.
block|,
operator|(
name|rand
argument_list|()
operator|%
literal|100
operator|)
operator|/
literal|100.
block|}
decl_stmt|;
name|glVertexAttribPointer
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|,
name|GL_FLOAT
argument_list|,
name|GL_FALSE
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|glDrawArrays
argument_list|(
name|GL_TRIANGLE_STRIP
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|glViewport
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|glMatrixMode
argument_list|(
name|GL_PROJECTION
argument_list|)
expr_stmt|;
name|glLoadIdentity
argument_list|()
expr_stmt|;
name|glFrustum
argument_list|(
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|glTranslated
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|glMatrixMode
argument_list|(
name|GL_MODELVIEW
argument_list|)
expr_stmt|;
name|glLoadIdentity
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
operator|++
name|i
control|)
block|{
name|glBegin
argument_list|(
name|GL_TRIANGLES
argument_list|)
expr_stmt|;
name|glColor3f
argument_list|(
name|qrandom
argument_list|()
argument_list|,
name|qrandom
argument_list|()
argument_list|,
name|qrandom
argument_list|()
argument_list|)
expr_stmt|;
name|glVertex2f
argument_list|(
name|qrandom
argument_list|()
operator|*
name|w
argument_list|,
name|qrandom
argument_list|()
operator|*
name|h
argument_list|)
expr_stmt|;
name|glColor3f
argument_list|(
name|qrandom
argument_list|()
argument_list|,
name|qrandom
argument_list|()
argument_list|,
name|qrandom
argument_list|()
argument_list|)
expr_stmt|;
name|glVertex2f
argument_list|(
name|qrandom
argument_list|()
operator|*
name|w
argument_list|,
name|qrandom
argument_list|()
operator|*
name|h
argument_list|)
expr_stmt|;
name|glColor3f
argument_list|(
name|qrandom
argument_list|()
argument_list|,
name|qrandom
argument_list|()
argument_list|,
name|qrandom
argument_list|()
argument_list|)
expr_stmt|;
name|glVertex2f
argument_list|(
name|qrandom
argument_list|()
operator|*
name|w
argument_list|,
name|qrandom
argument_list|()
operator|*
name|h
argument_list|)
expr_stmt|;
name|glEnd
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_class
DECL|class|ThreadSafeGLWidget
class|class
name|ThreadSafeGLWidget
super|:
specifier|public
name|QGLWidget
block|{
public|public:
DECL|function|ThreadSafeGLWidget
name|ThreadSafeGLWidget
parameter_list|(
name|QWidget
modifier|*
name|parent
init|=
literal|0
parameter_list|)
member_init_list|:
name|QGLWidget
argument_list|(
name|parent
argument_list|)
block|{}
DECL|function|paintEvent
name|void
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
block|{
comment|// ignored as we're anyway swapping as fast as we can
block|}
empty_stmt|;
DECL|function|resizeEvent
name|void
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
name|e
parameter_list|)
block|{
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|newSize
operator|=
name|e
operator|->
name|size
argument_list|()
expr_stmt|;
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
DECL|member|mutex
name|QMutex
name|mutex
decl_stmt|;
DECL|member|newSize
name|QSize
name|newSize
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|SceneRenderingThread
class|class
name|SceneRenderingThread
super|:
specifier|public
name|QThread
block|{
name|Q_OBJECT
public|public:
DECL|function|SceneRenderingThread
name|SceneRenderingThread
parameter_list|(
name|ThreadSafeGLWidget
modifier|*
name|widget
parameter_list|)
member_init_list|:
name|m_widget
argument_list|(
name|widget
argument_list|)
block|{
name|moveToThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|m_size
operator|=
name|widget
operator|->
name|size
argument_list|()
expr_stmt|;
block|}
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|QTime
name|time
decl_stmt|;
name|time
operator|.
name|start
argument_list|()
expr_stmt|;
name|failure
operator|=
literal|false
expr_stmt|;
while|while
condition|(
name|time
operator|.
name|elapsed
argument_list|()
operator|<
name|RUNNING_TIME
operator|&&
operator|!
name|failure
condition|)
block|{
name|m_widget
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
name|m_widget
operator|->
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|QSize
name|s
init|=
name|m_widget
operator|->
name|newSize
decl_stmt|;
name|m_widget
operator|->
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|m_size
condition|)
block|{
name|glViewport
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|s
operator|.
name|width
argument_list|()
argument_list|,
name|s
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QGLContext
operator|::
name|currentContext
argument_list|()
operator|!=
name|m_widget
operator|->
name|context
argument_list|()
condition|)
block|{
name|failure
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|glClear
argument_list|(
name|GL_COLOR_BUFFER_BIT
argument_list|)
expr_stmt|;
name|int
name|w
init|=
name|m_widget
operator|->
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|m_widget
operator|->
name|height
argument_list|()
decl_stmt|;
name|renderAScene
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|int
name|color
decl_stmt|;
name|glReadPixels
argument_list|(
name|w
operator|/
literal|2
argument_list|,
name|h
operator|/
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|m_widget
operator|->
name|swapBuffers
argument_list|()
expr_stmt|;
block|}
name|m_widget
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
block|}
DECL|member|failure
name|bool
name|failure
decl_stmt|;
private|private:
DECL|member|m_widget
name|ThreadSafeGLWidget
modifier|*
name|m_widget
decl_stmt|;
DECL|member|m_size
name|QSize
name|m_size
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|renderInThread_data
name|void
name|tst_QGLThreads
operator|::
name|renderInThread_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"resize"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"update"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"basic"
argument_list|)
operator|<<
literal|false
operator|<<
literal|false
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"with-resize"
argument_list|)
operator|<<
literal|true
operator|<<
literal|false
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"with-update"
argument_list|)
operator|<<
literal|false
operator|<<
literal|true
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"with-resize-and-update"
argument_list|)
operator|<<
literal|true
operator|<<
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|renderInThread
name|void
name|tst_QGLThreads
operator|::
name|renderInThread
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|ThreadedOpenGL
argument_list|)
condition|)
name|QSKIP
argument_list|(
literal|"No platformsupport for ThreadedOpenGL"
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|resize
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|update
argument_list|)
expr_stmt|;
name|ThreadSafeGLWidget
name|widget
decl_stmt|;
name|widget
operator|.
name|resize
argument_list|(
literal|200
argument_list|,
literal|200
argument_list|)
expr_stmt|;
name|SceneRenderingThread
name|thread
argument_list|(
operator|&
name|widget
argument_list|)
decl_stmt|;
name|widget
operator|.
name|show
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|QTest
operator|::
name|qWaitForWindowExposed
argument_list|(
operator|&
name|widget
argument_list|)
argument_list|)
expr_stmt|;
name|widget
operator|.
name|doneCurrent
argument_list|()
expr_stmt|;
name|widget
operator|.
name|context
argument_list|()
operator|->
name|moveToThread
argument_list|(
operator|&
name|thread
argument_list|)
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
name|int
name|value
init|=
literal|10
decl_stmt|;
while|while
condition|(
name|thread
operator|.
name|isRunning
argument_list|()
condition|)
block|{
if|if
condition|(
name|resize
condition|)
name|widget
operator|.
name|resize
argument_list|(
literal|200
operator|+
name|value
argument_list|,
literal|200
operator|+
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
condition|)
name|widget
operator|.
name|update
argument_list|(
literal|100
operator|+
name|value
argument_list|,
literal|100
operator|+
name|value
argument_list|,
literal|20
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|qApp
operator|->
name|processEvents
argument_list|()
expr_stmt|;
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|QThread
operator|::
name|msleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|QVERIFY
argument_list|(
operator|!
name|thread
operator|.
name|failure
argument_list|)
expr_stmt|;
block|}
end_function
begin_class
DECL|class|Device
class|class
name|Device
block|{
public|public:
DECL|function|~Device
specifier|virtual
name|~
name|Device
parameter_list|()
block|{}
specifier|virtual
name|QPaintDevice
modifier|*
name|realPaintDevice
parameter_list|()
function_decl|=
literal|0
function_decl|;
DECL|function|prepareDevice
specifier|virtual
name|void
name|prepareDevice
parameter_list|()
block|{}
DECL|function|moveToThread
specifier|virtual
name|void
name|moveToThread
parameter_list|(
name|QThread
modifier|*
parameter_list|)
block|{}
block|}
class|;
end_class
begin_class
DECL|class|GLWidgetWrapper
class|class
name|GLWidgetWrapper
super|:
specifier|public
name|Device
block|{
public|public:
DECL|function|GLWidgetWrapper
name|GLWidgetWrapper
parameter_list|()
block|{
name|widget
operator|.
name|resize
argument_list|(
literal|150
argument_list|,
literal|150
argument_list|)
expr_stmt|;
name|widget
operator|.
name|show
argument_list|()
expr_stmt|;
name|QTest
operator|::
name|qWaitForWindowExposed
argument_list|(
operator|&
name|widget
argument_list|)
expr_stmt|;
name|widget
operator|.
name|doneCurrent
argument_list|()
expr_stmt|;
block|}
DECL|function|realPaintDevice
name|QPaintDevice
modifier|*
name|realPaintDevice
parameter_list|()
block|{
return|return
operator|&
name|widget
return|;
block|}
DECL|function|moveToThread
name|void
name|moveToThread
parameter_list|(
name|QThread
modifier|*
name|thread
parameter_list|)
block|{
name|widget
operator|.
name|context
argument_list|()
operator|->
name|moveToThread
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
DECL|member|widget
name|ThreadSafeGLWidget
name|widget
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|PixmapWrapper
class|class
name|PixmapWrapper
super|:
specifier|public
name|Device
block|{
public|public:
DECL|function|PixmapWrapper
name|PixmapWrapper
parameter_list|()
block|{
name|pixmap
operator|=
operator|new
name|QPixmap
argument_list|(
literal|512
argument_list|,
literal|512
argument_list|)
expr_stmt|;
block|}
DECL|function|~PixmapWrapper
name|~
name|PixmapWrapper
parameter_list|()
block|{
operator|delete
name|pixmap
expr_stmt|;
block|}
DECL|function|realPaintDevice
name|QPaintDevice
modifier|*
name|realPaintDevice
parameter_list|()
block|{
return|return
name|pixmap
return|;
block|}
DECL|member|pixmap
name|QPixmap
modifier|*
name|pixmap
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|PixelBufferWrapper
class|class
name|PixelBufferWrapper
super|:
specifier|public
name|Device
block|{
public|public:
DECL|function|PixelBufferWrapper
name|PixelBufferWrapper
parameter_list|()
block|{
name|pbuffer
operator|=
operator|new
name|QGLPixelBuffer
argument_list|(
literal|512
argument_list|,
literal|512
argument_list|)
expr_stmt|;
block|}
DECL|function|~PixelBufferWrapper
name|~
name|PixelBufferWrapper
parameter_list|()
block|{
operator|delete
name|pbuffer
expr_stmt|;
block|}
DECL|function|realPaintDevice
name|QPaintDevice
modifier|*
name|realPaintDevice
parameter_list|()
block|{
return|return
name|pbuffer
return|;
block|}
DECL|function|moveToThread
name|void
name|moveToThread
parameter_list|(
name|QThread
modifier|*
name|thread
parameter_list|)
block|{
name|pbuffer
operator|->
name|context
argument_list|()
operator|->
name|moveToThread
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
DECL|member|pbuffer
name|QGLPixelBuffer
modifier|*
name|pbuffer
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|FrameBufferObjectWrapper
class|class
name|FrameBufferObjectWrapper
super|:
specifier|public
name|Device
block|{
public|public:
DECL|function|FrameBufferObjectWrapper
name|FrameBufferObjectWrapper
parameter_list|()
block|{
name|widget
operator|.
name|makeCurrent
argument_list|()
expr_stmt|;
name|fbo
operator|=
operator|new
name|QGLFramebufferObject
argument_list|(
literal|512
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|widget
operator|.
name|doneCurrent
argument_list|()
expr_stmt|;
block|}
DECL|function|~FrameBufferObjectWrapper
name|~
name|FrameBufferObjectWrapper
parameter_list|()
block|{
operator|delete
name|fbo
expr_stmt|;
block|}
DECL|function|realPaintDevice
name|QPaintDevice
modifier|*
name|realPaintDevice
parameter_list|()
block|{
return|return
name|fbo
return|;
block|}
DECL|function|prepareDevice
name|void
name|prepareDevice
parameter_list|()
block|{
name|widget
operator|.
name|makeCurrent
argument_list|()
expr_stmt|;
block|}
DECL|function|moveToThread
name|void
name|moveToThread
parameter_list|(
name|QThread
modifier|*
name|thread
parameter_list|)
block|{
name|widget
operator|.
name|context
argument_list|()
operator|->
name|moveToThread
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
DECL|member|widget
name|ThreadSafeGLWidget
name|widget
decl_stmt|;
DECL|member|fbo
name|QGLFramebufferObject
modifier|*
name|fbo
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|ThreadPainter
class|class
name|ThreadPainter
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
DECL|function|ThreadPainter
name|ThreadPainter
parameter_list|(
name|Device
modifier|*
name|pd
parameter_list|)
member_init_list|:
name|device
argument_list|(
name|pd
argument_list|)
member_init_list|,
name|fail
argument_list|(
literal|true
argument_list|)
block|{
name|pixmap
operator|=
name|QPixmap
argument_list|(
literal|40
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|pixmap
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|green
argument_list|)
expr_stmt|;
name|QPainter
name|p
argument_list|(
operator|&
name|pixmap
argument_list|)
decl_stmt|;
name|p
operator|.
name|drawLine
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|40
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|p
operator|.
name|drawLine
argument_list|(
literal|0
argument_list|,
literal|40
argument_list|,
literal|40
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
public|public
name|slots
public|:
DECL|function|draw
name|void
name|draw
parameter_list|()
block|{
name|bool
name|beginFailed
init|=
literal|false
decl_stmt|;
name|QTime
name|time
decl_stmt|;
name|time
operator|.
name|start
argument_list|()
expr_stmt|;
name|int
name|rotAngle
init|=
literal|10
decl_stmt|;
name|device
operator|->
name|prepareDevice
argument_list|()
expr_stmt|;
name|QPaintDevice
modifier|*
name|paintDevice
init|=
name|device
operator|->
name|realPaintDevice
argument_list|()
decl_stmt|;
name|QSize
name|s
argument_list|(
name|paintDevice
operator|->
name|width
argument_list|()
argument_list|,
name|paintDevice
operator|->
name|height
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|time
operator|.
name|elapsed
argument_list|()
operator|<
name|RUNNING_TIME
condition|)
block|{
name|QPainter
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|begin
argument_list|(
name|paintDevice
argument_list|)
condition|)
block|{
name|beginFailed
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|p
operator|.
name|translate
argument_list|(
name|s
operator|.
name|width
argument_list|()
operator|/
literal|2
argument_list|,
name|s
operator|.
name|height
argument_list|()
operator|/
literal|2
argument_list|)
expr_stmt|;
name|p
operator|.
name|rotate
argument_list|(
name|rotAngle
argument_list|)
expr_stmt|;
name|p
operator|.
name|translate
argument_list|(
operator|-
name|s
operator|.
name|width
argument_list|()
operator|/
literal|2
argument_list|,
operator|-
name|s
operator|.
name|height
argument_list|()
operator|/
literal|2
argument_list|)
expr_stmt|;
name|p
operator|.
name|fillRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|s
operator|.
name|width
argument_list|()
argument_list|,
name|s
operator|.
name|height
argument_list|()
argument_list|,
name|Qt
operator|::
name|red
argument_list|)
expr_stmt|;
name|QRect
name|rect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|p
operator|.
name|drawPixmap
argument_list|(
literal|10
argument_list|,
literal|10
argument_list|,
name|pixmap
argument_list|)
expr_stmt|;
name|p
operator|.
name|drawTiledPixmap
argument_list|(
literal|50
argument_list|,
literal|50
argument_list|,
literal|100
argument_list|,
literal|100
argument_list|,
name|pixmap
argument_list|)
expr_stmt|;
name|p
operator|.
name|drawText
argument_list|(
name|rect
operator|.
name|center
argument_list|()
argument_list|,
literal|"This is a piece of text"
argument_list|)
expr_stmt|;
name|p
operator|.
name|end
argument_list|()
expr_stmt|;
name|rotAngle
operator|+=
literal|2
expr_stmt|;
name|QThread
operator|::
name|msleep
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
name|device
operator|->
name|moveToThread
argument_list|(
name|qApp
operator|->
name|thread
argument_list|()
argument_list|)
expr_stmt|;
name|fail
operator|=
name|beginFailed
expr_stmt|;
name|QThread
operator|::
name|currentThread
argument_list|()
operator|->
name|quit
argument_list|()
expr_stmt|;
block|}
DECL|function|failed
name|bool
name|failed
parameter_list|()
block|{
return|return
name|fail
return|;
block|}
private|private:
DECL|member|pixmap
name|QPixmap
name|pixmap
decl_stmt|;
DECL|member|device
name|Device
modifier|*
name|device
decl_stmt|;
DECL|member|fail
name|bool
name|fail
decl_stmt|;
block|}
class|;
end_class
begin_class
template|template
parameter_list|<
name|class
name|T
parameter_list|>
class|class
DECL|class|PaintThreadManager
name|PaintThreadManager
block|{
public|public:
DECL|function|PaintThreadManager
name|PaintThreadManager
parameter_list|(
name|int
name|count
parameter_list|)
member_init_list|:
name|numThreads
argument_list|(
name|count
argument_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numThreads
condition|;
operator|++
name|i
control|)
block|{
name|devices
operator|.
name|append
argument_list|(
operator|new
name|T
argument_list|)
expr_stmt|;
name|threads
operator|.
name|append
argument_list|(
operator|new
name|QThread
argument_list|)
expr_stmt|;
name|painters
operator|.
name|append
argument_list|(
operator|new
name|ThreadPainter
argument_list|(
name|devices
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|painters
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|moveToThread
argument_list|(
name|threads
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|painters
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|connect
argument_list|(
name|threads
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|SIGNAL
argument_list|(
name|started
argument_list|()
argument_list|)
argument_list|,
name|painters
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|draw
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|devices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|moveToThread
argument_list|(
name|threads
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|~PaintThreadManager
name|~
name|PaintThreadManager
parameter_list|()
block|{
name|qDeleteAll
argument_list|(
name|threads
argument_list|)
expr_stmt|;
name|qDeleteAll
argument_list|(
name|painters
argument_list|)
expr_stmt|;
name|qDeleteAll
argument_list|(
name|devices
argument_list|)
expr_stmt|;
block|}
DECL|function|start
name|void
name|start
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numThreads
condition|;
operator|++
name|i
control|)
name|threads
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|start
argument_list|()
expr_stmt|;
block|}
DECL|function|areRunning
name|bool
name|areRunning
parameter_list|()
block|{
name|bool
name|running
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numThreads
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|threads
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|isRunning
argument_list|()
condition|)
name|running
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|running
return|;
block|}
DECL|function|failed
name|bool
name|failed
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numThreads
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|painters
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|failed
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
private|private:
DECL|member|threads
name|QList
argument_list|<
name|QThread
modifier|*
argument_list|>
name|threads
decl_stmt|;
DECL|member|devices
name|QList
argument_list|<
name|Device
modifier|*
argument_list|>
name|devices
decl_stmt|;
DECL|member|painters
name|QList
argument_list|<
name|ThreadPainter
modifier|*
argument_list|>
name|painters
decl_stmt|;
DECL|member|numThreads
name|int
name|numThreads
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*    This test uses QPainter to draw onto different QGLWidgets in    different threads at the same time. The ThreadSafeGLWidget is    necessary to handle paint and resize events that might come from    the main thread at any time while the test is running. The resize    and paint events would cause makeCurrent() calls to be issued from    within the QGLWidget while the widget's context was current in    another thread, which would cause errors. */
end_comment
begin_function
DECL|function|painterOnGLWidgetInThread
name|void
name|tst_QGLThreads
operator|::
name|painterOnGLWidgetInThread
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|ThreadedOpenGL
argument_list|)
condition|)
name|QSKIP
argument_list|(
literal|"No platformsupport for ThreadedOpenGL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|QGLFormat
operator|::
name|openGLVersionFlags
argument_list|()
operator|&
name|QGLFormat
operator|::
name|OpenGL_Version_2_0
operator|)
operator|||
operator|(
name|QGLFormat
operator|::
name|openGLVersionFlags
argument_list|()
operator|&
name|QGLFormat
operator|::
name|OpenGL_ES_Version_2_0
operator|)
operator|)
condition|)
block|{
name|QSKIP
argument_list|(
literal|"The OpenGL based threaded QPainter tests requires OpenGL/ES 2.0."
argument_list|)
expr_stmt|;
block|}
name|PaintThreadManager
argument_list|<
name|GLWidgetWrapper
argument_list|>
name|painterThreads
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|painterThreads
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|painterThreads
operator|.
name|areRunning
argument_list|()
condition|)
block|{
name|qApp
operator|->
name|processEvents
argument_list|()
expr_stmt|;
name|QThread
operator|::
name|msleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|QVERIFY
argument_list|(
operator|!
name|painterThreads
operator|.
name|failed
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*    This test uses QPainter to draw onto different QPixmaps in    different threads at the same time. */
end_comment
begin_function
DECL|function|painterOnPixmapInThread
name|void
name|tst_QGLThreads
operator|::
name|painterOnPixmapInThread
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|ThreadedOpenGL
argument_list|)
operator|||
operator|!
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|ThreadedPixmaps
argument_list|)
condition|)
name|QSKIP
argument_list|(
literal|"No platformsupport for ThreadedOpenGL or ThreadedPixmaps"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_X11
name|QSKIP
argument_list|(
literal|"Drawing text in threads onto X11 drawables currently crashes on some X11 servers."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PaintThreadManager
argument_list|<
name|PixmapWrapper
argument_list|>
name|painterThreads
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|painterThreads
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|painterThreads
operator|.
name|areRunning
argument_list|()
condition|)
block|{
name|qApp
operator|->
name|processEvents
argument_list|()
expr_stmt|;
name|QThread
operator|::
name|msleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|QVERIFY
argument_list|(
operator|!
name|painterThreads
operator|.
name|failed
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This test uses QPainter to draw onto different QGLPixelBuffer    objects in different threads at the same time. */
end_comment
begin_function
DECL|function|painterOnPboInThread
name|void
name|tst_QGLThreads
operator|::
name|painterOnPboInThread
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|ThreadedOpenGL
argument_list|)
condition|)
name|QSKIP
argument_list|(
literal|"No platformsupport for ThreadedOpenGL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|QGLFormat
operator|::
name|openGLVersionFlags
argument_list|()
operator|&
name|QGLFormat
operator|::
name|OpenGL_Version_2_0
operator|)
operator|||
operator|(
name|QGLFormat
operator|::
name|openGLVersionFlags
argument_list|()
operator|&
name|QGLFormat
operator|::
name|OpenGL_ES_Version_2_0
operator|)
operator|)
condition|)
block|{
name|QSKIP
argument_list|(
literal|"The OpenGL based threaded QPainter tests requires OpenGL/ES 2.0."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|QGLPixelBuffer
operator|::
name|hasOpenGLPbuffers
argument_list|()
condition|)
block|{
name|QSKIP
argument_list|(
literal|"This system doesn't support pbuffers."
argument_list|)
expr_stmt|;
block|}
name|PaintThreadManager
argument_list|<
name|PixelBufferWrapper
argument_list|>
name|painterThreads
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|painterThreads
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|painterThreads
operator|.
name|areRunning
argument_list|()
condition|)
block|{
name|qApp
operator|->
name|processEvents
argument_list|()
expr_stmt|;
name|QThread
operator|::
name|msleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|QVERIFY
argument_list|(
operator|!
name|painterThreads
operator|.
name|failed
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This test uses QPainter to draw onto different    QGLFramebufferObjects (bound in a QGLWidget's context) in different    threads at the same time. */
end_comment
begin_function
DECL|function|painterOnFboInThread
name|void
name|tst_QGLThreads
operator|::
name|painterOnFboInThread
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|ThreadedOpenGL
argument_list|)
condition|)
name|QSKIP
argument_list|(
literal|"No platformsupport for ThreadedOpenGL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|QGLFormat
operator|::
name|openGLVersionFlags
argument_list|()
operator|&
name|QGLFormat
operator|::
name|OpenGL_Version_2_0
operator|)
operator|||
operator|(
name|QGLFormat
operator|::
name|openGLVersionFlags
argument_list|()
operator|&
name|QGLFormat
operator|::
name|OpenGL_ES_Version_2_0
operator|)
operator|)
condition|)
block|{
name|QSKIP
argument_list|(
literal|"The OpenGL based threaded QPainter tests requires OpenGL/ES 2.0."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|QGLFramebufferObject
operator|::
name|hasOpenGLFramebufferObjects
argument_list|()
condition|)
block|{
name|QSKIP
argument_list|(
literal|"This system doesn't support framebuffer objects."
argument_list|)
expr_stmt|;
block|}
name|PaintThreadManager
argument_list|<
name|FrameBufferObjectWrapper
argument_list|>
name|painterThreads
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|painterThreads
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|painterThreads
operator|.
name|areRunning
argument_list|()
condition|)
block|{
name|qApp
operator|->
name|processEvents
argument_list|()
expr_stmt|;
name|QThread
operator|::
name|msleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|QVERIFY
argument_list|(
operator|!
name|painterThreads
operator|.
name|failed
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|QApplication
operator|::
name|setAttribute
argument_list|(
name|Qt
operator|::
name|AA_X11InitThreads
argument_list|)
expr_stmt|;
name|QApplication
name|app
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
decl_stmt|;
name|QTEST_DISABLE_KEYPAD_NAVIGATION
type|\
name|tst_QGLThreads
name|tc
decl_stmt|;
return|return
name|QTest
operator|::
name|qExec
argument_list|(
operator|&
name|tc
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function
begin_include
include|#
directive|include
file|"tst_qglthreads.moc"
end_include
end_unit
