begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the test suite of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtTest/QtTest>
end_include
begin_include
include|#
directive|include
file|<qabstracteventdispatcher.h>
end_include
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<qcoreevent.h>
end_include
begin_include
include|#
directive|include
file|<qeventloop.h>
end_include
begin_include
include|#
directive|include
file|<qmutex.h>
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|<qtimer.h>
end_include
begin_include
include|#
directive|include
file|<qwaitcondition.h>
end_include
begin_include
include|#
directive|include
file|<QTcpServer>
end_include
begin_include
include|#
directive|include
file|<QTcpSocket>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
end_ifdef
begin_include
include|#
directive|include
file|<e32base.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//TESTED_CLASS=
end_comment
begin_comment
comment|//TESTED_FILES=
end_comment
begin_class
DECL|class|EventLoopExiter
class|class
name|EventLoopExiter
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
DECL|member|eventLoop
name|QEventLoop
modifier|*
name|eventLoop
decl_stmt|;
public|public:
DECL|function|EventLoopExiter
specifier|inline
name|EventLoopExiter
parameter_list|(
name|QEventLoop
modifier|*
name|el
parameter_list|)
member_init_list|:
name|eventLoop
argument_list|(
name|el
argument_list|)
block|{ }
public|public
name|slots
public|:
name|void
name|exit
parameter_list|()
function_decl|;
name|void
name|exit1
parameter_list|()
function_decl|;
name|void
name|exit2
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_function
DECL|function|exit
name|void
name|EventLoopExiter
operator|::
name|exit
parameter_list|()
block|{
name|eventLoop
operator|->
name|exit
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|exit1
name|void
name|EventLoopExiter
operator|::
name|exit1
parameter_list|()
block|{
name|eventLoop
operator|->
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|exit2
name|void
name|EventLoopExiter
operator|::
name|exit2
parameter_list|()
block|{
name|eventLoop
operator|->
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function
begin_class
DECL|class|EventLoopThread
class|class
name|EventLoopThread
super|:
specifier|public
name|QThread
block|{
name|Q_OBJECT
signals|signals:
name|void
name|checkPoint
parameter_list|()
function_decl|;
public|public:
DECL|member|eventLoop
name|QEventLoop
modifier|*
name|eventLoop
decl_stmt|;
name|void
name|run
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_function
DECL|function|run
name|void
name|EventLoopThread
operator|::
name|run
parameter_list|()
block|{
name|eventLoop
operator|=
operator|new
name|QEventLoop
expr_stmt|;
emit|emit
name|checkPoint
argument_list|()
emit|;
operator|(
name|void
operator|)
name|eventLoop
operator|->
name|exec
argument_list|()
expr_stmt|;
operator|delete
name|eventLoop
expr_stmt|;
name|eventLoop
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_class
DECL|class|MultipleExecThread
class|class
name|MultipleExecThread
super|:
specifier|public
name|QThread
block|{
name|Q_OBJECT
signals|signals:
name|void
name|checkPoint
parameter_list|()
function_decl|;
public|public:
DECL|member|mutex
name|QMutex
name|mutex
decl_stmt|;
DECL|member|cond
name|QWaitCondition
name|cond
decl_stmt|;
DECL|member|result1
specifier|volatile
name|int
name|result1
decl_stmt|;
DECL|member|result2
specifier|volatile
name|int
name|result2
decl_stmt|;
DECL|function|MultipleExecThread
name|MultipleExecThread
parameter_list|()
member_init_list|:
name|result1
argument_list|(
literal|0xdead
argument_list|)
member_init_list|,
name|result2
argument_list|(
literal|0xbeef
argument_list|)
block|{}
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
comment|// this exec should work
name|cond
operator|.
name|wakeOne
argument_list|()
expr_stmt|;
name|cond
operator|.
name|wait
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|QTimer
name|timer
decl_stmt|;
name|connect
argument_list|(
operator|&
name|timer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|quit
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|timer
operator|.
name|setInterval
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|timer
operator|.
name|start
argument_list|()
expr_stmt|;
name|result1
operator|=
name|exec
argument_list|()
expr_stmt|;
comment|// this should return immediately, since exit() has been called
name|cond
operator|.
name|wakeOne
argument_list|()
expr_stmt|;
name|cond
operator|.
name|wait
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|QEventLoop
name|eventLoop
decl_stmt|;
name|result2
operator|=
name|eventLoop
operator|.
name|exec
argument_list|()
expr_stmt|;
block|}
block|}
class|;
end_class
begin_class
DECL|class|StartStopEvent
class|class
name|StartStopEvent
super|:
specifier|public
name|QEvent
block|{
public|public:
DECL|function|StartStopEvent
name|StartStopEvent
parameter_list|(
name|int
name|type
parameter_list|,
name|QEventLoop
modifier|*
name|loop
init|=
literal|0
parameter_list|)
member_init_list|:
name|QEvent
argument_list|(
name|Type
argument_list|(
name|type
argument_list|)
argument_list|)
member_init_list|,
name|el
argument_list|(
name|loop
argument_list|)
block|{ }
DECL|member|el
name|QEventLoop
modifier|*
name|el
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|EventLoopExecutor
class|class
name|EventLoopExecutor
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
DECL|member|eventLoop
name|QEventLoop
modifier|*
name|eventLoop
decl_stmt|;
public|public:
DECL|member|returnCode
name|int
name|returnCode
decl_stmt|;
DECL|function|EventLoopExecutor
name|EventLoopExecutor
parameter_list|(
name|QEventLoop
modifier|*
name|eventLoop
parameter_list|)
member_init_list|:
name|QObject
argument_list|()
member_init_list|,
name|eventLoop
argument_list|(
name|eventLoop
argument_list|)
member_init_list|,
name|returnCode
argument_list|(
operator|-
literal|42
argument_list|)
block|{     }
public|public
name|slots
public|:
DECL|function|exec
name|void
name|exec
parameter_list|()
block|{
name|QTimer
operator|::
name|singleShot
argument_list|(
literal|100
argument_list|,
name|eventLoop
argument_list|,
name|SLOT
argument_list|(
name|quit
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// this should return immediately, and the timer event should be delivered to
comment|// tst_QEventLoop::exec() test, letting the test complete
name|returnCode
operator|=
name|eventLoop
operator|->
name|exec
argument_list|()
expr_stmt|;
block|}
block|}
class|;
end_class
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_EXCEPTIONS
end_ifndef
begin_class
DECL|class|QEventLoopTestException
class|class
name|QEventLoopTestException
block|{
block|}
class|;
end_class
begin_class
DECL|class|ExceptionThrower
class|class
name|ExceptionThrower
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
DECL|function|ExceptionThrower
name|ExceptionThrower
parameter_list|()
member_init_list|:
name|QObject
argument_list|()
block|{ }
public|public
name|slots
public|:
DECL|function|throwException
name|void
name|throwException
parameter_list|()
block|{
name|QEventLoopTestException
name|e
decl_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
class|;
end_class
begin_endif
endif|#
directive|endif
end_endif
begin_class
DECL|class|tst_QEventLoop
class|class
name|tst_QEventLoop
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
name|tst_QEventLoop
parameter_list|()
constructor_decl|;
name|~
name|tst_QEventLoop
parameter_list|()
destructor_decl|;
public|public
name|slots
public|:
name|void
name|init
parameter_list|()
function_decl|;
name|void
name|cleanup
parameter_list|()
function_decl|;
private|private
name|slots
private|:
comment|// This test *must* run first. See the definition for why.
name|void
name|onlySymbianActiveScheduler
parameter_list|()
function_decl|;
name|void
name|symbianNestedActiveSchedulerLoop_data
parameter_list|()
function_decl|;
name|void
name|symbianNestedActiveSchedulerLoop
parameter_list|()
function_decl|;
name|void
name|processEvents
parameter_list|()
function_decl|;
name|void
name|exec
parameter_list|()
function_decl|;
name|void
name|reexec
parameter_list|()
function_decl|;
name|void
name|exit
parameter_list|()
function_decl|;
name|void
name|execAfterExit
parameter_list|()
function_decl|;
name|void
name|wakeUp
parameter_list|()
function_decl|;
name|void
name|quit
parameter_list|()
function_decl|;
name|void
name|processEventsExcludeSocket
parameter_list|()
function_decl|;
name|void
name|processEventsExcludeTimers
parameter_list|()
function_decl|;
comment|// keep this test last:
name|void
name|nestedLoops
parameter_list|()
function_decl|;
protected|protected:
name|void
name|customEvent
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_constructor
DECL|function|tst_QEventLoop
name|tst_QEventLoop
operator|::
name|tst_QEventLoop
parameter_list|()
block|{ }
end_constructor
begin_destructor
DECL|function|~tst_QEventLoop
name|tst_QEventLoop
operator|::
name|~
name|tst_QEventLoop
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|init
name|void
name|tst_QEventLoop
operator|::
name|init
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|cleanup
name|void
name|tst_QEventLoop
operator|::
name|cleanup
parameter_list|()
block|{ }
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
end_ifdef
begin_class
DECL|class|OnlySymbianActiveScheduler_helper
class|class
name|OnlySymbianActiveScheduler_helper
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
DECL|function|OnlySymbianActiveScheduler_helper
name|OnlySymbianActiveScheduler_helper
parameter_list|(
name|int
name|fd
parameter_list|,
name|QTimer
modifier|*
name|zeroTimer
parameter_list|)
member_init_list|:
name|fd
argument_list|(
name|fd
argument_list|)
member_init_list|,
name|timerCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|zeroTimer
argument_list|(
name|zeroTimer
argument_list|)
member_init_list|,
name|zeroTimerCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|notifierCount
argument_list|(
literal|0
argument_list|)
block|{     }
DECL|function|~OnlySymbianActiveScheduler_helper
name|~
name|OnlySymbianActiveScheduler_helper
parameter_list|()
block|{}
public|public
name|slots
public|:
DECL|function|timerSlot
name|void
name|timerSlot
parameter_list|()
block|{
comment|// Let all the events occur twice so we know they reactivated after
comment|// each occurrence.
if|if
condition|(
operator|++
name|timerCount
operator|>=
literal|2
condition|)
block|{
comment|// This will hopefully run last, so stop the active scheduler.
name|CActiveScheduler
operator|::
name|Stop
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|zeroTimerSlot
name|void
name|zeroTimerSlot
parameter_list|()
block|{
if|if
condition|(
operator|++
name|zeroTimerCount
operator|>=
literal|2
condition|)
block|{
name|zeroTimer
operator|->
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|notifierSlot
name|void
name|notifierSlot
parameter_list|()
block|{
if|if
condition|(
operator|++
name|notifierCount
operator|>=
literal|2
condition|)
block|{
name|char
name|dummy
decl_stmt|;
operator|::
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
private|private:
DECL|member|fd
name|int
name|fd
decl_stmt|;
DECL|member|timerCount
name|int
name|timerCount
decl_stmt|;
DECL|member|zeroTimer
name|QTimer
modifier|*
name|zeroTimer
decl_stmt|;
DECL|member|zeroTimerCount
name|int
name|zeroTimerCount
decl_stmt|;
DECL|member|notifierCount
name|int
name|notifierCount
decl_stmt|;
block|}
class|;
end_class
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|onlySymbianActiveScheduler
name|void
name|tst_QEventLoop
operator|::
name|onlySymbianActiveScheduler
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_OS_SYMBIAN
name|QSKIP
argument_list|(
literal|"This is a Symbian-only test."
argument_list|,
name|SkipAll
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// In here we try to use timers and sockets exclusively using the Symbian
comment|// active scheduler and no processEvents().
comment|// This test should therefore be run first, so that we can verify that
comment|// the first occurrence of processEvents does not do any initalization that
comment|// we depend on.
comment|// Open up a pipe so we can test socket notifiers.
name|int
name|pipeEnds
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|::
name|pipe
argument_list|(
name|pipeEnds
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|QFAIL
argument_list|(
literal|"Could not open pipe"
argument_list|)
expr_stmt|;
block|}
name|QSocketNotifier
name|notifier
argument_list|(
name|pipeEnds
index|[
literal|0
index|]
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|)
decl_stmt|;
name|QSignalSpy
name|notifierSpy
argument_list|(
operator|&
name|notifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|dummy
init|=
literal|1
decl_stmt|;
operator|::
name|write
argument_list|(
name|pipeEnds
index|[
literal|1
index|]
argument_list|,
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|QTimer
name|zeroTimer
decl_stmt|;
name|QSignalSpy
name|zeroTimerSpy
argument_list|(
operator|&
name|zeroTimer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|zeroTimer
operator|.
name|setInterval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|zeroTimer
operator|.
name|start
argument_list|()
expr_stmt|;
name|QTimer
name|timer
decl_stmt|;
name|QSignalSpy
name|timerSpy
argument_list|(
operator|&
name|timer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|timer
operator|.
name|setInterval
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
comment|// Generous timeout or this test will fail if there is high load
name|timer
operator|.
name|start
argument_list|()
expr_stmt|;
name|OnlySymbianActiveScheduler_helper
name|helper
argument_list|(
name|pipeEnds
index|[
literal|0
index|]
argument_list|,
operator|&
name|zeroTimer
argument_list|)
decl_stmt|;
name|connect
argument_list|(
operator|&
name|notifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
operator|&
name|helper
argument_list|,
name|SLOT
argument_list|(
name|notifierSlot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|zeroTimer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
operator|&
name|helper
argument_list|,
name|SLOT
argument_list|(
name|zeroTimerSlot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|timer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
operator|&
name|helper
argument_list|,
name|SLOT
argument_list|(
name|timerSlot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|CActiveScheduler
operator|::
name|Start
argument_list|()
expr_stmt|;
operator|::
name|close
argument_list|(
name|pipeEnds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|::
name|close
argument_list|(
name|pipeEnds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|notifierSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|zeroTimerSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|timerSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|processEvents
name|void
name|tst_QEventLoop
operator|::
name|processEvents
parameter_list|()
block|{
name|QSignalSpy
name|spy1
argument_list|(
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|aboutToBlock
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QSignalSpy
name|spy2
argument_list|(
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|awake
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QEventLoop
name|eventLoop
decl_stmt|;
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
operator|&
name|eventLoop
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|User
argument_list|)
argument_list|)
expr_stmt|;
comment|// process posted events, QEventLoop::processEvents() should return
comment|// true
name|QVERIFY
argument_list|(
name|eventLoop
operator|.
name|processEvents
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|spy1
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|spy2
operator|.
name|count
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// allow any session manager to complete its handshake, so that
comment|// there are no pending events left.
while|while
condition|(
name|eventLoop
operator|.
name|processEvents
argument_list|()
condition|)
empty_stmt|;
comment|// On mac we get application started events at this point,
comment|// so process events one more time just to be sure.
name|eventLoop
operator|.
name|processEvents
argument_list|()
expr_stmt|;
comment|// no events to process, QEventLoop::processEvents() should return
comment|// false
name|spy1
operator|.
name|clear
argument_list|()
expr_stmt|;
name|spy2
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|eventLoop
operator|.
name|processEvents
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|spy1
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|spy2
operator|.
name|count
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// make sure the test doesn't block forever
name|int
name|timerId
init|=
name|startTimer
argument_list|(
literal|100
argument_list|)
decl_stmt|;
comment|// wait for more events to process, QEventLoop::processEvents()
comment|// should return true
name|spy1
operator|.
name|clear
argument_list|()
expr_stmt|;
name|spy2
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|eventLoop
operator|.
name|processEvents
argument_list|(
name|QEventLoop
operator|::
name|WaitForMoreEvents
argument_list|)
argument_list|)
expr_stmt|;
comment|// Verify that the eventloop has blocked and woken up. Some eventloops
comment|// may block and wake up multiple times.
name|QVERIFY
argument_list|(
name|spy1
operator|.
name|count
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|spy2
operator|.
name|count
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// We should get one awake for each aboutToBlock, plus one awake when
comment|// processEvents is entered.
name|QVERIFY
argument_list|(
name|spy2
operator|.
name|count
argument_list|()
operator|>=
name|spy1
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|killTimer
argument_list|(
name|timerId
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_NOKIAX86
argument_list|)
end_if
begin_comment
comment|// Symbian needs bit longer timeout for emulator, as emulator startup causes additional delay
end_comment
begin_define
DECL|macro|EXEC_TIMEOUT
define|#
directive|define
name|EXEC_TIMEOUT
value|1000
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|EXEC_TIMEOUT
define|#
directive|define
name|EXEC_TIMEOUT
value|100
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|exec
name|void
name|tst_QEventLoop
operator|::
name|exec
parameter_list|()
block|{
block|{
name|QEventLoop
name|eventLoop
decl_stmt|;
name|EventLoopExiter
name|exiter
argument_list|(
operator|&
name|eventLoop
argument_list|)
decl_stmt|;
name|int
name|returnCode
decl_stmt|;
name|QTimer
operator|::
name|singleShot
argument_list|(
name|EXEC_TIMEOUT
argument_list|,
operator|&
name|exiter
argument_list|,
name|SLOT
argument_list|(
name|exit
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|returnCode
operator|=
name|eventLoop
operator|.
name|exec
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|returnCode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QTimer
operator|::
name|singleShot
argument_list|(
name|EXEC_TIMEOUT
argument_list|,
operator|&
name|exiter
argument_list|,
name|SLOT
argument_list|(
name|exit1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|returnCode
operator|=
name|eventLoop
operator|.
name|exec
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|returnCode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|QTimer
operator|::
name|singleShot
argument_list|(
name|EXEC_TIMEOUT
argument_list|,
operator|&
name|exiter
argument_list|,
name|SLOT
argument_list|(
name|exit2
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|returnCode
operator|=
name|eventLoop
operator|.
name|exec
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|returnCode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|{
comment|// calling QEventLoop::exec() after a thread loop has exit()ed should return immediately
comment|// Note: this behaviour differs from QCoreApplication and QEventLoop
comment|// see tst_QCoreApplication::eventLoopExecAfterExit, tst_QEventLoop::reexec
name|MultipleExecThread
name|thread
decl_stmt|;
comment|// start thread and wait for checkpoint
name|thread
operator|.
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
name|thread
operator|.
name|cond
operator|.
name|wait
argument_list|(
operator|&
name|thread
operator|.
name|mutex
argument_list|)
expr_stmt|;
comment|// make sure the eventloop runs
name|QSignalSpy
name|spy
argument_list|(
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|(
operator|&
name|thread
argument_list|)
argument_list|,
name|SIGNAL
argument_list|(
name|awake
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|thread
operator|.
name|cond
operator|.
name|wakeOne
argument_list|()
expr_stmt|;
name|thread
operator|.
name|cond
operator|.
name|wait
argument_list|(
operator|&
name|thread
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|spy
operator|.
name|count
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|int
name|v
init|=
name|thread
operator|.
name|result1
decl_stmt|;
name|QCOMPARE
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// exec should return immediately
name|spy
operator|.
name|clear
argument_list|()
expr_stmt|;
name|thread
operator|.
name|cond
operator|.
name|wakeOne
argument_list|()
expr_stmt|;
name|thread
operator|.
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|thread
operator|.
name|wait
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|spy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|v
operator|=
name|thread
operator|.
name|result2
expr_stmt|;
name|QCOMPARE
argument_list|(
name|v
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|{
comment|// a single instance of QEventLoop should not be allowed to recurse into exec()
name|QEventLoop
name|eventLoop
decl_stmt|;
name|EventLoopExecutor
name|executor
argument_list|(
operator|&
name|eventLoop
argument_list|)
decl_stmt|;
name|QTimer
operator|::
name|singleShot
argument_list|(
name|EXEC_TIMEOUT
argument_list|,
operator|&
name|executor
argument_list|,
name|SLOT
argument_list|(
name|exec
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|returnCode
init|=
name|eventLoop
operator|.
name|exec
argument_list|()
decl_stmt|;
name|QCOMPARE
argument_list|(
name|returnCode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|executor
operator|.
name|returnCode
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_EXCEPTIONS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE_WM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_EVENTLOOP_EXCEPTIONS
argument_list|)
comment|// Windows Mobile cannot handle cross library exceptions
comment|// qobject.cpp will try to rethrow the exception after handling
comment|// which causes gwes.exe to crash
comment|// Symbian doesn't propagate exceptions from eventloop, but converts them to
comment|// CActiveScheduler errors instead -> this test will hang.
block|{
comment|// QEventLoop::exec() is exception safe
name|QEventLoop
name|eventLoop
decl_stmt|;
name|int
name|caughtExceptions
init|=
literal|0
decl_stmt|;
try|try
block|{
name|ExceptionThrower
name|exceptionThrower
decl_stmt|;
name|QTimer
operator|::
name|singleShot
argument_list|(
name|EXEC_TIMEOUT
argument_list|,
operator|&
name|exceptionThrower
argument_list|,
name|SLOT
argument_list|(
name|throwException
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|eventLoop
operator|.
name|exec
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
modifier|...
parameter_list|)
block|{
operator|++
name|caughtExceptions
expr_stmt|;
block|}
try|try
block|{
name|ExceptionThrower
name|exceptionThrower
decl_stmt|;
name|QTimer
operator|::
name|singleShot
argument_list|(
name|EXEC_TIMEOUT
argument_list|,
operator|&
name|exceptionThrower
argument_list|,
name|SLOT
argument_list|(
name|throwException
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|eventLoop
operator|.
name|exec
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
modifier|...
parameter_list|)
block|{
operator|++
name|caughtExceptions
expr_stmt|;
block|}
name|QCOMPARE
argument_list|(
name|caughtExceptions
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|reexec
name|void
name|tst_QEventLoop
operator|::
name|reexec
parameter_list|()
block|{
name|QEventLoop
name|loop
decl_stmt|;
comment|// exec once
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
operator|&
name|loop
argument_list|,
literal|"quit"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|loop
operator|.
name|exec
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// and again
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
operator|&
name|loop
argument_list|,
literal|"quit"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|loop
operator|.
name|exec
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|exit
name|void
name|tst_QEventLoop
operator|::
name|exit
parameter_list|()
block|{
name|DEPENDS_ON
argument_list|(
name|exec
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|execAfterExit
name|void
name|tst_QEventLoop
operator|::
name|execAfterExit
parameter_list|()
block|{
name|QEventLoop
name|loop
decl_stmt|;
name|EventLoopExiter
name|obj
argument_list|(
operator|&
name|loop
argument_list|)
decl_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
operator|&
name|obj
argument_list|,
literal|"exit"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|loop
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|loop
operator|.
name|exec
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|wakeUp
name|void
name|tst_QEventLoop
operator|::
name|wakeUp
parameter_list|()
block|{
name|EventLoopThread
name|thread
decl_stmt|;
name|QEventLoop
name|eventLoop
decl_stmt|;
name|connect
argument_list|(
operator|&
name|thread
argument_list|,
name|SIGNAL
argument_list|(
name|checkPoint
argument_list|()
argument_list|)
argument_list|,
operator|&
name|eventLoop
argument_list|,
name|SLOT
argument_list|(
name|quit
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|thread
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
operator|&
name|eventLoop
argument_list|,
name|SLOT
argument_list|(
name|quit
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|eventLoop
operator|.
name|exec
argument_list|()
expr_stmt|;
name|QSignalSpy
name|spy
argument_list|(
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|(
operator|&
name|thread
argument_list|)
argument_list|,
name|SIGNAL
argument_list|(
name|awake
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|thread
operator|.
name|eventLoop
operator|->
name|wakeUp
argument_list|()
expr_stmt|;
comment|// give the thread time to wake up
name|QTimer
operator|::
name|singleShot
argument_list|(
literal|1000
argument_list|,
operator|&
name|eventLoop
argument_list|,
name|SLOT
argument_list|(
name|quit
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|eventLoop
operator|.
name|exec
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|spy
operator|.
name|count
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|thread
operator|.
name|quit
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|eventLoop
operator|.
name|exec
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|quit
name|void
name|tst_QEventLoop
operator|::
name|quit
parameter_list|()
block|{
name|QEventLoop
name|eventLoop
decl_stmt|;
name|int
name|returnCode
decl_stmt|;
name|QTimer
operator|::
name|singleShot
argument_list|(
literal|100
argument_list|,
operator|&
name|eventLoop
argument_list|,
name|SLOT
argument_list|(
name|quit
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|returnCode
operator|=
name|eventLoop
operator|.
name|exec
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|returnCode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|nestedLoops
name|void
name|tst_QEventLoop
operator|::
name|nestedLoops
parameter_list|()
block|{
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|this
argument_list|,
operator|new
name|StartStopEvent
argument_list|(
name|QEvent
operator|::
name|User
argument_list|)
argument_list|)
expr_stmt|;
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|this
argument_list|,
operator|new
name|StartStopEvent
argument_list|(
name|QEvent
operator|::
name|User
argument_list|)
argument_list|)
expr_stmt|;
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|this
argument_list|,
operator|new
name|StartStopEvent
argument_list|(
name|QEvent
operator|::
name|User
argument_list|)
argument_list|)
expr_stmt|;
comment|// without the fix, this will *wedge* and never return
name|QTest
operator|::
name|qWait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|customEvent
name|void
name|tst_QEventLoop
operator|::
name|customEvent
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|User
condition|)
block|{
name|QEventLoop
name|loop
decl_stmt|;
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|this
argument_list|,
operator|new
name|StartStopEvent
argument_list|(
name|int
argument_list|(
name|QEvent
operator|::
name|User
argument_list|)
operator|+
literal|1
argument_list|,
operator|&
name|loop
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|.
name|exec
argument_list|()
expr_stmt|;
block|}
else|else
block|{
cast|static_cast
argument_list|<
name|StartStopEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
operator|->
name|el
operator|->
name|exit
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_class
DECL|class|SocketEventsTester
class|class
name|SocketEventsTester
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
DECL|function|SocketEventsTester
name|SocketEventsTester
parameter_list|()
block|{
name|socket
operator|=
literal|0
expr_stmt|;
name|server
operator|=
literal|0
expr_stmt|;
name|dataArrived
operator|=
literal|false
expr_stmt|;
name|testResult
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|~SocketEventsTester
name|~
name|SocketEventsTester
parameter_list|()
block|{
operator|delete
name|socket
expr_stmt|;
operator|delete
name|server
expr_stmt|;
block|}
DECL|function|init
name|bool
name|init
parameter_list|()
block|{
name|bool
name|ret
init|=
literal|false
decl_stmt|;
name|server
operator|=
operator|new
name|QTcpServer
argument_list|()
expr_stmt|;
name|socket
operator|=
operator|new
name|QTcpSocket
argument_list|()
expr_stmt|;
name|connect
argument_list|(
name|server
argument_list|,
name|SIGNAL
argument_list|(
name|newConnection
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|sendHello
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|sendAck
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|server
operator|->
name|listen
argument_list|(
name|QHostAddress
operator|::
name|LocalHost
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|socket
operator|->
name|connectToHost
argument_list|(
name|server
operator|->
name|serverAddress
argument_list|()
argument_list|,
name|server
operator|->
name|serverPort
argument_list|()
argument_list|)
expr_stmt|;
name|socket
operator|->
name|waitForConnected
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|member|socket
name|QTcpSocket
modifier|*
name|socket
decl_stmt|;
DECL|member|server
name|QTcpServer
modifier|*
name|server
decl_stmt|;
DECL|member|dataArrived
name|bool
name|dataArrived
decl_stmt|;
DECL|member|testResult
name|bool
name|testResult
decl_stmt|;
public|public
name|slots
public|:
DECL|function|sendAck
name|void
name|sendAck
parameter_list|()
block|{
name|dataArrived
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|sendHello
name|void
name|sendHello
parameter_list|()
block|{
name|char
name|data
index|[
literal|10
index|]
init|=
literal|"HELLO"
decl_stmt|;
name|qint64
name|size
init|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|QTcpSocket
modifier|*
name|serverSocket
init|=
name|server
operator|->
name|nextPendingConnection
argument_list|()
decl_stmt|;
name|serverSocket
operator|->
name|write
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|serverSocket
operator|->
name|flush
argument_list|()
expr_stmt|;
name|QTest
operator|::
name|qSleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|//allow the TCP/IP stack time to loopback the data, so our socket is ready to read
name|QCoreApplication
operator|::
name|processEvents
argument_list|(
name|QEventLoop
operator|::
name|ExcludeSocketNotifiers
argument_list|)
expr_stmt|;
name|testResult
operator|=
name|dataArrived
expr_stmt|;
name|QCoreApplication
operator|::
name|processEvents
argument_list|()
expr_stmt|;
comment|//check the deferred event is processed
name|serverSocket
operator|->
name|close
argument_list|()
expr_stmt|;
name|QThread
operator|::
name|currentThread
argument_list|()
operator|->
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
class|;
end_class
begin_class
DECL|class|SocketTestThread
class|class
name|SocketTestThread
super|:
specifier|public
name|QThread
block|{
name|Q_OBJECT
public|public:
DECL|function|SocketTestThread
name|SocketTestThread
parameter_list|()
member_init_list|:
name|QThread
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|testResult
argument_list|(
literal|false
argument_list|)
block|{}
empty_stmt|;
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|SocketEventsTester
modifier|*
name|tester
init|=
operator|new
name|SocketEventsTester
argument_list|()
decl_stmt|;
if|if
condition|(
name|tester
operator|->
name|init
argument_list|()
condition|)
name|exec
argument_list|()
expr_stmt|;
name|testResult
operator|=
name|tester
operator|->
name|testResult
expr_stmt|;
name|dataArrived
operator|=
name|tester
operator|->
name|dataArrived
expr_stmt|;
operator|delete
name|tester
expr_stmt|;
block|}
DECL|member|testResult
name|bool
name|testResult
decl_stmt|;
DECL|member|dataArrived
name|bool
name|dataArrived
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|processEventsExcludeSocket
name|void
name|tst_QEventLoop
operator|::
name|processEventsExcludeSocket
parameter_list|()
block|{
name|SocketTestThread
name|thread
decl_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|thread
operator|.
name|wait
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|thread
operator|.
name|testResult
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|thread
operator|.
name|dataArrived
argument_list|)
expr_stmt|;
block|}
end_function
begin_class
DECL|class|TimerReceiver
class|class
name|TimerReceiver
super|:
specifier|public
name|QObject
block|{
public|public:
DECL|member|gotTimerEvent
name|int
name|gotTimerEvent
decl_stmt|;
DECL|function|TimerReceiver
name|TimerReceiver
parameter_list|()
member_init_list|:
name|QObject
argument_list|()
member_init_list|,
name|gotTimerEvent
argument_list|(
operator|-
literal|1
argument_list|)
block|{ }
DECL|function|timerEvent
name|void
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|event
parameter_list|)
block|{
name|gotTimerEvent
operator|=
name|event
operator|->
name|timerId
argument_list|()
expr_stmt|;
block|}
block|}
class|;
end_class
begin_function
DECL|function|processEventsExcludeTimers
name|void
name|tst_QEventLoop
operator|::
name|processEventsExcludeTimers
parameter_list|()
block|{
name|TimerReceiver
name|timerReceiver
decl_stmt|;
name|int
name|timerId
init|=
name|timerReceiver
operator|.
name|startTimer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QEventLoop
name|eventLoop
decl_stmt|;
comment|// normal process events will send timers
name|eventLoop
operator|.
name|processEvents
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|timerReceiver
operator|.
name|gotTimerEvent
argument_list|,
name|timerId
argument_list|)
expr_stmt|;
name|timerReceiver
operator|.
name|gotTimerEvent
operator|=
operator|-
literal|1
expr_stmt|;
comment|// normal process events will send timers
name|eventLoop
operator|.
name|processEvents
argument_list|(
name|QEventLoop
operator|::
name|X11ExcludeTimers
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
name|QEXPECT_FAIL
argument_list|(
literal|""
argument_list|,
literal|"X11ExcludeTimers only works on UN*X"
argument_list|,
name|Continue
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QCOMPARE
argument_list|(
name|timerReceiver
operator|.
name|gotTimerEvent
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|timerReceiver
operator|.
name|gotTimerEvent
operator|=
operator|-
literal|1
expr_stmt|;
comment|// resume timer processing
name|eventLoop
operator|.
name|processEvents
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|timerReceiver
operator|.
name|gotTimerEvent
argument_list|,
name|timerId
argument_list|)
expr_stmt|;
name|timerReceiver
operator|.
name|gotTimerEvent
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
end_ifdef
begin_class
DECL|class|DummyActiveObject
class|class
name|DummyActiveObject
super|:
specifier|public
name|CActive
block|{
public|public:
name|DummyActiveObject
parameter_list|(
name|int
name|levels
parameter_list|)
constructor_decl|;
name|~
name|DummyActiveObject
parameter_list|()
destructor_decl|;
name|void
name|Start
parameter_list|()
function_decl|;
protected|protected:
name|void
name|DoCancel
parameter_list|()
function_decl|;
name|void
name|RunL
parameter_list|()
function_decl|;
public|public:
DECL|member|succeeded
name|bool
name|succeeded
decl_stmt|;
private|private:
DECL|member|m_rTimer
name|RTimer
name|m_rTimer
decl_stmt|;
DECL|member|remainingLevels
name|int
name|remainingLevels
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|ActiveSchedulerLoop
class|class
name|ActiveSchedulerLoop
super|:
specifier|public
name|QObject
block|{
public|public:
DECL|function|ActiveSchedulerLoop
name|ActiveSchedulerLoop
parameter_list|(
name|int
name|levels
parameter_list|)
member_init_list|:
name|succeeded
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|timerId
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|remainingLevels
argument_list|(
name|levels
argument_list|)
block|{}
DECL|function|~ActiveSchedulerLoop
name|~
name|ActiveSchedulerLoop
parameter_list|()
block|{}
name|void
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|e
parameter_list|)
function_decl|;
public|public:
DECL|member|succeeded
name|bool
name|succeeded
decl_stmt|;
DECL|member|timerId
name|int
name|timerId
decl_stmt|;
DECL|member|remainingLevels
name|int
name|remainingLevels
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|DummyActiveObject
name|DummyActiveObject
operator|::
name|DummyActiveObject
parameter_list|(
name|int
name|levels
parameter_list|)
member_init_list|:
name|CActive
argument_list|(
name|CActive
operator|::
name|EPriorityStandard
argument_list|)
member_init_list|,
name|succeeded
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|remainingLevels
argument_list|(
name|levels
argument_list|)
block|{
name|m_rTimer
operator|.
name|CreateLocal
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~DummyActiveObject
name|DummyActiveObject
operator|::
name|~
name|DummyActiveObject
parameter_list|()
block|{
name|Cancel
argument_list|()
expr_stmt|;
name|m_rTimer
operator|.
name|Close
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|DoCancel
name|void
name|DummyActiveObject
operator|::
name|DoCancel
parameter_list|()
block|{
name|m_rTimer
operator|.
name|Cancel
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|RunL
name|void
name|DummyActiveObject
operator|::
name|RunL
parameter_list|()
block|{
if|if
condition|(
name|remainingLevels
operator|-
literal|1
operator|<=
literal|0
condition|)
block|{
name|ActiveSchedulerLoop
name|loop
argument_list|(
name|remainingLevels
operator|-
literal|1
argument_list|)
decl_stmt|;
name|loop
operator|.
name|timerId
operator|=
name|loop
operator|.
name|startTimer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QCoreApplication
operator|::
name|processEvents
argument_list|()
expr_stmt|;
name|succeeded
operator|=
name|loop
operator|.
name|succeeded
expr_stmt|;
block|}
else|else
block|{
name|succeeded
operator|=
literal|true
expr_stmt|;
block|}
name|CActiveScheduler
operator|::
name|Stop
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Start
name|void
name|DummyActiveObject
operator|::
name|Start
parameter_list|()
block|{
name|m_rTimer
operator|.
name|After
argument_list|(
name|iStatus
argument_list|,
literal|100000
argument_list|)
expr_stmt|;
comment|// 100 ms
name|SetActive
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|timerEvent
name|void
name|ActiveSchedulerLoop
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|DummyActiveObject
modifier|*
name|dummy
init|=
operator|new
operator|(
name|ELeave
operator|)
name|DummyActiveObject
argument_list|(
name|remainingLevels
argument_list|)
decl_stmt|;
name|CActiveScheduler
operator|::
name|Add
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|dummy
operator|->
name|Start
argument_list|()
expr_stmt|;
name|CActiveScheduler
operator|::
name|Start
argument_list|()
expr_stmt|;
name|succeeded
operator|=
name|dummy
operator|->
name|succeeded
expr_stmt|;
operator|delete
name|dummy
expr_stmt|;
name|killTimer
argument_list|(
name|timerId
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// We cannot trap panics when the test case fails, so run it in a different thread instead.
end_comment
begin_class
DECL|class|ActiveSchedulerThread
class|class
name|ActiveSchedulerThread
super|:
specifier|public
name|QThread
block|{
public|public:
name|ActiveSchedulerThread
parameter_list|(
name|QEventLoop
operator|::
name|ProcessEventsFlag
name|flags
parameter_list|)
constructor_decl|;
name|~
name|ActiveSchedulerThread
parameter_list|()
destructor_decl|;
protected|protected:
name|void
name|run
parameter_list|()
function_decl|;
public|public:
DECL|member|succeeded
specifier|volatile
name|bool
name|succeeded
decl_stmt|;
private|private:
DECL|member|m_flags
name|QEventLoop
operator|::
name|ProcessEventsFlag
name|m_flags
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|ActiveSchedulerThread
name|ActiveSchedulerThread
operator|::
name|ActiveSchedulerThread
parameter_list|(
name|QEventLoop
operator|::
name|ProcessEventsFlag
name|flags
parameter_list|)
member_init_list|:
name|succeeded
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_flags
argument_list|(
name|flags
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~ActiveSchedulerThread
name|ActiveSchedulerThread
operator|::
name|~
name|ActiveSchedulerThread
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|run
name|void
name|ActiveSchedulerThread
operator|::
name|run
parameter_list|()
block|{
name|ActiveSchedulerLoop
name|loop
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|loop
operator|.
name|timerId
operator|=
name|loop
operator|.
name|startTimer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// It may panic in here if the active scheduler and the Qt loop don't go together.
name|QCoreApplication
operator|::
name|processEvents
argument_list|(
name|m_flags
argument_list|)
expr_stmt|;
name|succeeded
operator|=
name|loop
operator|.
name|succeeded
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// ifdef Q_OS_SYMBIAN
end_comment
begin_function
DECL|function|symbianNestedActiveSchedulerLoop_data
name|void
name|tst_QEventLoop
operator|::
name|symbianNestedActiveSchedulerLoop_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"processEventFlags"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"AllEvents"
argument_list|)
operator|<<
operator|(
name|int
operator|)
name|QEventLoop
operator|::
name|AllEvents
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"WaitForMoreEvents"
argument_list|)
operator|<<
operator|(
name|int
operator|)
name|QEventLoop
operator|::
name|WaitForMoreEvents
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   Before you start fiddling with this test, you should have a good understanding of how   Symbian active objects work. What the test does is to try to screw up the semaphore count   in the active scheduler to cause stray signals, by running the Qt event loop and the   active scheduler inside each other. Naturally, its attempts to do this should be futile! */
end_comment
begin_function
DECL|function|symbianNestedActiveSchedulerLoop
name|void
name|tst_QEventLoop
operator|::
name|symbianNestedActiveSchedulerLoop
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_OS_SYMBIAN
name|QSKIP
argument_list|(
literal|"This is a Symbian only test."
argument_list|,
name|SkipAll
argument_list|)
expr_stmt|;
else|#
directive|else
name|QFETCH
argument_list|(
name|int
argument_list|,
name|processEventFlags
argument_list|)
expr_stmt|;
name|ActiveSchedulerThread
name|thread
argument_list|(
operator|(
name|QEventLoop
operator|::
name|ProcessEventsFlag
operator|)
name|processEventFlags
argument_list|)
decl_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
name|thread
operator|.
name|wait
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|thread
operator|.
name|succeeded
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_macro
name|QTEST_MAIN
argument_list|(
argument|tst_QEventLoop
argument_list|)
end_macro
begin_include
include|#
directive|include
file|"tst_qeventloop.moc"
end_include
end_unit
