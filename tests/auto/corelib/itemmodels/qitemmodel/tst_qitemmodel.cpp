begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the test suite of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtTest/QtTest>
end_include
begin_include
include|#
directive|include
file|<QtCore/QCoreApplication>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"modelstotest.cpp"
end_include
begin_include
include|#
directive|include
file|<QMetaType>
end_include
begin_comment
comment|/*!     See modelstotest.cpp for instructions on how to have your model tested with these tests.      Each test such as rowCount have a _data() function which populate the QTest data with     the tests specified by modelstotest.cpp and any extra data needed for that particular test.      setupWithNoTestData() fills the QTest data with just the tests and is used by most tests.  */
end_comment
begin_class
DECL|class|tst_QItemModel
class|class
name|tst_QItemModel
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public
name|slots
public|:
name|void
name|init
parameter_list|()
function_decl|;
name|void
name|cleanup
parameter_list|()
function_decl|;
private|private
name|slots
private|:
name|void
name|nonDestructiveBasicTest_data
parameter_list|()
function_decl|;
name|void
name|nonDestructiveBasicTest
parameter_list|()
function_decl|;
name|void
name|rowCount_data
parameter_list|()
function_decl|;
name|void
name|rowCount
parameter_list|()
function_decl|;
name|void
name|columnCount_data
parameter_list|()
function_decl|;
name|void
name|columnCount
parameter_list|()
function_decl|;
name|void
name|hasIndex_data
parameter_list|()
function_decl|;
name|void
name|hasIndex
parameter_list|()
function_decl|;
name|void
name|index_data
parameter_list|()
function_decl|;
name|void
name|index
parameter_list|()
function_decl|;
name|void
name|parent_data
parameter_list|()
function_decl|;
name|void
name|parent
parameter_list|()
function_decl|;
name|void
name|data_data
parameter_list|()
function_decl|;
name|void
name|data
parameter_list|()
function_decl|;
name|void
name|setData_data
parameter_list|()
function_decl|;
name|void
name|setData
parameter_list|()
function_decl|;
name|void
name|setHeaderData_data
parameter_list|()
function_decl|;
name|void
name|setHeaderData
parameter_list|()
function_decl|;
name|void
name|remove_data
parameter_list|()
function_decl|;
name|void
name|remove
parameter_list|()
function_decl|;
name|void
name|insert_data
parameter_list|()
function_decl|;
name|void
name|insert
parameter_list|()
function_decl|;
name|void
name|sort_data
parameter_list|()
function_decl|;
name|void
name|sort
parameter_list|()
function_decl|;
protected|protected
name|slots
protected|:
name|void
name|slot_rowsAboutToRemove
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
function_decl|;
name|void
name|slot_rowsRemoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
function_decl|;
name|void
name|slot_columnsAboutToRemove
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
function_decl|;
name|void
name|slot_columnsRemoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
function_decl|;
name|void
name|slot_rowsAboutToInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
function_decl|;
name|void
name|slot_rowsInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
function_decl|;
name|void
name|slot_columnsAboutToInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
function_decl|;
name|void
name|slot_columnsInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
function_decl|;
private|private:
name|void
name|setupWithNoTestData
parameter_list|()
function_decl|;
DECL|member|currentModel
name|QAbstractItemModel
modifier|*
name|currentModel
decl_stmt|;
DECL|member|testModels
name|ModelsToTest
modifier|*
name|testModels
decl_stmt|;
comment|// used by remove()
DECL|member|parentOfRemoved
name|QPersistentModelIndex
name|parentOfRemoved
decl_stmt|;
DECL|member|afterAboutToRemoveRowCount
name|int
name|afterAboutToRemoveRowCount
decl_stmt|;
DECL|member|afterRemoveRowCount
name|int
name|afterRemoveRowCount
decl_stmt|;
DECL|member|afterAboutToRemoveColumnCount
name|int
name|afterAboutToRemoveColumnCount
decl_stmt|;
DECL|member|afterRemoveColumnCount
name|int
name|afterRemoveColumnCount
decl_stmt|;
comment|// remove() recursive
DECL|member|removeRecursively
name|bool
name|removeRecursively
decl_stmt|;
comment|// used by insert()
DECL|member|parentOfInserted
name|QPersistentModelIndex
name|parentOfInserted
decl_stmt|;
DECL|member|afterAboutToInsertRowCount
name|int
name|afterAboutToInsertRowCount
decl_stmt|;
DECL|member|afterInsertRowCount
name|int
name|afterInsertRowCount
decl_stmt|;
DECL|member|afterAboutToInsertColumnCount
name|int
name|afterAboutToInsertColumnCount
decl_stmt|;
DECL|member|afterInsertColumnCount
name|int
name|afterInsertColumnCount
decl_stmt|;
comment|// insert() recursive
DECL|member|insertRecursively
name|bool
name|insertRecursively
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|init
name|void
name|tst_QItemModel
operator|::
name|init
parameter_list|()
block|{
name|testModels
operator|=
operator|new
name|ModelsToTest
argument_list|()
expr_stmt|;
name|removeRecursively
operator|=
literal|false
expr_stmt|;
name|insertRecursively
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cleanup
name|void
name|tst_QItemModel
operator|::
name|cleanup
parameter_list|()
block|{
name|testModels
operator|->
name|cleanupTestArea
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
operator|delete
name|testModels
expr_stmt|;
operator|delete
name|currentModel
expr_stmt|;
name|currentModel
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setupWithNoTestData
name|void
name|tst_QItemModel
operator|::
name|setupWithNoTestData
parameter_list|()
block|{
name|ModelsToTest
name|modelsToTest
decl_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"modelType"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"readOnly"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"isEmpty"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|modelsToTest
operator|.
name|tests
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ModelsToTest
operator|::
name|test
name|t
init|=
name|modelsToTest
operator|.
name|tests
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|bool
name|readOnly
init|=
operator|(
name|t
operator|.
name|read
operator|==
name|ModelsToTest
operator|::
name|ReadOnly
operator|)
decl_stmt|;
name|bool
name|isEmpty
init|=
operator|(
name|t
operator|.
name|contains
operator|==
name|ModelsToTest
operator|::
name|Empty
operator|)
decl_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
name|t
operator|.
name|modelType
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
operator|<<
name|t
operator|.
name|modelType
operator|<<
name|readOnly
operator|<<
name|isEmpty
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|nonDestructiveBasicTest_data
name|void
name|tst_QItemModel
operator|::
name|nonDestructiveBasicTest_data
parameter_list|()
block|{
name|setupWithNoTestData
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     nonDestructiveBasicTest tries to call a number of the basic functions (not all)     to make sure the model doesn't segfault, testing the functions that makes sense.  */
end_comment
begin_function
DECL|function|nonDestructiveBasicTest
name|void
name|tst_QItemModel
operator|::
name|nonDestructiveBasicTest
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|modelType
argument_list|)
expr_stmt|;
name|currentModel
operator|=
name|testModels
operator|->
name|createModel
argument_list|(
name|modelType
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|buddy
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|canFetchMore
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
operator|->
name|columnCount
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|data
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
argument_list|,
name|QVariant
argument_list|()
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|fetchMore
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Qt
operator|::
name|ItemFlags
name|flags
init|=
name|currentModel
operator|->
name|flags
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|flags
operator|==
name|Qt
operator|::
name|ItemIsDropEnabled
operator|||
name|flags
operator|==
literal|0
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|hasIndex
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|headerData
argument_list|(
literal|0
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|,
name|QModelIndex
argument_list|()
expr_stmt|;
name|currentModel
operator|->
name|itemData
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
name|QVariant
name|cache
decl_stmt|;
name|currentModel
operator|->
name|match
argument_list|(
name|QModelIndex
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|mimeTypes
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|parent
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
operator|->
name|rowCount
argument_list|()
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|QVariant
name|variant
decl_stmt|;
name|currentModel
operator|->
name|setData
argument_list|(
name|QModelIndex
argument_list|()
argument_list|,
name|variant
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|setHeaderData
argument_list|(
operator|-
literal|1
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|,
name|QVariant
argument_list|()
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|setHeaderData
argument_list|(
literal|0
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|,
name|QVariant
argument_list|()
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|setHeaderData
argument_list|(
name|currentModel
operator|->
name|columnCount
argument_list|()
operator|+
literal|100
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|,
name|QVariant
argument_list|()
argument_list|)
expr_stmt|;
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
name|roles
decl_stmt|;
name|currentModel
operator|->
name|setItemData
argument_list|(
name|QModelIndex
argument_list|()
argument_list|,
name|roles
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|sibling
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|span
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|supportedDropActions
argument_list|()
expr_stmt|;
name|currentModel
operator|->
name|revert
argument_list|()
expr_stmt|;
name|currentModel
operator|->
name|submit
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|rowCount_data
name|void
name|tst_QItemModel
operator|::
name|rowCount_data
parameter_list|()
block|{
name|setupWithNoTestData
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Tests model's implimentation of QAbstractItemModel::rowCount() and hasChildren()  */
end_comment
begin_function
DECL|function|rowCount
name|void
name|tst_QItemModel
operator|::
name|rowCount
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|modelType
argument_list|)
expr_stmt|;
name|currentModel
operator|=
name|testModels
operator|->
name|createModel
argument_list|(
name|modelType
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|isEmpty
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
condition|)
block|{
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|rowCount
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QVERIFY
argument_list|(
name|currentModel
operator|->
name|rowCount
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// check top row
name|QModelIndex
name|topIndex
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|rows
init|=
name|currentModel
operator|->
name|rowCount
argument_list|(
name|topIndex
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|rows
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rows
operator|>
literal|0
condition|)
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|topIndex
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
else|else
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|topIndex
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|QModelIndex
name|secondLevelIndex
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|topIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|secondLevelIndex
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// not the top level
comment|// check a row count where parent is valid
name|rows
operator|=
name|currentModel
operator|->
name|rowCount
argument_list|(
name|secondLevelIndex
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|rows
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rows
operator|>
literal|0
condition|)
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|secondLevelIndex
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
else|else
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|secondLevelIndex
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// rowCount is tested more extensivly more later in checkChildren(),
comment|// but this catches the big mistakes
block|}
end_function
begin_function
DECL|function|columnCount_data
name|void
name|tst_QItemModel
operator|::
name|columnCount_data
parameter_list|()
block|{
name|setupWithNoTestData
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Tests model's implimentation of QAbstractItemModel::columnCount() and hasChildren()  */
end_comment
begin_function
DECL|function|columnCount
name|void
name|tst_QItemModel
operator|::
name|columnCount
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|modelType
argument_list|)
expr_stmt|;
name|currentModel
operator|=
name|testModels
operator|->
name|createModel
argument_list|(
name|modelType
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|isEmpty
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
condition|)
block|{
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QVERIFY
argument_list|(
name|currentModel
operator|->
name|columnCount
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// check top row
name|QModelIndex
name|topIndex
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|columns
init|=
name|currentModel
operator|->
name|columnCount
argument_list|(
name|topIndex
argument_list|)
decl_stmt|;
comment|// check a row count where parent is valid
name|columns
operator|=
name|currentModel
operator|->
name|columnCount
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|topIndex
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|columns
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// columnCount is tested more extensivly more later in checkChildren(),
comment|// but this catches the big mistakes
block|}
end_function
begin_function
DECL|function|hasIndex_data
name|void
name|tst_QItemModel
operator|::
name|hasIndex_data
parameter_list|()
block|{
name|setupWithNoTestData
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Tests model's implimentation of QAbstractItemModel::hasIndex()  */
end_comment
begin_function
DECL|function|hasIndex
name|void
name|tst_QItemModel
operator|::
name|hasIndex
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|modelType
argument_list|)
expr_stmt|;
name|currentModel
operator|=
name|testModels
operator|->
name|createModel
argument_list|(
name|modelType
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
comment|// Make sure that invalid values returns an invalid index
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasIndex
argument_list|(
operator|-
literal|2
argument_list|,
operator|-
literal|2
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasIndex
argument_list|(
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasIndex
argument_list|(
literal|0
argument_list|,
operator|-
literal|2
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|rows
init|=
name|currentModel
operator|->
name|rowCount
argument_list|()
decl_stmt|;
name|int
name|columns
init|=
name|currentModel
operator|->
name|columnCount
argument_list|()
decl_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasIndex
argument_list|(
name|rows
argument_list|,
name|columns
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasIndex
argument_list|(
name|rows
operator|+
literal|1
argument_list|,
name|columns
operator|+
literal|1
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|isEmpty
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
condition|)
return|return;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasIndex
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// hasIndex is tested more extensivly more later in checkChildren(),
comment|// but this catches the big mistakes
block|}
end_function
begin_function
DECL|function|index_data
name|void
name|tst_QItemModel
operator|::
name|index_data
parameter_list|()
block|{
name|setupWithNoTestData
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Tests model's implimentation of QAbstractItemModel::index()  */
end_comment
begin_function
DECL|function|index
name|void
name|tst_QItemModel
operator|::
name|index
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|modelType
argument_list|)
expr_stmt|;
name|currentModel
operator|=
name|testModels
operator|->
name|createModel
argument_list|(
name|modelType
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
comment|// Make sure that invalid values returns an invalid index
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
operator|-
literal|2
argument_list|,
operator|-
literal|2
argument_list|)
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
operator|-
literal|2
argument_list|)
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|isEmpty
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
condition|)
return|return;
name|int
name|rows
init|=
name|currentModel
operator|->
name|rowCount
argument_list|()
decl_stmt|;
name|int
name|columns
init|=
name|currentModel
operator|->
name|columnCount
argument_list|()
decl_stmt|;
comment|// Catch off by one errors
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
name|rows
argument_list|,
name|columns
argument_list|)
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|isValid
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Make sure that the same index is always returned
name|QModelIndex
name|a
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QModelIndex
name|b
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|a
operator|==
name|b
argument_list|)
expr_stmt|;
comment|// index is tested more extensivly more later in checkChildren(),
comment|// but this catches the big mistakes
block|}
end_function
begin_function
DECL|function|parent_data
name|void
name|tst_QItemModel
operator|::
name|parent_data
parameter_list|()
block|{
name|setupWithNoTestData
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     A model that returns an index of parent X should also return X when asking     for the parent of the index.      This recursive function does pretty extensive testing on the whole model in an     effort to catch edge cases.      This function assumes that rowCount(), columnCount() and index() work.  If they have     a bug it will point it out, but the above tests should have already found the basic bugs     because it is easier to figure out the problem in those tests then this one.  */
end_comment
begin_function
DECL|function|checkChildren
name|void
name|checkChildren
parameter_list|(
name|QAbstractItemModel
modifier|*
name|currentModel
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|currentDepth
init|=
literal|0
parameter_list|)
block|{
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|readOnly
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentModel
operator|->
name|canFetchMore
argument_list|(
name|parent
argument_list|)
condition|)
name|currentModel
operator|->
name|fetchMore
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|int
name|rows
init|=
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|int
name|columns
init|=
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
decl_stmt|;
specifier|const
name|QModelIndex
name|topLeftChild
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|rows
operator|>
literal|0
argument_list|,
operator|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|// Some reasuring testing against rows(),columns(), and hasChildren()
name|QVERIFY
argument_list|(
name|rows
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|columns
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rows
operator|>
literal|0
operator|||
name|columns
operator|>
literal|0
condition|)
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
else|else
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasIndex
argument_list|(
name|rows
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
operator|++
name|r
control|)
block|{
if|if
condition|(
name|currentModel
operator|->
name|canFetchMore
argument_list|(
name|parent
argument_list|)
condition|)
name|currentModel
operator|->
name|fetchMore
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasIndex
argument_list|(
name|r
argument_list|,
name|columns
operator|+
literal|1
argument_list|,
name|parent
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|columns
condition|;
operator|++
name|c
control|)
block|{
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasIndex
argument_list|(
name|r
argument_list|,
name|c
argument_list|,
name|parent
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QModelIndex
name|index
init|=
name|currentModel
operator|->
name|index
argument_list|(
name|r
argument_list|,
name|c
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|index
operator|.
name|isValid
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readOnly
condition|)
name|currentModel
operator|->
name|setData
argument_list|(
name|index
argument_list|,
literal|"I'm a little tea pot short and stout"
argument_list|)
expr_stmt|;
name|QModelIndex
name|modifiedIndex
init|=
name|currentModel
operator|->
name|index
argument_list|(
name|r
argument_list|,
name|c
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|index
argument_list|,
name|modifiedIndex
argument_list|)
expr_stmt|;
comment|// Make sure we get the same index if we request it twice in a row
name|QModelIndex
name|a
init|=
name|currentModel
operator|->
name|index
argument_list|(
name|r
argument_list|,
name|c
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|QModelIndex
name|b
init|=
name|currentModel
operator|->
name|index
argument_list|(
name|r
argument_list|,
name|c
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|a
operator|==
name|b
argument_list|)
expr_stmt|;
block|{
specifier|const
name|QModelIndex
name|sibling
init|=
name|currentModel
operator|->
name|sibling
argument_list|(
name|r
argument_list|,
name|c
argument_list|,
name|topLeftChild
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|index
operator|==
name|sibling
argument_list|)
expr_stmt|;
block|}
block|{
specifier|const
name|QModelIndex
name|sibling
init|=
name|topLeftChild
operator|.
name|sibling
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|index
operator|==
name|sibling
argument_list|)
expr_stmt|;
block|}
comment|// Some basic checking on the index that is returned
name|QVERIFY
argument_list|(
name|index
operator|.
name|model
argument_list|()
operator|==
name|currentModel
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|data
argument_list|(
name|index
argument_list|,
name|Qt
operator|::
name|DisplayRole
argument_list|)
operator|.
name|isValid
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// If the next test fails here is some somewhat useful debug you play with.
comment|/*             if (currentModel->parent(index) != parent) {                 qDebug()<< r<< c<< currentDepth<< currentModel->data(index).toString()<< currentModel->data(parent).toString();                 qDebug()<< index<< parent<< currentModel->parent(index);                 QTreeView view;                 view.setModel(currentModel);                 view.show();                 QTest::qWait(9000);             }*/
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|parent
argument_list|(
name|index
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
comment|// recursivly go down
if|if
condition|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|index
argument_list|)
operator|&&
name|currentDepth
operator|<
literal|5
condition|)
block|{
name|checkChildren
argument_list|(
name|currentModel
argument_list|,
name|index
argument_list|,
operator|++
name|currentDepth
argument_list|)
expr_stmt|;
comment|// Because this is recursive we will return at the first failure rather then
comment|// reporting it over and over
if|if
condition|(
name|QTest
operator|::
name|currentTestFailed
argument_list|()
condition|)
return|return;
block|}
comment|// make sure that after testing the children that the index pointer doesn't change.
name|QModelIndex
name|newerIndex
init|=
name|currentModel
operator|->
name|index
argument_list|(
name|r
argument_list|,
name|c
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|index
argument_list|,
name|newerIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Tests model's implimentation of QAbstractItemModel::parent()  */
end_comment
begin_function
DECL|function|parent
name|void
name|tst_QItemModel
operator|::
name|parent
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|modelType
argument_list|)
expr_stmt|;
name|currentModel
operator|=
name|testModels
operator|->
name|createModel
argument_list|(
name|modelType
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
comment|// Make sure the model won't crash and will return an invalid QModelIndex
comment|// when asked for the parent of an invalid index.
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|parent
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|isEmpty
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
condition|)
return|return;
comment|// Common error test #1, make sure that a top level index has a parent
comment|// that is a invalid QModelIndex.  You model
name|QModelIndex
name|topIndex
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|parent
argument_list|(
name|topIndex
argument_list|)
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
comment|// Common error test #2, make sure that a second level index has a parent
comment|// that is the top level index.
if|if
condition|(
name|currentModel
operator|->
name|rowCount
argument_list|(
name|topIndex
argument_list|)
operator|>
literal|0
condition|)
block|{
name|QModelIndex
name|childIndex
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|topIndex
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|parent
argument_list|(
name|childIndex
argument_list|)
argument_list|,
name|topIndex
argument_list|)
expr_stmt|;
block|}
comment|// Common error test #3, the second column has the same children
comment|// as the first column in a row.
name|QModelIndex
name|topIndex1
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentModel
operator|->
name|rowCount
argument_list|(
name|topIndex1
argument_list|)
operator|>
literal|0
condition|)
block|{
name|QModelIndex
name|childIndex
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|topIndex
argument_list|)
decl_stmt|;
name|QModelIndex
name|childIndex1
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|topIndex1
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|childIndex
operator|!=
name|childIndex1
argument_list|)
expr_stmt|;
block|}
comment|// Full test, walk 10 levels deap through the model making sure that all
comment|// parents's children correctly specify their parent
name|QModelIndex
name|top
init|=
name|QModelIndex
argument_list|()
decl_stmt|;
name|checkChildren
argument_list|(
name|currentModel
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|data_data
name|void
name|tst_QItemModel
operator|::
name|data_data
parameter_list|()
block|{
name|setupWithNoTestData
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Tests model's implimentation of QAbstractItemModel::data()  */
end_comment
begin_function
DECL|function|data
name|void
name|tst_QItemModel
operator|::
name|data
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|modelType
argument_list|)
expr_stmt|;
name|currentModel
operator|=
name|testModels
operator|->
name|createModel
argument_list|(
name|modelType
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
comment|// Invalid index should return an invalid qvariant
name|QVERIFY
argument_list|(
operator|!
name|currentModel
operator|->
name|data
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|isEmpty
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
condition|)
return|return;
comment|// A valid index should have a valid qvariant data
name|QVERIFY
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
comment|// shouldn't be able to set data on an invalid index
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|setData
argument_list|(
name|QModelIndex
argument_list|()
argument_list|,
literal|"foo"
argument_list|,
name|Qt
operator|::
name|DisplayRole
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// General Purpose roles
name|QVariant
name|variant
init|=
name|currentModel
operator|->
name|data
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Qt
operator|::
name|ToolTipRole
argument_list|)
decl_stmt|;
if|if
condition|(
name|variant
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QVERIFY
argument_list|(
name|variant
operator|.
name|canConvert
argument_list|<
name|QString
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|variant
operator|=
name|currentModel
operator|->
name|data
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Qt
operator|::
name|StatusTipRole
argument_list|)
expr_stmt|;
if|if
condition|(
name|variant
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QVERIFY
argument_list|(
name|variant
operator|.
name|canConvert
argument_list|<
name|QString
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|variant
operator|=
name|currentModel
operator|->
name|data
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Qt
operator|::
name|WhatsThisRole
argument_list|)
expr_stmt|;
if|if
condition|(
name|variant
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QVERIFY
argument_list|(
name|variant
operator|.
name|canConvert
argument_list|<
name|QString
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|variant
operator|=
name|currentModel
operator|->
name|data
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Qt
operator|::
name|SizeHintRole
argument_list|)
expr_stmt|;
if|if
condition|(
name|variant
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QVERIFY
argument_list|(
name|variant
operator|.
name|canConvert
argument_list|<
name|QSize
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Appearance roles
name|QVariant
name|fontVariant
init|=
name|currentModel
operator|->
name|data
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Qt
operator|::
name|FontRole
argument_list|)
decl_stmt|;
if|if
condition|(
name|fontVariant
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QVERIFY
argument_list|(
name|fontVariant
operator|.
name|canConvert
argument_list|<
name|QFont
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QVariant
name|textAlignmentVariant
init|=
name|currentModel
operator|->
name|data
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Qt
operator|::
name|TextAlignmentRole
argument_list|)
decl_stmt|;
if|if
condition|(
name|textAlignmentVariant
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|int
name|alignment
init|=
name|textAlignmentVariant
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|QVERIFY
argument_list|(
name|alignment
operator|==
name|Qt
operator|::
name|AlignLeft
operator|||
name|alignment
operator|==
name|Qt
operator|::
name|AlignRight
operator|||
name|alignment
operator|==
name|Qt
operator|::
name|AlignHCenter
operator|||
name|alignment
operator|==
name|Qt
operator|::
name|AlignJustify
argument_list|)
expr_stmt|;
block|}
name|QVariant
name|colorVariant
init|=
name|currentModel
operator|->
name|data
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Qt
operator|::
name|BackgroundColorRole
argument_list|)
decl_stmt|;
if|if
condition|(
name|colorVariant
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QVERIFY
argument_list|(
name|colorVariant
operator|.
name|canConvert
argument_list|<
name|QColor
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|colorVariant
operator|=
name|currentModel
operator|->
name|data
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Qt
operator|::
name|TextColorRole
argument_list|)
expr_stmt|;
if|if
condition|(
name|colorVariant
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QVERIFY
argument_list|(
name|colorVariant
operator|.
name|canConvert
argument_list|<
name|QColor
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QVariant
name|checkStateVariant
init|=
name|currentModel
operator|->
name|data
argument_list|(
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Qt
operator|::
name|CheckStateRole
argument_list|)
decl_stmt|;
if|if
condition|(
name|checkStateVariant
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|int
name|state
init|=
name|checkStateVariant
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|QVERIFY
argument_list|(
name|state
operator|==
name|Qt
operator|::
name|Unchecked
operator|||
name|state
operator|==
name|Qt
operator|::
name|PartiallyChecked
operator|||
name|state
operator|==
name|Qt
operator|::
name|Checked
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setData_data
name|void
name|tst_QItemModel
operator|::
name|setData_data
parameter_list|()
block|{
name|setupWithNoTestData
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Tests model's implimentation of QAbstractItemModel::setData()  */
end_comment
begin_function
DECL|function|setData
name|void
name|tst_QItemModel
operator|::
name|setData
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|modelType
argument_list|)
expr_stmt|;
name|currentModel
operator|=
name|testModels
operator|->
name|createModel
argument_list|(
name|modelType
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
name|QSignalSpy
name|spy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|dataChanged
argument_list|(
name|QModelIndex
argument_list|,
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|spy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|setData
argument_list|(
name|QModelIndex
argument_list|()
argument_list|,
name|QVariant
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|spy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|isEmpty
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
condition|)
return|return;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|readOnly
argument_list|)
expr_stmt|;
if|if
condition|(
name|readOnly
condition|)
return|return;
comment|// Populate the test area so we can chage stuff.  See: cleanup()
name|QModelIndex
name|topIndex
init|=
name|testModels
operator|->
name|populateTestArea
argument_list|(
name|currentModel
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|topIndex
argument_list|)
argument_list|)
expr_stmt|;
name|QModelIndex
name|index
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|topIndex
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|index
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|spy
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QString
name|text
init|=
literal|"Index private pointers should always be the same"
decl_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|setData
argument_list|(
name|index
argument_list|,
name|text
argument_list|,
name|Qt
operator|::
name|EditRole
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|index
operator|.
name|data
argument_list|(
name|Qt
operator|::
name|EditRole
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|text
argument_list|)
expr_stmt|;
comment|// Changing the text shouldn't change the layout, parent, pointer etc.
name|QModelIndex
name|changedIndex
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|topIndex
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|changedIndex
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|spy
operator|.
name|count
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setHeaderData_data
name|void
name|tst_QItemModel
operator|::
name|setHeaderData_data
parameter_list|()
block|{
name|setupWithNoTestData
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Tests model's implimentation of QAbstractItemModel::setHeaderData()  */
end_comment
begin_function
DECL|function|setHeaderData
name|void
name|tst_QItemModel
operator|::
name|setHeaderData
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|modelType
argument_list|)
expr_stmt|;
name|currentModel
operator|=
name|testModels
operator|->
name|createModel
argument_list|(
name|modelType
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|setHeaderData
argument_list|(
operator|-
literal|1
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|,
name|QVariant
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|setHeaderData
argument_list|(
operator|-
literal|1
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|,
name|QVariant
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|isEmpty
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
condition|)
return|return;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|readOnly
argument_list|)
expr_stmt|;
if|if
condition|(
name|readOnly
condition|)
return|return;
comment|// Populate the test area so we can change stuff.  See: cleanup()
name|QModelIndex
name|topIndex
init|=
name|testModels
operator|->
name|populateTestArea
argument_list|(
name|currentModel
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|topIndex
argument_list|)
argument_list|)
expr_stmt|;
name|QModelIndex
name|index
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|topIndex
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|index
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|qRegisterMetaType
argument_list|<
name|Qt
operator|::
name|Orientation
argument_list|>
argument_list|(
literal|"Qt::Orientation"
argument_list|)
expr_stmt|;
name|QSignalSpy
name|spy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|headerDataChanged
argument_list|(
name|Qt
operator|::
name|Orientation
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|spy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|text
init|=
literal|"Index private pointers should always be the same"
decl_stmt|;
name|int
name|signalCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|currentModel
operator|->
name|setHeaderData
argument_list|(
name|i
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|,
name|text
argument_list|)
condition|)
block|{
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|headerData
argument_list|(
name|i
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|text
argument_list|)
expr_stmt|;
operator|++
name|signalCount
expr_stmt|;
block|}
if|if
condition|(
name|currentModel
operator|->
name|setHeaderData
argument_list|(
name|i
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|,
name|text
argument_list|)
condition|)
block|{
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|headerData
argument_list|(
name|i
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|text
argument_list|)
expr_stmt|;
operator|++
name|signalCount
expr_stmt|;
block|}
block|}
name|QCOMPARE
argument_list|(
name|spy
operator|.
name|count
argument_list|()
argument_list|,
name|signalCount
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sort_data
name|void
name|tst_QItemModel
operator|::
name|sort_data
parameter_list|()
block|{
name|setupWithNoTestData
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Tests model's implimentation of QAbstractItemModel::sort()  */
end_comment
begin_function
DECL|function|sort
name|void
name|tst_QItemModel
operator|::
name|sort
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|modelType
argument_list|)
expr_stmt|;
name|currentModel
operator|=
name|testModels
operator|->
name|createModel
argument_list|(
name|modelType
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|isEmpty
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
condition|)
return|return;
comment|// Populate the test area so we can chage stuff.  See: cleanup()
name|QPersistentModelIndex
name|topIndex
init|=
name|testModels
operator|->
name|populateTestArea
argument_list|(
name|currentModel
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|topIndex
argument_list|)
argument_list|)
expr_stmt|;
name|QModelIndex
name|index
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|topIndex
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|index
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QSignalSpy
name|spy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|layoutChanged
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|spy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
operator|-
literal|1
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
block|{
name|currentModel
operator|->
name|sort
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|topIndex
argument_list|)
condition|)
block|{
name|QVERIFY
argument_list|(
name|spy
operator|.
name|count
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|index
operator|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|topIndex
argument_list|)
expr_stmt|;
name|spy
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
name|currentModel
operator|->
name|sort
argument_list|(
literal|99999
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Tests model's implimentation of QAbstractItemModel::removeRow() and QAbstractItemModel::removeColumn()  */
end_comment
begin_define
DECL|macro|START
define|#
directive|define
name|START
value|0
end_define
begin_define
DECL|macro|MIDDLE
define|#
directive|define
name|MIDDLE
value|6
end_define
begin_define
DECL|macro|END
define|#
directive|define
name|END
value|-1
end_define
begin_define
DECL|macro|MANY
define|#
directive|define
name|MANY
value|9
end_define
begin_define
DECL|macro|ALL
define|#
directive|define
name|ALL
value|-1
end_define
begin_define
DECL|macro|NOSIGNALS
define|#
directive|define
name|NOSIGNALS
value|0
end_define
begin_define
DECL|macro|DEFAULTCOUNT
define|#
directive|define
name|DEFAULTCOUNT
value|1
end_define
begin_define
DECL|macro|DNS
define|#
directive|define
name|DNS
value|1
end_define
begin_comment
DECL|macro|DNS
comment|// DefaultNumberOfSignals
end_comment
begin_define
DECL|macro|RECURSIVE
define|#
directive|define
name|RECURSIVE
value|true
end_define
begin_define
DECL|macro|SUCCESS
define|#
directive|define
name|SUCCESS
value|true
end_define
begin_define
DECL|macro|FAIL
define|#
directive|define
name|FAIL
value|false
end_define
begin_function
DECL|function|remove_data
name|void
name|tst_QItemModel
operator|::
name|remove_data
parameter_list|()
block|{
name|ModelsToTest
name|modelsToTest
decl_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"modelType"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"readOnly"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"isEmpty"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"start"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"count"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"numberOfRowsAboutToBeRemovedSignals"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"numberOfColumnsAboutToBeRemovedSignals"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"numberOfRowsRemovedSignals"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"numberOfColumnsRemovedSignals"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"recursive"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"recursiveRow"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"recursiveCount"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"shouldSucceed"
argument_list|)
expr_stmt|;
DECL|macro|makeTestRow
define|#
directive|define
name|makeTestRow
parameter_list|(
name|testName
parameter_list|,
name|start
parameter_list|,
name|count
parameter_list|,
name|sar
parameter_list|,
name|srr
parameter_list|,
name|sac
parameter_list|,
name|src
parameter_list|,
name|r
parameter_list|,
name|rr
parameter_list|,
name|rc
parameter_list|,
name|s
parameter_list|)
define|\
value|QTest::newRow((t.modelType + testName).toLatin1().data())<< t.modelType<< readOnly<< isEmpty<< \         start<< count<< \         sar<< srr<< sac<< src<< \         r<< rr<< rc<< \         s;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|modelsToTest
operator|.
name|tests
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ModelsToTest
operator|::
name|test
name|t
init|=
name|modelsToTest
operator|.
name|tests
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QString
name|name
init|=
name|t
operator|.
name|modelType
decl_stmt|;
name|bool
name|readOnly
init|=
operator|(
name|t
operator|.
name|read
operator|==
name|ModelsToTest
operator|::
name|ReadOnly
operator|)
decl_stmt|;
name|bool
name|isEmpty
init|=
operator|(
name|t
operator|.
name|contains
operator|==
name|ModelsToTest
operator|::
name|Empty
operator|)
decl_stmt|;
comment|// half these
name|makeTestRow
argument_list|(
literal|":one at the start"
argument_list|,
name|START
argument_list|,
name|DEFAULTCOUNT
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":one at the middle"
argument_list|,
name|MIDDLE
argument_list|,
name|DEFAULTCOUNT
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":one at the end"
argument_list|,
name|END
argument_list|,
name|DEFAULTCOUNT
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":many at the start"
argument_list|,
name|START
argument_list|,
name|MANY
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":many at the middle"
argument_list|,
name|MIDDLE
argument_list|,
name|MANY
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":many at the end"
argument_list|,
name|END
argument_list|,
name|MANY
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":remove all"
argument_list|,
name|START
argument_list|,
name|ALL
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":none at the start"
argument_list|,
name|START
argument_list|,
literal|0
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":none at the middle"
argument_list|,
name|MIDDLE
argument_list|,
literal|0
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":none at the end"
argument_list|,
name|END
argument_list|,
literal|0
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":invalid start, valid count 1"
argument_list|,
operator|-
literal|99
argument_list|,
literal|0
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":invalid start, valid count 2"
argument_list|,
literal|9999
argument_list|,
literal|0
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":invalid start, valid count 3"
argument_list|,
operator|-
literal|99
argument_list|,
literal|1
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":invalid start, valid count 4"
argument_list|,
literal|9999
argument_list|,
literal|1
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":invalid start, valid count 5"
argument_list|,
operator|-
literal|99
argument_list|,
name|MANY
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":invalid start, valid count 6"
argument_list|,
literal|9999
argument_list|,
name|MANY
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":valid start, invalid count 1"
argument_list|,
name|START
argument_list|,
operator|-
literal|2
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":valid start, invalid count 2"
argument_list|,
name|MIDDLE
argument_list|,
operator|-
literal|2
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":valid start, invalid count 3"
argument_list|,
name|END
argument_list|,
operator|-
literal|2
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":valid start, invalid count 4"
argument_list|,
name|START
argument_list|,
literal|9999
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":valid start, invalid count 5"
argument_list|,
name|MIDDLE
argument_list|,
literal|9999
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":valid start, invalid count 6"
argument_list|,
name|END
argument_list|,
literal|9999
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
comment|// Recursive remove's might assert, haven't decided yet...
comment|//makeTestRow(":one at the start recursivly",  START,  DEFAULTCOUNT, 2, DNS, 2, DNS, RECURSIVE, START, DEFAULTCOUNT, FAIL);
comment|//makeTestRow(":one at the middle recursivly", MIDDLE, DEFAULTCOUNT, 2, DNS, 2, DNS, RECURSIVE, START, DEFAULTCOUNT, SUCCESS);
comment|//makeTestRow(":one at the end recursivly",    END,    DEFAULTCOUNT, 2, DNS, 2, DNS, RECURSIVE, START, DEFAULTCOUNT, SUCCESS);
block|}
block|}
end_function
begin_function
DECL|function|remove
name|void
name|tst_QItemModel
operator|::
name|remove
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|modelType
argument_list|)
expr_stmt|;
name|currentModel
operator|=
name|testModels
operator|->
name|createModel
argument_list|(
name|modelType
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|readOnly
argument_list|)
expr_stmt|;
if|if
condition|(
name|readOnly
condition|)
return|return;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
name|removeRecursively
operator|=
name|recursive
expr_stmt|;
comment|/*!     Removes count number of rows starting at start     if count is -1 it removes all rows     if start is -1 then it starts at the last row - count  */
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|shouldSucceed
argument_list|)
expr_stmt|;
comment|// Populate the test area so we can remove something.  See: cleanup()
comment|// parentOfRemoved is stored so that the slots can make sure parentOfRemoved is the index that is emitted.
name|parentOfRemoved
operator|=
name|testModels
operator|->
name|populateTestArea
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
operator|-
literal|1
condition|)
name|count
operator|=
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfRemoved
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
operator|-
literal|1
condition|)
name|start
operator|=
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfRemoved
argument_list|)
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfRemoved
argument_list|)
operator|==
literal|0
operator|||
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parentOfRemoved
argument_list|)
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"model test area doesn't have any rows or columns, can't fully test remove(). Skipping"
expr_stmt|;
return|return;
block|}
comment|// When a row or column is removed there should be two signals.
comment|// Watch to make sure they are emitted and get the row/column count when they do get emitted by connecting them to a slot
name|QSignalSpy
name|columnsAboutToBeRemovedSpy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|columnsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QSignalSpy
name|rowsAboutToBeRemovedSpy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|rowsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QSignalSpy
name|columnsRemovedSpy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|columnsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QSignalSpy
name|rowsRemovedSpy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|rowsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QSignalSpy
name|modelResetSpy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|modelReset
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QSignalSpy
name|modelLayoutChangedSpy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|layoutChanged
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|columnsAboutToBeRemovedSpy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|rowsAboutToBeRemovedSpy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|columnsRemovedSpy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|rowsRemovedSpy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|modelResetSpy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|modelLayoutChangedSpy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|numberOfRowsAboutToBeRemovedSignals
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|numberOfColumnsAboutToBeRemovedSignals
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|numberOfRowsRemovedSignals
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|numberOfColumnsRemovedSignals
argument_list|)
expr_stmt|;
comment|//
comment|// test removeRow()
comment|//
name|connect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|rowsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_rowsAboutToRemove
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|rowsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_rowsRemoved
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|beforeRemoveRowCount
init|=
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfRemoved
argument_list|)
decl_stmt|;
name|QPersistentModelIndex
name|dyingIndex
init|=
name|currentModel
operator|->
name|index
argument_list|(
name|start
operator|+
name|count
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|parentOfRemoved
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|removeRows
argument_list|(
name|start
argument_list|,
name|count
argument_list|,
name|parentOfRemoved
argument_list|)
argument_list|,
name|shouldSucceed
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|submit
argument_list|()
expr_stmt|;
if|if
condition|(
name|shouldSucceed
operator|&&
name|dyingIndex
operator|.
name|isValid
argument_list|()
condition|)
name|QCOMPARE
argument_list|(
name|dyingIndex
operator|.
name|row
argument_list|()
argument_list|,
name|start
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowsAboutToBeRemovedSpy
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|QList
argument_list|<
name|QVariant
argument_list|>
name|arguments
init|=
name|rowsAboutToBeRemovedSpy
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QModelIndex
name|parent
init|=
operator|(
name|qvariant_cast
argument_list|<
name|QModelIndex
argument_list|>
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|first
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|int
name|last
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|QCOMPARE
argument_list|(
name|first
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|last
argument_list|,
name|start
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|parentOfRemoved
operator|==
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rowsRemovedSpy
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|QList
argument_list|<
name|QVariant
argument_list|>
name|arguments
init|=
name|rowsRemovedSpy
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QModelIndex
name|parent
init|=
operator|(
name|qvariant_cast
argument_list|<
name|QModelIndex
argument_list|>
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|first
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|int
name|last
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|QCOMPARE
argument_list|(
name|first
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|last
argument_list|,
name|start
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|parentOfRemoved
operator|==
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// Only the row signals should have been emitted
if|if
condition|(
name|modelResetSpy
operator|.
name|count
argument_list|()
operator|>=
literal|1
operator|||
name|modelLayoutChangedSpy
operator|.
name|count
argument_list|()
operator|>=
literal|1
condition|)
block|{
name|QCOMPARE
argument_list|(
name|columnsAboutToBeRemovedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|rowsAboutToBeRemovedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|columnsRemovedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|rowsRemovedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QCOMPARE
argument_list|(
name|columnsAboutToBeRemovedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|rowsAboutToBeRemovedSpy
operator|.
name|count
argument_list|()
argument_list|,
name|numberOfRowsAboutToBeRemovedSignals
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|columnsRemovedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|rowsRemovedSpy
operator|.
name|count
argument_list|()
argument_list|,
name|numberOfRowsRemovedSignals
argument_list|)
expr_stmt|;
block|}
comment|// The row count should only change *after* rowsAboutToBeRemoved has been emitted
if|if
condition|(
name|shouldSucceed
condition|)
block|{
if|if
condition|(
name|modelResetSpy
operator|.
name|count
argument_list|()
operator|==
literal|0
operator|&&
name|modelLayoutChangedSpy
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
block|{
name|QCOMPARE
argument_list|(
name|afterAboutToRemoveRowCount
argument_list|,
name|beforeRemoveRowCount
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|afterRemoveRowCount
argument_list|,
name|beforeRemoveRowCount
operator|-
name|count
operator|-
operator|(
name|numberOfRowsRemovedSignals
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|modelResetSpy
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfRemoved
argument_list|)
argument_list|,
name|beforeRemoveRowCount
operator|-
name|count
operator|-
operator|(
name|numberOfRowsRemovedSignals
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|recursive
condition|)
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfRemoved
argument_list|)
argument_list|,
name|beforeRemoveRowCount
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfRemoved
argument_list|)
argument_list|,
name|beforeRemoveRowCount
argument_list|)
expr_stmt|;
block|}
name|disconnect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|rowsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_rowsAboutToRemove
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|rowsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_rowsRemoved
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|modelResetSpy
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|modelResetSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// Test remove column
comment|//
name|connect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|columnsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_columnsAboutToRemove
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|columnsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_columnsRemoved
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|beforeRemoveColumnCount
init|=
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parentOfRemoved
argument_list|)
decl_stmt|;
comment|// Some models don't let you remove the column, only row
if|if
condition|(
name|currentModel
operator|->
name|removeColumns
argument_list|(
name|start
argument_list|,
name|count
argument_list|,
name|parentOfRemoved
argument_list|)
condition|)
block|{
name|currentModel
operator|->
name|submit
argument_list|()
expr_stmt|;
comment|// Didn't reset the rows, so they should still be at the same value
if|if
condition|(
name|modelResetSpy
operator|.
name|count
argument_list|()
operator|>=
literal|1
operator|||
name|modelLayoutChangedSpy
operator|.
name|count
argument_list|()
operator|>=
literal|1
condition|)
block|{
name|QCOMPARE
argument_list|(
name|columnsAboutToBeRemovedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//QCOMPARE(rowsAboutToBeRemovedSpy.count(), numberOfRowsAboutToBeRemovedSignals);
name|QCOMPARE
argument_list|(
name|columnsRemovedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//QCOMPARE(rowsRemovedSpy.count(), numberOfRowsRemovedSignals);
block|}
else|else
block|{
name|QCOMPARE
argument_list|(
name|columnsAboutToBeRemovedSpy
operator|.
name|count
argument_list|()
argument_list|,
name|numberOfColumnsAboutToBeRemovedSignals
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|rowsAboutToBeRemovedSpy
operator|.
name|count
argument_list|()
argument_list|,
name|numberOfRowsAboutToBeRemovedSignals
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|columnsRemovedSpy
operator|.
name|count
argument_list|()
argument_list|,
name|numberOfColumnsRemovedSignals
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|rowsRemovedSpy
operator|.
name|count
argument_list|()
argument_list|,
name|numberOfRowsRemovedSignals
argument_list|)
expr_stmt|;
block|}
comment|// The column count should only change *after* rowsAboutToBeRemoved has been emitted
if|if
condition|(
name|shouldSucceed
condition|)
block|{
if|if
condition|(
name|modelResetSpy
operator|.
name|count
argument_list|()
operator|==
literal|0
operator|&&
name|modelLayoutChangedSpy
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
block|{
name|QCOMPARE
argument_list|(
name|afterAboutToRemoveColumnCount
argument_list|,
name|beforeRemoveColumnCount
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|afterRemoveColumnCount
argument_list|,
name|beforeRemoveColumnCount
operator|-
name|count
operator|-
operator|(
name|numberOfColumnsRemovedSignals
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|modelResetSpy
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parentOfRemoved
argument_list|)
argument_list|,
name|beforeRemoveColumnCount
operator|-
name|count
operator|-
operator|(
name|numberOfColumnsRemovedSignals
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfRemoved
argument_list|)
argument_list|,
name|beforeRemoveRowCount
argument_list|)
expr_stmt|;
block|}
name|disconnect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|columnsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_columnsAboutToRemove
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|columnsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_columnsRemoved
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|columnsAboutToBeRemovedSpy
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|QList
argument_list|<
name|QVariant
argument_list|>
name|arguments
init|=
name|columnsAboutToBeRemovedSpy
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QModelIndex
name|parent
init|=
operator|(
name|qvariant_cast
argument_list|<
name|QModelIndex
argument_list|>
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|first
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|int
name|last
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|QCOMPARE
argument_list|(
name|first
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|last
argument_list|,
name|start
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|parentOfRemoved
operator|==
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|columnsRemovedSpy
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|QList
argument_list|<
name|QVariant
argument_list|>
name|arguments
init|=
name|columnsRemovedSpy
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QModelIndex
name|parent
init|=
operator|(
name|qvariant_cast
argument_list|<
name|QModelIndex
argument_list|>
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|first
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|int
name|last
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|QCOMPARE
argument_list|(
name|first
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|last
argument_list|,
name|start
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|parentOfRemoved
operator|==
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// Cleanup the test area because remove::() is called multiple times in a test
name|testModels
operator|->
name|cleanupTestArea
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Developers like to use the slots to then *do* something on the model so it needs to be     in a working state.  */
end_comment
begin_function
DECL|function|verifyState
name|void
name|verifyState
parameter_list|(
name|QAbstractItemModel
modifier|*
name|currentModel
parameter_list|)
block|{
comment|// Make sure the model isn't confused right now and still knows what is root
if|if
condition|(
name|currentModel
operator|->
name|hasChildren
argument_list|()
condition|)
block|{
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasIndex
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QModelIndex
name|index
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|index
operator|.
name|isValid
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|parent
argument_list|(
name|index
argument_list|)
operator|.
name|isValid
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QModelIndex
name|index
init|=
name|currentModel
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|index
operator|.
name|isValid
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|slot_rowsAboutToRemove
name|void
name|tst_QItemModel
operator|::
name|slot_rowsAboutToRemove
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|QVERIFY
argument_list|(
name|parentOfRemoved
operator|==
name|parent
argument_list|)
expr_stmt|;
name|afterAboutToRemoveRowCount
operator|=
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|// hasChildren() should still work
if|if
condition|(
name|afterAboutToRemoveRowCount
operator|>
literal|0
condition|)
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
else|else
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|verifyState
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
comment|// This does happen
if|if
condition|(
name|removeRecursively
condition|)
block|{
name|QFETCH
argument_list|(
name|int
argument_list|,
name|recursiveRow
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|recursiveCount
argument_list|)
expr_stmt|;
name|removeRecursively
operator|=
literal|false
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|removeRows
argument_list|(
name|recursiveRow
argument_list|,
name|recursiveCount
argument_list|,
name|parent
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|slot_rowsRemoved
name|void
name|tst_QItemModel
operator|::
name|slot_rowsRemoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|QVERIFY
argument_list|(
name|parentOfRemoved
operator|==
name|parent
argument_list|)
expr_stmt|;
name|afterRemoveRowCount
operator|=
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|afterRemoveRowCount
operator|>
literal|0
condition|)
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
else|else
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|verifyState
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|slot_columnsAboutToRemove
name|void
name|tst_QItemModel
operator|::
name|slot_columnsAboutToRemove
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|QVERIFY
argument_list|(
name|parentOfRemoved
operator|==
name|parent
argument_list|)
expr_stmt|;
name|afterAboutToRemoveColumnCount
operator|=
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|// hasChildren() should still work
if|if
condition|(
name|afterAboutToRemoveColumnCount
operator|>
literal|0
operator|&&
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|>
literal|0
condition|)
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
else|else
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|verifyState
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|slot_columnsRemoved
name|void
name|tst_QItemModel
operator|::
name|slot_columnsRemoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|QVERIFY
argument_list|(
name|parentOfRemoved
operator|==
name|parent
argument_list|)
expr_stmt|;
name|afterRemoveColumnCount
operator|=
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|afterRemoveColumnCount
operator|>
literal|0
condition|)
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
else|else
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|verifyState
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Tests the model's insertRow/Column()  */
end_comment
begin_function
DECL|function|insert_data
name|void
name|tst_QItemModel
operator|::
name|insert_data
parameter_list|()
block|{
name|ModelsToTest
name|modelsToTest
decl_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"modelType"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"readOnly"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"isEmpty"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"start"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"count"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"numberOfRowsAboutToBeInsertedSignals"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"numberOfColumnsAboutToBeInsertedSignals"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"numberOfRowsInsertedSignals"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"numberOfColumnsInsertedSignals"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"recursive"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"recursiveRow"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"recursiveCount"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"shouldSucceed"
argument_list|)
expr_stmt|;
DECL|macro|makeTestRow
define|#
directive|define
name|makeTestRow
parameter_list|(
name|testName
parameter_list|,
name|start
parameter_list|,
name|count
parameter_list|,
name|sar
parameter_list|,
name|srr
parameter_list|,
name|sac
parameter_list|,
name|src
parameter_list|,
name|r
parameter_list|,
name|rr
parameter_list|,
name|rc
parameter_list|,
name|s
parameter_list|)
define|\
value|QTest::newRow((t.modelType + testName).toLatin1().data())<< t.modelType<< readOnly<< isEmpty<< \         start<< count<< \         sar<< srr<< sac<< src<< \         r<< rr<< rc<< \         s;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|modelsToTest
operator|.
name|tests
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ModelsToTest
operator|::
name|test
name|t
init|=
name|modelsToTest
operator|.
name|tests
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QString
name|name
init|=
name|t
operator|.
name|modelType
decl_stmt|;
name|bool
name|readOnly
init|=
operator|(
name|t
operator|.
name|read
operator|==
name|ModelsToTest
operator|::
name|ReadOnly
operator|)
decl_stmt|;
name|bool
name|isEmpty
init|=
operator|(
name|t
operator|.
name|contains
operator|==
name|ModelsToTest
operator|::
name|Empty
operator|)
decl_stmt|;
comment|// half these
name|makeTestRow
argument_list|(
literal|":one at the start"
argument_list|,
name|START
argument_list|,
name|DEFAULTCOUNT
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":one at the middle"
argument_list|,
name|MIDDLE
argument_list|,
name|DEFAULTCOUNT
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":one at the end"
argument_list|,
name|END
argument_list|,
name|DEFAULTCOUNT
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":many at the start"
argument_list|,
name|START
argument_list|,
name|MANY
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":many at the middle"
argument_list|,
name|MIDDLE
argument_list|,
name|MANY
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":many at the end"
argument_list|,
name|END
argument_list|,
name|MANY
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":add row count"
argument_list|,
name|START
argument_list|,
name|ALL
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
name|DNS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":none at the start"
argument_list|,
name|START
argument_list|,
literal|0
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":none at the middle"
argument_list|,
name|MIDDLE
argument_list|,
literal|0
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":none at the end"
argument_list|,
name|END
argument_list|,
literal|0
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":invalid start, valid count 1"
argument_list|,
operator|-
literal|99
argument_list|,
literal|0
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":invalid start, valid count 2"
argument_list|,
literal|9999
argument_list|,
literal|0
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":invalid start, valid count 3"
argument_list|,
operator|-
literal|99
argument_list|,
literal|1
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":invalid start, valid count 4"
argument_list|,
literal|9999
argument_list|,
literal|1
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":invalid start, valid count 5"
argument_list|,
operator|-
literal|99
argument_list|,
name|MANY
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":invalid start, valid count 6"
argument_list|,
literal|9999
argument_list|,
name|MANY
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":valid start, invalid count 1"
argument_list|,
name|START
argument_list|,
operator|-
literal|2
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":valid start, invalid count 2"
argument_list|,
name|MIDDLE
argument_list|,
operator|-
literal|2
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|makeTestRow
argument_list|(
literal|":valid start, invalid count 3"
argument_list|,
name|END
argument_list|,
operator|-
literal|2
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
name|NOSIGNALS
argument_list|,
operator|!
name|RECURSIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
comment|// Recursive insert's might assert, haven't decided yet...
comment|//makeTestRow(":one at the start recursivly",  START,  DEFAULTCOUNT, 2, DNS, 2, DNS, RECURSIVE, START, DEFAULTCOUNT, FAIL);
comment|//makeTestRow(":one at the middle recursivly", MIDDLE, DEFAULTCOUNT, 2, DNS, 2, DNS, RECURSIVE, START, DEFAULTCOUNT, SUCCESS);
comment|//makeTestRow(":one at the end recursivly",    END,    DEFAULTCOUNT, 2, DNS, 2, DNS, RECURSIVE, START, DEFAULTCOUNT, SUCCESS);
block|}
block|}
end_function
begin_function
DECL|function|insert
name|void
name|tst_QItemModel
operator|::
name|insert
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|modelType
argument_list|)
expr_stmt|;
name|currentModel
operator|=
name|testModels
operator|->
name|createModel
argument_list|(
name|modelType
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|readOnly
argument_list|)
expr_stmt|;
if|if
condition|(
name|readOnly
condition|)
return|return;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
name|insertRecursively
operator|=
name|recursive
expr_stmt|;
comment|/*!     Inserts count number of rows starting at start     if count is -1 it inserts all rows     if start is -1 then it starts at the last row - count  */
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|shouldSucceed
argument_list|)
expr_stmt|;
comment|// Populate the test area so we can insert something.  See: cleanup()
comment|// parentOfInserted is stored so that the slots can make sure parentOfInserted is the index that is emitted.
name|parentOfInserted
operator|=
name|testModels
operator|->
name|populateTestArea
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
operator|-
literal|1
condition|)
name|count
operator|=
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfInserted
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
operator|-
literal|1
condition|)
name|start
operator|=
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfInserted
argument_list|)
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfInserted
argument_list|)
operator|==
literal|0
operator|||
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parentOfInserted
argument_list|)
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"model test area doesn't have any rows, can't fully test insert(). Skipping"
expr_stmt|;
return|return;
block|}
comment|// When a row or column is inserted there should be two signals.
comment|// Watch to make sure they are emitted and get the row/column count when they do get emitted by connecting them to a slot
name|QSignalSpy
name|columnsAboutToBeInsertedSpy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|columnsAboutToBeInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QSignalSpy
name|rowsAboutToBeInsertedSpy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|rowsAboutToBeInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QSignalSpy
name|columnsInsertedSpy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|columnsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QSignalSpy
name|rowsInsertedSpy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|rowsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QSignalSpy
name|modelResetSpy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|modelReset
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QSignalSpy
name|modelLayoutChangedSpy
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|layoutChanged
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|columnsAboutToBeInsertedSpy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|rowsAboutToBeInsertedSpy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|columnsInsertedSpy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|rowsInsertedSpy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|modelResetSpy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|modelLayoutChangedSpy
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|numberOfRowsAboutToBeInsertedSignals
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|numberOfColumnsAboutToBeInsertedSignals
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|numberOfRowsInsertedSignals
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|numberOfColumnsInsertedSignals
argument_list|)
expr_stmt|;
comment|//
comment|// test insertRow()
comment|//
name|connect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|rowsAboutToBeInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_rowsAboutToInserted
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|rowsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_rowsInserted
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|beforeInsertRowCount
init|=
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfInserted
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|insertRows
argument_list|(
name|start
argument_list|,
name|count
argument_list|,
name|parentOfInserted
argument_list|)
argument_list|,
name|shouldSucceed
argument_list|)
expr_stmt|;
name|currentModel
operator|->
name|submit
argument_list|()
expr_stmt|;
if|if
condition|(
name|rowsAboutToBeInsertedSpy
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|QList
argument_list|<
name|QVariant
argument_list|>
name|arguments
init|=
name|rowsAboutToBeInsertedSpy
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QModelIndex
name|parent
init|=
operator|(
name|qvariant_cast
argument_list|<
name|QModelIndex
argument_list|>
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|first
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|int
name|last
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|QCOMPARE
argument_list|(
name|first
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|last
argument_list|,
name|start
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|parentOfInserted
operator|==
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rowsInsertedSpy
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|QList
argument_list|<
name|QVariant
argument_list|>
name|arguments
init|=
name|rowsInsertedSpy
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QModelIndex
name|parent
init|=
operator|(
name|qvariant_cast
argument_list|<
name|QModelIndex
argument_list|>
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|first
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|int
name|last
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|QCOMPARE
argument_list|(
name|first
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|last
argument_list|,
name|start
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|parentOfInserted
operator|==
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// Only the row signals should have been emitted
if|if
condition|(
name|modelResetSpy
operator|.
name|count
argument_list|()
operator|>=
literal|1
operator|||
name|modelLayoutChangedSpy
operator|.
name|count
argument_list|()
operator|>=
literal|1
condition|)
block|{
name|QCOMPARE
argument_list|(
name|columnsAboutToBeInsertedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|rowsAboutToBeInsertedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|columnsInsertedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|rowsInsertedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QCOMPARE
argument_list|(
name|columnsAboutToBeInsertedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|rowsAboutToBeInsertedSpy
operator|.
name|count
argument_list|()
argument_list|,
name|numberOfRowsAboutToBeInsertedSignals
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|columnsInsertedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|rowsInsertedSpy
operator|.
name|count
argument_list|()
argument_list|,
name|numberOfRowsInsertedSignals
argument_list|)
expr_stmt|;
block|}
comment|// The row count should only change *after* rowsAboutToBeInserted has been emitted
if|if
condition|(
name|shouldSucceed
condition|)
block|{
if|if
condition|(
name|modelResetSpy
operator|.
name|count
argument_list|()
operator|==
literal|0
operator|&&
name|modelLayoutChangedSpy
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
block|{
name|QCOMPARE
argument_list|(
name|afterAboutToInsertRowCount
argument_list|,
name|beforeInsertRowCount
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|afterInsertRowCount
argument_list|,
name|beforeInsertRowCount
operator|+
name|count
operator|+
operator|(
name|numberOfRowsInsertedSignals
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|modelResetSpy
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfInserted
argument_list|)
argument_list|,
name|beforeInsertRowCount
operator|+
name|count
operator|+
operator|(
name|numberOfRowsInsertedSignals
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|recursive
condition|)
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfInserted
argument_list|)
argument_list|,
name|beforeInsertRowCount
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfInserted
argument_list|)
argument_list|,
name|beforeInsertRowCount
argument_list|)
expr_stmt|;
block|}
name|disconnect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|rowsAboutToBeInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_rowsAboutToInserted
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|rowsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_rowsInserted
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|modelResetSpy
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|//
comment|// Test insertColumn()
comment|//
name|connect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|columnsAboutToBeInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_columnsAboutToInserted
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|columnsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_columnsInserted
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|beforeInsertColumnCount
init|=
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parentOfInserted
argument_list|)
decl_stmt|;
comment|// Some models don't let you insert the column, only row
if|if
condition|(
name|currentModel
operator|->
name|insertColumns
argument_list|(
name|start
argument_list|,
name|count
argument_list|,
name|parentOfInserted
argument_list|)
condition|)
block|{
name|currentModel
operator|->
name|submit
argument_list|()
expr_stmt|;
if|if
condition|(
name|modelResetSpy
operator|.
name|count
argument_list|()
operator|>=
literal|1
operator|||
name|modelLayoutChangedSpy
operator|.
name|count
argument_list|()
operator|>=
literal|1
condition|)
block|{
comment|// Didn't reset the rows, so they should still be at the same value
name|QCOMPARE
argument_list|(
name|columnsAboutToBeInsertedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//QCOMPARE(rowsAboutToBeInsertedSpy.count(), numberOfRowsAboutToBeInsertedSignals);
name|QCOMPARE
argument_list|(
name|columnsInsertedSpy
operator|.
name|count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//QCOMPARE(rowsInsertedSpy.count(), numberOfRowsInsertedSignals);
block|}
else|else
block|{
comment|// Didn't reset the rows, so they should still be at the same value
name|QCOMPARE
argument_list|(
name|columnsAboutToBeInsertedSpy
operator|.
name|count
argument_list|()
argument_list|,
name|numberOfColumnsAboutToBeInsertedSignals
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|rowsAboutToBeInsertedSpy
operator|.
name|count
argument_list|()
argument_list|,
name|numberOfRowsAboutToBeInsertedSignals
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|columnsInsertedSpy
operator|.
name|count
argument_list|()
argument_list|,
name|numberOfColumnsInsertedSignals
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|rowsInsertedSpy
operator|.
name|count
argument_list|()
argument_list|,
name|numberOfRowsInsertedSignals
argument_list|)
expr_stmt|;
block|}
comment|// The column count should only change *after* rowsAboutToBeInserted has been emitted
if|if
condition|(
name|shouldSucceed
condition|)
block|{
if|if
condition|(
name|modelResetSpy
operator|.
name|count
argument_list|()
operator|==
literal|0
operator|&&
name|modelLayoutChangedSpy
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
block|{
name|QCOMPARE
argument_list|(
name|afterAboutToInsertColumnCount
argument_list|,
name|beforeInsertColumnCount
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|afterInsertColumnCount
argument_list|,
name|beforeInsertColumnCount
operator|+
name|count
operator|+
operator|(
name|numberOfColumnsInsertedSignals
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|modelResetSpy
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parentOfInserted
argument_list|)
argument_list|,
name|beforeInsertColumnCount
operator|+
name|count
operator|+
operator|(
name|numberOfColumnsInsertedSignals
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parentOfInserted
argument_list|)
argument_list|,
name|beforeInsertRowCount
argument_list|)
expr_stmt|;
block|}
name|disconnect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|columnsAboutToBeInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_columnsAboutToInserted
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|currentModel
argument_list|,
name|SIGNAL
argument_list|(
name|columnsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|slot_columnsInserted
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|columnsAboutToBeInsertedSpy
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|QList
argument_list|<
name|QVariant
argument_list|>
name|arguments
init|=
name|columnsAboutToBeInsertedSpy
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QModelIndex
name|parent
init|=
operator|(
name|qvariant_cast
argument_list|<
name|QModelIndex
argument_list|>
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|first
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|int
name|last
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|QCOMPARE
argument_list|(
name|first
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|last
argument_list|,
name|start
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|parentOfInserted
operator|==
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|columnsInsertedSpy
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|QList
argument_list|<
name|QVariant
argument_list|>
name|arguments
init|=
name|columnsInsertedSpy
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QModelIndex
name|parent
init|=
operator|(
name|qvariant_cast
argument_list|<
name|QModelIndex
argument_list|>
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|first
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|int
name|last
init|=
name|arguments
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|QCOMPARE
argument_list|(
name|first
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|last
argument_list|,
name|start
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|parentOfInserted
operator|==
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// Cleanup the test area because insert::() is called multiple times in a test
name|testModels
operator|->
name|cleanupTestArea
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|slot_rowsAboutToInserted
name|void
name|tst_QItemModel
operator|::
name|slot_rowsAboutToInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|QVERIFY
argument_list|(
name|parentOfInserted
operator|==
name|parent
argument_list|)
expr_stmt|;
name|afterAboutToInsertRowCount
operator|=
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|bool
name|hasChildren
init|=
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|bool
name|hasDimensions
init|=
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
operator|>
literal|0
operator|&&
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|>
literal|0
decl_stmt|;
name|QCOMPARE
argument_list|(
name|hasChildren
argument_list|,
name|hasDimensions
argument_list|)
expr_stmt|;
name|verifyState
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
comment|// This does happen
if|if
condition|(
name|insertRecursively
condition|)
block|{
name|QFETCH
argument_list|(
name|int
argument_list|,
name|recursiveRow
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|recursiveCount
argument_list|)
expr_stmt|;
name|insertRecursively
operator|=
literal|false
expr_stmt|;
name|QCOMPARE
argument_list|(
name|currentModel
operator|->
name|insertRows
argument_list|(
name|recursiveRow
argument_list|,
name|recursiveCount
argument_list|,
name|parent
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|slot_rowsInserted
name|void
name|tst_QItemModel
operator|::
name|slot_rowsInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|QVERIFY
argument_list|(
name|parentOfInserted
operator|==
name|parent
argument_list|)
expr_stmt|;
name|afterInsertRowCount
operator|=
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|bool
name|hasChildren
init|=
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|bool
name|hasDimensions
init|=
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
operator|>
literal|0
operator|&&
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|>
literal|0
decl_stmt|;
name|QCOMPARE
argument_list|(
name|hasChildren
argument_list|,
name|hasDimensions
argument_list|)
expr_stmt|;
name|verifyState
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|slot_columnsAboutToInserted
name|void
name|tst_QItemModel
operator|::
name|slot_columnsAboutToInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|QVERIFY
argument_list|(
name|parentOfInserted
operator|==
name|parent
argument_list|)
expr_stmt|;
name|afterAboutToInsertColumnCount
operator|=
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|bool
name|hasChildren
init|=
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|bool
name|hasDimensions
init|=
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
operator|>
literal|0
operator|&&
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|>
literal|0
decl_stmt|;
name|QCOMPARE
argument_list|(
name|hasChildren
argument_list|,
name|hasDimensions
argument_list|)
expr_stmt|;
name|verifyState
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|slot_columnsInserted
name|void
name|tst_QItemModel
operator|::
name|slot_columnsInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|QVERIFY
argument_list|(
name|parentOfInserted
operator|==
name|parent
argument_list|)
expr_stmt|;
name|afterInsertColumnCount
operator|=
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|bool
name|hasChildren
init|=
name|currentModel
operator|->
name|hasChildren
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|bool
name|hasDimensions
init|=
name|currentModel
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
operator|>
literal|0
operator|&&
name|currentModel
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|>
literal|0
decl_stmt|;
name|QCOMPARE
argument_list|(
name|hasChildren
argument_list|,
name|hasDimensions
argument_list|)
expr_stmt|;
name|verifyState
argument_list|(
name|currentModel
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QTEST_MAIN
argument_list|(
argument|tst_QItemModel
argument_list|)
end_macro
begin_include
include|#
directive|include
file|"tst_qitemmodel.moc"
end_include
end_unit
