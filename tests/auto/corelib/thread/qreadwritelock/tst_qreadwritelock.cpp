begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the test suite of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtTest/QtTest>
end_include
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<qreadwritelock.h>
end_include
begin_include
include|#
directive|include
file|<qmutex.h>
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|<qwaitcondition.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_include
include|#
directive|include
file|<qt_windows.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_WINRT
end_ifndef
begin_define
DECL|macro|sleep
define|#
directive|define
name|sleep
parameter_list|(
name|X
parameter_list|)
value|Sleep(X)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|sleep
define|#
directive|define
name|sleep
parameter_list|(
name|X
parameter_list|)
value|WaitForSingleObjectEx(GetCurrentThread(), X, FALSE);
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//on solaris, threads that loop on the release bool variable
end_comment
begin_comment
comment|//needs to sleep more than 1 usec.
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_SOLARIS
end_ifdef
begin_define
DECL|macro|RWTESTSLEEP
define|#
directive|define
name|RWTESTSLEEP
value|usleep(10);
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|RWTESTSLEEP
define|#
directive|define
name|RWTESTSLEEP
value|usleep(1);
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_class
DECL|class|tst_QReadWriteLock
class|class
name|tst_QReadWriteLock
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
comment|/*     Singlethreaded tests */
private|private
name|slots
private|:
name|void
name|constructDestruct
parameter_list|()
function_decl|;
name|void
name|readLockUnlock
parameter_list|()
function_decl|;
name|void
name|writeLockUnlock
parameter_list|()
function_decl|;
name|void
name|readLockUnlockLoop
parameter_list|()
function_decl|;
name|void
name|writeLockUnlockLoop
parameter_list|()
function_decl|;
name|void
name|readLockLoop
parameter_list|()
function_decl|;
name|void
name|writeLockLoop
parameter_list|()
function_decl|;
name|void
name|readWriteLockUnlockLoop
parameter_list|()
function_decl|;
name|void
name|tryReadLock
parameter_list|()
function_decl|;
name|void
name|tryWriteLock
parameter_list|()
function_decl|;
comment|/*     Multithreaded tests */
private|private
name|slots
private|:
name|void
name|readLockBlockRelease
parameter_list|()
function_decl|;
name|void
name|writeLockBlockRelease
parameter_list|()
function_decl|;
name|void
name|multipleReadersBlockRelease
parameter_list|()
function_decl|;
name|void
name|multipleReadersLoop
parameter_list|()
function_decl|;
name|void
name|multipleWritersLoop
parameter_list|()
function_decl|;
name|void
name|multipleReadersWritersLoop
parameter_list|()
function_decl|;
name|void
name|countingTest
parameter_list|()
function_decl|;
name|void
name|limitedReaders
parameter_list|()
function_decl|;
name|void
name|deleteOnUnlock
parameter_list|()
function_decl|;
comment|/*     Performance tests */
private|private
name|slots
private|:
name|void
name|uncontendedLocks
parameter_list|()
function_decl|;
comment|// recursive locking tests
name|void
name|recursiveReadLock
parameter_list|()
function_decl|;
name|void
name|recursiveWriteLock
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_function
DECL|function|constructDestruct
name|void
name|tst_QReadWriteLock
operator|::
name|constructDestruct
parameter_list|()
block|{
block|{
name|QReadWriteLock
name|rwlock
decl_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|readLockUnlock
name|void
name|tst_QReadWriteLock
operator|::
name|readLockUnlock
parameter_list|()
block|{
name|QReadWriteLock
name|rwlock
decl_stmt|;
name|rwlock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|writeLockUnlock
name|void
name|tst_QReadWriteLock
operator|::
name|writeLockUnlock
parameter_list|()
block|{
name|QReadWriteLock
name|rwlock
decl_stmt|;
name|rwlock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|readLockUnlockLoop
name|void
name|tst_QReadWriteLock
operator|::
name|readLockUnlockLoop
parameter_list|()
block|{
name|QReadWriteLock
name|rwlock
decl_stmt|;
name|int
name|runs
init|=
literal|10000
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|runs
condition|;
operator|++
name|i
control|)
block|{
name|rwlock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|writeLockUnlockLoop
name|void
name|tst_QReadWriteLock
operator|::
name|writeLockUnlockLoop
parameter_list|()
block|{
name|QReadWriteLock
name|rwlock
decl_stmt|;
name|int
name|runs
init|=
literal|10000
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|runs
condition|;
operator|++
name|i
control|)
block|{
name|rwlock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|readLockLoop
name|void
name|tst_QReadWriteLock
operator|::
name|readLockLoop
parameter_list|()
block|{
name|QReadWriteLock
name|rwlock
decl_stmt|;
name|int
name|runs
init|=
literal|10000
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|runs
condition|;
operator|++
name|i
control|)
block|{
name|rwlock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|runs
condition|;
operator|++
name|i
control|)
block|{
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|writeLockLoop
name|void
name|tst_QReadWriteLock
operator|::
name|writeLockLoop
parameter_list|()
block|{
comment|/*         If you include this, the test should print one line         and then block.     */
if|#
directive|if
literal|0
block|QReadWriteLock rwlock;     int runs=10000;     int i;     for (i=0; i<runs; ++i) {         rwlock.lockForWrite();         qDebug("I am going to block now.");     }
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|readWriteLockUnlockLoop
name|void
name|tst_QReadWriteLock
operator|::
name|readWriteLockUnlockLoop
parameter_list|()
block|{
name|QReadWriteLock
name|rwlock
decl_stmt|;
name|int
name|runs
init|=
literal|10000
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|runs
condition|;
operator|++
name|i
control|)
block|{
name|rwlock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
name|QAtomicInt
name|lockCount
argument_list|(
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|readWriteLock
name|QReadWriteLock
name|readWriteLock
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|testsTurn
name|QSemaphore
name|testsTurn
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|threadsTurn
name|QSemaphore
name|threadsTurn
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|tryReadLock
name|void
name|tst_QReadWriteLock
operator|::
name|tryReadLock
parameter_list|()
block|{
name|QReadWriteLock
name|rwlock
decl_stmt|;
name|QVERIFY
argument_list|(
name|rwlock
operator|.
name|tryLockForRead
argument_list|()
argument_list|)
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|rwlock
operator|.
name|tryLockForRead
argument_list|()
argument_list|)
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|rwlock
operator|.
name|tryLockForRead
argument_list|()
argument_list|)
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|rwlock
operator|.
name|tryLockForRead
argument_list|()
argument_list|)
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// functionality test
block|{
class|class
name|Thread
super|:
specifier|public
name|QThread
block|{
public|public:
name|void
name|run
parameter_list|()
block|{
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|readWriteLock
operator|.
name|tryLockForRead
argument_list|()
argument_list|)
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|readWriteLock
operator|.
name|tryLockForRead
argument_list|()
argument_list|)
expr_stmt|;
name|lockCount
operator|.
name|ref
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|readWriteLock
operator|.
name|tryLockForRead
argument_list|()
argument_list|)
expr_stmt|;
name|lockCount
operator|.
name|ref
argument_list|()
expr_stmt|;
name|lockCount
operator|.
name|deref
argument_list|()
expr_stmt|;
name|readWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|lockCount
operator|.
name|deref
argument_list|()
expr_stmt|;
name|readWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|QTime
name|timer
decl_stmt|;
name|timer
operator|.
name|start
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|readWriteLock
operator|.
name|tryLockForRead
argument_list|(
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|timer
operator|.
name|elapsed
argument_list|()
operator|>=
literal|1000
argument_list|)
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|timer
operator|.
name|start
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|readWriteLock
operator|.
name|tryLockForRead
argument_list|(
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|timer
operator|.
name|elapsed
argument_list|()
operator|<=
literal|1000
argument_list|)
expr_stmt|;
name|lockCount
operator|.
name|ref
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|readWriteLock
operator|.
name|tryLockForRead
argument_list|(
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
name|lockCount
operator|.
name|ref
argument_list|()
expr_stmt|;
name|lockCount
operator|.
name|deref
argument_list|()
expr_stmt|;
name|readWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|lockCount
operator|.
name|deref
argument_list|()
expr_stmt|;
name|readWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
block|}
block|}
class|;
name|Thread
name|thread
decl_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|readWriteLock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|lockCount
operator|.
name|testAndSetRelaxed
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|lockCount
operator|.
name|testAndSetRelaxed
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|readWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|readWriteLock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|lockCount
operator|.
name|testAndSetRelaxed
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|lockCount
operator|.
name|testAndSetRelaxed
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|readWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// stop thread
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|thread
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|tryWriteLock
name|void
name|tst_QReadWriteLock
operator|::
name|tryWriteLock
parameter_list|()
block|{
block|{
name|QReadWriteLock
name|rwlock
decl_stmt|;
name|QVERIFY
argument_list|(
name|rwlock
operator|.
name|tryLockForWrite
argument_list|()
argument_list|)
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|rwlock
operator|.
name|tryLockForWrite
argument_list|()
argument_list|)
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|rwlock
operator|.
name|tryLockForWrite
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|rwlock
operator|.
name|tryLockForWrite
argument_list|()
argument_list|)
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|rwlock
operator|.
name|tryLockForWrite
argument_list|()
argument_list|)
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|{
name|QReadWriteLock
name|rwlock
argument_list|(
name|QReadWriteLock
operator|::
name|Recursive
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|rwlock
operator|.
name|tryLockForWrite
argument_list|()
argument_list|)
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|rwlock
operator|.
name|tryLockForWrite
argument_list|()
argument_list|)
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|rwlock
operator|.
name|tryLockForWrite
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|rwlock
operator|.
name|tryLockForWrite
argument_list|()
argument_list|)
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|rwlock
operator|.
name|tryLockForWrite
argument_list|()
argument_list|)
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// functionality test
block|{
class|class
name|Thread
super|:
specifier|public
name|QThread
block|{
public|public:
name|Thread
parameter_list|()
member_init_list|:
name|failureCount
argument_list|(
literal|0
argument_list|)
block|{ }
name|void
name|run
parameter_list|()
block|{
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
if|if
condition|(
name|readWriteLock
operator|.
name|tryLockForWrite
argument_list|()
condition|)
name|failureCount
operator|++
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|readWriteLock
operator|.
name|tryLockForWrite
argument_list|()
condition|)
name|failureCount
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|lockCount
operator|.
name|testAndSetRelaxed
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
name|failureCount
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|lockCount
operator|.
name|testAndSetRelaxed
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|failureCount
operator|++
expr_stmt|;
name|readWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
if|if
condition|(
name|readWriteLock
operator|.
name|tryLockForWrite
argument_list|(
literal|1000
argument_list|)
condition|)
name|failureCount
operator|++
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|readWriteLock
operator|.
name|tryLockForWrite
argument_list|(
literal|1000
argument_list|)
condition|)
name|failureCount
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|lockCount
operator|.
name|testAndSetRelaxed
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
name|failureCount
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|lockCount
operator|.
name|testAndSetRelaxed
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|failureCount
operator|++
expr_stmt|;
name|readWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
block|}
name|int
name|failureCount
decl_stmt|;
block|}
class|;
name|Thread
name|thread
decl_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|readWriteLock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
name|lockCount
operator|.
name|ref
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|lockCount
operator|.
name|deref
argument_list|()
expr_stmt|;
name|readWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|readWriteLock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
name|lockCount
operator|.
name|ref
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|lockCount
operator|.
name|deref
argument_list|()
expr_stmt|;
name|readWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// stop thread
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|thread
operator|.
name|wait
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|thread
operator|.
name|failureCount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|threadDone
name|bool
name|threadDone
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|release
name|QAtomicInt
name|release
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*     write-lock     unlock     set threadone */
end_comment
begin_class
DECL|class|WriteLockThread
class|class
name|WriteLockThread
super|:
specifier|public
name|QThread
block|{
public|public:
DECL|member|testRwlock
name|QReadWriteLock
modifier|&
name|testRwlock
decl_stmt|;
DECL|function|WriteLockThread
specifier|inline
name|WriteLockThread
parameter_list|(
name|QReadWriteLock
modifier|&
name|l
parameter_list|)
member_init_list|:
name|testRwlock
argument_list|(
name|l
argument_list|)
block|{ }
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|testRwlock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
name|testRwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|threadDone
operator|=
literal|true
expr_stmt|;
block|}
block|}
class|;
end_class
begin_comment
comment|/*     read-lock     unlock     set threadone */
end_comment
begin_class
DECL|class|ReadLockThread
class|class
name|ReadLockThread
super|:
specifier|public
name|QThread
block|{
public|public:
DECL|member|testRwlock
name|QReadWriteLock
modifier|&
name|testRwlock
decl_stmt|;
DECL|function|ReadLockThread
specifier|inline
name|ReadLockThread
parameter_list|(
name|QReadWriteLock
modifier|&
name|l
parameter_list|)
member_init_list|:
name|testRwlock
argument_list|(
name|l
argument_list|)
block|{ }
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|testRwlock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
name|testRwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|threadDone
operator|=
literal|true
expr_stmt|;
block|}
block|}
class|;
end_class
begin_comment
comment|/*     write-lock     wait for release==true     unlock */
end_comment
begin_class
DECL|class|WriteLockReleasableThread
class|class
name|WriteLockReleasableThread
super|:
specifier|public
name|QThread
block|{
public|public:
DECL|member|testRwlock
name|QReadWriteLock
modifier|&
name|testRwlock
decl_stmt|;
DECL|function|WriteLockReleasableThread
specifier|inline
name|WriteLockReleasableThread
parameter_list|(
name|QReadWriteLock
modifier|&
name|l
parameter_list|)
member_init_list|:
name|testRwlock
argument_list|(
name|l
argument_list|)
block|{ }
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|testRwlock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
while|while
condition|(
name|release
operator|.
name|load
argument_list|()
operator|==
literal|false
condition|)
block|{
name|RWTESTSLEEP
block|}
name|testRwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
class|;
end_class
begin_comment
comment|/*     read-lock     wait for release==true     unlock */
end_comment
begin_class
DECL|class|ReadLockReleasableThread
class|class
name|ReadLockReleasableThread
super|:
specifier|public
name|QThread
block|{
public|public:
DECL|member|testRwlock
name|QReadWriteLock
modifier|&
name|testRwlock
decl_stmt|;
DECL|function|ReadLockReleasableThread
specifier|inline
name|ReadLockReleasableThread
parameter_list|(
name|QReadWriteLock
modifier|&
name|l
parameter_list|)
member_init_list|:
name|testRwlock
argument_list|(
name|l
argument_list|)
block|{ }
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|testRwlock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
while|while
condition|(
name|release
operator|.
name|load
argument_list|()
operator|==
literal|false
condition|)
block|{
name|RWTESTSLEEP
block|}
name|testRwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
class|;
end_class
begin_comment
comment|/*     for(runTime msecs)         read-lock         msleep(holdTime msecs)         release lock         msleep(waitTime msecs) */
end_comment
begin_class
DECL|class|ReadLockLoopThread
class|class
name|ReadLockLoopThread
super|:
specifier|public
name|QThread
block|{
public|public:
DECL|member|testRwlock
name|QReadWriteLock
modifier|&
name|testRwlock
decl_stmt|;
DECL|member|runTime
name|int
name|runTime
decl_stmt|;
DECL|member|holdTime
name|int
name|holdTime
decl_stmt|;
DECL|member|waitTime
name|int
name|waitTime
decl_stmt|;
DECL|member|print
name|bool
name|print
decl_stmt|;
DECL|member|t
name|QTime
name|t
decl_stmt|;
DECL|function|ReadLockLoopThread
specifier|inline
name|ReadLockLoopThread
parameter_list|(
name|QReadWriteLock
modifier|&
name|l
parameter_list|,
name|int
name|runTime
parameter_list|,
name|int
name|holdTime
init|=
literal|0
parameter_list|,
name|int
name|waitTime
init|=
literal|0
parameter_list|,
name|bool
name|print
init|=
literal|false
parameter_list|)
member_init_list|:
name|testRwlock
argument_list|(
name|l
argument_list|)
member_init_list|,
name|runTime
argument_list|(
name|runTime
argument_list|)
member_init_list|,
name|holdTime
argument_list|(
name|holdTime
argument_list|)
member_init_list|,
name|waitTime
argument_list|(
name|waitTime
argument_list|)
member_init_list|,
name|print
argument_list|(
name|print
argument_list|)
block|{ }
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|elapsed
argument_list|()
operator|<
name|runTime
condition|)
block|{
name|testRwlock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
if|if
condition|(
name|print
condition|)
name|printf
argument_list|(
literal|"reading\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|holdTime
condition|)
name|msleep
argument_list|(
name|holdTime
argument_list|)
expr_stmt|;
name|testRwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|waitTime
condition|)
name|msleep
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
class|;
end_class
begin_comment
comment|/*     for(runTime msecs)         write-lock         msleep(holdTime msecs)         release lock         msleep(waitTime msecs) */
end_comment
begin_class
DECL|class|WriteLockLoopThread
class|class
name|WriteLockLoopThread
super|:
specifier|public
name|QThread
block|{
public|public:
DECL|member|testRwlock
name|QReadWriteLock
modifier|&
name|testRwlock
decl_stmt|;
DECL|member|runTime
name|int
name|runTime
decl_stmt|;
DECL|member|holdTime
name|int
name|holdTime
decl_stmt|;
DECL|member|waitTime
name|int
name|waitTime
decl_stmt|;
DECL|member|print
name|bool
name|print
decl_stmt|;
DECL|member|t
name|QTime
name|t
decl_stmt|;
DECL|function|WriteLockLoopThread
specifier|inline
name|WriteLockLoopThread
parameter_list|(
name|QReadWriteLock
modifier|&
name|l
parameter_list|,
name|int
name|runTime
parameter_list|,
name|int
name|holdTime
init|=
literal|0
parameter_list|,
name|int
name|waitTime
init|=
literal|0
parameter_list|,
name|bool
name|print
init|=
literal|false
parameter_list|)
member_init_list|:
name|testRwlock
argument_list|(
name|l
argument_list|)
member_init_list|,
name|runTime
argument_list|(
name|runTime
argument_list|)
member_init_list|,
name|holdTime
argument_list|(
name|holdTime
argument_list|)
member_init_list|,
name|waitTime
argument_list|(
name|waitTime
argument_list|)
member_init_list|,
name|print
argument_list|(
name|print
argument_list|)
block|{ }
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|elapsed
argument_list|()
operator|<
name|runTime
condition|)
block|{
name|testRwlock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
if|if
condition|(
name|print
condition|)
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|holdTime
condition|)
name|msleep
argument_list|(
name|holdTime
argument_list|)
expr_stmt|;
name|testRwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|waitTime
condition|)
name|msleep
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
class|;
end_class
begin_decl_stmt
DECL|variable|count
specifier|volatile
name|int
name|count
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*     for(runTime msecs)         write-lock         count to maxval         set count to 0         release lock         msleep waitTime */
end_comment
begin_class
DECL|class|WriteLockCountThread
class|class
name|WriteLockCountThread
super|:
specifier|public
name|QThread
block|{
public|public:
DECL|member|testRwlock
name|QReadWriteLock
modifier|&
name|testRwlock
decl_stmt|;
DECL|member|runTime
name|int
name|runTime
decl_stmt|;
DECL|member|waitTime
name|int
name|waitTime
decl_stmt|;
DECL|member|maxval
name|int
name|maxval
decl_stmt|;
DECL|member|t
name|QTime
name|t
decl_stmt|;
DECL|function|WriteLockCountThread
specifier|inline
name|WriteLockCountThread
parameter_list|(
name|QReadWriteLock
modifier|&
name|l
parameter_list|,
name|int
name|runTime
parameter_list|,
name|int
name|waitTime
parameter_list|,
name|int
name|maxval
parameter_list|)
member_init_list|:
name|testRwlock
argument_list|(
name|l
argument_list|)
member_init_list|,
name|runTime
argument_list|(
name|runTime
argument_list|)
member_init_list|,
name|waitTime
argument_list|(
name|waitTime
argument_list|)
member_init_list|,
name|maxval
argument_list|(
name|maxval
argument_list|)
block|{ }
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|elapsed
argument_list|()
operator|<
name|runTime
condition|)
block|{
name|testRwlock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
condition|)
name|qFatal
argument_list|(
literal|"Non-zero count at start of write! (%d)"
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|//            printf(".");
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxval
condition|;
operator|++
name|i
control|)
block|{
specifier|volatile
name|int
name|lc
init|=
name|count
decl_stmt|;
operator|++
name|lc
expr_stmt|;
name|count
operator|=
name|lc
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|testRwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|msleep
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
class|;
end_class
begin_comment
comment|/*     for(runTime msecs)         read-lock         verify count==0         release lock         msleep waitTime */
end_comment
begin_class
DECL|class|ReadLockCountThread
class|class
name|ReadLockCountThread
super|:
specifier|public
name|QThread
block|{
public|public:
DECL|member|testRwlock
name|QReadWriteLock
modifier|&
name|testRwlock
decl_stmt|;
DECL|member|runTime
name|int
name|runTime
decl_stmt|;
DECL|member|waitTime
name|int
name|waitTime
decl_stmt|;
DECL|member|t
name|QTime
name|t
decl_stmt|;
DECL|function|ReadLockCountThread
specifier|inline
name|ReadLockCountThread
parameter_list|(
name|QReadWriteLock
modifier|&
name|l
parameter_list|,
name|int
name|runTime
parameter_list|,
name|int
name|waitTime
parameter_list|)
member_init_list|:
name|testRwlock
argument_list|(
name|l
argument_list|)
member_init_list|,
name|runTime
argument_list|(
name|runTime
argument_list|)
member_init_list|,
name|waitTime
argument_list|(
name|waitTime
argument_list|)
block|{ }
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|elapsed
argument_list|()
operator|<
name|runTime
condition|)
block|{
name|testRwlock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
condition|)
name|qFatal
argument_list|(
literal|"Non-zero count at Read! (%d)"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|testRwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|msleep
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
class|;
end_class
begin_comment
comment|/*     A writer acquires a read-lock, a reader locks     the writer releases the lock, the reader gets the lock */
end_comment
begin_function
DECL|function|readLockBlockRelease
name|void
name|tst_QReadWriteLock
operator|::
name|readLockBlockRelease
parameter_list|()
block|{
name|QReadWriteLock
name|testLock
decl_stmt|;
name|testLock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
name|threadDone
operator|=
literal|false
expr_stmt|;
name|ReadLockThread
name|rlt
argument_list|(
name|testLock
argument_list|)
decl_stmt|;
name|rlt
operator|.
name|start
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|testLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|rlt
operator|.
name|wait
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|threadDone
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     writer1 acquires a read-lock, writer2 blocks,     writer1 releases the lock, writer2 gets the lock */
end_comment
begin_function
DECL|function|writeLockBlockRelease
name|void
name|tst_QReadWriteLock
operator|::
name|writeLockBlockRelease
parameter_list|()
block|{
name|QReadWriteLock
name|testLock
decl_stmt|;
name|testLock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
name|threadDone
operator|=
literal|false
expr_stmt|;
name|WriteLockThread
name|wlt
argument_list|(
name|testLock
argument_list|)
decl_stmt|;
name|wlt
operator|.
name|start
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|testLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|wlt
operator|.
name|wait
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|threadDone
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     Two readers acquire a read-lock, one writer attempts a write block,     the readers release their locks, the writer gets the lock. */
end_comment
begin_function
DECL|function|multipleReadersBlockRelease
name|void
name|tst_QReadWriteLock
operator|::
name|multipleReadersBlockRelease
parameter_list|()
block|{
name|QReadWriteLock
name|testLock
decl_stmt|;
name|release
operator|.
name|store
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|threadDone
operator|=
literal|false
expr_stmt|;
name|ReadLockReleasableThread
name|rlt1
argument_list|(
name|testLock
argument_list|)
decl_stmt|;
name|ReadLockReleasableThread
name|rlt2
argument_list|(
name|testLock
argument_list|)
decl_stmt|;
name|rlt1
operator|.
name|start
argument_list|()
expr_stmt|;
name|rlt2
operator|.
name|start
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|WriteLockThread
name|wlt
argument_list|(
name|testLock
argument_list|)
decl_stmt|;
name|wlt
operator|.
name|start
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|release
operator|.
name|store
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|wlt
operator|.
name|wait
argument_list|()
expr_stmt|;
name|rlt1
operator|.
name|wait
argument_list|()
expr_stmt|;
name|rlt2
operator|.
name|wait
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|threadDone
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     Multiple readers locks and unlocks a lock. */
end_comment
begin_function
DECL|function|multipleReadersLoop
name|void
name|tst_QReadWriteLock
operator|::
name|multipleReadersLoop
parameter_list|()
block|{
name|int
name|time
init|=
literal|500
decl_stmt|;
name|int
name|hold
init|=
literal|250
decl_stmt|;
name|int
name|wait
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
specifier|const
name|int
name|numthreads
init|=
literal|50
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
specifier|const
name|int
name|numthreads
init|=
literal|40
decl_stmt|;
else|#
directive|else
specifier|const
name|int
name|numthreads
init|=
literal|75
decl_stmt|;
endif|#
directive|endif
name|QReadWriteLock
name|testLock
decl_stmt|;
name|ReadLockLoopThread
modifier|*
name|threads
index|[
name|numthreads
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numthreads
condition|;
operator|++
name|i
control|)
name|threads
index|[
name|i
index|]
operator|=
operator|new
name|ReadLockLoopThread
argument_list|(
name|testLock
argument_list|,
name|time
argument_list|,
name|hold
argument_list|,
name|wait
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numthreads
condition|;
operator|++
name|i
control|)
name|threads
index|[
name|i
index|]
operator|->
name|start
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numthreads
condition|;
operator|++
name|i
control|)
name|threads
index|[
name|i
index|]
operator|->
name|wait
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numthreads
condition|;
operator|++
name|i
control|)
operator|delete
name|threads
index|[
name|i
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     Multiple writers locks and unlocks a lock. */
end_comment
begin_function
DECL|function|multipleWritersLoop
name|void
name|tst_QReadWriteLock
operator|::
name|multipleWritersLoop
parameter_list|()
block|{
name|int
name|time
init|=
literal|500
decl_stmt|;
name|int
name|wait
init|=
literal|0
decl_stmt|;
name|int
name|hold
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|numthreads
init|=
literal|50
decl_stmt|;
name|QReadWriteLock
name|testLock
decl_stmt|;
name|WriteLockLoopThread
modifier|*
name|threads
index|[
name|numthreads
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numthreads
condition|;
operator|++
name|i
control|)
name|threads
index|[
name|i
index|]
operator|=
operator|new
name|WriteLockLoopThread
argument_list|(
name|testLock
argument_list|,
name|time
argument_list|,
name|hold
argument_list|,
name|wait
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numthreads
condition|;
operator|++
name|i
control|)
name|threads
index|[
name|i
index|]
operator|->
name|start
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numthreads
condition|;
operator|++
name|i
control|)
name|threads
index|[
name|i
index|]
operator|->
name|wait
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numthreads
condition|;
operator|++
name|i
control|)
operator|delete
name|threads
index|[
name|i
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     Multiple readers and writers locks and unlocks a lock. */
end_comment
begin_function
DECL|function|multipleReadersWritersLoop
name|void
name|tst_QReadWriteLock
operator|::
name|multipleReadersWritersLoop
parameter_list|()
block|{
comment|//int time=INT_MAX;
name|int
name|time
init|=
literal|10000
decl_stmt|;
name|int
name|readerThreads
init|=
literal|20
decl_stmt|;
name|int
name|readerWait
init|=
literal|0
decl_stmt|;
name|int
name|readerHold
init|=
literal|1
decl_stmt|;
name|int
name|writerThreads
init|=
literal|2
decl_stmt|;
name|int
name|writerWait
init|=
literal|500
decl_stmt|;
name|int
name|writerHold
init|=
literal|50
decl_stmt|;
name|QReadWriteLock
name|testLock
decl_stmt|;
name|ReadLockLoopThread
modifier|*
name|readers
index|[
literal|1024
index|]
decl_stmt|;
name|WriteLockLoopThread
modifier|*
name|writers
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|readerThreads
condition|;
operator|++
name|i
control|)
name|readers
index|[
name|i
index|]
operator|=
operator|new
name|ReadLockLoopThread
argument_list|(
name|testLock
argument_list|,
name|time
argument_list|,
name|readerHold
argument_list|,
name|readerWait
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|writerThreads
condition|;
operator|++
name|i
control|)
name|writers
index|[
name|i
index|]
operator|=
operator|new
name|WriteLockLoopThread
argument_list|(
name|testLock
argument_list|,
name|time
argument_list|,
name|writerHold
argument_list|,
name|writerWait
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|readerThreads
condition|;
operator|++
name|i
control|)
name|readers
index|[
name|i
index|]
operator|->
name|start
argument_list|(
name|QThread
operator|::
name|NormalPriority
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|writerThreads
condition|;
operator|++
name|i
control|)
name|writers
index|[
name|i
index|]
operator|->
name|start
argument_list|(
name|QThread
operator|::
name|IdlePriority
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|readerThreads
condition|;
operator|++
name|i
control|)
name|readers
index|[
name|i
index|]
operator|->
name|wait
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|writerThreads
condition|;
operator|++
name|i
control|)
name|writers
index|[
name|i
index|]
operator|->
name|wait
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|readerThreads
condition|;
operator|++
name|i
control|)
operator|delete
name|readers
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|writerThreads
condition|;
operator|++
name|i
control|)
operator|delete
name|writers
index|[
name|i
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     Writers increment a variable from 0 to maxval, then reset it to 0.     Readers verify that the variable remains at 0. */
end_comment
begin_function
DECL|function|countingTest
name|void
name|tst_QReadWriteLock
operator|::
name|countingTest
parameter_list|()
block|{
comment|//int time=INT_MAX;
name|int
name|time
init|=
literal|10000
decl_stmt|;
name|int
name|readerThreads
init|=
literal|20
decl_stmt|;
name|int
name|readerWait
init|=
literal|1
decl_stmt|;
name|int
name|writerThreads
init|=
literal|3
decl_stmt|;
name|int
name|writerWait
init|=
literal|150
decl_stmt|;
name|int
name|maxval
init|=
literal|10000
decl_stmt|;
name|QReadWriteLock
name|testLock
decl_stmt|;
name|ReadLockCountThread
modifier|*
name|readers
index|[
literal|1024
index|]
decl_stmt|;
name|WriteLockCountThread
modifier|*
name|writers
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|readerThreads
condition|;
operator|++
name|i
control|)
name|readers
index|[
name|i
index|]
operator|=
operator|new
name|ReadLockCountThread
argument_list|(
name|testLock
argument_list|,
name|time
argument_list|,
name|readerWait
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|writerThreads
condition|;
operator|++
name|i
control|)
name|writers
index|[
name|i
index|]
operator|=
operator|new
name|WriteLockCountThread
argument_list|(
name|testLock
argument_list|,
name|time
argument_list|,
name|writerWait
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|readerThreads
condition|;
operator|++
name|i
control|)
name|readers
index|[
name|i
index|]
operator|->
name|start
argument_list|(
name|QThread
operator|::
name|NormalPriority
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|writerThreads
condition|;
operator|++
name|i
control|)
name|writers
index|[
name|i
index|]
operator|->
name|start
argument_list|(
name|QThread
operator|::
name|LowestPriority
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|readerThreads
condition|;
operator|++
name|i
control|)
name|readers
index|[
name|i
index|]
operator|->
name|wait
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|writerThreads
condition|;
operator|++
name|i
control|)
name|writers
index|[
name|i
index|]
operator|->
name|wait
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|readerThreads
condition|;
operator|++
name|i
control|)
operator|delete
name|readers
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|writerThreads
condition|;
operator|++
name|i
control|)
operator|delete
name|writers
index|[
name|i
index|]
expr_stmt|;
block|}
end_function
begin_function
DECL|function|limitedReaders
name|void
name|tst_QReadWriteLock
operator|::
name|limitedReaders
parameter_list|()
block|{  }
end_function
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|/*     Test a race-condition that may happen if one thread is in unlock() while     another thread deletes the rw-lock.      MainThread              DeleteOnUnlockThread      write-lock     unlock       |                     write-lock       |                     unlock       |                     delete lock     deref d inside unlock */
end_comment
begin_class
DECL|class|DeleteOnUnlockThread
class|class
name|DeleteOnUnlockThread
super|:
specifier|public
name|QThread
block|{
public|public:
DECL|function|DeleteOnUnlockThread
name|DeleteOnUnlockThread
parameter_list|(
name|QReadWriteLock
modifier|*
modifier|*
name|lock
parameter_list|,
name|QWaitCondition
modifier|*
name|startup
parameter_list|,
name|QMutex
modifier|*
name|waitMutex
parameter_list|)
member_init_list|:
name|m_lock
argument_list|(
name|lock
argument_list|)
member_init_list|,
name|m_startup
argument_list|(
name|startup
argument_list|)
member_init_list|,
name|m_waitMutex
argument_list|(
name|waitMutex
argument_list|)
block|{}
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|m_waitMutex
operator|->
name|lock
argument_list|()
expr_stmt|;
name|m_startup
operator|->
name|wakeAll
argument_list|()
expr_stmt|;
name|m_waitMutex
operator|->
name|unlock
argument_list|()
expr_stmt|;
comment|// DeleteOnUnlockThread and the main thread will race from this point
operator|(
operator|*
name|m_lock
operator|)
operator|->
name|lockForWrite
argument_list|()
expr_stmt|;
operator|(
operator|*
name|m_lock
operator|)
operator|->
name|unlock
argument_list|()
expr_stmt|;
operator|delete
operator|*
name|m_lock
expr_stmt|;
block|}
private|private:
DECL|member|m_lock
name|QReadWriteLock
modifier|*
modifier|*
name|m_lock
decl_stmt|;
DECL|member|m_startup
name|QWaitCondition
modifier|*
name|m_startup
decl_stmt|;
DECL|member|m_waitMutex
name|QMutex
modifier|*
name|m_waitMutex
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|deleteOnUnlock
name|void
name|tst_QReadWriteLock
operator|::
name|deleteOnUnlock
parameter_list|()
block|{
name|QReadWriteLock
modifier|*
name|lock
init|=
literal|0
decl_stmt|;
name|QWaitCondition
name|startup
decl_stmt|;
name|QMutex
name|waitMutex
decl_stmt|;
name|DeleteOnUnlockThread
name|thread2
argument_list|(
operator|&
name|lock
argument_list|,
operator|&
name|startup
argument_list|,
operator|&
name|waitMutex
argument_list|)
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|elapsed
argument_list|()
operator|<
literal|4000
condition|)
block|{
name|lock
operator|=
operator|new
name|QReadWriteLock
argument_list|()
expr_stmt|;
name|waitMutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|lock
operator|->
name|lockForWrite
argument_list|()
expr_stmt|;
name|thread2
operator|.
name|start
argument_list|()
expr_stmt|;
name|startup
operator|.
name|wait
argument_list|(
operator|&
name|waitMutex
argument_list|)
expr_stmt|;
name|waitMutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// DeleteOnUnlockThread and the main thread will race from this point
name|lock
operator|->
name|unlock
argument_list|()
expr_stmt|;
name|thread2
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|uncontendedLocks
name|void
name|tst_QReadWriteLock
operator|::
name|uncontendedLocks
parameter_list|()
block|{
name|uint
name|read
init|=
literal|0
decl_stmt|;
name|uint
name|write
init|=
literal|0
decl_stmt|;
name|uint
name|count
init|=
literal|0
decl_stmt|;
name|int
name|millisecs
init|=
literal|1000
decl_stmt|;
block|{
name|QTime
name|t
decl_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|elapsed
argument_list|()
operator|<
name|millisecs
condition|)
block|{
operator|++
name|count
expr_stmt|;
block|}
block|}
block|{
name|QReadWriteLock
name|rwlock
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|elapsed
argument_list|()
operator|<
name|millisecs
condition|)
block|{
name|rwlock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
operator|++
name|read
expr_stmt|;
block|}
block|}
block|{
name|QReadWriteLock
name|rwlock
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|elapsed
argument_list|()
operator|<
name|millisecs
condition|)
block|{
name|rwlock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
name|rwlock
operator|.
name|unlock
argument_list|()
expr_stmt|;
operator|++
name|write
expr_stmt|;
block|}
block|}
name|qDebug
argument_list|(
literal|"during %d millisecs:"
argument_list|,
name|millisecs
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"counted to %u"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"%u uncontended read locks/unlocks"
argument_list|,
name|read
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"%u uncontended write locks/unlocks"
argument_list|,
name|write
argument_list|)
expr_stmt|;
block|}
end_function
begin_enum
DECL|enumerator|RecursiveLockCount
enum|enum
block|{
name|RecursiveLockCount
init|=
literal|10
block|}
enum|;
end_enum
begin_function
DECL|function|recursiveReadLock
name|void
name|tst_QReadWriteLock
operator|::
name|recursiveReadLock
parameter_list|()
block|{
comment|// thread to attempt locking for writing while the test recursively locks for reading
class|class
name|RecursiveReadLockThread
super|:
specifier|public
name|QThread
block|{
public|public:
name|QReadWriteLock
modifier|*
name|lock
decl_stmt|;
name|bool
name|tryLockForWriteResult
decl_stmt|;
name|void
name|run
parameter_list|()
block|{
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// test is recursively locking for writing
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RecursiveLockCount
condition|;
operator|++
name|i
control|)
block|{
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|tryLockForWriteResult
operator|=
name|lock
operator|->
name|tryLockForWrite
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
comment|// test is releasing recursive write lock
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RecursiveLockCount
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|tryLockForWriteResult
operator|=
name|lock
operator|->
name|tryLockForWrite
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
comment|// after final unlock in test, we should get the lock
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|tryLockForWriteResult
operator|=
name|lock
operator|->
name|tryLockForWrite
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// cleanup
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|lock
operator|->
name|unlock
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// test will lockForRead(), then we will lockForWrite()
comment|// (and block), purpose is to ensure that the test can
comment|// recursive lockForRead() even with a waiting writer
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
comment|// testsTurn.release(); // ### do not release here, the test uses tryAcquire()
name|lock
operator|->
name|lockForWrite
argument_list|()
expr_stmt|;
name|lock
operator|->
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
class|;
comment|// init
name|QReadWriteLock
name|lock
argument_list|(
name|QReadWriteLock
operator|::
name|Recursive
argument_list|)
decl_stmt|;
name|RecursiveReadLockThread
name|thread
decl_stmt|;
name|thread
operator|.
name|lock
operator|=
operator|&
name|lock
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
comment|// verify that we can get multiple read locks in the same thread
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RecursiveLockCount
condition|;
operator|++
name|i
control|)
block|{
name|QVERIFY
argument_list|(
name|lock
operator|.
name|tryLockForRead
argument_list|()
argument_list|)
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|thread
operator|.
name|tryLockForWriteResult
argument_list|)
expr_stmt|;
block|}
comment|// have to unlock the same number of times that we locked
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RecursiveLockCount
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|thread
operator|.
name|tryLockForWriteResult
argument_list|)
expr_stmt|;
block|}
comment|// after the final unlock, we should be able to get the write lock
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|thread
operator|.
name|tryLockForWriteResult
argument_list|)
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// check that recursive read locking works even when we have a waiting writer
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|lock
operator|.
name|tryLockForRead
argument_list|()
argument_list|)
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|tryAcquire
argument_list|(
literal|1
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|lock
operator|.
name|tryLockForRead
argument_list|()
argument_list|)
expr_stmt|;
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// cleanup
name|QVERIFY
argument_list|(
name|thread
operator|.
name|wait
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|recursiveWriteLock
name|void
name|tst_QReadWriteLock
operator|::
name|recursiveWriteLock
parameter_list|()
block|{
comment|// thread to attempt locking for reading while the test recursively locks for writing
class|class
name|RecursiveWriteLockThread
super|:
specifier|public
name|QThread
block|{
public|public:
name|QReadWriteLock
modifier|*
name|lock
decl_stmt|;
name|bool
name|tryLockForReadResult
decl_stmt|;
name|void
name|run
parameter_list|()
block|{
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// test is recursively locking for writing
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RecursiveLockCount
condition|;
operator|++
name|i
control|)
block|{
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|tryLockForReadResult
operator|=
name|lock
operator|->
name|tryLockForRead
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
comment|// test is releasing recursive write lock
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RecursiveLockCount
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|tryLockForReadResult
operator|=
name|lock
operator|->
name|tryLockForRead
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
comment|// after final unlock in test, we should get the lock
name|threadsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|tryLockForReadResult
operator|=
name|lock
operator|->
name|tryLockForRead
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// cleanup
name|lock
operator|->
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
class|;
comment|// init
name|QReadWriteLock
name|lock
argument_list|(
name|QReadWriteLock
operator|::
name|Recursive
argument_list|)
decl_stmt|;
name|RecursiveWriteLockThread
name|thread
decl_stmt|;
name|thread
operator|.
name|lock
operator|=
operator|&
name|lock
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
comment|// verify that we can get multiple read locks in the same thread
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RecursiveLockCount
condition|;
operator|++
name|i
control|)
block|{
name|QVERIFY
argument_list|(
name|lock
operator|.
name|tryLockForWrite
argument_list|()
argument_list|)
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|thread
operator|.
name|tryLockForReadResult
argument_list|)
expr_stmt|;
block|}
comment|// have to unlock the same number of times that we locked
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RecursiveLockCount
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|thread
operator|.
name|tryLockForReadResult
argument_list|)
expr_stmt|;
block|}
comment|// after the final unlock, thread should be able to get the read lock
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|threadsTurn
operator|.
name|release
argument_list|()
expr_stmt|;
name|testsTurn
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|thread
operator|.
name|tryLockForReadResult
argument_list|)
expr_stmt|;
comment|// cleanup
name|QVERIFY
argument_list|(
name|thread
operator|.
name|wait
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QTEST_MAIN
argument_list|(
argument|tst_QReadWriteLock
argument_list|)
end_macro
begin_include
include|#
directive|include
file|"tst_qreadwritelock.moc"
end_include
end_unit
