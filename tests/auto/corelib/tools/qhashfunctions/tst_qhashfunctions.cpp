begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd and/or its subsidiary(-ies). ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the test suite of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtTest/QtTest>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<qtypetraits.h>
end_include
begin_include
include|#
directive|include
file|<iterator>
end_include
begin_include
include|#
directive|include
file|<sstream>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_class
DECL|class|tst_QHashFunctions
class|class
name|tst_QHashFunctions
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
private|private
name|Q_SLOTS
private|:
name|void
name|qhash
parameter_list|()
function_decl|;
name|void
name|fp_qhash_of_zero_is_zero
parameter_list|()
function_decl|;
name|void
name|qthash_data
parameter_list|()
function_decl|;
name|void
name|qthash
parameter_list|()
function_decl|;
name|void
name|range
parameter_list|()
function_decl|;
name|void
name|rangeCommutative
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_function
DECL|function|qhash
name|void
name|tst_QHashFunctions
operator|::
name|qhash
parameter_list|()
block|{
block|{
name|QBitArray
name|a1
decl_stmt|;
name|QBitArray
name|a2
decl_stmt|;
name|QVERIFY
argument_list|(
name|qHash
argument_list|(
name|a1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|a1
operator|.
name|resize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|a1
operator|.
name|setBit
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|a2
operator|.
name|resize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|a2
operator|.
name|setBit
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|uint
name|h1
init|=
name|qHash
argument_list|(
name|a1
argument_list|)
decl_stmt|;
name|uint
name|h2
init|=
name|qHash
argument_list|(
name|a2
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|h1
operator|!=
name|h2
argument_list|)
expr_stmt|;
name|a2
operator|.
name|setBit
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|h1
operator|==
name|qHash
argument_list|(
name|a2
argument_list|)
argument_list|)
expr_stmt|;
name|a1
operator|.
name|fill
argument_list|(
literal|true
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|a1
operator|.
name|resize
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|h1
operator|=
name|qHash
argument_list|(
name|a1
argument_list|)
expr_stmt|;
name|a2
operator|.
name|fill
argument_list|(
literal|true
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|h2
operator|=
name|qHash
argument_list|(
name|a2
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|h1
operator|==
name|h2
argument_list|)
expr_stmt|;
name|a2
operator|.
name|setBit
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|uint
name|h3
init|=
name|qHash
argument_list|(
name|a2
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|h2
operator|!=
name|h3
argument_list|)
expr_stmt|;
name|a2
operator|.
name|setBit
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|h2
operator|==
name|qHash
argument_list|(
name|a2
argument_list|)
argument_list|)
expr_stmt|;
name|a2
operator|.
name|setBit
argument_list|(
literal|6
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|uint
name|h4
init|=
name|qHash
argument_list|(
name|a2
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|h2
operator|!=
name|h4
argument_list|)
expr_stmt|;
name|a2
operator|.
name|setBit
argument_list|(
literal|6
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|h2
operator|==
name|qHash
argument_list|(
name|a2
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|h3
operator|!=
name|h4
argument_list|)
expr_stmt|;
block|}
block|{
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|p12
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|p21
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|qHash
argument_list|(
name|p12
argument_list|)
operator|==
name|qHash
argument_list|(
name|p12
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|qHash
argument_list|(
name|p21
argument_list|)
operator|==
name|qHash
argument_list|(
name|p21
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|qHash
argument_list|(
name|p12
argument_list|)
operator|!=
name|qHash
argument_list|(
name|p21
argument_list|)
argument_list|)
expr_stmt|;
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|pA
argument_list|(
literal|0x12345678
argument_list|,
literal|0x12345678
argument_list|)
decl_stmt|;
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|pB
argument_list|(
literal|0x12345675
argument_list|,
literal|0x12345675
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|qHash
argument_list|(
name|pA
argument_list|)
operator|!=
name|qHash
argument_list|(
name|pB
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|fp_qhash_of_zero_is_zero
name|void
name|tst_QHashFunctions
operator|::
name|fp_qhash_of_zero_is_zero
parameter_list|()
block|{
name|QCOMPARE
argument_list|(
name|qHash
argument_list|(
operator|-
literal|0.0f
argument_list|)
argument_list|,
literal|0U
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|qHash
argument_list|(
literal|0.0f
argument_list|)
argument_list|,
literal|0U
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|qHash
argument_list|(
operator|-
literal|0.0
argument_list|)
argument_list|,
literal|0U
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|qHash
argument_list|(
literal|0.0
argument_list|)
argument_list|,
literal|0U
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_DARWIN
name|QCOMPARE
argument_list|(
name|qHash
argument_list|(
operator|-
literal|0.0L
argument_list|)
argument_list|,
literal|0U
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|qHash
argument_list|(
literal|0.0L
argument_list|)
argument_list|,
literal|0U
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|qthash_data
name|void
name|tst_QHashFunctions
operator|::
name|qthash_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"key"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|uint
argument_list|>
argument_list|(
literal|"hash"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"null"
argument_list|)
operator|<<
name|QString
argument_list|()
operator|<<
literal|0u
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"empty"
argument_list|)
operator|<<
name|QStringLiteral
argument_list|(
literal|""
argument_list|)
operator|<<
literal|0u
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"abcdef"
argument_list|)
operator|<<
name|QStringLiteral
argument_list|(
literal|"abcdef"
argument_list|)
operator|<<
literal|108567222u
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"tqbfjotld"
argument_list|)
operator|<<
name|QStringLiteral
argument_list|(
literal|"The quick brown fox jumps over the lazy dog"
argument_list|)
operator|<<
literal|140865879u
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"42"
argument_list|)
operator|<<
name|QStringLiteral
argument_list|(
literal|"42"
argument_list|)
operator|<<
literal|882u
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qthash
name|void
name|tst_QHashFunctions
operator|::
name|qthash
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|key
argument_list|)
expr_stmt|;
specifier|const
name|uint
name|result
init|=
name|qt_hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|QTEST
argument_list|(
name|result
argument_list|,
literal|"hash"
argument_list|)
expr_stmt|;
block|}
end_function
begin_namespace
DECL|namespace|SomeNamespace
namespace|namespace
name|SomeNamespace
block|{
DECL|struct|Hashable
DECL|member|i
struct|struct
name|Hashable
block|{
name|int
name|i
decl_stmt|;
block|}
struct|;
DECL|function|qHash
specifier|inline
name|uint
name|qHash
parameter_list|(
name|Hashable
name|h
parameter_list|,
name|uint
name|seed
init|=
literal|0
parameter_list|)
block|{
return|return
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qHash
argument_list|)
argument_list|(
name|h
operator|.
name|i
argument_list|,
name|seed
argument_list|)
return|;
block|}
block|}
end_namespace
begin_function
DECL|function|range
name|void
name|tst_QHashFunctions
operator|::
name|range
parameter_list|()
block|{
specifier|static
specifier|const
name|int
name|ints
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
specifier|static
specifier|const
name|size_t
name|numInts
init|=
sizeof|sizeof
name|ints
operator|/
sizeof|sizeof
expr|*
name|ints
decl_stmt|;
comment|// empty range just gives the seed:
name|QCOMPARE
argument_list|(
name|qHashRange
argument_list|(
name|ints
argument_list|,
name|ints
argument_list|,
literal|0xdeadbeefU
argument_list|)
argument_list|,
literal|0xdeadbeefU
argument_list|)
expr_stmt|;
comment|// verify that order matters:
name|QVERIFY
argument_list|(
name|qHashRange
argument_list|(
name|ints
argument_list|,
name|ints
operator|+
name|numInts
argument_list|)
operator|!=
name|qHashRange
argument_list|(
name|std
operator|::
name|reverse_iterator
argument_list|<
specifier|const
name|int
operator|*
argument_list|>
argument_list|(
name|ints
operator|+
name|numInts
argument_list|)
argument_list|,
name|std
operator|::
name|reverse_iterator
argument_list|<
specifier|const
name|int
operator|*
argument_list|>
argument_list|(
name|ints
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|{
comment|// verify that the input iterator category suffices:
name|std
operator|::
name|stringstream
name|sstream
decl_stmt|;
name|Q_STATIC_ASSERT
argument_list|(
operator|(
name|QtPrivate
operator|::
name|is_same
argument_list|<
name|std
operator|::
name|input_iterator_tag
argument_list|,
name|std
operator|::
name|istream_iterator
argument_list|<
name|int
argument_list|>
operator|::
name|iterator_category
argument_list|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
name|std
operator|::
name|copy
argument_list|(
name|ints
argument_list|,
name|ints
operator|+
name|numInts
argument_list|,
name|std
operator|::
name|ostream_iterator
argument_list|<
name|int
argument_list|>
argument_list|(
name|sstream
argument_list|,
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
name|sstream
operator|.
name|seekg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|std
operator|::
name|istream_iterator
argument_list|<
name|int
argument_list|>
name|it
argument_list|(
name|sstream
argument_list|)
decl_stmt|,
name|end
decl_stmt|;
name|QCOMPARE
argument_list|(
name|qHashRange
argument_list|(
name|ints
argument_list|,
name|ints
operator|+
name|numInts
argument_list|)
argument_list|,
name|qHashRange
argument_list|(
name|it
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SomeNamespace
operator|::
name|Hashable
name|hashables
index|[]
init|=
block|{
block|{
literal|0
block|}
block|,
block|{
literal|1
block|}
block|,
block|{
literal|2
block|}
block|,
block|{
literal|3
block|}
block|,
block|{
literal|4
block|}
block|,
block|{
literal|5
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|size_t
name|numHashables
init|=
sizeof|sizeof
name|hashables
operator|/
sizeof|sizeof
expr|*
name|hashables
decl_stmt|;
comment|// compile check: is qHash() found using ADL?
operator|(
name|void
operator|)
name|qHashRange
argument_list|(
name|hashables
argument_list|,
name|hashables
operator|+
name|numHashables
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|rangeCommutative
name|void
name|tst_QHashFunctions
operator|::
name|rangeCommutative
parameter_list|()
block|{
name|int
name|ints
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
specifier|static
specifier|const
name|size_t
name|numInts
init|=
sizeof|sizeof
name|ints
operator|/
sizeof|sizeof
expr|*
name|ints
decl_stmt|;
comment|// empty range just gives the seed:
name|QCOMPARE
argument_list|(
name|qHashRangeCommutative
argument_list|(
name|ints
argument_list|,
name|ints
argument_list|,
literal|0xdeadbeefU
argument_list|)
argument_list|,
literal|0xdeadbeefU
argument_list|)
expr_stmt|;
comment|// verify that order doesn't matter:
name|QCOMPARE
argument_list|(
name|qHashRangeCommutative
argument_list|(
name|ints
argument_list|,
name|ints
operator|+
name|numInts
argument_list|)
argument_list|,
name|qHashRangeCommutative
argument_list|(
name|std
operator|::
name|reverse_iterator
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|ints
operator|+
name|numInts
argument_list|)
argument_list|,
name|std
operator|::
name|reverse_iterator
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|ints
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|{
comment|// verify that the input iterator category suffices:
name|std
operator|::
name|stringstream
name|sstream
decl_stmt|;
name|std
operator|::
name|copy
argument_list|(
name|ints
argument_list|,
name|ints
operator|+
name|numInts
argument_list|,
name|std
operator|::
name|ostream_iterator
argument_list|<
name|int
argument_list|>
argument_list|(
name|sstream
argument_list|,
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
name|sstream
operator|.
name|seekg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|std
operator|::
name|istream_iterator
argument_list|<
name|int
argument_list|>
name|it
argument_list|(
name|sstream
argument_list|)
decl_stmt|,
name|end
decl_stmt|;
name|QCOMPARE
argument_list|(
name|qHashRangeCommutative
argument_list|(
name|ints
argument_list|,
name|ints
operator|+
name|numInts
argument_list|)
argument_list|,
name|qHashRangeCommutative
argument_list|(
name|it
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SomeNamespace
operator|::
name|Hashable
name|hashables
index|[]
init|=
block|{
block|{
literal|0
block|}
block|,
block|{
literal|1
block|}
block|,
block|{
literal|2
block|}
block|,
block|{
literal|3
block|}
block|,
block|{
literal|4
block|}
block|,
block|{
literal|5
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|size_t
name|numHashables
init|=
sizeof|sizeof
name|hashables
operator|/
sizeof|sizeof
expr|*
name|hashables
decl_stmt|;
comment|// compile check: is qHash() found using ADL?
operator|(
name|void
operator|)
name|qHashRangeCommutative
argument_list|(
name|hashables
argument_list|,
name|hashables
operator|+
name|numHashables
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QTEST_APPLESS_MAIN
argument_list|(
argument|tst_QHashFunctions
argument_list|)
end_macro
begin_include
include|#
directive|include
file|"tst_qhashfunctions.moc"
end_include
end_unit
