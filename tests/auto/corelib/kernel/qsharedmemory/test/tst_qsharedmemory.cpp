begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the test suite of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_include
include|#
directive|include
file|<QFile>
end_include
begin_include
include|#
directive|include
file|<QProcess>
end_include
begin_include
include|#
directive|include
file|<QSharedMemory>
end_include
begin_include
include|#
directive|include
file|<QTest>
end_include
begin_include
include|#
directive|include
file|<QThread>
end_include
begin_define
DECL|macro|EXISTING_SHARE
define|#
directive|define
name|EXISTING_SHARE
value|"existing"
end_define
begin_define
DECL|macro|EXISTING_SIZE
define|#
directive|define
name|EXISTING_SIZE
value|1024
end_define
begin_macro
name|Q_DECLARE_METATYPE
argument_list|(
argument|QSharedMemory::SharedMemoryError
argument_list|)
end_macro
begin_macro
name|Q_DECLARE_METATYPE
argument_list|(
argument|QSharedMemory::AccessMode
argument_list|)
end_macro
begin_class
DECL|class|tst_QSharedMemory
class|class
name|tst_QSharedMemory
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
name|tst_QSharedMemory
parameter_list|()
constructor_decl|;
specifier|virtual
name|~
name|tst_QSharedMemory
parameter_list|()
destructor_decl|;
public|public
name|Q_SLOTS
public|:
name|void
name|init
parameter_list|()
function_decl|;
name|void
name|initTestCase
parameter_list|()
function_decl|;
name|void
name|cleanup
parameter_list|()
function_decl|;
private|private
name|slots
private|:
comment|// basics
name|void
name|constructor
parameter_list|()
function_decl|;
name|void
name|key_data
parameter_list|()
function_decl|;
name|void
name|key
parameter_list|()
function_decl|;
name|void
name|create_data
parameter_list|()
function_decl|;
name|void
name|create
parameter_list|()
function_decl|;
name|void
name|attach_data
parameter_list|()
function_decl|;
name|void
name|attach
parameter_list|()
function_decl|;
name|void
name|lock
parameter_list|()
function_decl|;
comment|// custom edge cases
ifndef|#
directive|ifndef
name|Q_OS_HPUX
name|void
name|removeWhileAttached
parameter_list|()
function_decl|;
endif|#
directive|endif
name|void
name|emptyMemory
parameter_list|()
function_decl|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_PROCESS
argument_list|)
name|void
name|readOnly
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|// basics all together
ifndef|#
directive|ifndef
name|Q_OS_HPUX
name|void
name|simpleProducerConsumer_data
parameter_list|()
function_decl|;
name|void
name|simpleProducerConsumer
parameter_list|()
function_decl|;
name|void
name|simpleDoubleProducerConsumer
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|// with threads
name|void
name|simpleThreadedProducerConsumer_data
parameter_list|()
function_decl|;
name|void
name|simpleThreadedProducerConsumer
parameter_list|()
function_decl|;
comment|// with processes
ifndef|#
directive|ifndef
name|QT_NO_PROCESS
name|void
name|simpleProcessProducerConsumer_data
parameter_list|()
function_decl|;
name|void
name|simpleProcessProducerConsumer
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|// extreme cases
name|void
name|useTooMuchMemory
parameter_list|()
function_decl|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|void
name|attachTooMuch
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|// unique keys
name|void
name|uniqueKey_data
parameter_list|()
function_decl|;
name|void
name|uniqueKey
parameter_list|()
function_decl|;
protected|protected:
name|QString
name|helperBinary
parameter_list|()
function_decl|;
name|int
name|remove
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
function_decl|;
DECL|function|rememberKey
name|QString
name|rememberKey
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
name|EXISTING_SHARE
condition|)
return|return
name|key
return|;
if|if
condition|(
operator|!
name|keys
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|keys
operator|.
name|append
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|key
return|;
block|}
DECL|member|keys
name|QStringList
name|keys
decl_stmt|;
DECL|member|jail
name|QList
argument_list|<
name|QSharedMemory
modifier|*
argument_list|>
name|jail
decl_stmt|;
DECL|member|existingSharedMemory
name|QSharedMemory
modifier|*
name|existingSharedMemory
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|tst_QSharedMemory
name|tst_QSharedMemory
operator|::
name|tst_QSharedMemory
parameter_list|()
member_init_list|:
name|existingSharedMemory
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~tst_QSharedMemory
name|tst_QSharedMemory
operator|::
name|~
name|tst_QSharedMemory
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|initTestCase
name|void
name|tst_QSharedMemory
operator|::
name|initTestCase
parameter_list|()
block|{
name|QVERIFY2
argument_list|(
operator|!
name|helperBinary
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"Could not find helper binary"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|tst_QSharedMemory
operator|::
name|init
parameter_list|()
block|{
name|existingSharedMemory
operator|=
operator|new
name|QSharedMemory
argument_list|(
name|EXISTING_SHARE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|existingSharedMemory
operator|->
name|create
argument_list|(
name|EXISTING_SIZE
argument_list|)
condition|)
block|{
name|QVERIFY
argument_list|(
name|existingSharedMemory
operator|->
name|error
argument_list|()
operator|==
name|QSharedMemory
operator|::
name|AlreadyExists
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|cleanup
name|void
name|tst_QSharedMemory
operator|::
name|cleanup
parameter_list|()
block|{
operator|delete
name|existingSharedMemory
expr_stmt|;
name|qDeleteAll
argument_list|(
name|jail
operator|.
name|begin
argument_list|()
argument_list|,
name|jail
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|jail
operator|.
name|clear
argument_list|()
expr_stmt|;
name|keys
operator|.
name|append
argument_list|(
name|EXISTING_SHARE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSharedMemory
name|sm
argument_list|(
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sm
operator|.
name|create
argument_list|(
literal|1024
argument_list|)
condition|)
block|{
comment|//if (sm.error() != QSharedMemory::KeyError)
comment|//    qWarning()<< "test cleanup: remove failed:"<< keys.at(i)<< sm.error()<< sm.errorString();
name|sm
operator|.
name|attach
argument_list|()
expr_stmt|;
name|sm
operator|.
name|detach
argument_list|()
expr_stmt|;
name|remove
argument_list|(
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_WIN
end_ifndef
begin_include
include|#
directive|include
file|<private/qsharedmemory_p.h>
end_include
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<sys/ipc.h>
end_include
begin_include
include|#
directive|include
file|<sys/shm.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|helperBinary
name|QString
name|tst_QSharedMemory
operator|::
name|helperBinary
parameter_list|()
block|{
name|QString
name|binary
init|=
name|QStringLiteral
argument_list|(
literal|"helperbinary"
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|binary
operator|+=
name|QStringLiteral
argument_list|(
literal|".exe"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|QFINDTESTDATA
argument_list|(
name|binary
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|remove
name|int
name|tst_QSharedMemory
operator|::
name|remove
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|Q_OS_WIN
comment|// On unix the shared memory might exists from a previously failed test
comment|// or segfault, remove it it does
if|if
condition|(
name|key
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
comment|// ftok requires that an actual file exists somewhere
name|QString
name|fileName
init|=
name|QSharedMemoryPrivate
operator|::
name|makePlatformSafeKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
comment|//qDebug()<< "exits failed";
return|return
operator|-
literal|2
return|;
block|}
name|int
name|unix_key
init|=
name|ftok
argument_list|(
name|fileName
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
literal|'Q'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|unix_key
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"ftok failed"
expr_stmt|;
return|return
operator|-
literal|3
return|;
block|}
name|int
name|id
init|=
name|shmget
argument_list|(
name|unix_key
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|)
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|id
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"shmget failed"
operator|<<
name|strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
return|return
operator|-
literal|4
return|;
block|}
name|struct
name|shmid_ds
name|shmid_ds
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|shmctl
argument_list|(
name|id
argument_list|,
name|IPC_RMID
argument_list|,
operator|&
name|shmid_ds
argument_list|)
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"shmctl failed"
expr_stmt|;
return|return
operator|-
literal|5
return|;
block|}
return|return
name|QFile
operator|::
name|remove
argument_list|(
name|fileName
argument_list|)
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Tests the default values  */
end_comment
begin_function
DECL|function|constructor
name|void
name|tst_QSharedMemory
operator|::
name|constructor
parameter_list|()
block|{
name|QSharedMemory
name|sm
decl_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|key
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|sm
operator|.
name|isAttached
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|data
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|size
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|error
argument_list|()
argument_list|,
name|QSharedMemory
operator|::
name|NoError
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|errorString
argument_list|()
operator|==
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|key_data
name|void
name|tst_QSharedMemory
operator|::
name|key_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"constructorKey"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"setKey"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"setNativeKey"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"null, null, null"
argument_list|)
operator|<<
name|QString
argument_list|()
operator|<<
name|QString
argument_list|()
operator|<<
name|QString
argument_list|()
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"one, null, null"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"one"
argument_list|)
operator|<<
name|QString
argument_list|()
operator|<<
name|QString
argument_list|()
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"null, one, null"
argument_list|)
operator|<<
name|QString
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"one"
argument_list|)
operator|<<
name|QString
argument_list|()
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"null, null, one"
argument_list|)
operator|<<
name|QString
argument_list|()
operator|<<
name|QString
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"one"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"one, two, null"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"one"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"two"
argument_list|)
operator|<<
name|QString
argument_list|()
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"one, null, two"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"one"
argument_list|)
operator|<<
name|QString
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"two"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"null, one, two"
argument_list|)
operator|<<
name|QString
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"one"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"two"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"one, two, three"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"one"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"two"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"three"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"invalid"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"o/e"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"t/o"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"|x"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Basic key testing  */
end_comment
begin_function
DECL|function|key
name|void
name|tst_QSharedMemory
operator|::
name|key
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|constructorKey
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|setKey
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|setNativeKey
argument_list|)
expr_stmt|;
name|QSharedMemory
name|sm
argument_list|(
name|constructorKey
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|key
argument_list|()
argument_list|,
name|constructorKey
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|nativeKey
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|constructorKey
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|sm
operator|.
name|setKey
argument_list|(
name|setKey
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|key
argument_list|()
argument_list|,
name|setKey
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|nativeKey
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|setKey
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|sm
operator|.
name|setNativeKey
argument_list|(
name|setNativeKey
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|key
argument_list|()
operator|.
name|isNull
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|nativeKey
argument_list|()
argument_list|,
name|setNativeKey
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|isAttached
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|error
argument_list|()
argument_list|,
name|QSharedMemory
operator|::
name|NoError
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|errorString
argument_list|()
operator|==
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|data
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|size
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|detach
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|create_data
name|void
name|tst_QSharedMemory
operator|::
name|create_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"key"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"size"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"canCreate"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|QSharedMemory
operator|::
name|SharedMemoryError
argument_list|>
argument_list|(
literal|"error"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"null key"
argument_list|)
operator|<<
name|QString
argument_list|()
operator|<<
literal|1024
operator|<<
literal|false
operator|<<
name|QSharedMemory
operator|::
name|KeyError
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"-1 size"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"negsize"
argument_list|)
operator|<<
operator|-
literal|1
operator|<<
literal|false
operator|<<
name|QSharedMemory
operator|::
name|InvalidSize
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"nor size"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"norsize"
argument_list|)
operator|<<
literal|1024
operator|<<
literal|true
operator|<<
name|QSharedMemory
operator|::
name|NoError
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"already exists"
argument_list|)
operator|<<
name|QString
argument_list|(
name|EXISTING_SHARE
argument_list|)
operator|<<
name|EXISTING_SIZE
operator|<<
literal|false
operator|<<
name|QSharedMemory
operator|::
name|AlreadyExists
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Basic create testing  */
end_comment
begin_function
DECL|function|create
name|void
name|tst_QSharedMemory
operator|::
name|create
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|canCreate
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|QSharedMemory
operator|::
name|SharedMemoryError
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|QSharedMemory
name|sm
argument_list|(
name|rememberKey
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|create
argument_list|(
name|size
argument_list|)
argument_list|,
name|canCreate
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|.
name|error
argument_list|()
operator|!=
name|error
condition|)
name|qDebug
argument_list|()
operator|<<
name|sm
operator|.
name|errorString
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|key
argument_list|()
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|canCreate
condition|)
block|{
name|QVERIFY
argument_list|(
name|sm
operator|.
name|errorString
argument_list|()
operator|==
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|data
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|size
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QVERIFY
argument_list|(
name|sm
operator|.
name|data
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|errorString
argument_list|()
operator|!=
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|attach_data
name|void
name|tst_QSharedMemory
operator|::
name|attach_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"key"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"exists"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|QSharedMemory
operator|::
name|SharedMemoryError
argument_list|>
argument_list|(
literal|"error"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"null key"
argument_list|)
operator|<<
name|QString
argument_list|()
operator|<<
literal|false
operator|<<
name|QSharedMemory
operator|::
name|KeyError
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"doesn't exists"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"doesntexists"
argument_list|)
operator|<<
literal|false
operator|<<
name|QSharedMemory
operator|::
name|NotFound
expr_stmt|;
comment|// HPUX doesn't allow for multiple attaches per process.
ifndef|#
directive|ifndef
name|Q_OS_HPUX
name|QTest
operator|::
name|newRow
argument_list|(
literal|"already exists"
argument_list|)
operator|<<
name|QString
argument_list|(
name|EXISTING_SHARE
argument_list|)
operator|<<
literal|true
operator|<<
name|QSharedMemory
operator|::
name|NoError
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Basic attach/detach testing  */
end_comment
begin_function
DECL|function|attach
name|void
name|tst_QSharedMemory
operator|::
name|attach
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|exists
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|QSharedMemory
operator|::
name|SharedMemoryError
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|QSharedMemory
name|sm
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|attach
argument_list|()
argument_list|,
name|exists
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|isAttached
argument_list|()
argument_list|,
name|exists
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|error
argument_list|()
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|key
argument_list|()
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
name|QVERIFY
argument_list|(
name|sm
operator|.
name|data
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|size
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|errorString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|detach
argument_list|()
argument_list|)
expr_stmt|;
comment|// Make sure detach doesn't screw up something and we can't re-attach.
name|QVERIFY
argument_list|(
name|sm
operator|.
name|attach
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|data
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|size
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|detach
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|.
name|size
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|data
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QVERIFY
argument_list|(
name|sm
operator|.
name|data
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|size
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|errorString
argument_list|()
operator|!=
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|sm
operator|.
name|detach
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|lock
name|void
name|tst_QSharedMemory
operator|::
name|lock
parameter_list|()
block|{
name|QSharedMemory
name|shm
decl_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|shm
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|shm
operator|.
name|error
argument_list|()
argument_list|,
name|QSharedMemory
operator|::
name|LockError
argument_list|)
expr_stmt|;
name|shm
operator|.
name|setKey
argument_list|(
name|QLatin1String
argument_list|(
literal|"qsharedmemory"
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|shm
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|shm
operator|.
name|error
argument_list|()
argument_list|,
name|QSharedMemory
operator|::
name|LockError
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|shm
operator|.
name|create
argument_list|(
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|shm
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|ignoreMessage
argument_list|(
name|QtWarningMsg
argument_list|,
literal|"QSharedMemory::lock: already locked"
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|shm
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
comment|// we didn't unlock(), so ignore the warning from auto-detach in destructor
name|QTest
operator|::
name|ignoreMessage
argument_list|(
name|QtWarningMsg
argument_list|,
literal|"QSharedMemory::lock: already locked"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Other shared memory are allowed to be attached after we remove,     but new shared memory are not allowed to attach after a remove.  */
end_comment
begin_comment
comment|// HPUX doesn't allow for multiple attaches per process.
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_HPUX
end_ifndef
begin_function
DECL|function|removeWhileAttached
name|void
name|tst_QSharedMemory
operator|::
name|removeWhileAttached
parameter_list|()
block|{
name|rememberKey
argument_list|(
literal|"one"
argument_list|)
expr_stmt|;
comment|// attach 1
name|QSharedMemory
modifier|*
name|smOne
init|=
operator|new
name|QSharedMemory
argument_list|(
name|QLatin1String
argument_list|(
literal|"one"
argument_list|)
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|smOne
operator|->
name|create
argument_list|(
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|smOne
operator|->
name|isAttached
argument_list|()
argument_list|)
expr_stmt|;
comment|// attach 2
name|QSharedMemory
modifier|*
name|smTwo
init|=
operator|new
name|QSharedMemory
argument_list|(
name|QLatin1String
argument_list|(
literal|"one"
argument_list|)
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|smTwo
operator|->
name|attach
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|smTwo
operator|->
name|isAttached
argument_list|()
argument_list|)
expr_stmt|;
comment|// detach 1 and remove, remove one first to catch another error.
operator|delete
name|smOne
expr_stmt|;
operator|delete
name|smTwo
expr_stmt|;
comment|// three shouldn't be able to attach
name|QSharedMemory
name|smThree
argument_list|(
name|QLatin1String
argument_list|(
literal|"one"
argument_list|)
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|smThree
operator|.
name|attach
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|smThree
operator|.
name|error
argument_list|()
argument_list|,
name|QSharedMemory
operator|::
name|NotFound
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     The memory should be set to 0 after created.  */
end_comment
begin_function
DECL|function|emptyMemory
name|void
name|tst_QSharedMemory
operator|::
name|emptyMemory
parameter_list|()
block|{
name|QSharedMemory
name|sm
argument_list|(
name|rememberKey
argument_list|(
name|QLatin1String
argument_list|(
literal|"voidland"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|size
init|=
literal|1024
decl_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|.
name|create
argument_list|(
name|size
argument_list|,
name|QSharedMemory
operator|::
name|ReadOnly
argument_list|)
argument_list|)
expr_stmt|;
name|char
modifier|*
name|get
init|=
operator|(
name|char
operator|*
operator|)
name|sm
operator|.
name|data
argument_list|()
decl_stmt|;
name|char
name|null
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
name|QCOMPARE
argument_list|(
name|get
index|[
name|i
index|]
argument_list|,
name|null
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Verify that attach with ReadOnly is actually read only     by writing to data and causing a segfault. */
end_comment
begin_comment
comment|// This test opens a crash dialog on Windows.
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_PROCESS
argument_list|)
end_if
begin_function
DECL|function|readOnly
name|void
name|tst_QSharedMemory
operator|::
name|readOnly
parameter_list|()
block|{
name|rememberKey
argument_list|(
literal|"readonly_segfault"
argument_list|)
expr_stmt|;
comment|// ### on windows disable the popup somehow
name|QProcess
name|p
decl_stmt|;
name|p
operator|.
name|start
argument_list|(
name|helperBinary
argument_list|()
argument_list|,
name|QStringList
argument_list|(
literal|"readonly_segfault"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|setProcessChannelMode
argument_list|(
name|QProcess
operator|::
name|ForwardedChannels
argument_list|)
expr_stmt|;
name|p
operator|.
name|waitForFinished
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|p
operator|.
name|error
argument_list|()
argument_list|,
name|QProcess
operator|::
name|Crashed
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Keep making shared memory until the kernel stops us.  */
end_comment
begin_function
DECL|function|useTooMuchMemory
name|void
name|tst_QSharedMemory
operator|::
name|useTooMuchMemory
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_OS_LINUX
name|bool
name|success
init|=
literal|true
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|success
condition|)
block|{
name|QString
name|key
init|=
name|QString
argument_list|(
literal|"maxmemorytest_%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|count
operator|++
argument_list|)
decl_stmt|;
name|QSharedMemory
modifier|*
name|sm
init|=
operator|new
name|QSharedMemory
argument_list|(
name|rememberKey
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|jail
operator|.
name|append
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|int
name|size
init|=
literal|32768
operator|*
literal|1024
decl_stmt|;
name|success
operator|=
name|sm
operator|->
name|create
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
operator|&&
name|sm
operator|->
name|error
argument_list|()
operator|==
name|QSharedMemory
operator|::
name|AlreadyExists
condition|)
block|{
comment|// left over from a crash, clean it up
name|sm
operator|->
name|attach
argument_list|()
expr_stmt|;
name|sm
operator|->
name|detach
argument_list|()
expr_stmt|;
name|success
operator|=
name|sm
operator|->
name|create
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|QVERIFY
argument_list|(
operator|!
name|sm
operator|->
name|isAttached
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|->
name|key
argument_list|()
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|sm
operator|->
name|size
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|->
name|data
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|error
argument_list|()
operator|!=
name|QSharedMemory
operator|::
name|OutOfResources
condition|)
name|qDebug
argument_list|()
operator|<<
name|sm
operator|->
name|error
argument_list|()
operator|<<
name|sm
operator|->
name|errorString
argument_list|()
expr_stmt|;
comment|// ### Linux wont return OutOfResources if there are not enough semaphores to use.
name|QVERIFY
argument_list|(
name|sm
operator|->
name|error
argument_list|()
operator|==
name|QSharedMemory
operator|::
name|OutOfResources
operator|||
name|sm
operator|->
name|error
argument_list|()
operator|==
name|QSharedMemory
operator|::
name|LockError
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|sm
operator|->
name|errorString
argument_list|()
operator|!=
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|sm
operator|->
name|attach
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|sm
operator|->
name|detach
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QVERIFY
argument_list|(
name|sm
operator|->
name|isAttached
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Create one shared memory (government) and see how many other shared memories (wars) we can     attach before the system runs out of resources.  */
end_comment
begin_comment
comment|// HPUX doesn't allow for multiple attaches per process.
end_comment
begin_comment
comment|// For WinCE, this test nearly kills the system, so skip it.
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_function
DECL|function|attachTooMuch
name|void
name|tst_QSharedMemory
operator|::
name|attachTooMuch
parameter_list|()
block|{
name|QSKIP
argument_list|(
literal|"disabled"
argument_list|)
expr_stmt|;
name|QSharedMemory
name|government
argument_list|(
name|rememberKey
argument_list|(
literal|"government"
argument_list|)
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|government
operator|.
name|create
argument_list|(
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|QSharedMemory
modifier|*
name|war
init|=
operator|new
name|QSharedMemory
argument_list|(
name|government
operator|.
name|key
argument_list|()
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|war
argument_list|)
expr_stmt|;
name|jail
operator|.
name|append
argument_list|(
name|war
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|war
operator|->
name|attach
argument_list|()
condition|)
block|{
name|QVERIFY
argument_list|(
operator|!
name|war
operator|->
name|isAttached
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|war
operator|->
name|key
argument_list|()
argument_list|,
name|government
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|war
operator|->
name|size
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|war
operator|->
name|data
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|war
operator|->
name|error
argument_list|()
argument_list|,
name|QSharedMemory
operator|::
name|OutOfResources
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|war
operator|->
name|errorString
argument_list|()
operator|!=
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|war
operator|->
name|detach
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|QVERIFY
argument_list|(
name|war
operator|->
name|isAttached
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// HPUX doesn't allow for multiple attaches per process.
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_HPUX
end_ifndef
begin_function
DECL|function|simpleProducerConsumer_data
name|void
name|tst_QSharedMemory
operator|::
name|simpleProducerConsumer_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|QSharedMemory
operator|::
name|AccessMode
argument_list|>
argument_list|(
literal|"mode"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"readonly"
argument_list|)
operator|<<
name|QSharedMemory
operator|::
name|ReadOnly
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"readwrite"
argument_list|)
operator|<<
name|QSharedMemory
operator|::
name|ReadWrite
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     The basic consumer producer that rounds out the basic testing.     If this fails then any muli-threading/process might fail (but be     harder to debug)      This doesn't require nor test any locking system.  */
end_comment
begin_function
DECL|function|simpleProducerConsumer
name|void
name|tst_QSharedMemory
operator|::
name|simpleProducerConsumer
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QSharedMemory
operator|::
name|AccessMode
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|rememberKey
argument_list|(
name|QLatin1String
argument_list|(
literal|"market"
argument_list|)
argument_list|)
expr_stmt|;
name|QSharedMemory
name|producer
argument_list|(
name|QLatin1String
argument_list|(
literal|"market"
argument_list|)
argument_list|)
decl_stmt|;
name|QSharedMemory
name|consumer
argument_list|(
name|QLatin1String
argument_list|(
literal|"market"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|size
init|=
literal|512
decl_stmt|;
name|QVERIFY
argument_list|(
name|producer
operator|.
name|create
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|consumer
operator|.
name|attach
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|char
modifier|*
name|put
init|=
operator|(
name|char
operator|*
operator|)
name|producer
operator|.
name|data
argument_list|()
decl_stmt|;
name|char
modifier|*
name|get
init|=
operator|(
name|char
operator|*
operator|)
name|consumer
operator|.
name|data
argument_list|()
decl_stmt|;
comment|// On Windows CE you always have ReadWrite access. Thus
comment|// ViewMapOfFile returns the same pointer
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|QVERIFY
argument_list|(
name|put
operator|!=
name|get
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|put
index|[
name|i
index|]
operator|=
literal|'Q'
expr_stmt|;
name|QCOMPARE
argument_list|(
name|get
index|[
name|i
index|]
argument_list|,
literal|'Q'
argument_list|)
expr_stmt|;
block|}
name|QVERIFY
argument_list|(
name|consumer
operator|.
name|detach
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// HPUX doesn't allow for multiple attaches per process.
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_HPUX
end_ifndef
begin_function
DECL|function|simpleDoubleProducerConsumer
name|void
name|tst_QSharedMemory
operator|::
name|simpleDoubleProducerConsumer
parameter_list|()
block|{
name|rememberKey
argument_list|(
name|QLatin1String
argument_list|(
literal|"market"
argument_list|)
argument_list|)
expr_stmt|;
name|QSharedMemory
name|producer
argument_list|(
name|QLatin1String
argument_list|(
literal|"market"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|size
init|=
literal|512
decl_stmt|;
name|QVERIFY
argument_list|(
name|producer
operator|.
name|create
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|producer
operator|.
name|detach
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|producer
operator|.
name|create
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|QSharedMemory
name|consumer
argument_list|(
name|QLatin1String
argument_list|(
literal|"market"
argument_list|)
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|consumer
operator|.
name|attach
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_class
DECL|class|Consumer
class|class
name|Consumer
super|:
specifier|public
name|QThread
block|{
public|public:
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|QSharedMemory
name|consumer
argument_list|(
name|QLatin1String
argument_list|(
literal|"market"
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|consumer
operator|.
name|attach
argument_list|()
condition|)
block|{
if|if
condition|(
name|consumer
operator|.
name|error
argument_list|()
operator|!=
name|QSharedMemory
operator|::
name|NotFound
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"consumer: failed to connect"
operator|<<
name|consumer
operator|.
name|error
argument_list|()
operator|<<
name|consumer
operator|.
name|errorString
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|consumer
operator|.
name|error
argument_list|()
operator|==
name|QSharedMemory
operator|::
name|NotFound
operator|||
name|consumer
operator|.
name|error
argument_list|()
operator|==
name|QSharedMemory
operator|::
name|KeyError
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|qWait
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|char
modifier|*
name|memory
init|=
operator|(
name|char
operator|*
operator|)
name|consumer
operator|.
name|data
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|!
name|consumer
operator|.
name|lock
argument_list|()
condition|)
break|break;
if|if
condition|(
name|memory
index|[
literal|0
index|]
operator|==
literal|'Q'
condition|)
name|memory
index|[
literal|0
index|]
operator|=
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|memory
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
name|memory
index|[
literal|1
index|]
operator|++
expr_stmt|;
name|QVERIFY
argument_list|(
name|consumer
operator|.
name|unlock
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|QVERIFY
argument_list|(
name|consumer
operator|.
name|unlock
argument_list|()
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|qWait
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|QVERIFY
argument_list|(
name|consumer
operator|.
name|detach
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
class|;
end_class
begin_class
DECL|class|Producer
class|class
name|Producer
super|:
specifier|public
name|QThread
block|{
public|public:
DECL|function|Producer
name|Producer
parameter_list|()
member_init_list|:
name|producer
argument_list|(
name|QLatin1String
argument_list|(
literal|"market"
argument_list|)
argument_list|)
block|{
name|int
name|size
init|=
literal|1024
decl_stmt|;
if|if
condition|(
operator|!
name|producer
operator|.
name|create
argument_list|(
name|size
argument_list|)
condition|)
block|{
comment|// left over from a crash...
if|if
condition|(
name|producer
operator|.
name|error
argument_list|()
operator|==
name|QSharedMemory
operator|::
name|AlreadyExists
condition|)
block|{
name|producer
operator|.
name|attach
argument_list|()
expr_stmt|;
name|producer
operator|.
name|detach
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|producer
operator|.
name|create
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|char
modifier|*
name|memory
init|=
operator|(
name|char
operator|*
operator|)
name|producer
operator|.
name|data
argument_list|()
decl_stmt|;
name|memory
index|[
literal|1
index|]
operator|=
literal|'0'
expr_stmt|;
name|QTime
name|timer
decl_stmt|;
name|timer
operator|.
name|start
argument_list|()
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
literal|5
operator|&&
name|timer
operator|.
name|elapsed
argument_list|()
operator|<
literal|5000
condition|)
block|{
name|QVERIFY
argument_list|(
name|producer
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory
index|[
literal|0
index|]
operator|==
literal|'Q'
condition|)
block|{
name|QVERIFY
argument_list|(
name|producer
operator|.
name|unlock
argument_list|()
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|qWait
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|++
name|i
expr_stmt|;
name|memory
index|[
literal|0
index|]
operator|=
literal|'Q'
expr_stmt|;
name|QVERIFY
argument_list|(
name|producer
operator|.
name|unlock
argument_list|()
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|qWait
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// tell everyone to quit
name|QVERIFY
argument_list|(
name|producer
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
name|memory
index|[
literal|0
index|]
operator|=
literal|'E'
expr_stmt|;
name|QVERIFY
argument_list|(
name|producer
operator|.
name|unlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|member|producer
name|QSharedMemory
name|producer
decl_stmt|;
private|private:
block|}
class|;
end_class
begin_function
DECL|function|simpleThreadedProducerConsumer_data
name|void
name|tst_QSharedMemory
operator|::
name|simpleThreadedProducerConsumer_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"producerIsThread"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"threads"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
name|QTest
operator|::
name|newRow
argument_list|(
literal|"1 consumer, producer is thread"
argument_list|)
operator|<<
literal|true
operator|<<
literal|1
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"1 consumer, producer is this"
argument_list|)
operator|<<
literal|false
operator|<<
literal|1
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"5 consumers, producer is thread"
argument_list|)
operator|<<
literal|true
operator|<<
literal|5
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"5 consumers, producer is this"
argument_list|)
operator|<<
literal|false
operator|<<
literal|5
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     The basic producer/consumer, but this time using threads.  */
end_comment
begin_function
DECL|function|simpleThreadedProducerConsumer
name|void
name|tst_QSharedMemory
operator|::
name|simpleThreadedProducerConsumer
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|producerIsThread
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|threads
argument_list|)
expr_stmt|;
name|rememberKey
argument_list|(
name|QLatin1String
argument_list|(
literal|"market"
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|Q_OS_HPUX
operator|&&
name|defined
name|__ia64
name|QSKIP
argument_list|(
literal|"This test locks up on gravlaks.troll.no"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Producer
name|p
decl_stmt|;
name|QVERIFY
argument_list|(
name|p
operator|.
name|producer
operator|.
name|isAttached
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|producerIsThread
condition|)
name|p
operator|.
name|start
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|Consumer
modifier|*
argument_list|>
name|consumers
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threads
condition|;
operator|++
name|i
control|)
block|{
name|consumers
operator|.
name|append
argument_list|(
operator|new
name|Consumer
argument_list|()
argument_list|)
expr_stmt|;
name|consumers
operator|.
name|last
argument_list|()
operator|->
name|start
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|producerIsThread
condition|)
name|p
operator|.
name|run
argument_list|()
expr_stmt|;
name|p
operator|.
name|wait
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|consumers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Consumer
modifier|*
name|c
init|=
name|consumers
operator|.
name|first
argument_list|()
decl_stmt|;
name|QVERIFY
argument_list|(
name|c
operator|->
name|isFinished
argument_list|()
operator|||
name|c
operator|->
name|wait
argument_list|(
literal|5000
argument_list|)
argument_list|)
expr_stmt|;
operator|delete
name|consumers
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PROCESS
end_ifndef
begin_function
DECL|function|simpleProcessProducerConsumer_data
name|void
name|tst_QSharedMemory
operator|::
name|simpleProcessProducerConsumer_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"processes"
argument_list|)
expr_stmt|;
name|int
name|tries
init|=
literal|5
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tries
condition|;
operator|++
name|i
control|)
block|{
name|QTest
operator|::
name|newRow
argument_list|(
literal|"1 process"
argument_list|)
operator|<<
literal|1
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"5 processes"
argument_list|)
operator|<<
literal|5
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Create external processes that produce and consume.  */
end_comment
begin_function
DECL|function|simpleProcessProducerConsumer
name|void
name|tst_QSharedMemory
operator|::
name|simpleProcessProducerConsumer
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|int
argument_list|,
name|processes
argument_list|)
expr_stmt|;
name|rememberKey
argument_list|(
literal|"market"
argument_list|)
expr_stmt|;
name|QProcess
name|producer
decl_stmt|;
name|producer
operator|.
name|start
argument_list|(
name|helperBinary
argument_list|()
argument_list|,
name|QStringList
argument_list|(
literal|"producer"
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY2
argument_list|(
name|producer
operator|.
name|waitForStarted
argument_list|()
argument_list|,
literal|"Could not start helper binary"
argument_list|)
expr_stmt|;
name|QVERIFY2
argument_list|(
name|producer
operator|.
name|waitForReadyRead
argument_list|()
argument_list|,
literal|"Helper process failed to create shared memory segment: "
operator|+
name|producer
operator|.
name|readAllStandardError
argument_list|()
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QProcess
modifier|*
argument_list|>
name|consumers
decl_stmt|;
name|unsigned
name|int
name|failedProcesses
init|=
literal|0
decl_stmt|;
specifier|const
name|QStringList
name|consumerArguments
init|=
name|QStringList
argument_list|(
literal|"consumer"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|processes
condition|;
operator|++
name|i
control|)
block|{
name|QProcess
modifier|*
name|p
init|=
operator|new
name|QProcess
decl_stmt|;
name|p
operator|->
name|setProcessChannelMode
argument_list|(
name|QProcess
operator|::
name|ForwardedChannels
argument_list|)
expr_stmt|;
name|p
operator|->
name|start
argument_list|(
name|helperBinary
argument_list|()
argument_list|,
name|consumerArguments
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|waitForStarted
argument_list|(
literal|2000
argument_list|)
condition|)
name|consumers
operator|.
name|append
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
operator|++
name|failedProcesses
expr_stmt|;
block|}
name|bool
name|consumerFailed
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|consumers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QVERIFY
argument_list|(
name|consumers
operator|.
name|first
argument_list|()
operator|->
name|waitForFinished
argument_list|(
literal|3000
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|consumers
operator|.
name|first
argument_list|()
operator|->
name|state
argument_list|()
operator|==
name|QProcess
operator|::
name|Running
operator|||
name|consumers
operator|.
name|first
argument_list|()
operator|->
name|exitStatus
argument_list|()
operator|!=
name|QProcess
operator|::
name|NormalExit
operator|||
name|consumers
operator|.
name|first
argument_list|()
operator|->
name|exitCode
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|consumerFailed
operator|=
literal|true
expr_stmt|;
block|}
operator|delete
name|consumers
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
block|}
name|QCOMPARE
argument_list|(
name|consumerFailed
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|failedProcesses
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// tell the producer to exit now
name|producer
operator|.
name|write
argument_list|(
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|producer
operator|.
name|waitForBytesWritten
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|producer
operator|.
name|waitForFinished
argument_list|(
literal|5000
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|uniqueKey_data
name|void
name|tst_QSharedMemory
operator|::
name|uniqueKey_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"key1"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"key2"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"null == null"
argument_list|)
operator|<<
name|QString
argument_list|()
operator|<<
name|QString
argument_list|()
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"key == key"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"key"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"key"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"key1 == key1"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"key1"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"key1"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"key != key1"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"key"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"key1"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"ke1y != key1"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"ke1y"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"key1"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"key1 != key2"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"key1"
argument_list|)
operator|<<
name|QString
argument_list|(
literal|"key2"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|uniqueKey
name|void
name|tst_QSharedMemory
operator|::
name|uniqueKey
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|key1
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|key2
argument_list|)
expr_stmt|;
name|QSharedMemory
name|sm1
argument_list|(
name|key1
argument_list|)
decl_stmt|;
name|QSharedMemory
name|sm2
argument_list|(
name|key2
argument_list|)
decl_stmt|;
name|bool
name|setEqual
init|=
operator|(
name|key1
operator|==
name|key2
operator|)
decl_stmt|;
name|bool
name|keyEqual
init|=
operator|(
name|sm1
operator|.
name|key
argument_list|()
operator|==
name|sm2
operator|.
name|key
argument_list|()
operator|)
decl_stmt|;
name|bool
name|nativeEqual
init|=
operator|(
name|sm1
operator|.
name|nativeKey
argument_list|()
operator|==
name|sm2
operator|.
name|nativeKey
argument_list|()
operator|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|keyEqual
argument_list|,
name|setEqual
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|nativeEqual
argument_list|,
name|setEqual
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QTEST_MAIN
argument_list|(
argument|tst_QSharedMemory
argument_list|)
end_macro
begin_include
include|#
directive|include
file|"tst_qsharedmemory.moc"
end_include
end_unit
