begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Thiago Macieira<thiago@kde.org> ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:BSD$ ** You may use this file under the terms of the BSD license as follows: ** ** "Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions are ** met: **   * Redistributions of source code must retain the above copyright **     notice, this list of conditions and the following disclaimer. **   * Redistributions in binary form must reproduce the above copyright **     notice, this list of conditions and the following disclaimer in **     the documentation and/or other materials provided with the **     distribution. **   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names **     of its contributors may be used to endorse or promote products derived **     from this software without specific prior written permission. ** ** ** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR ** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE." ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtCore/QThread>
end_include
begin_include
include|#
directive|include
file|<QtTest/QtTest>
end_include
begin_class
DECL|class|tst_QGlobalStatic
class|class
name|tst_QGlobalStatic
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
private|private
name|Q_SLOTS
private|:
name|void
name|beforeInitialization
parameter_list|()
function_decl|;
name|void
name|api
parameter_list|()
function_decl|;
name|void
name|constVolatile
parameter_list|()
function_decl|;
name|void
name|exception
parameter_list|()
function_decl|;
name|void
name|threadStressTest
parameter_list|()
function_decl|;
name|void
name|afterDestruction
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|const int
argument_list|,
argument|constInt
argument_list|,
argument|(
literal|42
argument|)
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|volatile int
argument_list|,
argument|volatileInt
argument_list|,
argument|(-
literal|47
argument|)
argument_list|)
end_macro
begin_function
DECL|function|otherFunction
name|void
name|otherFunction
parameter_list|()
block|{
comment|// never called
name|constInt
argument_list|()
expr_stmt|;
name|volatileInt
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// do not initialize the following Q_GLOBAL_STATIC
end_comment
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|int
argument_list|,
argument|checkedBeforeInitialization
argument_list|)
end_macro
begin_function
DECL|function|beforeInitialization
name|void
name|tst_QGlobalStatic
operator|::
name|beforeInitialization
parameter_list|()
block|{
name|QVERIFY
argument_list|(
operator|!
name|checkedBeforeInitialization
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|checkedBeforeInitialization
operator|.
name|isDestroyed
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|Type
struct|struct
name|Type
block|{
DECL|member|i
name|int
name|i
decl_stmt|;
block|}
struct|;
end_struct
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|Type
argument_list|,
argument|checkedAfterInitialization
argument_list|)
end_macro
begin_function
DECL|function|api
name|void
name|tst_QGlobalStatic
operator|::
name|api
parameter_list|()
block|{
comment|// check the API
name|QVERIFY
argument_list|(
operator|(
name|Type
operator|*
operator|)
name|checkedAfterInitialization
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|checkedAfterInitialization
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|checkedAfterInitialization
operator|=
name|Type
argument_list|()
expr_stmt|;
operator|*
name|checkedAfterInitialization
argument_list|()
operator|=
name|Type
argument_list|()
expr_stmt|;
name|checkedAfterInitialization
argument_list|()
operator|->
name|i
operator|=
literal|47
expr_stmt|;
name|checkedAfterInitialization
operator|->
name|i
operator|=
literal|42
expr_stmt|;
name|QCOMPARE
argument_list|(
name|checkedAfterInitialization
argument_list|()
operator|->
name|i
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|checkedAfterInitialization
argument_list|()
operator|->
name|i
operator|=
literal|47
expr_stmt|;
name|QCOMPARE
argument_list|(
name|checkedAfterInitialization
operator|->
name|i
argument_list|,
literal|47
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|checkedAfterInitialization
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|checkedAfterInitialization
operator|.
name|isDestroyed
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|constVolatile
name|void
name|tst_QGlobalStatic
operator|::
name|constVolatile
parameter_list|()
block|{
name|QCOMPARE
argument_list|(
operator|*
name|constInt
argument_list|()
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
operator|(
name|int
operator|)
operator|*
name|volatileInt
argument_list|()
argument_list|,
operator|-
literal|47
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
operator|*
name|constInt
argument_list|()
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
operator|(
name|int
operator|)
operator|*
name|volatileInt
argument_list|()
argument_list|,
operator|-
literal|47
argument_list|)
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|ThrowingType
struct|struct
name|ThrowingType
block|{
DECL|member|constructedCount
specifier|static
name|QBasicAtomicInt
name|constructedCount
decl_stmt|;
DECL|member|destructedCount
specifier|static
name|QBasicAtomicInt
name|destructedCount
decl_stmt|;
DECL|function|ThrowingType
name|ThrowingType
parameter_list|(
name|QBasicAtomicInt
modifier|&
name|throwControl
parameter_list|)
block|{
name|constructedCount
operator|.
name|ref
argument_list|()
expr_stmt|;
if|if
condition|(
name|throwControl
operator|.
name|fetchAndAddRelaxed
argument_list|(
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
throw|throw
literal|0
throw|;
block|}
DECL|function|~ThrowingType
name|~
name|ThrowingType
parameter_list|()
block|{
name|destructedCount
operator|.
name|ref
argument_list|()
expr_stmt|;
block|}
block|}
struct|;
end_struct
begin_decl_stmt
DECL|member|constructedCount
name|QBasicAtomicInt
name|ThrowingType
operator|::
name|constructedCount
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|destructedCount
name|QBasicAtomicInt
name|ThrowingType
operator|::
name|destructedCount
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|exceptionControlVar
name|QBasicAtomicInt
name|exceptionControlVar
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|ThrowingType
argument_list|,
argument|exceptionGS
argument_list|,
argument|(exceptionControlVar)
argument_list|)
end_macro
begin_function
DECL|function|exception
name|void
name|tst_QGlobalStatic
operator|::
name|exception
parameter_list|()
block|{
if|if
condition|(
name|exceptionControlVar
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
name|QSKIP
argument_list|(
literal|"This test cannot be run more than once"
argument_list|)
expr_stmt|;
name|ThrowingType
operator|::
name|constructedCount
operator|.
name|store
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ThrowingType
operator|::
name|destructedCount
operator|.
name|store
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bool
name|exceptionCaught
init|=
literal|false
decl_stmt|;
try|try
block|{
name|exceptionGS
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|int
parameter_list|)
block|{
name|exceptionCaught
operator|=
literal|true
expr_stmt|;
block|}
name|QCOMPARE
argument_list|(
name|ThrowingType
operator|::
name|constructedCount
operator|.
name|load
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|exceptionCaught
argument_list|)
expr_stmt|;
name|exceptionGS
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|ThrowingType
operator|::
name|constructedCount
operator|.
name|load
argument_list|()
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|threadStressTestControlVar
name|QBasicAtomicInt
name|threadStressTestControlVar
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|5
argument_list|)
decl_stmt|;
end_decl_stmt
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|ThrowingType
argument_list|,
argument|threadStressTestGS
argument_list|,
argument|(threadStressTestControlVar)
argument_list|)
end_macro
begin_function
DECL|function|threadStressTest
name|void
name|tst_QGlobalStatic
operator|::
name|threadStressTest
parameter_list|()
block|{
class|class
name|ThreadStressTestThread
super|:
specifier|public
name|QThread
block|{
public|public:
name|QReadWriteLock
modifier|*
name|lock
decl_stmt|;
name|void
name|run
parameter_list|()
block|{
name|QReadLocker
name|l
argument_list|(
name|lock
argument_list|)
decl_stmt|;
comment|//usleep(qrand() * 200 / RAND_MAX);
comment|// thundering herd
try|try
block|{
name|threadStressTestGS
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|int
parameter_list|)
block|{             }
block|}
block|}
class|;
name|ThrowingType
operator|::
name|constructedCount
operator|.
name|store
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ThrowingType
operator|::
name|destructedCount
operator|.
name|store
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|int
name|expectedConstructionCount
init|=
name|threadStressTestControlVar
operator|.
name|load
argument_list|()
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|expectedConstructionCount
operator|<=
literal|0
condition|)
name|QSKIP
argument_list|(
literal|"This test cannot be run more than once"
argument_list|)
expr_stmt|;
specifier|const
name|int
name|numThreads
init|=
literal|200
decl_stmt|;
name|ThreadStressTestThread
name|threads
index|[
name|numThreads
index|]
decl_stmt|;
name|QReadWriteLock
name|lock
decl_stmt|;
name|lock
operator|.
name|lockForWrite
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numThreads
condition|;
operator|++
name|i
control|)
block|{
name|threads
index|[
name|i
index|]
operator|.
name|lock
operator|=
operator|&
name|lock
expr_stmt|;
name|threads
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// wait for all threads
comment|// release the herd
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numThreads
condition|;
operator|++
name|i
control|)
name|threads
index|[
name|i
index|]
operator|.
name|wait
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|ThrowingType
operator|::
name|constructedCount
operator|.
name|loadAcquire
argument_list|()
argument_list|,
name|expectedConstructionCount
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|ThrowingType
operator|::
name|destructedCount
operator|.
name|loadAcquire
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|int
argument_list|,
argument|checkedAfterDestruction
argument_list|)
end_macro
begin_function
DECL|function|afterDestruction
name|void
name|tst_QGlobalStatic
operator|::
name|afterDestruction
parameter_list|()
block|{
comment|// this test will not produce results now
comment|// it will simply run some code on destruction (after the global statics have been deleted)
comment|// if that fails, this will cause a crash
comment|// static destruction is LIFO: so we must add our exit-time code before the
comment|// global static is used for the first time
specifier|static
struct|struct
name|RunAtExit
block|{
name|~
name|RunAtExit
parameter_list|()
block|{
name|int
modifier|*
name|ptr
init|=
name|checkedAfterDestruction
argument_list|()
decl_stmt|;
if|if
condition|(
name|ptr
condition|)
name|qFatal
argument_list|(
literal|"Global static is not null as was expected"
argument_list|)
expr_stmt|;
block|}
block|}
name|runAtExit
struct|;
operator|(
name|void
operator|)
name|runAtExit
expr_stmt|;
operator|*
name|checkedAfterDestruction
operator|=
literal|42
expr_stmt|;
block|}
end_function
begin_expr_stmt
DECL|variable|tst_QGlobalStatic
name|QTEST_APPLESS_MAIN
argument_list|(
name|tst_QGlobalStatic
argument_list|)
expr_stmt|;
end_expr_stmt
begin_include
include|#
directive|include
file|"tst_qglobalstatic.moc"
end_include
end_unit
