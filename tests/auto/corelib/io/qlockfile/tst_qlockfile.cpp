begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 David Faure<faure+bluesystems@kde.org> ** Contact: http://www.qt-project.org/legal ** ** This file is part of the test suite of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtTest/QtTest>
end_include
begin_include
include|#
directive|include
file|<QtConcurrentRun>
end_include
begin_include
include|#
directive|include
file|<qlockfile.h>
end_include
begin_include
include|#
directive|include
file|<qtemporarydir.h>
end_include
begin_class
DECL|class|tst_QLockFile
class|class
name|tst_QLockFile
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
private|private
name|slots
private|:
name|void
name|initTestCase
parameter_list|()
function_decl|;
name|void
name|lockUnlock
parameter_list|()
function_decl|;
name|void
name|lockOutOtherProcess
parameter_list|()
function_decl|;
name|void
name|lockOutOtherThread
parameter_list|()
function_decl|;
name|void
name|waitForLock_data
parameter_list|()
function_decl|;
name|void
name|waitForLock
parameter_list|()
function_decl|;
name|void
name|staleLockFromCrashedProcess_data
parameter_list|()
function_decl|;
name|void
name|staleLockFromCrashedProcess
parameter_list|()
function_decl|;
name|void
name|staleShortLockFromBusyProcess
parameter_list|()
function_decl|;
name|void
name|staleLongLockFromBusyProcess
parameter_list|()
function_decl|;
name|void
name|staleLockRace
parameter_list|()
function_decl|;
name|void
name|noPermissions
parameter_list|()
function_decl|;
public|public:
DECL|member|m_helperApp
name|QString
name|m_helperApp
decl_stmt|;
DECL|member|dir
name|QTemporaryDir
name|dir
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|initTestCase
name|void
name|tst_QLockFile
operator|::
name|initTestCase
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_NO_PROCESS
name|QSKIP
argument_list|(
literal|"This test requires QProcess support"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// chdir to our testdata path and execute helper apps relative to that.
name|QString
name|testdata_dir
init|=
name|QFileInfo
argument_list|(
name|QFINDTESTDATA
argument_list|(
literal|"qlockfiletesthelper"
argument_list|)
argument_list|)
operator|.
name|absolutePath
argument_list|()
decl_stmt|;
name|QVERIFY2
argument_list|(
name|QDir
operator|::
name|setCurrent
argument_list|(
name|testdata_dir
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
literal|"Could not chdir to "
operator|+
name|testdata_dir
argument_list|)
argument_list|)
expr_stmt|;
name|m_helperApp
operator|=
literal|"qlockfiletesthelper/qlockfile_test_helper"
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|lockUnlock
name|void
name|tst_QLockFile
operator|::
name|lockUnlock
parameter_list|()
block|{
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/lock1"
decl_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QFile
argument_list|(
name|fileName
argument_list|)
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|QLockFile
name|lockFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|lockFile
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|lockFile
operator|.
name|isLocked
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
comment|// Recursive locking is not allowed
comment|// (can't test lock() here, it would wait forever)
name|QVERIFY
argument_list|(
operator|!
name|lockFile
operator|.
name|tryLock
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|LockFailedError
argument_list|)
argument_list|)
expr_stmt|;
name|qint64
name|pid
decl_stmt|;
name|QString
name|hostname
decl_stmt|,
name|appname
decl_stmt|;
name|QVERIFY
argument_list|(
name|lockFile
operator|.
name|getLockInfo
argument_list|(
operator|&
name|pid
argument_list|,
operator|&
name|hostname
argument_list|,
operator|&
name|appname
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|pid
argument_list|,
name|QCoreApplication
operator|::
name|applicationPid
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|appname
argument_list|,
name|qAppName
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|lockFile
operator|.
name|tryLock
argument_list|(
literal|200
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|LockFailedError
argument_list|)
argument_list|)
expr_stmt|;
comment|// Unlock deletes the lock file
name|lockFile
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|lockFile
operator|.
name|isLocked
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lockOutOtherProcess
name|void
name|tst_QLockFile
operator|::
name|lockOutOtherProcess
parameter_list|()
block|{
comment|// Lock
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/lockOtherProcess"
decl_stmt|;
name|QLockFile
name|lockFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|lockFile
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
comment|// Other process can't acquire lock
name|QProcess
name|proc
decl_stmt|;
name|proc
operator|.
name|start
argument_list|(
name|m_helperApp
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|fileName
argument_list|)
expr_stmt|;
name|QVERIFY2
argument_list|(
name|proc
operator|.
name|waitForStarted
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|proc
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|proc
operator|.
name|waitForFinished
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|proc
operator|.
name|exitCode
argument_list|()
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|LockFailedError
argument_list|)
argument_list|)
expr_stmt|;
comment|// Unlock
name|lockFile
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
comment|// Other process can now acquire lock
name|int
name|ret
init|=
name|QProcess
operator|::
name|execute
argument_list|(
name|m_helperApp
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|fileName
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|ret
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
comment|// Lock doesn't survive process though (on clean exit)
name|QVERIFY
argument_list|(
operator|!
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|tryLockFromThread
specifier|static
name|QLockFile
operator|::
name|LockError
name|tryLockFromThread
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QLockFile
name|lockInThread
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|lockInThread
operator|.
name|tryLock
argument_list|()
expr_stmt|;
return|return
name|lockInThread
operator|.
name|error
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|lockOutOtherThread
name|void
name|tst_QLockFile
operator|::
name|lockOutOtherThread
parameter_list|()
block|{
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/lockOtherThread"
decl_stmt|;
name|QLockFile
name|lockFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|lockFile
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
comment|// Other thread can't acquire lock
name|QFuture
argument_list|<
name|QLockFile
operator|::
name|LockError
argument_list|>
name|ret
init|=
name|QtConcurrent
operator|::
name|run
argument_list|<
name|QLockFile
operator|::
name|LockError
argument_list|>
argument_list|(
name|tryLockFromThread
argument_list|,
name|fileName
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|ret
operator|.
name|result
argument_list|()
argument_list|,
name|QLockFile
operator|::
name|LockFailedError
argument_list|)
expr_stmt|;
name|lockFile
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// Now other thread can acquire lock
name|QFuture
argument_list|<
name|QLockFile
operator|::
name|LockError
argument_list|>
name|ret2
init|=
name|QtConcurrent
operator|::
name|run
argument_list|<
name|QLockFile
operator|::
name|LockError
argument_list|>
argument_list|(
name|tryLockFromThread
argument_list|,
name|fileName
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|ret2
operator|.
name|result
argument_list|()
argument_list|,
name|QLockFile
operator|::
name|NoError
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lockFromThread
specifier|static
name|bool
name|lockFromThread
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|int
name|sleepMs
parameter_list|,
name|QSemaphore
modifier|*
name|semThreadReady
parameter_list|,
name|QSemaphore
modifier|*
name|semMainThreadDone
parameter_list|)
block|{
name|QLockFile
name|lockFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lockFile
operator|.
name|lock
argument_list|()
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Locking failed"
operator|<<
name|lockFile
operator|.
name|error
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|semThreadReady
operator|->
name|release
argument_list|()
expr_stmt|;
name|QThread
operator|::
name|msleep
argument_list|(
name|sleepMs
argument_list|)
expr_stmt|;
name|semMainThreadDone
operator|->
name|acquire
argument_list|()
expr_stmt|;
name|lockFile
operator|.
name|unlock
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|waitForLock_data
name|void
name|tst_QLockFile
operator|::
name|waitForLock_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"testNumber"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"threadSleepMs"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"releaseEarly"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"tryLockTimeout"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"expectedResult"
argument_list|)
expr_stmt|;
name|int
name|tn
init|=
literal|0
decl_stmt|;
comment|// test number
name|QTest
operator|::
name|newRow
argument_list|(
literal|"wait_forever_succeeds"
argument_list|)
operator|<<
operator|++
name|tn
operator|<<
literal|500
operator|<<
literal|true
operator|<<
operator|-
literal|1
operator|<<
literal|true
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"wait_longer_succeeds"
argument_list|)
operator|<<
operator|++
name|tn
operator|<<
literal|500
operator|<<
literal|true
operator|<<
literal|1000
operator|<<
literal|true
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"wait_zero_fails"
argument_list|)
operator|<<
operator|++
name|tn
operator|<<
literal|500
operator|<<
literal|false
operator|<<
literal|0
operator|<<
literal|false
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"wait_not_enough_fails"
argument_list|)
operator|<<
operator|++
name|tn
operator|<<
literal|500
operator|<<
literal|false
operator|<<
literal|100
operator|<<
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|waitForLock
name|void
name|tst_QLockFile
operator|::
name|waitForLock
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|int
argument_list|,
name|testNumber
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|threadSleepMs
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|releaseEarly
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|tryLockTimeout
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|expectedResult
argument_list|)
expr_stmt|;
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/waitForLock"
operator|+
name|QString
operator|::
name|number
argument_list|(
name|testNumber
argument_list|)
decl_stmt|;
name|QLockFile
name|lockFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QSemaphore
name|semThreadReady
decl_stmt|,
name|semMainThreadDone
decl_stmt|;
comment|// Lock file from a thread
name|QFuture
argument_list|<
name|bool
argument_list|>
name|ret
init|=
name|QtConcurrent
operator|::
name|run
argument_list|<
name|bool
argument_list|>
argument_list|(
name|lockFromThread
argument_list|,
name|fileName
argument_list|,
name|threadSleepMs
argument_list|,
operator|&
name|semThreadReady
argument_list|,
operator|&
name|semMainThreadDone
argument_list|)
decl_stmt|;
name|semThreadReady
operator|.
name|acquire
argument_list|()
expr_stmt|;
if|if
condition|(
name|releaseEarly
condition|)
comment|// let the thread release the lock after threadSleepMs
name|semMainThreadDone
operator|.
name|release
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|lockFile
operator|.
name|tryLock
argument_list|(
name|tryLockTimeout
argument_list|)
argument_list|,
name|expectedResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedResult
condition|)
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|LockFailedError
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|releaseEarly
condition|)
comment|// only let the thread release the lock now
name|semMainThreadDone
operator|.
name|release
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|ret
argument_list|)
expr_stmt|;
comment|// waits for the thread to finish
block|}
end_function
begin_function
DECL|function|staleLockFromCrashedProcess_data
name|void
name|tst_QLockFile
operator|::
name|staleLockFromCrashedProcess_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"staleLockTime"
argument_list|)
expr_stmt|;
comment|// Test both use cases for QLockFile, should make no difference here.
name|QTest
operator|::
name|newRow
argument_list|(
literal|"short"
argument_list|)
operator|<<
literal|30000
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"long"
argument_list|)
operator|<<
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|staleLockFromCrashedProcess
name|void
name|tst_QLockFile
operator|::
name|staleLockFromCrashedProcess
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|int
argument_list|,
name|staleLockTime
argument_list|)
expr_stmt|;
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/staleLockFromCrashedProcess"
decl_stmt|;
name|int
name|ret
init|=
name|QProcess
operator|::
name|execute
argument_list|(
name|m_helperApp
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|fileName
operator|<<
literal|"-crash"
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|ret
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
name|QTRY_VERIFY
argument_list|(
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
name|QLockFile
name|secondLock
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|secondLock
operator|.
name|setStaleLockTime
argument_list|(
name|staleLockTime
argument_list|)
expr_stmt|;
comment|// tryLock detects and removes the stale lock (since the PID is dead)
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// It can take a bit of time on Windows, though.
name|QVERIFY
argument_list|(
name|secondLock
operator|.
name|tryLock
argument_list|(
literal|30000
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|QVERIFY
argument_list|(
name|secondLock
operator|.
name|tryLock
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|secondLock
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|staleShortLockFromBusyProcess
name|void
name|tst_QLockFile
operator|::
name|staleShortLockFromBusyProcess
parameter_list|()
block|{
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/staleLockFromBusyProcess"
decl_stmt|;
name|QProcess
name|proc
decl_stmt|;
name|proc
operator|.
name|start
argument_list|(
name|m_helperApp
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|fileName
operator|<<
literal|"-busy"
argument_list|)
expr_stmt|;
name|QVERIFY2
argument_list|(
name|proc
operator|.
name|waitForStarted
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|proc
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QTRY_VERIFY
argument_list|(
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
name|QLockFile
name|secondLock
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|secondLock
operator|.
name|tryLock
argument_list|()
argument_list|)
expr_stmt|;
comment|// held by other process
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|secondLock
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|LockFailedError
argument_list|)
argument_list|)
expr_stmt|;
name|qint64
name|pid
decl_stmt|;
name|QString
name|hostname
decl_stmt|,
name|appname
decl_stmt|;
name|QTRY_VERIFY
argument_list|(
name|secondLock
operator|.
name|getLockInfo
argument_list|(
operator|&
name|pid
argument_list|,
operator|&
name|hostname
argument_list|,
operator|&
name|appname
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|QCOMPARE
argument_list|(
name|pid
argument_list|,
name|proc
operator|.
name|pid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|secondLock
operator|.
name|setStaleLockTime
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|qSleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|// make the lock stale
comment|// We can't "steal" (delete+recreate) a lock file from a running process
comment|// until the file descriptor is closed.
name|QVERIFY
argument_list|(
operator|!
name|secondLock
operator|.
name|tryLock
argument_list|()
argument_list|)
expr_stmt|;
name|proc
operator|.
name|waitForFinished
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|secondLock
operator|.
name|tryLock
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|staleLongLockFromBusyProcess
name|void
name|tst_QLockFile
operator|::
name|staleLongLockFromBusyProcess
parameter_list|()
block|{
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/staleLockFromBusyProcess"
decl_stmt|;
name|QProcess
name|proc
decl_stmt|;
name|proc
operator|.
name|start
argument_list|(
name|m_helperApp
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|fileName
operator|<<
literal|"-busy"
argument_list|)
expr_stmt|;
name|QVERIFY2
argument_list|(
name|proc
operator|.
name|waitForStarted
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|proc
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QTRY_VERIFY
argument_list|(
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
name|QLockFile
name|secondLock
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|secondLock
operator|.
name|setStaleLockTime
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|secondLock
operator|.
name|tryLock
argument_list|(
literal|100
argument_list|)
argument_list|)
expr_stmt|;
comment|// never stale
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|secondLock
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|LockFailedError
argument_list|)
argument_list|)
expr_stmt|;
name|qint64
name|pid
decl_stmt|;
name|QTRY_VERIFY
argument_list|(
name|secondLock
operator|.
name|getLockInfo
argument_list|(
operator|&
name|pid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|pid
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// As long as the other process is running, we can't remove the lock file
name|QVERIFY
argument_list|(
operator|!
name|secondLock
operator|.
name|removeStaleLockFile
argument_list|()
argument_list|)
expr_stmt|;
name|proc
operator|.
name|waitForFinished
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|tryStaleLockFromThread
specifier|static
name|QString
name|tryStaleLockFromThread
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QLockFile
name|lockInThread
argument_list|(
name|fileName
operator|+
literal|".lock"
argument_list|)
decl_stmt|;
name|lockInThread
operator|.
name|setStaleLockTime
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lockInThread
operator|.
name|lock
argument_list|()
condition|)
return|return
literal|"Error locking: "
operator|+
name|QString
operator|::
name|number
argument_list|(
name|lockInThread
operator|.
name|error
argument_list|()
argument_list|)
return|;
comment|// The concurrent use of the file below (write, read, delete) is protected by the lock file above.
comment|// (provided that it doesn't become stale due to this operation taking too long)
name|QFile
name|theFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|theFile
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
condition|)
return|return
literal|"Couldn't open for write"
return|;
name|theFile
operator|.
name|write
argument_list|(
literal|"Hello world"
argument_list|)
expr_stmt|;
name|theFile
operator|.
name|flush
argument_list|()
expr_stmt|;
name|theFile
operator|.
name|close
argument_list|()
expr_stmt|;
name|QFile
name|reader
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reader
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
return|return
literal|"Couldn't open for read"
return|;
specifier|const
name|QByteArray
name|read
init|=
name|reader
operator|.
name|readAll
argument_list|()
decl_stmt|;
if|if
condition|(
name|read
operator|!=
literal|"Hello world"
condition|)
return|return
literal|"File didn't have the expected contents:"
operator|+
name|read
return|;
name|reader
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|staleLockRace
name|void
name|tst_QLockFile
operator|::
name|staleLockRace
parameter_list|()
block|{
comment|// Multiple threads notice a stale lock at the same time
comment|// Only one thread should delete it, otherwise a race will ensue
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/sharedFile"
decl_stmt|;
specifier|const
name|QString
name|lockName
init|=
name|fileName
operator|+
literal|".lock"
decl_stmt|;
name|int
name|ret
init|=
name|QProcess
operator|::
name|execute
argument_list|(
name|m_helperApp
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|lockName
operator|<<
literal|"-crash"
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|ret
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
name|QTRY_VERIFY
argument_list|(
name|QFile
operator|::
name|exists
argument_list|(
name|lockName
argument_list|)
argument_list|)
expr_stmt|;
name|QThreadPool
operator|::
name|globalInstance
argument_list|()
operator|->
name|setMaxThreadCount
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|QFutureSynchronizer
argument_list|<
name|QString
argument_list|>
name|synchronizer
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|synchronizer
operator|.
name|addFuture
argument_list|(
name|QtConcurrent
operator|::
name|run
argument_list|<
name|QString
argument_list|>
argument_list|(
name|tryStaleLockFromThread
argument_list|,
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
name|synchronizer
operator|.
name|waitForFinished
argument_list|()
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QFuture
argument_list|<
name|QString
argument_list|>
modifier|&
name|future
decl|,
name|synchronizer
operator|.
name|futures
argument_list|()
control|)
name|QVERIFY2
argument_list|(
name|future
operator|.
name|result
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|future
operator|.
name|result
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|noPermissions
name|void
name|tst_QLockFile
operator|::
name|noPermissions
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// A readonly directory still allows us to create files, on Windows.
name|QSKIP
argument_list|(
literal|"No permission testing on Windows"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Restore permissions so that the QTemporaryDir cleanup can happen
class|class
name|PermissionRestorer
block|{
name|QString
name|m_path
decl_stmt|;
public|public:
name|PermissionRestorer
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
member_init_list|:
name|m_path
argument_list|(
name|path
argument_list|)
block|{}
name|~
name|PermissionRestorer
parameter_list|()
block|{
name|QFile
name|file
argument_list|(
name|m_path
argument_list|)
decl_stmt|;
name|file
operator|.
name|setPermissions
argument_list|(
name|QFile
operator|::
name|Permissions
argument_list|(
name|QFile
operator|::
name|ReadOwner
operator||
name|QFile
operator|::
name|WriteOwner
operator||
name|QFile
operator|::
name|ExeOwner
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
class|;
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/staleLock"
decl_stmt|;
name|QFile
name|dirAsFile
argument_list|(
name|dir
operator|.
name|path
argument_list|()
argument_list|)
decl_stmt|;
comment|// I have to use QFile to change a dir's permissions...
name|QVERIFY2
argument_list|(
name|dirAsFile
operator|.
name|setPermissions
argument_list|(
name|QFile
operator|::
name|Permissions
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|dir
operator|.
name|path
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// no permissions
name|PermissionRestorer
name|permissionRestorer
argument_list|(
name|dir
operator|.
name|path
argument_list|()
argument_list|)
decl_stmt|;
name|QLockFile
name|lockFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|lockFile
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|PermissionError
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QTEST_MAIN
argument_list|(
argument|tst_QLockFile
argument_list|)
end_macro
begin_include
include|#
directive|include
file|"tst_qlockfile.moc"
end_include
end_unit
