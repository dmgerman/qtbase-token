begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 David Faure<faure+bluesystems@kde.org> ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the test suite of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:GPL-EXCEPT$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3 as published by the Free Software ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtTest/QtTest>
end_include
begin_include
include|#
directive|include
file|<QtConcurrentRun>
end_include
begin_include
include|#
directive|include
file|<qlockfile.h>
end_include
begin_include
include|#
directive|include
file|<qtemporarydir.h>
end_include
begin_include
include|#
directive|include
file|<qsysinfo.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
end_if
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
end_elif
begin_include
include|#
directive|include
file|<qt_windows.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_class
DECL|class|tst_QLockFile
class|class
name|tst_QLockFile
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
private|private
name|slots
private|:
name|void
name|initTestCase
parameter_list|()
function_decl|;
name|void
name|lockUnlock
parameter_list|()
function_decl|;
name|void
name|lockOutOtherProcess
parameter_list|()
function_decl|;
name|void
name|lockOutOtherThread
parameter_list|()
function_decl|;
name|void
name|raceWithOtherThread
parameter_list|()
function_decl|;
name|void
name|waitForLock_data
parameter_list|()
function_decl|;
name|void
name|waitForLock
parameter_list|()
function_decl|;
name|void
name|staleLockFromCrashedProcess_data
parameter_list|()
function_decl|;
name|void
name|staleLockFromCrashedProcess
parameter_list|()
function_decl|;
name|void
name|staleLockFromCrashedProcessReusedPid
parameter_list|()
function_decl|;
name|void
name|staleShortLockFromBusyProcess
parameter_list|()
function_decl|;
name|void
name|staleLongLockFromBusyProcess
parameter_list|()
function_decl|;
name|void
name|staleLockRace
parameter_list|()
function_decl|;
name|void
name|noPermissions
parameter_list|()
function_decl|;
name|void
name|noPermissionsWindows
parameter_list|()
function_decl|;
name|void
name|corruptedLockFile
parameter_list|()
function_decl|;
private|private:
specifier|static
name|bool
name|overwritePidInLockFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|filePath
parameter_list|,
name|qint64
name|pid
parameter_list|)
function_decl|;
public|public:
DECL|member|m_helperApp
name|QString
name|m_helperApp
decl_stmt|;
DECL|member|dir
name|QTemporaryDir
name|dir
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|initTestCase
name|void
name|tst_QLockFile
operator|::
name|initTestCase
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
name|QSKIP
argument_list|(
literal|"This test requires deploying and running external console applications"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|QT_NO_PROCESS
argument_list|)
name|QSKIP
argument_list|(
literal|"This test requires QProcess support"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QVERIFY2
argument_list|(
name|dir
operator|.
name|isValid
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|dir
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// chdir to our testdata path and execute helper apps relative to that.
name|QString
name|testdata_dir
init|=
name|QFileInfo
argument_list|(
name|QFINDTESTDATA
argument_list|(
literal|"qlockfiletesthelper"
argument_list|)
argument_list|)
operator|.
name|absolutePath
argument_list|()
decl_stmt|;
name|QVERIFY2
argument_list|(
name|QDir
operator|::
name|setCurrent
argument_list|(
name|testdata_dir
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
literal|"Could not chdir to "
operator|+
name|testdata_dir
argument_list|)
argument_list|)
expr_stmt|;
name|m_helperApp
operator|=
literal|"qlockfiletesthelper/qlockfile_test_helper"
expr_stmt|;
endif|#
directive|endif
comment|// !QT_NO_PROCESS
block|}
end_function
begin_function
DECL|function|lockUnlock
name|void
name|tst_QLockFile
operator|::
name|lockUnlock
parameter_list|()
block|{
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/lock1"
decl_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QFile
argument_list|(
name|fileName
argument_list|)
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|QLockFile
name|lockFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|lockFile
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|lockFile
operator|.
name|isLocked
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
comment|// Recursive locking is not allowed
comment|// (can't test lock() here, it would wait forever)
name|QVERIFY
argument_list|(
operator|!
name|lockFile
operator|.
name|tryLock
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|LockFailedError
argument_list|)
argument_list|)
expr_stmt|;
name|qint64
name|pid
decl_stmt|;
name|QString
name|hostname
decl_stmt|,
name|appname
decl_stmt|;
name|QVERIFY
argument_list|(
name|lockFile
operator|.
name|getLockInfo
argument_list|(
operator|&
name|pid
argument_list|,
operator|&
name|hostname
argument_list|,
operator|&
name|appname
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|pid
argument_list|,
name|QCoreApplication
operator|::
name|applicationPid
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|appname
argument_list|,
name|qAppName
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|lockFile
operator|.
name|tryLock
argument_list|(
literal|200
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|LockFailedError
argument_list|)
argument_list|)
expr_stmt|;
comment|// Unlock deletes the lock file
name|lockFile
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|lockFile
operator|.
name|isLocked
argument_list|()
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lockOutOtherProcess
name|void
name|tst_QLockFile
operator|::
name|lockOutOtherProcess
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_NO_PROCESS
name|QSKIP
argument_list|(
literal|"This test requires QProcess support"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// Lock
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/lockOtherProcess"
decl_stmt|;
name|QLockFile
name|lockFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|lockFile
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
comment|// Other process can't acquire lock
name|QProcess
name|proc
decl_stmt|;
name|proc
operator|.
name|start
argument_list|(
name|m_helperApp
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|fileName
argument_list|)
expr_stmt|;
name|QVERIFY2
argument_list|(
name|proc
operator|.
name|waitForStarted
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|proc
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|proc
operator|.
name|waitForFinished
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|proc
operator|.
name|exitCode
argument_list|()
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|LockFailedError
argument_list|)
argument_list|)
expr_stmt|;
comment|// Unlock
name|lockFile
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
comment|// Other process can now acquire lock
name|int
name|ret
init|=
name|QProcess
operator|::
name|execute
argument_list|(
name|m_helperApp
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|fileName
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|ret
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
comment|// Lock doesn't survive process though (on clean exit)
name|QVERIFY
argument_list|(
operator|!
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// !QT_NO_PROCESS
block|}
end_function
begin_function
DECL|function|tryLockFromThread
specifier|static
name|QLockFile
operator|::
name|LockError
name|tryLockFromThread
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QLockFile
name|lockInThread
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|lockInThread
operator|.
name|tryLock
argument_list|()
expr_stmt|;
return|return
name|lockInThread
operator|.
name|error
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|lockOutOtherThread
name|void
name|tst_QLockFile
operator|::
name|lockOutOtherThread
parameter_list|()
block|{
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/lockOtherThread"
decl_stmt|;
name|QLockFile
name|lockFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|lockFile
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
comment|// Other thread can't acquire lock
name|QFuture
argument_list|<
name|QLockFile
operator|::
name|LockError
argument_list|>
name|ret
init|=
name|QtConcurrent
operator|::
name|run
argument_list|<
name|QLockFile
operator|::
name|LockError
argument_list|>
argument_list|(
name|tryLockFromThread
argument_list|,
name|fileName
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|ret
operator|.
name|result
argument_list|()
argument_list|,
name|QLockFile
operator|::
name|LockFailedError
argument_list|)
expr_stmt|;
name|lockFile
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// Now other thread can acquire lock
name|QFuture
argument_list|<
name|QLockFile
operator|::
name|LockError
argument_list|>
name|ret2
init|=
name|QtConcurrent
operator|::
name|run
argument_list|<
name|QLockFile
operator|::
name|LockError
argument_list|>
argument_list|(
name|tryLockFromThread
argument_list|,
name|fileName
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|ret2
operator|.
name|result
argument_list|()
argument_list|,
name|QLockFile
operator|::
name|NoError
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lockFromThread
specifier|static
name|QLockFile
operator|::
name|LockError
name|lockFromThread
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QLockFile
name|lockInThread
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|lockInThread
operator|.
name|lock
argument_list|()
expr_stmt|;
return|return
name|lockInThread
operator|.
name|error
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// QTBUG-38853, best way to trigger it was to add a QThread::sleep(1) in QLockFilePrivate::getLockInfo() after the first readLine.
end_comment
begin_comment
comment|// Then (on Windows), the QFile::remove() in unlock() (called by the first thread who got the lock, in the destructor)
end_comment
begin_comment
comment|// would fail due to the existing reader on the file. Fixed by checking the return value of QFile::remove() in unlock().
end_comment
begin_function
DECL|function|raceWithOtherThread
name|void
name|tst_QLockFile
operator|::
name|raceWithOtherThread
parameter_list|()
block|{
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/raceWithOtherThread"
decl_stmt|;
name|QFuture
argument_list|<
name|QLockFile
operator|::
name|LockError
argument_list|>
name|ret
init|=
name|QtConcurrent
operator|::
name|run
argument_list|<
name|QLockFile
operator|::
name|LockError
argument_list|>
argument_list|(
name|lockFromThread
argument_list|,
name|fileName
argument_list|)
decl_stmt|;
name|QFuture
argument_list|<
name|QLockFile
operator|::
name|LockError
argument_list|>
name|ret2
init|=
name|QtConcurrent
operator|::
name|run
argument_list|<
name|QLockFile
operator|::
name|LockError
argument_list|>
argument_list|(
name|lockFromThread
argument_list|,
name|fileName
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|ret
operator|.
name|result
argument_list|()
argument_list|,
name|QLockFile
operator|::
name|NoError
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|ret2
operator|.
name|result
argument_list|()
argument_list|,
name|QLockFile
operator|::
name|NoError
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lockFromThread
specifier|static
name|bool
name|lockFromThread
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|int
name|sleepMs
parameter_list|,
name|QSemaphore
modifier|*
name|semThreadReady
parameter_list|,
name|QSemaphore
modifier|*
name|semMainThreadDone
parameter_list|)
block|{
name|QLockFile
name|lockFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lockFile
operator|.
name|lock
argument_list|()
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Locking failed"
operator|<<
name|lockFile
operator|.
name|error
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|semThreadReady
operator|->
name|release
argument_list|()
expr_stmt|;
name|QThread
operator|::
name|msleep
argument_list|(
name|sleepMs
argument_list|)
expr_stmt|;
name|semMainThreadDone
operator|->
name|acquire
argument_list|()
expr_stmt|;
name|lockFile
operator|.
name|unlock
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|waitForLock_data
name|void
name|tst_QLockFile
operator|::
name|waitForLock_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"testNumber"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"threadSleepMs"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"releaseEarly"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"tryLockTimeout"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|bool
argument_list|>
argument_list|(
literal|"expectedResult"
argument_list|)
expr_stmt|;
name|int
name|tn
init|=
literal|0
decl_stmt|;
comment|// test number
name|QTest
operator|::
name|newRow
argument_list|(
literal|"wait_forever_succeeds"
argument_list|)
operator|<<
operator|++
name|tn
operator|<<
literal|500
operator|<<
literal|true
operator|<<
operator|-
literal|1
operator|<<
literal|true
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"wait_longer_succeeds"
argument_list|)
operator|<<
operator|++
name|tn
operator|<<
literal|500
operator|<<
literal|true
operator|<<
literal|1000
operator|<<
literal|true
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"wait_zero_fails"
argument_list|)
operator|<<
operator|++
name|tn
operator|<<
literal|500
operator|<<
literal|false
operator|<<
literal|0
operator|<<
literal|false
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"wait_not_enough_fails"
argument_list|)
operator|<<
operator|++
name|tn
operator|<<
literal|500
operator|<<
literal|false
operator|<<
literal|100
operator|<<
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|waitForLock
name|void
name|tst_QLockFile
operator|::
name|waitForLock
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|int
argument_list|,
name|testNumber
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|threadSleepMs
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|releaseEarly
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|int
argument_list|,
name|tryLockTimeout
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|bool
argument_list|,
name|expectedResult
argument_list|)
expr_stmt|;
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/waitForLock"
operator|+
name|QString
operator|::
name|number
argument_list|(
name|testNumber
argument_list|)
decl_stmt|;
name|QLockFile
name|lockFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QSemaphore
name|semThreadReady
decl_stmt|,
name|semMainThreadDone
decl_stmt|;
comment|// Lock file from a thread
name|QFuture
argument_list|<
name|bool
argument_list|>
name|ret
init|=
name|QtConcurrent
operator|::
name|run
argument_list|<
name|bool
argument_list|>
argument_list|(
name|lockFromThread
argument_list|,
name|fileName
argument_list|,
name|threadSleepMs
argument_list|,
operator|&
name|semThreadReady
argument_list|,
operator|&
name|semMainThreadDone
argument_list|)
decl_stmt|;
name|semThreadReady
operator|.
name|acquire
argument_list|()
expr_stmt|;
if|if
condition|(
name|releaseEarly
condition|)
comment|// let the thread release the lock after threadSleepMs
name|semMainThreadDone
operator|.
name|release
argument_list|()
expr_stmt|;
name|QCOMPARE
argument_list|(
name|lockFile
operator|.
name|tryLock
argument_list|(
name|tryLockTimeout
argument_list|)
argument_list|,
name|expectedResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedResult
condition|)
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|LockFailedError
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|releaseEarly
condition|)
comment|// only let the thread release the lock now
name|semMainThreadDone
operator|.
name|release
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|ret
argument_list|)
expr_stmt|;
comment|// waits for the thread to finish
block|}
end_function
begin_function
DECL|function|staleLockFromCrashedProcess_data
name|void
name|tst_QLockFile
operator|::
name|staleLockFromCrashedProcess_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"staleLockTime"
argument_list|)
expr_stmt|;
comment|// Test both use cases for QLockFile, should make no difference here.
name|QTest
operator|::
name|newRow
argument_list|(
literal|"short"
argument_list|)
operator|<<
literal|30000
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"long"
argument_list|)
operator|<<
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|staleLockFromCrashedProcess
name|void
name|tst_QLockFile
operator|::
name|staleLockFromCrashedProcess
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_NO_PROCESS
name|QSKIP
argument_list|(
literal|"This test requires QProcess support"
argument_list|)
expr_stmt|;
else|#
directive|else
name|QFETCH
argument_list|(
name|int
argument_list|,
name|staleLockTime
argument_list|)
expr_stmt|;
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/staleLockFromCrashedProcess"
decl_stmt|;
name|int
name|ret
init|=
name|QProcess
operator|::
name|execute
argument_list|(
name|m_helperApp
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|fileName
operator|<<
literal|"-crash"
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|ret
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
name|QTRY_VERIFY
argument_list|(
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
name|QLockFile
name|secondLock
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|secondLock
operator|.
name|setStaleLockTime
argument_list|(
name|staleLockTime
argument_list|)
expr_stmt|;
comment|// tryLock detects and removes the stale lock (since the PID is dead)
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// It can take a bit of time on Windows, though.
name|QVERIFY
argument_list|(
name|secondLock
operator|.
name|tryLock
argument_list|(
literal|30000
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|QVERIFY
argument_list|(
name|secondLock
operator|.
name|tryLock
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|secondLock
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// !QT_NO_PROCESS
block|}
end_function
begin_function
DECL|function|staleLockFromCrashedProcessReusedPid
name|void
name|tst_QLockFile
operator|::
name|staleLockFromCrashedProcessReusedPid
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_PROCESS
argument_list|)
name|QSKIP
argument_list|(
literal|"This test requires QProcess support"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_IOS
argument_list|)
name|QSKIP
argument_list|(
literal|"We cannot retrieve information about other processes on this platform."
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/staleLockFromCrashedProcessReusedPid"
decl_stmt|;
name|int
name|ret
init|=
name|QProcess
operator|::
name|execute
argument_list|(
name|m_helperApp
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|fileName
operator|<<
literal|"-crash"
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|ret
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|overwritePidInLockFile
argument_list|(
name|fileName
argument_list|,
name|QCoreApplication
operator|::
name|applicationPid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QLockFile
name|secondLock
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|qint64
name|pid
init|=
literal|0
decl_stmt|;
name|secondLock
operator|.
name|getLockInfo
argument_list|(
operator|&
name|pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|pid
argument_list|,
name|QCoreApplication
operator|::
name|applicationPid
argument_list|()
argument_list|)
expr_stmt|;
name|secondLock
operator|.
name|setStaleLockTime
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|secondLock
operator|.
name|tryLock
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|secondLock
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// !QT_NO_PROCESS
block|}
end_function
begin_function
DECL|function|staleShortLockFromBusyProcess
name|void
name|tst_QLockFile
operator|::
name|staleShortLockFromBusyProcess
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_NO_PROCESS
name|QSKIP
argument_list|(
literal|"This test requires QProcess support"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/staleLockFromBusyProcess"
decl_stmt|;
name|QProcess
name|proc
decl_stmt|;
name|proc
operator|.
name|start
argument_list|(
name|m_helperApp
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|fileName
operator|<<
literal|"-busy"
argument_list|)
expr_stmt|;
name|QVERIFY2
argument_list|(
name|proc
operator|.
name|waitForStarted
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|proc
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QTRY_VERIFY
argument_list|(
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
name|QLockFile
name|secondLock
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|secondLock
operator|.
name|tryLock
argument_list|()
argument_list|)
expr_stmt|;
comment|// held by other process
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|secondLock
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|LockFailedError
argument_list|)
argument_list|)
expr_stmt|;
name|qint64
name|pid
decl_stmt|;
name|QString
name|hostname
decl_stmt|,
name|appname
decl_stmt|;
name|QTRY_VERIFY
argument_list|(
name|secondLock
operator|.
name|getLockInfo
argument_list|(
operator|&
name|pid
argument_list|,
operator|&
name|hostname
argument_list|,
operator|&
name|appname
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|QCOMPARE
argument_list|(
name|pid
argument_list|,
name|proc
operator|.
name|pid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|secondLock
operator|.
name|setStaleLockTime
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|qSleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|// make the lock stale
comment|// We can't "steal" (delete+recreate) a lock file from a running process
comment|// until the file descriptor is closed.
name|QVERIFY
argument_list|(
operator|!
name|secondLock
operator|.
name|tryLock
argument_list|()
argument_list|)
expr_stmt|;
name|proc
operator|.
name|waitForFinished
argument_list|()
expr_stmt|;
name|QVERIFY
argument_list|(
name|secondLock
operator|.
name|tryLock
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// !QT_NO_PROCESS
block|}
end_function
begin_function
DECL|function|staleLongLockFromBusyProcess
name|void
name|tst_QLockFile
operator|::
name|staleLongLockFromBusyProcess
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_NO_PROCESS
name|QSKIP
argument_list|(
literal|"This test requires QProcess support"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/staleLockFromBusyProcess"
decl_stmt|;
name|QProcess
name|proc
decl_stmt|;
name|proc
operator|.
name|start
argument_list|(
name|m_helperApp
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|fileName
operator|<<
literal|"-busy"
argument_list|)
expr_stmt|;
name|QVERIFY2
argument_list|(
name|proc
operator|.
name|waitForStarted
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|proc
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QTRY_VERIFY
argument_list|(
name|QFile
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
name|QLockFile
name|secondLock
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|secondLock
operator|.
name|setStaleLockTime
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|secondLock
operator|.
name|tryLock
argument_list|(
literal|100
argument_list|)
argument_list|)
expr_stmt|;
comment|// never stale
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|secondLock
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|LockFailedError
argument_list|)
argument_list|)
expr_stmt|;
name|qint64
name|pid
decl_stmt|;
name|QTRY_VERIFY
argument_list|(
name|secondLock
operator|.
name|getLockInfo
argument_list|(
operator|&
name|pid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|pid
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// As long as the other process is running, we can't remove the lock file
name|QVERIFY
argument_list|(
operator|!
name|secondLock
operator|.
name|removeStaleLockFile
argument_list|()
argument_list|)
expr_stmt|;
name|proc
operator|.
name|waitForFinished
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// !QT_NO_PROCESS
block|}
end_function
begin_function
DECL|function|tryStaleLockFromThread
specifier|static
name|QString
name|tryStaleLockFromThread
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QLockFile
name|lockInThread
argument_list|(
name|fileName
operator|+
literal|".lock"
argument_list|)
decl_stmt|;
name|lockInThread
operator|.
name|setStaleLockTime
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lockInThread
operator|.
name|lock
argument_list|()
condition|)
return|return
literal|"Error locking: "
operator|+
name|QString
operator|::
name|number
argument_list|(
name|lockInThread
operator|.
name|error
argument_list|()
argument_list|)
return|;
comment|// The concurrent use of the file below (write, read, delete) is protected by the lock file above.
comment|// (provided that it doesn't become stale due to this operation taking too long)
name|QFile
name|theFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|theFile
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
condition|)
return|return
literal|"Couldn't open for write"
return|;
name|theFile
operator|.
name|write
argument_list|(
literal|"Hello world"
argument_list|)
expr_stmt|;
name|theFile
operator|.
name|flush
argument_list|()
expr_stmt|;
name|theFile
operator|.
name|close
argument_list|()
expr_stmt|;
name|QFile
name|reader
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reader
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
return|return
literal|"Couldn't open for read"
return|;
specifier|const
name|QByteArray
name|read
init|=
name|reader
operator|.
name|readAll
argument_list|()
decl_stmt|;
if|if
condition|(
name|read
operator|!=
literal|"Hello world"
condition|)
return|return
literal|"File didn't have the expected contents:"
operator|+
name|read
return|;
name|reader
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|staleLockRace
name|void
name|tst_QLockFile
operator|::
name|staleLockRace
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_NO_PROCESS
name|QSKIP
argument_list|(
literal|"This test requires QProcess support"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// Multiple threads notice a stale lock at the same time
comment|// Only one thread should delete it, otherwise a race will ensue
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/sharedFile"
decl_stmt|;
specifier|const
name|QString
name|lockName
init|=
name|fileName
operator|+
literal|".lock"
decl_stmt|;
name|int
name|ret
init|=
name|QProcess
operator|::
name|execute
argument_list|(
name|m_helperApp
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|lockName
operator|<<
literal|"-crash"
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|ret
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
name|QTRY_VERIFY
argument_list|(
name|QFile
operator|::
name|exists
argument_list|(
name|lockName
argument_list|)
argument_list|)
expr_stmt|;
name|QThreadPool
operator|::
name|globalInstance
argument_list|()
operator|->
name|setMaxThreadCount
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|QFutureSynchronizer
argument_list|<
name|QString
argument_list|>
name|synchronizer
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|synchronizer
operator|.
name|addFuture
argument_list|(
name|QtConcurrent
operator|::
name|run
argument_list|<
name|QString
argument_list|>
argument_list|(
name|tryStaleLockFromThread
argument_list|,
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
name|synchronizer
operator|.
name|waitForFinished
argument_list|()
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QFuture
argument_list|<
name|QString
argument_list|>
modifier|&
name|future
decl|,
name|synchronizer
operator|.
name|futures
argument_list|()
control|)
name|QVERIFY2
argument_list|(
name|future
operator|.
name|result
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|future
operator|.
name|result
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// !QT_NO_PROCESS
block|}
end_function
begin_function
DECL|function|noPermissions
name|void
name|tst_QLockFile
operator|::
name|noPermissions
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
comment|// A readonly directory still allows us to create files, on Windows.
name|QSKIP
argument_list|(
literal|"No permission testing on Windows"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
if|if
condition|(
operator|::
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
name|QSKIP
argument_list|(
literal|"Test is not applicable with root privileges"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Restore permissions so that the QTemporaryDir cleanup can happen
class|class
name|PermissionRestorer
block|{
name|QString
name|m_path
decl_stmt|;
public|public:
name|PermissionRestorer
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
member_init_list|:
name|m_path
argument_list|(
name|path
argument_list|)
block|{}
name|~
name|PermissionRestorer
parameter_list|()
block|{
name|QFile
name|file
argument_list|(
name|m_path
argument_list|)
decl_stmt|;
name|file
operator|.
name|setPermissions
argument_list|(
name|QFile
operator|::
name|Permissions
argument_list|(
name|QFile
operator|::
name|ReadOwner
operator||
name|QFile
operator|::
name|WriteOwner
operator||
name|QFile
operator|::
name|ExeOwner
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
class|;
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/staleLock"
decl_stmt|;
name|QFile
name|dirAsFile
argument_list|(
name|dir
operator|.
name|path
argument_list|()
argument_list|)
decl_stmt|;
comment|// I have to use QFile to change a dir's permissions...
name|QVERIFY2
argument_list|(
name|dirAsFile
operator|.
name|setPermissions
argument_list|(
name|QFile
operator|::
name|Permissions
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|dir
operator|.
name|path
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// no permissions
name|PermissionRestorer
name|permissionRestorer
argument_list|(
name|dir
operator|.
name|path
argument_list|()
argument_list|)
decl_stmt|;
name|QLockFile
name|lockFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|lockFile
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|PermissionError
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_enum
DECL|enum|ProcessProperty
enum|enum
name|ProcessProperty
block|{
DECL|enumerator|ElevatedProcess
name|ElevatedProcess
init|=
literal|0x1
block|,
DECL|enumerator|VirtualStore
name|VirtualStore
init|=
literal|0x2
block|}
enum|;
end_enum
begin_macro
name|Q_DECLARE_FLAGS
argument_list|(
argument|ProcessProperties
argument_list|,
argument|ProcessProperty
argument_list|)
end_macro
begin_macro
name|Q_DECLARE_OPERATORS_FOR_FLAGS
argument_list|(
argument|ProcessProperties
argument_list|)
end_macro
begin_function
DECL|function|processProperties
specifier|static
specifier|inline
name|ProcessProperties
name|processProperties
parameter_list|()
block|{
name|ProcessProperties
name|result
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
name|HANDLE
name|processToken
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|OpenProcessToken
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|TOKEN_QUERY
argument_list|,
operator|&
name|processToken
argument_list|)
condition|)
block|{
name|DWORD
name|elevation
decl_stmt|;
comment|// struct containing a DWORD, not present in some MinGW headers.
name|DWORD
name|cbSize
init|=
sizeof|sizeof
argument_list|(
name|elevation
argument_list|)
decl_stmt|;
if|if
condition|(
name|GetTokenInformation
argument_list|(
name|processToken
argument_list|,
name|TokenElevation
argument_list|,
operator|&
name|elevation
argument_list|,
name|cbSize
argument_list|,
operator|&
name|cbSize
argument_list|)
operator|&&
name|elevation
condition|)
block|{
name|result
operator||=
name|ElevatedProcess
expr_stmt|;
block|}
comment|// Check for UAC virtualization (compatibility mode for old software
comment|// allowing it to write to system folders by mirroring them under
comment|// "\Users\...\AppData\Local\VirtualStore\", which is typically the case
comment|// for MinGW).
name|DWORD
name|virtualStoreEnabled
init|=
literal|0
decl_stmt|;
name|cbSize
operator|=
sizeof|sizeof
argument_list|(
name|virtualStoreEnabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetTokenInformation
argument_list|(
name|processToken
argument_list|,
name|TokenVirtualizationEnabled
argument_list|,
operator|&
name|virtualStoreEnabled
argument_list|,
name|cbSize
argument_list|,
operator|&
name|cbSize
argument_list|)
operator|&&
name|virtualStoreEnabled
condition|)
block|{
name|result
operator||=
name|VirtualStore
expr_stmt|;
block|}
name|CloseHandle
argument_list|(
name|processToken
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|noPermissionsWindows
name|void
name|tst_QLockFile
operator|::
name|noPermissionsWindows
parameter_list|()
block|{
comment|// Windows: Do the permissions test in a system directory in which
comment|// files cannot be created.
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
name|QSKIP
argument_list|(
literal|"This test is for desktop Windows only"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
name|QSysInfo
operator|::
name|windowsVersion
argument_list|()
operator|<
name|QSysInfo
operator|::
name|WV_WINDOWS7
condition|)
name|QSKIP
argument_list|(
literal|"This test requires at least Windows 7"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
specifier|const
name|int
name|p
init|=
name|processProperties
argument_list|()
condition|)
block|{
specifier|const
name|QByteArray
name|message
init|=
literal|"This test cannot be run (properties=0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|p
argument_list|,
literal|16
argument_list|)
operator|+
literal|')'
decl_stmt|;
name|QSKIP
argument_list|(
name|message
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|const
name|QString
name|fileName
init|=
name|QFile
operator|::
name|decodeName
argument_list|(
name|qgetenv
argument_list|(
literal|"ProgramFiles"
argument_list|)
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|QCoreApplication
operator|::
name|applicationName
argument_list|()
operator|+
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|toString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"yyMMddhhmm"
argument_list|)
argument_list|)
decl_stmt|;
name|QLockFile
name|lockFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
operator|!
name|lockFile
operator|.
name|lock
argument_list|()
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|lockFile
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|PermissionError
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|corruptedLockFile
name|void
name|tst_QLockFile
operator|::
name|corruptedLockFile
parameter_list|()
block|{
specifier|const
name|QString
name|fileName
init|=
name|dir
operator|.
name|path
argument_list|()
operator|+
literal|"/corruptedLockFile"
decl_stmt|;
block|{
comment|// Create a empty file. Typically the result of a computer crash or hard disk full.
name|QFile
name|file
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QVERIFY
argument_list|(
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|WriteOnly
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QLockFile
name|secondLock
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|secondLock
operator|.
name|setStaleLockTime
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|QVERIFY
argument_list|(
name|secondLock
operator|.
name|tryLock
argument_list|(
literal|10000
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|int
argument_list|(
name|secondLock
operator|.
name|error
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|QLockFile
operator|::
name|NoError
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|overwritePidInLockFile
name|bool
name|tst_QLockFile
operator|::
name|overwritePidInLockFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|filePath
parameter_list|,
name|qint64
name|pid
parameter_list|)
block|{
name|QFile
name|f
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadWrite
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Cannot open %s."
argument_list|,
name|qPrintable
argument_list|(
name|filePath
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QByteArray
name|buf
init|=
name|f
operator|.
name|readAll
argument_list|()
decl_stmt|;
name|int
name|i
init|=
name|buf
operator|.
name|indexOf
argument_list|(
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"Unexpected lockfile content."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|buf
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buf
operator|.
name|prepend
argument_list|(
name|QByteArray
operator|::
name|number
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|f
operator|.
name|resize
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|f
operator|.
name|write
argument_list|(
name|buf
argument_list|)
operator|==
name|buf
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_macro
name|QTEST_MAIN
argument_list|(
argument|tst_QLockFile
argument_list|)
end_macro
begin_include
include|#
directive|include
file|"tst_qlockfile.moc"
end_include
end_unit
