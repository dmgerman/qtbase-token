begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the test suite of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QStringList>
end_include
begin_include
include|#
directive|include
file|<QFile>
end_include
begin_include
include|#
directive|include
file|<QtTest/QtTest>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_include
include|#
directive|include
file|<sys/mman.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// MAP_ANON is deprecated on Linux, and MAP_ANONYMOUS is not present on Mac
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MAP_ANONYMOUS
end_ifndef
begin_define
DECL|macro|MAP_ANONYMOUS
define|#
directive|define
name|MAP_ANONYMOUS
value|MAP_ANON
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<private/qsimd_p.h>
end_include
begin_include
include|#
directive|include
file|"data.h"
end_include
begin_class
DECL|class|tst_QString
class|class
name|tst_QString
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
name|tst_QString
parameter_list|()
constructor_decl|;
private|private
name|slots
private|:
name|void
name|equals
parameter_list|()
specifier|const
function_decl|;
name|void
name|equals_data
parameter_list|()
specifier|const
function_decl|;
name|void
name|equals2_data
parameter_list|()
specifier|const
function_decl|;
name|void
name|equals2
parameter_list|()
specifier|const
function_decl|;
name|void
name|ucstrncmp_data
parameter_list|()
specifier|const
function_decl|;
name|void
name|ucstrncmp
parameter_list|()
specifier|const
function_decl|;
name|void
name|fromUtf8
parameter_list|()
specifier|const
function_decl|;
name|void
name|fromLatin1_data
parameter_list|()
specifier|const
function_decl|;
name|void
name|fromLatin1
parameter_list|()
specifier|const
function_decl|;
name|void
name|fromLatin1Alternatives_data
parameter_list|()
specifier|const
function_decl|;
name|void
name|fromLatin1Alternatives
parameter_list|()
specifier|const
function_decl|;
name|void
name|fromUtf8Alternatives_data
parameter_list|()
specifier|const
function_decl|;
name|void
name|fromUtf8Alternatives
parameter_list|()
specifier|const
function_decl|;
name|void
name|toUpper_data
parameter_list|()
function_decl|;
name|void
name|toUpper
parameter_list|()
function_decl|;
name|void
name|toLower_data
parameter_list|()
function_decl|;
name|void
name|toLower
parameter_list|()
function_decl|;
name|void
name|toCaseFolded_data
parameter_list|()
function_decl|;
name|void
name|toCaseFolded
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_function
DECL|function|equals
name|void
name|tst_QString
operator|::
name|equals
parameter_list|()
specifier|const
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|QBENCHMARK
block|{
name|a
operator|==
name|b
expr_stmt|;
block|}
block|}
end_function
begin_constructor
DECL|function|tst_QString
name|tst_QString
operator|::
name|tst_QString
parameter_list|()
block|{ }
end_constructor
begin_function
DECL|function|equals_data
name|void
name|tst_QString
operator|::
name|equals_data
parameter_list|()
specifier|const
block|{
specifier|static
specifier|const
struct|struct
block|{
name|ushort
name|data
index|[
literal|80
index|]
decl_stmt|;
name|int
name|dummy
decl_stmt|;
comment|// just to ensure 4-byte alignment
block|}
name|data
init|=
block|{
block|{
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
comment|// 16
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
comment|// 32
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
comment|// 48
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
comment|// 64
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|96
block|,
literal|96
block|,
literal|96
block|,
literal|96
block|,
literal|64
block|,
literal|64
block|,
literal|96
block|,
literal|96
block|,
literal|96
block|,
literal|96
block|,
literal|96
block|,
literal|96
comment|// 80
block|}
block|,
literal|0
block|}
struct|;
specifier|const
name|QChar
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|data
operator|.
name|data
argument_list|)
decl_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
name|QString
name|base
init|=
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
argument_list|,
literal|64
argument_list|)
decl_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"different-length"
argument_list|)
operator|<<
name|base
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"same-string"
argument_list|)
operator|<<
name|base
operator|<<
name|base
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"same-data"
argument_list|)
operator|<<
name|base
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|// try to avoid crossing a cache line (that is, at ptr[64])
name|QTest
operator|::
name|newRow
argument_list|(
literal|"aligned-aligned-4n"
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
argument_list|,
literal|60
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|2
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"aligned-unaligned-4n"
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
argument_list|,
literal|60
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"unaligned-unaligned-4n"
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
literal|60
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|3
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"aligned-aligned-4n+1"
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
argument_list|,
literal|61
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|2
argument_list|,
literal|61
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"aligned-unaligned-4n+1"
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
argument_list|,
literal|61
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
literal|61
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"unaligned-unaligned-4n+1"
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
literal|61
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|3
argument_list|,
literal|61
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"aligned-aligned-4n-1"
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
argument_list|,
literal|59
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|2
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"aligned-unaligned-4n-1"
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
argument_list|,
literal|59
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"unaligned-unaligned-4n-1"
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
literal|59
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|3
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"aligned-aligned-2n"
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
argument_list|,
literal|58
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|2
argument_list|,
literal|58
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"aligned-unaligned-2n"
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
argument_list|,
literal|58
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
literal|58
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"unaligned-unaligned-2n"
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
literal|58
argument_list|)
operator|<<
name|QString
operator|::
name|fromRawData
argument_list|(
name|ptr
operator|+
literal|3
argument_list|,
literal|58
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|equals2_memcmp_call
specifier|static
name|bool
name|equals2_memcmp_call
parameter_list|(
specifier|const
name|ushort
modifier|*
name|p1
parameter_list|,
specifier|const
name|ushort
modifier|*
name|p2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
name|memcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|len
operator|*
literal|2
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_function
DECL|function|equals2_bytewise
specifier|static
name|bool
name|equals2_bytewise
parameter_list|(
specifier|const
name|ushort
modifier|*
name|p1
parameter_list|,
specifier|const
name|ushort
modifier|*
name|p2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|p1
operator|==
name|p2
operator|||
operator|!
name|len
condition|)
return|return
literal|true
return|;
name|uchar
modifier|*
name|b1
init|=
operator|(
name|uchar
operator|*
operator|)
name|p1
decl_stmt|;
name|uchar
modifier|*
name|b2
init|=
operator|(
name|uchar
operator|*
operator|)
name|p2
decl_stmt|;
name|len
operator|*=
literal|2
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
if|if
condition|(
operator|*
name|b1
operator|++
operator|!=
operator|*
name|b2
operator|++
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|equals2_shortwise
specifier|static
name|bool
name|equals2_shortwise
parameter_list|(
specifier|const
name|ushort
modifier|*
name|p1
parameter_list|,
specifier|const
name|ushort
modifier|*
name|p2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|p1
operator|==
name|p2
operator|||
operator|!
name|len
condition|)
return|return
literal|true
return|;
comment|//    for (register int counter; counter< len; ++counter)
comment|//        if (p1[counter] != p2[counter])
comment|//            return false;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
name|p1
index|[
name|len
index|]
operator|!=
name|p2
index|[
name|len
index|]
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|equals2_intwise
specifier|static
name|bool
name|equals2_intwise
parameter_list|(
specifier|const
name|ushort
modifier|*
name|p1
parameter_list|,
specifier|const
name|ushort
modifier|*
name|p2
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|p1
operator|==
name|p2
operator|||
operator|!
name|length
condition|)
return|return
literal|true
return|;
specifier|register
union|union
block|{
specifier|const
name|quint16
modifier|*
name|w
decl_stmt|;
specifier|const
name|quint32
modifier|*
name|d
decl_stmt|;
name|quintptr
name|value
decl_stmt|;
block|}
name|sa
union|,
name|sb
union|;
name|sa
operator|.
name|w
operator|=
name|p1
expr_stmt|;
name|sb
operator|.
name|w
operator|=
name|p2
expr_stmt|;
comment|// check alignment
if|if
condition|(
operator|(
name|sa
operator|.
name|value
operator|&
literal|2
operator|)
operator|==
operator|(
name|sb
operator|.
name|value
operator|&
literal|2
operator|)
condition|)
block|{
comment|// both addresses have the same alignment
if|if
condition|(
name|sa
operator|.
name|value
operator|&
literal|2
condition|)
block|{
comment|// both addresses are not aligned to 4-bytes boundaries
comment|// compare the first character
if|if
condition|(
operator|*
name|sa
operator|.
name|w
operator|!=
operator|*
name|sb
operator|.
name|w
condition|)
return|return
literal|false
return|;
operator|--
name|length
expr_stmt|;
operator|++
name|sa
operator|.
name|w
expr_stmt|;
operator|++
name|sb
operator|.
name|w
expr_stmt|;
comment|// now both addresses are 4-bytes aligned
block|}
comment|// both addresses are 4-bytes aligned
comment|// do a fast 32-bit comparison
specifier|register
specifier|const
name|quint32
modifier|*
name|e
init|=
name|sa
operator|.
name|d
operator|+
operator|(
name|length
operator|>>
literal|1
operator|)
decl_stmt|;
for|for
control|(
init|;
name|sa
operator|.
name|d
operator|!=
name|e
condition|;
operator|++
name|sa
operator|.
name|d
operator|,
operator|++
name|sb
operator|.
name|d
control|)
block|{
if|if
condition|(
operator|*
name|sa
operator|.
name|d
operator|!=
operator|*
name|sb
operator|.
name|d
condition|)
return|return
literal|false
return|;
block|}
comment|// do we have a tail?
return|return
operator|(
name|length
operator|&
literal|1
operator|)
condition|?
operator|*
name|sa
operator|.
name|w
operator|==
operator|*
name|sb
operator|.
name|w
else|:
literal|true
return|;
block|}
else|else
block|{
comment|// one of the addresses isn't 4-byte aligned but the other is
specifier|register
specifier|const
name|quint16
modifier|*
name|e
init|=
name|sa
operator|.
name|w
operator|+
name|length
decl_stmt|;
for|for
control|(
init|;
name|sa
operator|.
name|w
operator|!=
name|e
condition|;
operator|++
name|sa
operator|.
name|w
operator|,
operator|++
name|sb
operator|.
name|w
control|)
block|{
if|if
condition|(
operator|*
name|sa
operator|.
name|w
operator|!=
operator|*
name|sb
operator|.
name|w
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|equals2_short_tail
specifier|static
specifier|inline
name|bool
name|equals2_short_tail
parameter_list|(
specifier|const
name|ushort
modifier|*
name|p1
parameter_list|,
specifier|const
name|ushort
modifier|*
name|p2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
operator|*
name|p1
operator|!=
operator|*
name|p2
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|--
name|len
condition|)
block|{
if|if
condition|(
name|p1
index|[
literal|1
index|]
operator|!=
name|p2
index|[
literal|1
index|]
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|--
name|len
condition|)
block|{
if|if
condition|(
name|p1
index|[
literal|2
index|]
operator|!=
name|p2
index|[
literal|2
index|]
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|--
name|len
condition|)
block|{
if|if
condition|(
name|p1
index|[
literal|3
index|]
operator|!=
name|p2
index|[
literal|3
index|]
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|--
name|len
condition|)
block|{
if|if
condition|(
name|p1
index|[
literal|4
index|]
operator|!=
name|p2
index|[
literal|4
index|]
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|--
name|len
condition|)
block|{
if|if
condition|(
name|p1
index|[
literal|5
index|]
operator|!=
name|p2
index|[
literal|5
index|]
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|--
name|len
condition|)
block|{
if|if
condition|(
name|p1
index|[
literal|6
index|]
operator|!=
name|p2
index|[
literal|6
index|]
condition|)
return|return
literal|false
return|;
return|return
name|p1
index|[
literal|7
index|]
operator|==
name|p2
index|[
literal|7
index|]
return|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//#pragma GCC optimize("no-unroll-loops")
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__SSE2__
end_ifdef
begin_function
DECL|function|equals2_sse2_aligned
specifier|static
name|bool
name|equals2_sse2_aligned
parameter_list|(
specifier|const
name|ushort
modifier|*
name|p1
parameter_list|,
specifier|const
name|ushort
modifier|*
name|p2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|8
condition|)
block|{
name|__m128i
name|q1
init|=
name|_mm_load_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|p1
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|q2
init|=
name|_mm_load_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|p2
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
decl_stmt|;
if|if
condition|(
name|ushort
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
operator|!=
name|ushort
argument_list|(
literal|0xffff
argument_list|)
condition|)
return|return
literal|false
return|;
name|len
operator|-=
literal|8
expr_stmt|;
name|counter
operator|+=
literal|8
expr_stmt|;
block|}
name|p1
operator|+=
name|counter
expr_stmt|;
name|p2
operator|+=
name|counter
expr_stmt|;
block|}
return|return
name|equals2_short_tail
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|equals2_sse2
specifier|static
name|bool
name|equals2_sse2
parameter_list|(
specifier|const
name|ushort
modifier|*
name|p1
parameter_list|,
specifier|const
name|ushort
modifier|*
name|p2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|p1
operator|==
name|p2
operator|||
operator|!
name|len
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|__m128i
name|q1
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|p1
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|q2
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|p2
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
decl_stmt|;
if|if
condition|(
name|ushort
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
operator|!=
literal|0xffff
condition|)
return|return
literal|false
return|;
name|len
operator|-=
literal|8
expr_stmt|;
name|counter
operator|+=
literal|8
expr_stmt|;
block|}
name|p1
operator|+=
name|counter
expr_stmt|;
name|p2
operator|+=
name|counter
expr_stmt|;
block|}
return|return
name|equals2_short_tail
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//static bool equals2_sse2(const ushort *p1, const ushort *p2, int len)
end_comment
begin_comment
comment|//{
end_comment
begin_comment
comment|//    register int val1 = quintptr(p1)& 0xf;
end_comment
begin_comment
comment|//    register int val2 = quintptr(p2)& 0xf;
end_comment
begin_comment
comment|//    if (false&& val1 + val2 == 0)
end_comment
begin_comment
comment|//        return equals2_sse2_aligned(p1, p2, len);
end_comment
begin_comment
comment|//    else
end_comment
begin_comment
comment|//        return equals2_sse2_unaligned(p1, p2, len);
end_comment
begin_comment
comment|//}
end_comment
begin_function
DECL|function|equals2_sse2_aligning
specifier|static
name|bool
name|equals2_sse2_aligning
parameter_list|(
specifier|const
name|ushort
modifier|*
name|p1
parameter_list|,
specifier|const
name|ushort
modifier|*
name|p2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
literal|8
condition|)
return|return
name|equals2_short_tail
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|len
argument_list|)
return|;
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
comment|// which one is easier to align, p1 or p2 ?
specifier|register
name|int
name|val1
init|=
name|quintptr
argument_list|(
name|p1
argument_list|)
operator|&
literal|0xf
decl_stmt|;
specifier|register
name|int
name|val2
init|=
name|quintptr
argument_list|(
name|p2
argument_list|)
operator|&
literal|0xf
decl_stmt|;
if|if
condition|(
name|val1
operator|&&
name|val2
condition|)
block|{
if|#
directive|if
literal|0
comment|// we'll align the one which requires the least number of steps
block|if (val1> val2) {             qSwap(p1, p2);             val1 = val2;         }
comment|// val1 contains the number of bytes past the 16-aligned mark
comment|// we must read 16-val1 bytes to align
block|val1 = 16 - val1;         if (val1& 0x2) {             if (*p1 != *p2)                 return false;             --len;             ++counter;         }         while (val1& 12) {             if (*(uint*)p1 != *(uint*)p2)                 return false;             --len;             counter += 2;             val1 -= 4;         }
else|#
directive|else
comment|// we'll align the one closest to the 16-byte mark
if|if
condition|(
name|val1
operator|>
name|val2
condition|)
block|{
name|qSwap
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|val1
operator|=
name|val2
expr_stmt|;
block|}
comment|// we're reading val1 bytes too many
name|__m128i
name|q2
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|p2
operator|-
name|val1
operator|/
literal|2
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
operator|*
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|p1
operator|-
name|val1
operator|/
literal|2
operator|)
argument_list|,
name|q2
argument_list|)
decl_stmt|;
if|if
condition|(
name|short
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
operator|>>
name|val1
operator|!=
name|short
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|false
return|;
name|counter
operator|=
literal|8
operator|-
name|val1
operator|/
literal|2
expr_stmt|;
name|len
operator|-=
literal|8
operator|-
name|val1
operator|/
literal|2
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|val2
condition|)
block|{
comment|// p2 is already aligned
name|qSwap
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
comment|// p1 is aligned
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|__m128i
name|q1
init|=
name|_mm_load_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|p1
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|q2
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|p2
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
decl_stmt|;
if|if
condition|(
name|ushort
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
operator|!=
name|ushort
argument_list|(
literal|0xffff
argument_list|)
condition|)
return|return
literal|false
return|;
name|len
operator|-=
literal|8
expr_stmt|;
name|counter
operator|+=
literal|8
expr_stmt|;
block|}
comment|// tail
return|return
name|equals2_short_tail
argument_list|(
name|p1
operator|+
name|counter
argument_list|,
name|p2
operator|+
name|counter
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__SSE3__
end_ifdef
begin_function
DECL|function|equals2_sse3
specifier|static
name|bool
name|equals2_sse3
parameter_list|(
specifier|const
name|ushort
modifier|*
name|p1
parameter_list|,
specifier|const
name|ushort
modifier|*
name|p2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|p1
operator|==
name|p2
operator|||
operator|!
name|len
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|__m128i
name|q1
init|=
name|_mm_lddqu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|p1
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|q2
init|=
name|_mm_lddqu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|p2
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
decl_stmt|;
if|if
condition|(
name|ushort
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
operator|!=
literal|0xffff
condition|)
return|return
literal|false
return|;
name|len
operator|-=
literal|8
expr_stmt|;
name|counter
operator|+=
literal|8
expr_stmt|;
block|}
name|p1
operator|+=
name|counter
expr_stmt|;
name|p2
operator|+=
name|counter
expr_stmt|;
block|}
return|return
name|equals2_short_tail
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__SSSE3__
end_ifdef
begin_function
DECL|function|equals2_ssse3_alignr
template|template
parameter_list|<
name|int
name|N
parameter_list|>
specifier|static
specifier|inline
name|bool
name|equals2_ssse3_alignr
parameter_list|(
name|__m128i
modifier|*
name|m1
parameter_list|,
name|__m128i
modifier|*
name|m2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|__m128i
name|lower
init|=
name|_mm_load_si128
argument_list|(
name|m1
argument_list|)
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|__m128i
name|upper
init|=
name|_mm_load_si128
argument_list|(
name|m1
operator|+
literal|1
argument_list|)
decl_stmt|;
name|__m128i
name|correct
decl_stmt|;
name|correct
operator|=
name|_mm_alignr_epi8
argument_list|(
name|upper
argument_list|,
name|lower
argument_list|,
name|N
argument_list|)
expr_stmt|;
name|__m128i
name|q2
init|=
name|_mm_lddqu_si128
argument_list|(
name|m2
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|correct
argument_list|,
name|q2
argument_list|)
decl_stmt|;
if|if
condition|(
name|ushort
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
operator|!=
literal|0xffff
condition|)
return|return
literal|false
return|;
name|len
operator|-=
literal|8
expr_stmt|;
operator|++
name|m2
expr_stmt|;
operator|++
name|m1
expr_stmt|;
name|lower
operator|=
name|upper
expr_stmt|;
block|}
comment|// tail
return|return
name|len
operator|==
literal|0
operator|||
name|equals2_short_tail
argument_list|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|m1
operator|+
name|N
operator|/
literal|2
argument_list|,
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|m2
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|equals2_ssse3_aligned
specifier|static
specifier|inline
name|bool
name|equals2_ssse3_aligned
parameter_list|(
name|__m128i
modifier|*
name|m1
parameter_list|,
name|__m128i
modifier|*
name|m2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|__m128i
name|q2
init|=
name|_mm_lddqu_si128
argument_list|(
name|m2
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
operator|*
name|m1
argument_list|,
name|q2
argument_list|)
decl_stmt|;
if|if
condition|(
name|ushort
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
operator|!=
literal|0xffff
condition|)
return|return
literal|false
return|;
name|len
operator|-=
literal|8
expr_stmt|;
operator|++
name|m1
expr_stmt|;
operator|++
name|m2
expr_stmt|;
block|}
return|return
name|len
operator|==
literal|0
operator|||
name|equals2_short_tail
argument_list|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|m1
argument_list|,
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|m2
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|equals2_ssse3
specifier|static
name|bool
name|equals2_ssse3
parameter_list|(
specifier|const
name|ushort
modifier|*
name|p1
parameter_list|,
specifier|const
name|ushort
modifier|*
name|p2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// p1& 0xf can be:
comment|//   0,  2,  4,  6,  8, 10, 12, 14
comment|// If it's 0, we're aligned
comment|// If it's not, then we're interested in the 16 - (p1& 0xf) bytes only
if|if
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
comment|// find the last aligned position below the p1 memory
name|__m128i
modifier|*
name|m1
init|=
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|quintptr
argument_list|(
name|p1
argument_list|)
operator|&
operator|~
literal|0xf
operator|)
decl_stmt|;
name|__m128i
modifier|*
name|m2
init|=
operator|(
name|__m128i
operator|*
operator|)
name|p2
decl_stmt|;
name|qptrdiff
name|diff
init|=
name|quintptr
argument_list|(
name|p1
argument_list|)
operator|-
name|quintptr
argument_list|(
name|m1
argument_list|)
decl_stmt|;
comment|// diff contains the number of extra bytes
if|if
condition|(
name|diff
operator|==
literal|10
condition|)
return|return
name|equals2_ssse3_alignr
argument_list|<
literal|10
argument_list|>
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
elseif|else
if|if
condition|(
name|diff
operator|==
literal|2
condition|)
return|return
name|equals2_ssse3_alignr
argument_list|<
literal|2
argument_list|>
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
if|if
condition|(
name|diff
operator|<
literal|8
condition|)
block|{
if|if
condition|(
name|diff
operator|<
literal|4
condition|)
block|{
return|return
name|equals2_ssse3_aligned
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|diff
operator|==
literal|4
condition|)
return|return
name|equals2_ssse3_alignr
argument_list|<
literal|4
argument_list|>
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
else|else
comment|// diff == 6
return|return
name|equals2_ssse3_alignr
argument_list|<
literal|6
argument_list|>
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|diff
operator|<
literal|12
condition|)
block|{
return|return
name|equals2_ssse3_alignr
argument_list|<
literal|8
argument_list|>
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|diff
operator|==
literal|12
condition|)
return|return
name|equals2_ssse3_alignr
argument_list|<
literal|12
argument_list|>
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
else|else
comment|// diff == 14
return|return
name|equals2_ssse3_alignr
argument_list|<
literal|14
argument_list|>
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
block|}
comment|// tail
return|return
name|equals2_short_tail
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|equals2_ssse3_aligning_alignr
template|template
parameter_list|<
name|int
name|N
parameter_list|>
specifier|static
specifier|inline
name|bool
name|equals2_ssse3_aligning_alignr
parameter_list|(
name|__m128i
modifier|*
name|m1
parameter_list|,
name|__m128i
modifier|*
name|m2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|__m128i
name|lower
init|=
name|_mm_load_si128
argument_list|(
name|m1
argument_list|)
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|__m128i
name|upper
init|=
name|_mm_load_si128
argument_list|(
name|m1
operator|+
literal|1
argument_list|)
decl_stmt|;
name|__m128i
name|correct
decl_stmt|;
name|correct
operator|=
name|_mm_alignr_epi8
argument_list|(
name|upper
argument_list|,
name|lower
argument_list|,
name|N
argument_list|)
expr_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|correct
argument_list|,
operator|*
name|m2
argument_list|)
decl_stmt|;
if|if
condition|(
name|ushort
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
operator|!=
literal|0xffff
condition|)
return|return
literal|false
return|;
name|len
operator|-=
literal|8
expr_stmt|;
operator|++
name|m2
expr_stmt|;
operator|++
name|m1
expr_stmt|;
name|lower
operator|=
name|upper
expr_stmt|;
block|}
comment|// tail
return|return
name|len
operator|==
literal|0
operator|||
name|equals2_short_tail
argument_list|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|m1
operator|+
name|N
operator|/
literal|2
argument_list|,
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|m2
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|equals2_ssse3_aligning
specifier|static
name|bool
name|equals2_ssse3_aligning
parameter_list|(
specifier|const
name|ushort
modifier|*
name|p1
parameter_list|,
specifier|const
name|ushort
modifier|*
name|p2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
literal|8
condition|)
return|return
name|equals2_short_tail
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|len
argument_list|)
return|;
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
comment|// which one is easier to align, p1 or p2 ?
block|{
specifier|register
name|int
name|val1
init|=
name|quintptr
argument_list|(
name|p1
argument_list|)
operator|&
literal|0xf
decl_stmt|;
specifier|register
name|int
name|val2
init|=
name|quintptr
argument_list|(
name|p2
argument_list|)
operator|&
literal|0xf
decl_stmt|;
if|if
condition|(
name|val1
operator|&&
name|val2
condition|)
block|{
comment|// we'll align the one closest to the 16-byte mark
if|if
condition|(
name|val1
operator|<
name|val2
condition|)
block|{
name|qSwap
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|val2
operator|=
name|val1
expr_stmt|;
block|}
comment|// we're reading val1 bytes too many
name|__m128i
name|q1
init|=
name|_mm_lddqu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|p1
operator|-
name|val2
operator|/
literal|2
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|q1
argument_list|,
operator|*
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|p2
operator|-
name|val2
operator|/
literal|2
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|short
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
operator|>>
name|val1
operator|!=
name|short
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|false
return|;
name|counter
operator|=
literal|8
operator|-
name|val2
operator|/
literal|2
expr_stmt|;
name|len
operator|-=
literal|8
operator|-
name|val2
operator|/
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|val1
condition|)
block|{
comment|// p1 is already aligned
name|qSwap
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
block|}
comment|// p2 is aligned now
comment|// we want to use palignr in the mis-alignment of p1
name|__m128i
modifier|*
name|m1
init|=
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|quintptr
argument_list|(
name|p1
operator|+
name|counter
argument_list|)
operator|&
operator|~
literal|0xf
operator|)
decl_stmt|;
name|__m128i
modifier|*
name|m2
init|=
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|p2
operator|+
name|counter
operator|)
decl_stmt|;
specifier|register
name|int
name|val1
init|=
name|quintptr
argument_list|(
name|p1
operator|+
name|counter
argument_list|)
operator|-
name|quintptr
argument_list|(
name|m1
argument_list|)
decl_stmt|;
comment|// val1 contains the number of extra bytes
if|if
condition|(
name|val1
operator|==
literal|8
condition|)
return|return
name|equals2_ssse3_aligning_alignr
argument_list|<
literal|8
argument_list|>
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
if|if
condition|(
name|val1
operator|==
literal|0
condition|)
return|return
name|equals2_sse2_aligned
argument_list|(
name|p1
operator|+
name|counter
argument_list|,
name|p2
operator|+
name|counter
argument_list|,
name|len
argument_list|)
return|;
if|if
condition|(
name|val1
operator|<
literal|8
condition|)
block|{
if|if
condition|(
name|val1
operator|<
literal|4
condition|)
block|{
return|return
name|equals2_ssse3_aligning_alignr
argument_list|<
literal|2
argument_list|>
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|val1
operator|==
literal|4
condition|)
return|return
name|equals2_ssse3_aligning_alignr
argument_list|<
literal|4
argument_list|>
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
else|else
comment|// diff == 6
return|return
name|equals2_ssse3_aligning_alignr
argument_list|<
literal|6
argument_list|>
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|val1
operator|<
literal|12
condition|)
block|{
return|return
name|equals2_ssse3_aligning_alignr
argument_list|<
literal|10
argument_list|>
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|val1
operator|==
literal|12
condition|)
return|return
name|equals2_ssse3_aligning_alignr
argument_list|<
literal|12
argument_list|>
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
else|else
comment|// diff == 14
return|return
name|equals2_ssse3_aligning_alignr
argument_list|<
literal|14
argument_list|>
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__SSE4_1__
end_ifdef
begin_function
DECL|function|equals2_sse4
specifier|static
name|bool
name|equals2_sse4
parameter_list|(
specifier|const
name|ushort
modifier|*
name|p1
parameter_list|,
specifier|const
name|ushort
modifier|*
name|p2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// We use the pcmpestrm instruction searching for differences (negative polarity)
comment|// it will reset CF if it's all equal
comment|// it will reset OF if the first char is equal
comment|// it will set ZF& SF if the length is less than 8 (which means we've done the last operation)
comment|// the three possible conditions are:
comment|//  difference found:         CF = 1
comment|//  all equal, not finished:  CF = ZF = SF = 0
comment|//  all equal, finished:      CF = 0, ZF = SF = 1
comment|// We use the JA instruction that jumps if ZF = 0 and CF = 0
if|if
condition|(
name|p1
operator|==
name|p2
operator|||
operator|!
name|len
condition|)
return|return
literal|true
return|;
comment|// This function may read some bytes past the end of p1 or p2
comment|// It is safe to do that, as long as those extra bytes (beyond p1+len and p2+len)
comment|// are on the same page as the last valid byte.
comment|// If len is a multiple of 8, we'll never load invalid bytes.
if|if
condition|(
name|len
operator|&
literal|7
condition|)
block|{
comment|// The last load would load (len& ~7) valid bytes and (8 - (len& ~7)) invalid bytes.
comment|// So we can't do the last load if any of those bytes is in a different
comment|// page. That is, if:
comment|//    pX + len      is on a different page from     pX + (len& ~7) + 8
comment|//
comment|// that is, if second-to-last load ended up less than 16 bytes from the page end:
comment|//    pX + (len& ~7)  is the last ushort read in the second-to-last load
if|if
condition|(
name|len
operator|<
literal|8
condition|)
return|return
name|equals2_short_tail
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|len
argument_list|)
return|;
if|if
condition|(
operator|(
name|quintptr
argument_list|(
name|p1
operator|+
operator|(
name|len
operator|&
operator|~
literal|7
operator|)
argument_list|)
operator|&
literal|0xfff
operator|)
operator|>
literal|0xff0
operator|||
operator|(
name|quintptr
argument_list|(
name|p2
operator|+
operator|(
name|len
operator|&
operator|~
literal|7
operator|)
argument_list|)
operator|&
literal|0xfff
operator|)
operator|>
literal|0xff0
condition|)
block|{
comment|// yes, so we mustn't do the final 128-bit load
name|bool
name|result
decl_stmt|;
asm|asm (             "sub        %[p1], %[p2]\n\t"             "sub        $16, %[p1]\n\t"             "add        $8, %[len]\n\t"
comment|// main loop:
asm|"0:\n\t"             "add        $16, %[p1]\n\t"             "sub        $8, %[len]\n\t"             "jz         1f\n\t"             "lddqu      (%[p1]), %%xmm0\n\t"             "mov        %[len], %%edx\n\t"             "pcmpestri  %[mode], (%[p2],%[p1]), %%xmm0\n\t"              "jna        1f\n\t"             "add        $16, %[p1]\n\t"             "sub        $8, %[len]\n\t"             "jz         1f\n\t"             "lddqu      (%[p1]), %%xmm0\n\t"             "mov        %[len], %%edx\n\t"             "pcmpestri  %[mode], (%[p2],%[p1]), %%xmm0\n\t"              "ja         0b\n\t"             "1:\n\t"             "setnc      %[result]\n\t"             : [result] "=a" (result),               [p1] "+r" (p1),               [p2] "+r" (p2)             : [len] "0" (len& ~7),               [mode] "i" (_SIDD_UWORD_OPS | _SIDD_CMP_EQUAL_EACH | _SIDD_NEGATIVE_POLARITY)             : "%edx", "%ecx", "%xmm0"             );
return|return
name|result
operator|&&
name|equals2_short_tail
argument_list|(
name|p1
argument_list|,
operator|(
specifier|const
name|ushort
operator|*
operator|)
operator|(
name|quintptr
argument_list|(
name|p1
argument_list|)
operator|+
name|quintptr
argument_list|(
name|p2
argument_list|)
operator|)
argument_list|,
name|len
operator|&
literal|7
argument_list|)
return|;
block|}
block|}
comment|//    const qptrdiff disp = p2 - p1;
comment|//    p1 -= 8;
comment|//    len += 8;
comment|//    while (true) {
comment|//        enum { Mode = _SIDD_UWORD_OPS | _SIDD_CMP_EQUAL_EACH | _SIDD_NEGATIVE_POLARITY };
comment|//        p1 += 8;
comment|//        len -= 8;
comment|//        if (!len)
comment|//            return true;
comment|//        __m128i q1 = _mm_lddqu_si128((__m128i *)(p1 + disp));
comment|//        __m128i *m2 = (__m128i *)p1;
comment|//        bool cmp_a = _mm_cmpestra(q1, len, *m2, len, Mode);
comment|//        if (cmp_a)
comment|//            continue;
comment|//        return !_mm_cmpestrc(q1, len, *m2, len, Mode);
comment|//    }
comment|//    return true;
name|bool
name|result
decl_stmt|;
asm|asm (         "sub        %[p1], %[p2]\n\t"         "sub        $16, %[p1]\n\t"         "add        $8, %[len]\n\t"      "0:\n\t"         "add        $16, %[p1]\n\t"         "sub        $8, %[len]\n\t"         "jz         1f\n\t"         "lddqu      (%[p2],%[p1]), %%xmm0\n\t"         "mov        %[len], %%edx\n\t"         "pcmpestri  %[mode], (%[p1]), %%xmm0\n\t"          "jna        1f\n\t"         "add        $16, %[p1]\n\t"         "sub        $8, %[len]\n\t"         "jz         1f\n\t"         "lddqu      (%[p2],%[p1]), %%xmm0\n\t"         "mov        %[len], %%edx\n\t"         "pcmpestri  %[mode], (%[p1]), %%xmm0\n\t"          "ja         0b\n\t"      "1:\n\t"         "setnc      %[result]\n\t"         : [result] "=a" (result)         : [len] "0" (len),           [p1] "r" (p1),           [p2] "r" (p2),           [mode] "i" (_SIDD_UWORD_OPS | _SIDD_CMP_EQUAL_EACH | _SIDD_NEGATIVE_POLARITY)         : "%edx", "%ecx", "%xmm0"     );
return|return
name|result
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|FuncPtr
typedef|typedef
name|bool
function_decl|(
modifier|*
name|FuncPtr
function_decl|)
parameter_list|(
specifier|const
name|ushort
modifier|*
parameter_list|,
specifier|const
name|ushort
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef
begin_decl_stmt
DECL|variable|func
specifier|static
specifier|const
name|FuncPtr
name|func
index|[]
init|=
block|{
name|equals2_memcmp_call
block|,
comment|// 0
name|equals2_bytewise
block|,
comment|// 1
name|equals2_shortwise
block|,
comment|// 1
name|equals2_intwise
block|,
comment|// 3
ifdef|#
directive|ifdef
name|__SSE2__
name|equals2_sse2
block|,
comment|// 4
name|equals2_sse2_aligning
block|,
comment|// 5
ifdef|#
directive|ifdef
name|__SSE3__
name|equals2_sse3
block|,
comment|// 6
ifdef|#
directive|ifdef
name|__SSSE3__
name|equals2_ssse3
block|,
comment|// 7
name|equals2_ssse3
block|,
comment|// 8
ifdef|#
directive|ifdef
name|__SSE4_1__
name|equals2_sse4
block|,
comment|// 9
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|functionCount
specifier|static
specifier|const
name|int
name|functionCount
init|=
sizeof|sizeof
argument_list|(
name|func
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|func
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|equals2_data
name|void
name|tst_QString
operator|::
name|equals2_data
parameter_list|()
specifier|const
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|int
argument_list|>
argument_list|(
literal|"algorithm"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"selftest"
argument_list|)
operator|<<
operator|-
literal|1
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"memcmp_call"
argument_list|)
operator|<<
literal|0
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"bytewise"
argument_list|)
operator|<<
literal|1
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"shortwise"
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"intwise"
argument_list|)
operator|<<
literal|3
expr_stmt|;
ifdef|#
directive|ifdef
name|__SSE2__
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse2"
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse2_aligning"
argument_list|)
operator|<<
literal|5
expr_stmt|;
ifdef|#
directive|ifdef
name|__SSE3__
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse3"
argument_list|)
operator|<<
literal|6
expr_stmt|;
ifdef|#
directive|ifdef
name|__SSSE3__
name|QTest
operator|::
name|newRow
argument_list|(
literal|"ssse3"
argument_list|)
operator|<<
literal|7
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"ssse3_aligning"
argument_list|)
operator|<<
literal|8
expr_stmt|;
ifdef|#
directive|ifdef
name|__SSE4_1__
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse4.2"
argument_list|)
operator|<<
literal|9
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_decl_stmt
DECL|function|equals2_selftest
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|noinline
operator|)
argument_list|)
name|equals2_selftest
argument_list|()
argument_list|{
ifdef|#
directive|ifdef
name|Q_OS_UNIX
specifier|const
name|long
name|pagesize
operator|=
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
argument_list|;
name|void
operator|*
name|page1
argument_list|,
operator|*
name|page3
argument_list|;
name|ushort
operator|*
name|page2
argument_list|;
name|page1
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|pagesize
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANONYMOUS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|;
name|page2
operator|=
operator|(
name|ushort
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|pagesize
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANONYMOUS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|;
name|page3
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|pagesize
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANONYMOUS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|;
name|Q_ASSERT
argument_list|(
name|quintptr
argument_list|(
name|page2
argument_list|)
operator|==
name|quintptr
argument_list|(
name|page1
argument_list|)
operator|+
name|pagesize
operator|||
name|quintptr
argument_list|(
name|page2
argument_list|)
operator|==
name|quintptr
argument_list|(
name|page1
argument_list|)
operator|-
name|pagesize
argument_list|)
argument_list|;
name|Q_ASSERT
argument_list|(
name|quintptr
argument_list|(
name|page3
argument_list|)
operator|==
name|quintptr
argument_list|(
name|page2
argument_list|)
operator|+
name|pagesize
operator|||
name|quintptr
argument_list|(
name|page3
argument_list|)
operator|==
name|quintptr
argument_list|(
name|page2
argument_list|)
operator|-
name|pagesize
argument_list|)
argument_list|;
name|munmap
argument_list|(
name|page1
argument_list|,
name|pagesize
argument_list|)
argument_list|;
name|munmap
argument_list|(
name|page3
argument_list|,
name|pagesize
argument_list|)
argument_list|;
comment|// populate our page
argument_list|for
operator|(
name|uint
name|i
operator|=
literal|0
expr|;
name|i
operator|<
name|pagesize
operator|/
expr|sizeof
operator|(
name|long
name|long
operator|)
expr|;
operator|++
name|i
operator|)
operator|(
operator|(
name|long
name|long
operator|*
operator|)
name|page2
operator|)
index|[
name|i
index|]
operator|=
name|Q_INT64_C
argument_list|(
literal|0x0041004100410041
argument_list|)
argument_list|;
comment|// the following should crash:
comment|//page2[-1] = 0xdead;
comment|//page2[pagesize / sizeof(ushort) + 1] = 0xbeef;
specifier|static
specifier|const
name|ushort
name|needle
index|[]
operator|=
block|{
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|}
argument_list|;      for
operator|(
name|int
name|algo
operator|=
literal|0
expr|;
name|algo
operator|<
name|functionCount
expr|;
operator|++
name|algo
operator|)
block|{
comment|// boundary condition test:
for|for
control|(
name|int
name|i
type|= 0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
operator|(
name|func
index|[
name|algo
index|]
operator|)
operator|(
name|page2
operator|+
name|i
operator|,
name|needle
operator|,
sizeof|sizeof
name|needle
operator|/
literal|2
operator|)
block|;
operator|(
name|func
index|[
name|algo
index|]
operator|)
operator|(
name|page2
operator|-
name|i
operator|-
literal|1
operator|-
sizeof|sizeof
argument_list|(
name|needle
argument_list|)
operator|/
literal|2
operator|+
name|pagesize
operator|/
literal|2
operator|,
name|needle
operator|,
sizeof|sizeof
name|needle
operator|/
literal|2
operator|)
block|;         }
block|}
name|munmap
argument_list|(
name|page2
argument_list|,
name|pagesize
argument_list|)
argument_list|;
endif|#
directive|endif
argument_list|for
operator|(
name|int
name|algo
operator|=
literal|0
expr|;
name|algo
operator|<
name|functionCount
expr|;
operator|++
name|algo
operator|)
block|{
for|for
control|(
name|int
name|i
type|= 0
init|;
name|i
operator|<
name|stringCollectionCount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|ushort
operator|*
name|p1
operator|=
name|stringCollectionData
operator|+
name|stringCollection
index|[
name|i
index|]
operator|.
name|offset1
block|;
specifier|const
name|ushort
operator|*
name|p2
operator|=
name|stringCollectionData
operator|+
name|stringCollection
index|[
name|i
index|]
operator|.
name|offset2
block|;
name|bool
name|expected
operator|=
name|memcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|stringCollection
index|[
name|i
index|]
operator|.
name|len
operator|*
literal|2
argument_list|)
operator|==
literal|0
block|;
name|bool
name|result
operator|=
operator|(
name|func
index|[
name|algo
index|]
operator|)
operator|(
name|p1
operator|,
name|p2
operator|,
name|stringCollection
index|[
name|i
index|]
operator|.
name|len
operator|)
block|;
if|if
condition|(
name|expected
operator|!=
name|result
condition|)
name|qWarning
argument_list|()
operator|.
name|nospace
argument_list|()
operator|<<
literal|"algo="
operator|<<
name|algo
operator|<<
literal|" i="
operator|<<
name|i
operator|<<
literal|" failed ("
operator|<<
name|result
operator|<<
literal|"!="
operator|<<
name|expected
operator|<<
literal|"); strings were "
operator|<<
name|QByteArray
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p1
argument_list|,
name|stringCollection
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|.
name|toHex
argument_list|()
operator|<<
literal|" and "
operator|<<
name|QByteArray
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p2
argument_list|,
name|stringCollection
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|.
name|toHex
argument_list|()
expr_stmt|;
block|}
expr|} }
DECL|function|equals2
name|void
name|tst_QString
operator|::
name|equals2
operator|(
operator|)
specifier|const
block|{
name|QFETCH
argument_list|(
name|int
argument_list|,
name|algorithm
argument_list|)
block|;
if|if
condition|(
name|algorithm
operator|==
operator|-
literal|1
condition|)
block|{
name|equals2_selftest
argument_list|()
block|;
return|return;
block|}
name|QBENCHMARK
block|{
for|for
control|(
name|int
name|i
type|= 0
init|;
name|i
operator|<
name|stringCollectionCount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|ushort
operator|*
name|p1
operator|=
name|stringCollectionData
operator|+
name|stringCollection
index|[
name|i
index|]
operator|.
name|offset1
block|;
specifier|const
name|ushort
operator|*
name|p2
operator|=
name|stringCollectionData
operator|+
name|stringCollection
index|[
name|i
index|]
operator|.
name|offset2
block|;
name|bool
name|result
operator|=
operator|(
name|func
index|[
name|algorithm
index|]
operator|)
operator|(
name|p1
operator|,
name|p2
operator|,
name|stringCollection
index|[
name|i
index|]
operator|.
name|len
operator|)
block|;
name|Q_UNUSED
argument_list|(
name|result
argument_list|)
block|;         }
block|}
expr|}
DECL|function|ucstrncmp_shortwise
specifier|static
name|int
name|ucstrncmp_shortwise
argument_list|(
argument|const ushort *a
argument_list|,
argument|const ushort *b
argument_list|,
argument|int l
argument_list|)
block|{
while|while
condition|(
name|l
operator|--
operator|&&
operator|*
name|a
operator|==
operator|*
name|b
condition|)
name|a
operator|++
operator|,
name|b
operator|++
expr_stmt|;
if|if
condition|(
name|l
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
operator|*
name|a
operator|-
operator|*
name|b
return|;
end_decl_stmt
begin_function
unit|}  static
DECL|function|ucstrncmp_intwise
name|int
name|ucstrncmp_intwise
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|b
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// do both strings have the same alignment?
if|if
condition|(
operator|(
name|quintptr
argument_list|(
name|a
argument_list|)
operator|&
literal|2
operator|)
operator|==
operator|(
name|quintptr
argument_list|(
name|b
argument_list|)
operator|&
literal|2
operator|)
condition|)
block|{
comment|// are we aligned to 4 bytes?
if|if
condition|(
name|quintptr
argument_list|(
name|a
argument_list|)
operator|&
literal|2
condition|)
block|{
if|if
condition|(
operator|*
name|a
operator|!=
operator|*
name|b
condition|)
return|return
operator|*
name|a
operator|-
operator|*
name|b
return|;
operator|++
name|a
expr_stmt|;
operator|++
name|b
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
specifier|const
name|uint
modifier|*
name|p1
init|=
operator|(
specifier|const
name|uint
operator|*
operator|)
name|a
decl_stmt|;
specifier|const
name|uint
modifier|*
name|p2
init|=
operator|(
specifier|const
name|uint
operator|*
operator|)
name|b
decl_stmt|;
name|quintptr
name|counter
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|1
condition|;
name|len
operator|-=
literal|2
operator|,
operator|++
name|counter
control|)
block|{
if|if
condition|(
name|p1
index|[
name|counter
index|]
operator|!=
name|p2
index|[
name|counter
index|]
condition|)
block|{
comment|// which ushort isn't equal?
name|int
name|diff
init|=
name|a
index|[
literal|2
operator|*
name|counter
index|]
operator|-
name|b
index|[
literal|2
operator|*
name|counter
index|]
decl_stmt|;
return|return
name|diff
condition|?
name|diff
else|:
name|a
index|[
literal|2
operator|*
name|counter
operator|+
literal|1
index|]
operator|-
name|b
index|[
literal|2
operator|*
name|counter
operator|+
literal|1
index|]
return|;
block|}
block|}
return|return
name|len
condition|?
name|a
index|[
literal|2
operator|*
name|counter
index|]
operator|-
name|b
index|[
literal|2
operator|*
name|counter
index|]
else|:
literal|0
return|;
block|}
else|else
block|{
while|while
condition|(
name|len
operator|--
operator|&&
operator|*
name|a
operator|==
operator|*
name|b
condition|)
name|a
operator|++
operator|,
name|b
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
operator|*
name|a
operator|-
operator|*
name|b
return|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__SSE2__
end_ifdef
begin_function
DECL|function|ucstrncmp_short_tail
specifier|static
specifier|inline
name|int
name|ucstrncmp_short_tail
parameter_list|(
specifier|const
name|ushort
modifier|*
name|p1
parameter_list|,
specifier|const
name|ushort
modifier|*
name|p2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
operator|*
name|p1
operator|!=
operator|*
name|p2
condition|)
return|return
operator|*
name|p1
operator|-
operator|*
name|p2
return|;
if|if
condition|(
operator|--
name|len
condition|)
block|{
if|if
condition|(
name|p1
index|[
literal|1
index|]
operator|!=
name|p2
index|[
literal|1
index|]
condition|)
return|return
name|p1
index|[
literal|1
index|]
operator|-
name|p2
index|[
literal|1
index|]
return|;
if|if
condition|(
operator|--
name|len
condition|)
block|{
if|if
condition|(
name|p1
index|[
literal|2
index|]
operator|!=
name|p2
index|[
literal|2
index|]
condition|)
return|return
name|p1
index|[
literal|2
index|]
operator|-
name|p2
index|[
literal|2
index|]
return|;
if|if
condition|(
operator|--
name|len
condition|)
block|{
if|if
condition|(
name|p1
index|[
literal|3
index|]
operator|!=
name|p2
index|[
literal|3
index|]
condition|)
return|return
name|p1
index|[
literal|3
index|]
operator|-
name|p2
index|[
literal|3
index|]
return|;
if|if
condition|(
operator|--
name|len
condition|)
block|{
if|if
condition|(
name|p1
index|[
literal|4
index|]
operator|!=
name|p2
index|[
literal|4
index|]
condition|)
return|return
name|p1
index|[
literal|4
index|]
operator|-
name|p2
index|[
literal|4
index|]
return|;
if|if
condition|(
operator|--
name|len
condition|)
block|{
if|if
condition|(
name|p1
index|[
literal|5
index|]
operator|!=
name|p2
index|[
literal|5
index|]
condition|)
return|return
name|p1
index|[
literal|5
index|]
operator|-
name|p2
index|[
literal|5
index|]
return|;
if|if
condition|(
operator|--
name|len
condition|)
block|{
if|if
condition|(
name|p1
index|[
literal|6
index|]
operator|!=
name|p2
index|[
literal|6
index|]
condition|)
return|return
name|p1
index|[
literal|6
index|]
operator|-
name|p2
index|[
literal|6
index|]
return|;
return|return
name|p1
index|[
literal|7
index|]
operator|-
name|p2
index|[
literal|7
index|]
return|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|bsf_nonzero
specifier|static
specifier|inline
name|int
name|bsf_nonzero
parameter_list|(
specifier|register
name|int
name|val
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_CC_GNU
comment|// returns the first non-zero bit on a non-zero reg
asm|asm ("bsf   %1, %0" : "=r" (result) : "r" (val));
return|return
name|result
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
name|_BitScanForward
argument_list|(
operator|&
name|result
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|result
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|ucstrncmp_sse2
specifier|static
name|int
name|ucstrncmp_sse2
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|b
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|__m128i
name|m1
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|a
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|m2
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|b
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|)
decl_stmt|;
name|ushort
name|mask
init|=
name|~
name|uint
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|// which ushort isn't equal?
name|counter
operator|+=
name|bsf_nonzero
argument_list|(
name|mask
argument_list|)
operator|/
literal|2
expr_stmt|;
return|return
name|a
index|[
name|counter
index|]
operator|-
name|b
index|[
name|counter
index|]
return|;
block|}
name|counter
operator|+=
literal|8
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
return|return
name|ucstrncmp_short_tail
argument_list|(
name|a
operator|+
name|counter
argument_list|,
name|b
operator|+
name|counter
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ucstrncmp_sse2_aligning
specifier|static
name|int
name|ucstrncmp_sse2_aligning
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|b
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|__m128i
name|m1
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|a
argument_list|)
decl_stmt|;
name|__m128i
name|m2
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|b
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|)
decl_stmt|;
name|ushort
name|mask
init|=
name|~
name|uint
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|// which ushort isn't equal?
name|int
name|counter
init|=
name|bsf_nonzero
argument_list|(
name|mask
argument_list|)
operator|/
literal|2
decl_stmt|;
return|return
name|a
index|[
name|counter
index|]
operator|-
name|b
index|[
name|counter
index|]
return|;
block|}
comment|// now align to do 16-byte loads
name|int
name|diff
init|=
literal|8
operator|-
operator|(
name|quintptr
argument_list|(
name|a
argument_list|)
operator|&
literal|0xf
operator|)
operator|/
literal|2
decl_stmt|;
name|len
operator|-=
name|diff
expr_stmt|;
name|a
operator|+=
name|diff
expr_stmt|;
name|b
operator|+=
name|diff
expr_stmt|;
block|}
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|__m128i
name|m1
init|=
name|_mm_load_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|a
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|m2
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|b
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|)
decl_stmt|;
name|ushort
name|mask
init|=
name|~
name|uint
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|// which ushort isn't equal?
name|counter
operator|+=
name|bsf_nonzero
argument_list|(
name|mask
argument_list|)
operator|/
literal|2
expr_stmt|;
return|return
name|a
index|[
name|counter
index|]
operator|-
name|b
index|[
name|counter
index|]
return|;
block|}
name|counter
operator|+=
literal|8
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
return|return
name|ucstrncmp_short_tail
argument_list|(
name|a
operator|+
name|counter
argument_list|,
name|b
operator|+
name|counter
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ucstrncmp_sse2_aligned
specifier|static
specifier|inline
name|int
name|ucstrncmp_sse2_aligned
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|b
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|quintptr
name|counter
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|__m128i
name|m1
init|=
name|_mm_load_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|a
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|m2
init|=
name|_mm_load_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|b
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|)
decl_stmt|;
name|ushort
name|mask
init|=
name|~
name|uint
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|// which ushort isn't equal?
name|counter
operator|+=
name|bsf_nonzero
argument_list|(
name|mask
argument_list|)
operator|/
literal|2
expr_stmt|;
return|return
name|a
index|[
name|counter
index|]
operator|-
name|b
index|[
name|counter
index|]
return|;
block|}
name|counter
operator|+=
literal|8
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
return|return
name|ucstrncmp_short_tail
argument_list|(
name|a
operator|+
name|counter
argument_list|,
name|b
operator|+
name|counter
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__SSSE3__
end_ifdef
begin_function
DECL|function|ucstrncmp_ssse3_alignr_aligned
specifier|static
specifier|inline
name|int
name|ucstrncmp_ssse3_alignr_aligned
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|b
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|quintptr
name|counter
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|__m128i
name|m1
init|=
name|_mm_load_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|a
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|m2
init|=
name|_mm_lddqu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|b
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|)
decl_stmt|;
name|ushort
name|mask
init|=
name|~
name|uint
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|// which ushort isn't equal?
name|counter
operator|+=
name|bsf_nonzero
argument_list|(
name|mask
argument_list|)
operator|/
literal|2
expr_stmt|;
return|return
name|a
index|[
name|counter
index|]
operator|-
name|b
index|[
name|counter
index|]
return|;
block|}
name|counter
operator|+=
literal|8
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
return|return
name|ucstrncmp_short_tail
argument_list|(
name|a
operator|+
name|counter
argument_list|,
name|b
operator|+
name|counter
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_typedef
DECL|typedef|MMLoadFunction
typedef|typedef
name|__m128i
function_decl|(
modifier|*
name|MMLoadFunction
function_decl|)
parameter_list|(
specifier|const
name|__m128i
modifier|*
parameter_list|)
function_decl|;
end_typedef
begin_function
template|template
parameter_list|<
name|int
name|N
parameter_list|,
name|MMLoadFunction
name|LoadFunction
parameter_list|>
DECL|function|ucstrncmp_ssse3_alignr
specifier|static
specifier|inline
name|int
name|ucstrncmp_ssse3_alignr
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|b
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
name|__m128i
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|upper
operator|=
name|_mm_load_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
do|do
block|{
name|lower
operator|=
name|upper
expr_stmt|;
name|upper
operator|=
name|_mm_load_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|a
operator|+
name|counter
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|__m128i
name|merged
init|=
name|_mm_alignr_epi8
argument_list|(
name|upper
argument_list|,
name|lower
argument_list|,
name|N
argument_list|)
decl_stmt|;
name|__m128i
name|m2
init|=
name|LoadFunction
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|b
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|merged
argument_list|,
name|m2
argument_list|)
decl_stmt|;
name|ushort
name|mask
init|=
name|~
name|uint
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|// which ushort isn't equal?
name|counter
operator|+=
name|bsf_nonzero
argument_list|(
name|mask
argument_list|)
operator|/
literal|2
expr_stmt|;
return|return
name|a
index|[
name|counter
operator|+
name|N
operator|/
literal|2
index|]
operator|-
name|b
index|[
name|counter
index|]
return|;
block|}
name|counter
operator|+=
literal|8
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|>=
literal|8
condition|)
do|;
return|return
name|ucstrncmp_short_tail
argument_list|(
name|a
operator|+
name|counter
operator|+
name|N
operator|/
literal|2
argument_list|,
name|b
operator|+
name|counter
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// external linkage to be used as the MMLoadFunction template argument for ucstrncmp_ssse3_alignr
end_comment
begin_function
DECL|function|EXT_mm_lddqu_si128
name|__m128i
name|EXT_mm_lddqu_si128
parameter_list|(
specifier|const
name|__m128i
modifier|*
name|p
parameter_list|)
block|{
return|return
name|_mm_lddqu_si128
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|EXT_mm_load_si128
name|__m128i
name|EXT_mm_load_si128
parameter_list|(
name|__m128i
specifier|const
modifier|*
name|p
parameter_list|)
block|{
return|return
name|_mm_load_si128
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ucstrncmp_ssse3
specifier|static
name|int
name|ucstrncmp_ssse3
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|b
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|int
name|val
init|=
name|quintptr
argument_list|(
name|a
argument_list|)
operator|&
literal|0xf
decl_stmt|;
name|a
operator|-=
name|val
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|10
condition|)
return|return
name|ucstrncmp_ssse3_alignr
argument_list|<
literal|10
argument_list|,
name|EXT_mm_lddqu_si128
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|2
condition|)
return|return
name|ucstrncmp_ssse3_alignr
argument_list|<
literal|2
argument_list|,
name|EXT_mm_lddqu_si128
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
if|if
condition|(
name|val
operator|<
literal|8
condition|)
block|{
if|if
condition|(
name|val
operator|<
literal|4
condition|)
return|return
name|ucstrncmp_ssse3_alignr_aligned
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|4
condition|)
return|return
name|ucstrncmp_ssse3_alignr
argument_list|<
literal|4
argument_list|,
name|EXT_mm_lddqu_si128
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|ucstrncmp_ssse3_alignr
argument_list|<
literal|6
argument_list|,
name|EXT_mm_lddqu_si128
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|val
operator|<
literal|12
condition|)
return|return
name|ucstrncmp_ssse3_alignr
argument_list|<
literal|8
argument_list|,
name|EXT_mm_lddqu_si128
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|12
condition|)
return|return
name|ucstrncmp_ssse3_alignr
argument_list|<
literal|12
argument_list|,
name|EXT_mm_lddqu_si128
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|ucstrncmp_ssse3_alignr
argument_list|<
literal|14
argument_list|,
name|EXT_mm_lddqu_si128
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
return|return
name|ucstrncmp_short_tail
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ucstrncmp_ssse3_aligning
specifier|static
name|int
name|ucstrncmp_ssse3_aligning
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|b
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|__m128i
name|m1
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|a
argument_list|)
decl_stmt|;
name|__m128i
name|m2
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|b
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|)
decl_stmt|;
name|ushort
name|mask
init|=
name|~
name|uint
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|// which ushort isn't equal?
name|int
name|counter
init|=
name|bsf_nonzero
argument_list|(
name|mask
argument_list|)
operator|/
literal|2
decl_stmt|;
return|return
name|a
index|[
name|counter
index|]
operator|-
name|b
index|[
name|counter
index|]
return|;
block|}
comment|// now 'b' align to do 16-byte loads
name|int
name|diff
init|=
literal|8
operator|-
operator|(
name|quintptr
argument_list|(
name|b
argument_list|)
operator|&
literal|0xf
operator|)
operator|/
literal|2
decl_stmt|;
name|len
operator|-=
name|diff
expr_stmt|;
name|a
operator|+=
name|diff
expr_stmt|;
name|b
operator|+=
name|diff
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
literal|8
condition|)
return|return
name|ucstrncmp_short_tail
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
comment|// 'b' is aligned
name|int
name|val
init|=
name|quintptr
argument_list|(
name|a
argument_list|)
operator|&
literal|0xf
decl_stmt|;
name|a
operator|-=
name|val
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|8
condition|)
return|return
name|ucstrncmp_ssse3_alignr
argument_list|<
literal|8
argument_list|,
name|EXT_mm_load_si128
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
name|ucstrncmp_sse2_aligned
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
if|if
condition|(
name|val
operator|<
literal|8
condition|)
block|{
if|if
condition|(
name|val
operator|<
literal|4
condition|)
return|return
name|ucstrncmp_ssse3_alignr
argument_list|<
literal|2
argument_list|,
name|EXT_mm_load_si128
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|4
condition|)
return|return
name|ucstrncmp_ssse3_alignr
argument_list|<
literal|4
argument_list|,
name|EXT_mm_load_si128
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|ucstrncmp_ssse3_alignr
argument_list|<
literal|6
argument_list|,
name|EXT_mm_load_si128
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|val
operator|<
literal|12
condition|)
return|return
name|ucstrncmp_ssse3_alignr
argument_list|<
literal|10
argument_list|,
name|EXT_mm_load_si128
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|12
condition|)
return|return
name|ucstrncmp_ssse3_alignr
argument_list|<
literal|12
argument_list|,
name|EXT_mm_load_si128
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|ucstrncmp_ssse3_alignr
argument_list|<
literal|14
argument_list|,
name|EXT_mm_load_si128
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
end_function
begin_function
specifier|static
specifier|inline
DECL|function|ucstrncmp_ssse3_aligning2_aligned
name|int
name|ucstrncmp_ssse3_aligning2_aligned
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|b
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|garbage
parameter_list|)
block|{
comment|// len>= 8
name|__m128i
name|m1
init|=
name|_mm_load_si128
argument_list|(
operator|(
specifier|const
name|__m128i
operator|*
operator|)
name|a
argument_list|)
decl_stmt|;
name|__m128i
name|m2
init|=
name|_mm_load_si128
argument_list|(
operator|(
specifier|const
name|__m128i
operator|*
operator|)
name|b
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|)
decl_stmt|;
name|int
name|mask
init|=
name|short
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
decl_stmt|;
comment|// force sign extension
name|mask
operator|>>=
name|garbage
expr_stmt|;
if|if
condition|(
operator|~
name|mask
condition|)
block|{
comment|// which ushort isn't equal?
name|uint
name|counter
init|=
operator|(
name|garbage
operator|+
name|bsf_nonzero
argument_list|(
operator|~
name|mask
argument_list|)
operator|)
decl_stmt|;
return|return
name|a
index|[
name|counter
operator|/
literal|2
index|]
operator|-
name|b
index|[
name|counter
operator|/
literal|2
index|]
return|;
block|}
comment|// the first 16-garbage bytes (8-garbage/2 ushorts) were equal
name|len
operator|-=
literal|8
operator|-
name|garbage
operator|/
literal|2
expr_stmt|;
return|return
name|ucstrncmp_sse2_aligned
argument_list|(
name|a
operator|+
literal|8
argument_list|,
name|b
operator|+
literal|8
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|int
name|N
parameter_list|>
specifier|static
specifier|inline
DECL|function|ucstrncmp_ssse3_aligning2_alignr
name|int
name|ucstrncmp_ssse3_aligning2_alignr
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|b
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|garbage
parameter_list|)
block|{
comment|// len>= 8
name|__m128i
name|lower
decl_stmt|,
name|upper
decl_stmt|,
name|merged
decl_stmt|;
name|lower
operator|=
name|_mm_load_si128
argument_list|(
operator|(
specifier|const
name|__m128i
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
name|upper
operator|=
name|_mm_load_si128
argument_list|(
operator|(
specifier|const
name|__m128i
operator|*
operator|)
operator|(
name|a
operator|+
literal|8
operator|)
argument_list|)
expr_stmt|;
name|merged
operator|=
name|_mm_alignr_epi8
argument_list|(
name|upper
argument_list|,
name|lower
argument_list|,
name|N
argument_list|)
expr_stmt|;
name|__m128i
name|m2
init|=
name|_mm_load_si128
argument_list|(
operator|(
specifier|const
name|__m128i
operator|*
operator|)
name|b
argument_list|)
decl_stmt|;
name|__m128i
name|cmp
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|merged
argument_list|,
name|m2
argument_list|)
decl_stmt|;
name|int
name|mask
init|=
name|short
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
decl_stmt|;
comment|// force sign extension
name|mask
operator|>>=
name|garbage
expr_stmt|;
if|if
condition|(
operator|~
name|mask
condition|)
block|{
comment|// which ushort isn't equal?
name|uint
name|counter
init|=
operator|(
name|garbage
operator|+
name|bsf_nonzero
argument_list|(
operator|~
name|mask
argument_list|)
operator|)
decl_stmt|;
return|return
name|a
index|[
name|counter
operator|/
literal|2
operator|+
name|N
operator|/
literal|2
index|]
operator|-
name|b
index|[
name|counter
operator|/
literal|2
index|]
return|;
block|}
comment|// the first 16-garbage bytes (8-garbage/2 ushorts) were equal
name|quintptr
name|counter
init|=
literal|8
decl_stmt|;
name|len
operator|-=
literal|8
operator|-
name|garbage
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|lower
operator|=
name|upper
expr_stmt|;
name|upper
operator|=
name|_mm_load_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|a
operator|+
name|counter
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|merged
operator|=
name|_mm_alignr_epi8
argument_list|(
name|upper
argument_list|,
name|lower
argument_list|,
name|N
argument_list|)
expr_stmt|;
name|m2
operator|=
name|_mm_load_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|b
operator|+
name|counter
operator|)
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|_mm_cmpeq_epi16
argument_list|(
name|merged
argument_list|,
name|m2
argument_list|)
expr_stmt|;
name|ushort
name|mask
init|=
name|~
name|uint
argument_list|(
name|_mm_movemask_epi8
argument_list|(
name|cmp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
comment|// which ushort isn't equal?
name|counter
operator|+=
name|bsf_nonzero
argument_list|(
name|mask
argument_list|)
operator|/
literal|2
expr_stmt|;
return|return
name|a
index|[
name|counter
operator|+
name|N
operator|/
literal|2
index|]
operator|-
name|b
index|[
name|counter
index|]
return|;
block|}
name|counter
operator|+=
literal|8
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
return|return
name|ucstrncmp_short_tail
argument_list|(
name|a
operator|+
name|counter
operator|+
name|N
operator|/
literal|2
argument_list|,
name|b
operator|+
name|counter
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|conditional_invert
specifier|static
specifier|inline
name|int
name|conditional_invert
parameter_list|(
name|int
name|result
parameter_list|,
name|bool
name|invert
parameter_list|)
block|{
if|if
condition|(
name|invert
condition|)
return|return
operator|-
name|result
return|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|ucstrncmp_ssse3_aligning2
specifier|static
name|int
name|ucstrncmp_ssse3_aligning2
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|b
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// Different strategy from above: instead of doing two unaligned loads
comment|// when trying to align, we'll only do aligned loads and round down the
comment|// addresses of a and b. This means the first load will contain garbage
comment|// in the beginning of the string, which we'll shift out of the way
comment|// (after _mm_movemask_epi8)
if|if
condition|(
name|len
operator|<
literal|8
condition|)
return|return
name|ucstrncmp_intwise
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
return|;
comment|// both a and b are misaligned
comment|// we'll call the alignr function with the alignment *difference* between the two
name|int
name|offset
init|=
operator|(
name|quintptr
argument_list|(
name|a
argument_list|)
operator|&
literal|0xf
operator|)
operator|-
operator|(
name|quintptr
argument_list|(
name|b
argument_list|)
operator|&
literal|0xf
operator|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>=
literal|0
condition|)
block|{
comment|// from this point on, b has the shortest alignment
comment|// and align(a) = align(b) + offset
comment|// round down the alignment so align(b) == align(a) == 0
name|int
name|garbage
init|=
operator|(
name|quintptr
argument_list|(
name|b
argument_list|)
operator|&
literal|0xf
operator|)
decl_stmt|;
name|a
operator|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
operator|(
name|quintptr
argument_list|(
name|a
argument_list|)
operator|&
operator|~
literal|0xf
operator|)
expr_stmt|;
name|b
operator|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
operator|(
name|quintptr
argument_list|(
name|b
argument_list|)
operator|&
operator|~
literal|0xf
operator|)
expr_stmt|;
comment|// now the first load of b will load 'garbage' extra bytes
comment|// and the first load of a will load 'garbage + offset' extra bytes
if|if
condition|(
name|offset
operator|==
literal|8
condition|)
return|return
name|ucstrncmp_ssse3_aligning2_alignr
argument_list|<
literal|8
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
name|ucstrncmp_ssse3_aligning2_aligned
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
if|if
condition|(
name|offset
operator|<
literal|8
condition|)
block|{
if|if
condition|(
name|offset
operator|<
literal|4
condition|)
return|return
name|ucstrncmp_ssse3_aligning2_alignr
argument_list|<
literal|2
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
elseif|else
if|if
condition|(
name|offset
operator|==
literal|4
condition|)
return|return
name|ucstrncmp_ssse3_aligning2_alignr
argument_list|<
literal|4
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
else|else
return|return
name|ucstrncmp_ssse3_aligning2_alignr
argument_list|<
literal|6
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|<
literal|12
condition|)
return|return
name|ucstrncmp_ssse3_aligning2_alignr
argument_list|<
literal|10
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
elseif|else
if|if
condition|(
name|offset
operator|==
literal|12
condition|)
return|return
name|ucstrncmp_ssse3_aligning2_alignr
argument_list|<
literal|12
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
else|else
return|return
name|ucstrncmp_ssse3_aligning2_alignr
argument_list|<
literal|14
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// same as above but inverted
name|int
name|garbage
init|=
operator|(
name|quintptr
argument_list|(
name|a
argument_list|)
operator|&
literal|0xf
operator|)
decl_stmt|;
name|a
operator|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
operator|(
name|quintptr
argument_list|(
name|a
argument_list|)
operator|&
operator|~
literal|0xf
operator|)
expr_stmt|;
name|b
operator|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
operator|(
name|quintptr
argument_list|(
name|b
argument_list|)
operator|&
operator|~
literal|0xf
operator|)
expr_stmt|;
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|8
condition|)
return|return
operator|-
name|ucstrncmp_ssse3_aligning2_alignr
argument_list|<
literal|8
argument_list|>
argument_list|(
name|b
argument_list|,
name|a
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
if|if
condition|(
name|offset
operator|<
literal|8
condition|)
block|{
if|if
condition|(
name|offset
operator|<
literal|4
condition|)
return|return
operator|-
name|ucstrncmp_ssse3_aligning2_alignr
argument_list|<
literal|2
argument_list|>
argument_list|(
name|b
argument_list|,
name|a
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
elseif|else
if|if
condition|(
name|offset
operator|==
literal|4
condition|)
return|return
operator|-
name|ucstrncmp_ssse3_aligning2_alignr
argument_list|<
literal|4
argument_list|>
argument_list|(
name|b
argument_list|,
name|a
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
else|else
return|return
operator|-
name|ucstrncmp_ssse3_aligning2_alignr
argument_list|<
literal|6
argument_list|>
argument_list|(
name|b
argument_list|,
name|a
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|<
literal|12
condition|)
return|return
operator|-
name|ucstrncmp_ssse3_aligning2_alignr
argument_list|<
literal|10
argument_list|>
argument_list|(
name|b
argument_list|,
name|a
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
elseif|else
if|if
condition|(
name|offset
operator|==
literal|12
condition|)
return|return
operator|-
name|ucstrncmp_ssse3_aligning2_alignr
argument_list|<
literal|12
argument_list|>
argument_list|(
name|b
argument_list|,
name|a
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
else|else
return|return
operator|-
name|ucstrncmp_ssse3_aligning2_alignr
argument_list|<
literal|14
argument_list|>
argument_list|(
name|b
argument_list|,
name|a
argument_list|,
name|len
argument_list|,
name|garbage
argument_list|)
return|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|UcstrncmpFunction
typedef|typedef
name|int
function_decl|(
modifier|*
name|UcstrncmpFunction
function_decl|)
parameter_list|(
specifier|const
name|ushort
modifier|*
parameter_list|,
specifier|const
name|ushort
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef
begin_macro
name|Q_DECLARE_METATYPE
argument_list|(
argument|UcstrncmpFunction
argument_list|)
end_macro
begin_function
DECL|function|ucstrncmp_data
name|void
name|tst_QString
operator|::
name|ucstrncmp_data
parameter_list|()
specifier|const
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|UcstrncmpFunction
argument_list|>
argument_list|(
literal|"function"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"selftest"
argument_list|)
operator|<<
name|UcstrncmpFunction
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"shortwise"
argument_list|)
operator|<<
operator|&
name|ucstrncmp_shortwise
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"intwise"
argument_list|)
operator|<<
operator|&
name|ucstrncmp_intwise
expr_stmt|;
ifdef|#
directive|ifdef
name|__SSE2__
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse2"
argument_list|)
operator|<<
operator|&
name|ucstrncmp_sse2
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse2_aligning"
argument_list|)
operator|<<
operator|&
name|ucstrncmp_sse2_aligning
expr_stmt|;
ifdef|#
directive|ifdef
name|__SSSE3__
name|QTest
operator|::
name|newRow
argument_list|(
literal|"ssse3"
argument_list|)
operator|<<
operator|&
name|ucstrncmp_ssse3
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"ssse3_aligning"
argument_list|)
operator|<<
operator|&
name|ucstrncmp_ssse3_aligning
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"ssse3_aligning2"
argument_list|)
operator|<<
operator|&
name|ucstrncmp_ssse3_aligning2
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|ucstrncmp
name|void
name|tst_QString
operator|::
name|ucstrncmp
parameter_list|()
specifier|const
block|{
name|QFETCH
argument_list|(
name|UcstrncmpFunction
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|function
condition|)
block|{
specifier|static
specifier|const
name|UcstrncmpFunction
name|func
index|[]
init|=
block|{
operator|&
name|ucstrncmp_shortwise
block|,
operator|&
name|ucstrncmp_intwise
block|,
ifdef|#
directive|ifdef
name|__SSE2__
operator|&
name|ucstrncmp_sse2
block|,
operator|&
name|ucstrncmp_sse2_aligning
block|,
ifdef|#
directive|ifdef
name|__SSSE3__
operator|&
name|ucstrncmp_ssse3
block|,
operator|&
name|ucstrncmp_ssse3_aligning
block|,
operator|&
name|ucstrncmp_ssse3_aligning2
endif|#
directive|endif
endif|#
directive|endif
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|functionCount
init|=
sizeof|sizeof
name|func
operator|/
sizeof|sizeof
name|func
index|[
literal|0
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_UNIX
specifier|const
name|long
name|pagesize
init|=
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
decl_stmt|;
name|void
modifier|*
name|page1
decl_stmt|,
modifier|*
name|page3
decl_stmt|;
name|ushort
modifier|*
name|page2
decl_stmt|;
name|page1
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|pagesize
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANONYMOUS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|page2
operator|=
operator|(
name|ushort
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|pagesize
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANONYMOUS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|page3
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|pagesize
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANONYMOUS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|quintptr
argument_list|(
name|page2
argument_list|)
operator|==
name|quintptr
argument_list|(
name|page1
argument_list|)
operator|+
name|pagesize
operator|||
name|quintptr
argument_list|(
name|page2
argument_list|)
operator|==
name|quintptr
argument_list|(
name|page1
argument_list|)
operator|-
name|pagesize
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|quintptr
argument_list|(
name|page3
argument_list|)
operator|==
name|quintptr
argument_list|(
name|page2
argument_list|)
operator|+
name|pagesize
operator|||
name|quintptr
argument_list|(
name|page3
argument_list|)
operator|==
name|quintptr
argument_list|(
name|page2
argument_list|)
operator|-
name|pagesize
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|page1
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|page3
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
comment|// populate our page
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pagesize
operator|/
expr|sizeof
operator|(
name|long
name|long
operator|)
condition|;
operator|++
name|i
control|)
operator|(
operator|(
name|long
name|long
operator|*
operator|)
name|page2
operator|)
index|[
name|i
index|]
operator|=
name|Q_INT64_C
argument_list|(
literal|0x0041004100410041
argument_list|)
expr_stmt|;
comment|// the following should crash:
comment|//page2[-1] = 0xdead;
comment|//page2[pagesize / sizeof(ushort) + 1] = 0xbeef;
specifier|static
specifier|const
name|ushort
name|needle
index|[]
init|=
block|{
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|}
decl_stmt|;
for|for
control|(
name|int
name|algo
init|=
literal|0
init|;
name|algo
operator|<
name|functionCount
condition|;
operator|++
name|algo
control|)
block|{
comment|// boundary condition test:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
operator|(
name|func
index|[
name|algo
index|]
operator|)
operator|(
name|page2
operator|+
name|i
operator|,
name|needle
operator|,
sizeof|sizeof
name|needle
operator|/
literal|2
operator|)
expr_stmt|;
operator|(
name|func
index|[
name|algo
index|]
operator|)
operator|(
name|page2
operator|-
name|i
operator|-
literal|1
operator|-
sizeof|sizeof
argument_list|(
name|needle
argument_list|)
operator|/
literal|2
operator|+
name|pagesize
operator|/
literal|2
operator|,
name|needle
operator|,
sizeof|sizeof
name|needle
operator|/
literal|2
operator|)
expr_stmt|;
block|}
block|}
name|munmap
argument_list|(
name|page2
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|algo
init|=
literal|0
init|;
name|algo
operator|<
name|functionCount
condition|;
operator|++
name|algo
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stringCollectionCount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|ushort
modifier|*
name|p1
init|=
name|stringCollectionData
operator|+
name|stringCollection
index|[
name|i
index|]
operator|.
name|offset1
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|p2
init|=
name|stringCollectionData
operator|+
name|stringCollection
index|[
name|i
index|]
operator|.
name|offset2
decl_stmt|;
name|int
name|expected
init|=
name|ucstrncmp_shortwise
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|stringCollection
index|[
name|i
index|]
operator|.
name|len
argument_list|)
decl_stmt|;
name|expected
operator|=
name|qBound
argument_list|(
operator|-
literal|1
argument_list|,
name|expected
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|int
name|result
init|=
operator|(
name|func
index|[
name|algo
index|]
operator|)
operator|(
name|p1
expr|,
name|p2
expr|,
name|stringCollection
index|[
name|i
index|]
operator|.
name|len
operator|)
decl_stmt|;
name|result
operator|=
name|qBound
argument_list|(
operator|-
literal|1
argument_list|,
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|expected
operator|!=
name|result
condition|)
name|qWarning
argument_list|()
operator|.
name|nospace
argument_list|()
operator|<<
literal|"algo="
operator|<<
name|algo
operator|<<
literal|" i="
operator|<<
name|i
operator|<<
literal|" failed ("
operator|<<
name|result
operator|<<
literal|"!="
operator|<<
name|expected
operator|<<
literal|"); strings were "
operator|<<
name|QByteArray
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p1
argument_list|,
name|stringCollection
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|.
name|toHex
argument_list|()
operator|<<
literal|" and "
operator|<<
name|QByteArray
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p2
argument_list|,
name|stringCollection
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|.
name|toHex
argument_list|()
expr_stmt|;
block|}
block|}
return|return;
block|}
name|QBENCHMARK
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stringCollectionCount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|ushort
modifier|*
name|p1
init|=
name|stringCollectionData
operator|+
name|stringCollection
index|[
name|i
index|]
operator|.
name|offset1
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|p2
init|=
name|stringCollectionData
operator|+
name|stringCollection
index|[
name|i
index|]
operator|.
name|offset2
decl_stmt|;
call|(
name|function
call|)
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|stringCollection
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|fromUtf8
name|void
name|tst_QString
operator|::
name|fromUtf8
parameter_list|()
specifier|const
block|{
name|QString
name|testFile
init|=
name|QFINDTESTDATA
argument_list|(
literal|"utf-8.txt"
argument_list|)
decl_stmt|;
name|QVERIFY2
argument_list|(
operator|!
name|testFile
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"cannot find test file utf-8.txt!"
argument_list|)
expr_stmt|;
name|QFile
name|file
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|qFatal
argument_list|(
literal|"Cannot open input file"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QByteArray
name|data
init|=
name|file
operator|.
name|readAll
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
init|=
name|data
operator|.
name|constData
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|data
operator|.
name|size
argument_list|()
decl_stmt|;
name|QBENCHMARK
block|{
name|QString
operator|::
name|fromUtf8
argument_list|(
name|d
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|fromLatin1_data
name|void
name|tst_QString
operator|::
name|fromLatin1_data
parameter_list|()
specifier|const
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|QByteArray
argument_list|>
argument_list|(
literal|"latin1"
argument_list|)
expr_stmt|;
comment|// make all the strings have the same length
name|QTest
operator|::
name|newRow
argument_list|(
literal|"ascii-only"
argument_list|)
operator|<<
name|QByteArray
argument_list|(
literal|"HelloWorld"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"ascii+control"
argument_list|)
operator|<<
name|QByteArray
argument_list|(
literal|"Hello\1\r\n\x7f\t"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"ascii+nul"
argument_list|)
operator|<<
name|QByteArray
argument_list|(
literal|"a\0zbc\0defg"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"non-ascii"
argument_list|)
operator|<<
name|QByteArray
argument_list|(
literal|"\x80\xc0\xff\x81\xc1\xfe\x90\xd0\xef\xa0"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fromLatin1
name|void
name|tst_QString
operator|::
name|fromLatin1
parameter_list|()
specifier|const
block|{
name|QFETCH
argument_list|(
name|QByteArray
argument_list|,
name|latin1
argument_list|)
expr_stmt|;
while|while
condition|(
name|latin1
operator|.
name|length
argument_list|()
operator|<
literal|128
condition|)
block|{
name|latin1
operator|+=
name|latin1
expr_stmt|;
block|}
name|QByteArray
name|copy1
init|=
name|latin1
decl_stmt|,
name|copy2
init|=
name|latin1
decl_stmt|,
name|copy3
init|=
name|latin1
decl_stmt|;
name|copy1
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|copy2
operator|.
name|detach
argument_list|()
expr_stmt|;
name|copy3
operator|+=
name|latin1
expr_stmt|;
comment|// longer length
name|copy2
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QBENCHMARK
block|{
name|QString
name|s1
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|latin1
argument_list|)
decl_stmt|;
name|QString
name|s2
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|latin1
argument_list|)
decl_stmt|;
name|QString
name|s3
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|copy1
argument_list|)
decl_stmt|;
name|QString
name|s4
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|copy3
argument_list|)
decl_stmt|;
name|s3
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|copy3
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_typedef
DECL|typedef|FromLatin1Function
typedef|typedef
name|void
function_decl|(
modifier|*
name|FromLatin1Function
function_decl|)
parameter_list|(
name|ushort
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef
begin_macro
name|Q_DECLARE_METATYPE
argument_list|(
argument|FromLatin1Function
argument_list|)
end_macro
begin_function
DECL|function|fromLatin1_regular
name|void
name|fromLatin1_regular
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
comment|// from qstring.cpp:
while|while
condition|(
name|size
operator|--
condition|)
operator|*
name|dst
operator|++
operator|=
operator|(
name|uchar
operator|)
operator|*
name|str
operator|++
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__SSE2__
end_ifdef
begin_function
DECL|function|fromLatin1_sse2_qt47
name|void
name|fromLatin1_sse2_qt47
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|>=
literal|16
condition|)
block|{
name|int
name|chunkCount
init|=
name|size
operator|>>
literal|4
decl_stmt|;
comment|// divided by 16
specifier|const
name|__m128i
name|nullMask
init|=
name|_mm_set1_epi32
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|chunkCount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|__m128i
name|chunk
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|str
argument_list|)
decl_stmt|;
comment|// load
name|str
operator|+=
literal|16
expr_stmt|;
comment|// unpack the first 8 bytes, padding with zeros
specifier|const
name|__m128i
name|firstHalf
init|=
name|_mm_unpacklo_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|dst
argument_list|,
name|firstHalf
argument_list|)
expr_stmt|;
comment|// store
name|dst
operator|+=
literal|8
expr_stmt|;
comment|// unpack the last 8 bytes, padding with zeros
specifier|const
name|__m128i
name|secondHalf
init|=
name|_mm_unpackhi_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|dst
argument_list|,
name|secondHalf
argument_list|)
expr_stmt|;
comment|// store
name|dst
operator|+=
literal|8
expr_stmt|;
block|}
name|size
operator|=
name|size
operator|%
literal|16
expr_stmt|;
block|}
while|while
condition|(
name|size
operator|--
condition|)
operator|*
name|dst
operator|++
operator|=
operator|(
name|uchar
operator|)
operator|*
name|str
operator|++
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fromLatin1_epilog
specifier|static
specifier|inline
name|void
name|fromLatin1_epilog
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
operator|!
name|size
condition|)
return|return;
name|dst
index|[
literal|0
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|1
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|2
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|3
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|4
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|5
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|6
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|7
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|7
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|8
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|8
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|9
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|9
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|10
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|10
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|11
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|11
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|12
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|12
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|13
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|13
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|14
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|14
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|15
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|15
index|]
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fromLatin1_sse2_improved
name|void
name|fromLatin1_sse2_improved
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|const
name|__m128i
name|nullMask
init|=
name|_mm_set1_epi32
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
name|size
operator|-=
literal|16
expr_stmt|;
while|while
condition|(
name|size
operator|>=
name|counter
condition|)
block|{
specifier|const
name|__m128i
name|chunk
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|str
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
comment|// load
comment|// unpack the first 8 bytes, padding with zeros
specifier|const
name|__m128i
name|firstHalf
init|=
name|_mm_unpacklo_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|)
argument_list|,
name|firstHalf
argument_list|)
expr_stmt|;
comment|// store
comment|// unpack the last 8 bytes, padding with zeros
specifier|const
name|__m128i
name|secondHalf
init|=
name|_mm_unpackhi_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|+
literal|8
operator|)
argument_list|,
name|secondHalf
argument_list|)
expr_stmt|;
comment|// store
name|counter
operator|+=
literal|16
expr_stmt|;
block|}
name|size
operator|+=
literal|16
expr_stmt|;
name|fromLatin1_epilog
argument_list|(
name|dst
operator|+
name|counter
argument_list|,
name|str
operator|+
name|counter
argument_list|,
name|size
operator|-
name|counter
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fromLatin1_sse2_improved2
name|void
name|fromLatin1_sse2_improved2
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|const
name|__m128i
name|nullMask
init|=
name|_mm_set1_epi32
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
name|size
operator|-=
literal|32
expr_stmt|;
while|while
condition|(
name|size
operator|>=
name|counter
condition|)
block|{
specifier|const
name|__m128i
name|chunk1
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|str
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
comment|// load
specifier|const
name|__m128i
name|chunk2
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|str
operator|+
name|counter
operator|+
literal|16
operator|)
argument_list|)
decl_stmt|;
comment|// load
comment|// unpack the first 8 bytes, padding with zeros
specifier|const
name|__m128i
name|firstHalf1
init|=
name|_mm_unpacklo_epi8
argument_list|(
name|chunk1
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|)
argument_list|,
name|firstHalf1
argument_list|)
expr_stmt|;
comment|// store
comment|// unpack the last 8 bytes, padding with zeros
specifier|const
name|__m128i
name|secondHalf1
init|=
name|_mm_unpackhi_epi8
argument_list|(
name|chunk1
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|+
literal|8
operator|)
argument_list|,
name|secondHalf1
argument_list|)
expr_stmt|;
comment|// store
comment|// unpack the first 8 bytes, padding with zeros
specifier|const
name|__m128i
name|firstHalf2
init|=
name|_mm_unpacklo_epi8
argument_list|(
name|chunk2
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|+
literal|16
operator|)
argument_list|,
name|firstHalf2
argument_list|)
expr_stmt|;
comment|// store
comment|// unpack the last 8 bytes, padding with zeros
specifier|const
name|__m128i
name|secondHalf2
init|=
name|_mm_unpackhi_epi8
argument_list|(
name|chunk2
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|+
literal|24
operator|)
argument_list|,
name|secondHalf2
argument_list|)
expr_stmt|;
comment|// store
name|counter
operator|+=
literal|32
expr_stmt|;
block|}
name|size
operator|+=
literal|16
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|counter
condition|)
block|{
specifier|const
name|__m128i
name|chunk
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|str
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
comment|// load
comment|// unpack the first 8 bytes, padding with zeros
specifier|const
name|__m128i
name|firstHalf
init|=
name|_mm_unpacklo_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|)
argument_list|,
name|firstHalf
argument_list|)
expr_stmt|;
comment|// store
comment|// unpack the last 8 bytes, padding with zeros
specifier|const
name|__m128i
name|secondHalf
init|=
name|_mm_unpackhi_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|+
literal|8
operator|)
argument_list|,
name|secondHalf
argument_list|)
expr_stmt|;
comment|// store
name|counter
operator|+=
literal|16
expr_stmt|;
block|}
name|size
operator|+=
literal|16
expr_stmt|;
name|fromLatin1_epilog
argument_list|(
name|dst
operator|+
name|counter
argument_list|,
name|str
operator|+
name|counter
argument_list|,
name|size
operator|-
name|counter
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fromLatin1_prolog_unrolled
name|void
name|fromLatin1_prolog_unrolled
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
comment|// QString's data pointer is most often ending in 0x2 or 0xa
comment|// that means the two most common values for size are (8-1)=7 and (8-5)=3
if|if
condition|(
name|size
operator|==
literal|7
condition|)
goto|goto
name|copy_7
goto|;
if|if
condition|(
name|size
operator|==
literal|3
condition|)
goto|goto
name|copy_3
goto|;
if|if
condition|(
name|size
operator|==
literal|6
condition|)
goto|goto
name|copy_6
goto|;
if|if
condition|(
name|size
operator|==
literal|5
condition|)
goto|goto
name|copy_5
goto|;
if|if
condition|(
name|size
operator|==
literal|4
condition|)
goto|goto
name|copy_4
goto|;
if|if
condition|(
name|size
operator|==
literal|2
condition|)
goto|goto
name|copy_2
goto|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
goto|goto
name|copy_1
goto|;
return|return;
name|copy_7
label|:
name|dst
index|[
literal|6
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|6
index|]
expr_stmt|;
name|copy_6
label|:
name|dst
index|[
literal|5
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|5
index|]
expr_stmt|;
name|copy_5
label|:
name|dst
index|[
literal|4
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|4
index|]
expr_stmt|;
name|copy_4
label|:
name|dst
index|[
literal|3
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|3
index|]
expr_stmt|;
name|copy_3
label|:
name|dst
index|[
literal|2
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|2
index|]
expr_stmt|;
name|copy_2
label|:
name|dst
index|[
literal|1
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|1
index|]
expr_stmt|;
name|copy_1
label|:
name|dst
index|[
literal|0
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fromLatin1_prolog_sse2_overcommit
name|void
name|fromLatin1_prolog_sse2_overcommit
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
parameter_list|)
block|{
comment|// do one iteration of conversion
specifier|const
name|__m128i
name|chunk
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|str
argument_list|)
decl_stmt|;
comment|// load
comment|// unpack only the first 8 bytes, padding with zeros
specifier|const
name|__m128i
name|nullMask
init|=
name|_mm_set1_epi32
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|__m128i
name|firstHalf
init|=
name|_mm_unpacklo_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|dst
argument_list|,
name|firstHalf
argument_list|)
expr_stmt|;
comment|// store
block|}
end_function
begin_function
template|template
parameter_list|<
name|FromLatin1Function
name|prologFunction
parameter_list|>
DECL|function|fromLatin1_sse2_withprolog
name|void
name|fromLatin1_sse2_withprolog
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
comment|// same as the improved code, but we attempt to align at the prolog
comment|// therefore, we issue aligned stores
if|if
condition|(
name|size
operator|>=
literal|16
condition|)
block|{
name|uint
name|misalignment
init|=
name|uint
argument_list|(
name|quintptr
argument_list|(
name|dst
argument_list|)
operator|&
literal|0xf
argument_list|)
decl_stmt|;
name|uint
name|prologCount
init|=
operator|(
literal|16
operator|-
name|misalignment
operator|)
operator|/
literal|2
decl_stmt|;
name|prologFunction
argument_list|(
name|dst
argument_list|,
name|str
argument_list|,
name|prologCount
argument_list|)
expr_stmt|;
name|size
operator|-=
name|prologCount
expr_stmt|;
name|dst
operator|+=
name|prologCount
expr_stmt|;
name|str
operator|+=
name|prologCount
expr_stmt|;
block|}
specifier|const
name|__m128i
name|nullMask
init|=
name|_mm_set1_epi32
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
name|size
operator|-=
literal|16
expr_stmt|;
while|while
condition|(
name|size
operator|>=
name|counter
condition|)
block|{
specifier|const
name|__m128i
name|chunk
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|str
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
comment|// load
comment|// unpack the first 8 bytes, padding with zeros
specifier|const
name|__m128i
name|firstHalf
init|=
name|_mm_unpacklo_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_store_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|)
argument_list|,
name|firstHalf
argument_list|)
expr_stmt|;
comment|// store
comment|// unpack the last 8 bytes, padding with zeros
specifier|const
name|__m128i
name|secondHalf
init|=
name|_mm_unpackhi_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_store_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|+
literal|8
operator|)
argument_list|,
name|secondHalf
argument_list|)
expr_stmt|;
comment|// store
name|counter
operator|+=
literal|16
expr_stmt|;
block|}
name|size
operator|+=
literal|16
expr_stmt|;
name|fromLatin1_epilog
argument_list|(
name|dst
operator|+
name|counter
argument_list|,
name|str
operator|+
name|counter
argument_list|,
name|size
operator|-
name|counter
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__SSE4_1__
end_ifdef
begin_function
DECL|function|fromLatin1_sse4_pmovzxbw
name|void
name|fromLatin1_sse4_pmovzxbw
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
name|size
operator|-=
literal|16
expr_stmt|;
while|while
condition|(
name|size
operator|>=
name|counter
condition|)
block|{
name|__m128i
name|chunk
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|str
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
comment|// load
comment|// unpack the first 8 bytes, padding with zeros
specifier|const
name|__m128i
name|firstHalf
init|=
name|_mm_cvtepu8_epi16
argument_list|(
name|chunk
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|)
argument_list|,
name|firstHalf
argument_list|)
expr_stmt|;
comment|// store
comment|// unpack the last 8 bytes, padding with zeros
name|chunk
operator|=
name|_mm_srli_si128
argument_list|(
name|chunk
argument_list|,
literal|8
argument_list|)
expr_stmt|;
specifier|const
name|__m128i
name|secondHalf
init|=
name|_mm_cvtepu8_epi16
argument_list|(
name|chunk
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|+
literal|8
operator|)
argument_list|,
name|secondHalf
argument_list|)
expr_stmt|;
comment|// store
name|counter
operator|+=
literal|16
expr_stmt|;
block|}
name|size
operator|+=
literal|16
expr_stmt|;
name|fromLatin1_epilog
argument_list|(
name|dst
operator|+
name|counter
argument_list|,
name|str
operator|+
name|counter
argument_list|,
name|size
operator|-
name|counter
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fromLatin1_prolog_sse4_overcommit
name|void
name|fromLatin1_prolog_sse4_overcommit
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
parameter_list|)
block|{
comment|// load 8 bytes and zero-extend them to 16
specifier|const
name|__m128i
name|chunk
init|=
name|_mm_cvtepu8_epi16
argument_list|(
operator|*
operator|(
name|__m128i
operator|*
operator|)
name|str
argument_list|)
decl_stmt|;
comment|// load
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|dst
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
comment|// store
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|__ARM_NEON__
end_ifdef
begin_function
DECL|function|fromLatin1_epilog
specifier|static
specifier|inline
name|void
name|fromLatin1_epilog
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
operator|!
name|size
condition|)
return|return;
name|dst
index|[
literal|0
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|1
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|2
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|3
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|4
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|5
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|6
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
name|dst
index|[
literal|7
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
literal|7
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|size
condition|)
return|return;
block|}
end_function
begin_function
DECL|function|fromLatin1_neon_improved
name|void
name|fromLatin1_neon_improved
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
comment|// load 8 bytes into one doubleword Neon register
specifier|const
name|uint8x8_t
name|chunk
init|=
name|vld1_u8
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|str
argument_list|)
decl_stmt|;
name|str
operator|+=
literal|8
expr_stmt|;
comment|// expand 8 bytes into 16 bytes in a quadword register
specifier|const
name|uint16x8_t
name|expanded
init|=
name|vmovl_u8
argument_list|(
name|chunk
argument_list|)
decl_stmt|;
name|vst1q_u16
argument_list|(
name|dst
argument_list|,
name|expanded
argument_list|)
expr_stmt|;
comment|// store
name|dst
operator|+=
literal|8
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
name|fromLatin1_epilog
argument_list|(
name|dst
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fromLatin1_neon_improved2
name|void
name|fromLatin1_neon_improved2
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
name|len
operator|>=
literal|16
condition|)
block|{
comment|// load 16 bytes into one quadword Neon register
specifier|const
name|uint8x16_t
name|chunk
init|=
name|vld1q_u8
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|str
argument_list|)
decl_stmt|;
name|str
operator|+=
literal|16
expr_stmt|;
comment|// expand each doubleword of the quadword register into a quadword
specifier|const
name|uint16x8_t
name|expanded_low
init|=
name|vmovl_u8
argument_list|(
name|vget_low_u8
argument_list|(
name|chunk
argument_list|)
argument_list|)
decl_stmt|;
name|vst1q_u16
argument_list|(
name|dst
argument_list|,
name|expanded_low
argument_list|)
expr_stmt|;
comment|// store
name|dst
operator|+=
literal|8
expr_stmt|;
specifier|const
name|uint16x8_t
name|expanded_high
init|=
name|vmovl_u8
argument_list|(
name|vget_high_u8
argument_list|(
name|chunk
argument_list|)
argument_list|)
decl_stmt|;
name|vst1q_u16
argument_list|(
name|dst
argument_list|,
name|expanded_high
argument_list|)
expr_stmt|;
comment|// store
name|dst
operator|+=
literal|8
expr_stmt|;
name|len
operator|-=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
comment|// load 8 bytes into one doubleword Neon register
specifier|const
name|uint8x8_t
name|chunk
init|=
name|vld1_u8
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|str
argument_list|)
decl_stmt|;
name|str
operator|+=
literal|8
expr_stmt|;
comment|// expand 8 bytes into 16 bytes in a quadword register
specifier|const
name|uint16x8_t
name|expanded
init|=
name|vmovl_u8
argument_list|(
name|chunk
argument_list|)
decl_stmt|;
name|vst1q_u16
argument_list|(
name|dst
argument_list|,
name|expanded
argument_list|)
expr_stmt|;
comment|// store
name|dst
operator|+=
literal|8
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
name|fromLatin1_epilog
argument_list|(
name|dst
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fromLatin1_neon_handwritten
name|void
name|fromLatin1_neon_handwritten
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// same as above, but handwritten Neon
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|uint16x8_t
name|chunk
decl_stmt|;
asm|asm (             "vld1.8     %[chunk], [%[str]]!\n"             "vmovl.u8   %q[chunk], %[chunk]\n"             "vst1.16    %h[chunk], [%[dst]]!\n"             : [dst] "+r" (dst),               [str] "+r" (str),               [chunk] "=w" (chunk));
name|len
operator|-=
literal|8
expr_stmt|;
block|}
name|fromLatin1_epilog
argument_list|(
name|dst
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fromLatin1_neon_handwritten2
name|void
name|fromLatin1_neon_handwritten2
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// same as above, but handwritten Neon
while|while
condition|(
name|len
operator|>=
literal|16
condition|)
block|{
name|uint16x8_t
name|chunk1
decl_stmt|,
name|chunk2
decl_stmt|;
asm|asm (             "vld1.8     %h[chunk1], [%[str]]!\n"             "vmovl.u8   %q[chunk2], %f[chunk1]\n"             "vmovl.u8   %q[chunk1], %e[chunk1]\n"             "vst1.16    %h[chunk1], [%[dst]]!\n"             "vst1.16    %h[chunk2], [%[dst]]!\n"           : [dst] "+r" (dst),             [str] "+r" (str),             [chunk1] "=w" (chunk1),             [chunk2] "=w" (chunk2));
name|len
operator|-=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|uint16x8_t
name|chunk
decl_stmt|;
asm|asm (             "vld1.8     %[chunk], [%[str]]!\n"             "vmovl.u8   %q[chunk], %[chunk]\n"             "vst1.16    %h[chunk], [%[dst]]!\n"             : [dst] "+r" (dst),               [str] "+r" (str),               [chunk] "=w" (chunk));
name|len
operator|-=
literal|8
expr_stmt|;
block|}
name|fromLatin1_epilog
argument_list|(
name|dst
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|fromLatin1Alternatives_data
name|void
name|tst_QString
operator|::
name|fromLatin1Alternatives_data
parameter_list|()
specifier|const
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|FromLatin1Function
argument_list|>
argument_list|(
literal|"function"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"empty"
argument_list|)
operator|<<
name|FromLatin1Function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"regular"
argument_list|)
operator|<<
operator|&
name|fromLatin1_regular
expr_stmt|;
ifdef|#
directive|ifdef
name|__SSE2__
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse2-qt4.7"
argument_list|)
operator|<<
operator|&
name|fromLatin1_sse2_qt47
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse2-improved"
argument_list|)
operator|<<
operator|&
name|fromLatin1_sse2_improved
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse2-improved2"
argument_list|)
operator|<<
operator|&
name|fromLatin1_sse2_improved2
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse2-with-prolog-regular"
argument_list|)
operator|<<
operator|&
name|fromLatin1_sse2_withprolog
argument_list|<
operator|&
name|fromLatin1_regular
argument_list|>
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse2-with-prolog-unrolled"
argument_list|)
operator|<<
operator|&
name|fromLatin1_sse2_withprolog
argument_list|<
operator|&
name|fromLatin1_prolog_unrolled
argument_list|>
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse2-with-prolog-sse2-overcommit"
argument_list|)
operator|<<
operator|&
name|fromLatin1_sse2_withprolog
argument_list|<
operator|&
name|fromLatin1_prolog_sse2_overcommit
argument_list|>
expr_stmt|;
ifdef|#
directive|ifdef
name|__SSE4_1__
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse2-with-prolog-sse4-overcommit"
argument_list|)
operator|<<
operator|&
name|fromLatin1_sse2_withprolog
argument_list|<
operator|&
name|fromLatin1_prolog_sse4_overcommit
argument_list|>
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse4-pmovzxbw"
argument_list|)
operator|<<
operator|&
name|fromLatin1_sse4_pmovzxbw
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__ARM_NEON__
name|QTest
operator|::
name|newRow
argument_list|(
literal|"neon-improved"
argument_list|)
operator|<<
operator|&
name|fromLatin1_neon_improved
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"neon-improved2"
argument_list|)
operator|<<
operator|&
name|fromLatin1_neon_improved2
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"neon-handwritten"
argument_list|)
operator|<<
operator|&
name|fromLatin1_neon_handwritten
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"neon-handwritten2"
argument_list|)
operator|<<
operator|&
name|fromLatin1_neon_handwritten2
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_decl_stmt
specifier|extern
name|StringData
name|fromLatin1Data
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|fromLatin1Alternatives_internal
specifier|static
name|void
name|fromLatin1Alternatives_internal
parameter_list|(
name|FromLatin1Function
name|function
parameter_list|,
name|QString
modifier|&
name|dst
parameter_list|,
name|bool
name|doVerify
parameter_list|)
block|{
struct|struct
name|Entry
block|{
name|int
name|len
decl_stmt|;
name|int
name|offset1
decl_stmt|,
name|offset2
decl_stmt|;
name|int
name|align1
decl_stmt|,
name|align2
decl_stmt|;
block|}
struct|;
specifier|const
name|Entry
modifier|*
name|entries
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|Entry
operator|*
argument_list|>
argument_list|(
name|fromLatin1Data
operator|.
name|entries
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fromLatin1Data
operator|.
name|entryCount
condition|;
operator|++
name|i
control|)
block|{
name|int
name|len
init|=
name|entries
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
init|=
name|fromLatin1Data
operator|.
name|charData
operator|+
name|entries
index|[
name|i
index|]
operator|.
name|offset1
decl_stmt|;
if|if
condition|(
operator|!
name|function
condition|)
continue|continue;
if|if
condition|(
operator|!
name|doVerify
condition|)
block|{
call|(
name|function
call|)
argument_list|(
operator|&
name|dst
operator|.
name|data
argument_list|()
operator|->
name|unicode
argument_list|()
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|.
name|fill
argument_list|(
name|QChar
argument_list|(
literal|'x'
argument_list|)
argument_list|,
name|dst
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
call|(
name|function
call|)
argument_list|(
operator|&
name|dst
operator|.
name|data
argument_list|()
operator|->
name|unicode
argument_list|()
operator|+
literal|8
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|QString
name|zeroes
argument_list|(
literal|8
argument_list|,
name|QChar
argument_list|(
literal|'x'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|final
init|=
name|dst
operator|.
name|mid
argument_list|(
literal|8
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|final
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
name|src
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|dst
operator|.
name|left
argument_list|(
literal|8
argument_list|)
argument_list|,
name|zeroes
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|dst
operator|.
name|mid
argument_list|(
name|len
operator|+
literal|8
argument_list|,
literal|8
argument_list|)
argument_list|,
name|zeroes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|fromLatin1Alternatives
name|void
name|tst_QString
operator|::
name|fromLatin1Alternatives
parameter_list|()
specifier|const
block|{
name|QFETCH
argument_list|(
name|FromLatin1Function
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|QString
name|dst
argument_list|(
name|fromLatin1Data
operator|.
name|maxLength
operator|+
literal|16
argument_list|,
name|QChar
argument_list|(
literal|'x'
argument_list|)
argument_list|)
decl_stmt|;
name|fromLatin1Alternatives_internal
argument_list|(
name|function
argument_list|,
name|dst
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QBENCHMARK
block|{
name|fromLatin1Alternatives_internal
argument_list|(
name|function
argument_list|,
name|dst
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_typedef
DECL|typedef|FromUtf8Function
typedef|typedef
name|int
function_decl|(
modifier|*
name|FromUtf8Function
function_decl|)
parameter_list|(
name|ushort
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef
begin_macro
name|Q_DECLARE_METATYPE
argument_list|(
argument|FromUtf8Function
argument_list|)
end_macro
begin_decl_stmt
specifier|extern
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|state
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|state
comment|// just because the code in qutfcodec.cpp uses a state
end_comment
begin_function
DECL|function|fromUtf8_latin1_regular
name|int
name|fromUtf8_latin1_regular
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|fromLatin1_regular
argument_list|(
name|dst
argument_list|,
name|chars
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__SSE2__
end_ifdef
begin_function
DECL|function|fromUtf8_latin1_qt47
name|int
name|fromUtf8_latin1_qt47
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|fromLatin1_sse2_qt47
argument_list|(
name|dst
argument_list|,
name|chars
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_function
DECL|function|fromUtf8_latin1_sse2_improved
name|int
name|fromUtf8_latin1_sse2_improved
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|fromLatin1_sse2_improved
argument_list|(
name|dst
argument_list|,
name|chars
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|fromUtf8_qt47
name|int
name|fromUtf8_qt47
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// this is almost the code found in Qt 4.7's qutfcodec.cpp QUtf8Codec::convertToUnicode
comment|// That function returns a QString, this one returns the number of characters converted
comment|// That's to avoid doing malloc() inside the benchmark test
comment|// Any differences between this code and the original are just because of that, I promise
name|bool
name|headerdone
init|=
literal|false
decl_stmt|;
name|ushort
name|replacement
init|=
name|QChar
operator|::
name|ReplacementCharacter
decl_stmt|;
name|int
name|need
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
name|uint
name|uc
init|=
literal|0
decl_stmt|;
name|uint
name|min_uc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|state
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
condition|)
name|headerdone
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|ConvertInvalidToNull
condition|)
name|replacement
operator|=
name|QChar
operator|::
name|Null
expr_stmt|;
name|need
operator|=
name|state
operator|->
name|remainingChars
expr_stmt|;
if|if
condition|(
name|need
condition|)
block|{
name|uc
operator|=
name|state
operator|->
name|state_data
index|[
literal|0
index|]
expr_stmt|;
name|min_uc
operator|=
name|state
operator|->
name|state_data
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|headerdone
operator|&&
name|len
operator|>
literal|3
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|0
index|]
operator|==
literal|0xef
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|1
index|]
operator|==
literal|0xbb
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|2
index|]
operator|==
literal|0xbf
condition|)
block|{
comment|// starts with a byte order mark
name|chars
operator|+=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
name|headerdone
operator|=
literal|true
expr_stmt|;
block|}
comment|// QString result(need + len + 1, Qt::Uninitialized); // worst case
comment|// ushort *qch = (ushort *)result.unicode();
name|ushort
modifier|*
name|qch
init|=
name|dst
decl_stmt|;
name|uchar
name|ch
decl_stmt|;
name|int
name|invalid
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|ch
operator|=
name|chars
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|need
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xc0
operator|)
operator|==
literal|0x80
condition|)
block|{
name|uc
operator|=
operator|(
name|uc
operator|<<
literal|6
operator|)
operator||
operator|(
name|ch
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|--
name|need
expr_stmt|;
if|if
condition|(
operator|!
name|need
condition|)
block|{
comment|// utf-8 bom composes into 0xfeff code point
name|bool
name|nonCharacter
decl_stmt|;
if|if
condition|(
operator|!
name|headerdone
operator|&&
name|uc
operator|==
literal|0xfeff
condition|)
block|{
comment|// don't do anything, just skip the BOM
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|nonCharacter
operator|=
name|QChar
operator|::
name|isNonCharacter
argument_list|(
name|uc
argument_list|)
operator|)
operator|&&
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|uc
argument_list|)
operator|&&
name|uc
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
condition|)
block|{
comment|// surrogate pair
comment|//Q_ASSERT((qch - (ushort*)result.unicode()) + 2< result.length());
operator|*
name|qch
operator|++
operator|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|uc
argument_list|)
expr_stmt|;
operator|*
name|qch
operator|++
operator|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|uc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|uc
operator|<
name|min_uc
operator|)
operator|||
name|QChar
operator|::
name|isSurrogate
argument_list|(
name|uc
argument_list|)
operator|||
name|nonCharacter
operator|||
name|uc
operator|>
name|QChar
operator|::
name|LastValidCodePoint
condition|)
block|{
comment|// error: overlong sequence, UTF16 surrogate or non-character
operator|*
name|qch
operator|++
operator|=
name|replacement
expr_stmt|;
operator|++
name|invalid
expr_stmt|;
block|}
else|else
block|{
operator|*
name|qch
operator|++
operator|=
name|uc
expr_stmt|;
block|}
name|headerdone
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// error
name|i
operator|=
name|error
expr_stmt|;
operator|*
name|qch
operator|++
operator|=
name|replacement
expr_stmt|;
operator|++
name|invalid
expr_stmt|;
name|need
operator|=
literal|0
expr_stmt|;
name|headerdone
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|<
literal|128
condition|)
block|{
operator|*
name|qch
operator|++
operator|=
name|ushort
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|headerdone
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
block|{
name|uc
operator|=
name|ch
operator|&
literal|0x1f
expr_stmt|;
name|need
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|i
expr_stmt|;
name|min_uc
operator|=
literal|0x80
expr_stmt|;
name|headerdone
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
block|{
name|uc
operator|=
name|ch
operator|&
literal|0x0f
expr_stmt|;
name|need
operator|=
literal|2
expr_stmt|;
name|error
operator|=
name|i
expr_stmt|;
name|min_uc
operator|=
literal|0x800
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xf8
operator|)
operator|==
literal|0xf0
condition|)
block|{
name|uc
operator|=
name|ch
operator|&
literal|0x07
expr_stmt|;
name|need
operator|=
literal|3
expr_stmt|;
name|error
operator|=
name|i
expr_stmt|;
name|min_uc
operator|=
literal|0x10000
expr_stmt|;
name|headerdone
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// error
operator|*
name|qch
operator|++
operator|=
name|replacement
expr_stmt|;
operator|++
name|invalid
expr_stmt|;
name|headerdone
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|state
operator|&&
name|need
operator|>
literal|0
condition|)
block|{
comment|// unterminated UTF sequence
for|for
control|(
name|int
name|i
init|=
name|error
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|qch
operator|++
operator|=
name|replacement
expr_stmt|;
operator|++
name|invalid
expr_stmt|;
block|}
block|}
comment|//result.truncate(qch - (ushort *)result.unicode());
if|if
condition|(
name|state
condition|)
block|{
name|state
operator|->
name|invalidChars
operator|+=
name|invalid
expr_stmt|;
name|state
operator|->
name|remainingChars
operator|=
name|need
expr_stmt|;
if|if
condition|(
name|headerdone
condition|)
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
name|state
operator|->
name|state_data
index|[
literal|0
index|]
operator|=
name|need
condition|?
name|uc
else|:
literal|0
expr_stmt|;
name|state
operator|->
name|state_data
index|[
literal|1
index|]
operator|=
name|need
condition|?
name|min_uc
else|:
literal|0
expr_stmt|;
block|}
comment|//return result;
return|return
name|qch
operator|-
name|dst
return|;
block|}
end_function
begin_function
DECL|function|fromUtf8_qt47_stateless
name|int
name|fromUtf8_qt47_stateless
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// This is the same code as above, but for stateless UTF-8 conversion
comment|// no other improvements
name|bool
name|headerdone
init|=
literal|false
decl_stmt|;
specifier|const
name|ushort
name|replacement
init|=
name|QChar
operator|::
name|ReplacementCharacter
decl_stmt|;
name|int
name|need
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
name|uint
name|uc
init|=
literal|0
decl_stmt|;
name|uint
name|min_uc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|0
index|]
operator|==
literal|0xef
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|1
index|]
operator|==
literal|0xbb
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|2
index|]
operator|==
literal|0xbf
condition|)
block|{
comment|// starts with a byte order mark
name|chars
operator|+=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
comment|// QString result(need + len + 1, Qt::Uninitialized); // worst case
comment|// ushort *qch = (ushort *)result.unicode();
name|ushort
modifier|*
name|qch
init|=
name|dst
decl_stmt|;
name|uchar
name|ch
decl_stmt|;
name|int
name|invalid
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|ch
operator|=
name|chars
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|need
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xc0
operator|)
operator|==
literal|0x80
condition|)
block|{
name|uc
operator|=
operator|(
name|uc
operator|<<
literal|6
operator|)
operator||
operator|(
name|ch
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|--
name|need
expr_stmt|;
if|if
condition|(
operator|!
name|need
condition|)
block|{
comment|// utf-8 bom composes into 0xfeff code point
name|bool
name|nonCharacter
decl_stmt|;
if|if
condition|(
operator|!
name|headerdone
operator|&&
name|uc
operator|==
literal|0xfeff
condition|)
block|{
comment|// don't do anything, just skip the BOM
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|nonCharacter
operator|=
name|QChar
operator|::
name|isNonCharacter
argument_list|(
name|uc
argument_list|)
operator|)
operator|&&
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|uc
argument_list|)
operator|&&
name|uc
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
condition|)
block|{
comment|// surrogate pair
comment|//Q_ASSERT((qch - (ushort*)result.unicode()) + 2< result.length());
operator|*
name|qch
operator|++
operator|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|uc
argument_list|)
expr_stmt|;
operator|*
name|qch
operator|++
operator|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|uc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|uc
operator|<
name|min_uc
operator|)
operator|||
name|QChar
operator|::
name|isSurrogate
argument_list|(
name|uc
argument_list|)
operator|||
name|nonCharacter
operator|||
name|uc
operator|>
name|QChar
operator|::
name|LastValidCodePoint
condition|)
block|{
comment|// error: overlong sequence, UTF16 surrogate or non-character
operator|*
name|qch
operator|++
operator|=
name|replacement
expr_stmt|;
operator|++
name|invalid
expr_stmt|;
block|}
else|else
block|{
operator|*
name|qch
operator|++
operator|=
name|uc
expr_stmt|;
block|}
name|headerdone
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// error
name|i
operator|=
name|error
expr_stmt|;
operator|*
name|qch
operator|++
operator|=
name|replacement
expr_stmt|;
operator|++
name|invalid
expr_stmt|;
name|need
operator|=
literal|0
expr_stmt|;
name|headerdone
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|<
literal|128
condition|)
block|{
operator|*
name|qch
operator|++
operator|=
name|ushort
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|headerdone
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
block|{
name|uc
operator|=
name|ch
operator|&
literal|0x1f
expr_stmt|;
name|need
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|i
expr_stmt|;
name|min_uc
operator|=
literal|0x80
expr_stmt|;
name|headerdone
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
block|{
name|uc
operator|=
name|ch
operator|&
literal|0x0f
expr_stmt|;
name|need
operator|=
literal|2
expr_stmt|;
name|error
operator|=
name|i
expr_stmt|;
name|min_uc
operator|=
literal|0x800
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xf8
operator|)
operator|==
literal|0xf0
condition|)
block|{
name|uc
operator|=
name|ch
operator|&
literal|0x07
expr_stmt|;
name|need
operator|=
literal|3
expr_stmt|;
name|error
operator|=
name|i
expr_stmt|;
name|min_uc
operator|=
literal|0x10000
expr_stmt|;
name|headerdone
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// error
operator|*
name|qch
operator|++
operator|=
name|replacement
expr_stmt|;
operator|++
name|invalid
expr_stmt|;
name|headerdone
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|need
operator|>
literal|0
condition|)
block|{
comment|// unterminated UTF sequence
for|for
control|(
name|int
name|i
init|=
name|error
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|qch
operator|++
operator|=
name|replacement
expr_stmt|;
operator|++
name|invalid
expr_stmt|;
block|}
block|}
comment|//result.truncate(qch - (ushort *)result.unicode());
comment|//return result;
return|return
name|qch
operator|-
name|dst
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|bool
name|trusted
parameter_list|>
DECL|function|extract_utf8_multibyte
specifier|static
specifier|inline
name|void
name|extract_utf8_multibyte
parameter_list|(
name|ushort
modifier|*
modifier|&
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|chars
parameter_list|,
name|qptrdiff
modifier|&
name|counter
parameter_list|,
name|int
modifier|&
name|len
parameter_list|)
block|{
name|uchar
name|ch
init|=
name|chars
index|[
name|counter
index|]
decl_stmt|;
comment|// is it a leading or a continuation one?
if|if
condition|(
operator|!
name|trusted
operator|&&
operator|(
name|ch
operator|&
literal|0xc0
operator|)
operator|==
literal|0x80
condition|)
block|{
comment|// continuation character found without the leading
name|dst
index|[
name|counter
operator|++
index|]
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
block|{
comment|// two-byte UTF-8 sequence
if|if
condition|(
operator|!
name|trusted
operator|&&
name|counter
operator|+
literal|1
operator|==
name|len
condition|)
block|{
name|dst
index|[
name|counter
operator|++
index|]
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
return|return;
block|}
name|uchar
name|ch2
init|=
name|chars
index|[
name|counter
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|trusted
condition|)
if|if
condition|(
operator|(
name|ch2
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|dst
index|[
name|counter
operator|++
index|]
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
return|return;
block|}
name|ushort
name|ucs
init|=
operator|(
name|ch
operator|&
literal|0x1f
operator|)
decl_stmt|;
name|ucs
operator|<<=
literal|6
expr_stmt|;
name|ucs
operator||=
operator|(
name|ch2
operator|&
literal|0x3f
operator|)
expr_stmt|;
comment|// dst[counter] will correspond to chars[counter..counter+1], so adjust
operator|++
name|chars
expr_stmt|;
operator|--
name|len
expr_stmt|;
if|if
condition|(
name|trusted
operator|||
name|ucs
operator|>=
literal|0x80
condition|)
name|dst
index|[
name|counter
index|]
operator|=
name|ucs
expr_stmt|;
else|else
name|dst
index|[
name|counter
index|]
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
operator|++
name|counter
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
block|{
comment|// three-byte UTF-8 sequence
if|if
condition|(
operator|!
name|trusted
operator|&&
name|counter
operator|+
literal|2
operator|>=
name|len
condition|)
block|{
name|dst
index|[
name|counter
operator|++
index|]
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
return|return;
block|}
name|uchar
name|ch2
init|=
name|chars
index|[
name|counter
operator|+
literal|1
index|]
decl_stmt|;
name|uchar
name|ch3
init|=
name|chars
index|[
name|counter
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|trusted
condition|)
if|if
condition|(
operator|(
name|ch2
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
operator|||
operator|(
name|ch3
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|dst
index|[
name|counter
operator|++
index|]
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
return|return;
block|}
name|ushort
name|ucs
init|=
operator|(
name|ch
operator|&
literal|0x1f
operator|)
operator|<<
literal|12
operator||
operator|(
name|ch2
operator|&
literal|0x3f
operator|)
operator|<<
literal|6
operator||
operator|(
name|ch3
operator|&
literal|0x3f
operator|)
decl_stmt|;
comment|// dst[counter] will correspond to chars[counter..counter+2], so adjust
name|chars
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|trusted
operator|&&
operator|(
name|ucs
operator|<
literal|0x800
operator|||
name|QChar
operator|::
name|isNonCharacter
argument_list|(
name|ucs
argument_list|)
operator|||
name|QChar
operator|::
name|isSurrogate
argument_list|(
name|ucs
argument_list|)
operator|)
condition|)
name|dst
index|[
name|counter
index|]
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
else|else
name|dst
index|[
name|counter
index|]
operator|=
name|ucs
expr_stmt|;
operator|++
name|counter
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xf8
operator|)
operator|==
literal|0xf0
condition|)
block|{
comment|// four-byte UTF-8 sequence
comment|// will require an UTF-16 surrogate pair
if|if
condition|(
operator|!
name|trusted
operator|&&
name|counter
operator|+
literal|3
operator|>=
name|len
condition|)
block|{
name|dst
index|[
name|counter
operator|++
index|]
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
return|return;
block|}
name|uchar
name|ch2
init|=
name|chars
index|[
name|counter
operator|+
literal|1
index|]
decl_stmt|;
name|uchar
name|ch3
init|=
name|chars
index|[
name|counter
operator|+
literal|2
index|]
decl_stmt|;
name|uchar
name|ch4
init|=
name|chars
index|[
name|counter
operator|+
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|trusted
condition|)
if|if
condition|(
operator|(
name|ch2
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
operator|||
operator|(
name|ch3
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
operator|||
operator|(
name|ch4
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|dst
index|[
name|counter
operator|++
index|]
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
return|return;
block|}
name|uint
name|ucs
init|=
operator|(
name|ch
operator|&
literal|0x1f
operator|)
operator|<<
literal|18
operator||
operator|(
name|ch2
operator|&
literal|0x3f
operator|)
operator|<<
literal|12
operator||
operator|(
name|ch3
operator|&
literal|0x3f
operator|)
operator|<<
literal|6
operator||
operator|(
name|ch4
operator|&
literal|0x3f
operator|)
decl_stmt|;
comment|// dst[counter] will correspond to chars[counter..counter+2], so adjust
name|chars
operator|+=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|trusted
operator|||
operator|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|ucs
argument_list|)
operator|&&
name|ucs
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
operator|&&
operator|!
name|QChar
operator|::
name|isNonCharacter
argument_list|(
name|ucs
argument_list|)
operator|)
condition|)
block|{
name|dst
index|[
name|counter
operator|+
literal|0
index|]
operator|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|ucs
argument_list|)
expr_stmt|;
name|dst
index|[
name|counter
operator|+
literal|1
index|]
operator|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|ucs
argument_list|)
expr_stmt|;
name|counter
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|dst
index|[
name|counter
operator|++
index|]
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
block|}
return|return;
block|}
operator|++
name|counter
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fromUtf8_optimised_for_ascii
name|int
name|fromUtf8_optimised_for_ascii
parameter_list|(
name|ushort
modifier|*
name|qch
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|0
index|]
operator|==
literal|0xef
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|1
index|]
operator|==
literal|0xbb
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|2
index|]
operator|==
literal|0xbf
condition|)
block|{
comment|// starts with a byte order mark
name|chars
operator|+=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
name|ushort
modifier|*
name|dst
init|=
name|qch
decl_stmt|;
while|while
condition|(
name|counter
operator|<
name|len
condition|)
block|{
name|uchar
name|ch
init|=
name|chars
index|[
name|counter
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|dst
index|[
name|counter
index|]
operator|=
name|ch
expr_stmt|;
operator|++
name|counter
expr_stmt|;
continue|continue;
block|}
comment|// UTF-8 character found
name|extract_utf8_multibyte
argument_list|<
literal|false
argument_list|>
argument_list|(
name|dst
argument_list|,
name|chars
argument_list|,
name|counter
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|dst
operator|+
name|counter
operator|-
name|qch
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__SSE2__
end_ifdef
begin_function
DECL|function|fromUtf8_sse2_optimised_for_ascii
name|int
name|fromUtf8_sse2_optimised_for_ascii
parameter_list|(
name|ushort
modifier|*
name|qch
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|0
index|]
operator|==
literal|0xef
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|1
index|]
operator|==
literal|0xbb
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|2
index|]
operator|==
literal|0xbf
condition|)
block|{
comment|// starts with a byte order mark
name|chars
operator|+=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
name|ushort
modifier|*
name|dst
init|=
name|qch
decl_stmt|;
name|len
operator|-=
literal|16
expr_stmt|;
specifier|const
name|__m128i
name|nullMask
init|=
name|_mm_set1_epi32
argument_list|(
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|counter
operator|<
name|len
condition|)
block|{
specifier|const
name|__m128i
name|chunk
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|chars
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
comment|// load
name|ushort
name|highbytes
init|=
name|_mm_movemask_epi8
argument_list|(
name|chunk
argument_list|)
decl_stmt|;
comment|// unpack the first 8 bytes, padding with zeros
specifier|const
name|__m128i
name|firstHalf
init|=
name|_mm_unpacklo_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|)
argument_list|,
name|firstHalf
argument_list|)
expr_stmt|;
comment|// store
if|if
condition|(
operator|!
name|uchar
argument_list|(
name|highbytes
argument_list|)
condition|)
block|{
comment|// unpack the last 8 bytes, padding with zeros
specifier|const
name|__m128i
name|secondHalf
init|=
name|_mm_unpackhi_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|+
literal|8
operator|)
argument_list|,
name|secondHalf
argument_list|)
expr_stmt|;
comment|// store
if|if
condition|(
operator|!
name|highbytes
condition|)
block|{
name|counter
operator|+=
literal|16
expr_stmt|;
continue|continue;
block|}
block|}
comment|// UTF-8 character found
comment|// which one?
name|counter
operator|+=
name|bsf_nonzero
argument_list|(
name|highbytes
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|16
expr_stmt|;
name|extract_utf8_multibyte
argument_list|<
literal|false
argument_list|>
argument_list|(
name|dst
argument_list|,
name|chars
argument_list|,
name|counter
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|16
expr_stmt|;
block|}
name|len
operator|+=
literal|16
expr_stmt|;
while|while
condition|(
name|counter
operator|<
name|len
condition|)
block|{
name|uchar
name|ch
init|=
name|chars
index|[
name|counter
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|dst
index|[
name|counter
index|]
operator|=
name|ch
expr_stmt|;
operator|++
name|counter
expr_stmt|;
continue|continue;
block|}
comment|// UTF-8 character found
name|extract_utf8_multibyte
argument_list|<
literal|false
argument_list|>
argument_list|(
name|dst
argument_list|,
name|chars
argument_list|,
name|counter
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|dst
operator|+
name|counter
operator|-
name|qch
return|;
block|}
end_function
begin_function
DECL|function|fromUtf8_sse2_trusted_no_bom
name|int
name|fromUtf8_sse2_trusted_no_bom
parameter_list|(
name|ushort
modifier|*
name|qch
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
name|ushort
modifier|*
name|dst
init|=
name|qch
decl_stmt|;
name|len
operator|-=
literal|16
expr_stmt|;
specifier|const
name|__m128i
name|nullMask
init|=
name|_mm_set1_epi32
argument_list|(
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|counter
operator|<
name|len
condition|)
block|{
specifier|const
name|__m128i
name|chunk
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|chars
operator|+
name|counter
operator|)
argument_list|)
decl_stmt|;
comment|// load
name|ushort
name|highbytes
init|=
name|_mm_movemask_epi8
argument_list|(
name|chunk
argument_list|)
decl_stmt|;
comment|// unpack the first 8 bytes, padding with zeros
specifier|const
name|__m128i
name|firstHalf
init|=
name|_mm_unpacklo_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|)
argument_list|,
name|firstHalf
argument_list|)
expr_stmt|;
comment|// store
if|if
condition|(
operator|!
name|uchar
argument_list|(
name|highbytes
argument_list|)
condition|)
block|{
comment|// unpack the last 8 bytes, padding with zeros
specifier|const
name|__m128i
name|secondHalf
init|=
name|_mm_unpackhi_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|counter
operator|+
literal|8
operator|)
argument_list|,
name|secondHalf
argument_list|)
expr_stmt|;
comment|// store
if|if
condition|(
operator|!
name|highbytes
condition|)
block|{
name|counter
operator|+=
literal|16
expr_stmt|;
continue|continue;
block|}
block|}
comment|// UTF-8 character found
comment|// which one?
name|counter
operator|+=
name|bsf_nonzero
argument_list|(
name|highbytes
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|16
expr_stmt|;
name|extract_utf8_multibyte
argument_list|<
literal|true
argument_list|>
argument_list|(
name|dst
argument_list|,
name|chars
argument_list|,
name|counter
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|16
expr_stmt|;
block|}
name|len
operator|+=
literal|16
expr_stmt|;
while|while
condition|(
name|counter
operator|<
name|len
condition|)
block|{
name|uchar
name|ch
init|=
name|chars
index|[
name|counter
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|dst
index|[
name|counter
index|]
operator|=
name|ch
expr_stmt|;
operator|++
name|counter
expr_stmt|;
continue|continue;
block|}
comment|// UTF-8 character found
name|extract_utf8_multibyte
argument_list|<
literal|true
argument_list|>
argument_list|(
name|dst
argument_list|,
name|chars
argument_list|,
name|counter
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|dst
operator|+
name|counter
operator|-
name|qch
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|__ARM_NEON__
end_ifdef
begin_function
DECL|function|fromUtf8_latin1_neon
name|int
name|fromUtf8_latin1_neon
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|fromLatin1_neon_improved
argument_list|(
name|dst
argument_list|,
name|chars
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_function
DECL|function|fromUtf8_neon
name|int
name|fromUtf8_neon
parameter_list|(
name|ushort
modifier|*
name|qch
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|0
index|]
operator|==
literal|0xef
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|1
index|]
operator|==
literal|0xbb
operator|&&
operator|(
name|uchar
operator|)
name|chars
index|[
literal|2
index|]
operator|==
literal|0xbf
condition|)
block|{
comment|// starts with a byte order mark
name|chars
operator|+=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
name|ushort
modifier|*
name|dst
init|=
name|qch
decl_stmt|;
specifier|const
name|uint8x8_t
name|highBit
init|=
name|vdup_n_u8
argument_list|(
literal|0x80
argument_list|)
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
comment|// load 8 bytes into one doubleword Neon register
specifier|const
name|uint8x8_t
name|chunk
init|=
name|vld1_u8
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|chars
argument_list|)
decl_stmt|;
specifier|const
name|uint16x8_t
name|expanded
init|=
name|vmovl_u8
argument_list|(
name|chunk
argument_list|)
decl_stmt|;
name|vst1q_u16
argument_list|(
name|dst
argument_list|,
name|expanded
argument_list|)
expr_stmt|;
name|uint8x8_t
name|highBits
init|=
name|vtst_u8
argument_list|(
name|chunk
argument_list|,
name|highBit
argument_list|)
decl_stmt|;
comment|// we need to find the lowest byte set
name|int
name|mask_low
init|=
name|vget_lane_u32
argument_list|(
name|vreinterpret_u32_u8
argument_list|(
name|highBits
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|mask_high
init|=
name|vget_lane_u32
argument_list|(
name|vreinterpret_u32_u8
argument_list|(
name|highBits
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|mask_low
operator|==
literal|0
operator|&&
name|mask_high
operator|==
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|chars
operator|+=
literal|8
expr_stmt|;
name|dst
operator|+=
literal|8
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|// UTF-8 character found
comment|// which one?
name|qptrdiff
name|pos
decl_stmt|;
asm|asm ("rbit  %0, %1\n"                  "clz   %1, %1\n"                : "=r" (pos)                : "r" (mask_low
operator|?
asm|mask_low : mask_high));
comment|// now mask_low contains the number of leading zeroes
comment|// or the value 32 (0x20) if no zeroes were found
comment|// the number of leading zeroes is 8*pos
name|pos
operator|/=
literal|8
expr_stmt|;
name|extract_utf8_multibyte
argument_list|<
literal|false
argument_list|>
argument_list|(
name|dst
argument_list|,
name|chars
argument_list|,
name|pos
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|chars
operator|+=
name|pos
expr_stmt|;
name|dst
operator|+=
name|pos
expr_stmt|;
name|len
operator|-=
name|pos
expr_stmt|;
block|}
block|}
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|counter
operator|<
name|len
condition|)
block|{
name|uchar
name|ch
init|=
name|chars
index|[
name|counter
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|dst
index|[
name|counter
index|]
operator|=
name|ch
expr_stmt|;
operator|++
name|counter
expr_stmt|;
continue|continue;
block|}
comment|// UTF-8 character found
name|extract_utf8_multibyte
argument_list|<
literal|false
argument_list|>
argument_list|(
name|dst
argument_list|,
name|chars
argument_list|,
name|counter
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|dst
operator|+
name|counter
operator|-
name|qch
return|;
block|}
end_function
begin_function
DECL|function|fromUtf8_neon_trusted
name|int
name|fromUtf8_neon_trusted
parameter_list|(
name|ushort
modifier|*
name|qch
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|ushort
modifier|*
name|dst
init|=
name|qch
decl_stmt|;
specifier|const
name|uint8x8_t
name|highBit
init|=
name|vdup_n_u8
argument_list|(
literal|0x80
argument_list|)
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
comment|// load 8 bytes into one doubleword Neon register
specifier|const
name|uint8x8_t
name|chunk
init|=
name|vld1_u8
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|chars
argument_list|)
decl_stmt|;
specifier|const
name|uint16x8_t
name|expanded
init|=
name|vmovl_u8
argument_list|(
name|chunk
argument_list|)
decl_stmt|;
name|vst1q_u16
argument_list|(
name|dst
argument_list|,
name|expanded
argument_list|)
expr_stmt|;
name|uint8x8_t
name|highBits
init|=
name|vtst_u8
argument_list|(
name|chunk
argument_list|,
name|highBit
argument_list|)
decl_stmt|;
comment|// we need to find the lowest byte set
name|int
name|mask_low
init|=
name|vget_lane_u32
argument_list|(
name|vreinterpret_u32_u8
argument_list|(
name|highBits
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|mask_high
init|=
name|vget_lane_u32
argument_list|(
name|vreinterpret_u32_u8
argument_list|(
name|highBits
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|mask_low
operator|==
literal|0
operator|&&
name|mask_high
operator|==
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|chars
operator|+=
literal|8
expr_stmt|;
name|dst
operator|+=
literal|8
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|// UTF-8 character found
comment|// which one?
name|qptrdiff
name|pos
decl_stmt|;
asm|asm ("rbit  %0, %1\n"                  "clz   %1, %1\n"                : "=r" (pos)                : "r" (mask_low
operator|?
asm|mask_low : mask_high));
comment|// now mask_low contains the number of leading zeroes
comment|// or the value 32 (0x20) if no zeroes were found
comment|// the number of leading zeroes is 8*pos
name|pos
operator|/=
literal|8
expr_stmt|;
name|extract_utf8_multibyte
argument_list|<
literal|true
argument_list|>
argument_list|(
name|dst
argument_list|,
name|chars
argument_list|,
name|pos
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|chars
operator|+=
name|pos
expr_stmt|;
name|dst
operator|+=
name|pos
expr_stmt|;
name|len
operator|-=
name|pos
expr_stmt|;
block|}
block|}
name|qptrdiff
name|counter
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|counter
operator|<
name|len
condition|)
block|{
name|uchar
name|ch
init|=
name|chars
index|[
name|counter
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|dst
index|[
name|counter
index|]
operator|=
name|ch
expr_stmt|;
operator|++
name|counter
expr_stmt|;
continue|continue;
block|}
comment|// UTF-8 character found
name|extract_utf8_multibyte
argument_list|<
literal|true
argument_list|>
argument_list|(
name|dst
argument_list|,
name|chars
argument_list|,
name|counter
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|dst
operator|+
name|counter
operator|-
name|qch
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|fromUtf8Alternatives_data
name|void
name|tst_QString
operator|::
name|fromUtf8Alternatives_data
parameter_list|()
specifier|const
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|FromUtf8Function
argument_list|>
argument_list|(
literal|"function"
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"empty"
argument_list|)
operator|<<
name|FromUtf8Function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"qt-4.7"
argument_list|)
operator|<<
operator|&
name|fromUtf8_qt47
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"qt-4.7-stateless"
argument_list|)
operator|<<
operator|&
name|fromUtf8_qt47_stateless
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"optimized-for-ascii"
argument_list|)
operator|<<
operator|&
name|fromUtf8_optimised_for_ascii
expr_stmt|;
ifdef|#
directive|ifdef
name|__SSE2__
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse2-optimized-for-ascii"
argument_list|)
operator|<<
operator|&
name|fromUtf8_sse2_optimised_for_ascii
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"sse2-trusted-no-bom"
argument_list|)
operator|<<
operator|&
name|fromUtf8_sse2_trusted_no_bom
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__ARM_NEON__
name|QTest
operator|::
name|newRow
argument_list|(
literal|"neon"
argument_list|)
operator|<<
operator|&
name|fromUtf8_neon
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"neon-trusted-no-bom"
argument_list|)
operator|<<
operator|&
name|fromUtf8_neon_trusted
expr_stmt|;
endif|#
directive|endif
name|QTest
operator|::
name|newRow
argument_list|(
literal|"latin1-generic"
argument_list|)
operator|<<
operator|&
name|fromUtf8_latin1_regular
expr_stmt|;
ifdef|#
directive|ifdef
name|__SSE2__
name|QTest
operator|::
name|newRow
argument_list|(
literal|"latin1-sse2-qt4.7"
argument_list|)
operator|<<
operator|&
name|fromUtf8_latin1_qt47
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"latin1-sse2-improved"
argument_list|)
operator|<<
operator|&
name|fromUtf8_latin1_sse2_improved
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__ARM_NEON__
name|QTest
operator|::
name|newRow
argument_list|(
literal|"latin1-neon-improved"
argument_list|)
operator|<<
operator|&
name|fromUtf8_latin1_neon
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_decl_stmt
specifier|extern
name|StringData
name|fromUtf8Data
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|fromUtf8Alternatives_internal
specifier|static
name|void
name|fromUtf8Alternatives_internal
parameter_list|(
name|FromUtf8Function
name|function
parameter_list|,
name|QString
modifier|&
name|dst
parameter_list|,
name|bool
name|doVerify
parameter_list|)
block|{
if|if
condition|(
operator|!
name|doVerify
condition|)
block|{
comment|// NOTE: this only works because the Latin1 data is ASCII-only
name|fromLatin1Alternatives_internal
argument_list|(
cast|reinterpret_cast
argument_list|<
name|FromLatin1Function
argument_list|>
argument_list|(
name|function
argument_list|)
argument_list|,
name|dst
argument_list|,
name|doVerify
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|QTest
operator|::
name|currentDataTag
argument_list|()
argument_list|,
literal|"latin1-"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
return|return;
block|}
struct|struct
name|Entry
block|{
name|int
name|len
decl_stmt|;
name|int
name|offset1
decl_stmt|,
name|offset2
decl_stmt|;
name|int
name|align1
decl_stmt|,
name|align2
decl_stmt|;
block|}
struct|;
specifier|const
name|Entry
modifier|*
name|entries
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|Entry
operator|*
argument_list|>
argument_list|(
name|fromUtf8Data
operator|.
name|entries
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fromUtf8Data
operator|.
name|entryCount
condition|;
operator|++
name|i
control|)
block|{
name|int
name|len
init|=
name|entries
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
init|=
name|fromUtf8Data
operator|.
name|charData
operator|+
name|entries
index|[
name|i
index|]
operator|.
name|offset1
decl_stmt|;
if|if
condition|(
operator|!
name|function
condition|)
continue|continue;
if|if
condition|(
operator|!
name|doVerify
condition|)
block|{
call|(
name|function
call|)
argument_list|(
operator|&
name|dst
operator|.
name|data
argument_list|()
operator|->
name|unicode
argument_list|()
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|.
name|fill
argument_list|(
name|QChar
argument_list|(
literal|'x'
argument_list|)
argument_list|,
name|dst
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|utf8len
init|=
call|(
name|function
call|)
argument_list|(
operator|&
name|dst
operator|.
name|data
argument_list|()
operator|->
name|unicode
argument_list|()
operator|+
literal|8
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|QString
name|expected
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|src
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|QString
name|final
init|=
name|dst
operator|.
name|mid
argument_list|(
literal|8
argument_list|,
name|expected
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|final
operator|!=
name|expected
operator|||
name|utf8len
operator|!=
name|expected
operator|.
name|length
argument_list|()
condition|)
name|qDebug
argument_list|()
operator|<<
name|i
operator|<<
name|entries
index|[
name|i
index|]
operator|.
name|offset1
operator|<<
name|utf8len
operator|<<
name|final
operator|<<
name|expected
operator|.
name|length
argument_list|()
operator|<<
name|expected
expr_stmt|;
name|QCOMPARE
argument_list|(
name|final
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|utf8len
argument_list|,
name|expected
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|zeroes
argument_list|(
literal|8
argument_list|,
name|QChar
argument_list|(
literal|'x'
argument_list|)
argument_list|)
decl_stmt|;
name|QCOMPARE
argument_list|(
name|dst
operator|.
name|left
argument_list|(
literal|8
argument_list|)
argument_list|,
name|zeroes
argument_list|)
expr_stmt|;
name|QCOMPARE
argument_list|(
name|dst
operator|.
name|mid
argument_list|(
name|len
operator|+
literal|8
argument_list|,
literal|8
argument_list|)
argument_list|,
name|zeroes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|fromUtf8Alternatives
name|void
name|tst_QString
operator|::
name|fromUtf8Alternatives
parameter_list|()
specifier|const
block|{
name|QFETCH
argument_list|(
name|FromUtf8Function
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|QString
name|dst
argument_list|(
name|fromUtf8Data
operator|.
name|maxLength
operator|+
literal|16
argument_list|,
name|QChar
argument_list|(
literal|'x'
argument_list|)
argument_list|)
decl_stmt|;
name|fromUtf8Alternatives_internal
argument_list|(
name|function
argument_list|,
name|dst
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QBENCHMARK
block|{
name|fromUtf8Alternatives_internal
argument_list|(
name|function
argument_list|,
name|dst
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|toUpper_data
name|void
name|tst_QString
operator|::
name|toUpper_data
parameter_list|()
block|{
name|QTest
operator|::
name|addColumn
argument_list|<
name|QString
argument_list|>
argument_list|(
literal|"s"
argument_list|)
expr_stmt|;
name|QString
name|lowerLatin1
argument_list|(
literal|300
argument_list|,
name|QChar
argument_list|(
literal|'a'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|upperLatin1
argument_list|(
literal|300
argument_list|,
name|QChar
argument_list|(
literal|'A'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|lowerDeseret
decl_stmt|;
block|{
name|QString
name|pattern
decl_stmt|;
name|pattern
operator|+=
name|QChar
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
literal|0x10428
argument_list|)
argument_list|)
expr_stmt|;
name|pattern
operator|+=
name|QChar
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
literal|0x10428
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|300
operator|/
name|pattern
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|lowerDeseret
operator|+=
name|pattern
expr_stmt|;
block|}
name|QString
name|upperDeseret
decl_stmt|;
block|{
name|QString
name|pattern
decl_stmt|;
name|pattern
operator|+=
name|QChar
argument_list|(
name|QChar
operator|::
name|highSurrogate
argument_list|(
literal|0x10400
argument_list|)
argument_list|)
expr_stmt|;
name|pattern
operator|+=
name|QChar
argument_list|(
name|QChar
operator|::
name|lowSurrogate
argument_list|(
literal|0x10400
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|300
operator|/
name|pattern
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|upperDeseret
operator|+=
name|pattern
expr_stmt|;
block|}
name|QString
name|lowerLigature
argument_list|(
literal|600
argument_list|,
name|QChar
argument_list|(
literal|0xFB03
argument_list|)
argument_list|)
decl_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"600<a>"
argument_list|)
operator|<<
operator|(
name|lowerLatin1
operator|+
name|lowerLatin1
operator|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"600<A>"
argument_list|)
operator|<<
operator|(
name|upperLatin1
operator|+
name|upperLatin1
operator|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"300<a>+300<A>"
argument_list|)
operator|<<
operator|(
name|lowerLatin1
operator|+
name|upperLatin1
operator|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"300<A>+300<a>"
argument_list|)
operator|<<
operator|(
name|upperLatin1
operator|+
name|lowerLatin1
operator|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"300<10428>"
argument_list|)
operator|<<
operator|(
name|lowerDeseret
operator|+
name|lowerDeseret
operator|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"300<10400>"
argument_list|)
operator|<<
operator|(
name|upperDeseret
operator|+
name|upperDeseret
operator|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"150<10428>+150<10400>"
argument_list|)
operator|<<
operator|(
name|lowerDeseret
operator|+
name|upperDeseret
operator|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"150<10400>+150<10428>"
argument_list|)
operator|<<
operator|(
name|upperDeseret
operator|+
name|lowerDeseret
operator|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"300a+150<10400>"
argument_list|)
operator|<<
operator|(
name|lowerLatin1
operator|+
name|upperDeseret
operator|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"300a+150<10428>"
argument_list|)
operator|<<
operator|(
name|lowerLatin1
operator|+
name|lowerDeseret
operator|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"300A+150<10400>"
argument_list|)
operator|<<
operator|(
name|upperLatin1
operator|+
name|upperDeseret
operator|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"300A+150<10428>"
argument_list|)
operator|<<
operator|(
name|upperLatin1
operator|+
name|lowerDeseret
operator|)
expr_stmt|;
name|QTest
operator|::
name|newRow
argument_list|(
literal|"600<FB03> (ligature)"
argument_list|)
operator|<<
name|lowerLigature
expr_stmt|;
block|}
end_function
begin_function
DECL|function|toUpper
name|void
name|tst_QString
operator|::
name|toUpper
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|QBENCHMARK
block|{
name|s
operator|.
name|toUpper
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|toLower_data
name|void
name|tst_QString
operator|::
name|toLower_data
parameter_list|()
block|{
name|toUpper_data
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|toLower
name|void
name|tst_QString
operator|::
name|toLower
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|QBENCHMARK
block|{
name|s
operator|.
name|toLower
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|toCaseFolded_data
name|void
name|tst_QString
operator|::
name|toCaseFolded_data
parameter_list|()
block|{
name|toUpper_data
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|toCaseFolded
name|void
name|tst_QString
operator|::
name|toCaseFolded
parameter_list|()
block|{
name|QFETCH
argument_list|(
name|QString
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|QBENCHMARK
block|{
name|s
operator|.
name|toCaseFolded
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QTEST_APPLESS_MAIN
argument_list|(
argument|tst_QString
argument_list|)
end_macro
begin_include
include|#
directive|include
file|"main.moc"
end_include
end_unit
