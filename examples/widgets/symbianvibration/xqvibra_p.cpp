begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:BSD$ ** You may use this file under the terms of the BSD license as follows: ** ** "Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions are ** met: **   * Redistributions of source code must retain the above copyright **     notice, this list of conditions and the following disclaimer. **   * Redistributions in binary form must reproduce the above copyright **     notice, this list of conditions and the following disclaimer in **     the documentation and/or other materials provided with the **     distribution. **   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor **     the names of its contributors may be used to endorse or promote **     products derived from this software without specific prior written **     permission. ** ** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR ** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE." ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"xqvibra_p.h"
end_include
begin_decl_stmt
DECL|variable|KDefaultIntensity
specifier|const
name|int
name|KDefaultIntensity
init|=
literal|0xFF
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|XQVibraPrivate
name|XQVibraPrivate
operator|::
name|XQVibraPrivate
parameter_list|(
name|XQVibra
modifier|*
name|vibra
parameter_list|)
member_init_list|:
name|q
argument_list|(
name|vibra
argument_list|)
member_init_list|,
name|iStatus
argument_list|(
name|XQVibra
operator|::
name|StatusOff
argument_list|)
member_init_list|,
name|iDuration
argument_list|(
name|XQVibra
operator|::
name|InfiniteDuration
argument_list|)
member_init_list|,
name|iIntensity
argument_list|(
name|KDefaultIntensity
argument_list|)
block|{
name|TRAP
argument_list|(
argument|iError
argument_list|,
argument|iVibra = CHWRMVibra::NewL();
argument_list|)
name|QObject
operator|::
name|connect
argument_list|(
operator|&
name|iTimer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|stop
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~XQVibraPrivate
name|XQVibraPrivate
operator|::
name|~
name|XQVibraPrivate
parameter_list|()
block|{
operator|delete
name|iVibra
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|start
name|bool
name|XQVibraPrivate
operator|::
name|start
parameter_list|(
name|int
name|aDuration
parameter_list|)
block|{
name|iDuration
operator|=
name|aDuration
expr_stmt|;
name|TRAP
argument_list|(
argument|iError
argument_list|,
argument|if (iIntensity == KDefaultIntensity) {             iVibra->StartVibraL(XQVibra::InfiniteDuration);         } else {             iVibra->StopVibraL();             iVibra->StartVibraL(XQVibra::InfiniteDuration, iIntensity);         }          if (aDuration != XQVibra::InfiniteDuration) {             iTimer.start(aDuration);         } else {             iTimer.stop();         }          if (iStatus != XQVibra::StatusOn) {             iStatus = XQVibra::StatusOn;             emit q->statusChanged(iStatus);         }
argument_list|)
return|return
operator|(
name|iError
operator|==
name|KErrNone
operator|)
return|;
block|}
end_function
begin_function
DECL|function|stop
name|bool
name|XQVibraPrivate
operator|::
name|stop
parameter_list|()
block|{
name|TRAP
argument_list|(
argument|iError
argument_list|,
argument|if (iVibra->VibraStatus() == CHWRMVibra::EVibraStatusOn) {             iVibra->StopVibraL();             if (iTimer.isActive()) {                 iTimer.stop();             }         }          iStatus = XQVibra::StatusOff;         emit q->statusChanged(iStatus);
argument_list|)
return|return
operator|(
name|iError
operator|==
name|KErrNone
operator|)
return|;
block|}
end_function
begin_function
DECL|function|VibraModeChanged
name|void
name|XQVibraPrivate
operator|::
name|VibraModeChanged
parameter_list|(
name|CHWRMVibra
operator|::
name|TVibraModeState
comment|/*aStatus*/
parameter_list|)
block|{
comment|// Implementation isn't needed here because this information isn't used in the public side of the extension
block|}
end_function
begin_function
DECL|function|VibraStatusChanged
name|void
name|XQVibraPrivate
operator|::
name|VibraStatusChanged
parameter_list|(
name|CHWRMVibra
operator|::
name|TVibraStatus
name|aStatus
parameter_list|)
block|{
if|if
condition|(
name|aStatus
operator|==
name|CHWRMVibra
operator|::
name|EVibraStatusUnknown
operator|||
name|aStatus
operator|==
name|CHWRMVibra
operator|::
name|EVibraStatusNotAllowed
condition|)
block|{
name|iStatus
operator|=
name|XQVibra
operator|::
name|StatusNotAllowed
expr_stmt|;
emit|emit
name|q
operator|->
name|statusChanged
argument_list|(
name|iStatus
argument_list|)
emit|;
block|}
if|if
condition|(
name|iDuration
operator|==
name|XQVibra
operator|::
name|InfiniteDuration
condition|)
block|{
if|if
condition|(
name|iStatus
operator|!=
name|XQVibra
operator|::
name|StatusOff
condition|)
block|{
name|iStatus
operator|=
name|XQVibra
operator|::
name|StatusOff
expr_stmt|;
emit|emit
name|q
operator|->
name|statusChanged
argument_list|(
name|iStatus
argument_list|)
emit|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|setIntensity
name|bool
name|XQVibraPrivate
operator|::
name|setIntensity
parameter_list|(
name|int
name|aIntensity
parameter_list|)
block|{
name|TRAP
argument_list|(
argument|iError
argument_list|,
argument|if (aIntensity>= KHWRMVibraMinIntensity&& aIntensity<= KHWRMVibraMaxIntensity) {             iIntensity = aIntensity;             if (iIntensity ==
literal|0
argument|&& iStatus == XQVibra::StatusOn) {                 iVibra->StopVibraL();             } else if (iStatus == XQVibra::StatusOn) {                 iVibra->StopVibraL();                 iVibra->StartVibraL(XQVibra::InfiniteDuration, iIntensity);             }         } else {             User::Leave(KErrArgument);         }
argument_list|)
return|return
operator|(
name|iError
operator|==
name|KErrNone
operator|)
return|;
block|}
end_function
begin_function
DECL|function|currentStatus
name|XQVibra
operator|::
name|Status
name|XQVibraPrivate
operator|::
name|currentStatus
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|iVibra
operator|->
name|VibraStatus
argument_list|()
operator|==
name|CHWRMVibra
operator|::
name|EVibraStatusUnknown
operator|||
name|iVibra
operator|->
name|VibraStatus
argument_list|()
operator|==
name|CHWRMVibra
operator|::
name|EVibraStatusNotAllowed
condition|)
block|{
return|return
name|XQVibra
operator|::
name|StatusNotAllowed
return|;
block|}
return|return
name|iStatus
return|;
block|}
end_function
begin_function
DECL|function|error
name|XQVibra
operator|::
name|Error
name|XQVibraPrivate
operator|::
name|error
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|iError
condition|)
block|{
case|case
name|KErrNone
case|:
return|return
name|XQVibra
operator|::
name|NoError
return|;
case|case
name|KErrNoMemory
case|:
return|return
name|XQVibra
operator|::
name|OutOfMemoryError
return|;
case|case
name|KErrArgument
case|:
return|return
name|XQVibra
operator|::
name|ArgumentError
return|;
case|case
name|KErrInUse
case|:
return|return
name|XQVibra
operator|::
name|VibraInUseError
return|;
case|case
name|KErrGeneral
case|:
return|return
name|XQVibra
operator|::
name|HardwareError
return|;
case|case
name|KErrTimedOut
case|:
return|return
name|XQVibra
operator|::
name|TimeOutError
return|;
case|case
name|KErrLocked
case|:
return|return
name|XQVibra
operator|::
name|VibraLockedError
return|;
case|case
name|KErrAccessDenied
case|:
return|return
name|XQVibra
operator|::
name|AccessDeniedError
return|;
default|default:
return|return
name|XQVibra
operator|::
name|UnknownError
return|;
block|}
block|}
end_function
begin_comment
comment|// End of file
end_comment
end_unit
