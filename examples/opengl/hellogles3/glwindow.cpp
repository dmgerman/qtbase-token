begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the examples of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:BSD$ ** You may use this file under the terms of the BSD license as follows: ** ** "Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions are ** met: **   * Redistributions of source code must retain the above copyright **     notice, this list of conditions and the following disclaimer. **   * Redistributions in binary form must reproduce the above copyright **     notice, this list of conditions and the following disclaimer in **     the documentation and/or other materials provided with the **     distribution. **   * Neither the name of The Qt Company Ltd nor the names of its **     contributors may be used to endorse or promote products derived **     from this software without specific prior written permission. ** ** ** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR ** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE." ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"glwindow.h"
end_include
begin_include
include|#
directive|include
file|<QImage>
end_include
begin_include
include|#
directive|include
file|<QOpenGLTexture>
end_include
begin_include
include|#
directive|include
file|<QOpenGLShaderProgram>
end_include
begin_include
include|#
directive|include
file|<QOpenGLBuffer>
end_include
begin_include
include|#
directive|include
file|<QOpenGLContext>
end_include
begin_include
include|#
directive|include
file|<QOpenGLVertexArrayObject>
end_include
begin_include
include|#
directive|include
file|<QOpenGLExtraFunctions>
end_include
begin_include
include|#
directive|include
file|<QPropertyAnimation>
end_include
begin_include
include|#
directive|include
file|<QPauseAnimation>
end_include
begin_include
include|#
directive|include
file|<QSequentialAnimationGroup>
end_include
begin_include
include|#
directive|include
file|<QTimer>
end_include
begin_constructor
DECL|function|GLWindow
name|GLWindow
operator|::
name|GLWindow
parameter_list|()
member_init_list|:
name|m_texture
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_program
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_vbo
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_vao
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_target
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
member_init_list|,
name|m_uniformsDirty
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|m_r
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_r2
argument_list|(
literal|0
argument_list|)
block|{
name|m_world
operator|.
name|setToIdentity
argument_list|()
expr_stmt|;
name|m_world
operator|.
name|translate
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|m_world
operator|.
name|rotate
argument_list|(
literal|180
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QSequentialAnimationGroup
modifier|*
name|animGroup
init|=
operator|new
name|QSequentialAnimationGroup
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|animGroup
operator|->
name|setLoopCount
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QPropertyAnimation
modifier|*
name|zAnim0
init|=
operator|new
name|QPropertyAnimation
argument_list|(
name|this
argument_list|,
name|QByteArrayLiteral
argument_list|(
literal|"z"
argument_list|)
argument_list|)
decl_stmt|;
name|zAnim0
operator|->
name|setStartValue
argument_list|(
literal|1.5f
argument_list|)
expr_stmt|;
name|zAnim0
operator|->
name|setEndValue
argument_list|(
literal|10.0f
argument_list|)
expr_stmt|;
name|zAnim0
operator|->
name|setDuration
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|animGroup
operator|->
name|addAnimation
argument_list|(
name|zAnim0
argument_list|)
expr_stmt|;
name|QPropertyAnimation
modifier|*
name|zAnim1
init|=
operator|new
name|QPropertyAnimation
argument_list|(
name|this
argument_list|,
name|QByteArrayLiteral
argument_list|(
literal|"z"
argument_list|)
argument_list|)
decl_stmt|;
name|zAnim1
operator|->
name|setStartValue
argument_list|(
literal|10.0f
argument_list|)
expr_stmt|;
name|zAnim1
operator|->
name|setEndValue
argument_list|(
literal|50.0f
argument_list|)
expr_stmt|;
name|zAnim1
operator|->
name|setDuration
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
name|zAnim1
operator|->
name|setEasingCurve
argument_list|(
name|QEasingCurve
operator|::
name|OutElastic
argument_list|)
expr_stmt|;
name|animGroup
operator|->
name|addAnimation
argument_list|(
name|zAnim1
argument_list|)
expr_stmt|;
name|QPropertyAnimation
modifier|*
name|zAnim2
init|=
operator|new
name|QPropertyAnimation
argument_list|(
name|this
argument_list|,
name|QByteArrayLiteral
argument_list|(
literal|"z"
argument_list|)
argument_list|)
decl_stmt|;
name|zAnim2
operator|->
name|setStartValue
argument_list|(
literal|50.0f
argument_list|)
expr_stmt|;
name|zAnim2
operator|->
name|setEndValue
argument_list|(
literal|1.5f
argument_list|)
expr_stmt|;
name|zAnim2
operator|->
name|setDuration
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|animGroup
operator|->
name|addAnimation
argument_list|(
name|zAnim2
argument_list|)
expr_stmt|;
name|animGroup
operator|->
name|start
argument_list|()
expr_stmt|;
name|QPropertyAnimation
modifier|*
name|rAnim
init|=
operator|new
name|QPropertyAnimation
argument_list|(
name|this
argument_list|,
name|QByteArrayLiteral
argument_list|(
literal|"r"
argument_list|)
argument_list|)
decl_stmt|;
name|rAnim
operator|->
name|setStartValue
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
name|rAnim
operator|->
name|setEndValue
argument_list|(
literal|360.0f
argument_list|)
expr_stmt|;
name|rAnim
operator|->
name|setDuration
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|rAnim
operator|->
name|setLoopCount
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rAnim
operator|->
name|start
argument_list|()
expr_stmt|;
name|QTimer
operator|::
name|singleShot
argument_list|(
literal|4000
argument_list|,
name|this
argument_list|,
operator|&
name|GLWindow
operator|::
name|startSecondStage
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~GLWindow
name|GLWindow
operator|::
name|~
name|GLWindow
parameter_list|()
block|{
name|makeCurrent
argument_list|()
expr_stmt|;
operator|delete
name|m_texture
expr_stmt|;
operator|delete
name|m_program
expr_stmt|;
operator|delete
name|m_vbo
expr_stmt|;
operator|delete
name|m_vao
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|startSecondStage
name|void
name|GLWindow
operator|::
name|startSecondStage
parameter_list|()
block|{
name|QPropertyAnimation
modifier|*
name|r2Anim
init|=
operator|new
name|QPropertyAnimation
argument_list|(
name|this
argument_list|,
name|QByteArrayLiteral
argument_list|(
literal|"r2"
argument_list|)
argument_list|)
decl_stmt|;
name|r2Anim
operator|->
name|setStartValue
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
name|r2Anim
operator|->
name|setEndValue
argument_list|(
literal|360.0f
argument_list|)
expr_stmt|;
name|r2Anim
operator|->
name|setDuration
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
name|r2Anim
operator|->
name|setLoopCount
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|r2Anim
operator|->
name|start
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setZ
name|void
name|GLWindow
operator|::
name|setZ
parameter_list|(
name|float
name|v
parameter_list|)
block|{
name|m_eye
operator|.
name|setZ
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|m_uniformsDirty
operator|=
literal|true
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setR
name|void
name|GLWindow
operator|::
name|setR
parameter_list|(
name|float
name|v
parameter_list|)
block|{
name|m_r
operator|=
name|v
expr_stmt|;
name|m_uniformsDirty
operator|=
literal|true
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setR2
name|void
name|GLWindow
operator|::
name|setR2
parameter_list|(
name|float
name|v
parameter_list|)
block|{
name|m_r2
operator|=
name|v
expr_stmt|;
name|m_uniformsDirty
operator|=
literal|true
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|vertexShaderSource
specifier|static
specifier|const
name|char
modifier|*
name|vertexShaderSource
init|=
literal|"layout(location = 0) in vec4 vertex;\n"
literal|"layout(location = 1) in vec3 normal;\n"
literal|"out vec3 vert;\n"
literal|"out vec3 vertNormal;\n"
literal|"out vec3 color;\n"
literal|"uniform mat4 projMatrix;\n"
literal|"uniform mat4 camMatrix;\n"
literal|"uniform mat4 worldMatrix;\n"
literal|"uniform mat4 myMatrix;\n"
literal|"uniform sampler2D sampler;\n"
literal|"void main() {\n"
literal|"   ivec2 pos = ivec2(gl_InstanceID % 32, gl_InstanceID / 32);\n"
literal|"   vec2 t = vec2(float(-16 + pos.x) * 0.8, float(-18 + pos.y) * 0.6);\n"
literal|"   float val = 2.0 * length(texelFetch(sampler, pos, 0).rgb);\n"
literal|"   mat4 wm = myMatrix * mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, t.x, t.y, val, 1) * worldMatrix;\n"
literal|"   color = texelFetch(sampler, pos, 0).rgb * vec3(0.4, 1.0, 0.0);\n"
literal|"   vert = vec3(wm * vertex);\n"
literal|"   vertNormal = mat3(transpose(inverse(wm))) * normal;\n"
literal|"   gl_Position = projMatrix * camMatrix * wm * vertex;\n"
literal|"}\n"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fragmentShaderSource
specifier|static
specifier|const
name|char
modifier|*
name|fragmentShaderSource
init|=
literal|"in highp vec3 vert;\n"
literal|"in highp vec3 vertNormal;\n"
literal|"in highp vec3 color;\n"
literal|"out highp vec4 fragColor;\n"
literal|"uniform highp vec3 lightPos;\n"
literal|"void main() {\n"
literal|"   highp vec3 L = normalize(lightPos - vert);\n"
literal|"   highp float NL = max(dot(normalize(vertNormal), L), 0.0);\n"
literal|"   highp vec3 col = clamp(color * 0.2 + color * 0.8 * NL, 0.0, 1.0);\n"
literal|"   fragColor = vec4(col, 1.0);\n"
literal|"}\n"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|versionedShaderCode
name|QByteArray
name|versionedShaderCode
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|QByteArray
name|versionedSrc
decl_stmt|;
if|if
condition|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
name|versionedSrc
operator|.
name|append
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"#version 300 es\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|versionedSrc
operator|.
name|append
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"#version 330\n"
argument_list|)
argument_list|)
expr_stmt|;
name|versionedSrc
operator|.
name|append
argument_list|(
name|src
argument_list|)
expr_stmt|;
return|return
name|versionedSrc
return|;
block|}
end_function
begin_function
DECL|function|initializeGL
name|void
name|GLWindow
operator|::
name|initializeGL
parameter_list|()
block|{
name|QOpenGLFunctions
modifier|*
name|f
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|functions
argument_list|()
decl_stmt|;
if|if
condition|(
name|m_texture
condition|)
block|{
operator|delete
name|m_texture
expr_stmt|;
name|m_texture
operator|=
literal|0
expr_stmt|;
block|}
name|QImage
name|img
argument_list|(
literal|":/qtlogo.png"
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|img
operator|.
name|isNull
argument_list|()
argument_list|)
expr_stmt|;
name|m_texture
operator|=
operator|new
name|QOpenGLTexture
argument_list|(
name|img
operator|.
name|scaled
argument_list|(
literal|32
argument_list|,
literal|36
argument_list|)
operator|.
name|mirrored
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_program
condition|)
block|{
operator|delete
name|m_program
expr_stmt|;
name|m_program
operator|=
literal|0
expr_stmt|;
block|}
name|m_program
operator|=
operator|new
name|QOpenGLShaderProgram
expr_stmt|;
comment|// Prepend the correct version directive to the sources. The rest is the
comment|// same, thanks to the common GLSL syntax.
name|m_program
operator|->
name|addShaderFromSourceCode
argument_list|(
name|QOpenGLShader
operator|::
name|Vertex
argument_list|,
name|versionedShaderCode
argument_list|(
name|vertexShaderSource
argument_list|)
argument_list|)
expr_stmt|;
name|m_program
operator|->
name|addShaderFromSourceCode
argument_list|(
name|QOpenGLShader
operator|::
name|Fragment
argument_list|,
name|versionedShaderCode
argument_list|(
name|fragmentShaderSource
argument_list|)
argument_list|)
expr_stmt|;
name|m_program
operator|->
name|link
argument_list|()
expr_stmt|;
name|m_projMatrixLoc
operator|=
name|m_program
operator|->
name|uniformLocation
argument_list|(
literal|"projMatrix"
argument_list|)
expr_stmt|;
name|m_camMatrixLoc
operator|=
name|m_program
operator|->
name|uniformLocation
argument_list|(
literal|"camMatrix"
argument_list|)
expr_stmt|;
name|m_worldMatrixLoc
operator|=
name|m_program
operator|->
name|uniformLocation
argument_list|(
literal|"worldMatrix"
argument_list|)
expr_stmt|;
name|m_myMatrixLoc
operator|=
name|m_program
operator|->
name|uniformLocation
argument_list|(
literal|"myMatrix"
argument_list|)
expr_stmt|;
name|m_lightPosLoc
operator|=
name|m_program
operator|->
name|uniformLocation
argument_list|(
literal|"lightPos"
argument_list|)
expr_stmt|;
comment|// Create a VAO. Not strictly required for ES 3, but it is for plain OpenGL.
if|if
condition|(
name|m_vao
condition|)
block|{
operator|delete
name|m_vao
expr_stmt|;
name|m_vao
operator|=
literal|0
expr_stmt|;
block|}
name|m_vao
operator|=
operator|new
name|QOpenGLVertexArrayObject
expr_stmt|;
if|if
condition|(
name|m_vao
operator|->
name|create
argument_list|()
condition|)
name|m_vao
operator|->
name|bind
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_vbo
condition|)
block|{
operator|delete
name|m_vbo
expr_stmt|;
name|m_vbo
operator|=
literal|0
expr_stmt|;
block|}
name|m_program
operator|->
name|bind
argument_list|()
expr_stmt|;
name|m_vbo
operator|=
operator|new
name|QOpenGLBuffer
expr_stmt|;
name|m_vbo
operator|->
name|create
argument_list|()
expr_stmt|;
name|m_vbo
operator|->
name|bind
argument_list|()
expr_stmt|;
name|m_vbo
operator|->
name|allocate
argument_list|(
name|m_logo
operator|.
name|constData
argument_list|()
argument_list|,
name|m_logo
operator|.
name|count
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|glEnableVertexAttribArray
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|f
operator|->
name|glEnableVertexAttribArray
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|f
operator|->
name|glVertexAttribPointer
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
name|GL_FLOAT
argument_list|,
name|GL_FALSE
argument_list|,
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|f
operator|->
name|glVertexAttribPointer
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|,
name|GL_FLOAT
argument_list|,
name|GL_FALSE
argument_list|,
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|GLfloat
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|m_vbo
operator|->
name|release
argument_list|()
expr_stmt|;
name|f
operator|->
name|glEnable
argument_list|(
name|GL_DEPTH_TEST
argument_list|)
expr_stmt|;
name|f
operator|->
name|glEnable
argument_list|(
name|GL_CULL_FACE
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resizeGL
name|void
name|GLWindow
operator|::
name|resizeGL
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|m_proj
operator|.
name|setToIdentity
argument_list|()
expr_stmt|;
name|m_proj
operator|.
name|perspective
argument_list|(
literal|45.0f
argument_list|,
name|GLfloat
argument_list|(
name|w
argument_list|)
operator|/
name|h
argument_list|,
literal|0.01f
argument_list|,
literal|100.0f
argument_list|)
expr_stmt|;
name|m_uniformsDirty
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|paintGL
name|void
name|GLWindow
operator|::
name|paintGL
parameter_list|()
block|{
comment|// Now use QOpenGLExtraFunctions instead of QOpenGLFunctions as we want to
comment|// do more than what GL(ES) 2.0 offers.
name|QOpenGLExtraFunctions
modifier|*
name|f
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|extraFunctions
argument_list|()
decl_stmt|;
name|f
operator|->
name|glClearColor
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|f
operator|->
name|glClear
argument_list|(
name|GL_COLOR_BUFFER_BIT
operator||
name|GL_DEPTH_BUFFER_BIT
argument_list|)
expr_stmt|;
name|m_program
operator|->
name|bind
argument_list|()
expr_stmt|;
name|m_texture
operator|->
name|bind
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_uniformsDirty
condition|)
block|{
name|m_uniformsDirty
operator|=
literal|false
expr_stmt|;
name|QMatrix4x4
name|camera
decl_stmt|;
name|camera
operator|.
name|lookAt
argument_list|(
name|m_eye
argument_list|,
name|m_eye
operator|+
name|m_target
argument_list|,
name|QVector3D
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|m_program
operator|->
name|setUniformValue
argument_list|(
name|m_projMatrixLoc
argument_list|,
name|m_proj
argument_list|)
expr_stmt|;
name|m_program
operator|->
name|setUniformValue
argument_list|(
name|m_camMatrixLoc
argument_list|,
name|camera
argument_list|)
expr_stmt|;
name|QMatrix4x4
name|wm
init|=
name|m_world
decl_stmt|;
name|wm
operator|.
name|rotate
argument_list|(
name|m_r
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_program
operator|->
name|setUniformValue
argument_list|(
name|m_worldMatrixLoc
argument_list|,
name|wm
argument_list|)
expr_stmt|;
name|QMatrix4x4
name|mm
decl_stmt|;
name|mm
operator|.
name|setToIdentity
argument_list|()
expr_stmt|;
name|mm
operator|.
name|rotate
argument_list|(
operator|-
name|m_r2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_program
operator|->
name|setUniformValue
argument_list|(
name|m_myMatrixLoc
argument_list|,
name|mm
argument_list|)
expr_stmt|;
name|m_program
operator|->
name|setUniformValue
argument_list|(
name|m_lightPosLoc
argument_list|,
name|QVector3D
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|70
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Now call a function introduced in OpenGL 3.1 / OpenGL ES 3.0. We
comment|// requested a 3.3 or ES 3.0 context, so we know this will work.
name|f
operator|->
name|glDrawArraysInstanced
argument_list|(
name|GL_TRIANGLES
argument_list|,
literal|0
argument_list|,
name|m_logo
operator|.
name|vertexCount
argument_list|()
argument_list|,
literal|32
operator|*
literal|36
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
