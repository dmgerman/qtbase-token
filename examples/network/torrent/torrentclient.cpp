begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the examples of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:BSD$ ** You may use this file under the terms of the BSD license as follows: ** ** "Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions are ** met: **   * Redistributions of source code must retain the above copyright **     notice, this list of conditions and the following disclaimer. **   * Redistributions in binary form must reproduce the above copyright **     notice, this list of conditions and the following disclaimer in **     the documentation and/or other materials provided with the **     distribution. **   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names **     of its contributors may be used to endorse or promote products derived **     from this software without specific prior written permission. ** ** ** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR ** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE." ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"connectionmanager.h"
end_include
begin_include
include|#
directive|include
file|"filemanager.h"
end_include
begin_include
include|#
directive|include
file|"metainfo.h"
end_include
begin_include
include|#
directive|include
file|"torrentclient.h"
end_include
begin_include
include|#
directive|include
file|"torrentserver.h"
end_include
begin_include
include|#
directive|include
file|"trackerclient.h"
end_include
begin_include
include|#
directive|include
file|"peerwireclient.h"
end_include
begin_include
include|#
directive|include
file|"ratecontroller.h"
end_include
begin_include
include|#
directive|include
file|<QtCore>
end_include
begin_include
include|#
directive|include
file|<QNetworkInterface>
end_include
begin_comment
comment|// These constants could also be configurable by the user.
end_comment
begin_decl_stmt
DECL|variable|ServerMinPort
specifier|static
specifier|const
name|int
name|ServerMinPort
init|=
literal|6881
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ServerMaxPort
specifier|static
specifier|const
name|int
name|ServerMaxPort
init|=
comment|/* 6889 */
literal|7000
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|BlockSize
specifier|static
specifier|const
name|int
name|BlockSize
init|=
literal|16384
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|MaxBlocksInProgress
specifier|static
specifier|const
name|int
name|MaxBlocksInProgress
init|=
literal|5
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|MaxBlocksInMultiMode
specifier|static
specifier|const
name|int
name|MaxBlocksInMultiMode
init|=
literal|2
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|MaxConnectionPerPeer
specifier|static
specifier|const
name|int
name|MaxConnectionPerPeer
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|RateControlWindowLength
specifier|static
specifier|const
name|int
name|RateControlWindowLength
init|=
literal|10
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|RateControlTimerDelay
specifier|static
specifier|const
name|int
name|RateControlTimerDelay
init|=
literal|1000
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|MinimumTimeBeforeRevisit
specifier|static
specifier|const
name|int
name|MinimumTimeBeforeRevisit
init|=
literal|30
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|MaxUploads
specifier|static
specifier|const
name|int
name|MaxUploads
init|=
literal|4
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|UploadScheduleInterval
specifier|static
specifier|const
name|int
name|UploadScheduleInterval
init|=
literal|10000
decl_stmt|;
end_decl_stmt
begin_class
DECL|class|TorrentPiece
class|class
name|TorrentPiece
block|{
public|public:
DECL|member|index
name|int
name|index
decl_stmt|;
DECL|member|length
name|int
name|length
decl_stmt|;
DECL|member|completedBlocks
name|QBitArray
name|completedBlocks
decl_stmt|;
DECL|member|requestedBlocks
name|QBitArray
name|requestedBlocks
decl_stmt|;
DECL|member|inProgress
name|bool
name|inProgress
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|TorrentClientPrivate
class|class
name|TorrentClientPrivate
block|{
public|public:
name|TorrentClientPrivate
parameter_list|(
name|TorrentClient
modifier|*
name|qq
parameter_list|)
constructor_decl|;
comment|// State / error
name|void
name|setError
parameter_list|(
name|TorrentClient
operator|::
name|Error
name|error
parameter_list|)
function_decl|;
name|void
name|setState
parameter_list|(
name|TorrentClient
operator|::
name|State
name|state
parameter_list|)
function_decl|;
DECL|member|error
name|TorrentClient
operator|::
name|Error
name|error
decl_stmt|;
DECL|member|state
name|TorrentClient
operator|::
name|State
name|state
decl_stmt|;
DECL|member|errorString
name|QString
name|errorString
decl_stmt|;
DECL|member|stateString
name|QString
name|stateString
decl_stmt|;
comment|// Where to save data
DECL|member|destinationFolder
name|QString
name|destinationFolder
decl_stmt|;
DECL|member|metaInfo
name|MetaInfo
name|metaInfo
decl_stmt|;
comment|// Announce tracker and file manager
DECL|member|peerId
name|QByteArray
name|peerId
decl_stmt|;
DECL|member|infoHash
name|QByteArray
name|infoHash
decl_stmt|;
DECL|member|trackerClient
name|TrackerClient
name|trackerClient
decl_stmt|;
DECL|member|fileManager
name|FileManager
name|fileManager
decl_stmt|;
comment|// Connections
DECL|member|connections
name|QList
argument_list|<
name|PeerWireClient
modifier|*
argument_list|>
name|connections
decl_stmt|;
DECL|member|peers
name|QList
argument_list|<
name|TorrentPeer
modifier|*
argument_list|>
name|peers
decl_stmt|;
DECL|member|schedulerCalled
name|bool
name|schedulerCalled
decl_stmt|;
name|void
name|callScheduler
parameter_list|()
function_decl|;
DECL|member|connectingToClients
name|bool
name|connectingToClients
decl_stmt|;
name|void
name|callPeerConnector
parameter_list|()
function_decl|;
DECL|member|uploadScheduleTimer
name|int
name|uploadScheduleTimer
decl_stmt|;
comment|// Pieces
DECL|member|readIds
name|QMap
argument_list|<
name|int
argument_list|,
name|PeerWireClient
modifier|*
argument_list|>
name|readIds
decl_stmt|;
DECL|member|payloads
name|QMultiMap
argument_list|<
name|PeerWireClient
modifier|*
argument_list|,
name|TorrentPiece
modifier|*
argument_list|>
name|payloads
decl_stmt|;
DECL|member|pendingPieces
name|QMap
argument_list|<
name|int
argument_list|,
name|TorrentPiece
modifier|*
argument_list|>
name|pendingPieces
decl_stmt|;
DECL|member|completedPieces
name|QBitArray
name|completedPieces
decl_stmt|;
DECL|member|incompletePieces
name|QBitArray
name|incompletePieces
decl_stmt|;
DECL|member|pieceCount
name|int
name|pieceCount
decl_stmt|;
comment|// Progress
DECL|member|lastProgressValue
name|int
name|lastProgressValue
decl_stmt|;
DECL|member|downloadedBytes
name|qint64
name|downloadedBytes
decl_stmt|;
DECL|member|uploadedBytes
name|qint64
name|uploadedBytes
decl_stmt|;
DECL|member|downloadRate
name|int
name|downloadRate
index|[
name|RateControlWindowLength
index|]
decl_stmt|;
DECL|member|uploadRate
name|int
name|uploadRate
index|[
name|RateControlWindowLength
index|]
decl_stmt|;
DECL|member|transferRateTimer
name|int
name|transferRateTimer
decl_stmt|;
DECL|member|q
name|TorrentClient
modifier|*
name|q
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|TorrentClientPrivate
name|TorrentClientPrivate
operator|::
name|TorrentClientPrivate
parameter_list|(
name|TorrentClient
modifier|*
name|qq
parameter_list|)
member_init_list|:
name|trackerClient
argument_list|(
name|qq
argument_list|)
member_init_list|,
name|q
argument_list|(
name|qq
argument_list|)
block|{
name|error
operator|=
name|TorrentClient
operator|::
name|UnknownError
expr_stmt|;
name|state
operator|=
name|TorrentClient
operator|::
name|Idle
expr_stmt|;
name|errorString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Unknown error"
argument_list|)
expr_stmt|;
name|stateString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Idle"
argument_list|)
expr_stmt|;
name|schedulerCalled
operator|=
literal|false
expr_stmt|;
name|connectingToClients
operator|=
literal|false
expr_stmt|;
name|uploadScheduleTimer
operator|=
literal|0
expr_stmt|;
name|lastProgressValue
operator|=
operator|-
literal|1
expr_stmt|;
name|pieceCount
operator|=
literal|0
expr_stmt|;
name|downloadedBytes
operator|=
literal|0
expr_stmt|;
name|uploadedBytes
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|downloadRate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|downloadRate
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|uploadRate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uploadRate
argument_list|)
argument_list|)
expr_stmt|;
name|transferRateTimer
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|setError
name|void
name|TorrentClientPrivate
operator|::
name|setError
parameter_list|(
name|TorrentClient
operator|::
name|Error
name|errorCode
parameter_list|)
block|{
name|this
operator|->
name|error
operator|=
name|errorCode
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|TorrentClient
operator|::
name|UnknownError
case|:
name|errorString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Unknown error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TorrentClient
operator|::
name|TorrentParseError
case|:
name|errorString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Invalid torrent data"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TorrentClient
operator|::
name|InvalidTrackerError
case|:
name|errorString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Unable to connect to tracker"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TorrentClient
operator|::
name|FileError
case|:
name|errorString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"File error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TorrentClient
operator|::
name|ServerError
case|:
name|errorString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Unable to initialize server"
argument_list|)
expr_stmt|;
break|break;
block|}
emit|emit
name|q
operator|->
name|error
argument_list|(
name|errorCode
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|setState
name|void
name|TorrentClientPrivate
operator|::
name|setState
parameter_list|(
name|TorrentClient
operator|::
name|State
name|state
parameter_list|)
block|{
name|this
operator|->
name|state
operator|=
name|state
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|TorrentClient
operator|::
name|Idle
case|:
name|stateString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Idle"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TorrentClient
operator|::
name|Paused
case|:
name|stateString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Paused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TorrentClient
operator|::
name|Stopping
case|:
name|stateString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Stopping"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TorrentClient
operator|::
name|Preparing
case|:
name|stateString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Preparing"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TorrentClient
operator|::
name|Searching
case|:
name|stateString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Searching"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TorrentClient
operator|::
name|Connecting
case|:
name|stateString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Connecting"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TorrentClient
operator|::
name|WarmingUp
case|:
name|stateString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Warming up"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TorrentClient
operator|::
name|Downloading
case|:
name|stateString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Downloading"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TorrentClient
operator|::
name|Endgame
case|:
name|stateString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Finishing"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TorrentClient
operator|::
name|Seeding
case|:
name|stateString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|TorrentClient
argument_list|,
literal|"Seeding"
argument_list|)
expr_stmt|;
break|break;
block|}
emit|emit
name|q
operator|->
name|stateChanged
argument_list|(
name|state
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|callScheduler
name|void
name|TorrentClientPrivate
operator|::
name|callScheduler
parameter_list|()
block|{
if|if
condition|(
operator|!
name|schedulerCalled
condition|)
block|{
name|schedulerCalled
operator|=
literal|true
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"scheduleDownloads"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|callPeerConnector
name|void
name|TorrentClientPrivate
operator|::
name|callPeerConnector
parameter_list|()
block|{
if|if
condition|(
operator|!
name|connectingToClients
condition|)
block|{
name|connectingToClients
operator|=
literal|true
expr_stmt|;
name|QTimer
operator|::
name|singleShot
argument_list|(
literal|10000
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|connectToPeers
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_constructor
DECL|function|TorrentClient
name|TorrentClient
operator|::
name|TorrentClient
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|d
argument_list|(
operator|new
name|TorrentClientPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
comment|// Connect the file manager
name|connect
argument_list|(
operator|&
name|d
operator|->
name|fileManager
argument_list|,
name|SIGNAL
argument_list|(
name|dataRead
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|QByteArray
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|sendToPeer
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|QByteArray
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|fileManager
argument_list|,
name|SIGNAL
argument_list|(
name|verificationProgress
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|updateProgress
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|fileManager
argument_list|,
name|SIGNAL
argument_list|(
name|verificationDone
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|fullVerificationDone
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|fileManager
argument_list|,
name|SIGNAL
argument_list|(
name|pieceVerified
argument_list|(
name|int
argument_list|,
name|bool
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|pieceVerified
argument_list|(
name|int
argument_list|,
name|bool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|fileManager
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|handleFileError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Connect the tracker client
name|connect
argument_list|(
operator|&
name|d
operator|->
name|trackerClient
argument_list|,
name|SIGNAL
argument_list|(
name|peerListUpdated
argument_list|(
name|QList
argument_list|<
name|TorrentPeer
argument_list|>
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|addToPeerList
argument_list|(
name|QList
argument_list|<
name|TorrentPeer
argument_list|>
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|trackerClient
argument_list|,
name|SIGNAL
argument_list|(
name|stopped
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|stopped
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~TorrentClient
name|TorrentClient
operator|::
name|~
name|TorrentClient
parameter_list|()
block|{
name|qDeleteAll
argument_list|(
name|d
operator|->
name|peers
argument_list|)
expr_stmt|;
name|qDeleteAll
argument_list|(
name|d
operator|->
name|pendingPieces
argument_list|)
expr_stmt|;
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|setTorrent
name|bool
name|TorrentClient
operator|::
name|setTorrent
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
operator|||
operator|!
name|setTorrent
argument_list|(
name|file
operator|.
name|readAll
argument_list|()
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|TorrentParseError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setTorrent
name|bool
name|TorrentClient
operator|::
name|setTorrent
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|torrentData
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|metaInfo
operator|.
name|parse
argument_list|(
name|torrentData
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|TorrentParseError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Calculate SHA1 hash of the "info" section in the torrent
name|QByteArray
name|infoValue
init|=
name|d
operator|->
name|metaInfo
operator|.
name|infoValue
argument_list|()
decl_stmt|;
name|d
operator|->
name|infoHash
operator|=
name|QCryptographicHash
operator|::
name|hash
argument_list|(
name|infoValue
argument_list|,
name|QCryptographicHash
operator|::
name|Sha1
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|metaInfo
name|MetaInfo
name|TorrentClient
operator|::
name|metaInfo
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|metaInfo
return|;
block|}
end_function
begin_function
DECL|function|setDestinationFolder
name|void
name|TorrentClient
operator|::
name|setDestinationFolder
parameter_list|(
specifier|const
name|QString
modifier|&
name|directory
parameter_list|)
block|{
name|d
operator|->
name|destinationFolder
operator|=
name|directory
expr_stmt|;
block|}
end_function
begin_function
DECL|function|destinationFolder
name|QString
name|TorrentClient
operator|::
name|destinationFolder
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|destinationFolder
return|;
block|}
end_function
begin_function
DECL|function|setDumpedState
name|void
name|TorrentClient
operator|::
name|setDumpedState
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|dumpedState
parameter_list|)
block|{
comment|// Recover partially completed pieces
name|QDataStream
name|stream
argument_list|(
name|dumpedState
argument_list|)
decl_stmt|;
name|quint16
name|version
init|=
literal|0
decl_stmt|;
name|stream
operator|>>
name|version
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|2
condition|)
return|return;
name|stream
operator|>>
name|d
operator|->
name|completedPieces
expr_stmt|;
while|while
condition|(
operator|!
name|stream
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|int
name|index
decl_stmt|;
name|int
name|length
decl_stmt|;
name|QBitArray
name|completed
decl_stmt|;
name|stream
operator|>>
name|index
operator|>>
name|length
operator|>>
name|completed
expr_stmt|;
if|if
condition|(
name|stream
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
block|{
name|d
operator|->
name|completedPieces
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
block|}
name|TorrentPiece
modifier|*
name|piece
init|=
operator|new
name|TorrentPiece
decl_stmt|;
name|piece
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|piece
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|piece
operator|->
name|completedBlocks
operator|=
name|completed
expr_stmt|;
name|piece
operator|->
name|requestedBlocks
operator|.
name|resize
argument_list|(
name|completed
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|piece
operator|->
name|inProgress
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|pendingPieces
index|[
name|index
index|]
operator|=
name|piece
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|dumpedState
name|QByteArray
name|TorrentClient
operator|::
name|dumpedState
parameter_list|()
specifier|const
block|{
name|QByteArray
name|partials
decl_stmt|;
name|QDataStream
name|stream
argument_list|(
operator|&
name|partials
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|stream
operator|<<
name|quint16
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|stream
operator|<<
name|d
operator|->
name|completedPieces
expr_stmt|;
comment|// Save the state of all partially downloaded pieces into a format
comment|// suitable for storing in settings.
name|QMap
argument_list|<
name|int
argument_list|,
name|TorrentPiece
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|pendingPieces
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|pendingPieces
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|TorrentPiece
modifier|*
name|piece
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|blocksLeftForPiece
argument_list|(
name|piece
argument_list|)
operator|>
literal|0
operator|&&
name|blocksLeftForPiece
argument_list|(
name|piece
argument_list|)
operator|<
name|piece
operator|->
name|completedBlocks
operator|.
name|size
argument_list|()
condition|)
block|{
name|stream
operator|<<
name|piece
operator|->
name|index
expr_stmt|;
name|stream
operator|<<
name|piece
operator|->
name|length
expr_stmt|;
name|stream
operator|<<
name|piece
operator|->
name|completedBlocks
expr_stmt|;
block|}
operator|++
name|it
expr_stmt|;
block|}
return|return
name|partials
return|;
block|}
end_function
begin_function
DECL|function|progress
name|qint64
name|TorrentClient
operator|::
name|progress
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|lastProgressValue
return|;
block|}
end_function
begin_function
DECL|function|setDownloadedBytes
name|void
name|TorrentClient
operator|::
name|setDownloadedBytes
parameter_list|(
name|qint64
name|bytes
parameter_list|)
block|{
name|d
operator|->
name|downloadedBytes
operator|=
name|bytes
expr_stmt|;
block|}
end_function
begin_function
DECL|function|downloadedBytes
name|qint64
name|TorrentClient
operator|::
name|downloadedBytes
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|downloadedBytes
return|;
block|}
end_function
begin_function
DECL|function|setUploadedBytes
name|void
name|TorrentClient
operator|::
name|setUploadedBytes
parameter_list|(
name|qint64
name|bytes
parameter_list|)
block|{
name|d
operator|->
name|uploadedBytes
operator|=
name|bytes
expr_stmt|;
block|}
end_function
begin_function
DECL|function|uploadedBytes
name|qint64
name|TorrentClient
operator|::
name|uploadedBytes
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|uploadedBytes
return|;
block|}
end_function
begin_function
DECL|function|connectedPeerCount
name|int
name|TorrentClient
operator|::
name|connectedPeerCount
parameter_list|()
specifier|const
block|{
name|int
name|tmp
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
name|PeerWireClient
modifier|*
name|client
decl|,
name|d
operator|->
name|connections
control|)
block|{
if|if
condition|(
name|client
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
operator|++
name|tmp
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function
begin_function
DECL|function|seedCount
name|int
name|TorrentClient
operator|::
name|seedCount
parameter_list|()
specifier|const
block|{
name|int
name|tmp
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
name|PeerWireClient
modifier|*
name|client
decl|,
name|d
operator|->
name|connections
control|)
block|{
if|if
condition|(
name|client
operator|->
name|availablePieces
argument_list|()
operator|.
name|count
argument_list|(
literal|true
argument_list|)
operator|==
name|d
operator|->
name|pieceCount
condition|)
operator|++
name|tmp
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function
begin_function
DECL|function|state
name|TorrentClient
operator|::
name|State
name|TorrentClient
operator|::
name|state
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|state
return|;
block|}
end_function
begin_function
DECL|function|stateString
name|QString
name|TorrentClient
operator|::
name|stateString
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|stateString
return|;
block|}
end_function
begin_function
DECL|function|error
name|TorrentClient
operator|::
name|Error
name|TorrentClient
operator|::
name|error
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|error
return|;
block|}
end_function
begin_function
DECL|function|errorString
name|QString
name|TorrentClient
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|errorString
return|;
block|}
end_function
begin_function
DECL|function|peerId
name|QByteArray
name|TorrentClient
operator|::
name|peerId
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|peerId
return|;
block|}
end_function
begin_function
DECL|function|infoHash
name|QByteArray
name|TorrentClient
operator|::
name|infoHash
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|infoHash
return|;
block|}
end_function
begin_function
DECL|function|start
name|void
name|TorrentClient
operator|::
name|start
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|Idle
condition|)
return|return;
name|TorrentServer
operator|::
name|instance
argument_list|()
operator|->
name|addClient
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Initialize the file manager
name|d
operator|->
name|setState
argument_list|(
name|Preparing
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileManager
operator|.
name|setMetaInfo
argument_list|(
name|d
operator|->
name|metaInfo
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileManager
operator|.
name|setDestinationFolder
argument_list|(
name|d
operator|->
name|destinationFolder
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileManager
operator|.
name|setCompletedPieces
argument_list|(
name|d
operator|->
name|completedPieces
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileManager
operator|.
name|start
argument_list|(
name|QThread
operator|::
name|LowestPriority
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileManager
operator|.
name|startDataVerification
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stop
name|void
name|TorrentClient
operator|::
name|stop
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Stopping
condition|)
return|return;
name|TorrentServer
operator|::
name|instance
argument_list|()
operator|->
name|removeClient
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Update the state
name|State
name|oldState
init|=
name|d
operator|->
name|state
decl_stmt|;
name|d
operator|->
name|setState
argument_list|(
name|Stopping
argument_list|)
expr_stmt|;
comment|// Stop the timer
if|if
condition|(
name|d
operator|->
name|transferRateTimer
condition|)
block|{
name|killTimer
argument_list|(
name|d
operator|->
name|transferRateTimer
argument_list|)
expr_stmt|;
name|d
operator|->
name|transferRateTimer
operator|=
literal|0
expr_stmt|;
block|}
comment|// Abort all existing connections
foreach|foreach
control|(
name|PeerWireClient
modifier|*
name|client
decl|,
name|d
operator|->
name|connections
control|)
block|{
name|RateController
operator|::
name|instance
argument_list|()
operator|->
name|removeSocket
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|ConnectionManager
operator|::
name|instance
argument_list|()
operator|->
name|removeConnection
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|client
operator|->
name|abort
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|connections
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Perhaps stop the tracker
if|if
condition|(
name|oldState
operator|>
name|Preparing
condition|)
block|{
name|d
operator|->
name|trackerClient
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|setState
argument_list|(
name|Idle
argument_list|)
expr_stmt|;
emit|emit
name|stopped
argument_list|()
emit|;
block|}
block|}
end_function
begin_function
DECL|function|setPaused
name|void
name|TorrentClient
operator|::
name|setPaused
parameter_list|(
name|bool
name|paused
parameter_list|)
block|{
if|if
condition|(
name|paused
condition|)
block|{
comment|// Abort all connections, and set the max number of
comment|// connections to 0. Keep the list of peers, so we can quickly
comment|// resume later.
name|d
operator|->
name|setState
argument_list|(
name|Paused
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|PeerWireClient
modifier|*
name|client
decl|,
name|d
operator|->
name|connections
control|)
name|client
operator|->
name|abort
argument_list|()
expr_stmt|;
name|d
operator|->
name|connections
operator|.
name|clear
argument_list|()
expr_stmt|;
name|TorrentServer
operator|::
name|instance
argument_list|()
operator|->
name|removeClient
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Restore the max number of connections, and start the peer
comment|// connector. We should also quickly start receiving incoming
comment|// connections.
name|d
operator|->
name|setState
argument_list|(
name|d
operator|->
name|completedPieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
operator|==
name|d
operator|->
name|fileManager
operator|.
name|pieceCount
argument_list|()
condition|?
name|Seeding
else|:
name|Searching
argument_list|)
expr_stmt|;
name|connectToPeers
argument_list|()
expr_stmt|;
name|TorrentServer
operator|::
name|instance
argument_list|()
operator|->
name|addClient
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|timerEvent
name|void
name|TorrentClient
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|uploadScheduleTimer
condition|)
block|{
comment|// Update the state of who's choked and who's not
name|scheduleUploads
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|!=
name|d
operator|->
name|transferRateTimer
condition|)
block|{
name|QObject
operator|::
name|timerEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Calculate average upload/download rate
name|qint64
name|uploadBytesPerSecond
init|=
literal|0
decl_stmt|;
name|qint64
name|downloadBytesPerSecond
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RateControlWindowLength
condition|;
operator|++
name|i
control|)
block|{
name|uploadBytesPerSecond
operator|+=
name|d
operator|->
name|uploadRate
index|[
name|i
index|]
expr_stmt|;
name|downloadBytesPerSecond
operator|+=
name|d
operator|->
name|downloadRate
index|[
name|i
index|]
expr_stmt|;
block|}
name|uploadBytesPerSecond
operator|/=
name|qint64
argument_list|(
name|RateControlWindowLength
argument_list|)
expr_stmt|;
name|downloadBytesPerSecond
operator|/=
name|qint64
argument_list|(
name|RateControlWindowLength
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|RateControlWindowLength
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|d
operator|->
name|uploadRate
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|d
operator|->
name|uploadRate
index|[
name|i
index|]
expr_stmt|;
name|d
operator|->
name|downloadRate
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|d
operator|->
name|downloadRate
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
operator|->
name|uploadRate
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|downloadRate
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
emit|emit
name|uploadRateUpdated
argument_list|(
name|int
argument_list|(
name|uploadBytesPerSecond
argument_list|)
argument_list|)
emit|;
emit|emit
name|downloadRateUpdated
argument_list|(
name|int
argument_list|(
name|downloadBytesPerSecond
argument_list|)
argument_list|)
emit|;
comment|// Stop the timer if there is no activity.
if|if
condition|(
name|downloadBytesPerSecond
operator|==
literal|0
operator|&&
name|uploadBytesPerSecond
operator|==
literal|0
condition|)
block|{
name|killTimer
argument_list|(
name|d
operator|->
name|transferRateTimer
argument_list|)
expr_stmt|;
name|d
operator|->
name|transferRateTimer
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|sendToPeer
name|void
name|TorrentClient
operator|::
name|sendToPeer
parameter_list|(
name|int
name|readId
parameter_list|,
name|int
name|pieceIndex
parameter_list|,
name|int
name|begin
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
comment|// Send the requested block to the peer if the client connection
comment|// still exists; otherwise do nothing. This slot is called by the
comment|// file manager after it has read a block of data.
name|PeerWireClient
modifier|*
name|client
init|=
name|d
operator|->
name|readIds
operator|.
name|value
argument_list|(
name|readId
argument_list|)
decl_stmt|;
if|if
condition|(
name|client
condition|)
block|{
if|if
condition|(
operator|(
name|client
operator|->
name|peerWireState
argument_list|()
operator|&
name|PeerWireClient
operator|::
name|ChokingPeer
operator|)
operator|==
literal|0
condition|)
name|client
operator|->
name|sendBlock
argument_list|(
name|pieceIndex
argument_list|,
name|begin
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|readIds
operator|.
name|remove
argument_list|(
name|readId
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fullVerificationDone
name|void
name|TorrentClient
operator|::
name|fullVerificationDone
parameter_list|()
block|{
comment|// Update our list of completed and incomplete pieces.
name|d
operator|->
name|completedPieces
operator|=
name|d
operator|->
name|fileManager
operator|.
name|completedPieces
argument_list|()
expr_stmt|;
name|d
operator|->
name|incompletePieces
operator|.
name|resize
argument_list|(
name|d
operator|->
name|completedPieces
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|pieceCount
operator|=
name|d
operator|->
name|completedPieces
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|fileManager
operator|.
name|pieceCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|completedPieces
operator|.
name|testBit
argument_list|(
name|i
argument_list|)
condition|)
name|d
operator|->
name|incompletePieces
operator|.
name|setBit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|updateProgress
argument_list|()
expr_stmt|;
comment|// If the checksums show that what the dumped state thought was
comment|// partial was in fact complete, then we trust the checksums.
name|QMap
argument_list|<
name|int
argument_list|,
name|TorrentPiece
modifier|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|pendingPieces
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|pendingPieces
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|completedPieces
operator|.
name|testBit
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
condition|)
name|it
operator|=
name|d
operator|->
name|pendingPieces
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
else|else
operator|++
name|it
expr_stmt|;
block|}
name|d
operator|->
name|uploadScheduleTimer
operator|=
name|startTimer
argument_list|(
name|UploadScheduleInterval
argument_list|)
expr_stmt|;
comment|// Start the server
name|TorrentServer
modifier|*
name|server
init|=
name|TorrentServer
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|server
operator|->
name|isListening
argument_list|()
condition|)
block|{
comment|// Set up the peer wire server
for|for
control|(
name|int
name|i
init|=
name|ServerMinPort
init|;
name|i
operator|<=
name|ServerMaxPort
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|server
operator|->
name|listen
argument_list|(
name|QHostAddress
operator|::
name|Any
argument_list|,
name|i
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|server
operator|->
name|isListening
argument_list|()
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|ServerError
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|d
operator|->
name|setState
argument_list|(
name|d
operator|->
name|completedPieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
operator|==
name|d
operator|->
name|pieceCount
condition|?
name|Seeding
else|:
name|Searching
argument_list|)
expr_stmt|;
comment|// Start the tracker client
name|d
operator|->
name|trackerClient
operator|.
name|start
argument_list|(
name|d
operator|->
name|metaInfo
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pieceVerified
name|void
name|TorrentClient
operator|::
name|pieceVerified
parameter_list|(
name|int
name|pieceIndex
parameter_list|,
name|bool
name|ok
parameter_list|)
block|{
name|TorrentPiece
modifier|*
name|piece
init|=
name|d
operator|->
name|pendingPieces
operator|.
name|value
argument_list|(
name|pieceIndex
argument_list|)
decl_stmt|;
comment|// Remove this piece from all payloads
name|QMultiMap
argument_list|<
name|PeerWireClient
modifier|*
argument_list|,
name|TorrentPiece
modifier|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|payloads
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|payloads
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|index
operator|==
name|pieceIndex
condition|)
name|it
operator|=
name|d
operator|->
name|payloads
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
else|else
operator|++
name|it
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
comment|// If a piece did not pass the SHA1 check, we'll simply clear
comment|// its state, and the scheduler will re-request it
name|piece
operator|->
name|inProgress
operator|=
literal|false
expr_stmt|;
name|piece
operator|->
name|completedBlocks
operator|.
name|fill
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|piece
operator|->
name|requestedBlocks
operator|.
name|fill
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|callScheduler
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Update the peer list so we know who's still interesting.
foreach|foreach
control|(
name|TorrentPeer
modifier|*
name|peer
decl|,
name|d
operator|->
name|peers
control|)
block|{
if|if
condition|(
operator|!
name|peer
operator|->
name|interesting
condition|)
continue|continue;
name|bool
name|interesting
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|pieceCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|peer
operator|->
name|pieces
operator|.
name|testBit
argument_list|(
name|i
argument_list|)
operator|&&
name|d
operator|->
name|incompletePieces
operator|.
name|testBit
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|interesting
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
name|peer
operator|->
name|interesting
operator|=
name|interesting
expr_stmt|;
block|}
comment|// Delete the piece and update our structures.
operator|delete
name|piece
expr_stmt|;
name|d
operator|->
name|pendingPieces
operator|.
name|remove
argument_list|(
name|pieceIndex
argument_list|)
expr_stmt|;
name|d
operator|->
name|completedPieces
operator|.
name|setBit
argument_list|(
name|pieceIndex
argument_list|)
expr_stmt|;
name|d
operator|->
name|incompletePieces
operator|.
name|clearBit
argument_list|(
name|pieceIndex
argument_list|)
expr_stmt|;
comment|// Notify connected peers.
foreach|foreach
control|(
name|PeerWireClient
modifier|*
name|client
decl|,
name|d
operator|->
name|connections
control|)
block|{
if|if
condition|(
name|client
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
operator|&&
operator|!
name|client
operator|->
name|availablePieces
argument_list|()
operator|.
name|testBit
argument_list|(
name|pieceIndex
argument_list|)
condition|)
block|{
name|client
operator|->
name|sendPieceNotification
argument_list|(
name|pieceIndex
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Notify the tracker if we've entered Seeding status; otherwise
comment|// call the scheduler.
name|int
name|completed
init|=
name|d
operator|->
name|completedPieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|completed
operator|==
name|d
operator|->
name|pieceCount
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|Seeding
condition|)
block|{
name|d
operator|->
name|setState
argument_list|(
name|Seeding
argument_list|)
expr_stmt|;
name|d
operator|->
name|trackerClient
operator|.
name|startSeeding
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|completed
operator|==
literal|1
condition|)
name|d
operator|->
name|setState
argument_list|(
name|Downloading
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|incompletePieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
operator|<
literal|5
operator|&&
name|d
operator|->
name|pendingPieces
operator|.
name|size
argument_list|()
operator|>
name|d
operator|->
name|incompletePieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
condition|)
name|d
operator|->
name|setState
argument_list|(
name|Endgame
argument_list|)
expr_stmt|;
name|d
operator|->
name|callScheduler
argument_list|()
expr_stmt|;
block|}
name|updateProgress
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleFileError
name|void
name|TorrentClient
operator|::
name|handleFileError
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Paused
condition|)
return|return;
name|setPaused
argument_list|(
literal|true
argument_list|)
expr_stmt|;
emit|emit
name|error
argument_list|(
name|FileError
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|connectToPeers
name|void
name|TorrentClient
operator|::
name|connectToPeers
parameter_list|()
block|{
name|d
operator|->
name|connectingToClients
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Stopping
operator|||
name|d
operator|->
name|state
operator|==
name|Idle
operator|||
name|d
operator|->
name|state
operator|==
name|Paused
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Searching
condition|)
name|d
operator|->
name|setState
argument_list|(
name|Connecting
argument_list|)
expr_stmt|;
comment|// Find the list of peers we are not currently connected to, where
comment|// the more interesting peers are listed more than once.
name|QList
argument_list|<
name|TorrentPeer
modifier|*
argument_list|>
name|weighedPeers
init|=
name|weighedFreePeers
argument_list|()
decl_stmt|;
comment|// Start as many connections as we can
while|while
condition|(
operator|!
name|weighedPeers
operator|.
name|isEmpty
argument_list|()
operator|&&
name|ConnectionManager
operator|::
name|instance
argument_list|()
operator|->
name|canAddConnection
argument_list|()
operator|&&
operator|(
name|qrand
argument_list|()
operator|%
operator|(
name|ConnectionManager
operator|::
name|instance
argument_list|()
operator|->
name|maxConnections
argument_list|()
operator|/
literal|2
operator|)
operator|)
condition|)
block|{
name|PeerWireClient
modifier|*
name|client
init|=
operator|new
name|PeerWireClient
argument_list|(
name|ConnectionManager
operator|::
name|instance
argument_list|()
operator|->
name|clientId
argument_list|()
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|RateController
operator|::
name|instance
argument_list|()
operator|->
name|addSocket
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|ConnectionManager
operator|::
name|instance
argument_list|()
operator|->
name|addConnection
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|initializeConnection
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|d
operator|->
name|connections
operator|<<
name|client
expr_stmt|;
comment|// Pick a random peer from the list of weighed peers.
name|TorrentPeer
modifier|*
name|peer
init|=
name|weighedPeers
operator|.
name|takeAt
argument_list|(
name|qrand
argument_list|()
operator|%
name|weighedPeers
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|weighedPeers
operator|.
name|removeAll
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|connectStart
operator|=
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|toTime_t
argument_list|()
expr_stmt|;
name|peer
operator|->
name|lastVisited
operator|=
name|peer
operator|->
name|connectStart
expr_stmt|;
comment|// Connect to the peer.
name|client
operator|->
name|setPeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|client
operator|->
name|connectToHost
argument_list|(
name|peer
operator|->
name|address
argument_list|,
name|peer
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|weighedFreePeers
name|QList
argument_list|<
name|TorrentPeer
modifier|*
argument_list|>
name|TorrentClient
operator|::
name|weighedFreePeers
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|TorrentPeer
modifier|*
argument_list|>
name|weighedPeers
decl_stmt|;
comment|// Generate a list of peers that we want to connect to.
name|uint
name|now
init|=
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|toTime_t
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|TorrentPeer
modifier|*
argument_list|>
name|freePeers
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|int
argument_list|>
name|connectionsPerPeer
decl_stmt|;
foreach|foreach
control|(
name|TorrentPeer
modifier|*
name|peer
decl|,
name|d
operator|->
name|peers
control|)
block|{
name|bool
name|busy
init|=
literal|false
decl_stmt|;
foreach|foreach
control|(
name|PeerWireClient
modifier|*
name|client
decl|,
name|d
operator|->
name|connections
control|)
block|{
if|if
condition|(
name|client
operator|->
name|state
argument_list|()
operator|==
name|PeerWireClient
operator|::
name|ConnectedState
operator|&&
name|client
operator|->
name|peerAddress
argument_list|()
operator|==
name|peer
operator|->
name|address
operator|&&
name|client
operator|->
name|peerPort
argument_list|()
operator|==
name|peer
operator|->
name|port
condition|)
block|{
if|if
condition|(
operator|++
name|connectionsPerPeer
index|[
name|peer
operator|->
name|address
operator|.
name|toString
argument_list|()
index|]
operator|>=
name|MaxConnectionPerPeer
condition|)
block|{
name|busy
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|busy
operator|&&
operator|(
name|now
operator|-
name|peer
operator|->
name|lastVisited
operator|)
operator|>
name|uint
argument_list|(
name|MinimumTimeBeforeRevisit
argument_list|)
condition|)
name|freePeers
operator|<<
name|peer
expr_stmt|;
block|}
comment|// Nothing to connect to
if|if
condition|(
name|freePeers
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|weighedPeers
return|;
comment|// Assign points based on connection speed and pieces available.
name|QList
argument_list|<
name|QPair
argument_list|<
name|int
argument_list|,
name|TorrentPeer
modifier|*
argument_list|>
argument_list|>
name|points
decl_stmt|;
foreach|foreach
control|(
name|TorrentPeer
modifier|*
name|peer
decl|,
name|freePeers
control|)
block|{
name|int
name|tmp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|peer
operator|->
name|interesting
condition|)
block|{
name|tmp
operator|+=
name|peer
operator|->
name|numCompletedPieces
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Seeding
condition|)
name|tmp
operator|=
name|d
operator|->
name|pieceCount
operator|-
name|tmp
expr_stmt|;
if|if
condition|(
operator|!
name|peer
operator|->
name|connectStart
condition|)
comment|// An unknown peer is as interesting as a seed
name|tmp
operator|+=
name|d
operator|->
name|pieceCount
expr_stmt|;
comment|// 1/5 of the total score for each second below 5 it takes to
comment|// connect.
if|if
condition|(
name|peer
operator|->
name|connectTime
operator|<
literal|5
condition|)
name|tmp
operator|+=
operator|(
name|d
operator|->
name|pieceCount
operator|/
literal|10
operator|)
operator|*
operator|(
literal|5
operator|-
name|peer
operator|->
name|connectTime
operator|)
expr_stmt|;
block|}
name|points
operator|<<
name|QPair
argument_list|<
name|int
argument_list|,
name|TorrentPeer
operator|*
argument_list|>
argument_list|(
name|tmp
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
name|qSort
argument_list|(
name|points
argument_list|)
expr_stmt|;
comment|// Minimize the list so the point difference is never more than 1.
typedef|typedef
name|QPair
argument_list|<
name|int
argument_list|,
name|TorrentPeer
modifier|*
argument_list|>
name|PointPair
typedef|;
name|QMultiMap
argument_list|<
name|int
argument_list|,
name|TorrentPeer
modifier|*
argument_list|>
name|pointMap
decl_stmt|;
name|int
name|lowestScore
init|=
literal|0
decl_stmt|;
name|int
name|lastIndex
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
name|PointPair
name|point
decl|,
name|points
control|)
block|{
if|if
condition|(
name|point
operator|.
name|first
operator|>
name|lowestScore
condition|)
block|{
name|lowestScore
operator|=
name|point
operator|.
name|first
expr_stmt|;
operator|++
name|lastIndex
expr_stmt|;
block|}
name|pointMap
operator|.
name|insert
argument_list|(
name|lastIndex
argument_list|,
name|point
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
comment|// Now make up a list of peers where the ones with more points are
comment|// listed many times.
name|QMultiMap
argument_list|<
name|int
argument_list|,
name|TorrentPeer
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|pointMap
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|pointMap
operator|.
name|constEnd
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|it
operator|.
name|key
argument_list|()
operator|+
literal|1
condition|;
operator|++
name|i
control|)
name|weighedPeers
operator|<<
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
return|return
name|weighedPeers
return|;
block|}
end_function
begin_function
DECL|function|setupIncomingConnection
name|void
name|TorrentClient
operator|::
name|setupIncomingConnection
parameter_list|(
name|PeerWireClient
modifier|*
name|client
parameter_list|)
block|{
comment|// Connect signals
name|initializeConnection
argument_list|(
name|client
argument_list|)
expr_stmt|;
comment|// Initialize this client
name|RateController
operator|::
name|instance
argument_list|()
operator|->
name|addSocket
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|d
operator|->
name|connections
operator|<<
name|client
expr_stmt|;
name|client
operator|->
name|initialize
argument_list|(
name|d
operator|->
name|infoHash
argument_list|,
name|d
operator|->
name|pieceCount
argument_list|)
expr_stmt|;
name|client
operator|->
name|sendPieceList
argument_list|(
name|d
operator|->
name|completedPieces
argument_list|)
expr_stmt|;
emit|emit
name|peerInfoUpdated
argument_list|()
emit|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Searching
operator|||
name|d
operator|->
name|state
operator|==
name|Connecting
condition|)
block|{
name|int
name|completed
init|=
name|d
operator|->
name|completedPieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|completed
operator|==
literal|0
condition|)
name|d
operator|->
name|setState
argument_list|(
name|WarmingUp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|incompletePieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
operator|<
literal|5
operator|&&
name|d
operator|->
name|pendingPieces
operator|.
name|size
argument_list|()
operator|>
name|d
operator|->
name|incompletePieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
condition|)
name|d
operator|->
name|setState
argument_list|(
name|Endgame
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|connections
operator|.
name|isEmpty
argument_list|()
condition|)
name|scheduleUploads
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setupOutgoingConnection
name|void
name|TorrentClient
operator|::
name|setupOutgoingConnection
parameter_list|()
block|{
name|PeerWireClient
modifier|*
name|client
init|=
name|qobject_cast
argument_list|<
name|PeerWireClient
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|()
argument_list|)
decl_stmt|;
comment|// Update connection statistics.
foreach|foreach
control|(
name|TorrentPeer
modifier|*
name|peer
decl|,
name|d
operator|->
name|peers
control|)
block|{
if|if
condition|(
name|peer
operator|->
name|port
operator|==
name|client
operator|->
name|peerPort
argument_list|()
operator|&&
name|peer
operator|->
name|address
operator|==
name|client
operator|->
name|peerAddress
argument_list|()
condition|)
block|{
name|peer
operator|->
name|connectTime
operator|=
name|peer
operator|->
name|lastVisited
operator|-
name|peer
operator|->
name|connectStart
expr_stmt|;
break|break;
block|}
block|}
comment|// Send handshake and piece list
name|client
operator|->
name|initialize
argument_list|(
name|d
operator|->
name|infoHash
argument_list|,
name|d
operator|->
name|pieceCount
argument_list|)
expr_stmt|;
name|client
operator|->
name|sendPieceList
argument_list|(
name|d
operator|->
name|completedPieces
argument_list|)
expr_stmt|;
emit|emit
name|peerInfoUpdated
argument_list|()
emit|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Searching
operator|||
name|d
operator|->
name|state
operator|==
name|Connecting
condition|)
block|{
name|int
name|completed
init|=
name|d
operator|->
name|completedPieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|completed
operator|==
literal|0
condition|)
name|d
operator|->
name|setState
argument_list|(
name|WarmingUp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|incompletePieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
operator|<
literal|5
operator|&&
name|d
operator|->
name|pendingPieces
operator|.
name|size
argument_list|()
operator|>
name|d
operator|->
name|incompletePieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
condition|)
name|d
operator|->
name|setState
argument_list|(
name|Endgame
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|initializeConnection
name|void
name|TorrentClient
operator|::
name|initializeConnection
parameter_list|(
name|PeerWireClient
modifier|*
name|client
parameter_list|)
block|{
name|connect
argument_list|(
name|client
argument_list|,
name|SIGNAL
argument_list|(
name|connected
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|setupOutgoingConnection
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|client
argument_list|,
name|SIGNAL
argument_list|(
name|disconnected
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|removeClient
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|client
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|removeClient
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|client
argument_list|,
name|SIGNAL
argument_list|(
name|piecesAvailable
argument_list|(
name|QBitArray
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|peerPiecesAvailable
argument_list|(
name|QBitArray
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|client
argument_list|,
name|SIGNAL
argument_list|(
name|blockRequested
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|peerRequestsBlock
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|client
argument_list|,
name|SIGNAL
argument_list|(
name|blockReceived
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|QByteArray
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|blockReceived
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|QByteArray
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|client
argument_list|,
name|SIGNAL
argument_list|(
name|choked
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|peerChoked
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|client
argument_list|,
name|SIGNAL
argument_list|(
name|unchoked
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|peerUnchoked
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|client
argument_list|,
name|SIGNAL
argument_list|(
name|bytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|peerWireBytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|client
argument_list|,
name|SIGNAL
argument_list|(
name|bytesReceived
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|peerWireBytesReceived
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|removeClient
name|void
name|TorrentClient
operator|::
name|removeClient
parameter_list|()
block|{
name|PeerWireClient
modifier|*
name|client
init|=
cast|static_cast
argument_list|<
name|PeerWireClient
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|()
argument_list|)
decl_stmt|;
comment|// Remove the host from our list of known peers if the connection
comment|// failed.
if|if
condition|(
name|client
operator|->
name|peer
argument_list|()
operator|&&
name|client
operator|->
name|error
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectionRefusedError
condition|)
name|d
operator|->
name|peers
operator|.
name|removeAll
argument_list|(
name|client
operator|->
name|peer
argument_list|()
argument_list|)
expr_stmt|;
comment|// Remove the client from RateController and all structures.
name|RateController
operator|::
name|instance
argument_list|()
operator|->
name|removeSocket
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|d
operator|->
name|connections
operator|.
name|removeAll
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|QMultiMap
argument_list|<
name|PeerWireClient
modifier|*
argument_list|,
name|TorrentPiece
modifier|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|payloads
operator|.
name|find
argument_list|(
name|client
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|payloads
operator|.
name|end
argument_list|()
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|client
condition|)
block|{
name|TorrentPiece
modifier|*
name|piece
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|piece
operator|->
name|inProgress
operator|=
literal|false
expr_stmt|;
name|piece
operator|->
name|requestedBlocks
operator|.
name|fill
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|it
operator|=
name|d
operator|->
name|payloads
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
comment|// Remove pending read requests.
name|QMapIterator
argument_list|<
name|int
argument_list|,
name|PeerWireClient
modifier|*
argument_list|>
name|it2
argument_list|(
name|d
operator|->
name|readIds
argument_list|)
decl_stmt|;
while|while
condition|(
name|it2
operator|.
name|findNext
argument_list|(
name|client
argument_list|)
condition|)
name|d
operator|->
name|readIds
operator|.
name|remove
argument_list|(
name|it2
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
comment|// Delete the client later.
name|disconnect
argument_list|(
name|client
argument_list|,
name|SIGNAL
argument_list|(
name|disconnected
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|removeClient
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|client
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
name|ConnectionManager
operator|::
name|instance
argument_list|()
operator|->
name|removeConnection
argument_list|(
name|client
argument_list|)
expr_stmt|;
emit|emit
name|peerInfoUpdated
argument_list|()
emit|;
name|d
operator|->
name|callPeerConnector
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|peerPiecesAvailable
name|void
name|TorrentClient
operator|::
name|peerPiecesAvailable
parameter_list|(
specifier|const
name|QBitArray
modifier|&
name|pieces
parameter_list|)
block|{
name|PeerWireClient
modifier|*
name|client
init|=
name|qobject_cast
argument_list|<
name|PeerWireClient
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|()
argument_list|)
decl_stmt|;
comment|// Find the peer in our list of announced peers. If it's there,
comment|// then we can use the piece list into to gather statistics that
comment|// help us decide what peers to connect to.
name|TorrentPeer
modifier|*
name|peer
init|=
literal|0
decl_stmt|;
name|QList
argument_list|<
name|TorrentPeer
modifier|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|peers
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|peers
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|->
name|address
operator|==
name|client
operator|->
name|peerAddress
argument_list|()
operator|&&
operator|(
operator|*
name|it
operator|)
operator|->
name|port
operator|==
name|client
operator|->
name|peerPort
argument_list|()
condition|)
block|{
name|peer
operator|=
operator|*
name|it
expr_stmt|;
break|break;
block|}
operator|++
name|it
expr_stmt|;
block|}
comment|// If the peer is a seed, and we are in seeding mode, then the
comment|// peer is uninteresting.
if|if
condition|(
name|pieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
operator|==
name|d
operator|->
name|pieceCount
condition|)
block|{
if|if
condition|(
name|peer
condition|)
name|peer
operator|->
name|seed
operator|=
literal|true
expr_stmt|;
emit|emit
name|peerInfoUpdated
argument_list|()
emit|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Seeding
condition|)
block|{
name|client
operator|->
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|peer
condition|)
name|peer
operator|->
name|interesting
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|peerWireState
argument_list|()
operator|&
name|PeerWireClient
operator|::
name|InterestedInPeer
operator|)
operator|==
literal|0
condition|)
name|client
operator|->
name|sendInterested
argument_list|()
expr_stmt|;
name|d
operator|->
name|callScheduler
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|// Update our list of available pieces.
if|if
condition|(
name|peer
condition|)
block|{
name|peer
operator|->
name|pieces
operator|=
name|pieces
expr_stmt|;
name|peer
operator|->
name|numCompletedPieces
operator|=
name|pieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Check for interesting pieces, and tell the peer whether we are
comment|// interested or not.
name|bool
name|interested
init|=
literal|false
decl_stmt|;
name|int
name|piecesSize
init|=
name|pieces
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pieceIndex
init|=
literal|0
init|;
name|pieceIndex
operator|<
name|piecesSize
condition|;
operator|++
name|pieceIndex
control|)
block|{
if|if
condition|(
operator|!
name|pieces
operator|.
name|testBit
argument_list|(
name|pieceIndex
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|d
operator|->
name|completedPieces
operator|.
name|testBit
argument_list|(
name|pieceIndex
argument_list|)
condition|)
block|{
name|interested
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|peerWireState
argument_list|()
operator|&
name|PeerWireClient
operator|::
name|InterestedInPeer
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|peer
condition|)
name|peer
operator|->
name|interesting
operator|=
literal|true
expr_stmt|;
name|client
operator|->
name|sendInterested
argument_list|()
expr_stmt|;
block|}
name|QMultiMap
argument_list|<
name|PeerWireClient
modifier|*
argument_list|,
name|TorrentPiece
modifier|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|payloads
operator|.
name|find
argument_list|(
name|client
argument_list|)
decl_stmt|;
name|int
name|inProgress
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|payloads
operator|.
name|end
argument_list|()
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|client
condition|)
block|{
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|inProgress
condition|)
name|inProgress
operator|+=
name|it
operator|.
name|value
argument_list|()
operator|->
name|requestedBlocks
operator|.
name|count
argument_list|(
literal|true
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inProgress
condition|)
name|d
operator|->
name|callScheduler
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|interested
operator|&&
operator|(
name|client
operator|->
name|peerWireState
argument_list|()
operator|&
name|PeerWireClient
operator|::
name|InterestedInPeer
operator|)
condition|)
block|{
if|if
condition|(
name|peer
condition|)
name|peer
operator|->
name|interesting
operator|=
literal|false
expr_stmt|;
name|client
operator|->
name|sendNotInterested
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|peerRequestsBlock
name|void
name|TorrentClient
operator|::
name|peerRequestsBlock
parameter_list|(
name|int
name|pieceIndex
parameter_list|,
name|int
name|begin
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|PeerWireClient
modifier|*
name|client
init|=
name|qobject_cast
argument_list|<
name|PeerWireClient
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|()
argument_list|)
decl_stmt|;
comment|// Silently ignore requests from choked peers
if|if
condition|(
name|client
operator|->
name|peerWireState
argument_list|()
operator|&
name|PeerWireClient
operator|::
name|ChokingPeer
condition|)
return|return;
comment|// Silently ignore requests for pieces we don't have.
if|if
condition|(
operator|!
name|d
operator|->
name|completedPieces
operator|.
name|testBit
argument_list|(
name|pieceIndex
argument_list|)
condition|)
return|return;
comment|// Request the block from the file manager
name|d
operator|->
name|readIds
operator|.
name|insert
argument_list|(
name|d
operator|->
name|fileManager
operator|.
name|read
argument_list|(
name|pieceIndex
argument_list|,
name|begin
argument_list|,
name|length
argument_list|)
argument_list|,
name|qobject_cast
argument_list|<
name|PeerWireClient
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|blockReceived
name|void
name|TorrentClient
operator|::
name|blockReceived
parameter_list|(
name|int
name|pieceIndex
parameter_list|,
name|int
name|begin
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
name|PeerWireClient
modifier|*
name|client
init|=
name|qobject_cast
argument_list|<
name|PeerWireClient
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|client
operator|->
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Ignore it if we already have this block.
name|int
name|blockBit
init|=
name|begin
operator|/
name|BlockSize
decl_stmt|;
name|TorrentPiece
modifier|*
name|piece
init|=
name|d
operator|->
name|pendingPieces
operator|.
name|value
argument_list|(
name|pieceIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|piece
operator|||
name|piece
operator|->
name|completedBlocks
operator|.
name|testBit
argument_list|(
name|blockBit
argument_list|)
condition|)
block|{
comment|// Discard blocks that we already have, and fill up the pipeline.
name|requestMore
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// If we are in warmup or endgame mode, cancel all duplicate
comment|// requests for this block.
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|WarmingUp
operator|||
name|d
operator|->
name|state
operator|==
name|Endgame
condition|)
block|{
name|QMultiMap
argument_list|<
name|PeerWireClient
modifier|*
argument_list|,
name|TorrentPiece
modifier|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|payloads
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|payloads
operator|.
name|end
argument_list|()
condition|)
block|{
name|PeerWireClient
modifier|*
name|otherClient
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
name|otherClient
operator|!=
name|client
operator|&&
name|it
operator|.
name|value
argument_list|()
operator|->
name|index
operator|==
name|pieceIndex
condition|)
block|{
if|if
condition|(
name|otherClient
operator|->
name|incomingBlocks
argument_list|()
operator|.
name|contains
argument_list|(
name|TorrentBlock
argument_list|(
name|pieceIndex
argument_list|,
name|begin
argument_list|,
name|data
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
condition|)
name|it
operator|.
name|key
argument_list|()
operator|->
name|cancelRequest
argument_list|(
name|pieceIndex
argument_list|,
name|begin
argument_list|,
name|data
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|++
name|it
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|Downloading
operator|&&
name|d
operator|->
name|state
operator|!=
name|Endgame
operator|&&
name|d
operator|->
name|completedPieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
operator|>
literal|0
condition|)
name|d
operator|->
name|setState
argument_list|(
name|Downloading
argument_list|)
expr_stmt|;
comment|// Store this block
name|d
operator|->
name|fileManager
operator|.
name|write
argument_list|(
name|pieceIndex
argument_list|,
name|begin
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|piece
operator|->
name|completedBlocks
operator|.
name|setBit
argument_list|(
name|blockBit
argument_list|)
expr_stmt|;
name|piece
operator|->
name|requestedBlocks
operator|.
name|clearBit
argument_list|(
name|blockBit
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocksLeftForPiece
argument_list|(
name|piece
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// Ask the file manager to verify the newly downloaded piece
name|d
operator|->
name|fileManager
operator|.
name|verifyPiece
argument_list|(
name|piece
operator|->
name|index
argument_list|)
expr_stmt|;
comment|// Remove this piece from all payloads
name|QMultiMap
argument_list|<
name|PeerWireClient
modifier|*
argument_list|,
name|TorrentPiece
modifier|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|payloads
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|payloads
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|it
operator|.
name|value
argument_list|()
operator|||
name|it
operator|.
name|value
argument_list|()
operator|->
name|index
operator|==
name|piece
operator|->
name|index
condition|)
name|it
operator|=
name|d
operator|->
name|payloads
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
else|else
operator|++
name|it
expr_stmt|;
block|}
block|}
comment|// Fill up the pipeline.
name|requestMore
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|peerWireBytesWritten
name|void
name|TorrentClient
operator|::
name|peerWireBytesWritten
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|transferRateTimer
condition|)
name|d
operator|->
name|transferRateTimer
operator|=
name|startTimer
argument_list|(
name|RateControlTimerDelay
argument_list|)
expr_stmt|;
name|d
operator|->
name|uploadRate
index|[
literal|0
index|]
operator|+=
name|size
expr_stmt|;
name|d
operator|->
name|uploadedBytes
operator|+=
name|size
expr_stmt|;
emit|emit
name|dataSent
argument_list|(
name|size
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|peerWireBytesReceived
name|void
name|TorrentClient
operator|::
name|peerWireBytesReceived
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|transferRateTimer
condition|)
name|d
operator|->
name|transferRateTimer
operator|=
name|startTimer
argument_list|(
name|RateControlTimerDelay
argument_list|)
expr_stmt|;
name|d
operator|->
name|downloadRate
index|[
literal|0
index|]
operator|+=
name|size
expr_stmt|;
name|d
operator|->
name|downloadedBytes
operator|+=
name|size
expr_stmt|;
emit|emit
name|dataSent
argument_list|(
name|size
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|blocksLeftForPiece
name|int
name|TorrentClient
operator|::
name|blocksLeftForPiece
parameter_list|(
specifier|const
name|TorrentPiece
modifier|*
name|piece
parameter_list|)
specifier|const
block|{
name|int
name|blocksLeft
init|=
literal|0
decl_stmt|;
name|int
name|completedBlocksSize
init|=
name|piece
operator|->
name|completedBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|completedBlocksSize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|piece
operator|->
name|completedBlocks
operator|.
name|testBit
argument_list|(
name|i
argument_list|)
condition|)
operator|++
name|blocksLeft
expr_stmt|;
block|}
return|return
name|blocksLeft
return|;
block|}
end_function
begin_function
DECL|function|scheduleUploads
name|void
name|TorrentClient
operator|::
name|scheduleUploads
parameter_list|()
block|{
comment|// Generate a list of clients sorted by their transfer
comment|// speeds.  When leeching, we sort by download speed, and when
comment|// seeding, we sort by upload speed. Seeds are left out; there's
comment|// no use in unchoking them.
name|QList
argument_list|<
name|PeerWireClient
modifier|*
argument_list|>
name|allClients
init|=
name|d
operator|->
name|connections
decl_stmt|;
name|QMultiMap
argument_list|<
name|int
argument_list|,
name|PeerWireClient
modifier|*
argument_list|>
name|transferSpeeds
decl_stmt|;
foreach|foreach
control|(
name|PeerWireClient
modifier|*
name|client
decl|,
name|allClients
control|)
block|{
if|if
condition|(
name|client
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
operator|&&
name|client
operator|->
name|availablePieces
argument_list|()
operator|.
name|count
argument_list|(
literal|true
argument_list|)
operator|!=
name|d
operator|->
name|pieceCount
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Seeding
condition|)
block|{
name|transferSpeeds
operator|.
name|insert
argument_list|(
name|client
operator|->
name|uploadSpeed
argument_list|()
argument_list|,
name|client
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|transferSpeeds
operator|.
name|insert
argument_list|(
name|client
operator|->
name|downloadSpeed
argument_list|()
argument_list|,
name|client
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Unchoke the top 'MaxUploads' downloaders (peers that we are
comment|// uploading to) and choke all others.
name|int
name|maxUploaders
init|=
name|MaxUploads
decl_stmt|;
name|QMapIterator
argument_list|<
name|int
argument_list|,
name|PeerWireClient
modifier|*
argument_list|>
name|it
argument_list|(
name|transferSpeeds
argument_list|)
decl_stmt|;
name|it
operator|.
name|toBack
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasPrevious
argument_list|()
condition|)
block|{
name|PeerWireClient
modifier|*
name|client
init|=
name|it
operator|.
name|previous
argument_list|()
operator|.
name|value
argument_list|()
decl_stmt|;
name|bool
name|interested
init|=
operator|(
name|client
operator|->
name|peerWireState
argument_list|()
operator|&
name|PeerWireClient
operator|::
name|PeerIsInterested
operator|)
decl_stmt|;
if|if
condition|(
name|maxUploaders
condition|)
block|{
name|allClients
operator|.
name|removeAll
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|peerWireState
argument_list|()
operator|&
name|PeerWireClient
operator|::
name|ChokingPeer
condition|)
name|client
operator|->
name|unchokePeer
argument_list|()
expr_stmt|;
operator|--
name|maxUploaders
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|client
operator|->
name|peerWireState
argument_list|()
operator|&
name|PeerWireClient
operator|::
name|ChokingPeer
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|qrand
argument_list|()
operator|%
literal|10
operator|)
operator|==
literal|0
condition|)
name|client
operator|->
name|abort
argument_list|()
expr_stmt|;
else|else
name|client
operator|->
name|chokePeer
argument_list|()
expr_stmt|;
name|allClients
operator|.
name|removeAll
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|interested
condition|)
name|allClients
operator|.
name|removeAll
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
comment|// Only interested peers are left in allClients. Unchoke one
comment|// random peer to allow it to compete for a position among the
comment|// downloaders.  (This is known as an "optimistic unchoke".)
if|if
condition|(
operator|!
name|allClients
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|PeerWireClient
modifier|*
name|client
init|=
name|allClients
index|[
name|qrand
argument_list|()
operator|%
name|allClients
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|client
operator|->
name|peerWireState
argument_list|()
operator|&
name|PeerWireClient
operator|::
name|ChokingPeer
condition|)
name|client
operator|->
name|unchokePeer
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|scheduleDownloads
name|void
name|TorrentClient
operator|::
name|scheduleDownloads
parameter_list|()
block|{
name|d
operator|->
name|schedulerCalled
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Stopping
operator|||
name|d
operator|->
name|state
operator|==
name|Paused
operator|||
name|d
operator|->
name|state
operator|==
name|Idle
condition|)
return|return;
comment|// Check what each client is doing, and assign payloads to those
comment|// who are either idle or done.
foreach|foreach
control|(
name|PeerWireClient
modifier|*
name|client
decl|,
name|d
operator|->
name|connections
control|)
name|schedulePieceForClient
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|schedulePieceForClient
name|void
name|TorrentClient
operator|::
name|schedulePieceForClient
parameter_list|(
name|PeerWireClient
modifier|*
name|client
parameter_list|)
block|{
comment|// Only schedule connected clients.
if|if
condition|(
name|client
operator|->
name|state
argument_list|()
operator|!=
name|QTcpSocket
operator|::
name|ConnectedState
condition|)
return|return;
comment|// The peer has choked us; try again later.
if|if
condition|(
name|client
operator|->
name|peerWireState
argument_list|()
operator|&
name|PeerWireClient
operator|::
name|ChokedByPeer
condition|)
return|return;
comment|// Make a list of all the client's pending pieces, and count how
comment|// many blocks have been requested.
name|QList
argument_list|<
name|int
argument_list|>
name|currentPieces
decl_stmt|;
name|bool
name|somePiecesAreNotInProgress
init|=
literal|false
decl_stmt|;
name|TorrentPiece
modifier|*
name|lastPendingPiece
init|=
literal|0
decl_stmt|;
name|QMultiMap
argument_list|<
name|PeerWireClient
modifier|*
argument_list|,
name|TorrentPiece
modifier|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|payloads
operator|.
name|find
argument_list|(
name|client
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|payloads
operator|.
name|end
argument_list|()
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|client
condition|)
block|{
name|lastPendingPiece
operator|=
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastPendingPiece
operator|->
name|inProgress
condition|)
block|{
name|currentPieces
operator|<<
name|lastPendingPiece
operator|->
name|index
expr_stmt|;
block|}
else|else
block|{
name|somePiecesAreNotInProgress
operator|=
literal|true
expr_stmt|;
block|}
operator|++
name|it
expr_stmt|;
block|}
comment|// Skip clients that already have too many blocks in progress.
if|if
condition|(
name|client
operator|->
name|incomingBlocks
argument_list|()
operator|.
name|size
argument_list|()
operator|>=
operator|(
operator|(
name|d
operator|->
name|state
operator|==
name|Endgame
operator|||
name|d
operator|->
name|state
operator|==
name|WarmingUp
operator|)
condition|?
name|MaxBlocksInMultiMode
else|:
name|MaxBlocksInProgress
operator|)
condition|)
return|return;
comment|// If all pieces are in progress, but we haven't filled up our
comment|// block requesting quota, then we need to schedule another piece.
if|if
condition|(
operator|!
name|somePiecesAreNotInProgress
operator|||
name|client
operator|->
name|incomingBlocks
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
name|lastPendingPiece
operator|=
literal|0
expr_stmt|;
name|TorrentPiece
modifier|*
name|piece
init|=
name|lastPendingPiece
decl_stmt|;
comment|// In warmup state, all clients request blocks from the same pieces.
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|WarmingUp
operator|&&
name|d
operator|->
name|pendingPieces
operator|.
name|size
argument_list|()
operator|>=
literal|4
condition|)
block|{
name|piece
operator|=
name|d
operator|->
name|payloads
operator|.
name|value
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|piece
condition|)
block|{
name|QList
argument_list|<
name|TorrentPiece
modifier|*
argument_list|>
name|values
init|=
name|d
operator|->
name|pendingPieces
operator|.
name|values
argument_list|()
decl_stmt|;
name|piece
operator|=
name|values
operator|.
name|value
argument_list|(
name|qrand
argument_list|()
operator|%
name|values
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|piece
operator|->
name|inProgress
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|payloads
operator|.
name|insert
argument_list|(
name|client
argument_list|,
name|piece
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|piece
operator|->
name|completedBlocks
operator|.
name|count
argument_list|(
literal|false
argument_list|)
operator|==
name|client
operator|->
name|incomingBlocks
argument_list|()
operator|.
name|size
argument_list|()
condition|)
return|return;
block|}
comment|// If no pieces are currently in progress, schedule a new one.
if|if
condition|(
operator|!
name|piece
condition|)
block|{
comment|// Build up a list of what pieces that we have not completed
comment|// are available to this client.
name|QBitArray
name|incompletePiecesAvailableToClient
init|=
name|d
operator|->
name|incompletePieces
decl_stmt|;
comment|// Remove all pieces that are marked as being in progress
comment|// already (i.e., pieces that this or other clients are
comment|// already waiting for). A special rule applies to warmup and
comment|// endgame mode; there, we allow several clients to request
comment|// the same piece. In endgame mode, this only applies to
comment|// clients that are currently uploading (more than 1.0KB/s).
if|if
condition|(
operator|(
name|d
operator|->
name|state
operator|==
name|Endgame
operator|&&
name|client
operator|->
name|uploadSpeed
argument_list|()
operator|<
literal|1024
operator|)
operator|||
name|d
operator|->
name|state
operator|!=
name|WarmingUp
condition|)
block|{
name|QMap
argument_list|<
name|int
argument_list|,
name|TorrentPiece
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|pendingPieces
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|pendingPieces
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|inProgress
condition|)
name|incompletePiecesAvailableToClient
operator|.
name|clearBit
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
block|}
comment|// Remove all pieces that the client cannot download.
name|incompletePiecesAvailableToClient
operator|&=
name|client
operator|->
name|availablePieces
argument_list|()
expr_stmt|;
comment|// Remove all pieces that this client has already requested.
foreach|foreach
control|(
name|int
name|i
decl|,
name|currentPieces
control|)
name|incompletePiecesAvailableToClient
operator|.
name|clearBit
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// Only continue if more pieces can be scheduled. If no pieces
comment|// are available and no blocks are in progress, just leave
comment|// the connection idle; it might become interesting later.
if|if
condition|(
name|incompletePiecesAvailableToClient
operator|.
name|count
argument_list|(
literal|true
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|// Check if any of the partially completed pieces can be
comment|// recovered, and if so, pick a random one of them.
name|QList
argument_list|<
name|TorrentPiece
modifier|*
argument_list|>
name|partialPieces
decl_stmt|;
name|QMap
argument_list|<
name|int
argument_list|,
name|TorrentPiece
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|pendingPieces
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|pendingPieces
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|TorrentPiece
modifier|*
name|tmp
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|incompletePiecesAvailableToClient
operator|.
name|testBit
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|tmp
operator|->
name|inProgress
operator|||
name|d
operator|->
name|state
operator|==
name|WarmingUp
operator|||
name|d
operator|->
name|state
operator|==
name|Endgame
condition|)
block|{
name|partialPieces
operator|<<
name|tmp
expr_stmt|;
break|break;
block|}
block|}
operator|++
name|it
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|partialPieces
operator|.
name|isEmpty
argument_list|()
condition|)
name|piece
operator|=
name|partialPieces
operator|.
name|value
argument_list|(
name|qrand
argument_list|()
operator|%
name|partialPieces
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|piece
condition|)
block|{
comment|// Pick a random piece 3 out of 4 times; otherwise, pick either
comment|// one of the most common or the least common pieces available,
comment|// depending on the state we're in.
name|int
name|pieceIndex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|WarmingUp
operator|||
operator|(
name|qrand
argument_list|()
operator|&
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
name|int
modifier|*
name|occurrences
init|=
operator|new
name|int
index|[
name|d
operator|->
name|pieceCount
index|]
decl_stmt|;
name|memset
argument_list|(
name|occurrences
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|pieceCount
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|// Count how many of each piece are available.
foreach|foreach
control|(
name|PeerWireClient
modifier|*
name|peer
decl|,
name|d
operator|->
name|connections
control|)
block|{
name|QBitArray
name|peerPieces
init|=
name|peer
operator|->
name|availablePieces
argument_list|()
decl_stmt|;
name|int
name|peerPiecesSize
init|=
name|peerPieces
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|peerPiecesSize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|peerPieces
operator|.
name|testBit
argument_list|(
name|i
argument_list|)
condition|)
operator|++
name|occurrences
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|// Find the rarest or most common pieces.
name|int
name|numOccurrences
init|=
name|d
operator|->
name|state
operator|==
name|WarmingUp
condition|?
literal|0
else|:
literal|99999
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|piecesReadyForDownload
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|pieceCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|WarmingUp
condition|)
block|{
comment|// Add common pieces
if|if
condition|(
name|occurrences
index|[
name|i
index|]
operator|>=
name|numOccurrences
operator|&&
name|incompletePiecesAvailableToClient
operator|.
name|testBit
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|occurrences
index|[
name|i
index|]
operator|>
name|numOccurrences
condition|)
name|piecesReadyForDownload
operator|.
name|clear
argument_list|()
expr_stmt|;
name|piecesReadyForDownload
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|numOccurrences
operator|=
name|occurrences
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Add rare pieces
if|if
condition|(
name|occurrences
index|[
name|i
index|]
operator|<=
name|numOccurrences
operator|&&
name|incompletePiecesAvailableToClient
operator|.
name|testBit
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|occurrences
index|[
name|i
index|]
operator|<
name|numOccurrences
condition|)
name|piecesReadyForDownload
operator|.
name|clear
argument_list|()
expr_stmt|;
name|piecesReadyForDownload
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|numOccurrences
operator|=
name|occurrences
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
comment|// Select one piece randomly
name|pieceIndex
operator|=
name|piecesReadyForDownload
operator|.
name|at
argument_list|(
name|qrand
argument_list|()
operator|%
name|piecesReadyForDownload
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|occurrences
expr_stmt|;
block|}
else|else
block|{
comment|// Make up a list of available piece indices, and pick
comment|// a random one.
name|QList
argument_list|<
name|int
argument_list|>
name|values
decl_stmt|;
name|int
name|incompletePiecesAvailableToClientSize
init|=
name|incompletePiecesAvailableToClient
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|incompletePiecesAvailableToClientSize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|incompletePiecesAvailableToClient
operator|.
name|testBit
argument_list|(
name|i
argument_list|)
condition|)
name|values
operator|<<
name|i
expr_stmt|;
block|}
name|pieceIndex
operator|=
name|values
operator|.
name|at
argument_list|(
name|qrand
argument_list|()
operator|%
name|values
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Create a new TorrentPiece and fill in all initial
comment|// properties.
name|piece
operator|=
operator|new
name|TorrentPiece
expr_stmt|;
name|piece
operator|->
name|index
operator|=
name|pieceIndex
expr_stmt|;
name|piece
operator|->
name|length
operator|=
name|d
operator|->
name|fileManager
operator|.
name|pieceLengthAt
argument_list|(
name|pieceIndex
argument_list|)
expr_stmt|;
name|int
name|numBlocks
init|=
name|piece
operator|->
name|length
operator|/
name|BlockSize
decl_stmt|;
if|if
condition|(
name|piece
operator|->
name|length
operator|%
name|BlockSize
condition|)
operator|++
name|numBlocks
expr_stmt|;
name|piece
operator|->
name|completedBlocks
operator|.
name|resize
argument_list|(
name|numBlocks
argument_list|)
expr_stmt|;
name|piece
operator|->
name|requestedBlocks
operator|.
name|resize
argument_list|(
name|numBlocks
argument_list|)
expr_stmt|;
name|d
operator|->
name|pendingPieces
operator|.
name|insert
argument_list|(
name|pieceIndex
argument_list|,
name|piece
argument_list|)
expr_stmt|;
block|}
name|piece
operator|->
name|inProgress
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|payloads
operator|.
name|insert
argument_list|(
name|client
argument_list|,
name|piece
argument_list|)
expr_stmt|;
block|}
comment|// Request more blocks from all pending pieces.
name|requestMore
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|requestMore
name|void
name|TorrentClient
operator|::
name|requestMore
parameter_list|(
name|PeerWireClient
modifier|*
name|client
parameter_list|)
block|{
comment|// Make a list of all pieces this client is currently waiting for,
comment|// and count the number of blocks in progress.
name|QMultiMap
argument_list|<
name|PeerWireClient
modifier|*
argument_list|,
name|TorrentPiece
modifier|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|payloads
operator|.
name|find
argument_list|(
name|client
argument_list|)
decl_stmt|;
name|int
name|numBlocksInProgress
init|=
name|client
operator|->
name|incomingBlocks
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|TorrentPiece
modifier|*
argument_list|>
name|piecesInProgress
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|payloads
operator|.
name|end
argument_list|()
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|client
condition|)
block|{
name|TorrentPiece
modifier|*
name|piece
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|piece
operator|->
name|inProgress
operator|||
operator|(
name|d
operator|->
name|state
operator|==
name|WarmingUp
operator|||
name|d
operator|->
name|state
operator|==
name|Endgame
operator|)
condition|)
name|piecesInProgress
operator|<<
name|piece
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
comment|// If no pieces are in progress, call the scheduler.
if|if
condition|(
name|piecesInProgress
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|incompletePieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
condition|)
block|{
name|d
operator|->
name|callScheduler
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// If too many pieces are in progress, there's nothing to do.
name|int
name|maxInProgress
init|=
operator|(
operator|(
name|d
operator|->
name|state
operator|==
name|Endgame
operator|||
name|d
operator|->
name|state
operator|==
name|WarmingUp
operator|)
condition|?
name|MaxBlocksInMultiMode
else|:
name|MaxBlocksInProgress
operator|)
decl_stmt|;
if|if
condition|(
name|numBlocksInProgress
operator|==
name|maxInProgress
condition|)
return|return;
comment|// Starting with the first piece that we're waiting for, request
comment|// blocks until the quota is filled up.
foreach|foreach
control|(
name|TorrentPiece
modifier|*
name|piece
decl|,
name|piecesInProgress
control|)
block|{
name|numBlocksInProgress
operator|+=
name|requestBlocks
argument_list|(
name|client
argument_list|,
name|piece
argument_list|,
name|maxInProgress
operator|-
name|numBlocksInProgress
argument_list|)
expr_stmt|;
if|if
condition|(
name|numBlocksInProgress
operator|==
name|maxInProgress
condition|)
break|break;
block|}
comment|// If we still didn't fill up the quota, we need to schedule more
comment|// pieces.
if|if
condition|(
name|numBlocksInProgress
operator|<
name|maxInProgress
operator|&&
name|d
operator|->
name|state
operator|!=
name|WarmingUp
condition|)
name|d
operator|->
name|callScheduler
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|requestBlocks
name|int
name|TorrentClient
operator|::
name|requestBlocks
parameter_list|(
name|PeerWireClient
modifier|*
name|client
parameter_list|,
name|TorrentPiece
modifier|*
name|piece
parameter_list|,
name|int
name|maxBlocks
parameter_list|)
block|{
comment|// Generate the list of incomplete blocks for this piece.
name|QVector
argument_list|<
name|int
argument_list|>
name|bits
decl_stmt|;
name|int
name|completedBlocksSize
init|=
name|piece
operator|->
name|completedBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|completedBlocksSize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|piece
operator|->
name|completedBlocks
operator|.
name|testBit
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|piece
operator|->
name|requestedBlocks
operator|.
name|testBit
argument_list|(
name|i
argument_list|)
condition|)
name|bits
operator|<<
name|i
expr_stmt|;
block|}
comment|// Nothing more to request.
if|if
condition|(
name|bits
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|WarmingUp
operator|&&
name|d
operator|->
name|state
operator|!=
name|Endgame
condition|)
return|return
literal|0
return|;
name|bits
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|completedBlocksSize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|piece
operator|->
name|completedBlocks
operator|.
name|testBit
argument_list|(
name|i
argument_list|)
condition|)
name|bits
operator|<<
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|WarmingUp
operator|||
name|d
operator|->
name|state
operator|==
name|Endgame
condition|)
block|{
comment|// By randomizing the list of blocks to request, we
comment|// significantly speed up the warmup and endgame modes, where
comment|// the same blocks are requested from multiple peers. The
comment|// speedup comes from an increased chance of receiving
comment|// different blocks from the different peers.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bits
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|a
init|=
name|qrand
argument_list|()
operator|%
name|bits
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|b
init|=
name|qrand
argument_list|()
operator|%
name|bits
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|tmp
init|=
name|bits
index|[
name|a
index|]
decl_stmt|;
name|bits
index|[
name|a
index|]
operator|=
name|bits
index|[
name|b
index|]
expr_stmt|;
name|bits
index|[
name|b
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|// Request no more blocks than we've been asked to.
name|int
name|blocksToRequest
init|=
name|qMin
argument_list|(
name|maxBlocks
argument_list|,
name|bits
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Calculate the offset and size of each block, and send requests.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocksToRequest
condition|;
operator|++
name|i
control|)
block|{
name|int
name|blockSize
init|=
name|BlockSize
decl_stmt|;
if|if
condition|(
operator|(
name|piece
operator|->
name|length
operator|%
name|BlockSize
operator|)
operator|&&
name|bits
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|completedBlocksSize
operator|-
literal|1
condition|)
name|blockSize
operator|=
name|piece
operator|->
name|length
operator|%
name|BlockSize
expr_stmt|;
name|client
operator|->
name|requestBlock
argument_list|(
name|piece
operator|->
name|index
argument_list|,
name|bits
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|*
name|BlockSize
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
name|piece
operator|->
name|requestedBlocks
operator|.
name|setBit
argument_list|(
name|bits
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|blocksToRequest
return|;
block|}
end_function
begin_function
DECL|function|peerChoked
name|void
name|TorrentClient
operator|::
name|peerChoked
parameter_list|()
block|{
name|PeerWireClient
modifier|*
name|client
init|=
name|qobject_cast
argument_list|<
name|PeerWireClient
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|client
condition|)
return|return;
comment|// When the peer chokes us, we immediately forget about all blocks
comment|// we've requested from it. We also remove the piece from out
comment|// payload, making it available to other clients.
name|QMultiMap
argument_list|<
name|PeerWireClient
modifier|*
argument_list|,
name|TorrentPiece
modifier|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|payloads
operator|.
name|find
argument_list|(
name|client
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|payloads
operator|.
name|end
argument_list|()
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|client
condition|)
block|{
name|it
operator|.
name|value
argument_list|()
operator|->
name|inProgress
operator|=
literal|false
expr_stmt|;
name|it
operator|.
name|value
argument_list|()
operator|->
name|requestedBlocks
operator|.
name|fill
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|it
operator|=
name|d
operator|->
name|payloads
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|peerUnchoked
name|void
name|TorrentClient
operator|::
name|peerUnchoked
parameter_list|()
block|{
name|PeerWireClient
modifier|*
name|client
init|=
name|qobject_cast
argument_list|<
name|PeerWireClient
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|client
condition|)
return|return;
comment|// We got unchoked, which means we can request more blocks.
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|Seeding
condition|)
name|d
operator|->
name|callScheduler
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addToPeerList
name|void
name|TorrentClient
operator|::
name|addToPeerList
parameter_list|(
specifier|const
name|QList
argument_list|<
name|TorrentPeer
argument_list|>
modifier|&
name|peerList
parameter_list|)
block|{
comment|// Add peers we don't already know of to our list of peers.
name|QList
argument_list|<
name|QHostAddress
argument_list|>
name|addresses
init|=
name|QNetworkInterface
operator|::
name|allAddresses
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|TorrentPeer
name|peer
decl|,
name|peerList
control|)
block|{
if|if
condition|(
name|addresses
operator|.
name|contains
argument_list|(
name|peer
operator|.
name|address
argument_list|)
operator|&&
name|peer
operator|.
name|port
operator|==
name|TorrentServer
operator|::
name|instance
argument_list|()
operator|->
name|serverPort
argument_list|()
condition|)
block|{
comment|// Skip our own server.
continue|continue;
block|}
name|bool
name|known
init|=
literal|false
decl_stmt|;
foreach|foreach
control|(
name|TorrentPeer
modifier|*
name|knownPeer
decl|,
name|d
operator|->
name|peers
control|)
block|{
if|if
condition|(
name|knownPeer
operator|->
name|port
operator|==
name|peer
operator|.
name|port
operator|&&
name|knownPeer
operator|->
name|address
operator|==
name|peer
operator|.
name|address
condition|)
block|{
name|known
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|known
condition|)
block|{
name|TorrentPeer
modifier|*
name|newPeer
init|=
operator|new
name|TorrentPeer
decl_stmt|;
operator|*
name|newPeer
operator|=
name|peer
expr_stmt|;
name|newPeer
operator|->
name|interesting
operator|=
literal|true
expr_stmt|;
name|newPeer
operator|->
name|seed
operator|=
literal|false
expr_stmt|;
name|newPeer
operator|->
name|lastVisited
operator|=
literal|0
expr_stmt|;
name|newPeer
operator|->
name|connectStart
operator|=
literal|0
expr_stmt|;
name|newPeer
operator|->
name|connectTime
operator|=
literal|999999
expr_stmt|;
name|newPeer
operator|->
name|pieces
operator|.
name|resize
argument_list|(
name|d
operator|->
name|pieceCount
argument_list|)
expr_stmt|;
name|newPeer
operator|->
name|numCompletedPieces
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|peers
operator|<<
name|newPeer
expr_stmt|;
block|}
block|}
comment|// If we've got more peers than we can connect to, we remove some
comment|// of the peers that have no (or low) activity.
name|int
name|maxPeers
init|=
name|ConnectionManager
operator|::
name|instance
argument_list|()
operator|->
name|maxConnections
argument_list|()
operator|*
literal|3
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|peers
operator|.
name|size
argument_list|()
operator|>
name|maxPeers
condition|)
block|{
comment|// Find what peers are currently connected& active
name|QSet
argument_list|<
name|TorrentPeer
modifier|*
argument_list|>
name|activePeers
decl_stmt|;
foreach|foreach
control|(
name|TorrentPeer
modifier|*
name|peer
decl|,
name|d
operator|->
name|peers
control|)
block|{
foreach|foreach
control|(
name|PeerWireClient
modifier|*
name|client
decl|,
name|d
operator|->
name|connections
control|)
block|{
if|if
condition|(
name|client
operator|->
name|peer
argument_list|()
operator|==
name|peer
operator|&&
operator|(
name|client
operator|->
name|downloadSpeed
argument_list|()
operator|+
name|client
operator|->
name|uploadSpeed
argument_list|()
operator|)
operator|>
literal|1024
condition|)
name|activePeers
operator|<<
name|peer
expr_stmt|;
block|}
block|}
comment|// Remove inactive peers from the peer list until we're below
comment|// the max connections count.
name|QList
argument_list|<
name|int
argument_list|>
name|toRemove
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|peers
operator|.
name|size
argument_list|()
operator|&&
operator|(
name|d
operator|->
name|peers
operator|.
name|size
argument_list|()
operator|-
name|toRemove
operator|.
name|size
argument_list|()
operator|)
operator|>
name|maxPeers
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|activePeers
operator|.
name|contains
argument_list|(
name|d
operator|->
name|peers
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|toRemove
operator|<<
name|i
expr_stmt|;
block|}
name|QListIterator
argument_list|<
name|int
argument_list|>
name|toRemoveIterator
argument_list|(
name|toRemove
argument_list|)
decl_stmt|;
name|toRemoveIterator
operator|.
name|toBack
argument_list|()
expr_stmt|;
while|while
condition|(
name|toRemoveIterator
operator|.
name|hasPrevious
argument_list|()
condition|)
name|d
operator|->
name|peers
operator|.
name|removeAt
argument_list|(
name|toRemoveIterator
operator|.
name|previous
argument_list|()
argument_list|)
expr_stmt|;
comment|// If we still have too many peers, remove the oldest ones.
while|while
condition|(
name|d
operator|->
name|peers
operator|.
name|size
argument_list|()
operator|>
name|maxPeers
condition|)
name|d
operator|->
name|peers
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|Paused
operator|&&
name|d
operator|->
name|state
operator|!=
name|Stopping
operator|&&
name|d
operator|->
name|state
operator|!=
name|Idle
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Searching
operator|||
name|d
operator|->
name|state
operator|==
name|WarmingUp
condition|)
name|connectToPeers
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|callPeerConnector
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|trackerStopped
name|void
name|TorrentClient
operator|::
name|trackerStopped
parameter_list|()
block|{
name|d
operator|->
name|setState
argument_list|(
name|Idle
argument_list|)
expr_stmt|;
emit|emit
name|stopped
argument_list|()
emit|;
block|}
end_function
begin_function
DECL|function|updateProgress
name|void
name|TorrentClient
operator|::
name|updateProgress
parameter_list|(
name|int
name|progress
parameter_list|)
block|{
if|if
condition|(
name|progress
operator|==
operator|-
literal|1
operator|&&
name|d
operator|->
name|pieceCount
operator|>
literal|0
condition|)
block|{
name|int
name|newProgress
init|=
operator|(
name|d
operator|->
name|completedPieces
operator|.
name|count
argument_list|(
literal|true
argument_list|)
operator|*
literal|100
operator|)
operator|/
name|d
operator|->
name|pieceCount
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|lastProgressValue
operator|!=
name|newProgress
condition|)
block|{
name|d
operator|->
name|lastProgressValue
operator|=
name|newProgress
expr_stmt|;
emit|emit
name|progressUpdated
argument_list|(
name|newProgress
argument_list|)
emit|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|lastProgressValue
operator|!=
name|progress
condition|)
block|{
name|d
operator|->
name|lastProgressValue
operator|=
name|progress
expr_stmt|;
emit|emit
name|progressUpdated
argument_list|(
name|progress
argument_list|)
emit|;
block|}
block|}
end_function
end_unit
