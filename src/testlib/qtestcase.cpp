begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtTest module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtTest/qtestcase.h>
end_include
begin_include
include|#
directive|include
file|<QtTest/qtestassert.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qbytearray.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmetaobject.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qobject.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvector.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qfile.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdir.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qprocess.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qlibraryinfo.h>
end_include
begin_include
include|#
directive|include
file|<QtTest/private/qtestlog_p.h>
end_include
begin_include
include|#
directive|include
file|<QtTest/private/qtesttable_p.h>
end_include
begin_include
include|#
directive|include
file|<QtTest/qtestdata.h>
end_include
begin_include
include|#
directive|include
file|<QtTest/private/qtestresult_p.h>
end_include
begin_include
include|#
directive|include
file|<QtTest/private/qsignaldumper_p.h>
end_include
begin_include
include|#
directive|include
file|<QtTest/private/qbenchmark_p.h>
end_include
begin_include
include|#
directive|include
file|<QtTest/private/cycle_p.h>
end_include
begin_include
include|#
directive|include
file|<stdarg.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_WINCE
end_ifndef
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_CC_MINGW
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|Q_CC_MINGW
argument_list|)
operator|&&
name|defined
argument_list|(
name|__MINGW64_VERSION_MAJOR
argument_list|)
operator|)
end_if
begin_include
include|#
directive|include
file|<crtdbg.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<windows.h>
end_include
begin_comment
comment|// for Sleep
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<signal.h>
end_include
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_MAC
end_ifdef
begin_include
include|#
directive|include
file|<Carbon/Carbon.h>
end_include
begin_comment
comment|// for SetFrontProcess
end_comment
begin_include
include|#
directive|include
file|<IOKit/pwr_mgt/IOPMLib.h>
end_include
begin_undef
DECL|macro|verify
undef|#
directive|undef
name|verify
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!    \namespace QTest    \inmodule QtTest     \brief The QTest namespace contains all the functions and    declarations that are related to the QTestLib tool.     Please refer to the \l{QTestLib Manual} documentation for information on    how to write unit tests. */
comment|/*! \macro QVERIFY(condition)     \relates QTest     The QVERIFY() macro checks whether the \a condition is true or not. If it is    true, execution continues. If not, a failure is recorded in the test log    and the test won't be executed further.     \b {Note:} This macro can only be used in a test function that is invoked    by the test framework.     Example:    \snippet code/src_qtestlib_qtestcase.cpp 0     \sa QCOMPARE(), QTRY_VERIFY() */
comment|/*! \macro QVERIFY2(condition, message)      \relates QTest      The QVERIFY2() macro behaves exactly like QVERIFY(), except that it outputs     a verbose \a message when \a condition is false. The \a message is a plain     C string.      Example:     \snippet code/src_qtestlib_qtestcase.cpp 1      \sa QVERIFY(), QCOMPARE() */
comment|/*! \macro QCOMPARE(actual, expected)     \relates QTest     The QCOMPARE macro compares an \a actual value to an \a expected value using    the equals operator. If \a actual and \a expected are identical, execution    continues. If not, a failure is recorded in the test log and the test    won't be executed further.     In the case of comparing floats and doubles, qFuzzyCompare() is used for    comparing. This means that comparing to 0 will likely fail. One solution    to this is to compare to 1, and add 1 to the produced output.     QCOMPARE tries to output the contents of the values if the comparison fails,    so it is visible from the test log why the comparison failed.     QCOMPARE is very strict on the data types. Both \a actual and \a expected    have to be of the same type, otherwise the test won't compile. This prohibits    unspecified behavior from being introduced; that is behavior that usually    occurs when the compiler implicitly casts the argument.     For your own classes, you can use \l QTest::toString() to format values for    outputting into the test log.     \note This macro can only be used in a test function that is invoked    by the test framework.     Example:    \snippet code/src_qtestlib_qtestcase.cpp 2     \sa QVERIFY(), QTRY_COMPARE(), QTest::toString() */
comment|/*! \macro QTRY_VERIFY_WITH_TIMEOUT(condition, timeout)    \since 5.0     \relates QTest     The QTRY_VERIFY_WITH_TIMEOUT() macro is similar to QVERIFY(), but checks the \a condition    repeatedly, until either the condition becomes true or the \a timeout is    reached.  Between each evaluation, events will be processed.  If the timeout    is reached, a failure is recorded in the test log and the test won't be    executed further.     \note This macro can only be used in a test function that is invoked    by the test framework.     \sa QTRY_VERIFY(), QVERIFY(), QCOMPARE(), QTRY_COMPARE() */
comment|/*! \macro QTRY_VERIFY(condition)    \since 5.0     \relates QTest     Invokes QTRY_VERIFY_WITH_TIMEOUT() with a timeout of five seconds.     \note This macro can only be used in a test function that is invoked    by the test framework.     \sa QTRY_VERIFY_WITH_TIMEOUT(), QVERIFY(), QCOMPARE(), QTRY_COMPARE() */
comment|/*! \macro QTRY_COMPARE_WITH_TIMEOUT(actual, expected, timeout)    \since 5.0     \relates QTest     The QTRY_COMPARE_WITH_TIMEOUT() macro is similar to QCOMPARE(), but performs the comparison    of the \a actual and \a expected values repeatedly, until either the two values    are equal or the \a timeout is reached.  Between each comparison, events    will be processed.  If the timeout is reached, a failure is recorded in the    test log and the test won't be executed further.     \note This macro can only be used in a test function that is invoked    by the test framework.     \sa QTRY_COMPARE(), QCOMPARE(), QVERIFY(), QTRY_VERIFY() */
comment|/*! \macro QTRY_COMPARE(actual, expected)    \since 5.0     \relates QTest     Invokes QTRY_COMPARE_WITH_TIMEOUT() with a timeout of five seconds.     \note This macro can only be used in a test function that is invoked    by the test framework.     \sa QTRY_COMPARE_WITH_TIMEOUT(), QCOMPARE(), QVERIFY(), QTRY_VERIFY() */
comment|/*! \macro QFETCH(type, name)     \relates QTest     The fetch macro creates a local variable named \a name with the type \a type    on the stack. \a name has to match the element name from the test's data.    If no such element exists, the test will assert.     Assuming a test has the following data:     \snippet code/src_qtestlib_qtestcase.cpp 3     The test data has two elements, a QString called \c aString and an integer    called \c expected. To fetch these values in the actual test:     \snippet code/src_qtestlib_qtestcase.cpp 4     \c aString and \c expected are variables on the stack that are initialized with    the current test data.     \b {Note:} This macro can only be used in a test function that is invoked    by the test framework. The test function must have a _data function. */
comment|/*! \macro QWARN(message)     \relates QTest    \threadsafe     Appends \a message as a warning to the test log. This macro can be used anywhere    in your tests. */
comment|/*! \macro QFAIL(message)     \relates QTest     This macro can be used to force a test failure. The test stops    executing and the failure \a message is appended to the test log.     \b {Note:} This macro can only be used in a test function that is invoked    by the test framework.     Example:     \snippet code/src_qtestlib_qtestcase.cpp 5 */
comment|/*! \macro QTEST(actual, testElement)     \relates QTest     QTEST() is a convenience macro for \l QCOMPARE() that compares    the value \a actual with the element \a testElement from the test's data.    If there is no such element, the test asserts.     Apart from that, QTEST() behaves exactly as \l QCOMPARE().     Instead of writing:     \snippet code/src_qtestlib_qtestcase.cpp 6     you can write:     \snippet code/src_qtestlib_qtestcase.cpp 7     \sa QCOMPARE() */
comment|/*! \macro QSKIP(description)     \relates QTest     If called from a test function, the QSKIP() macro stops execution of the test    without adding a failure to the test log. You can use it to skip tests that    wouldn't make sense in the current configuration. The text \a description is    appended to the test log and should contain an explanation of why the test    couldn't be executed.     If the test is data-driven, each call to QSKIP() will skip only the current    row of test data, so an unconditional call to QSKIP will produce one skip    message in the test log for each row of test data.     If called from an _data function, the QSKIP() macro will stop execution of    the _data function and will prevent execution of the associated test    function.     If called from initTestCase() or initTestCase_data(), the QSKIP() macro will    skip all test and _data functions.     \b {Note:} This macro can only be used in a test function or _data    function that is invoked by the test framework.     Example:    \snippet code/src_qtestlib_qtestcase.cpp 8 */
comment|/*! \macro QEXPECT_FAIL(dataIndex, comment, mode)     \relates QTest     The QEXPECT_FAIL() macro marks the next \l QCOMPARE() or \l QVERIFY() as an    expected failure. Instead of adding a failure to the test log, an expected    failure will be reported.     If a \l QVERIFY() or \l QCOMPARE() is marked as an expected failure,    but passes instead, an unexpected pass (XPASS) is written to the test log.     The parameter \a dataIndex describes for which entry in the test data the    failure is expected. Pass an empty string (\c{""}) if the failure    is expected for all entries or if no test data exists.     \a comment will be appended to the test log for the expected failure.     \a mode is a \l QTest::TestFailMode and sets whether the test should    continue to execute or not.     \b {Note:} This macro can only be used in a test function that is invoked    by the test framework.     Example 1:    \snippet code/src_qtestlib_qtestcase.cpp 9     In the example above, an expected fail will be written into the test output    if the variable \c i is not 42. If the variable \c i is 42, an unexpected pass    is written instead. The QEXPECT_FAIL() has no influence on the second QCOMPARE()    statement in the example.     Example 2:    \snippet code/src_qtestlib_qtestcase.cpp 10     The above testfunction will not continue executing for the test data    entry \c{data27}.     \sa QTest::TestFailMode, QVERIFY(), QCOMPARE() */
comment|/*! \macro QFINDTESTDATA(filename)    \since 5.0     \relates QTest     Returns a QString for the testdata file referred to by \a filename, or an    empty QString if the testdata file could not be found.     This macro allows the test to load data from an external file without    hardcoding an absolute filename into the test, or using relative paths    which may be error prone.     The returned path will be the first path from the following list which    resolves to an existing file or directory:     \list    \li \a filename relative to QCoreApplication::applicationDirPath()       (only if a QCoreApplication or QApplication object has been created).    \li \a filename relative to the test's standard install directory       (QLibraryInfo::TestsPath with the lowercased testcase name appended).    \li \a filename relative to the directory containing the source file from which       QFINDTESTDATA is invoked.    \endlist     If the named file/directory does not exist at any of these locations,    a warning is printed to the test log.     For example, in this code:    \snippet code/src_qtestlib_qtestcase.cpp 26     The testdata file will be resolved as the first existing file from:     \list    \li \c{/home/user/build/myxmlparser/tests/tst_myxmlparser/testxml/simple1.xml}    \li \c{/usr/local/Qt-5.0.0/tests/tst_myxmlparser/testxml/simple1.xml}    \li \c{/home/user/sources/myxmlparser/tests/tst_myxmlparser/testxml/simple1.xml}    \endlist     This allows the test to find its testdata regardless of whether the    test has been installed, and regardless of whether the test's build tree    is equal to the test's source tree.     \b {Note:} reliable detection of testdata from the source directory requires    either that qmake is used, or the \c{QT_TESTCASE_BUILDDIR} macro is defined to    point to the working directory from which the compiler is invoked, or only    absolute paths to the source files are passed to the compiler. Otherwise, the    absolute path of the source directory cannot be determined.     \bold {Note:} For tests that use the \l QTEST_APPLESS_MAIN() macro to generate a    \c{main()} function, \c{QFINDTESTDATA} will not attempt to find test data    relative to QCoreApplication::applicationDirPath().  In practice, this means that    tests using \c{QTEST_APPLESS_MAIN()} will fail to find their test data    if run from a shadow build tree. */
comment|/*! \macro QTEST_MAIN(TestClass)      \relates QTest      Implements a main() function that instantiates an application object and     the \a TestClass, and executes all tests in the order they were defined.     Use this macro to build stand-alone executables.      If \c QT_WIDGETS_LIB is defined, the application object will be a QApplication,     if \c QT_GUI_LIB is defined, the application object will be a QGuiApplication,     otherwise it will be a QCoreApplication.  If qmake is used and the configuration     includes \c{QT += widgets}, then \c QT_WIDGETS_LIB will be defined automatically.     Similarly, if qmake is used and the configuration includes \c{QT += gui}, then     \c QT_GUI_LIB will be defined automatically.      \b {Note:} On platforms that have keypad navigation enabled by default,     this macro will forcefully disable it if \c QT_WIDGETS_LIB is defined.  This is done     to simplify the usage of key events when writing autotests. If you wish to write a     test case that uses keypad navigation, you should enable it either in the     \c {initTestCase()} or \c {init()} functions of your test case by calling     \l {QApplication::setNavigationMode()}.      Example:     \snippet code/src_qtestlib_qtestcase.cpp 11      \sa QTEST_APPLESS_MAIN(), QTEST_GUILESS_MAIN(), QTest::qExec(),     QApplication::setNavigationMode() */
comment|/*! \macro QTEST_APPLESS_MAIN(TestClass)      \relates QTest      Implements a main() function that executes all tests in \a TestClass.      Behaves like \l QTEST_MAIN(), but doesn't instantiate a QApplication     object. Use this macro for really simple stand-alone non-GUI tests.      \sa QTEST_MAIN() */
comment|/*! \macro QTEST_GUILESS_MAIN(TestClass)     \since 5.0      \relates QTest      Implements a main() function that instantiates a QCoreApplication object     and the \a TestClass, and executes all tests in the order they were     defined.  Use this macro to build stand-alone executables.      Behaves like \l QTEST_MAIN(), but instantiates a QCoreApplication instead     of the QApplication object. Use this macro if your test case doesn't need     functionality offered by QApplication, but the event loop is still necessary.      \sa QTEST_MAIN() */
comment|/*!     \macro QBENCHMARK      \relates QTest      This macro is used to measure the performance of code within a test.     The code to be benchmarked is contained within a code block following     this macro.      For example:      \snippet qtestlib/tutorial5/benchmarking.cpp 0      \sa {QTestLib Manual#Creating a Benchmark}{Creating a Benchmark},         {Chapter 5: Writing a Benchmark}{Writing a Benchmark} */
comment|/*!     \macro QBENCHMARK_ONCE     \since 4.6      \relates QTest      \brief The QBENCHMARK_ONCE macro is for measuring performance of a     code block by running it once.      This macro is used to measure the performance of code within a test.     The code to be benchmarked is contained within a code block following     this macro.      Unlike QBENCHMARK, the contents of the contained code block is only run     once. The elapsed time will be reported as "0" if it's to short to     be measured by the selected backend. (Use)      \sa {QTestLib Manual#Creating a Benchmark}{Creating a Benchmark},     {Chapter 5: Writing a Benchmark}{Writing a Benchmark} */
comment|/*! \enum QTest::TestFailMode      This enum describes the modes for handling an expected failure of the     \l QVERIFY() or \l QCOMPARE() macros.      \value Abort Aborts the execution of the test. Use this mode when it            doesn't make sense to execute the test any further after the            expected failure.      \value Continue Continues execution of the test after the expected failure.      \sa QEXPECT_FAIL() */
comment|/*! \enum QTest::KeyAction      This enum describes possible actions for key handling.      \value Press    The key is pressed.     \value Release  The key is released.     \value Click    The key is clicked (pressed and released). */
comment|/*! \enum QTest::MouseAction      This enum describes possible actions for mouse handling.      \value MousePress    A mouse button is pressed.     \value MouseRelease  A mouse button is released.     \value MouseClick    A mouse button is clicked (pressed and released).     \value MouseDClick   A mouse button is double clicked (pressed and released twice).     \value MouseMove     The mouse pointer has moved. */
comment|/*! \fn void QTest::keyClick(QWidget *widget, char key, Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay=-1)      \overload      Simulates clicking of \a key with an optional \a modifier on a \a widget.     If \a delay is larger than 0, the test will wait for \a delay milliseconds     before clicking the key.      Example:     \snippet code/src_qtestlib_qtestcase.cpp 13      The example above simulates clicking \c a on \c myWidget without     any keyboard modifiers and without delay of the test.      \sa QTest::keyClicks() */
comment|/*! \fn void QTest::keyClick(QWidget *widget, Qt::Key key, Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay=-1)      Simulates clicking of \a key with an optional \a modifier on a \a widget.     If \a delay is larger than 0, the test will wait for \a delay milliseconds     before clicking the key.      Examples:     \snippet code/src_qtestlib_qtestcase.cpp 14      The first example above simulates clicking the \c escape key on \c     myWidget without any keyboard modifiers and without delay. The     second example simulates clicking \c shift-escape on \c myWidget     following a 200 ms delay of the test.      \sa QTest::keyClicks() */
comment|/*! \fn void QTest::keyEvent(KeyAction action, QWidget *widget, Qt::Key key, Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay=-1)      Sends a Qt key event to \a widget with the given \a key and an associated \a action.     Optionally, a keyboard \a modifier can be specified, as well as a \a delay     (in milliseconds) of the test before sending the event. */
comment|/*! \fn void QTest::keyEvent(KeyAction action, QWidget *widget, char ascii, Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay=-1)      \overload      Sends a Qt key event to \a widget with the given key \a ascii and an associated \a action.     Optionally, a keyboard \a modifier can be specified, as well as a \a delay     (in milliseconds) of the test before sending the event.  */
comment|/*! \fn void QTest::keyPress(QWidget *widget, Qt::Key key, Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay=-1)      Simulates pressing a \a key with an optional \a modifier on a \a widget. If \a delay     is larger than 0, the test will wait for \a delay milliseconds before pressing the key.      \b {Note:} At some point you should release the key using \l keyRelease().      \sa QTest::keyRelease(), QTest::keyClick() */
comment|/*! \fn void QTest::keyPress(QWidget *widget, char key, Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay=-1)      \overload      Simulates pressing a \a key with an optional \a modifier on a \a widget.     If \a delay is larger than 0, the test will wait for \a delay milliseconds     before pressing the key.      \b {Note:} At some point you should release the key using \l keyRelease().      \sa QTest::keyRelease(), QTest::keyClick() */
comment|/*! \fn void QTest::keyRelease(QWidget *widget, Qt::Key key, Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay=-1)      Simulates releasing a \a key with an optional \a modifier on a \a widget.     If \a delay is larger than 0, the test will wait for \a delay milliseconds     before releasing the key.      \sa QTest::keyPress(), QTest::keyClick() */
comment|/*! \fn void QTest::keyRelease(QWidget *widget, char key, Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay=-1)      \overload      Simulates releasing a \a key with an optional \a modifier on a \a widget.     If \a delay is larger than 0, the test will wait for \a delay milliseconds     before releasing the key.      \sa QTest::keyClick() */
comment|/*! \fn void QTest::keyClicks(QWidget *widget, const QString&sequence, Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay=-1)      Simulates clicking a \a sequence of keys on a \a     widget. Optionally, a keyboard \a modifier can be specified as     well as a \a delay (in milliseconds) of the test before each key     click.      Example:     \snippet code/src_qtestlib_qtestcase.cpp 15      The example above simulates clicking the sequence of keys     representing "hello world" on \c myWidget without any keyboard     modifiers and without delay of the test.      \sa QTest::keyClick() */
comment|/*! \fn void QTest::mousePress(QWidget *widget, Qt::MouseButton button, Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay=-1)      Simulates pressing a mouse \a button with an optional \a modifier     on a \a widget.  The position is defined by \a pos; the default     position is the center of the widget. If \a delay is specified,     the test will wait for the specified amount of milliseconds before     the press.      \sa QTest::mouseRelease(), QTest::mouseClick() */
comment|/*! \fn void QTest::mouseRelease(QWidget *widget, Qt::MouseButton button, Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay=-1)      Simulates releasing a mouse \a button with an optional \a modifier     on a \a widget.  The position of the release is defined by \a pos;     the default position is the center of the widget. If \a delay is     specified, the test will wait for the specified amount of     milliseconds before releasing the button.      \sa QTest::mousePress(), QTest::mouseClick() */
comment|/*! \fn void QTest::mouseClick(QWidget *widget, Qt::MouseButton button, Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay=-1)      Simulates clicking a mouse \a button with an optional \a modifier     on a \a widget.  The position of the click is defined by \a pos;     the default position is the center of the widget. If \a delay is     specified, the test will wait for the specified amount of     milliseconds before pressing and before releasing the button.      \sa QTest::mousePress(), QTest::mouseRelease() */
comment|/*! \fn void QTest::mouseDClick(QWidget *widget, Qt::MouseButton button, Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay=-1)      Simulates double clicking a mouse \a button with an optional \a     modifier on a \a widget.  The position of the click is defined by     \a pos; the default position is the center of the widget. If \a     delay is specified, the test will wait for the specified amount of     milliseconds before each press and release.      \sa QTest::mouseClick() */
comment|/*! \fn void QTest::mouseMove(QWidget *widget, QPoint pos = QPoint(), int delay=-1)      Moves the mouse pointer to a \a widget. If \a pos is not     specified, the mouse pointer moves to the center of the widget. If     a \a delay (in milliseconds) is given, the test will wait before     moving the mouse pointer. */
comment|/*!     \fn char *QTest::toString(const T&value)      Returns a textual representation of \a value. This function is used by     \l QCOMPARE() to output verbose information in case of a test failure.      You can add specializations of this function to your test to enable     verbose output.      \b {Note:} The caller of toString() must delete the returned data     using \c{delete[]}.  Your implementation should return a string     created with \c{new[]} or qstrdup().      Example:      \snippet code/src_qtestlib_qtestcase.cpp 16      The example above defines a toString() specialization for a class     called \c MyPoint. Whenever a comparison of two instances of \c     MyPoint fails, \l QCOMPARE() will call this function to output the     contents of \c MyPoint to the test log.      \sa QCOMPARE() */
comment|/*!     \fn char *QTest::toString(const QLatin1String&string)     \overload      Returns a textual representation of the given \a string. */
comment|/*!     \fn char *QTest::toString(const QString&string)     \overload      Returns a textual representation of the given \a string. */
comment|/*!     \fn char *QTest::toString(const QByteArray&ba)     \overload      Returns a textual representation of the byte array \a ba.      \sa QTest::toHexRepresentation() */
comment|/*!     \fn char *QTest::toString(const QTime&time)     \overload      Returns a textual representation of the given \a time. */
comment|/*!     \fn char *QTest::toString(const QDate&date)     \overload      Returns a textual representation of the given \a date. */
comment|/*!     \fn char *QTest::toString(const QDateTime&dateTime)     \overload      Returns a textual representation of the date and time specified by     \a dateTime. */
comment|/*!     \fn char *QTest::toString(const QChar&character)     \overload      Returns a textual representation of the given \a character. */
comment|/*!     \fn char *QTest::toString(const QPoint&point)     \overload      Returns a textual representation of the given \a point. */
comment|/*!     \fn char *QTest::toString(const QSize&size)     \overload      Returns a textual representation of the given \a size. */
comment|/*!     \fn char *QTest::toString(const QRect&rectangle)     \overload      Returns a textual representation of the given \a rectangle. */
comment|/*!     \fn char *QTest::toString(const QUrl&url)     \since 4.4     \overload      Returns a textual representation of the given \a url. */
comment|/*!     \fn char *QTest::toString(const QPointF&point)     \overload      Returns a textual representation of the given \a point. */
comment|/*!     \fn char *QTest::toString(const QSizeF&size)     \overload      Returns a textual representation of the given \a size. */
comment|/*!     \fn char *QTest::toString(const QRectF&rectangle)     \overload      Returns a textual representation of the given \a rectangle. */
comment|/*!     \fn char *QTest::toString(const QVariant&variant)     \overload      Returns a textual representation of the given \a variant. */
comment|/*! \fn void QTest::qWait(int ms)      Waits for \a ms milliseconds. While waiting, events will be processed and     your test will stay responsive to user interface events or network communication.      Example:     \snippet code/src_qtestlib_qtestcase.cpp 17      The code above will wait until the network server is responding for a     maximum of about 12.5 seconds.      \sa QTest::qSleep() */
comment|/*! \fn bool QTest::qWaitForWindowExposed(QWindow *window, int timeout)     \since 5.0      Waits for \a timeout milliseconds or until the \a window is exposed.     Returns true if \c window is exposed within \a timeout milliseconds, otherwise returns false.      This is mainly useful for asynchronous systems like X11, where a window will be mapped to screen some     time after being asked to show itself on the screen.      \sa QTest::qWaitForWindowActive(), QWindow::isExposed() */
comment|/*! \fn bool QTest::qWaitForWindowActive(QWindow *window, int timeout)     \since 5.0      Waits for \a timeout milliseconds or until the \a window is active.      Returns true if \c window is active within \a timeout milliseconds, otherwise returns false.      \sa QTest::qWaitForWindowExposed(), QWindow::isActive() */
comment|/*! \fn bool QTest::qWaitForWindowShown(QWindow *window, int timeout)     \since 5.0     \deprecated      Waits for \a timeout milliseconds or until the \a window is exposed.     Returns true if \c window is exposed within \a timeout milliseconds, otherwise returns false.      This function does the same as qWaitForWindowExposed().      \sa QTest::qWaitForWindowActive(), QTest::qWaitForWindowExposed() */
comment|/*! \fn bool QTest::qWaitForWindowExposed(QWidget *widget, int timeout)     \since 5.0      Waits for \a timeout milliseconds or until the \a widget's window is exposed.     Returns true if \c widget's window is exposed within \a timeout milliseconds, otherwise returns false.      This is mainly useful for asynchronous systems like X11, where a window will be mapped to screen some     time after being asked to show itself on the screen.      \sa QTest::qWaitForWindowActive() */
comment|/*! \fn bool QTest::qWaitForWindowActive(QWidget *widget, int timeout)     \since 5.0      Waits for \a timeout milliseconds or until the \a widget's window is active.      Returns true if \c widget's window is active within \a timeout milliseconds, otherwise returns false.      \sa QTest::qWaitForWindowExposed(), QWidget::isActiveWindow() */
comment|/*! \fn bool QTest::qWaitForWindowShown(QWidget *widget, int timeout)     \since 5.0     \deprecated      Waits for \a timeout milliseconds or until the \a widget's window is exposed.     Returns true if \c widget's window is exposed within \a timeout milliseconds, otherwise returns false.      This function does the same as qWaitForWindowExposed().      Example:     \snippet code/src_qtestlib_qtestcase.cpp 24      \sa QTest::qWaitForWindowActive(), QTest::qWaitForWindowExposed() */
comment|/*!     \class QTest::QTouchEventSequence     \inmodule QtTest     \since 4.6      \brief The QTouchEventSequence class is used to simulate a sequence of touch events.      To simulate a sequence of touch events on a specific device for a window or widget, call     QTest::touchEvent to create a QTouchEventSequence instance. Add touch events to     the sequence by calling press(), move(), release() and stationary(), and let the     instance run out of scope to commit the sequence to the event system.      Example:     \snippet code/src_qtestlib_qtestcase.cpp 25 */
comment|/*!     \fn QTest::QTouchEventSequence::~QTouchEventSequence()      Commits this sequence of touch events, unless autoCommit was disabled, and frees allocated resources. */
comment|/*!   \fn void QTest::QTouchEventSequence::commit(bool processEvents)     Commits this sequence of touch events to the event system. Normally there is no need to call this    function because it is called from the destructor. However, if autoCommit is disabled, the events    only get committed upon explicitly calling this function.     In special cases tests may want to disable the processing of the events. This can be achieved by    setting \a processEvents to false. This results in merely queuing the events, the event loop will    not be forced to process them. */
comment|/*!     \fn QTouchEventSequence&QTest::QTouchEventSequence::press(int touchId, const QPoint&pt, QWindow *window)     \since 5.0      Adds a press event for touchpoint \a touchId at position \a pt to this sequence and returns     a reference to this QTouchEventSequence.      The position \a pt is interpreted as relative to \a window. If \a window is the null pointer, then     \a pt is interpreted as relative to the window provided when instantiating this QTouchEventSequence.      Simulates that the user pressed the touch screen or pad with the finger identified by \a touchId. */
comment|/*!     \fn QTouchEventSequence&QTest::QTouchEventSequence::press(int touchId, const QPoint&pt, QWidget *widget)      Adds a press event for touchpoint \a touchId at position \a pt to this sequence and returns     a reference to this QTouchEventSequence.      The position \a pt is interpreted as relative to \a widget. If \a widget is the null pointer, then     \a pt is interpreted as relative to the widget provided when instantiating this QTouchEventSequence.      Simulates that the user pressed the touch screen or pad with the finger identified by \a touchId. */
comment|/*!     \fn QTouchEventSequence&QTest::QTouchEventSequence::move(int touchId, const QPoint&pt, QWindow *window)     \since 5.0      Adds a move event for touchpoint \a touchId at position \a pt to this sequence and returns     a reference to this QTouchEventSequence.      The position \a pt is interpreted as relative to \a window. If \a widnow is the null pointer, then     \a pt is interpreted as relative to the window provided when instantiating this QTouchEventSequence.      Simulates that the user moved the finger identified by \a touchId. */
comment|/*!     \fn QTouchEventSequence&QTest::QTouchEventSequence::move(int touchId, const QPoint&pt, QWidget *widget)      Adds a move event for touchpoint \a touchId at position \a pt to this sequence and returns     a reference to this QTouchEventSequence.      The position \a pt is interpreted as relative to \a widget. If \a widget is the null pointer, then     \a pt is interpreted as relative to the widget provided when instantiating this QTouchEventSequence.      Simulates that the user moved the finger identified by \a touchId. */
comment|/*!     \fn QTouchEventSequence&QTest::QTouchEventSequence::release(int touchId, const QPoint&pt, QWindow *window)     \since 5.0      Adds a release event for touchpoint \a touchId at position \a pt to this sequence and returns     a reference to this QTouchEventSequence.      The position \a pt is interpreted as relative to \a window. If \a window is the null pointer, then     \a pt is interpreted as relative to the window provided when instantiating this QTouchEventSequence.      Simulates that the user lifted the finger identified by \a touchId. */
comment|/*!     \fn QTouchEventSequence&QTest::QTouchEventSequence::release(int touchId, const QPoint&pt, QWidget *widget)      Adds a release event for touchpoint \a touchId at position \a pt to this sequence and returns     a reference to this QTouchEventSequence.      The position \a pt is interpreted as relative to \a widget. If \a widget is the null pointer, then     \a pt is interpreted as relative to the widget provided when instantiating this QTouchEventSequence.      Simulates that the user lifted the finger identified by \a touchId. */
comment|/*!     \fn QTouchEventSequence&QTest::QTouchEventSequence::stationary(int touchId)      Adds a stationary event for touchpoint \a touchId to this sequence and returns     a reference to this QTouchEventSequence.      Simulates that the user did not move the finger identified by \a touchId. */
comment|/*!     \fn QTouchEventSequence QTest::touchEvent(QWindow *window, QTouchEvent::DeviceType deviceType, bool autoCommit)     \since 5.0      Creates and returns a QTouchEventSequence for the device \a deviceType to     simulate events for \a window.      When adding touch events to the sequence, \a window will also be used to translate     the position provided to screen coordinates, unless another window is provided in the     respective calls to press(), move() etc.      The touch events are committed to the event system when the destructor of the     QTouchEventSequence is called (ie when the object returned runs out of scope), unless     \a autoCommit is set to false. When \a autoCommit is false, commit() has to be called     manually. */
comment|/*!     \fn QTouchEventSequence QTest::touchEvent(QWidget *widget, QTouchEvent::DeviceType deviceType, bool autoCommit)      Creates and returns a QTouchEventSequence for the device \a deviceType to     simulate events for \a widget.      When adding touch events to the sequence, \a widget will also be used to translate     the position provided to screen coordinates, unless another widget is provided in the     respective calls to press(), move() etc.      The touch events are committed to the event system when the destructor of the     QTouchEventSequence is called (ie when the object returned runs out of scope), unless     \a autoCommit is set to false. When \a autoCommit is false, commit() has to be called     manually. */
DECL|function|installCoverageTool
specifier|static
name|bool
name|installCoverageTool
parameter_list|(
specifier|const
name|char
modifier|*
name|appname
parameter_list|,
specifier|const
name|char
modifier|*
name|testname
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__COVERAGESCANNER__
if|if
condition|(
operator|!
name|qgetenv
argument_list|(
literal|"QT_TESTCOCOON_ACTIVE"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// Set environment variable QT_TESTCOCOON_ACTIVE to prevent an eventual subtest from
comment|// being considered as a stand-alone test regarding the coverage analysis.
name|qputenv
argument_list|(
literal|"QT_TESTCOCOON_ACTIVE"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
comment|// Install Coverage Tool
name|__coveragescanner_install
argument_list|(
name|appname
argument_list|)
expr_stmt|;
name|__coveragescanner_testname
argument_list|(
name|testname
argument_list|)
expr_stmt|;
name|__coveragescanner_clear
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|appname
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|testname
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
endif|#
directive|endif
block|}
end_function
begin_namespace
DECL|namespace|QTest
namespace|namespace
name|QTest
block|{
DECL|member|currentTestObject
specifier|static
name|QObject
modifier|*
name|currentTestObject
init|=
literal|0
decl_stmt|;
DECL|class|TestFunction
class|class
name|TestFunction
block|{
public|public:
DECL|function|TestFunction
name|TestFunction
parameter_list|()
member_init_list|:
name|function_
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|data_
argument_list|(
literal|0
argument_list|)
block|{}
DECL|function|set
name|void
name|set
parameter_list|(
name|int
name|function
parameter_list|,
name|char
modifier|*
name|data
parameter_list|)
block|{
name|function_
operator|=
name|function
expr_stmt|;
name|data_
operator|=
name|data
expr_stmt|;
block|}
DECL|function|data
name|char
modifier|*
name|data
parameter_list|()
specifier|const
block|{
return|return
name|data_
return|;
block|}
DECL|function|function
name|int
name|function
parameter_list|()
specifier|const
block|{
return|return
name|function_
return|;
block|}
DECL|function|~TestFunction
name|~
name|TestFunction
parameter_list|()
block|{
operator|delete
index|[]
name|data_
expr_stmt|;
block|}
private|private:
DECL|member|function_
name|int
name|function_
decl_stmt|;
DECL|member|data_
name|char
modifier|*
name|data_
decl_stmt|;
block|}
class|;
comment|/**      * Contains the list of test functions that was supplied      * on the command line, if any. Hence, if not empty,      * those functions should be run instead of      * all appearing in the test case.      */
DECL|member|testFuncs
specifier|static
name|TestFunction
modifier|*
name|testFuncs
init|=
literal|0
decl_stmt|;
DECL|member|testFuncCount
specifier|static
name|int
name|testFuncCount
init|=
literal|0
decl_stmt|;
comment|/** Don't leak testFuncs on exit even on error */
DECL|struct|TestFuncCleanup
specifier|static
struct|struct
name|TestFuncCleanup
block|{
DECL|function|cleanup
name|void
name|cleanup
parameter_list|()
block|{
operator|delete
index|[]
name|testFuncs
expr_stmt|;
name|testFuncCount
operator|=
literal|0
expr_stmt|;
name|testFuncs
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|~TestFuncCleanup
name|~
name|TestFuncCleanup
parameter_list|()
block|{
name|cleanup
argument_list|()
expr_stmt|;
block|}
DECL|member|testFuncCleaner
block|}
name|testFuncCleaner
struct|;
DECL|member|keyDelay
specifier|static
name|int
name|keyDelay
init|=
operator|-
literal|1
decl_stmt|;
DECL|member|mouseDelay
specifier|static
name|int
name|mouseDelay
init|=
operator|-
literal|1
decl_stmt|;
DECL|member|eventDelay
specifier|static
name|int
name|eventDelay
init|=
operator|-
literal|1
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
DECL|member|noCrashHandler
specifier|static
name|bool
name|noCrashHandler
init|=
literal|false
decl_stmt|;
endif|#
directive|endif
comment|/*! \internal     Invoke a method of the object without generating warning if the method does not exist  */
DECL|function|invokeMethod
specifier|static
name|void
name|invokeMethod
parameter_list|(
name|QObject
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|methodName
parameter_list|)
block|{
specifier|const
name|QMetaObject
modifier|*
name|metaObject
init|=
name|obj
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|int
name|funcIndex
init|=
name|metaObject
operator|->
name|indexOfMethod
argument_list|(
name|methodName
argument_list|)
decl_stmt|;
if|if
condition|(
name|funcIndex
operator|>=
literal|0
condition|)
block|{
name|QMetaMethod
name|method
init|=
name|metaObject
operator|->
name|method
argument_list|(
name|funcIndex
argument_list|)
decl_stmt|;
name|method
operator|.
name|invoke
argument_list|(
name|obj
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|defaultEventDelay
name|int
name|defaultEventDelay
parameter_list|()
block|{
if|if
condition|(
name|eventDelay
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|qgetenv
argument_list|(
literal|"QTEST_EVENT_DELAY"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|eventDelay
operator|=
name|atoi
argument_list|(
name|qgetenv
argument_list|(
literal|"QTEST_EVENT_DELAY"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|eventDelay
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|eventDelay
return|;
block|}
DECL|function|defaultMouseDelay
name|int
name|Q_TESTLIB_EXPORT
name|defaultMouseDelay
parameter_list|()
block|{
if|if
condition|(
name|mouseDelay
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|qgetenv
argument_list|(
literal|"QTEST_MOUSEEVENT_DELAY"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|mouseDelay
operator|=
name|atoi
argument_list|(
name|qgetenv
argument_list|(
literal|"QTEST_MOUSEEVENT_DELAY"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|mouseDelay
operator|=
name|defaultEventDelay
argument_list|()
expr_stmt|;
block|}
return|return
name|mouseDelay
return|;
block|}
DECL|function|defaultKeyDelay
name|int
name|Q_TESTLIB_EXPORT
name|defaultKeyDelay
parameter_list|()
block|{
if|if
condition|(
name|keyDelay
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|qgetenv
argument_list|(
literal|"QTEST_KEYEVENT_DELAY"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|keyDelay
operator|=
name|atoi
argument_list|(
name|qgetenv
argument_list|(
literal|"QTEST_KEYEVENT_DELAY"
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|keyDelay
operator|=
name|defaultEventDelay
argument_list|()
expr_stmt|;
block|}
return|return
name|keyDelay
return|;
block|}
DECL|function|isValidSlot
specifier|static
name|bool
name|isValidSlot
parameter_list|(
specifier|const
name|QMetaMethod
modifier|&
name|sl
parameter_list|)
block|{
if|if
condition|(
name|sl
operator|.
name|access
argument_list|()
operator|!=
name|QMetaMethod
operator|::
name|Private
operator|||
name|sl
operator|.
name|parameterCount
argument_list|()
operator|!=
literal|0
operator|||
name|sl
operator|.
name|returnType
argument_list|()
operator|!=
name|QMetaType
operator|::
name|Void
operator|||
name|sl
operator|.
name|methodType
argument_list|()
operator|!=
name|QMetaMethod
operator|::
name|Slot
condition|)
return|return
literal|false
return|;
name|QByteArray
name|name
init|=
name|sl
operator|.
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|name
operator|.
name|endsWith
argument_list|(
literal|"_data"
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|name
operator|==
literal|"initTestCase"
operator|||
name|name
operator|==
literal|"cleanupTestCase"
operator|||
name|name
operator|==
literal|"cleanup"
operator|||
name|name
operator|==
literal|"init"
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
DECL|member|printAvailableFunctions
name|Q_TESTLIB_EXPORT
name|bool
name|printAvailableFunctions
init|=
literal|false
decl_stmt|;
DECL|member|testFunctions
name|Q_TESTLIB_EXPORT
name|QStringList
name|testFunctions
decl_stmt|;
DECL|member|testTags
name|Q_TESTLIB_EXPORT
name|QStringList
name|testTags
decl_stmt|;
DECL|function|qPrintTestSlots
specifier|static
name|void
name|qPrintTestSlots
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|QTest
operator|::
name|currentTestObject
operator|->
name|metaObject
argument_list|()
operator|->
name|methodCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QMetaMethod
name|sl
init|=
name|QTest
operator|::
name|currentTestObject
operator|->
name|metaObject
argument_list|()
operator|->
name|method
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|isValidSlot
argument_list|(
name|sl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s\n"
argument_list|,
name|sl
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|qPrintDataTags
specifier|static
name|void
name|qPrintDataTags
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
comment|// Avoid invoking the actual test functions, and also avoid printing irrelevant output:
name|QTestLog
operator|::
name|setPrintAvailableTagsMode
argument_list|()
expr_stmt|;
comment|// Get global data tags:
name|QTestTable
operator|::
name|globalTestTable
argument_list|()
expr_stmt|;
name|invokeMethod
argument_list|(
name|QTest
operator|::
name|currentTestObject
argument_list|,
literal|"initTestCase_data()"
argument_list|)
expr_stmt|;
specifier|const
name|QTestTable
modifier|*
name|gTable
init|=
name|QTestTable
operator|::
name|globalTestTable
argument_list|()
decl_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|currTestMetaObj
init|=
name|QTest
operator|::
name|currentTestObject
operator|->
name|metaObject
argument_list|()
decl_stmt|;
comment|// Process test functions:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|currTestMetaObj
operator|->
name|methodCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QMetaMethod
name|tf
init|=
name|currTestMetaObj
operator|->
name|method
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|isValidSlot
argument_list|(
name|tf
argument_list|)
condition|)
block|{
comment|// Retrieve local tags:
name|QStringList
name|localTags
decl_stmt|;
name|QTestTable
name|table
decl_stmt|;
name|char
modifier|*
name|slot
init|=
name|qstrdup
argument_list|(
name|tf
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|slot
index|[
name|strlen
argument_list|(
name|slot
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|QByteArray
name|member
decl_stmt|;
name|member
operator|.
name|resize
argument_list|(
name|qstrlen
argument_list|(
name|slot
argument_list|)
operator|+
name|qstrlen
argument_list|(
literal|"_data()"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|qsnprintf
argument_list|(
name|member
operator|.
name|data
argument_list|()
argument_list|,
name|member
operator|.
name|size
argument_list|()
argument_list|,
literal|"%s_data()"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|invokeMethod
argument_list|(
name|QTest
operator|::
name|currentTestObject
argument_list|,
name|member
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|table
operator|.
name|dataCount
argument_list|()
condition|;
operator|++
name|j
control|)
name|localTags
operator|<<
name|QLatin1String
argument_list|(
name|table
operator|.
name|testData
argument_list|(
name|j
argument_list|)
operator|->
name|dataTag
argument_list|()
argument_list|)
expr_stmt|;
comment|// Print all tag combinations:
if|if
condition|(
name|gTable
operator|->
name|dataCount
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|localTags
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// No tags at all, so just print the test function:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s %s\n"
argument_list|,
name|currTestMetaObj
operator|->
name|className
argument_list|()
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Only local tags, so print each of them:
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|localTags
operator|.
name|size
argument_list|()
condition|;
operator|++
name|k
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s %s %s\n"
argument_list|,
name|currTestMetaObj
operator|->
name|className
argument_list|()
argument_list|,
name|slot
argument_list|,
name|localTags
operator|.
name|at
argument_list|(
name|k
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|gTable
operator|->
name|dataCount
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|localTags
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Only global tags, so print the current one:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s %s __global__ %s\n"
argument_list|,
name|currTestMetaObj
operator|->
name|className
argument_list|()
argument_list|,
name|slot
argument_list|,
name|gTable
operator|->
name|testData
argument_list|(
name|j
argument_list|)
operator|->
name|dataTag
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Local and global tags, so print each of the local ones and
comment|// the current global one:
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|localTags
operator|.
name|size
argument_list|()
condition|;
operator|++
name|k
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s %s %s __global__ %s\n"
argument_list|,
name|currTestMetaObj
operator|->
name|className
argument_list|()
argument_list|,
name|slot
argument_list|,
name|localTags
operator|.
name|at
argument_list|(
name|k
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|gTable
operator|->
name|testData
argument_list|(
name|j
argument_list|)
operator|->
name|dataTag
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|delete
index|[]
name|slot
expr_stmt|;
block|}
block|}
block|}
DECL|function|qToInt
specifier|static
name|int
name|qToInt
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|pEnd
decl_stmt|;
name|int
name|l
init|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|str
argument_list|,
operator|&
name|pEnd
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|pEnd
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid numeric parameter: '%s'\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
DECL|function|qtest_qParseArgs
name|Q_TESTLIB_EXPORT
name|void
name|qtest_qParseArgs
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|bool
name|qml
parameter_list|)
block|{
name|QTestLog
operator|::
name|LogMode
name|logFormat
init|=
name|QTestLog
operator|::
name|Plain
decl_stmt|;
specifier|const
name|char
modifier|*
name|logFilename
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|testOptions
init|=
literal|" New-style logging options:\n"
literal|" -o filename,format  : Output results to file in the specified format\n"
literal|"                       Use - to output to stdout\n"
literal|"                       Valid formats are:\n"
literal|"                         txt      : Plain text\n"
literal|"                         xunitxml : XML XUnit document\n"
literal|"                         xml      : XML document\n"
literal|"                         lightxml : A stream of XML tags\n"
literal|"\n"
literal|"     *** Multiple loggers can be specified, but at most one can log to stdout.\n"
literal|"\n"
literal|" Old-style logging options:\n"
literal|" -o filename         : Write the output into file\n"
literal|" -txt                : Output results in Plain Text\n"
literal|" -xunitxml           : Output results as XML XUnit document\n"
literal|" -xml                : Output results as XML document\n"
literal|" -lightxml           : Output results as stream of XML tags\n"
literal|"\n"
literal|"     *** If no output file is specified, stdout is assumed.\n"
literal|"     *** If no output format is specified, -txt is assumed.\n"
literal|"\n"
literal|" Test log detail options:\n"
literal|" -silent             : Log failures and fatal errors only\n"
literal|" -v1                 : Log the start of each testfunction\n"
literal|" -v2                 : Log each QVERIFY/QCOMPARE/QTEST (implies -v1)\n"
literal|" -vs                 : Log every signal emission and resulting slot invocations\n"
literal|"\n"
literal|"     *** The -silent and -v1 options only affect plain text output.\n"
literal|"\n"
literal|" Testing options:\n"
literal|" -functions          : Returns a list of current testfunctions\n"
literal|" -datatags           : Returns a list of current data tags.\n"
literal|"                       A global data tag is preceded by ' __global__ '.\n"
literal|" -eventdelay ms      : Set default delay for mouse and keyboard simulation to ms milliseconds\n"
literal|" -keydelay ms        : Set default delay for keyboard simulation to ms milliseconds\n"
literal|" -mousedelay ms      : Set default delay for mouse simulation to ms milliseconds\n"
literal|" -maxwarnings n      : Sets the maximum amount of messages to output.\n"
literal|"                       0 means unlimited, default: 2000\n"
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
literal|" -nocrashhandler     : Disables the crash handler\n"
endif|#
directive|endif
literal|"\n"
literal|" Benchmarking options:\n"
ifdef|#
directive|ifdef
name|QTESTLIB_USE_VALGRIND
literal|" -callgrind          : Use callgrind to time benchmarks\n"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TICK_COUNTER
literal|" -tickcounter        : Use CPU tick counters to time benchmarks\n"
endif|#
directive|endif
literal|" -eventcounter       : Counts events received during benchmarks\n"
literal|" -minimumvalue n     : Sets the minimum acceptable measurement value\n"
literal|" -iterations  n      : Sets the number of accumulation iterations.\n"
literal|" -median  n          : Sets the number of median iterations.\n"
literal|" -vb                 : Print out verbose benchmarking information.\n"
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-help"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--help"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"/?"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" Usage: %s [options] [testfunction[:testdata]]...\n"
literal|"    By default, all testfunctions will be run.\n\n"
literal|"%s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|testOptions
argument_list|)
expr_stmt|;
if|if
condition|(
name|qml
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
literal|" QmlTest options:\n"
literal|" -import dir         : Specify an import directory.\n"
literal|" -input dir/file     : Specify the root directory for test cases or a single test case file.\n"
literal|" -qtquick1           : Run with QtQuick 1 rather than QtQuick 2.\n"
literal|" -translation file   : Specify the translation file.\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
literal|" -help               : This help\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-functions"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|qml
condition|)
block|{
name|QTest
operator|::
name|printAvailableFunctions
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|qPrintTestSlots
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-datatags"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|qml
condition|)
block|{
name|qPrintDataTags
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-txt"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|logFormat
operator|=
name|QTestLog
operator|::
name|Plain
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-xunitxml"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|logFormat
operator|=
name|QTestLog
operator|::
name|XunitXML
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-xml"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|logFormat
operator|=
name|QTestLog
operator|::
name|XML
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lightxml"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|logFormat
operator|=
name|QTestLog
operator|::
name|LightXML
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-silent"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|QTestLog
operator|::
name|setVerboseLevel
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-v1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|QTestLog
operator|::
name|setVerboseLevel
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-v2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|QTestLog
operator|::
name|setVerboseLevel
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-vs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|QSignalDumper
operator|::
name|startDump
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-o"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-o needs an extra parameter specifying the filename and optional format\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
comment|// Do we have the old or new style -o option?
name|char
modifier|*
name|filename
init|=
operator|new
name|char
index|[
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|format
init|=
operator|new
name|char
index|[
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"%[^,],%s"
argument_list|,
name|filename
argument_list|,
name|format
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|// Old-style
name|logFilename
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// New-style
if|if
condition|(
name|strcmp
argument_list|(
name|format
argument_list|,
literal|"txt"
argument_list|)
operator|==
literal|0
condition|)
name|logFormat
operator|=
name|QTestLog
operator|::
name|Plain
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|format
argument_list|,
literal|"lightxml"
argument_list|)
operator|==
literal|0
condition|)
name|logFormat
operator|=
name|QTestLog
operator|::
name|LightXML
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|format
argument_list|,
literal|"xml"
argument_list|)
operator|==
literal|0
condition|)
name|logFormat
operator|=
name|QTestLog
operator|::
name|XML
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|format
argument_list|,
literal|"xunitxml"
argument_list|)
operator|==
literal|0
condition|)
name|logFormat
operator|=
name|QTestLog
operator|::
name|XunitXML
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"output format must be one of txt, lightxml, xml or xunitxml\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|&&
name|QTestLog
operator|::
name|loggerUsingStdout
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"only one logger can log to stdout\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|QTestLog
operator|::
name|addLogger
argument_list|(
name|logFormat
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
operator|delete
index|[]
name|filename
expr_stmt|;
operator|delete
index|[]
name|format
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-eventdelay"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-eventdelay needs an extra parameter to indicate the delay(ms)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QTest
operator|::
name|eventDelay
operator|=
name|qToInt
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-keydelay"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-keydelay needs an extra parameter to indicate the delay(ms)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QTest
operator|::
name|keyDelay
operator|=
name|qToInt
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mousedelay"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-mousedelay needs an extra parameter to indicate the delay(ms)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QTest
operator|::
name|mouseDelay
operator|=
name|qToInt
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-maxwarnings"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-maxwarnings needs an extra parameter with the amount of warnings\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QTestLog
operator|::
name|setMaxWarnings
argument_list|(
name|qToInt
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nocrashhandler"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|QTest
operator|::
name|noCrashHandler
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QTESTLIB_USE_VALGRIND
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-callgrind"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|QBenchmarkValgrindUtils
operator|::
name|haveValgrind
argument_list|()
condition|)
if|if
condition|(
name|QFileInfo
argument_list|(
name|QDir
operator|::
name|currentPath
argument_list|()
argument_list|)
operator|.
name|isWritable
argument_list|()
condition|)
block|{
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|setMode
argument_list|(
name|QBenchmarkGlobalData
operator|::
name|CallgrindParentProcess
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: Current directory not writable. Using the walltime measurer.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: Valgrind not found or too old. Make sure it is installed and in your path. "
literal|"Using the walltime measurer.\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-callgrindchild"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// "private" option
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|setMode
argument_list|(
name|QBenchmarkGlobalData
operator|::
name|CallgrindChildProcess
argument_list|)
expr_stmt|;
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|callgrindOutFileBase
operator|=
name|QBenchmarkValgrindUtils
operator|::
name|outFileBase
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TICK_COUNTER
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-tickcounter"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|setMode
argument_list|(
name|QBenchmarkGlobalData
operator|::
name|TickCounter
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-eventcounter"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|setMode
argument_list|(
name|QBenchmarkGlobalData
operator|::
name|EventCounter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-minimumvalue"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-minimumvalue needs an extra parameter to indicate the minimum time(ms)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|walltimeMinimum
operator|=
name|qToInt
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iterations"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-iterations needs an extra parameter to indicate the number of iterations\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|iterationCount
operator|=
name|qToInt
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-median"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-median needs an extra parameter to indicate the number of median iterations\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|medianIterationCount
operator|=
name|qToInt
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-vb"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|verboseOutput
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown option: '%s'\n\n%s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|testOptions
argument_list|)
expr_stmt|;
if|if
condition|(
name|qml
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nqmltest related options:\n"
literal|" -import    : Specify an import directory.\n"
literal|" -input     : Specify the root directory for test cases.\n"
literal|" -qtquick1  : Run with QtQuick 1 rather than QtQuick 2.\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
literal|" -help      : This help\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qml
condition|)
block|{
comment|// We can't check the availability of test functions until
comment|// we load the QML files.  So just store the data for now.
name|int
name|colon
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|offset
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
operator|*
operator|(
name|argv
index|[
name|i
index|]
operator|+
name|offset
operator|)
condition|;
operator|++
name|offset
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|argv
index|[
name|i
index|]
operator|+
name|offset
operator|)
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|argv
index|[
name|i
index|]
operator|+
name|offset
operator|+
literal|1
operator|)
operator|==
literal|':'
condition|)
block|{
comment|// "::" is used as a test name separator.
comment|// e.g. "ClickTests::test_click:row1".
operator|++
name|offset
expr_stmt|;
block|}
else|else
block|{
name|colon
operator|=
name|offset
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|colon
operator|==
operator|-
literal|1
condition|)
block|{
name|QTest
operator|::
name|testFunctions
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|testTags
operator|+=
name|QString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QTest
operator|::
name|testFunctions
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|QTest
operator|::
name|testTags
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|colon
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|QTest
operator|::
name|testFuncs
condition|)
block|{
name|QTest
operator|::
name|testFuncs
operator|=
operator|new
name|QTest
operator|::
name|TestFunction
index|[
literal|512
index|]
expr_stmt|;
block|}
name|int
name|colon
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|data
init|=
literal|0
decl_stmt|;
name|int
name|off
decl_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
operator|*
operator|(
name|argv
index|[
name|i
index|]
operator|+
name|off
operator|)
condition|;
operator|++
name|off
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|argv
index|[
name|i
index|]
operator|+
name|off
operator|)
operator|==
literal|':'
condition|)
block|{
name|colon
operator|=
name|off
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|colon
operator|!=
operator|-
literal|1
condition|)
block|{
name|data
operator|=
name|qstrdup
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
name|colon
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|qsnprintf
argument_list|(
name|buf
argument_list|,
name|qMin
argument_list|(
literal|512
argument_list|,
name|off
operator|+
literal|1
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|// copy text before the ':' into buf
name|qsnprintf
argument_list|(
name|buf
operator|+
name|off
argument_list|,
name|qMin
argument_list|(
literal|512
operator|-
name|off
argument_list|,
literal|3
argument_list|)
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
comment|// append "()"
name|int
name|idx
init|=
name|QTest
operator|::
name|currentTestObject
operator|->
name|metaObject
argument_list|()
operator|->
name|indexOfMethod
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
operator|!
name|isValidSlot
argument_list|(
name|QTest
operator|::
name|currentTestObject
operator|->
name|metaObject
argument_list|()
operator|->
name|method
argument_list|(
name|idx
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown testfunction: '%s'\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Available testfunctions:\n"
argument_list|)
expr_stmt|;
name|qPrintTestSlots
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|testFuncs
index|[
name|testFuncCount
index|]
operator|.
name|set
argument_list|(
name|idx
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|testFuncCount
operator|++
expr_stmt|;
name|QTEST_ASSERT
argument_list|(
name|QTest
operator|::
name|testFuncCount
operator|<
literal|512
argument_list|)
expr_stmt|;
block|}
block|}
name|bool
name|installedTestCoverage
init|=
name|installCoverageTool
argument_list|(
name|QTestResult
operator|::
name|currentAppname
argument_list|()
argument_list|,
name|QTestResult
operator|::
name|currentTestObjectName
argument_list|()
argument_list|)
decl_stmt|;
name|QTestLog
operator|::
name|setInstalledTestCoverage
argument_list|(
name|installedTestCoverage
argument_list|)
expr_stmt|;
comment|// If no loggers were created by the long version of the -o command-line
comment|// option, create a logger using whatever filename and format were
comment|// set using the old-style command-line options.
if|if
condition|(
name|QTestLog
operator|::
name|loggerCount
argument_list|()
operator|==
literal|0
condition|)
name|QTestLog
operator|::
name|addLogger
argument_list|(
name|logFormat
argument_list|,
name|logFilename
argument_list|)
expr_stmt|;
block|}
DECL|function|qMedian
name|QBenchmarkResult
name|qMedian
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QBenchmarkResult
argument_list|>
modifier|&
name|container
parameter_list|)
block|{
specifier|const
name|int
name|count
init|=
name|container
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|QBenchmarkResult
argument_list|()
return|;
if|if
condition|(
name|count
operator|==
literal|1
condition|)
return|return
name|container
operator|.
name|at
argument_list|(
literal|0
argument_list|)
return|;
name|QList
argument_list|<
name|QBenchmarkResult
argument_list|>
name|containerCopy
init|=
name|container
decl_stmt|;
name|qSort
argument_list|(
name|containerCopy
argument_list|)
expr_stmt|;
specifier|const
name|int
name|middle
init|=
name|count
operator|/
literal|2
decl_stmt|;
comment|// ### handle even-sized containers here by doing an aritmetic mean of the two middle items.
return|return
name|containerCopy
operator|.
name|at
argument_list|(
name|middle
argument_list|)
return|;
block|}
DECL|struct|QTestDataSetter
struct|struct
name|QTestDataSetter
block|{
DECL|function|QTestDataSetter
name|QTestDataSetter
parameter_list|(
name|QTestData
modifier|*
name|data
parameter_list|)
block|{
name|QTestResult
operator|::
name|setCurrentTestData
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
DECL|function|~QTestDataSetter
name|~
name|QTestDataSetter
parameter_list|()
block|{
name|QTestResult
operator|::
name|setCurrentTestData
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
struct|;
DECL|function|qInvokeTestMethodDataEntry
specifier|static
name|void
name|qInvokeTestMethodDataEntry
parameter_list|(
name|char
modifier|*
name|slot
parameter_list|)
block|{
comment|/* Benchmarking: for each median iteration*/
name|bool
name|isBenchmark
init|=
literal|false
decl_stmt|;
name|int
name|i
init|=
operator|(
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|measurer
operator|->
name|needsWarmupIteration
argument_list|()
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
decl_stmt|;
name|QList
argument_list|<
name|QBenchmarkResult
argument_list|>
name|results
decl_stmt|;
do|do
block|{
name|QBenchmarkTestMethodData
operator|::
name|current
operator|->
name|beginDataRun
argument_list|()
expr_stmt|;
comment|/* Benchmarking: for each accumulation iteration*/
name|bool
name|invokeOk
decl_stmt|;
do|do
block|{
name|invokeMethod
argument_list|(
name|QTest
operator|::
name|currentTestObject
argument_list|,
literal|"init()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|QTestResult
operator|::
name|skipCurrentTest
argument_list|()
operator|||
name|QTestResult
operator|::
name|currentTestFailed
argument_list|()
condition|)
break|break;
name|QBenchmarkTestMethodData
operator|::
name|current
operator|->
name|result
operator|=
name|QBenchmarkResult
argument_list|()
expr_stmt|;
name|QBenchmarkTestMethodData
operator|::
name|current
operator|->
name|resultAccepted
operator|=
literal|false
expr_stmt|;
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|context
operator|.
name|tag
operator|=
name|QLatin1String
argument_list|(
name|QTestResult
operator|::
name|currentDataTag
argument_list|()
condition|?
name|QTestResult
operator|::
name|currentDataTag
argument_list|()
else|:
literal|""
argument_list|)
expr_stmt|;
name|invokeOk
operator|=
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|QTest
operator|::
name|currentTestObject
argument_list|,
name|slot
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|invokeOk
condition|)
name|QTestResult
operator|::
name|addFailure
argument_list|(
literal|"Unable to execute slot"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|isBenchmark
operator|=
name|QBenchmarkTestMethodData
operator|::
name|current
operator|->
name|isBenchmark
argument_list|()
expr_stmt|;
name|QTestResult
operator|::
name|finishedCurrentTestData
argument_list|()
expr_stmt|;
name|invokeMethod
argument_list|(
name|QTest
operator|::
name|currentTestObject
argument_list|,
literal|"cleanup()"
argument_list|)
expr_stmt|;
comment|// If the test isn't a benchmark, finalize the result after cleanup() has finished.
if|if
condition|(
operator|!
name|isBenchmark
condition|)
name|QTestResult
operator|::
name|finishedCurrentTestDataCleanup
argument_list|()
expr_stmt|;
comment|// If this test method has a benchmark, repeat until all measurements are
comment|// acceptable.
comment|// The QBENCHMARK macro increases the number of iterations for each run until
comment|// this happens.
block|}
do|while
condition|(
name|invokeOk
operator|&&
name|isBenchmark
operator|&&
name|QBenchmarkTestMethodData
operator|::
name|current
operator|->
name|resultsAccepted
argument_list|()
operator|==
literal|false
operator|&&
operator|!
name|QTestResult
operator|::
name|skipCurrentTest
argument_list|()
operator|&&
operator|!
name|QTestResult
operator|::
name|currentTestFailed
argument_list|()
condition|)
do|;
name|QBenchmarkTestMethodData
operator|::
name|current
operator|->
name|endDataRun
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|QTestResult
operator|::
name|skipCurrentTest
argument_list|()
operator|&&
operator|!
name|QTestResult
operator|::
name|currentTestFailed
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|>
operator|-
literal|1
condition|)
comment|// iteration -1 is the warmup iteration.
name|results
operator|.
name|append
argument_list|(
name|QBenchmarkTestMethodData
operator|::
name|current
operator|->
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|isBenchmark
operator|&&
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|verboseOutput
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|QTestLog
operator|::
name|info
argument_list|(
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"warmup stage result      : %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|QBenchmarkTestMethodData
operator|::
name|current
operator|->
name|result
operator|.
name|value
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QTestLog
operator|::
name|info
argument_list|(
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"accumulation stage result: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|QBenchmarkTestMethodData
operator|::
name|current
operator|->
name|result
operator|.
name|value
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|isBenchmark
operator|&&
operator|(
operator|++
name|i
operator|<
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|adjustMedianIterationCount
argument_list|()
operator|)
operator|&&
operator|!
name|QTestResult
operator|::
name|skipCurrentTest
argument_list|()
operator|&&
operator|!
name|QTestResult
operator|::
name|currentTestFailed
argument_list|()
condition|)
do|;
comment|// If the test is a benchmark, finalize the result after all iterations have finished.
if|if
condition|(
name|isBenchmark
condition|)
block|{
name|bool
name|testPassed
init|=
operator|!
name|QTestResult
operator|::
name|skipCurrentTest
argument_list|()
operator|&&
operator|!
name|QTestResult
operator|::
name|currentTestFailed
argument_list|()
decl_stmt|;
name|QTestResult
operator|::
name|finishedCurrentTestDataCleanup
argument_list|()
expr_stmt|;
comment|// Only report benchmark figures if the test passed
if|if
condition|(
name|testPassed
operator|&&
name|QBenchmarkTestMethodData
operator|::
name|current
operator|->
name|resultsAccepted
argument_list|()
condition|)
name|QTestLog
operator|::
name|addBenchmarkResult
argument_list|(
name|qMedian
argument_list|(
name|results
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*!     \internal      Call slot_data(), init(), slot(), cleanup(), init(), slot(), cleanup(), ...     If data is set then it is the only test that is performed      If the function was successfully called, true is returned, otherwise     false.  */
DECL|function|qInvokeTestMethod
specifier|static
name|bool
name|qInvokeTestMethod
parameter_list|(
specifier|const
name|char
modifier|*
name|slotName
parameter_list|,
specifier|const
name|char
modifier|*
name|data
init|=
literal|0
parameter_list|)
block|{
name|QTEST_ASSERT
argument_list|(
name|slotName
argument_list|)
expr_stmt|;
name|QBenchmarkTestMethodData
name|benchmarkData
decl_stmt|;
name|QBenchmarkTestMethodData
operator|::
name|current
operator|=
operator|&
name|benchmarkData
expr_stmt|;
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|context
operator|.
name|slotName
operator|=
name|QLatin1String
argument_list|(
name|slotName
argument_list|)
expr_stmt|;
name|char
name|member
index|[
literal|512
index|]
decl_stmt|;
name|QTestTable
name|table
decl_stmt|;
name|char
modifier|*
name|slot
init|=
name|qstrdup
argument_list|(
name|slotName
argument_list|)
decl_stmt|;
name|slot
index|[
name|strlen
argument_list|(
name|slot
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|QTestResult
operator|::
name|setCurrentTestFunction
argument_list|(
name|slot
argument_list|)
expr_stmt|;
specifier|const
name|QTestTable
modifier|*
name|gTable
init|=
name|QTestTable
operator|::
name|globalTestTable
argument_list|()
decl_stmt|;
specifier|const
name|int
name|globalDataCount
init|=
name|gTable
operator|->
name|dataCount
argument_list|()
decl_stmt|;
name|int
name|curGlobalDataIndex
init|=
literal|0
decl_stmt|;
comment|/* For each test function that has a *_data() table/function, do: */
do|do
block|{
if|if
condition|(
operator|!
name|gTable
operator|->
name|isEmpty
argument_list|()
condition|)
name|QTestResult
operator|::
name|setCurrentGlobalTestData
argument_list|(
name|gTable
operator|->
name|testData
argument_list|(
name|curGlobalDataIndex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curGlobalDataIndex
operator|==
literal|0
condition|)
block|{
name|qsnprintf
argument_list|(
name|member
argument_list|,
literal|512
argument_list|,
literal|"%s_data()"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|invokeMethod
argument_list|(
name|QTest
operator|::
name|currentTestObject
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
name|bool
name|foundFunction
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|QTestResult
operator|::
name|skipCurrentTest
argument_list|()
condition|)
block|{
name|int
name|curDataIndex
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|dataCount
init|=
name|table
operator|.
name|dataCount
argument_list|()
decl_stmt|;
comment|// Data tag requested but none available?
if|if
condition|(
name|data
operator|&&
operator|!
name|dataCount
condition|)
block|{
comment|// Let empty data tag through.
if|if
condition|(
operator|!
operator|*
name|data
condition|)
name|data
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown testdata for function %s: '%s'\n"
argument_list|,
name|slotName
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Function has no testdata.\n"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/* For each entry in the data table, do: */
do|do
block|{
name|QTestResult
operator|::
name|setSkipCurrentTest
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|||
operator|!
name|qstrcmp
argument_list|(
name|data
argument_list|,
name|table
operator|.
name|testData
argument_list|(
name|curDataIndex
argument_list|)
operator|->
name|dataTag
argument_list|()
argument_list|)
condition|)
block|{
name|foundFunction
operator|=
literal|true
expr_stmt|;
name|QTestDataSetter
name|s
argument_list|(
name|curDataIndex
operator|>=
name|dataCount
condition|?
cast|static_cast
argument_list|<
name|QTestData
operator|*
argument_list|>
argument_list|(
literal|0
argument_list|)
else|:
name|table
operator|.
name|testData
argument_list|(
name|curDataIndex
argument_list|)
argument_list|)
decl_stmt|;
name|qInvokeTestMethodDataEntry
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
break|break;
block|}
operator|++
name|curDataIndex
expr_stmt|;
block|}
do|while
condition|(
name|curDataIndex
operator|<
name|dataCount
condition|)
do|;
block|}
if|if
condition|(
name|data
operator|&&
operator|!
name|foundFunction
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown testdata for function %s: '%s'\n"
argument_list|,
name|slotName
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Available testdata:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|table
operator|.
name|dataCount
argument_list|()
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|table
operator|.
name|testData
argument_list|(
name|i
argument_list|)
operator|->
name|dataTag
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QTestResult
operator|::
name|setCurrentGlobalTestData
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|++
name|curGlobalDataIndex
expr_stmt|;
block|}
do|while
condition|(
name|curGlobalDataIndex
operator|<
name|globalDataCount
condition|)
do|;
name|QTestResult
operator|::
name|finishedCurrentTestFunction
argument_list|()
expr_stmt|;
name|QTestResult
operator|::
name|setSkipCurrentTest
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|QTestResult
operator|::
name|setCurrentTestData
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|slot
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|fetchData
name|void
modifier|*
name|fetchData
parameter_list|(
name|QTestData
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|tagName
parameter_list|,
name|int
name|typeId
parameter_list|)
block|{
name|QTEST_ASSERT
argument_list|(
name|typeId
argument_list|)
expr_stmt|;
name|QTEST_ASSERT_X
argument_list|(
name|data
argument_list|,
literal|"QTest::fetchData()"
argument_list|,
literal|"Test data requested, but no testdata available."
argument_list|)
expr_stmt|;
name|QTEST_ASSERT
argument_list|(
name|data
operator|->
name|parent
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|idx
init|=
name|data
operator|->
name|parent
argument_list|()
operator|->
name|indexOf
argument_list|(
name|tagName
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|idx
operator|>=
name|data
operator|->
name|dataCount
argument_list|()
condition|)
block|{
name|qFatal
argument_list|(
literal|"QFETCH: Requested testdata '%s' not available, check your _data function."
argument_list|,
name|tagName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typeId
operator|!=
name|data
operator|->
name|parent
argument_list|()
operator|->
name|elementTypeId
argument_list|(
name|idx
argument_list|)
condition|)
block|{
name|qFatal
argument_list|(
literal|"Requested type '%s' does not match available type '%s'."
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|typeId
argument_list|)
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|data
operator|->
name|parent
argument_list|()
operator|->
name|elementTypeId
argument_list|(
name|idx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|data
operator|->
name|data
argument_list|(
name|idx
argument_list|)
return|;
block|}
comment|/*!   \fn char* QTest::toHexRepresentation(const char *ba, int length)    Returns a pointer to a string that is the string \a ba represented   as a space-separated sequence of hex characters. If the input is   considered too long, it is truncated. A trucation is indicated in   the returned string as an ellipsis at the end.    \a length is the length of the string \a ba.  */
DECL|function|toHexRepresentation
name|char
modifier|*
name|toHexRepresentation
parameter_list|(
specifier|const
name|char
modifier|*
name|ba
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return
name|qstrdup
argument_list|(
literal|""
argument_list|)
return|;
comment|/* We output at maximum about maxLen characters in order to avoid      * running out of memory and flooding things when the byte array      * is large.      *      * maxLen can't be for example 200 because QTestLib is sprinkled with fixed      * size char arrays.      * */
specifier|const
name|int
name|maxLen
init|=
literal|50
decl_stmt|;
specifier|const
name|int
name|len
init|=
name|qMin
argument_list|(
name|maxLen
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|maxLen
condition|)
block|{
specifier|const
name|int
name|size
init|=
name|len
operator|*
literal|3
operator|+
literal|4
decl_stmt|;
name|result
operator|=
operator|new
name|char
index|[
name|size
index|]
expr_stmt|;
name|char
modifier|*
specifier|const
name|forElipsis
init|=
name|result
operator|+
name|size
operator|-
literal|5
decl_stmt|;
name|forElipsis
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|forElipsis
index|[
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
name|forElipsis
index|[
literal|2
index|]
operator|=
literal|'.'
expr_stmt|;
name|forElipsis
index|[
literal|3
index|]
operator|=
literal|'.'
expr_stmt|;
name|result
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|size
init|=
name|len
operator|*
literal|3
decl_stmt|;
name|result
operator|=
operator|new
name|char
index|[
name|size
index|]
expr_stmt|;
name|result
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
specifier|const
name|char
name|toHex
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|o
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|const
name|char
name|at
init|=
name|ba
index|[
name|i
index|]
decl_stmt|;
name|result
index|[
name|o
index|]
operator|=
name|toHex
index|[
operator|(
name|at
operator|>>
literal|4
operator|)
operator|&
literal|0x0F
index|]
expr_stmt|;
operator|++
name|o
expr_stmt|;
name|result
index|[
name|o
index|]
operator|=
name|toHex
index|[
name|at
operator|&
literal|0x0F
index|]
expr_stmt|;
operator|++
name|i
expr_stmt|;
operator|++
name|o
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|len
condition|)
break|break;
else|else
block|{
name|result
index|[
name|o
index|]
operator|=
literal|' '
expr_stmt|;
operator|++
name|o
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|function|qInvokeTestMethods
specifier|static
name|void
name|qInvokeTestMethods
parameter_list|(
name|QObject
modifier|*
name|testObject
parameter_list|)
block|{
specifier|const
name|QMetaObject
modifier|*
name|metaObject
init|=
name|testObject
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|QTEST_ASSERT
argument_list|(
name|metaObject
argument_list|)
expr_stmt|;
name|QTestLog
operator|::
name|startLogging
argument_list|()
expr_stmt|;
name|QTestResult
operator|::
name|setCurrentTestFunction
argument_list|(
literal|"initTestCase"
argument_list|)
expr_stmt|;
name|QTestTable
operator|::
name|globalTestTable
argument_list|()
expr_stmt|;
name|invokeMethod
argument_list|(
name|testObject
argument_list|,
literal|"initTestCase_data()"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QTestResult
operator|::
name|skipCurrentTest
argument_list|()
operator|&&
operator|!
name|QTest
operator|::
name|currentTestFailed
argument_list|()
condition|)
block|{
name|invokeMethod
argument_list|(
name|testObject
argument_list|,
literal|"initTestCase()"
argument_list|)
expr_stmt|;
comment|// finishedCurrentTestDataCleanup() resets QTestResult::currentTestFailed(), so use a local copy.
specifier|const
name|bool
name|previousFailed
init|=
name|QTestResult
operator|::
name|currentTestFailed
argument_list|()
decl_stmt|;
name|QTestResult
operator|::
name|finishedCurrentTestData
argument_list|()
expr_stmt|;
name|QTestResult
operator|::
name|finishedCurrentTestDataCleanup
argument_list|()
expr_stmt|;
name|QTestResult
operator|::
name|finishedCurrentTestFunction
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|QTestResult
operator|::
name|skipCurrentTest
argument_list|()
operator|&&
operator|!
name|previousFailed
condition|)
block|{
if|if
condition|(
name|QTest
operator|::
name|testFuncs
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|QTest
operator|::
name|testFuncCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|qInvokeTestMethod
argument_list|(
name|metaObject
operator|->
name|method
argument_list|(
name|QTest
operator|::
name|testFuncs
index|[
name|i
index|]
operator|.
name|function
argument_list|()
argument_list|)
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|QTest
operator|::
name|testFuncs
index|[
name|i
index|]
operator|.
name|data
argument_list|()
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
name|testFuncCleaner
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|methodCount
init|=
name|metaObject
operator|->
name|methodCount
argument_list|()
decl_stmt|;
name|QMetaMethod
modifier|*
name|testMethods
init|=
operator|new
name|QMetaMethod
index|[
name|methodCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|methodCount
condition|;
name|i
operator|++
control|)
name|testMethods
index|[
name|i
index|]
operator|=
name|metaObject
operator|->
name|method
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|methodCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isValidSlot
argument_list|(
name|testMethods
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|qInvokeTestMethod
argument_list|(
name|testMethods
index|[
name|i
index|]
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
condition|)
break|break;
block|}
operator|delete
index|[]
name|testMethods
expr_stmt|;
name|testMethods
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|QTestResult
operator|::
name|setSkipCurrentTest
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|QTestResult
operator|::
name|setCurrentTestFunction
argument_list|(
literal|"cleanupTestCase"
argument_list|)
expr_stmt|;
name|invokeMethod
argument_list|(
name|testObject
argument_list|,
literal|"cleanupTestCase()"
argument_list|)
expr_stmt|;
name|QTestResult
operator|::
name|finishedCurrentTestData
argument_list|()
expr_stmt|;
name|QTestResult
operator|::
name|finishedCurrentTestDataCleanup
argument_list|()
expr_stmt|;
block|}
name|QTestResult
operator|::
name|finishedCurrentTestFunction
argument_list|()
expr_stmt|;
name|QTestResult
operator|::
name|setCurrentTestFunction
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QTestTable
operator|::
name|clearGlobalTestTable
argument_list|()
expr_stmt|;
name|QTestLog
operator|::
name|stopLogging
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
DECL|class|FatalSignalHandler
class|class
name|FatalSignalHandler
block|{
public|public:
name|FatalSignalHandler
parameter_list|()
constructor_decl|;
name|~
name|FatalSignalHandler
parameter_list|()
destructor_decl|;
private|private:
specifier|static
name|void
name|signal
parameter_list|(
name|int
parameter_list|)
function_decl|;
DECL|member|handledSignals
name|sigset_t
name|handledSignals
decl_stmt|;
block|}
class|;
DECL|function|signal
name|void
name|FatalSignalHandler
operator|::
name|signal
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|qFatal
argument_list|(
literal|"Received signal %d"
argument_list|,
name|signum
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_INTEGRITY
argument_list|)
block|{
name|struct
name|sigaction
name|act
decl_stmt|;
name|memset
argument_list|(
operator|&
name|act
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sigaction
argument_list|)
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|SIG_DFL
expr_stmt|;
name|sigaction
argument_list|(
name|signum
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
DECL|function|FatalSignalHandler
name|FatalSignalHandler
operator|::
name|FatalSignalHandler
parameter_list|()
block|{
name|sigemptyset
argument_list|(
operator|&
name|handledSignals
argument_list|)
expr_stmt|;
specifier|const
name|int
name|fatalSignals
index|[]
init|=
block|{
name|SIGHUP
block|,
name|SIGINT
block|,
name|SIGQUIT
block|,
name|SIGILL
block|,
name|SIGFPE
block|,
name|SIGSEGV
block|,
name|SIGPIPE
block|,
name|SIGTERM
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
name|memset
argument_list|(
operator|&
name|act
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|act
argument_list|)
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|FatalSignalHandler
operator|::
name|signal
expr_stmt|;
comment|// Remove the handler after it is invoked.
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_INTEGRITY
argument_list|)
name|act
operator|.
name|sa_flags
operator|=
name|SA_RESETHAND
expr_stmt|;
endif|#
directive|endif
comment|// Block all fatal signals in our signal handler so we don't try to close
comment|// the testlog twice.
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|fatalSignals
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
name|sigaddset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|,
name|fatalSignals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|struct
name|sigaction
name|oldact
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|fatalSignals
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
name|sigaction
argument_list|(
name|fatalSignals
index|[
name|i
index|]
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|SA_SIGINFO
name|oldact
operator|.
name|sa_flags
operator|&
name|SA_SIGINFO
operator|||
endif|#
directive|endif
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_DFL
condition|)
block|{
name|sigaction
argument_list|(
name|fatalSignals
index|[
name|i
index|]
argument_list|,
operator|&
name|oldact
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sigaddset
argument_list|(
operator|&
name|handledSignals
argument_list|,
name|fatalSignals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|~FatalSignalHandler
name|FatalSignalHandler
operator|::
name|~
name|FatalSignalHandler
parameter_list|()
block|{
comment|// Unregister any of our remaining signal handlers
name|struct
name|sigaction
name|act
decl_stmt|;
name|memset
argument_list|(
operator|&
name|act
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|act
argument_list|)
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|SIG_DFL
expr_stmt|;
name|struct
name|sigaction
name|oldact
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|sigismember
argument_list|(
operator|&
name|handledSignals
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
name|sigaction
argument_list|(
name|i
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
comment|// If someone overwrote it in the mean time, put it back
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|FatalSignalHandler
operator|::
name|signal
condition|)
name|sigaction
argument_list|(
name|i
argument_list|,
operator|&
name|oldact
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_comment
comment|/*!     Executes tests declared in \a testObject. In addition, the private slots     \c{initTestCase()}, \c{cleanupTestCase()}, \c{init()} and \c{cleanup()}     are executed if they exist. See \l{Creating a Test} for more details.      Optionally, the command line arguments \a argc and \a argv can be provided.     For a list of recognized arguments, read \l {QTestLib Command Line Arguments}.      The following example will run all tests in \c MyTestObject:      \snippet code/src_qtestlib_qtestcase.cpp 18      This function returns 0 if no tests failed, or a value other than 0 if one     or more tests failed or in case of unhandled exceptions.  (Skipped tests do     not influence the return value.)      For stand-alone test applications, the convenience macro \l QTEST_MAIN() can     be used to declare a main() function that parses the command line arguments     and executes the tests, avoiding the need to call this function explicitly.      The return value from this function is also the exit code of the test     application when the \l QTEST_MAIN() macro is used.      For stand-alone test applications, this function should not be called more     than once, as command-line options for logging test output to files and     executing individual test functions will not behave correctly.      Note: This function is not reentrant, only one test can run at a time. A     test that was executed with qExec() can't run another test via qExec() and     threads are not allowed to call qExec() simultaneously.      If you have programatically created the arguments, as opposed to getting them     from the arguments in \c main(), it is likely of interest to use     QTest::qExec(QObject *, const QStringList&) since it is Unicode safe.      \sa QTEST_MAIN() */
end_comment
begin_function
DECL|function|qExec
name|int
name|QTest
operator|::
name|qExec
parameter_list|(
name|QObject
modifier|*
name|testObject
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|QBenchmarkGlobalData
name|benchmarkData
decl_stmt|;
name|QBenchmarkGlobalData
operator|::
name|current
operator|=
operator|&
name|benchmarkData
expr_stmt|;
ifdef|#
directive|ifdef
name|QTESTLIB_USE_VALGRIND
name|int
name|callgrindChildExitCode
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_WS_MAC
name|bool
name|macNeedsActivate
init|=
name|qApp
operator|&&
operator|(
name|qstrcmp
argument_list|(
name|qApp
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
literal|"QApplication"
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|IOPMAssertionID
name|powerID
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_EXCEPTIONS
try|try
block|{
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_CC_MINGW
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|Q_CC_MINGW
argument_list|)
operator|&&
name|defined
argument_list|(
name|__MINGW64_VERSION_MAJOR
argument_list|)
operator|)
name|_CrtSetReportMode
argument_list|(
name|_CRT_ERROR
argument_list|,
name|_CRTDBG_MODE_DEBUG
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SetErrorMode
argument_list|(
name|SetErrorMode
argument_list|(
literal|0
argument_list|)
operator||
name|SEM_NOGPFAULTERRORBOX
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// Starting with Qt 4.4, applications launched from the command line
comment|// no longer get focus automatically. Since some tests might depend
comment|// on this, call SetFrontProcess here to get the pre 4.4 behavior.
if|if
condition|(
name|macNeedsActivate
condition|)
block|{
name|ProcessSerialNumber
name|psn
init|=
block|{
literal|0
block|,
name|kCurrentProcess
block|}
decl_stmt|;
name|SetFrontProcess
argument_list|(
operator|&
name|psn
argument_list|)
expr_stmt|;
name|IOReturn
name|ok
init|=
name|IOPMAssertionCreate
argument_list|(
name|kIOPMAssertionTypeNoDisplaySleep
argument_list|,
name|kIOPMAssertionLevelOn
argument_list|,
operator|&
name|powerID
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
operator|!=
name|kIOReturnSuccess
condition|)
name|macNeedsActivate
operator|=
literal|false
expr_stmt|;
comment|// no need to release the assertion on exit.
block|}
endif|#
directive|endif
name|QTestResult
operator|::
name|reset
argument_list|()
expr_stmt|;
name|QTEST_ASSERT
argument_list|(
name|testObject
argument_list|)
expr_stmt|;
name|QTEST_ASSERT
argument_list|(
operator|!
name|currentTestObject
argument_list|)
expr_stmt|;
name|currentTestObject
operator|=
name|testObject
expr_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|metaObject
init|=
name|testObject
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|QTEST_ASSERT
argument_list|(
name|metaObject
argument_list|)
expr_stmt|;
name|QTestResult
operator|::
name|setCurrentTestObject
argument_list|(
name|metaObject
operator|->
name|className
argument_list|()
argument_list|)
expr_stmt|;
name|QTestResult
operator|::
name|setCurrentAppname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|qtest_qParseArgs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|false
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QTESTLIB_USE_VALGRIND
if|if
condition|(
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|mode
argument_list|()
operator|==
name|QBenchmarkGlobalData
operator|::
name|CallgrindParentProcess
condition|)
block|{
specifier|const
name|QStringList
name|origAppArgs
argument_list|(
name|QCoreApplication
operator|::
name|arguments
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QBenchmarkValgrindUtils
operator|::
name|rerunThroughCallgrind
argument_list|(
name|origAppArgs
argument_list|,
name|callgrindChildExitCode
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|QBenchmarkValgrindUtils
operator|::
name|cleanup
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|QScopedPointer
argument_list|<
name|FatalSignalHandler
argument_list|>
name|handler
decl_stmt|;
if|if
condition|(
operator|!
name|noCrashHandler
condition|)
name|handler
operator|.
name|reset
argument_list|(
operator|new
name|FatalSignalHandler
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qInvokeTestMethods
argument_list|(
name|testObject
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_EXCEPTIONS
block|}
catch|catch
parameter_list|(
modifier|...
parameter_list|)
block|{
name|QTestResult
operator|::
name|addFailure
argument_list|(
literal|"Caught unhandled exception"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|QTestResult
operator|::
name|currentTestFunction
argument_list|()
condition|)
block|{
name|QTestResult
operator|::
name|finishedCurrentTestFunction
argument_list|()
expr_stmt|;
name|QTestResult
operator|::
name|setCurrentTestFunction
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|QTestLog
operator|::
name|stopLogging
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|macNeedsActivate
condition|)
block|{
name|IOPMAssertionRelease
argument_list|(
name|powerID
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|currentTestObject
operator|=
literal|0
expr_stmt|;
comment|// Rethrow exception to make debugging easier.
throw|throw;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
name|currentTestObject
operator|=
literal|0
expr_stmt|;
name|QSignalDumper
operator|::
name|endDump
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|macNeedsActivate
condition|)
block|{
name|IOPMAssertionRelease
argument_list|(
name|powerID
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QTESTLIB_USE_VALGRIND
if|if
condition|(
name|QBenchmarkGlobalData
operator|::
name|current
operator|->
name|mode
argument_list|()
operator|==
name|QBenchmarkGlobalData
operator|::
name|CallgrindParentProcess
condition|)
return|return
name|callgrindChildExitCode
return|;
endif|#
directive|endif
comment|// make sure our exit code is never going above 127
comment|// since that could wrap and indicate 0 test fails
return|return
name|qMin
argument_list|(
name|QTestLog
operator|::
name|failCount
argument_list|()
argument_list|,
literal|127
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload   \since 4.4    Behaves identically to qExec(QObject *, int, char**) but takes a   QStringList of \a arguments instead of a \c char** list.  */
end_comment
begin_function
DECL|function|qExec
name|int
name|QTest
operator|::
name|qExec
parameter_list|(
name|QObject
modifier|*
name|testObject
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|)
block|{
specifier|const
name|int
name|argc
init|=
name|arguments
operator|.
name|count
argument_list|()
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|char
modifier|*
argument_list|>
name|argv
argument_list|(
name|argc
argument_list|)
decl_stmt|;
name|QVector
argument_list|<
name|QByteArray
argument_list|>
name|args
decl_stmt|;
name|args
operator|.
name|reserve
argument_list|(
name|argc
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|args
operator|.
name|append
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|args
operator|.
name|last
argument_list|()
operator|.
name|data
argument_list|()
expr_stmt|;
block|}
return|return
name|qExec
argument_list|(
name|testObject
argument_list|,
name|argc
argument_list|,
name|argv
operator|.
name|data
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|qFail
name|void
name|QTest
operator|::
name|qFail
parameter_list|(
specifier|const
name|char
modifier|*
name|statementStr
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|QTestResult
operator|::
name|addFailure
argument_list|(
name|statementStr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|qVerify
name|bool
name|QTest
operator|::
name|qVerify
parameter_list|(
name|bool
name|statement
parameter_list|,
specifier|const
name|char
modifier|*
name|statementStr
parameter_list|,
specifier|const
name|char
modifier|*
name|description
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
return|return
name|QTestResult
operator|::
name|verify
argument_list|(
name|statement
argument_list|,
name|statementStr
argument_list|,
name|description
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn void QTest::qSkip(const char *message, const char *file, int line) \internal  */
end_comment
begin_function
DECL|function|qSkip
name|void
name|QTest
operator|::
name|qSkip
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|QTestResult
operator|::
name|addSkip
argument_list|(
name|message
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|QTestResult
operator|::
name|setSkipCurrentTest
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn bool QTest::qExpectFail(const char *dataIndex, const char *comment, TestFailMode mode, const char *file, int line) \internal  */
end_comment
begin_function
DECL|function|qExpectFail
name|bool
name|QTest
operator|::
name|qExpectFail
parameter_list|(
specifier|const
name|char
modifier|*
name|dataIndex
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|QTest
operator|::
name|TestFailMode
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
return|return
name|QTestResult
operator|::
name|expectFail
argument_list|(
name|dataIndex
argument_list|,
name|qstrdup
argument_list|(
name|comment
argument_list|)
argument_list|,
name|mode
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|qWarn
name|void
name|QTest
operator|::
name|qWarn
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|QTestLog
operator|::
name|warn
argument_list|(
name|message
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Ignores messages created by qDebug() or qWarning(). If the \a message     with the corresponding \a type is outputted, it will be removed from the     test log. If the test finished and the \a message was not outputted,     a test failure is appended to the test log.      \b {Note:} Invoking this function will only ignore one message.     If the message you want to ignore is outputted twice, you have to     call ignoreMessage() twice, too.      Example:     \snippet code/src_qtestlib_qtestcase.cpp 19      The example above tests that QDir::mkdir() outputs the right warning when invoked     with an invalid file name. */
end_comment
begin_function
DECL|function|ignoreMessage
name|void
name|QTest
operator|::
name|ignoreMessage
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|QTestLog
operator|::
name|ignoreMessage
argument_list|(
name|type
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_function
DECL|function|isWindowsBuildDirectory
specifier|static
specifier|inline
name|bool
name|isWindowsBuildDirectory
parameter_list|(
specifier|const
name|QString
modifier|&
name|dirName
parameter_list|)
block|{
return|return
name|dirName
operator|.
name|compare
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Debug"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
operator|||
name|dirName
operator|.
name|compare
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Release"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qFindTestData
name|QString
name|QTest
operator|::
name|qFindTestData
parameter_list|(
specifier|const
name|QString
modifier|&
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|builddir
parameter_list|)
block|{
name|QString
name|found
decl_stmt|;
comment|// Testdata priorities:
comment|//  1. relative to test binary.
if|if
condition|(
name|qApp
condition|)
block|{
name|QDir
name|binDirectory
argument_list|(
name|QCoreApplication
operator|::
name|applicationDirPath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|binDirectory
operator|.
name|exists
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|found
operator|=
name|binDirectory
operator|.
name|absoluteFilePath
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// Windows: The executable is typically located in one of the
comment|// 'Release' or 'Debug' directories.
elseif|else
if|if
condition|(
name|isWindowsBuildDirectory
argument_list|(
name|binDirectory
operator|.
name|dirName
argument_list|()
argument_list|)
operator|&&
name|binDirectory
operator|.
name|cdUp
argument_list|()
operator|&&
name|binDirectory
operator|.
name|exists
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|found
operator|=
name|binDirectory
operator|.
name|absoluteFilePath
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Q_OS_WIN
elseif|else
if|if
condition|(
name|QTestLog
operator|::
name|verboseLevel
argument_list|()
operator|>=
literal|2
condition|)
block|{
specifier|const
name|QString
name|candidate
init|=
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|QCoreApplication
operator|::
name|applicationDirPath
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|base
argument_list|)
decl_stmt|;
name|QTestLog
operator|::
name|info
argument_list|(
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"testdata %1 not found relative to test binary [%2]; "
literal|"checking next location"
argument_list|)
operator|.
name|arg
argument_list|(
name|base
argument_list|,
name|candidate
argument_list|)
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
comment|//  2. installed path.
if|if
condition|(
name|found
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|char
modifier|*
name|testObjectName
init|=
name|QTestResult
operator|::
name|currentTestObjectName
argument_list|()
decl_stmt|;
if|if
condition|(
name|testObjectName
condition|)
block|{
name|QString
name|testsPath
init|=
name|QLibraryInfo
operator|::
name|location
argument_list|(
name|QLibraryInfo
operator|::
name|TestsPath
argument_list|)
decl_stmt|;
name|QString
name|candidate
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1/%2/%3"
argument_list|)
operator|.
name|arg
argument_list|(
name|testsPath
argument_list|,
name|QFile
operator|::
name|decodeName
argument_list|(
name|testObjectName
argument_list|)
operator|.
name|toLower
argument_list|()
argument_list|,
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|QFileInfo
argument_list|(
name|candidate
argument_list|)
operator|.
name|exists
argument_list|()
condition|)
block|{
name|found
operator|=
name|candidate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QTestLog
operator|::
name|verboseLevel
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|QTestLog
operator|::
name|info
argument_list|(
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"testdata %1 not found in tests install path [%2]; "
literal|"checking next location"
argument_list|)
operator|.
name|arg
argument_list|(
name|base
argument_list|,
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|candidate
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//  3. relative to test source.
if|if
condition|(
name|found
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// srcdir is the directory containing the calling source file.
name|QFileInfo
name|srcdir
init|=
name|QFileInfo
argument_list|(
name|QFile
operator|::
name|decodeName
argument_list|(
name|file
argument_list|)
argument_list|)
operator|.
name|path
argument_list|()
decl_stmt|;
comment|// If the srcdir is relative, that means it is relative to the current working
comment|// directory of the compiler at compile time, which should be passed in as `builddir'.
if|if
condition|(
operator|!
name|srcdir
operator|.
name|isAbsolute
argument_list|()
operator|&&
name|builddir
condition|)
block|{
name|srcdir
operator|.
name|setFile
argument_list|(
name|QFile
operator|::
name|decodeName
argument_list|(
name|builddir
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
operator|+
name|srcdir
operator|.
name|filePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QString
name|candidate
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1/%2"
argument_list|)
operator|.
name|arg
argument_list|(
name|srcdir
operator|.
name|canonicalFilePath
argument_list|()
argument_list|,
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|QFileInfo
argument_list|(
name|candidate
argument_list|)
operator|.
name|exists
argument_list|()
condition|)
block|{
name|found
operator|=
name|candidate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QTestLog
operator|::
name|verboseLevel
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|QTestLog
operator|::
name|info
argument_list|(
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"testdata %1 not found relative to source path [%2]"
argument_list|)
operator|.
name|arg
argument_list|(
name|base
argument_list|,
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|candidate
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QTest
operator|::
name|qWarn
argument_list|(
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"testdata %1 could not be located!"
argument_list|)
operator|.
name|arg
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QTestLog
operator|::
name|verboseLevel
argument_list|()
operator|>=
literal|1
condition|)
block|{
name|QTestLog
operator|::
name|info
argument_list|(
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"testdata %1 was located at %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|base
argument_list|,
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|found
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|qFindTestData
name|QString
name|QTest
operator|::
name|qFindTestData
parameter_list|(
specifier|const
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|builddir
parameter_list|)
block|{
return|return
name|qFindTestData
argument_list|(
name|QFile
operator|::
name|decodeName
argument_list|(
name|base
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|builddir
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|qData
name|void
modifier|*
name|QTest
operator|::
name|qData
parameter_list|(
specifier|const
name|char
modifier|*
name|tagName
parameter_list|,
name|int
name|typeId
parameter_list|)
block|{
return|return
name|fetchData
argument_list|(
name|QTestResult
operator|::
name|currentTestData
argument_list|()
argument_list|,
name|tagName
argument_list|,
name|typeId
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|qGlobalData
name|void
modifier|*
name|QTest
operator|::
name|qGlobalData
parameter_list|(
specifier|const
name|char
modifier|*
name|tagName
parameter_list|,
name|int
name|typeId
parameter_list|)
block|{
return|return
name|fetchData
argument_list|(
name|QTestResult
operator|::
name|currentGlobalTestData
argument_list|()
argument_list|,
name|tagName
argument_list|,
name|typeId
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|qElementData
name|void
modifier|*
name|QTest
operator|::
name|qElementData
parameter_list|(
specifier|const
name|char
modifier|*
name|tagName
parameter_list|,
name|int
name|metaTypeId
parameter_list|)
block|{
name|QTEST_ASSERT
argument_list|(
name|tagName
argument_list|)
expr_stmt|;
name|QTestData
modifier|*
name|data
init|=
name|QTestResult
operator|::
name|currentTestData
argument_list|()
decl_stmt|;
name|QTEST_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|QTEST_ASSERT
argument_list|(
name|data
operator|->
name|parent
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|idx
init|=
name|data
operator|->
name|parent
argument_list|()
operator|->
name|indexOf
argument_list|(
name|tagName
argument_list|)
decl_stmt|;
name|QTEST_ASSERT
argument_list|(
name|idx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QTEST_ASSERT
argument_list|(
name|data
operator|->
name|parent
argument_list|()
operator|->
name|elementTypeId
argument_list|(
name|idx
argument_list|)
operator|==
name|metaTypeId
argument_list|)
expr_stmt|;
return|return
name|data
operator|->
name|data
argument_list|(
name|data
operator|->
name|parent
argument_list|()
operator|->
name|indexOf
argument_list|(
name|tagName
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|addColumnInternal
name|void
name|QTest
operator|::
name|addColumnInternal
parameter_list|(
name|int
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|QTestTable
modifier|*
name|tbl
init|=
name|QTestTable
operator|::
name|currentTestTable
argument_list|()
decl_stmt|;
name|QTEST_ASSERT_X
argument_list|(
name|tbl
argument_list|,
literal|"QTest::addColumn()"
argument_list|,
literal|"Cannot add testdata outside of a _data slot."
argument_list|)
expr_stmt|;
name|tbl
operator|->
name|addColumn
argument_list|(
name|id
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Appends a new row to the current test data. \a dataTag is the name of     the testdata that will appear in the test output. Returns a QTestData reference     that can be used to stream in data.      Example:     \snippet code/src_qtestlib_qtestcase.cpp 20      \b {Note:} This macro can only be used in a test's data function     that is invoked by the test framework.      See \l {Chapter 2: Data Driven Testing}{Data Driven Testing} for     a more extensive example.      \sa addColumn(), QFETCH() */
end_comment
begin_function
DECL|function|newRow
name|QTestData
modifier|&
name|QTest
operator|::
name|newRow
parameter_list|(
specifier|const
name|char
modifier|*
name|dataTag
parameter_list|)
block|{
name|QTEST_ASSERT_X
argument_list|(
name|dataTag
argument_list|,
literal|"QTest::newRow()"
argument_list|,
literal|"Data tag can not be null"
argument_list|)
expr_stmt|;
name|QTestTable
modifier|*
name|tbl
init|=
name|QTestTable
operator|::
name|currentTestTable
argument_list|()
decl_stmt|;
name|QTEST_ASSERT_X
argument_list|(
name|tbl
argument_list|,
literal|"QTest::newRow()"
argument_list|,
literal|"Cannot add testdata outside of a _data slot."
argument_list|)
expr_stmt|;
name|QTEST_ASSERT_X
argument_list|(
name|tbl
operator|->
name|elementCount
argument_list|()
argument_list|,
literal|"QTest::newRow()"
argument_list|,
literal|"Must add columns before attempting to add rows."
argument_list|)
expr_stmt|;
return|return
operator|*
name|tbl
operator|->
name|newData
argument_list|(
name|dataTag
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn void QTest::addColumn(const char *name, T *dummy = 0)      Adds a column with type \c{T} to the current test data.     \a name is the name of the column. \a dummy is a workaround     for buggy compilers and can be ignored.      To populate the column with values, newRow() can be used. Use     \l QFETCH() to fetch the data in the actual test.      Example:     \snippet code/src_qtestlib_qtestcase.cpp 21      To add custom types to the testdata, the type must be registered with     QMetaType via \l Q_DECLARE_METATYPE().      \b {Note:} This macro can only be used in a test's data function     that is invoked by the test framework.      See \l {Chapter 2: Data Driven Testing}{Data Driven Testing} for     a more extensive example.      \sa QTest::newRow(), QFETCH(), QMetaType */
end_comment
begin_comment
comment|/*!     Returns the name of the test function that is currently executed.      Example:      \snippet code/src_qtestlib_qtestcase.cpp 22 */
end_comment
begin_function
DECL|function|currentTestFunction
specifier|const
name|char
modifier|*
name|QTest
operator|::
name|currentTestFunction
parameter_list|()
block|{
return|return
name|QTestResult
operator|::
name|currentTestFunction
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the current test data. If the test doesn't     have any assigned testdata, the function returns 0. */
end_comment
begin_function
DECL|function|currentDataTag
specifier|const
name|char
modifier|*
name|QTest
operator|::
name|currentDataTag
parameter_list|()
block|{
return|return
name|QTestResult
operator|::
name|currentDataTag
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the current test function failed, otherwise false. */
end_comment
begin_function
DECL|function|currentTestFailed
name|bool
name|QTest
operator|::
name|currentTestFailed
parameter_list|()
block|{
return|return
name|QTestResult
operator|::
name|currentTestFailed
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sleeps for \a ms milliseconds, blocking execution of the     test. qSleep() will not do any event processing and leave your test     unresponsive. Network communication might time out while     sleeping. Use \l qWait() to do non-blocking sleeping.      \a ms must be greater than 0.      \b {Note:} The qSleep() function calls either \c nanosleep() on     unix or \c Sleep() on windows, so the accuracy of time spent in     qSleep() depends on the operating system.      Example:     \snippet code/src_qtestlib_qtestcase.cpp 23      \sa qWait() */
end_comment
begin_function
DECL|function|qSleep
name|void
name|QTest
operator|::
name|qSleep
parameter_list|(
name|int
name|ms
parameter_list|)
block|{
name|QTEST_ASSERT
argument_list|(
name|ms
operator|>
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|Sleep
argument_list|(
name|uint
argument_list|(
name|ms
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|timespec
name|ts
init|=
block|{
name|ms
operator|/
literal|1000
block|,
operator|(
name|ms
operator|%
literal|1000
operator|)
operator|*
literal|1000
operator|*
literal|1000
block|}
decl_stmt|;
name|nanosleep
argument_list|(
operator|&
name|ts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|testObject
name|QObject
modifier|*
name|QTest
operator|::
name|testObject
parameter_list|()
block|{
return|return
name|currentTestObject
return|;
block|}
end_function
begin_comment
comment|/*! \internal     This function is called by various specializations of QTest::qCompare     to decide whether to report a failure and to produce verbose test output.      The failureMsg parameter can be null, in which case a default message     will be output if the compare fails.  If the compare succeeds, failureMsg     will not be output.      If the caller has already passed a failure message showing the compared     values, or if those values cannot be stringified, val1 and val2 can be null.  */
end_comment
begin_function
DECL|function|compare_helper
name|bool
name|QTest
operator|::
name|compare_helper
parameter_list|(
name|bool
name|success
parameter_list|,
specifier|const
name|char
modifier|*
name|failureMsg
parameter_list|,
name|char
modifier|*
name|val1
parameter_list|,
name|char
modifier|*
name|val2
parameter_list|,
specifier|const
name|char
modifier|*
name|actual
parameter_list|,
specifier|const
name|char
modifier|*
name|expected
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
return|return
name|QTestResult
operator|::
name|compare
argument_list|(
name|success
argument_list|,
name|failureMsg
argument_list|,
name|val1
argument_list|,
name|val2
argument_list|,
name|actual
argument_list|,
name|expected
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QTest::qCompare<float>(float const&t1, float const&t2, const char *actual, const char *expected, const char *file, int line) \internal  */
end_comment
begin_function
template|template
parameter_list|<>
DECL|function|qCompare
name|Q_TESTLIB_EXPORT
name|bool
name|QTest
operator|::
name|qCompare
argument_list|<
name|float
argument_list|>
parameter_list|(
name|float
specifier|const
modifier|&
name|t1
parameter_list|,
name|float
specifier|const
modifier|&
name|t2
parameter_list|,
specifier|const
name|char
modifier|*
name|actual
parameter_list|,
specifier|const
name|char
modifier|*
name|expected
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
return|return
name|compare_helper
argument_list|(
name|qFuzzyCompare
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
argument_list|,
literal|"Compared floats are not the same (fuzzy compare)"
argument_list|,
name|toString
argument_list|(
name|t1
argument_list|)
argument_list|,
name|toString
argument_list|(
name|t2
argument_list|)
argument_list|,
name|actual
argument_list|,
name|expected
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QTest::qCompare<double>(double const&t1, double const&t2, const char *actual, const char *expected, const char *file, int line) \internal  */
end_comment
begin_function
template|template
parameter_list|<>
DECL|function|qCompare
name|Q_TESTLIB_EXPORT
name|bool
name|QTest
operator|::
name|qCompare
argument_list|<
name|double
argument_list|>
parameter_list|(
name|double
specifier|const
modifier|&
name|t1
parameter_list|,
name|double
specifier|const
modifier|&
name|t2
parameter_list|,
specifier|const
name|char
modifier|*
name|actual
parameter_list|,
specifier|const
name|char
modifier|*
name|expected
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
return|return
name|compare_helper
argument_list|(
name|qFuzzyCompare
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
argument_list|,
literal|"Compared doubles are not the same (fuzzy compare)"
argument_list|,
name|toString
argument_list|(
name|t1
argument_list|)
argument_list|,
name|toString
argument_list|(
name|t2
argument_list|)
argument_list|,
name|actual
argument_list|,
name|expected
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function
begin_define
DECL|macro|TO_STRING_IMPL
define|#
directive|define
name|TO_STRING_IMPL
parameter_list|(
name|TYPE
parameter_list|,
name|FORMAT
parameter_list|)
define|\
value|template<> Q_TESTLIB_EXPORT char *QTest::toString<TYPE>(const TYPE&t) \ { \     char *msg = new char[128]; \     qsnprintf(msg, 128, #FORMAT, t); \     return msg; \ }
end_define
begin_macro
name|TO_STRING_IMPL
argument_list|(
argument|short
argument_list|,
argument|%hd
argument_list|)
end_macro
begin_macro
name|TO_STRING_IMPL
argument_list|(
argument|ushort
argument_list|,
argument|%hu
argument_list|)
end_macro
begin_macro
name|TO_STRING_IMPL
argument_list|(
argument|int
argument_list|,
argument|%d
argument_list|)
end_macro
begin_macro
name|TO_STRING_IMPL
argument_list|(
argument|uint
argument_list|,
argument|%u
argument_list|)
end_macro
begin_macro
name|TO_STRING_IMPL
argument_list|(
argument|long
argument_list|,
argument|%ld
argument_list|)
end_macro
begin_macro
name|TO_STRING_IMPL
argument_list|(
argument|ulong
argument_list|,
argument|%lu
argument_list|)
end_macro
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_macro
name|TO_STRING_IMPL
argument_list|(
argument|qint64
argument_list|,
argument|%I64d
argument_list|)
end_macro
begin_macro
name|TO_STRING_IMPL
argument_list|(
argument|quint64
argument_list|,
argument|%I64u
argument_list|)
end_macro
begin_else
else|#
directive|else
end_else
begin_macro
name|TO_STRING_IMPL
argument_list|(
argument|qint64
argument_list|,
argument|%lld
argument_list|)
end_macro
begin_macro
name|TO_STRING_IMPL
argument_list|(
argument|quint64
argument_list|,
argument|%llu
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|TO_STRING_IMPL
argument_list|(
argument|bool
argument_list|,
argument|%d
argument_list|)
end_macro
begin_macro
name|TO_STRING_IMPL
argument_list|(
argument|char
argument_list|,
argument|%c
argument_list|)
end_macro
begin_macro
name|TO_STRING_IMPL
argument_list|(
argument|float
argument_list|,
argument|%g
argument_list|)
end_macro
begin_macro
name|TO_STRING_IMPL
argument_list|(
argument|double
argument_list|,
argument|%lg
argument_list|)
end_macro
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|toString
name|char
modifier|*
name|QTest
operator|::
name|toString
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|str
condition|)
return|return
literal|0
return|;
name|char
modifier|*
name|msg
init|=
operator|new
name|char
index|[
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
return|return
name|qstrcpy
argument_list|(
name|msg
argument_list|,
name|str
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|toString
name|char
modifier|*
name|QTest
operator|::
name|toString
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|msg
init|=
operator|new
name|char
index|[
literal|128
index|]
decl_stmt|;
name|qsnprintf
argument_list|(
name|msg
argument_list|,
literal|128
argument_list|,
literal|"%p"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|compare_string_helper
name|bool
name|QTest
operator|::
name|compare_string_helper
parameter_list|(
specifier|const
name|char
modifier|*
name|t1
parameter_list|,
specifier|const
name|char
modifier|*
name|t2
parameter_list|,
specifier|const
name|char
modifier|*
name|actual
parameter_list|,
specifier|const
name|char
modifier|*
name|expected
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
return|return
name|compare_helper
argument_list|(
name|qstrcmp
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|==
literal|0
argument_list|,
literal|"Compared strings are not the same"
argument_list|,
name|toString
argument_list|(
name|t1
argument_list|)
argument_list|,
name|toString
argument_list|(
name|t2
argument_list|)
argument_list|,
name|actual
argument_list|,
name|expected
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QTest::compare_ptr_helper(const void *t1, const void *t2, const char *actual, const char *expected, const char *file, int line);     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(T1 const&, T2 const&, const char *, const char *, const char *, int);     \internal */
end_comment
begin_comment
comment|/*! \fn void QTest::mouseEvent(MouseAction action, QWidget *widget, Qt::MouseButton button, Qt::KeyboardModifiers stateKey, QPoint pos, int delay=-1)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(QIcon const&t1, QIcon const&t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(QPixmap const&t1, QPixmap const&t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(T const&t1, T const&t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(const T *t1, const T *t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(T *t1, T *t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(const T1 *t1, const T2 *t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(T1 *t1, T2 *t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(const char *t1, const char *t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(char *t1, char *t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(char *t1, const char *t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(const char *t1, char *t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(QString const&t1, QLatin1String const&t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(QLatin1String const&t1, QString const&t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(QStringList const&t1, QStringList const&t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(QFlags<T> const&t1, T const&t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(QFlags<T> const&t1, int const&t2, const char *actual, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn bool QTest::qCompare(bool const&t1, int const&t2, const char *actual, const char *expected, const char *file, int line)   \internal  */
end_comment
begin_comment
comment|/*! \fn bool QTest::qTest(const T& actual, const char *elementName, const char *actualStr, const char *expected, const char *file, int line)     \internal */
end_comment
begin_comment
comment|/*! \fn void QTest::sendKeyEvent(KeyAction action, QWidget *widget, Qt::Key code, QString text, Qt::KeyboardModifiers modifier, int delay=-1)     \internal */
end_comment
begin_comment
comment|/*! \fn void QTest::sendKeyEvent(KeyAction action, QWidget *widget, Qt::Key code, char ascii, Qt::KeyboardModifiers modifier, int delay=-1)     \internal */
end_comment
begin_comment
comment|/*! \fn void QTest::simulateEvent(QWidget *widget, bool press, int code, Qt::KeyboardModifiers modifier, QString text, bool repeat, int delay=-1)     \internal */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
