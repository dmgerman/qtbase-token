begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Intel Corporation. ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qbenchmarkperfevents_p.h"
end_include
begin_include
include|#
directive|include
file|"qbenchmarkmetric.h"
end_include
begin_include
include|#
directive|include
file|"qbenchmark_p.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QTESTLIB_USE_PERF_EVENTS
end_ifdef
begin_comment
comment|// include the qcore_unix_p.h without core-private
end_comment
begin_comment
comment|// we only use inline functions anyway
end_comment
begin_include
include|#
directive|include
file|"../corelib/kernel/qcore_unix_p.h"
end_include
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<fcntl.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include
begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include
begin_include
include|#
directive|include
file|"3rdparty/linux_perf_event_p.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|event_type
specifier|static
name|quint32
name|event_type
init|=
name|PERF_TYPE_HARDWARE
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|event_id
specifier|static
name|quint64
name|event_id
init|=
name|PERF_COUNT_HW_CPU_CYCLES
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     \class QBenchmarkPerfEvents     \brief The Linux perf events benchmark backend      This benchmark backend uses the Linux Performance Counters interface,     introduced with the Linux kernel v2.6.31. The interface is done by one     system call (perf_event_open) which takes an attribute structure and     returns a file descriptor.      More information:      \li design docs: tools/perf/design.txt<http://lxr.linux.no/linux/tools/perf/design.txt>      \li sample tool: tools/perf/builtin-stat.c<http://lxr.linux.no/linux/tools/perf/builtin-stat.c>     (note: as of v3.3.1, the documentation is out-of-date with the kernel     interface, so reading the source code of existing tools is necessary)      This benchlib backend monitors the current process as well as child process     launched. We do not try to benchmark in kernel or hypervisor mode, as that     usually requires elevated privileges.  */
end_comment
begin_function
DECL|function|perf_event_open
specifier|static
name|int
name|perf_event_open
parameter_list|(
name|perf_event_attr
modifier|*
name|attr
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|int
name|cpu
parameter_list|,
name|int
name|group_fd
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
block|{
return|return
name|syscall
argument_list|(
name|SYS_perf_event_open
argument_list|,
name|attr
argument_list|,
name|pid
argument_list|,
name|cpu
argument_list|,
name|group_fd
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|isAvailable
name|bool
name|QBenchmarkPerfEventsMeasurer
operator|::
name|isAvailable
parameter_list|()
block|{
comment|// this generates an EFAULT because attr == NULL if perf_event_open is available
comment|// if the kernel is too old, it generates ENOSYS
return|return
name|perf_event_open
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|ENOSYS
return|;
block|}
end_function
begin_comment
comment|/* Event list structure    The following table provides the list of supported events     Event type   Event counter           Unit            Name and aliases    HARDWARE     CPU_CYCLES              CPUCycles       cycles  cpu-cycles    HARDWARE     INSTRUCTIONS            Instructions    instructions    HARDWARE     CACHE_REFERENCES        CacheReferences cache-references    HARDWARE     CACHE_MISSES            CacheMisses     cache-misses    HARDWARE     BRANCH_INSTRUCTIONS     BranchInstructions branch-instructions branches    HARDWARE     BRANCH_MISSES           BranchMisses    branch-misses    HARDWARE     BUS_CYCLES              BusCycles       bus-cycles    HARDWARE     STALLED_CYCLES_FRONTEND StalledCycles   stalled-cycles-frontend idle-cycles-frontend    HARDWARE     STALLED_CYCLES_BACKEND  StalledCycles   stalled-cycles-backend idle-cycles-backend    SOFTWARE     CPU_CLOCK               WalltimeMilliseconds cpu-clock    SOFTWARE     TASK_CLOCK              WalltimeMilliseconds task-clock    SOFTWARE     PAGE_FAULTS             PageFaults      page-faults faults    SOFTWARE     PAGE_FAULTS_MAJ         MajorPageFaults major-faults    SOFTWARE     PAGE_FAULTS_MIN         MinorPageFaults minor-faults    SOFTWARE     CONTEXT_SWITCHES        ContextSwitches context-switches cs    SOFTWARE     CPU_MIGRATIONS          CPUMigrations   cpu-migrations migrations    SOFTWARE     ALIGNMENT_FAULTS        AlignmentFaults alignment-faults    SOFTWARE     EMULATION_FAULTS        EmulationFaults emulation-faults     Use the following Perl script to re-generate the list === cut perl === #!/usr/bin/env perl # Load all entries into %map while (<STDIN>) {     m/^\s*(.*)\s*$/;     @_ = split /\s+/, $1;     $type = shift @_;     $id = ($type eq "HARDWARE" ? "PERF_COUNT_HW_" :        $type eq "SOFTWARE" ? "PERF_COUNT_SW_" :        $type eq "HW_CACHE" ? "CACHE_" : "") . shift @_;     $unit = shift @_;      for $string (@_) {     die "$string was already seen!" if defined($map{$string});     $map{$string} = [-1, $type, $id, $unit];     push @strings, $string;     } }  # sort the map and print the string list @strings = sort @strings; print "static const char eventlist_strings[] = \n"; $counter = 0; for $entry (@strings) {     print "    \"$entry\\0\"\n";     $map{$entry}[0] = $counter;     $counter += 1 + length $entry; }  # print the table print "    \"\\0\";\n\nstatic const Events eventlist[] = {\n"; for $entry (sort @strings) {     printf "    { %3d, PERF_TYPE_%s, %s, QTest::%s },\n",         $map{$entry}[0],     $map{$entry}[1],         $map{$entry}[2],         $map{$entry}[3]; } print "    {   0, PERF_TYPE_MAX, 0, QTest::Events }\n};\n"; === cut perl === */
end_comment
begin_struct
DECL|struct|Events
struct|struct
name|Events
block|{
DECL|member|offset
name|unsigned
name|offset
decl_stmt|;
DECL|member|type
name|quint32
name|type
decl_stmt|;
DECL|member|event_id
name|quint64
name|event_id
decl_stmt|;
DECL|member|metric
name|QTest
operator|::
name|QBenchmarkMetric
name|metric
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* -- BEGIN GENERATED CODE -- */
end_comment
begin_decl_stmt
DECL|variable|eventlist_strings
specifier|static
specifier|const
name|char
name|eventlist_strings
index|[]
init|=
literal|"alignment-faults\0"
literal|"branch-instructions\0"
literal|"branch-misses\0"
literal|"branches\0"
literal|"bus-cycles\0"
literal|"cache-misses\0"
literal|"cache-references\0"
literal|"context-switches\0"
literal|"cpu-clock\0"
literal|"cpu-cycles\0"
literal|"cpu-migrations\0"
literal|"cs\0"
literal|"cycles\0"
literal|"emulation-faults\0"
literal|"faults\0"
literal|"idle-cycles-backend\0"
literal|"idle-cycles-frontend\0"
literal|"instructions\0"
literal|"major-faults\0"
literal|"migrations\0"
literal|"minor-faults\0"
literal|"page-faults\0"
literal|"stalled-cycles-backend\0"
literal|"stalled-cycles-frontend\0"
literal|"task-clock\0"
literal|"\0"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|eventlist
specifier|static
specifier|const
name|Events
name|eventlist
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PERF_TYPE_SOFTWARE
block|,
name|PERF_COUNT_SW_ALIGNMENT_FAULTS
block|,
name|QTest
operator|::
name|AlignmentFaults
block|}
block|,
block|{
literal|17
block|,
name|PERF_TYPE_HARDWARE
block|,
name|PERF_COUNT_HW_BRANCH_INSTRUCTIONS
block|,
name|QTest
operator|::
name|BranchInstructions
block|}
block|,
block|{
literal|37
block|,
name|PERF_TYPE_HARDWARE
block|,
name|PERF_COUNT_HW_BRANCH_MISSES
block|,
name|QTest
operator|::
name|BranchMisses
block|}
block|,
block|{
literal|51
block|,
name|PERF_TYPE_HARDWARE
block|,
name|PERF_COUNT_HW_BRANCH_INSTRUCTIONS
block|,
name|QTest
operator|::
name|BranchInstructions
block|}
block|,
block|{
literal|60
block|,
name|PERF_TYPE_HARDWARE
block|,
name|PERF_COUNT_HW_BUS_CYCLES
block|,
name|QTest
operator|::
name|BusCycles
block|}
block|,
block|{
literal|71
block|,
name|PERF_TYPE_HARDWARE
block|,
name|PERF_COUNT_HW_CACHE_MISSES
block|,
name|QTest
operator|::
name|CacheMisses
block|}
block|,
block|{
literal|84
block|,
name|PERF_TYPE_HARDWARE
block|,
name|PERF_COUNT_HW_CACHE_REFERENCES
block|,
name|QTest
operator|::
name|CacheReferences
block|}
block|,
block|{
literal|101
block|,
name|PERF_TYPE_SOFTWARE
block|,
name|PERF_COUNT_SW_CONTEXT_SWITCHES
block|,
name|QTest
operator|::
name|ContextSwitches
block|}
block|,
block|{
literal|118
block|,
name|PERF_TYPE_SOFTWARE
block|,
name|PERF_COUNT_SW_CPU_CLOCK
block|,
name|QTest
operator|::
name|WalltimeMilliseconds
block|}
block|,
block|{
literal|128
block|,
name|PERF_TYPE_HARDWARE
block|,
name|PERF_COUNT_HW_CPU_CYCLES
block|,
name|QTest
operator|::
name|CPUCycles
block|}
block|,
block|{
literal|139
block|,
name|PERF_TYPE_SOFTWARE
block|,
name|PERF_COUNT_SW_CPU_MIGRATIONS
block|,
name|QTest
operator|::
name|CPUMigrations
block|}
block|,
block|{
literal|154
block|,
name|PERF_TYPE_SOFTWARE
block|,
name|PERF_COUNT_SW_CONTEXT_SWITCHES
block|,
name|QTest
operator|::
name|ContextSwitches
block|}
block|,
block|{
literal|157
block|,
name|PERF_TYPE_HARDWARE
block|,
name|PERF_COUNT_HW_CPU_CYCLES
block|,
name|QTest
operator|::
name|CPUCycles
block|}
block|,
block|{
literal|164
block|,
name|PERF_TYPE_SOFTWARE
block|,
name|PERF_COUNT_SW_EMULATION_FAULTS
block|,
name|QTest
operator|::
name|EmulationFaults
block|}
block|,
block|{
literal|181
block|,
name|PERF_TYPE_SOFTWARE
block|,
name|PERF_COUNT_SW_PAGE_FAULTS
block|,
name|QTest
operator|::
name|PageFaults
block|}
block|,
block|{
literal|188
block|,
name|PERF_TYPE_HARDWARE
block|,
name|PERF_COUNT_HW_STALLED_CYCLES_BACKEND
block|,
name|QTest
operator|::
name|StalledCycles
block|}
block|,
block|{
literal|208
block|,
name|PERF_TYPE_HARDWARE
block|,
name|PERF_COUNT_HW_STALLED_CYCLES_FRONTEND
block|,
name|QTest
operator|::
name|StalledCycles
block|}
block|,
block|{
literal|229
block|,
name|PERF_TYPE_HARDWARE
block|,
name|PERF_COUNT_HW_INSTRUCTIONS
block|,
name|QTest
operator|::
name|Instructions
block|}
block|,
block|{
literal|242
block|,
name|PERF_TYPE_SOFTWARE
block|,
name|PERF_COUNT_SW_PAGE_FAULTS_MAJ
block|,
name|QTest
operator|::
name|MajorPageFaults
block|}
block|,
block|{
literal|255
block|,
name|PERF_TYPE_SOFTWARE
block|,
name|PERF_COUNT_SW_CPU_MIGRATIONS
block|,
name|QTest
operator|::
name|CPUMigrations
block|}
block|,
block|{
literal|266
block|,
name|PERF_TYPE_SOFTWARE
block|,
name|PERF_COUNT_SW_PAGE_FAULTS_MIN
block|,
name|QTest
operator|::
name|MinorPageFaults
block|}
block|,
block|{
literal|279
block|,
name|PERF_TYPE_SOFTWARE
block|,
name|PERF_COUNT_SW_PAGE_FAULTS
block|,
name|QTest
operator|::
name|PageFaults
block|}
block|,
block|{
literal|291
block|,
name|PERF_TYPE_HARDWARE
block|,
name|PERF_COUNT_HW_STALLED_CYCLES_BACKEND
block|,
name|QTest
operator|::
name|StalledCycles
block|}
block|,
block|{
literal|314
block|,
name|PERF_TYPE_HARDWARE
block|,
name|PERF_COUNT_HW_STALLED_CYCLES_FRONTEND
block|,
name|QTest
operator|::
name|StalledCycles
block|}
block|,
block|{
literal|338
block|,
name|PERF_TYPE_SOFTWARE
block|,
name|PERF_COUNT_SW_TASK_CLOCK
block|,
name|QTest
operator|::
name|WalltimeMilliseconds
block|}
block|,
block|{
literal|0
block|,
name|PERF_TYPE_MAX
block|,
literal|0
block|,
name|QTest
operator|::
name|Events
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* -- END GENERATED CODE -- */
end_comment
begin_function
DECL|function|metricForEvent
name|QTest
operator|::
name|QBenchmarkMetric
name|QBenchmarkPerfEventsMeasurer
operator|::
name|metricForEvent
parameter_list|(
name|quint32
name|type
parameter_list|,
name|quint64
name|event_id
parameter_list|)
block|{
specifier|const
name|Events
modifier|*
name|ptr
init|=
name|eventlist
decl_stmt|;
for|for
control|(
init|;
name|ptr
operator|->
name|type
operator|!=
name|PERF_TYPE_MAX
condition|;
operator|++
name|ptr
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|type
operator|==
name|type
operator|&&
name|ptr
operator|->
name|event_id
operator|==
name|event_id
condition|)
return|return
name|ptr
operator|->
name|metric
return|;
block|}
return|return
name|QTest
operator|::
name|Events
return|;
block|}
end_function
begin_function
DECL|function|setCounter
name|void
name|QBenchmarkPerfEventsMeasurer
operator|::
name|setCounter
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|Events
modifier|*
name|ptr
init|=
name|eventlist
decl_stmt|;
for|for
control|(
init|;
name|ptr
operator|->
name|type
operator|!=
name|PERF_TYPE_MAX
condition|;
operator|++
name|ptr
control|)
block|{
name|int
name|c
init|=
name|strcmp
argument_list|(
name|name
argument_list|,
name|eventlist_strings
operator|+
name|ptr
operator|->
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Performance counter type '%s' is unknown\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
operator|::
name|event_type
operator|=
name|ptr
operator|->
name|type
expr_stmt|;
operator|::
name|event_id
operator|=
name|ptr
operator|->
name|event_id
expr_stmt|;
block|}
end_function
begin_function
DECL|function|listCounters
name|void
name|QBenchmarkPerfEventsMeasurer
operator|::
name|listCounters
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isAvailable
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"Performance counters are not available on this system\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"The following performance counters are available:\n"
argument_list|)
expr_stmt|;
specifier|const
name|Events
modifier|*
name|ptr
init|=
name|eventlist
decl_stmt|;
for|for
control|(
init|;
name|ptr
operator|->
name|type
operator|!=
name|PERF_TYPE_MAX
condition|;
operator|++
name|ptr
control|)
block|{
name|printf
argument_list|(
literal|"  %-30s [%s]\n"
argument_list|,
name|eventlist_strings
operator|+
name|ptr
operator|->
name|offset
argument_list|,
name|ptr
operator|->
name|type
operator|==
name|PERF_TYPE_HARDWARE
condition|?
literal|"hardware"
else|:
name|ptr
operator|->
name|type
operator|==
name|PERF_TYPE_SOFTWARE
condition|?
literal|"software"
else|:
name|ptr
operator|->
name|type
operator|==
name|PERF_TYPE_HW_CACHE
condition|?
literal|"cache"
else|:
literal|"other"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_constructor
DECL|function|QBenchmarkPerfEventsMeasurer
name|QBenchmarkPerfEventsMeasurer
operator|::
name|QBenchmarkPerfEventsMeasurer
parameter_list|()
member_init_list|:
name|fd
argument_list|(
operator|-
literal|1
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QBenchmarkPerfEventsMeasurer
name|QBenchmarkPerfEventsMeasurer
operator|::
name|~
name|QBenchmarkPerfEventsMeasurer
parameter_list|()
block|{
name|qt_safe_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|init
name|void
name|QBenchmarkPerfEventsMeasurer
operator|::
name|init
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|start
name|void
name|QBenchmarkPerfEventsMeasurer
operator|::
name|start
parameter_list|()
block|{
name|perf_event_attr
name|attr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|attr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|attr
argument_list|)
expr_stmt|;
comment|// common init
name|attr
operator|.
name|size
operator|=
sizeof|sizeof
name|attr
expr_stmt|;
name|attr
operator|.
name|sample_period
operator|=
literal|0
expr_stmt|;
name|attr
operator|.
name|sample_type
operator|=
literal|0
expr_stmt|;
name|attr
operator|.
name|read_format
operator|=
name|PERF_FORMAT_TOTAL_TIME_ENABLED
operator||
name|PERF_FORMAT_TOTAL_TIME_RUNNING
expr_stmt|;
name|attr
operator|.
name|disabled
operator|=
literal|true
expr_stmt|;
comment|// start disabled, we'll enable later
name|attr
operator|.
name|inherit
operator|=
literal|true
expr_stmt|;
comment|// let children inherit, if the benchmark has child processes
name|attr
operator|.
name|pinned
operator|=
literal|true
expr_stmt|;
comment|// keep it running on the PMU
name|attr
operator|.
name|inherit_stat
operator|=
literal|true
expr_stmt|;
comment|// collapse all the info from child processes
name|attr
operator|.
name|task
operator|=
literal|true
expr_stmt|;
comment|// trace fork and exit
comment|// our event type
name|attr
operator|.
name|type
operator|=
operator|::
name|event_type
expr_stmt|;
name|attr
operator|.
name|config
operator|=
operator|::
name|event_id
expr_stmt|;
comment|// pid == 0 -> attach to the current process
comment|// cpu == -1 -> monitor on all CPUs
comment|// group_fd == -1 -> this is the group leader
comment|// flags == 0 -> reserved, must be zero
name|fd
operator|=
name|perf_event_open
argument_list|(
operator|&
name|attr
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"QBenchmarkPerfEventsMeasurer::start: perf_event_open"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|::
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
block|}
comment|// enable the counter
operator|::
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PERF_EVENT_IOC_RESET
argument_list|)
expr_stmt|;
operator|::
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PERF_EVENT_IOC_ENABLE
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|checkpoint
name|qint64
name|QBenchmarkPerfEventsMeasurer
operator|::
name|checkpoint
parameter_list|()
block|{
operator|::
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PERF_EVENT_IOC_DISABLE
argument_list|)
expr_stmt|;
name|qint64
name|value
init|=
name|readValue
argument_list|()
decl_stmt|;
operator|::
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PERF_EVENT_IOC_ENABLE
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function
begin_function
DECL|function|stop
name|qint64
name|QBenchmarkPerfEventsMeasurer
operator|::
name|stop
parameter_list|()
block|{
comment|// disable the counter
operator|::
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PERF_EVENT_IOC_DISABLE
argument_list|)
expr_stmt|;
return|return
name|readValue
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|isMeasurementAccepted
name|bool
name|QBenchmarkPerfEventsMeasurer
operator|::
name|isMeasurementAccepted
parameter_list|(
name|qint64
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|adjustIterationCount
name|int
name|QBenchmarkPerfEventsMeasurer
operator|::
name|adjustIterationCount
parameter_list|(
name|int
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|adjustMedianCount
name|int
name|QBenchmarkPerfEventsMeasurer
operator|::
name|adjustMedianCount
parameter_list|(
name|int
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|metricType
name|QTest
operator|::
name|QBenchmarkMetric
name|QBenchmarkPerfEventsMeasurer
operator|::
name|metricType
parameter_list|()
block|{
return|return
name|metricForEvent
argument_list|(
name|event_type
argument_list|,
name|event_id
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|rawReadValue
specifier|static
name|quint64
name|rawReadValue
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
comment|/* from the kernel docs:      * struct read_format {      *  { u64           value;      *    { u64         time_enabled; }&& PERF_FORMAT_TOTAL_TIME_ENABLED      *    { u64         time_running; }&& PERF_FORMAT_TOTAL_TIME_RUNNING      *    { u64         id;           }&& PERF_FORMAT_ID      *  }&& !PERF_FORMAT_GROUP      */
struct|struct
name|read_format
block|{
name|quint64
name|value
decl_stmt|;
name|quint64
name|time_enabled
decl_stmt|;
name|quint64
name|time_running
decl_stmt|;
block|}
name|results
struct|;
name|size_t
name|nread
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|nread
operator|<
sizeof|sizeof
name|results
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|results
argument_list|)
decl_stmt|;
name|qint64
name|r
init|=
name|qt_safe_read
argument_list|(
name|fd
argument_list|,
name|ptr
operator|+
name|nread
argument_list|,
sizeof|sizeof
name|results
operator|-
name|nread
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"QBenchmarkPerfEventsMeasurer::readValue: reading the results"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|nread
operator|+=
name|quint64
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|results
operator|.
name|time_running
operator|==
name|results
operator|.
name|time_enabled
condition|)
return|return
name|results
operator|.
name|value
return|;
comment|// scale the results, though this shouldn't happen!
return|return
name|results
operator|.
name|value
operator|*
operator|(
name|double
argument_list|(
name|results
operator|.
name|time_running
argument_list|)
operator|/
name|double
argument_list|(
name|results
operator|.
name|time_enabled
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|readValue
name|qint64
name|QBenchmarkPerfEventsMeasurer
operator|::
name|readValue
parameter_list|()
block|{
name|quint64
name|raw
init|=
name|rawReadValue
argument_list|(
name|fd
argument_list|)
decl_stmt|;
if|if
condition|(
name|metricType
argument_list|()
operator|==
name|QTest
operator|::
name|WalltimeMilliseconds
condition|)
block|{
comment|// perf returns nanoseconds
return|return
name|raw
operator|/
literal|1000000
return|;
block|}
return|return
name|raw
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
end_unit
