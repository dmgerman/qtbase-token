begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Intel Corporation. ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qbenchmarkperfevents_p.h"
end_include
begin_include
include|#
directive|include
file|"qbenchmark_p.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QTESTLIB_USE_PERF_EVENTS
end_ifdef
begin_comment
comment|// include the qcore_unix_p.h without core-private
end_comment
begin_comment
comment|// we only use inline functions anyway
end_comment
begin_include
include|#
directive|include
file|"../corelib/kernel/qcore_unix_p.h"
end_include
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<fcntl.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include
begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include
begin_include
include|#
directive|include
file|"3rdparty/linux_perf_event_p.h"
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QBenchmarkPerfEvents     \brief The Linux perf events benchmark backend      This benchmark backend uses the Linux Performance Counters interface,     introduced with the Linux kernel v2.6.31. The interface is done by one     system call (perf_event_open) which takes an attribute structure and     returns a file descriptor.      More information:      \li design docs: tools/perf/design.txt<http://lxr.linux.no/linux/tools/perf/design.txt>      \li sample tool: tools/perf/builtin-stat.c<http://lxr.linux.no/linux/tools/perf/builtin-stat.c>     (note: as of v3.3.1, the documentation is out-of-date with the kernel     interface, so reading the source code of existing tools is necessary)      This benchlib backend monitors the current process as well as child process     launched. We do not try to benchmark in kernel or hypervisor mode, as that     usually requires elevated privileges.  */
DECL|function|perf_event_open
specifier|static
name|int
name|perf_event_open
parameter_list|(
name|perf_event_attr
modifier|*
name|attr
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|int
name|cpu
parameter_list|,
name|int
name|group_fd
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
block|{
return|return
name|syscall
argument_list|(
name|SYS_perf_event_open
argument_list|,
name|attr
argument_list|,
name|pid
argument_list|,
name|cpu
argument_list|,
name|group_fd
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|isAvailable
name|bool
name|QBenchmarkPerfEventsMeasurer
operator|::
name|isAvailable
parameter_list|()
block|{
comment|// this generates an EFAULT because attr == NULL if perf_event_open is available
comment|// if the kernel is too old, it generates ENOSYS
return|return
name|perf_event_open
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|ENOSYS
return|;
block|}
end_function
begin_constructor
DECL|function|QBenchmarkPerfEventsMeasurer
name|QBenchmarkPerfEventsMeasurer
operator|::
name|QBenchmarkPerfEventsMeasurer
parameter_list|()
member_init_list|:
name|fd
argument_list|(
operator|-
literal|1
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QBenchmarkPerfEventsMeasurer
name|QBenchmarkPerfEventsMeasurer
operator|::
name|~
name|QBenchmarkPerfEventsMeasurer
parameter_list|()
block|{
name|qt_safe_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|init
name|void
name|QBenchmarkPerfEventsMeasurer
operator|::
name|init
parameter_list|()
block|{
name|perf_event_attr
name|attr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|attr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|attr
argument_list|)
expr_stmt|;
comment|// common init
name|attr
operator|.
name|size
operator|=
sizeof|sizeof
name|attr
expr_stmt|;
name|attr
operator|.
name|sample_period
operator|=
literal|0
expr_stmt|;
name|attr
operator|.
name|sample_type
operator|=
literal|0
expr_stmt|;
name|attr
operator|.
name|read_format
operator|=
name|PERF_FORMAT_TOTAL_TIME_ENABLED
operator||
name|PERF_FORMAT_TOTAL_TIME_RUNNING
expr_stmt|;
name|attr
operator|.
name|disabled
operator|=
literal|true
expr_stmt|;
comment|// start disabled, we'll enable later
name|attr
operator|.
name|inherit
operator|=
literal|true
expr_stmt|;
comment|// let children inherit, if the benchmark has child processes
name|attr
operator|.
name|pinned
operator|=
literal|true
expr_stmt|;
comment|// keep it running on the PMU
name|attr
operator|.
name|inherit_stat
operator|=
literal|true
expr_stmt|;
comment|// collapse all the info from child processes
name|attr
operator|.
name|task
operator|=
literal|true
expr_stmt|;
comment|// trace fork and exit
comment|// our event type
comment|// ### FIXME hardcoded for now
name|attr
operator|.
name|type
operator|=
name|PERF_TYPE_HARDWARE
expr_stmt|;
name|attr
operator|.
name|config
operator|=
name|PERF_COUNT_HW_CPU_CYCLES
expr_stmt|;
comment|// pid == 0 -> attach to the current process
comment|// cpu == -1 -> monitor on all CPUs
comment|// group_fd == -1 -> this is the group leader
comment|// flags == 0 -> reserved, must be zero
name|fd
operator|=
name|perf_event_open
argument_list|(
operator|&
name|attr
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"QBenchmarkPerfEventsMeasurer::start: perf_event_open"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|::
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|start
name|void
name|QBenchmarkPerfEventsMeasurer
operator|::
name|start
parameter_list|()
block|{
comment|// enable the counter
operator|::
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PERF_EVENT_IOC_RESET
argument_list|)
expr_stmt|;
operator|::
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PERF_EVENT_IOC_ENABLE
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|checkpoint
name|qint64
name|QBenchmarkPerfEventsMeasurer
operator|::
name|checkpoint
parameter_list|()
block|{
operator|::
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PERF_EVENT_IOC_DISABLE
argument_list|)
expr_stmt|;
name|qint64
name|value
init|=
name|readValue
argument_list|()
decl_stmt|;
operator|::
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PERF_EVENT_IOC_ENABLE
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function
begin_function
DECL|function|stop
name|qint64
name|QBenchmarkPerfEventsMeasurer
operator|::
name|stop
parameter_list|()
block|{
comment|// disable the counter
operator|::
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PERF_EVENT_IOC_DISABLE
argument_list|)
expr_stmt|;
return|return
name|readValue
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|isMeasurementAccepted
name|bool
name|QBenchmarkPerfEventsMeasurer
operator|::
name|isMeasurementAccepted
parameter_list|(
name|qint64
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|adjustIterationCount
name|int
name|QBenchmarkPerfEventsMeasurer
operator|::
name|adjustIterationCount
parameter_list|(
name|int
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|adjustMedianCount
name|int
name|QBenchmarkPerfEventsMeasurer
operator|::
name|adjustMedianCount
parameter_list|(
name|int
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|metricType
name|QTest
operator|::
name|QBenchmarkMetric
name|QBenchmarkPerfEventsMeasurer
operator|::
name|metricType
parameter_list|()
block|{
return|return
name|QTest
operator|::
name|Events
return|;
block|}
end_function
begin_function
DECL|function|readValue
name|qint64
name|QBenchmarkPerfEventsMeasurer
operator|::
name|readValue
parameter_list|()
block|{
comment|/* from the kernel docs:      * struct read_format {      *  { u64           value;      *    { u64         time_enabled; }&& PERF_FORMAT_TOTAL_TIME_ENABLED      *    { u64         time_running; }&& PERF_FORMAT_TOTAL_TIME_RUNNING      *    { u64         id;           }&& PERF_FORMAT_ID      *  }&& !PERF_FORMAT_GROUP      */
struct|struct
name|read_format
block|{
name|quint64
name|value
decl_stmt|;
name|quint64
name|time_enabled
decl_stmt|;
name|quint64
name|time_running
decl_stmt|;
block|}
name|results
struct|;
name|size_t
name|nread
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|nread
operator|<
sizeof|sizeof
name|results
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|results
argument_list|)
decl_stmt|;
name|qint64
name|r
init|=
name|qt_safe_read
argument_list|(
name|fd
argument_list|,
name|ptr
operator|+
name|nread
argument_list|,
sizeof|sizeof
name|results
operator|-
name|nread
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"QBenchmarkPerfEventsMeasurer::readValue: reading the results"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|nread
operator|+=
name|quint64
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|results
operator|.
name|time_running
operator|==
name|results
operator|.
name|time_enabled
condition|)
return|return
name|results
operator|.
name|value
return|;
comment|// scale the results, though this shouldn't happen!
return|return
name|results
operator|.
name|value
operator|*
operator|(
name|double
argument_list|(
name|results
operator|.
name|time_running
argument_list|)
operator|/
name|double
argument_list|(
name|results
operator|.
name|time_enabled
argument_list|)
operator|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
end_unit
