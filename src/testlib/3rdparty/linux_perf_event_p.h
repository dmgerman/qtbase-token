begin_unit
begin_comment
comment|/*  * Performance events:  *  *    Copyright (C) 2008-2009, Thomas Gleixner<tglx@linutronix.de>  *    Copyright (C) 2008-2011, Red Hat, Inc., Ingo Molnar  *    Copyright (C) 2008-2011, Red Hat, Inc., Peter Zijlstra  *  * Data type definitions, declarations, prototypes.  *  *    Started by: Thomas Gleixner and Ingo Molnar  *  * For licencing details see kernel-base/COPYING  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_UAPI_LINUX_PERF_EVENT_H
end_ifndef
begin_define
DECL|macro|_UAPI_LINUX_PERF_EVENT_H
define|#
directive|define
name|_UAPI_LINUX_PERF_EVENT_H
end_define
begin_include
include|#
directive|include
file|<linux/types.h>
end_include
begin_include
include|#
directive|include
file|<linux/ioctl.h>
end_include
begin_include
include|#
directive|include
file|<asm/byteorder.h>
end_include
begin_comment
comment|/*  * User-space ABI bits:  */
end_comment
begin_comment
comment|/*  * attr.type  */
end_comment
begin_enum
DECL|enum|perf_type_id
enum|enum
name|perf_type_id
block|{
DECL|enumerator|PERF_TYPE_HARDWARE
name|PERF_TYPE_HARDWARE
init|=
literal|0
block|,
DECL|enumerator|PERF_TYPE_SOFTWARE
name|PERF_TYPE_SOFTWARE
init|=
literal|1
block|,
DECL|enumerator|PERF_TYPE_TRACEPOINT
name|PERF_TYPE_TRACEPOINT
init|=
literal|2
block|,
DECL|enumerator|PERF_TYPE_HW_CACHE
name|PERF_TYPE_HW_CACHE
init|=
literal|3
block|,
DECL|enumerator|PERF_TYPE_RAW
name|PERF_TYPE_RAW
init|=
literal|4
block|,
DECL|enumerator|PERF_TYPE_BREAKPOINT
name|PERF_TYPE_BREAKPOINT
init|=
literal|5
block|,
DECL|enumerator|PERF_TYPE_MAX
name|PERF_TYPE_MAX
block|,
comment|/* non-ABI */
block|}
enum|;
end_enum
begin_comment
comment|/*  * Generalized performance event event_id types, used by the  * attr.event_id parameter of the sys_perf_event_open()  * syscall:  */
end_comment
begin_enum
DECL|enum|perf_hw_id
enum|enum
name|perf_hw_id
block|{
comment|/* 	 * Common hardware events, generalized by the kernel: 	 */
DECL|enumerator|PERF_COUNT_HW_CPU_CYCLES
name|PERF_COUNT_HW_CPU_CYCLES
init|=
literal|0
block|,
DECL|enumerator|PERF_COUNT_HW_INSTRUCTIONS
name|PERF_COUNT_HW_INSTRUCTIONS
init|=
literal|1
block|,
DECL|enumerator|PERF_COUNT_HW_CACHE_REFERENCES
name|PERF_COUNT_HW_CACHE_REFERENCES
init|=
literal|2
block|,
DECL|enumerator|PERF_COUNT_HW_CACHE_MISSES
name|PERF_COUNT_HW_CACHE_MISSES
init|=
literal|3
block|,
DECL|enumerator|PERF_COUNT_HW_BRANCH_INSTRUCTIONS
name|PERF_COUNT_HW_BRANCH_INSTRUCTIONS
init|=
literal|4
block|,
DECL|enumerator|PERF_COUNT_HW_BRANCH_MISSES
name|PERF_COUNT_HW_BRANCH_MISSES
init|=
literal|5
block|,
DECL|enumerator|PERF_COUNT_HW_BUS_CYCLES
name|PERF_COUNT_HW_BUS_CYCLES
init|=
literal|6
block|,
DECL|enumerator|PERF_COUNT_HW_STALLED_CYCLES_FRONTEND
name|PERF_COUNT_HW_STALLED_CYCLES_FRONTEND
init|=
literal|7
block|,
DECL|enumerator|PERF_COUNT_HW_STALLED_CYCLES_BACKEND
name|PERF_COUNT_HW_STALLED_CYCLES_BACKEND
init|=
literal|8
block|,
DECL|enumerator|PERF_COUNT_HW_REF_CPU_CYCLES
name|PERF_COUNT_HW_REF_CPU_CYCLES
init|=
literal|9
block|,
DECL|enumerator|PERF_COUNT_HW_MAX
name|PERF_COUNT_HW_MAX
block|,
comment|/* non-ABI */
block|}
enum|;
end_enum
begin_comment
comment|/*  * Generalized hardware cache events:  *  *       { L1-D, L1-I, LLC, ITLB, DTLB, BPU, NODE } x  *       { read, write, prefetch } x  *       { accesses, misses }  */
end_comment
begin_enum
DECL|enum|perf_hw_cache_id
enum|enum
name|perf_hw_cache_id
block|{
DECL|enumerator|PERF_COUNT_HW_CACHE_L1D
name|PERF_COUNT_HW_CACHE_L1D
init|=
literal|0
block|,
DECL|enumerator|PERF_COUNT_HW_CACHE_L1I
name|PERF_COUNT_HW_CACHE_L1I
init|=
literal|1
block|,
DECL|enumerator|PERF_COUNT_HW_CACHE_LL
name|PERF_COUNT_HW_CACHE_LL
init|=
literal|2
block|,
DECL|enumerator|PERF_COUNT_HW_CACHE_DTLB
name|PERF_COUNT_HW_CACHE_DTLB
init|=
literal|3
block|,
DECL|enumerator|PERF_COUNT_HW_CACHE_ITLB
name|PERF_COUNT_HW_CACHE_ITLB
init|=
literal|4
block|,
DECL|enumerator|PERF_COUNT_HW_CACHE_BPU
name|PERF_COUNT_HW_CACHE_BPU
init|=
literal|5
block|,
DECL|enumerator|PERF_COUNT_HW_CACHE_NODE
name|PERF_COUNT_HW_CACHE_NODE
init|=
literal|6
block|,
DECL|enumerator|PERF_COUNT_HW_CACHE_MAX
name|PERF_COUNT_HW_CACHE_MAX
block|,
comment|/* non-ABI */
block|}
enum|;
end_enum
begin_enum
DECL|enum|perf_hw_cache_op_id
enum|enum
name|perf_hw_cache_op_id
block|{
DECL|enumerator|PERF_COUNT_HW_CACHE_OP_READ
name|PERF_COUNT_HW_CACHE_OP_READ
init|=
literal|0
block|,
DECL|enumerator|PERF_COUNT_HW_CACHE_OP_WRITE
name|PERF_COUNT_HW_CACHE_OP_WRITE
init|=
literal|1
block|,
DECL|enumerator|PERF_COUNT_HW_CACHE_OP_PREFETCH
name|PERF_COUNT_HW_CACHE_OP_PREFETCH
init|=
literal|2
block|,
DECL|enumerator|PERF_COUNT_HW_CACHE_OP_MAX
name|PERF_COUNT_HW_CACHE_OP_MAX
block|,
comment|/* non-ABI */
block|}
enum|;
end_enum
begin_enum
DECL|enum|perf_hw_cache_op_result_id
enum|enum
name|perf_hw_cache_op_result_id
block|{
DECL|enumerator|PERF_COUNT_HW_CACHE_RESULT_ACCESS
name|PERF_COUNT_HW_CACHE_RESULT_ACCESS
init|=
literal|0
block|,
DECL|enumerator|PERF_COUNT_HW_CACHE_RESULT_MISS
name|PERF_COUNT_HW_CACHE_RESULT_MISS
init|=
literal|1
block|,
DECL|enumerator|PERF_COUNT_HW_CACHE_RESULT_MAX
name|PERF_COUNT_HW_CACHE_RESULT_MAX
block|,
comment|/* non-ABI */
block|}
enum|;
end_enum
begin_comment
comment|/*  * Special "software" events provided by the kernel, even if the hardware  * does not support performance events. These events measure various  * physical and sw events of the kernel (and allow the profiling of them as  * well):  */
end_comment
begin_enum
DECL|enum|perf_sw_ids
enum|enum
name|perf_sw_ids
block|{
DECL|enumerator|PERF_COUNT_SW_CPU_CLOCK
name|PERF_COUNT_SW_CPU_CLOCK
init|=
literal|0
block|,
DECL|enumerator|PERF_COUNT_SW_TASK_CLOCK
name|PERF_COUNT_SW_TASK_CLOCK
init|=
literal|1
block|,
DECL|enumerator|PERF_COUNT_SW_PAGE_FAULTS
name|PERF_COUNT_SW_PAGE_FAULTS
init|=
literal|2
block|,
DECL|enumerator|PERF_COUNT_SW_CONTEXT_SWITCHES
name|PERF_COUNT_SW_CONTEXT_SWITCHES
init|=
literal|3
block|,
DECL|enumerator|PERF_COUNT_SW_CPU_MIGRATIONS
name|PERF_COUNT_SW_CPU_MIGRATIONS
init|=
literal|4
block|,
DECL|enumerator|PERF_COUNT_SW_PAGE_FAULTS_MIN
name|PERF_COUNT_SW_PAGE_FAULTS_MIN
init|=
literal|5
block|,
DECL|enumerator|PERF_COUNT_SW_PAGE_FAULTS_MAJ
name|PERF_COUNT_SW_PAGE_FAULTS_MAJ
init|=
literal|6
block|,
DECL|enumerator|PERF_COUNT_SW_ALIGNMENT_FAULTS
name|PERF_COUNT_SW_ALIGNMENT_FAULTS
init|=
literal|7
block|,
DECL|enumerator|PERF_COUNT_SW_EMULATION_FAULTS
name|PERF_COUNT_SW_EMULATION_FAULTS
init|=
literal|8
block|,
DECL|enumerator|PERF_COUNT_SW_MAX
name|PERF_COUNT_SW_MAX
block|,
comment|/* non-ABI */
block|}
enum|;
end_enum
begin_comment
comment|/*  * Bits that can be set in attr.sample_type to request information  * in the overflow packets.  */
end_comment
begin_enum
DECL|enum|perf_event_sample_format
enum|enum
name|perf_event_sample_format
block|{
DECL|enumerator|PERF_SAMPLE_IP
name|PERF_SAMPLE_IP
init|=
literal|1U
operator|<<
literal|0
block|,
DECL|enumerator|PERF_SAMPLE_TID
name|PERF_SAMPLE_TID
init|=
literal|1U
operator|<<
literal|1
block|,
DECL|enumerator|PERF_SAMPLE_TIME
name|PERF_SAMPLE_TIME
init|=
literal|1U
operator|<<
literal|2
block|,
DECL|enumerator|PERF_SAMPLE_ADDR
name|PERF_SAMPLE_ADDR
init|=
literal|1U
operator|<<
literal|3
block|,
DECL|enumerator|PERF_SAMPLE_READ
name|PERF_SAMPLE_READ
init|=
literal|1U
operator|<<
literal|4
block|,
DECL|enumerator|PERF_SAMPLE_CALLCHAIN
name|PERF_SAMPLE_CALLCHAIN
init|=
literal|1U
operator|<<
literal|5
block|,
DECL|enumerator|PERF_SAMPLE_ID
name|PERF_SAMPLE_ID
init|=
literal|1U
operator|<<
literal|6
block|,
DECL|enumerator|PERF_SAMPLE_CPU
name|PERF_SAMPLE_CPU
init|=
literal|1U
operator|<<
literal|7
block|,
DECL|enumerator|PERF_SAMPLE_PERIOD
name|PERF_SAMPLE_PERIOD
init|=
literal|1U
operator|<<
literal|8
block|,
DECL|enumerator|PERF_SAMPLE_STREAM_ID
name|PERF_SAMPLE_STREAM_ID
init|=
literal|1U
operator|<<
literal|9
block|,
DECL|enumerator|PERF_SAMPLE_RAW
name|PERF_SAMPLE_RAW
init|=
literal|1U
operator|<<
literal|10
block|,
DECL|enumerator|PERF_SAMPLE_BRANCH_STACK
name|PERF_SAMPLE_BRANCH_STACK
init|=
literal|1U
operator|<<
literal|11
block|,
DECL|enumerator|PERF_SAMPLE_REGS_USER
name|PERF_SAMPLE_REGS_USER
init|=
literal|1U
operator|<<
literal|12
block|,
DECL|enumerator|PERF_SAMPLE_STACK_USER
name|PERF_SAMPLE_STACK_USER
init|=
literal|1U
operator|<<
literal|13
block|,
DECL|enumerator|PERF_SAMPLE_MAX
name|PERF_SAMPLE_MAX
init|=
literal|1U
operator|<<
literal|14
block|,
comment|/* non-ABI */
block|}
enum|;
end_enum
begin_comment
comment|/*  * values to program into branch_sample_type when PERF_SAMPLE_BRANCH is set  *  * If the user does not pass priv level information via branch_sample_type,  * the kernel uses the event's priv level. Branch and event priv levels do  * not have to match. Branch priv level is checked for permissions.  *  * The branch types can be combined, however BRANCH_ANY covers all types  * of branches and therefore it supersedes all the other types.  */
end_comment
begin_enum
DECL|enum|perf_branch_sample_type
enum|enum
name|perf_branch_sample_type
block|{
DECL|enumerator|PERF_SAMPLE_BRANCH_USER
name|PERF_SAMPLE_BRANCH_USER
init|=
literal|1U
operator|<<
literal|0
block|,
comment|/* user branches */
DECL|enumerator|PERF_SAMPLE_BRANCH_KERNEL
name|PERF_SAMPLE_BRANCH_KERNEL
init|=
literal|1U
operator|<<
literal|1
block|,
comment|/* kernel branches */
DECL|enumerator|PERF_SAMPLE_BRANCH_HV
name|PERF_SAMPLE_BRANCH_HV
init|=
literal|1U
operator|<<
literal|2
block|,
comment|/* hypervisor branches */
DECL|enumerator|PERF_SAMPLE_BRANCH_ANY
name|PERF_SAMPLE_BRANCH_ANY
init|=
literal|1U
operator|<<
literal|3
block|,
comment|/* any branch types */
DECL|enumerator|PERF_SAMPLE_BRANCH_ANY_CALL
name|PERF_SAMPLE_BRANCH_ANY_CALL
init|=
literal|1U
operator|<<
literal|4
block|,
comment|/* any call branch */
DECL|enumerator|PERF_SAMPLE_BRANCH_ANY_RETURN
name|PERF_SAMPLE_BRANCH_ANY_RETURN
init|=
literal|1U
operator|<<
literal|5
block|,
comment|/* any return branch */
DECL|enumerator|PERF_SAMPLE_BRANCH_IND_CALL
name|PERF_SAMPLE_BRANCH_IND_CALL
init|=
literal|1U
operator|<<
literal|6
block|,
comment|/* indirect calls */
DECL|enumerator|PERF_SAMPLE_BRANCH_MAX
name|PERF_SAMPLE_BRANCH_MAX
init|=
literal|1U
operator|<<
literal|7
block|,
comment|/* non-ABI */
block|}
enum|;
end_enum
begin_define
DECL|macro|PERF_SAMPLE_BRANCH_PLM_ALL
define|#
directive|define
name|PERF_SAMPLE_BRANCH_PLM_ALL
define|\
value|(PERF_SAMPLE_BRANCH_USER|\ 	 PERF_SAMPLE_BRANCH_KERNEL|\ 	 PERF_SAMPLE_BRANCH_HV)
end_define
begin_comment
comment|/*  * Values to determine ABI of the registers dump.  */
end_comment
begin_enum
DECL|enum|perf_sample_regs_abi
enum|enum
name|perf_sample_regs_abi
block|{
DECL|enumerator|PERF_SAMPLE_REGS_ABI_NONE
name|PERF_SAMPLE_REGS_ABI_NONE
init|=
literal|0
block|,
DECL|enumerator|PERF_SAMPLE_REGS_ABI_32
name|PERF_SAMPLE_REGS_ABI_32
init|=
literal|1
block|,
DECL|enumerator|PERF_SAMPLE_REGS_ABI_64
name|PERF_SAMPLE_REGS_ABI_64
init|=
literal|2
block|, }
enum|;
end_enum
begin_comment
comment|/*  * The format of the data returned by read() on a perf event fd,  * as specified by attr.read_format:  *  * struct read_format {  *	{ u64		value;  *	  { u64		time_enabled; }&& PERF_FORMAT_TOTAL_TIME_ENABLED  *	  { u64		time_running; }&& PERF_FORMAT_TOTAL_TIME_RUNNING  *	  { u64		id;           }&& PERF_FORMAT_ID  *	}&& !PERF_FORMAT_GROUP  *  *	{ u64		nr;  *	  { u64		time_enabled; }&& PERF_FORMAT_TOTAL_TIME_ENABLED  *	  { u64		time_running; }&& PERF_FORMAT_TOTAL_TIME_RUNNING  *	  { u64		value;  *	    { u64	id;           }&& PERF_FORMAT_ID  *	  }		cntr[nr];  *	}&& PERF_FORMAT_GROUP  * };  */
end_comment
begin_enum
DECL|enum|perf_event_read_format
enum|enum
name|perf_event_read_format
block|{
DECL|enumerator|PERF_FORMAT_TOTAL_TIME_ENABLED
name|PERF_FORMAT_TOTAL_TIME_ENABLED
init|=
literal|1U
operator|<<
literal|0
block|,
DECL|enumerator|PERF_FORMAT_TOTAL_TIME_RUNNING
name|PERF_FORMAT_TOTAL_TIME_RUNNING
init|=
literal|1U
operator|<<
literal|1
block|,
DECL|enumerator|PERF_FORMAT_ID
name|PERF_FORMAT_ID
init|=
literal|1U
operator|<<
literal|2
block|,
DECL|enumerator|PERF_FORMAT_GROUP
name|PERF_FORMAT_GROUP
init|=
literal|1U
operator|<<
literal|3
block|,
DECL|enumerator|PERF_FORMAT_MAX
name|PERF_FORMAT_MAX
init|=
literal|1U
operator|<<
literal|4
block|,
comment|/* non-ABI */
block|}
enum|;
end_enum
begin_define
DECL|macro|PERF_ATTR_SIZE_VER0
define|#
directive|define
name|PERF_ATTR_SIZE_VER0
value|64
end_define
begin_comment
DECL|macro|PERF_ATTR_SIZE_VER0
comment|/* sizeof first published struct */
end_comment
begin_define
DECL|macro|PERF_ATTR_SIZE_VER1
define|#
directive|define
name|PERF_ATTR_SIZE_VER1
value|72
end_define
begin_comment
DECL|macro|PERF_ATTR_SIZE_VER1
comment|/* add: config2 */
end_comment
begin_define
DECL|macro|PERF_ATTR_SIZE_VER2
define|#
directive|define
name|PERF_ATTR_SIZE_VER2
value|80
end_define
begin_comment
DECL|macro|PERF_ATTR_SIZE_VER2
comment|/* add: branch_sample_type */
end_comment
begin_define
DECL|macro|PERF_ATTR_SIZE_VER3
define|#
directive|define
name|PERF_ATTR_SIZE_VER3
value|96
end_define
begin_comment
DECL|macro|PERF_ATTR_SIZE_VER3
comment|/* add: sample_regs_user */
end_comment
begin_comment
comment|/* add: sample_stack_user */
end_comment
begin_comment
comment|/*  * Hardware event_id to monitor via a performance monitoring event:  */
end_comment
begin_struct
DECL|struct|perf_event_attr
struct|struct
name|perf_event_attr
block|{
comment|/* 	 * Major type: hardware/software/tracepoint/etc. 	 */
DECL|member|type
name|__u32
name|type
decl_stmt|;
comment|/* 	 * Size of the attr structure, for fwd/bwd compat. 	 */
DECL|member|size
name|__u32
name|size
decl_stmt|;
comment|/* 	 * Type specific configuration information. 	 */
DECL|member|config
name|__u64
name|config
decl_stmt|;
union|union
block|{
DECL|member|sample_period
name|__u64
name|sample_period
decl_stmt|;
DECL|member|sample_freq
name|__u64
name|sample_freq
decl_stmt|;
block|}
union|;
DECL|member|sample_type
name|__u64
name|sample_type
decl_stmt|;
DECL|member|read_format
name|__u64
name|read_format
decl_stmt|;
DECL|member|disabled
name|__u64
name|disabled
range|:
literal|1
decl_stmt|,
comment|/* off by default        */
DECL|member|inherit
name|inherit
range|:
literal|1
decl_stmt|,
comment|/* children inherit it   */
DECL|member|pinned
name|pinned
range|:
literal|1
decl_stmt|,
comment|/* must always be on PMU */
DECL|member|exclusive
name|exclusive
range|:
literal|1
decl_stmt|,
comment|/* only group on PMU     */
DECL|member|exclude_user
name|exclude_user
range|:
literal|1
decl_stmt|,
comment|/* don't count user      */
DECL|member|exclude_kernel
name|exclude_kernel
range|:
literal|1
decl_stmt|,
comment|/* ditto kernel          */
DECL|member|exclude_hv
name|exclude_hv
range|:
literal|1
decl_stmt|,
comment|/* ditto hypervisor      */
DECL|member|exclude_idle
name|exclude_idle
range|:
literal|1
decl_stmt|,
comment|/* don't count when idle */
DECL|member|mmap
name|mmap
range|:
literal|1
decl_stmt|,
comment|/* include mmap data     */
DECL|member|comm
name|comm
range|:
literal|1
decl_stmt|,
comment|/* include comm data     */
DECL|member|freq
name|freq
range|:
literal|1
decl_stmt|,
comment|/* use freq, not period  */
DECL|member|inherit_stat
name|inherit_stat
range|:
literal|1
decl_stmt|,
comment|/* per task counts       */
DECL|member|enable_on_exec
name|enable_on_exec
range|:
literal|1
decl_stmt|,
comment|/* next exec enables     */
DECL|member|task
name|task
range|:
literal|1
decl_stmt|,
comment|/* trace fork/exit       */
DECL|member|watermark
name|watermark
range|:
literal|1
decl_stmt|,
comment|/* wakeup_watermark      */
comment|/* 				 * precise_ip: 				 * 				 *  0 - SAMPLE_IP can have arbitrary skid 				 *  1 - SAMPLE_IP must have constant skid 				 *  2 - SAMPLE_IP requested to have 0 skid 				 *  3 - SAMPLE_IP must have 0 skid 				 * 				 *  See also PERF_RECORD_MISC_EXACT_IP 				 */
DECL|member|precise_ip
name|precise_ip
range|:
literal|2
decl_stmt|,
comment|/* skid constraint       */
DECL|member|mmap_data
name|mmap_data
range|:
literal|1
decl_stmt|,
comment|/* non-exec mmap data    */
DECL|member|sample_id_all
name|sample_id_all
range|:
literal|1
decl_stmt|,
comment|/* sample_type all events */
DECL|member|exclude_host
name|exclude_host
range|:
literal|1
decl_stmt|,
comment|/* don't count in host   */
DECL|member|exclude_guest
name|exclude_guest
range|:
literal|1
decl_stmt|,
comment|/* don't count in guest  */
DECL|member|exclude_callchain_kernel
name|exclude_callchain_kernel
range|:
literal|1
decl_stmt|,
comment|/* exclude kernel callchains */
DECL|member|exclude_callchain_user
name|exclude_callchain_user
range|:
literal|1
decl_stmt|,
comment|/* exclude user callchains */
DECL|member|__reserved_1
name|__reserved_1
range|:
literal|41
decl_stmt|;
union|union
block|{
DECL|member|wakeup_events
name|__u32
name|wakeup_events
decl_stmt|;
comment|/* wakeup every n events */
DECL|member|wakeup_watermark
name|__u32
name|wakeup_watermark
decl_stmt|;
comment|/* bytes before wakeup   */
block|}
union|;
DECL|member|bp_type
name|__u32
name|bp_type
decl_stmt|;
union|union
block|{
DECL|member|bp_addr
name|__u64
name|bp_addr
decl_stmt|;
DECL|member|config1
name|__u64
name|config1
decl_stmt|;
comment|/* extension of config */
block|}
union|;
union|union
block|{
DECL|member|bp_len
name|__u64
name|bp_len
decl_stmt|;
DECL|member|config2
name|__u64
name|config2
decl_stmt|;
comment|/* extension of config1 */
block|}
union|;
DECL|member|branch_sample_type
name|__u64
name|branch_sample_type
decl_stmt|;
comment|/* enum perf_branch_sample_type */
comment|/* 	 * Defines set of user regs to dump on samples. 	 * See asm/perf_regs.h for details. 	 */
DECL|member|sample_regs_user
name|__u64
name|sample_regs_user
decl_stmt|;
comment|/* 	 * Defines size of the user stack to dump on samples. 	 */
DECL|member|sample_stack_user
name|__u32
name|sample_stack_user
decl_stmt|;
comment|/* Align to u64. */
DECL|member|__reserved_2
name|__u32
name|__reserved_2
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|perf_flags
define|#
directive|define
name|perf_flags
parameter_list|(
name|attr
parameter_list|)
value|(*(&(attr)->read_format + 1))
end_define
begin_comment
comment|/*  * Ioctls that can be done on a perf event fd:  */
end_comment
begin_define
DECL|macro|PERF_EVENT_IOC_ENABLE
define|#
directive|define
name|PERF_EVENT_IOC_ENABLE
value|_IO ('$', 0)
end_define
begin_define
DECL|macro|PERF_EVENT_IOC_DISABLE
define|#
directive|define
name|PERF_EVENT_IOC_DISABLE
value|_IO ('$', 1)
end_define
begin_define
DECL|macro|PERF_EVENT_IOC_REFRESH
define|#
directive|define
name|PERF_EVENT_IOC_REFRESH
value|_IO ('$', 2)
end_define
begin_define
DECL|macro|PERF_EVENT_IOC_RESET
define|#
directive|define
name|PERF_EVENT_IOC_RESET
value|_IO ('$', 3)
end_define
begin_define
DECL|macro|PERF_EVENT_IOC_PERIOD
define|#
directive|define
name|PERF_EVENT_IOC_PERIOD
value|_IOW('$', 4, __u64)
end_define
begin_define
DECL|macro|PERF_EVENT_IOC_SET_OUTPUT
define|#
directive|define
name|PERF_EVENT_IOC_SET_OUTPUT
value|_IO ('$', 5)
end_define
begin_define
DECL|macro|PERF_EVENT_IOC_SET_FILTER
define|#
directive|define
name|PERF_EVENT_IOC_SET_FILTER
value|_IOW('$', 6, char *)
end_define
begin_enum
DECL|enum|perf_event_ioc_flags
enum|enum
name|perf_event_ioc_flags
block|{
DECL|enumerator|PERF_IOC_FLAG_GROUP
name|PERF_IOC_FLAG_GROUP
init|=
literal|1U
operator|<<
literal|0
block|, }
enum|;
end_enum
begin_comment
comment|/*  * Structure of the page that can be mapped via mmap  */
end_comment
begin_struct
DECL|struct|perf_event_mmap_page
struct|struct
name|perf_event_mmap_page
block|{
DECL|member|version
name|__u32
name|version
decl_stmt|;
comment|/* version number of this structure */
DECL|member|compat_version
name|__u32
name|compat_version
decl_stmt|;
comment|/* lowest version this is compat with */
comment|/* 	 * Bits needed to read the hw events in user-space. 	 * 	 *   u32 seq, time_mult, time_shift, idx, width; 	 *   u64 count, enabled, running; 	 *   u64 cyc, time_offset; 	 *   s64 pmc = 0; 	 * 	 *   do { 	 *     seq = pc->lock; 	 *     barrier() 	 * 	 *     enabled = pc->time_enabled; 	 *     running = pc->time_running; 	 * 	 *     if (pc->cap_usr_time&& enabled != running) { 	 *       cyc = rdtsc(); 	 *       time_offset = pc->time_offset; 	 *       time_mult   = pc->time_mult; 	 *       time_shift  = pc->time_shift; 	 *     } 	 * 	 *     idx = pc->index; 	 *     count = pc->offset; 	 *     if (pc->cap_usr_rdpmc&& idx) { 	 *       width = pc->pmc_width; 	 *       pmc = rdpmc(idx - 1); 	 *     } 	 * 	 *     barrier(); 	 *   } while (pc->lock != seq); 	 * 	 * NOTE: for obvious reason this only works on self-monitoring 	 *       processes. 	 */
DECL|member|lock
name|__u32
name|lock
decl_stmt|;
comment|/* seqlock for synchronization */
DECL|member|index
name|__u32
name|index
decl_stmt|;
comment|/* hardware event identifier */
DECL|member|offset
name|__s64
name|offset
decl_stmt|;
comment|/* add to hardware event value */
DECL|member|time_enabled
name|__u64
name|time_enabled
decl_stmt|;
comment|/* time event active */
DECL|member|time_running
name|__u64
name|time_running
decl_stmt|;
comment|/* time event on cpu */
union|union
block|{
DECL|member|capabilities
name|__u64
name|capabilities
decl_stmt|;
name|__u64
name|cap_usr_time
range|:
literal|1
decl_stmt|,
name|cap_usr_rdpmc
range|:
literal|1
decl_stmt|,
name|cap_____res
range|:
literal|62
decl_stmt|;
block|}
union|;
comment|/* 	 * If cap_usr_rdpmc this field provides the bit-width of the value 	 * read using the rdpmc() or equivalent instruction. This can be used 	 * to sign extend the result like: 	 * 	 *   pmc<<= 64 - width; 	 *   pmc>>= 64 - width; // signed shift right 	 *   count += pmc; 	 */
DECL|member|pmc_width
name|__u16
name|pmc_width
decl_stmt|;
comment|/* 	 * If cap_usr_time the below fields can be used to compute the time 	 * delta since time_enabled (in ns) using rdtsc or similar. 	 * 	 *   u64 quot, rem; 	 *   u64 delta; 	 * 	 *   quot = (cyc>> time_shift); 	 *   rem = cyc& ((1<< time_shift) - 1); 	 *   delta = time_offset + quot * time_mult + 	 *              ((rem * time_mult)>> time_shift); 	 * 	 * Where time_offset,time_mult,time_shift and cyc are read in the 	 * seqcount loop described above. This delta can then be added to 	 * enabled and possible running (if idx), improving the scaling: 	 * 	 *   enabled += delta; 	 *   if (idx) 	 *     running += delta; 	 * 	 *   quot = count / running; 	 *   rem  = count % running; 	 *   count = quot * enabled + (rem * enabled) / running; 	 */
DECL|member|time_shift
name|__u16
name|time_shift
decl_stmt|;
DECL|member|time_mult
name|__u32
name|time_mult
decl_stmt|;
DECL|member|time_offset
name|__u64
name|time_offset
decl_stmt|;
comment|/* 		 * Hole for extension of the self monitor capabilities 		 */
DECL|member|__reserved
name|__u64
name|__reserved
index|[
literal|120
index|]
decl_stmt|;
comment|/* align to 1k */
comment|/* 	 * Control data for the mmap() data buffer. 	 * 	 * User-space reading the @data_head value should issue an rmb(), on 	 * SMP capable platforms, after reading this value -- see 	 * perf_event_wakeup(). 	 * 	 * When the mapping is PROT_WRITE the @data_tail value should be 	 * written by userspace to reflect the last read data. In this case 	 * the kernel will not over-write unread data. 	 */
DECL|member|data_head
name|__u64
name|data_head
decl_stmt|;
comment|/* head in the data section */
DECL|member|data_tail
name|__u64
name|data_tail
decl_stmt|;
comment|/* user-space written tail */
block|}
struct|;
end_struct
begin_define
DECL|macro|PERF_RECORD_MISC_CPUMODE_MASK
define|#
directive|define
name|PERF_RECORD_MISC_CPUMODE_MASK
value|(7<< 0)
end_define
begin_define
DECL|macro|PERF_RECORD_MISC_CPUMODE_UNKNOWN
define|#
directive|define
name|PERF_RECORD_MISC_CPUMODE_UNKNOWN
value|(0<< 0)
end_define
begin_define
DECL|macro|PERF_RECORD_MISC_KERNEL
define|#
directive|define
name|PERF_RECORD_MISC_KERNEL
value|(1<< 0)
end_define
begin_define
DECL|macro|PERF_RECORD_MISC_USER
define|#
directive|define
name|PERF_RECORD_MISC_USER
value|(2<< 0)
end_define
begin_define
DECL|macro|PERF_RECORD_MISC_HYPERVISOR
define|#
directive|define
name|PERF_RECORD_MISC_HYPERVISOR
value|(3<< 0)
end_define
begin_define
DECL|macro|PERF_RECORD_MISC_GUEST_KERNEL
define|#
directive|define
name|PERF_RECORD_MISC_GUEST_KERNEL
value|(4<< 0)
end_define
begin_define
DECL|macro|PERF_RECORD_MISC_GUEST_USER
define|#
directive|define
name|PERF_RECORD_MISC_GUEST_USER
value|(5<< 0)
end_define
begin_comment
comment|/*  * Indicates that the content of PERF_SAMPLE_IP points to  * the actual instruction that triggered the event. See also  * perf_event_attr::precise_ip.  */
end_comment
begin_define
DECL|macro|PERF_RECORD_MISC_EXACT_IP
define|#
directive|define
name|PERF_RECORD_MISC_EXACT_IP
value|(1<< 14)
end_define
begin_comment
comment|/*  * Reserve the last bit to indicate some extended misc field  */
end_comment
begin_define
DECL|macro|PERF_RECORD_MISC_EXT_RESERVED
define|#
directive|define
name|PERF_RECORD_MISC_EXT_RESERVED
value|(1<< 15)
end_define
begin_struct
DECL|struct|perf_event_header
struct|struct
name|perf_event_header
block|{
DECL|member|type
name|__u32
name|type
decl_stmt|;
DECL|member|misc
name|__u16
name|misc
decl_stmt|;
DECL|member|size
name|__u16
name|size
decl_stmt|;
block|}
struct|;
end_struct
begin_enum
DECL|enum|perf_event_type
enum|enum
name|perf_event_type
block|{
comment|/* 	 * If perf_event_attr.sample_id_all is set then all event types will 	 * have the sample_type selected fields related to where/when 	 * (identity) an event took place (TID, TIME, ID, CPU, STREAM_ID) 	 * described in PERF_RECORD_SAMPLE below, it will be stashed just after 	 * the perf_event_header and the fields already present for the existing 	 * fields, i.e. at the end of the payload. That way a newer perf.data 	 * file will be supported by older perf tools, with these new optional 	 * fields being ignored. 	 * 	 * The MMAP events record the PROT_EXEC mappings so that we can 	 * correlate userspace IPs to code. They have the following structure: 	 * 	 * struct { 	 *	struct perf_event_header	header; 	 * 	 *	u32				pid, tid; 	 *	u64				addr; 	 *	u64				len; 	 *	u64				pgoff; 	 *	char				filename[]; 	 * }; 	 */
DECL|enumerator|PERF_RECORD_MMAP
name|PERF_RECORD_MMAP
init|=
literal|1
block|,
comment|/* 	 * struct { 	 *	struct perf_event_header	header; 	 *	u64				id; 	 *	u64				lost; 	 * }; 	 */
DECL|enumerator|PERF_RECORD_LOST
name|PERF_RECORD_LOST
init|=
literal|2
block|,
comment|/* 	 * struct { 	 *	struct perf_event_header	header; 	 * 	 *	u32				pid, tid; 	 *	char				comm[]; 	 * }; 	 */
DECL|enumerator|PERF_RECORD_COMM
name|PERF_RECORD_COMM
init|=
literal|3
block|,
comment|/* 	 * struct { 	 *	struct perf_event_header	header; 	 *	u32				pid, ppid; 	 *	u32				tid, ptid; 	 *	u64				time; 	 * }; 	 */
DECL|enumerator|PERF_RECORD_EXIT
name|PERF_RECORD_EXIT
init|=
literal|4
block|,
comment|/* 	 * struct { 	 *	struct perf_event_header	header; 	 *	u64				time; 	 *	u64				id; 	 *	u64				stream_id; 	 * }; 	 */
DECL|enumerator|PERF_RECORD_THROTTLE
name|PERF_RECORD_THROTTLE
init|=
literal|5
block|,
DECL|enumerator|PERF_RECORD_UNTHROTTLE
name|PERF_RECORD_UNTHROTTLE
init|=
literal|6
block|,
comment|/* 	 * struct { 	 *	struct perf_event_header	header; 	 *	u32				pid, ppid; 	 *	u32				tid, ptid; 	 *	u64				time; 	 * }; 	 */
DECL|enumerator|PERF_RECORD_FORK
name|PERF_RECORD_FORK
init|=
literal|7
block|,
comment|/* 	 * struct { 	 *	struct perf_event_header	header; 	 *	u32				pid, tid; 	 * 	 *	struct read_format		values; 	 * }; 	 */
DECL|enumerator|PERF_RECORD_READ
name|PERF_RECORD_READ
init|=
literal|8
block|,
comment|/* 	 * struct { 	 *	struct perf_event_header	header; 	 * 	 *	{ u64			ip;	  }&& PERF_SAMPLE_IP 	 *	{ u32			pid, tid; }&& PERF_SAMPLE_TID 	 *	{ u64			time;     }&& PERF_SAMPLE_TIME 	 *	{ u64			addr;     }&& PERF_SAMPLE_ADDR 	 *	{ u64			id;	  }&& PERF_SAMPLE_ID 	 *	{ u64			stream_id;}&& PERF_SAMPLE_STREAM_ID 	 *	{ u32			cpu, res; }&& PERF_SAMPLE_CPU 	 *	{ u64			period;   }&& PERF_SAMPLE_PERIOD 	 * 	 *	{ struct read_format	values;	  }&& PERF_SAMPLE_READ 	 * 	 *	{ u64			nr, 	 *	  u64			ips[nr];  }&& PERF_SAMPLE_CALLCHAIN 	 * 	 *	# 	 *	# The RAW record below is opaque data wrt the ABI 	 *	# 	 *	# That is, the ABI doesn't make any promises wrt to 	 *	# the stability of its content, it may vary depending 	 *	# on event, hardware, kernel version and phase of 	 *	# the moon. 	 *	# 	 *	# In other words, PERF_SAMPLE_RAW contents are not an ABI. 	 *	# 	 * 	 *	{ u32			size; 	 *	  char                  data[size];}&& PERF_SAMPLE_RAW 	 * 	 *	{ u64 from, to, flags } lbr[nr];}&& PERF_SAMPLE_BRANCH_STACK 	 * 	 * 	{ u64			abi; # enum perf_sample_regs_abi 	 * 	  u64			regs[weight(mask)]; }&& PERF_SAMPLE_REGS_USER 	 * 	 * 	{ u64			size; 	 * 	  char			data[size]; 	 * 	  u64			dyn_size; }&& PERF_SAMPLE_STACK_USER 	 * }; 	 */
DECL|enumerator|PERF_RECORD_SAMPLE
name|PERF_RECORD_SAMPLE
init|=
literal|9
block|,
DECL|enumerator|PERF_RECORD_MAX
name|PERF_RECORD_MAX
block|,
comment|/* non-ABI */
block|}
enum|;
end_enum
begin_define
DECL|macro|PERF_MAX_STACK_DEPTH
define|#
directive|define
name|PERF_MAX_STACK_DEPTH
value|127
end_define
begin_enum
DECL|enum|perf_callchain_context
enum|enum
name|perf_callchain_context
block|{
DECL|enumerator|PERF_CONTEXT_HV
name|PERF_CONTEXT_HV
init|=
operator|(
name|__u64
operator|)
operator|-
literal|32
block|,
DECL|enumerator|PERF_CONTEXT_KERNEL
name|PERF_CONTEXT_KERNEL
init|=
operator|(
name|__u64
operator|)
operator|-
literal|128
block|,
DECL|enumerator|PERF_CONTEXT_USER
name|PERF_CONTEXT_USER
init|=
operator|(
name|__u64
operator|)
operator|-
literal|512
block|,
DECL|enumerator|PERF_CONTEXT_GUEST
name|PERF_CONTEXT_GUEST
init|=
operator|(
name|__u64
operator|)
operator|-
literal|2048
block|,
DECL|enumerator|PERF_CONTEXT_GUEST_KERNEL
name|PERF_CONTEXT_GUEST_KERNEL
init|=
operator|(
name|__u64
operator|)
operator|-
literal|2176
block|,
DECL|enumerator|PERF_CONTEXT_GUEST_USER
name|PERF_CONTEXT_GUEST_USER
init|=
operator|(
name|__u64
operator|)
operator|-
literal|2560
block|,
DECL|enumerator|PERF_CONTEXT_MAX
name|PERF_CONTEXT_MAX
init|=
operator|(
name|__u64
operator|)
operator|-
literal|4095
block|, }
enum|;
end_enum
begin_define
DECL|macro|PERF_FLAG_FD_NO_GROUP
define|#
directive|define
name|PERF_FLAG_FD_NO_GROUP
value|(1U<< 0)
end_define
begin_define
DECL|macro|PERF_FLAG_FD_OUTPUT
define|#
directive|define
name|PERF_FLAG_FD_OUTPUT
value|(1U<< 1)
end_define
begin_define
DECL|macro|PERF_FLAG_PID_CGROUP
define|#
directive|define
name|PERF_FLAG_PID_CGROUP
value|(1U<< 2)
end_define
begin_comment
DECL|macro|PERF_FLAG_PID_CGROUP
comment|/* pid=cgroup id, per-cpu mode only */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* _UAPI_LINUX_PERF_EVENT_H */
end_comment
end_unit
