begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtSql module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qsqlquery.h"
end_include
begin_comment
comment|//#define QT_DEBUG_SQL
end_comment
begin_include
include|#
directive|include
file|"qatomic.h"
end_include
begin_include
include|#
directive|include
file|"qsqlrecord.h"
end_include
begin_include
include|#
directive|include
file|"qsqlresult.h"
end_include
begin_include
include|#
directive|include
file|"qsqldriver.h"
end_include
begin_include
include|#
directive|include
file|"qsqldatabase.h"
end_include
begin_include
include|#
directive|include
file|"private/qsqlnulldriver_p.h"
end_include
begin_include
include|#
directive|include
file|"qvector.h"
end_include
begin_include
include|#
directive|include
file|"qmap.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QSqlQueryPrivate
class|class
name|QSqlQueryPrivate
block|{
public|public:
name|QSqlQueryPrivate
parameter_list|(
name|QSqlResult
modifier|*
name|result
parameter_list|)
constructor_decl|;
name|~
name|QSqlQueryPrivate
parameter_list|()
destructor_decl|;
DECL|member|ref
name|QAtomicInt
name|ref
decl_stmt|;
DECL|member|sqlResult
name|QSqlResult
modifier|*
name|sqlResult
decl_stmt|;
specifier|static
name|QSqlQueryPrivate
modifier|*
name|shared_null
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|QSqlQueryPrivate
argument_list|,
argument|nullQueryPrivate
argument_list|,
argument|(
literal|0
argument|)
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QSqlNullDriver
argument_list|,
argument|nullDriver
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|QSqlNullResult
argument_list|,
argument|nullResult
argument_list|,
argument|(nullDriver())
argument_list|)
end_macro
begin_function
DECL|function|shared_null
name|QSqlQueryPrivate
modifier|*
name|QSqlQueryPrivate
operator|::
name|shared_null
parameter_list|()
block|{
name|QSqlQueryPrivate
modifier|*
name|null
init|=
name|nullQueryPrivate
argument_list|()
decl_stmt|;
name|null
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
return|return
name|null
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_constructor
DECL|function|QSqlQueryPrivate
name|QSqlQueryPrivate
operator|::
name|QSqlQueryPrivate
parameter_list|(
name|QSqlResult
modifier|*
name|result
parameter_list|)
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|sqlResult
argument_list|(
name|result
argument_list|)
block|{
if|if
condition|(
operator|!
name|sqlResult
condition|)
name|sqlResult
operator|=
name|nullResult
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QSqlQueryPrivate
name|QSqlQueryPrivate
operator|::
name|~
name|QSqlQueryPrivate
parameter_list|()
block|{
name|QSqlResult
modifier|*
name|nr
init|=
name|nullResult
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|nr
operator|||
name|sqlResult
operator|==
name|nr
condition|)
return|return;
operator|delete
name|sqlResult
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \class QSqlQuery     \brief The QSqlQuery class provides a means of executing and     manipulating SQL statements.      \ingroup database     \ingroup shared      \inmodule QtSql      QSqlQuery encapsulates the functionality involved in creating,     navigating and retrieving data from SQL queries which are     executed on a \l QSqlDatabase. It can be used to execute DML     (data manipulation language) statements, such as \c SELECT, \c     INSERT, \c UPDATE and \c DELETE, as well as DDL (data definition     language) statements, such as \c{CREATE} \c{TABLE}. It can also     be used to execute database-specific commands which are not     standard SQL (e.g. \c{SET DATESTYLE=ISO} for PostgreSQL).      Successfully executed SQL statements set the query's state to     active so that isActive() returns true. Otherwise the query's     state is set to inactive. In either case, when executing a new SQL     statement, the query is positioned on an invalid record. An active     query must be navigated to a valid record (so that isValid()     returns true) before values can be retrieved.      For some databases, if an active query that is a \c{SELECT}     statement exists when you call \l{QSqlDatabase::}{commit()} or     \l{QSqlDatabase::}{rollback()}, the commit or rollback will     fail. See isActive() for details.      \target QSqlQuery examples      Navigating records is performed with the following functions:      \list     \li next()     \li previous()     \li first()     \li last()     \li seek()     \endlist      These functions allow the programmer to move forward, backward     or arbitrarily through the records returned by the query. If you     only need to move forward through the results (e.g., by using     next()), you can use setForwardOnly(), which will save a     significant amount of memory overhead and improve performance on     some databases. Once an active query is positioned on a valid     record, data can be retrieved using value(). All data is     transferred from the SQL backend using QVariants.      For example:      \snippet sqldatabase/sqldatabase.cpp 7      To access the data returned by a query, use value(int). Each     field in the data returned by a \c SELECT statement is accessed     by passing the field's position in the statement, starting from     0. This makes using \c{SELECT *} queries inadvisable because the     order of the fields returned is indeterminate.      For the sake of efficiency, there are no functions to access a     field by name (unless you use prepared queries with names, as     explained below). To convert a field name into an index, use     record().\l{QSqlRecord::indexOf()}{indexOf()}, for example:      \snippet sqldatabase/sqldatabase.cpp 8      QSqlQuery supports prepared query execution and the binding of     parameter values to placeholders. Some databases don't support     these features, so for those, Qt emulates the required     functionality. For example, the Oracle and ODBC drivers have     proper prepared query support, and Qt makes use of it; but for     databases that don't have this support, Qt implements the feature     itself, e.g. by replacing placeholders with actual values when a     query is executed. Use numRowsAffected() to find out how many rows     were affected by a non-\c SELECT query, and size() to find how     many were retrieved by a \c SELECT.      Oracle databases identify placeholders by using a colon-name     syntax, e.g \c{:name}. ODBC simply uses \c ? characters. Qt     supports both syntaxes, with the restriction that you can't mix     them in the same query.      You can retrieve the values of all the fields in a single variable     (a map) using boundValues().      \section1 Approaches to Binding Values      Below we present the same example using each of the four     different binding approaches, as well as one example of binding     values to a stored procedure.      \b{Named binding using named placeholders:}      \snippet sqldatabase/sqldatabase.cpp 9      \b{Positional binding using named placeholders:}      \snippet sqldatabase/sqldatabase.cpp 10      \b{Binding values using positional placeholders (version 1):}      \snippet sqldatabase/sqldatabase.cpp 11      \b{Binding values using positional placeholders (version 2):}      \snippet sqldatabase/sqldatabase.cpp 12      \b{Binding values to a stored procedure:}      This code calls a stored procedure called \c AsciiToInt(), passing     it a character through its in parameter, and taking its result in     the out parameter.      \snippet sqldatabase/sqldatabase.cpp 13      Note that unbound parameters will retain their values.      Stored procedures that uses the return statement to return values,     or return multiple result sets, are not fully supported. For specific     details see \l{SQL Database Drivers}.      \warning You must load the SQL driver and open the connection before a     QSqlQuery is created. Also, the connection must remain open while the     query exists; otherwise, the behavior of QSqlQuery is undefined.      \sa QSqlDatabase, QSqlQueryModel, QSqlTableModel, QVariant */
end_comment
begin_comment
comment|/*!     Constructs a QSqlQuery object which uses the QSqlResult \a result     to communicate with a database. */
end_comment
begin_constructor
DECL|function|QSqlQuery
name|QSqlQuery
operator|::
name|QSqlQuery
parameter_list|(
name|QSqlResult
modifier|*
name|result
parameter_list|)
block|{
name|d
operator|=
operator|new
name|QSqlQueryPrivate
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the object and frees any allocated resources. */
end_comment
begin_destructor
DECL|function|~QSqlQuery
name|QSqlQuery
operator|::
name|~
name|QSqlQuery
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Constructs a copy of \a other. */
end_comment
begin_constructor
DECL|function|QSqlQuery
name|QSqlQuery
operator|::
name|QSqlQuery
parameter_list|(
specifier|const
name|QSqlQuery
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qInit
specifier|static
name|void
name|qInit
parameter_list|(
name|QSqlQuery
modifier|*
name|q
parameter_list|,
specifier|const
name|QString
modifier|&
name|query
parameter_list|,
name|QSqlDatabase
name|db
parameter_list|)
block|{
name|QSqlDatabase
name|database
init|=
name|db
decl_stmt|;
if|if
condition|(
operator|!
name|database
operator|.
name|isValid
argument_list|()
condition|)
name|database
operator|=
name|QSqlDatabase
operator|::
name|database
argument_list|(
name|QLatin1String
argument_list|(
name|QSqlDatabase
operator|::
name|defaultConnection
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|database
operator|.
name|isValid
argument_list|()
condition|)
block|{
operator|*
name|q
operator|=
name|QSqlQuery
argument_list|(
name|database
operator|.
name|driver
argument_list|()
operator|->
name|createResult
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|query
operator|.
name|isEmpty
argument_list|()
condition|)
name|q
operator|->
name|exec
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs a QSqlQuery object using the SQL \a query and the     database \a db. If \a db is not specified, or is invalid, the application's     default database is used. If \a query is not an empty string, it     will be executed.      \sa QSqlDatabase */
end_comment
begin_constructor
DECL|function|QSqlQuery
name|QSqlQuery
operator|::
name|QSqlQuery
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|,
name|QSqlDatabase
name|db
parameter_list|)
block|{
name|d
operator|=
name|QSqlQueryPrivate
operator|::
name|shared_null
argument_list|()
expr_stmt|;
name|qInit
argument_list|(
name|this
argument_list|,
name|query
argument_list|,
name|db
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QSqlQuery object using the database \a db.     If \a db is invalid, the application's default database will be used.      \sa QSqlDatabase */
end_comment
begin_constructor
DECL|function|QSqlQuery
name|QSqlQuery
operator|::
name|QSqlQuery
parameter_list|(
name|QSqlDatabase
name|db
parameter_list|)
block|{
name|d
operator|=
name|QSqlQueryPrivate
operator|::
name|shared_null
argument_list|()
expr_stmt|;
name|qInit
argument_list|(
name|this
argument_list|,
name|QString
argument_list|()
argument_list|,
name|db
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns \a other to this object. */
end_comment
begin_function
DECL|function|operator =
name|QSqlQuery
modifier|&
name|QSqlQuery
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QSqlQuery
modifier|&
name|other
parameter_list|)
block|{
name|qAtomicAssign
argument_list|(
name|d
argument_list|,
name|other
operator|.
name|d
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if the query is \l{isActive()}{active} and positioned   on a valid record and the \a field is NULL; otherwise returns   false. Note that for some drivers, isNull() will not return accurate   information until after an attempt is made to retrieve data.    \sa isActive(), isValid(), value() */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QSqlQuery
operator|::
name|isNull
parameter_list|(
name|int
name|field
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|sqlResult
operator|->
name|isActive
argument_list|()
operator|&&
name|d
operator|->
name|sqlResult
operator|->
name|isValid
argument_list|()
condition|)
return|return
name|d
operator|->
name|sqlResult
operator|->
name|isNull
argument_list|(
name|field
argument_list|)
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!    Executes the SQL in \a query. Returns true and sets the query state   to \l{isActive()}{active} if the query was successful; otherwise   returns false. The \a query string must use syntax appropriate for   the SQL database being queried (for example, standard SQL).    After the query is executed, the query is positioned on an \e   invalid record and must be navigated to a valid record before data   values can be retrieved (for example, using next()).    Note that the last error for this query is reset when exec() is   called.    For SQLite, the query string can contain only one statement at a time.   If more than one statement is given, the function returns false.    Example:    \snippet sqldatabase/sqldatabase.cpp 34    \sa isActive(), isValid(), next(), previous(), first(), last(),   seek() */
end_comment
begin_function
DECL|function|exec
name|bool
name|QSqlQuery
operator|::
name|exec
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|bool
name|fo
init|=
name|isForwardOnly
argument_list|()
decl_stmt|;
operator|*
name|this
operator|=
name|QSqlQuery
argument_list|(
name|driver
argument_list|()
operator|->
name|createResult
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|sqlResult
operator|->
name|setNumericalPrecisionPolicy
argument_list|(
name|d
operator|->
name|sqlResult
operator|->
name|numericalPrecisionPolicy
argument_list|()
argument_list|)
expr_stmt|;
name|setForwardOnly
argument_list|(
name|fo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|sqlResult
operator|->
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|sqlResult
operator|->
name|setActive
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|sqlResult
operator|->
name|setLastError
argument_list|(
name|QSqlError
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|sqlResult
operator|->
name|setAt
argument_list|(
name|QSql
operator|::
name|BeforeFirstRow
argument_list|)
expr_stmt|;
name|d
operator|->
name|sqlResult
operator|->
name|setNumericalPrecisionPolicy
argument_list|(
name|d
operator|->
name|sqlResult
operator|->
name|numericalPrecisionPolicy
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|sqlResult
operator|->
name|setQuery
argument_list|(
name|query
operator|.
name|trimmed
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|driver
argument_list|()
operator|->
name|isOpen
argument_list|()
operator|||
name|driver
argument_list|()
operator|->
name|isOpenError
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSqlQuery::exec: database not open"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|query
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSqlQuery::exec: empty query"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
ifdef|#
directive|ifdef
name|QT_DEBUG_SQL
name|qDebug
argument_list|(
literal|"\n QSqlQuery: %s"
argument_list|,
name|query
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|d
operator|->
name|sqlResult
operator|->
name|reset
argument_list|(
name|query
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the value of field \a index in the current record.      The fields are numbered from left to right using the text of the     \c SELECT statement, e.g. in      \snippet code/src_sql_kernel_qsqlquery.cpp 0      field 0 is \c forename and field 1 is \c     surname. Using \c{SELECT *} is not recommended because the order     of the fields in the query is undefined.      An invalid QVariant is returned if field \a index does not     exist, if the query is inactive, or if the query is positioned on     an invalid record.      \sa previous(), next(), first(), last(), seek(), isActive(), isValid() */
end_comment
begin_function
DECL|function|value
name|QVariant
name|QSqlQuery
operator|::
name|value
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isActive
argument_list|()
operator|&&
name|isValid
argument_list|()
operator|&&
operator|(
name|index
operator|>
operator|-
literal|1
operator|)
condition|)
return|return
name|d
operator|->
name|sqlResult
operator|->
name|data
argument_list|(
name|index
argument_list|)
return|;
name|qWarning
argument_list|(
literal|"QSqlQuery::value: not positioned on a valid record"
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the value of the field called \a name in the current record.     If field \a name does not exist an invalid variant is returned.      This overload is less efficient than \l{QSqlQuery::}{value()} */
end_comment
begin_function
DECL|function|value
name|QVariant
name|QSqlQuery
operator|::
name|value
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|int
name|index
init|=
name|d
operator|->
name|sqlResult
operator|->
name|record
argument_list|()
operator|.
name|indexOf
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>
operator|-
literal|1
condition|)
return|return
name|value
argument_list|(
name|index
argument_list|)
return|;
name|qWarning
argument_list|(
literal|"QSqlQuery::value: unknown field name '%s'"
argument_list|,
name|qPrintable
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current internal position of the query. The first     record is at position zero. If the position is invalid, the     function returns QSql::BeforeFirstRow or     QSql::AfterLastRow, which are special negative values.      \sa previous(), next(), first(), last(), seek(), isActive(), isValid() */
end_comment
begin_function
DECL|function|at
name|int
name|QSqlQuery
operator|::
name|at
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sqlResult
operator|->
name|at
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text of the current query being used, or an empty     string if there is no current query text.      \sa executedQuery() */
end_comment
begin_function
DECL|function|lastQuery
name|QString
name|QSqlQuery
operator|::
name|lastQuery
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sqlResult
operator|->
name|lastQuery
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the database driver associated with the query. */
end_comment
begin_function
DECL|function|driver
specifier|const
name|QSqlDriver
modifier|*
name|QSqlQuery
operator|::
name|driver
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sqlResult
operator|->
name|driver
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the result associated with the query. */
end_comment
begin_function
DECL|function|result
specifier|const
name|QSqlResult
modifier|*
name|QSqlQuery
operator|::
name|result
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sqlResult
return|;
block|}
end_function
begin_comment
comment|/*!   Retrieves the record at position \a index, if available, and   positions the query on the retrieved record. The first record is at   position 0. Note that the query must be in an \l{isActive()}   {active} state and isSelect() must return true before calling this   function.    If \a relative is false (the default), the following rules apply:    \list    \li If \a index is negative, the result is positioned before the   first record and false is returned.    \li Otherwise, an attempt is made to move to the record at position   \a index. If the record at position \a index could not be retrieved,   the result is positioned after the last record and false is   returned. If the record is successfully retrieved, true is returned.    \endlist    If \a relative is true, the following rules apply:    \list    \li If the result is currently positioned before the first record or   on the first record, and \a index is negative, there is no change,   and false is returned.    \li If the result is currently located after the last record, and \a   index is positive, there is no change, and false is returned.    \li If the result is currently located somewhere in the middle, and   the relative offset \a index moves the result below zero, the result   is positioned before the first record and false is returned.    \li Otherwise, an attempt is made to move to the record \a index   records ahead of the current record (or \a index records behind the   current record if \a index is negative). If the record at offset \a   index could not be retrieved, the result is positioned after the   last record if \a index>= 0, (or before the first record if \a   index is negative), and false is returned. If the record is   successfully retrieved, true is returned.    \endlist    \sa next(), previous(), first(), last(), at(), isActive(), isValid() */
end_comment
begin_function
DECL|function|seek
name|bool
name|QSqlQuery
operator|::
name|seek
parameter_list|(
name|int
name|index
parameter_list|,
name|bool
name|relative
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isSelect
argument_list|()
operator|||
operator|!
name|isActive
argument_list|()
condition|)
return|return
literal|false
return|;
name|int
name|actualIdx
decl_stmt|;
if|if
condition|(
operator|!
name|relative
condition|)
block|{
comment|// arbitrary seek
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|d
operator|->
name|sqlResult
operator|->
name|setAt
argument_list|(
name|QSql
operator|::
name|BeforeFirstRow
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|actualIdx
operator|=
name|index
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|at
argument_list|()
condition|)
block|{
comment|// relative seek
case|case
name|QSql
operator|::
name|BeforeFirstRow
case|:
if|if
condition|(
name|index
operator|>
literal|0
condition|)
name|actualIdx
operator|=
name|index
expr_stmt|;
else|else
block|{
return|return
literal|false
return|;
block|}
break|break;
case|case
name|QSql
operator|::
name|AfterLastRow
case|:
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|d
operator|->
name|sqlResult
operator|->
name|fetchLast
argument_list|()
expr_stmt|;
name|actualIdx
operator|=
name|at
argument_list|()
operator|+
name|index
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
break|break;
default|default:
if|if
condition|(
operator|(
name|at
argument_list|()
operator|+
name|index
operator|)
operator|<
literal|0
condition|)
block|{
name|d
operator|->
name|sqlResult
operator|->
name|setAt
argument_list|(
name|QSql
operator|::
name|BeforeFirstRow
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|actualIdx
operator|=
name|at
argument_list|()
operator|+
name|index
expr_stmt|;
break|break;
block|}
block|}
comment|// let drivers optimize
if|if
condition|(
name|isForwardOnly
argument_list|()
operator|&&
name|actualIdx
operator|<
name|at
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSqlQuery::seek: cannot seek backwards in a forward only query"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|actualIdx
operator|==
operator|(
name|at
argument_list|()
operator|+
literal|1
operator|)
operator|&&
name|at
argument_list|()
operator|!=
name|QSql
operator|::
name|BeforeFirstRow
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|sqlResult
operator|->
name|fetchNext
argument_list|()
condition|)
block|{
name|d
operator|->
name|sqlResult
operator|->
name|setAt
argument_list|(
name|QSql
operator|::
name|AfterLastRow
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|actualIdx
operator|==
operator|(
name|at
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|sqlResult
operator|->
name|fetchPrevious
argument_list|()
condition|)
block|{
name|d
operator|->
name|sqlResult
operator|->
name|setAt
argument_list|(
name|QSql
operator|::
name|BeforeFirstRow
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|sqlResult
operator|->
name|fetch
argument_list|(
name|actualIdx
argument_list|)
condition|)
block|{
name|d
operator|->
name|sqlResult
operator|->
name|setAt
argument_list|(
name|QSql
operator|::
name|AfterLastRow
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!    Retrieves the next record in the result, if available, and positions   the query on the retrieved record. Note that the result must be in   the \l{isActive()}{active} state and isSelect() must return true   before calling this function or it will do nothing and return false.    The following rules apply:    \list    \li If the result is currently located before the first record,   e.g. immediately after a query is executed, an attempt is made to   retrieve the first record.    \li If the result is currently located after the last record, there   is no change and false is returned.    \li If the result is located somewhere in the middle, an attempt is   made to retrieve the next record.    \endlist    If the record could not be retrieved, the result is positioned after   the last record and false is returned. If the record is successfully   retrieved, true is returned.    \sa previous(), first(), last(), seek(), at(), isActive(), isValid() */
end_comment
begin_function
DECL|function|next
name|bool
name|QSqlQuery
operator|::
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSelect
argument_list|()
operator|||
operator|!
name|isActive
argument_list|()
condition|)
return|return
literal|false
return|;
name|bool
name|b
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|at
argument_list|()
condition|)
block|{
case|case
name|QSql
operator|::
name|BeforeFirstRow
case|:
name|b
operator|=
name|d
operator|->
name|sqlResult
operator|->
name|fetchFirst
argument_list|()
expr_stmt|;
return|return
name|b
return|;
case|case
name|QSql
operator|::
name|AfterLastRow
case|:
return|return
literal|false
return|;
default|default:
if|if
condition|(
operator|!
name|d
operator|->
name|sqlResult
operator|->
name|fetchNext
argument_list|()
condition|)
block|{
name|d
operator|->
name|sqlResult
operator|->
name|setAt
argument_list|(
name|QSql
operator|::
name|AfterLastRow
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_function
begin_comment
comment|/*!    Retrieves the previous record in the result, if available, and   positions the query on the retrieved record. Note that the result   must be in the \l{isActive()}{active} state and isSelect() must   return true before calling this function or it will do nothing and   return false.    The following rules apply:    \list    \li If the result is currently located before the first record, there   is no change and false is returned.    \li If the result is currently located after the last record, an   attempt is made to retrieve the last record.    \li If the result is somewhere in the middle, an attempt is made to   retrieve the previous record.    \endlist    If the record could not be retrieved, the result is positioned   before the first record and false is returned. If the record is   successfully retrieved, true is returned.    \sa next(), first(), last(), seek(), at(), isActive(), isValid() */
end_comment
begin_function
DECL|function|previous
name|bool
name|QSqlQuery
operator|::
name|previous
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSelect
argument_list|()
operator|||
operator|!
name|isActive
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|isForwardOnly
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSqlQuery::seek: cannot seek backwards in a forward only query"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|bool
name|b
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|at
argument_list|()
condition|)
block|{
case|case
name|QSql
operator|::
name|BeforeFirstRow
case|:
return|return
literal|false
return|;
case|case
name|QSql
operator|::
name|AfterLastRow
case|:
name|b
operator|=
name|d
operator|->
name|sqlResult
operator|->
name|fetchLast
argument_list|()
expr_stmt|;
return|return
name|b
return|;
default|default:
if|if
condition|(
operator|!
name|d
operator|->
name|sqlResult
operator|->
name|fetchPrevious
argument_list|()
condition|)
block|{
name|d
operator|->
name|sqlResult
operator|->
name|setAt
argument_list|(
name|QSql
operator|::
name|BeforeFirstRow
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   Retrieves the first record in the result, if available, and   positions the query on the retrieved record. Note that the result   must be in the \l{isActive()}{active} state and isSelect() must   return true before calling this function or it will do nothing and   return false.  Returns true if successful. If unsuccessful the query   position is set to an invalid position and false is returned.    \sa next(), previous(), last(), seek(), at(), isActive(), isValid()  */
end_comment
begin_function
DECL|function|first
name|bool
name|QSqlQuery
operator|::
name|first
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSelect
argument_list|()
operator|||
operator|!
name|isActive
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|isForwardOnly
argument_list|()
operator|&&
name|at
argument_list|()
operator|>
name|QSql
operator|::
name|BeforeFirstRow
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSqlQuery::seek: cannot seek backwards in a forward only query"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|bool
name|b
init|=
literal|false
decl_stmt|;
name|b
operator|=
name|d
operator|->
name|sqlResult
operator|->
name|fetchFirst
argument_list|()
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_comment
comment|/*!    Retrieves the last record in the result, if available, and positions   the query on the retrieved record. Note that the result must be in   the \l{isActive()}{active} state and isSelect() must return true   before calling this function or it will do nothing and return false.   Returns true if successful. If unsuccessful the query position is   set to an invalid position and false is returned.    \sa next(), previous(), first(), seek(), at(), isActive(), isValid() */
end_comment
begin_function
DECL|function|last
name|bool
name|QSqlQuery
operator|::
name|last
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSelect
argument_list|()
operator|||
operator|!
name|isActive
argument_list|()
condition|)
return|return
literal|false
return|;
name|bool
name|b
init|=
literal|false
decl_stmt|;
name|b
operator|=
name|d
operator|->
name|sqlResult
operator|->
name|fetchLast
argument_list|()
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the size of the result (number of rows returned), or -1 if   the size cannot be determined or if the database does not support   reporting information about query sizes. Note that for non-\c SELECT   statements (isSelect() returns false), size() will return -1. If the   query is not active (isActive() returns false), -1 is returned.    To determine the number of rows affected by a non-\c SELECT   statement, use numRowsAffected().    \sa isActive(), numRowsAffected(), QSqlDriver::hasFeature() */
end_comment
begin_function
DECL|function|size
name|int
name|QSqlQuery
operator|::
name|size
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isActive
argument_list|()
operator|&&
name|d
operator|->
name|sqlResult
operator|->
name|driver
argument_list|()
operator|->
name|hasFeature
argument_list|(
name|QSqlDriver
operator|::
name|QuerySize
argument_list|)
condition|)
return|return
name|d
operator|->
name|sqlResult
operator|->
name|size
argument_list|()
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the number of rows affected by the result's SQL statement,   or -1 if it cannot be determined. Note that for \c SELECT   statements, the value is undefined; use size() instead. If the query   is not \l{isActive()}{active}, -1 is returned.    \sa size(), QSqlDriver::hasFeature() */
end_comment
begin_function
DECL|function|numRowsAffected
name|int
name|QSqlQuery
operator|::
name|numRowsAffected
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isActive
argument_list|()
condition|)
return|return
name|d
operator|->
name|sqlResult
operator|->
name|numRowsAffected
argument_list|()
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   Returns error information about the last error (if any) that   occurred with this query.    \sa QSqlError, QSqlDatabase::lastError() */
end_comment
begin_function
DECL|function|lastError
name|QSqlError
name|QSqlQuery
operator|::
name|lastError
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sqlResult
operator|->
name|lastError
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if the query is currently positioned on a valid   record; otherwise returns false. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QSqlQuery
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sqlResult
operator|->
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!    Returns true if the query is \e{active}. An active QSqlQuery is one   that has been \l{QSqlQuery::exec()} {exec()'d} successfully but not   yet finished with.  When you are finished with an active query, you   can make the query inactive by calling finish() or clear(), or   you can delete the QSqlQuery instance.    \note Of particular interest is an active query that is a \c{SELECT}   statement. For some databases that support transactions, an active   query that is a \c{SELECT} statement can cause a \l{QSqlDatabase::}   {commit()} or a \l{QSqlDatabase::} {rollback()} to fail, so before   committing or rolling back, you should make your active \c{SELECT}   statement query inactive using one of the ways listed above.    \sa isSelect()  */
end_comment
begin_function
DECL|function|isActive
name|bool
name|QSqlQuery
operator|::
name|isActive
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sqlResult
operator|->
name|isActive
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if the current query is a \c SELECT statement;   otherwise returns false. */
end_comment
begin_function
DECL|function|isSelect
name|bool
name|QSqlQuery
operator|::
name|isSelect
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sqlResult
operator|->
name|isSelect
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if you can only scroll forward through a result set;   otherwise returns false.    \sa setForwardOnly(), next() */
end_comment
begin_function
DECL|function|isForwardOnly
name|bool
name|QSqlQuery
operator|::
name|isForwardOnly
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sqlResult
operator|->
name|isForwardOnly
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Sets forward only mode to \a forward. If \a forward is true, only   next() and seek() with positive values, are allowed for navigating   the results.    Forward only mode can be (depending on the driver) more memory   efficient since results do not need to be cached. It will also   improve performance on some databases. For this to be true, you must   call \c setForwardOnly() before the query is prepared or executed.   Note that the constructor that takes a query and a database may   execute the query.    Forward only mode is off by default.    Setting forward only to false is a suggestion to the database engine,   which has the final say on whether a result set is forward only or   scrollable. isForwardOnly() will always return the correct status of   the result set.    \note Calling setForwardOnly after execution of the query will result   in unexpected results at best, and crashes at worst.    \sa isForwardOnly(), next(), seek(), QSqlResult::setForwardOnly() */
end_comment
begin_function
DECL|function|setForwardOnly
name|void
name|QSqlQuery
operator|::
name|setForwardOnly
parameter_list|(
name|bool
name|forward
parameter_list|)
block|{
name|d
operator|->
name|sqlResult
operator|->
name|setForwardOnly
argument_list|(
name|forward
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns a QSqlRecord containing the field information for the   current query. If the query points to a valid row (isValid() returns   true), the record is populated with the row's values.  An empty   record is returned when there is no active query (isActive() returns   false).    To retrieve values from a query, value() should be used since   its index-based lookup is faster.    In the following example, a \c{SELECT * FROM} query is executed.   Since the order of the columns is not defined, QSqlRecord::indexOf()   is used to obtain the index of a column.    \snippet code/src_sql_kernel_qsqlquery.cpp 1    \sa value() */
end_comment
begin_function
DECL|function|record
name|QSqlRecord
name|QSqlQuery
operator|::
name|record
parameter_list|()
specifier|const
block|{
name|QSqlRecord
name|rec
init|=
name|d
operator|->
name|sqlResult
operator|->
name|record
argument_list|()
decl_stmt|;
if|if
condition|(
name|isValid
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rec
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|rec
operator|.
name|setValue
argument_list|(
name|i
argument_list|,
name|value
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rec
return|;
block|}
end_function
begin_comment
comment|/*!   Clears the result set and releases any resources held by the   query. Sets the query state to inactive. You should rarely if ever   need to call this function. */
end_comment
begin_function
DECL|function|clear
name|void
name|QSqlQuery
operator|::
name|clear
parameter_list|()
block|{
operator|*
name|this
operator|=
name|QSqlQuery
argument_list|(
name|driver
argument_list|()
operator|->
name|createResult
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Prepares the SQL query \a query for execution. Returns true if the   query is prepared successfully; otherwise returns false.    The query may contain placeholders for binding values. Both Oracle   style colon-name (e.g., \c{:surname}), and ODBC style (\c{?})   placeholders are supported; but they cannot be mixed in the same   query. See the \l{QSqlQuery examples}{Detailed Description} for   examples.    Portability note: Some databases choose to delay preparing a query   until it is executed the first time. In this case, preparing a   syntactically wrong query succeeds, but every consecutive exec()   will fail.    For SQLite, the query string can contain only one statement at a time.   If more than one statement is given, the function returns false.    Example:    \snippet sqldatabase/sqldatabase.cpp 9    \sa exec(), bindValue(), addBindValue() */
end_comment
begin_function
DECL|function|prepare
name|bool
name|QSqlQuery
operator|::
name|prepare
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|bool
name|fo
init|=
name|isForwardOnly
argument_list|()
decl_stmt|;
operator|*
name|this
operator|=
name|QSqlQuery
argument_list|(
name|driver
argument_list|()
operator|->
name|createResult
argument_list|()
argument_list|)
expr_stmt|;
name|setForwardOnly
argument_list|(
name|fo
argument_list|)
expr_stmt|;
name|d
operator|->
name|sqlResult
operator|->
name|setNumericalPrecisionPolicy
argument_list|(
name|d
operator|->
name|sqlResult
operator|->
name|numericalPrecisionPolicy
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|sqlResult
operator|->
name|setActive
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|sqlResult
operator|->
name|setLastError
argument_list|(
name|QSqlError
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|sqlResult
operator|->
name|setAt
argument_list|(
name|QSql
operator|::
name|BeforeFirstRow
argument_list|)
expr_stmt|;
name|d
operator|->
name|sqlResult
operator|->
name|setNumericalPrecisionPolicy
argument_list|(
name|d
operator|->
name|sqlResult
operator|->
name|numericalPrecisionPolicy
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|driver
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSqlQuery::prepare: no driver"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|driver
argument_list|()
operator|->
name|isOpen
argument_list|()
operator|||
name|driver
argument_list|()
operator|->
name|isOpenError
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSqlQuery::prepare: database not open"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|query
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSqlQuery::prepare: empty query"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
ifdef|#
directive|ifdef
name|QT_DEBUG_SQL
name|qDebug
argument_list|(
literal|"\n QSqlQuery::prepare: %s"
argument_list|,
name|query
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|d
operator|->
name|sqlResult
operator|->
name|savePrepare
argument_list|(
name|query
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Executes a previously prepared SQL query. Returns true if the query   executed successfully; otherwise returns false.    Note that the last error for this query is reset when exec() is   called.    \sa prepare(), bindValue(), addBindValue(), boundValue(), boundValues() */
end_comment
begin_function
DECL|function|exec
name|bool
name|QSqlQuery
operator|::
name|exec
parameter_list|()
block|{
name|d
operator|->
name|sqlResult
operator|->
name|resetBindCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|sqlResult
operator|->
name|lastError
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|sqlResult
operator|->
name|setLastError
argument_list|(
name|QSqlError
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sqlResult
operator|->
name|exec
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \enum QSqlQuery::BatchExecutionMode      \value ValuesAsRows - Updates multiple rows. Treats every entry in a QVariantList as a value for updating the next row.     \value ValuesAsColumns - Updates a single row. Treats every entry in a QVariantList as a single value of an array type. */
end_comment
begin_comment
comment|/*!     \since 4.2    Executes a previously prepared SQL query in a batch. All the bound   parameters have to be lists of variants. If the database doesn't   support batch executions, the driver will simulate it using   conventional exec() calls.    Returns true if the query is executed successfully; otherwise   returns false.    Example:    \snippet code/src_sql_kernel_qsqlquery.cpp 2    The example above inserts four new rows into \c myTable:    \snippet code/src_sql_kernel_qsqlquery.cpp 3    To bind NULL values, a null QVariant of the relevant type has to be   added to the bound QVariantList; for example, \c   {QVariant(QVariant::String)} should be used if you are using   strings.    \note Every bound QVariantList must contain the same amount of   variants.    \note The type of the QVariants in a list must not change. For   example, you cannot mix integer and string variants within a   QVariantList.    The \a mode parameter indicates how the bound QVariantList will be   interpreted.  If \a mode is \c ValuesAsRows, every variant within   the QVariantList will be interpreted as a value for a new row. \c   ValuesAsColumns is a special case for the Oracle driver. In this   mode, every entry within a QVariantList will be interpreted as   array-value for an IN or OUT value within a stored procedure.  Note   that this will only work if the IN or OUT value is a table-type   consisting of only one column of a basic type, for example \c{TYPE   myType IS TABLE OF VARCHAR(64) INDEX BY BINARY_INTEGER;}    \sa prepare(), bindValue(), addBindValue() */
end_comment
begin_function
DECL|function|execBatch
name|bool
name|QSqlQuery
operator|::
name|execBatch
parameter_list|(
name|BatchExecutionMode
name|mode
parameter_list|)
block|{
return|return
name|d
operator|->
name|sqlResult
operator|->
name|execBatch
argument_list|(
name|mode
operator|==
name|ValuesAsColumns
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Set the placeholder \a placeholder to be bound to value \a val in   the prepared statement. Note that the placeholder mark (e.g \c{:})   must be included when specifying the placeholder name. If \a   paramType is QSql::Out or QSql::InOut, the placeholder will be   overwritten with data from the database after the exec() call.   In this case, sufficient space must be pre-allocated to store   the result into.    To bind a NULL value, use a null QVariant; for example, use   \c {QVariant(QVariant::String)} if you are binding a string.    Values cannot be bound to multiple locations in the query, eg:   \code   INSERT INTO testtable (id, name, samename) VALUES (:id, :name, :name)   \endcode   Binding to name will bind to the first :name, but not the second.    \sa addBindValue(), prepare(), exec(), boundValue(), boundValues() */
end_comment
begin_function
DECL|function|bindValue
name|void
name|QSqlQuery
operator|::
name|bindValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|placeholder
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|val
parameter_list|,
name|QSql
operator|::
name|ParamType
name|paramType
parameter_list|)
block|{
name|d
operator|->
name|sqlResult
operator|->
name|bindValue
argument_list|(
name|placeholder
argument_list|,
name|val
argument_list|,
name|paramType
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Set the placeholder in position \a pos to be bound to value \a val   in the prepared statement. Field numbering starts at 0. If \a   paramType is QSql::Out or QSql::InOut, the placeholder will be   overwritten with data from the database after the exec() call. */
end_comment
begin_function
DECL|function|bindValue
name|void
name|QSqlQuery
operator|::
name|bindValue
parameter_list|(
name|int
name|pos
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|val
parameter_list|,
name|QSql
operator|::
name|ParamType
name|paramType
parameter_list|)
block|{
name|d
operator|->
name|sqlResult
operator|->
name|bindValue
argument_list|(
name|pos
argument_list|,
name|val
argument_list|,
name|paramType
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Adds the value \a val to the list of values when using positional   value binding. The order of the addBindValue() calls determines   which placeholder a value will be bound to in the prepared query.   If \a paramType is QSql::Out or QSql::InOut, the placeholder will be   overwritten with data from the database after the exec() call.    To bind a NULL value, use a null QVariant; for example, use \c   {QVariant(QVariant::String)} if you are binding a string.    \sa bindValue(), prepare(), exec(), boundValue(), boundValues() */
end_comment
begin_function
DECL|function|addBindValue
name|void
name|QSqlQuery
operator|::
name|addBindValue
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|val
parameter_list|,
name|QSql
operator|::
name|ParamType
name|paramType
parameter_list|)
block|{
name|d
operator|->
name|sqlResult
operator|->
name|addBindValue
argument_list|(
name|val
argument_list|,
name|paramType
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the value for the \a placeholder.    \sa boundValues(), bindValue(), addBindValue() */
end_comment
begin_function
DECL|function|boundValue
name|QVariant
name|QSqlQuery
operator|::
name|boundValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|placeholder
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|sqlResult
operator|->
name|boundValue
argument_list|(
name|placeholder
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the value for the placeholder at position \a pos. */
end_comment
begin_function
DECL|function|boundValue
name|QVariant
name|QSqlQuery
operator|::
name|boundValue
parameter_list|(
name|int
name|pos
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|sqlResult
operator|->
name|boundValue
argument_list|(
name|pos
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a map of the bound values.    With named binding, the bound values can be examined in the   following ways:    \snippet sqldatabase/sqldatabase.cpp 14    With positional binding, the code becomes:    \snippet sqldatabase/sqldatabase.cpp 15    \sa boundValue(), bindValue(), addBindValue() */
end_comment
begin_function
DECL|function|boundValues
name|QMap
argument_list|<
name|QString
argument_list|,
name|QVariant
argument_list|>
name|QSqlQuery
operator|::
name|boundValues
parameter_list|()
specifier|const
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|QVariant
argument_list|>
name|map
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QVariant
argument_list|>
name|values
argument_list|(
name|d
operator|->
name|sqlResult
operator|->
name|boundValues
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|map
index|[
name|d
operator|->
name|sqlResult
operator|->
name|boundValueName
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|values
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|map
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the last query that was successfully executed.    In most cases this function returns the same string as lastQuery().   If a prepared query with placeholders is executed on a DBMS that   does not support it, the preparation of this query is emulated. The   placeholders in the original query are replaced with their bound   values to form a new query. This function returns the modified   query. It is mostly useful for debugging purposes.    \sa lastQuery() */
end_comment
begin_function
DECL|function|executedQuery
name|QString
name|QSqlQuery
operator|::
name|executedQuery
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sqlResult
operator|->
name|executedQuery
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the object ID of the most recent inserted row if the   database supports it.  An invalid QVariant will be returned if the   query did not insert any value or if the database does not report   the id back.  If more than one row was touched by the insert, the   behavior is undefined.    For MySQL databases the row's auto-increment field will be returned.    \note For this function to work in PSQL, the table table must   contain OIDs, which may not have been created by default.  Check the   \c default_with_oids configuration variable to be sure.    \sa QSqlDriver::hasFeature() */
end_comment
begin_function
DECL|function|lastInsertId
name|QVariant
name|QSqlQuery
operator|::
name|lastInsertId
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sqlResult
operator|->
name|lastInsertId
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!    Instruct the database driver to return numerical values with a   precision specified by \a precisionPolicy.    The Oracle driver, for example, can retrieve numerical values as   strings to prevent the loss of precision. If high precision doesn't   matter, use this method to increase execution speed by bypassing   string conversions.    Note: Drivers that don't support fetching numerical values with low   precision will ignore the precision policy. You can use   QSqlDriver::hasFeature() to find out whether a driver supports this   feature.    Note: Setting the precision policy doesn't affect the currently   active query. Call \l{exec()}{exec(QString)} or prepare() in order   to activate the policy.    \sa QSql::NumericalPrecisionPolicy, numericalPrecisionPolicy() */
end_comment
begin_function
DECL|function|setNumericalPrecisionPolicy
name|void
name|QSqlQuery
operator|::
name|setNumericalPrecisionPolicy
parameter_list|(
name|QSql
operator|::
name|NumericalPrecisionPolicy
name|precisionPolicy
parameter_list|)
block|{
name|d
operator|->
name|sqlResult
operator|->
name|setNumericalPrecisionPolicy
argument_list|(
name|precisionPolicy
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the current precision policy.    \sa QSql::NumericalPrecisionPolicy, setNumericalPrecisionPolicy() */
end_comment
begin_function
DECL|function|numericalPrecisionPolicy
name|QSql
operator|::
name|NumericalPrecisionPolicy
name|QSqlQuery
operator|::
name|numericalPrecisionPolicy
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sqlResult
operator|->
name|numericalPrecisionPolicy
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.3.2    Instruct the database driver that no more data will be fetched from   this query until it is re-executed. There is normally no need to   call this function, but it may be helpful in order to free resources   such as locks or cursors if you intend to re-use the query at a   later time.    Sets the query to inactive. Bound values retain their values.    \sa prepare(), exec(), isActive() */
end_comment
begin_function
DECL|function|finish
name|void
name|QSqlQuery
operator|::
name|finish
parameter_list|()
block|{
if|if
condition|(
name|isActive
argument_list|()
condition|)
block|{
name|d
operator|->
name|sqlResult
operator|->
name|setLastError
argument_list|(
name|QSqlError
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|sqlResult
operator|->
name|setAt
argument_list|(
name|QSql
operator|::
name|BeforeFirstRow
argument_list|)
expr_stmt|;
name|d
operator|->
name|sqlResult
operator|->
name|detachFromResultSet
argument_list|()
expr_stmt|;
name|d
operator|->
name|sqlResult
operator|->
name|setActive
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \since 4.4    Discards the current result set and navigates to the next if available.    Some databases are capable of returning multiple result sets for   stored procedures or SQL batches (a query strings that contains   multiple statements). If multiple result sets are available after   executing a query this function can be used to navigate to the next   result set(s).    If a new result set is available this function will return true.   The query will be repositioned on an \e invalid record in the new   result set and must be navigated to a valid record before data   values can be retrieved. If a new result set isn't available the   function returns false and the query is set to inactive. In any   case the old result set will be discarded.    When one of the statements is a non-select statement a count of   affected rows may be available instead of a result set.    Note that some databases, i.e. Microsoft SQL Server, requires   non-scrollable cursors when working with multiple result sets.  Some   databases may execute all statements at once while others may delay   the execution until the result set is actually accessed, and some   databases may have restrictions on which statements are allowed to   be used in a SQL batch.    \sa QSqlDriver::hasFeature(), setForwardOnly(), next(), isSelect(),       numRowsAffected(), isActive(), lastError() */
end_comment
begin_function
DECL|function|nextResult
name|bool
name|QSqlQuery
operator|::
name|nextResult
parameter_list|()
block|{
if|if
condition|(
name|isActive
argument_list|()
condition|)
return|return
name|d
operator|->
name|sqlResult
operator|->
name|nextResult
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
