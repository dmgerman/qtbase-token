begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtSql module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qsqldriver.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qsqlerror.h"
end_include
begin_include
include|#
directive|include
file|"qsqlfield.h"
end_include
begin_include
include|#
directive|include
file|"qsqlindex.h"
end_include
begin_include
include|#
directive|include
file|"private/qobject_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qsqldriver_p.h"
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|prepareIdentifier
specifier|static
name|QString
name|prepareIdentifier
parameter_list|(
specifier|const
name|QString
modifier|&
name|identifier
parameter_list|,
name|QSqlDriver
operator|::
name|IdentifierType
name|type
parameter_list|,
specifier|const
name|QSqlDriver
modifier|*
name|driver
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|driver
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|QString
name|ret
init|=
name|identifier
decl_stmt|;
if|if
condition|(
operator|!
name|driver
operator|->
name|isIdentifierEscaped
argument_list|(
name|identifier
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|ret
operator|=
name|driver
operator|->
name|escapeIdentifier
argument_list|(
name|identifier
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     \class QSqlDriver     \brief The QSqlDriver class is an abstract base class for accessing     specific SQL databases.      \ingroup database     \inmodule QtSql      This class should not be used directly. Use QSqlDatabase instead.      If you want to create your own SQL drivers, you can subclass this     class and reimplement its pure virtual functions and those     virtual functions that you need. See \l{How to Write Your Own     Database Driver} for more information.      \sa QSqlDatabase, QSqlResult */
end_comment
begin_comment
comment|/*!     Constructs a new driver with the given \a parent. */
end_comment
begin_constructor
DECL|function|QSqlDriver
name|QSqlDriver
operator|::
name|QSqlDriver
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QSqlDriverPrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!  \internal */
end_comment
begin_constructor
DECL|function|QSqlDriver
name|QSqlDriver
operator|::
name|QSqlDriver
parameter_list|(
name|QSqlDriverPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the object and frees any allocated resources. */
end_comment
begin_destructor
DECL|function|~QSqlDriver
name|QSqlDriver
operator|::
name|~
name|QSqlDriver
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \since 4.4      \fn QSqlDriver::notification(const QString&name)      This signal is emitted when the database posts an event notification     that the driver subscribes to. \a name identifies the event notification.      \sa subscribeToNotification() */
end_comment
begin_comment
comment|/*!     \since 5.0      \fn QSqlDriver::notification(const QString&name, QSqlDriver::NotificationSource source, const QVariant& payload)      This signal is emitted when the database posts an event notification     that the driver subscribes to. \a name identifies the event notification, \a source indicates the signal source,     \a payload holds the extra data optionally delivered with the notification.      \sa subscribeToNotification() */
end_comment
begin_comment
comment|/*!     \fn bool QSqlDriver::open(const QString&db, const QString&user, const QString& password,                               const QString&host, int port, const QString&options)      Derived classes must reimplement this pure virtual function to     open a database connection on database \a db, using user name \a     user, password \a password, host \a host, port \a port and     connection options \a options.      The function must return true on success and false on failure.      \sa setOpen() */
end_comment
begin_comment
comment|/*!     \fn bool QSqlDriver::close()      Derived classes must reimplement this pure virtual function in     order to close the database connection. Return true on success,     false on failure.      \sa open(), setOpen() */
end_comment
begin_comment
comment|/*!     \fn QSqlResult *QSqlDriver::createResult() const      Creates an empty SQL result on the database. Derived classes must     reimplement this function and return a QSqlResult object     appropriate for their database to the caller. */
end_comment
begin_comment
comment|/*!     Returns true if the database connection is open; otherwise returns     false. */
end_comment
begin_function
DECL|function|isOpen
name|bool
name|QSqlDriver
operator|::
name|isOpen
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|isOpen
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the there was an error opening the database     connection; otherwise returns false. */
end_comment
begin_function
DECL|function|isOpenError
name|bool
name|QSqlDriver
operator|::
name|isOpenError
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|isOpenError
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QSqlDriver::DriverFeature      This enum contains a list of features a driver might support. Use     hasFeature() to query whether a feature is supported or not.      \value Transactions  Whether the driver supports SQL transactions.     \value QuerySize  Whether the database is capable of reporting the size     of a query. Note that some databases do not support returning the size     (i.e. number of rows returned) of a query, in which case     QSqlQuery::size() will return -1.     \value BLOB  Whether the driver supports Binary Large Object fields.     \value Unicode  Whether the driver supports Unicode strings if the     database server does.     \value PreparedQueries  Whether the driver supports prepared query execution.     \value NamedPlaceholders  Whether the driver supports the use of named placeholders.     \value PositionalPlaceholders  Whether the driver supports the use of positional placeholders.     \value LastInsertId  Whether the driver supports returning the Id of the last touched row.     \value BatchOperations  Whether the driver supports batched operations, see QSqlQuery::execBatch()     \value SimpleLocking  Whether the driver disallows a write lock on a table while other queries have a read lock on it.     \value LowPrecisionNumbers  Whether the driver allows fetching numerical values with low precision.     \value EventNotifications Whether the driver supports database event notifications.     \value FinishQuery Whether the driver can do any low-level resource cleanup when QSqlQuery::finish() is called.     \value MultipleResultSets Whether the driver can access multiple result sets returned from batched statements or stored procedures.     \value CancelQuery Whether the driver allows cancelling a running query.      More information about supported features can be found in the     \l{sql-driver.html}{Qt SQL driver} documentation.      \sa hasFeature() */
end_comment
begin_comment
comment|/*!     \enum QSqlDriver::StatementType      This enum contains a list of SQL statement (or clause) types the     driver can create.      \value WhereStatement  An SQL \c WHERE statement (e.g., \c{WHERE f = 5}).     \value SelectStatement An SQL \c SELECT statement (e.g., \c{SELECT f FROM t}).     \value UpdateStatement An SQL \c UPDATE statement (e.g., \c{UPDATE TABLE t set f = 1}).     \value InsertStatement An SQL \c INSERT statement (e.g., \c{INSERT INTO t (f) values (1)}).     \value DeleteStatement An SQL \c DELETE statement (e.g., \c{DELETE FROM t}).      \sa sqlStatement() */
end_comment
begin_comment
comment|/*!     \enum QSqlDriver::IdentifierType      This enum contains a list of SQL identifier types.      \value FieldName A SQL field name     \value TableName A SQL table name */
end_comment
begin_comment
comment|/*!     \enum QSqlDriver::NotificationSource      This enum contains a list of SQL notification sources.      \value UnknownSource The notification source is unknown     \value SelfSource The notification source is this connection     \value OtherSource The notification source is another connection */
end_comment
begin_comment
comment|/*!     \fn bool QSqlDriver::hasFeature(DriverFeature feature) const      Returns true if the driver supports feature \a feature; otherwise     returns false.      Note that some databases need to be open() before this can be     determined.      \sa DriverFeature */
end_comment
begin_comment
comment|/*!     This function sets the open state of the database to \a open.     Derived classes can use this function to report the status of     open().      \sa open(), setOpenError() */
end_comment
begin_function
DECL|function|setOpen
name|void
name|QSqlDriver
operator|::
name|setOpen
parameter_list|(
name|bool
name|open
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|isOpen
operator|=
name|open
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This function sets the open error state of the database to \a     error. Derived classes can use this function to report the status     of open(). Note that if \a error is true the open state of the     database is set to closed (i.e., isOpen() returns false).      \sa open(), setOpen() */
end_comment
begin_function
DECL|function|setOpenError
name|void
name|QSqlDriver
operator|::
name|setOpenError
parameter_list|(
name|bool
name|error
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|isOpenError
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|d_func
argument_list|()
operator|->
name|isOpen
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This function is called to begin a transaction. If successful,     return true, otherwise return false. The default implementation     does nothing and returns false.      \sa commitTransaction(), rollbackTransaction() */
end_comment
begin_function
DECL|function|beginTransaction
name|bool
name|QSqlDriver
operator|::
name|beginTransaction
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     This function is called to commit a transaction. If successful,     return true, otherwise return false. The default implementation     does nothing and returns false.      \sa beginTransaction(), rollbackTransaction() */
end_comment
begin_function
DECL|function|commitTransaction
name|bool
name|QSqlDriver
operator|::
name|commitTransaction
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     This function is called to rollback a transaction. If successful,     return true, otherwise return false. The default implementation     does nothing and returns false.      \sa beginTransaction(), commitTransaction() */
end_comment
begin_function
DECL|function|rollbackTransaction
name|bool
name|QSqlDriver
operator|::
name|rollbackTransaction
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     This function is used to set the value of the last error, \a error,     that occurred on the database.      \sa lastError() */
end_comment
begin_function
DECL|function|setLastError
name|void
name|QSqlDriver
operator|::
name|setLastError
parameter_list|(
specifier|const
name|QSqlError
modifier|&
name|error
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|error
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a QSqlError object which contains information about the     last error that occurred on the database. */
end_comment
begin_function
DECL|function|lastError
name|QSqlError
name|QSqlDriver
operator|::
name|lastError
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|error
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of the names of the tables in the database. The     default implementation returns an empty list.      The \a tableType argument describes what types of tables     should be returned. Due to binary compatibility, the string     contains the value of the enum QSql::TableTypes as text.     An empty string should be treated as QSql::Tables for     backward compatibility. */
end_comment
begin_function
DECL|function|tables
name|QStringList
name|QSqlDriver
operator|::
name|tables
parameter_list|(
name|QSql
operator|::
name|TableType
parameter_list|)
specifier|const
block|{
return|return
name|QStringList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the primary index for table \a tableName. Returns an empty     QSqlIndex if the table doesn't have a primary index. The default     implementation returns an empty index. */
end_comment
begin_function
DECL|function|primaryIndex
name|QSqlIndex
name|QSqlDriver
operator|::
name|primaryIndex
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
specifier|const
block|{
return|return
name|QSqlIndex
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QSqlRecord populated with the names of the fields in     table \a tableName. If no such table exists, an empty record is     returned. The default implementation returns an empty record. */
end_comment
begin_function
DECL|function|record
name|QSqlRecord
name|QSqlDriver
operator|::
name|record
parameter_list|(
specifier|const
name|QString
modifier|&
comment|/* tableName */
parameter_list|)
specifier|const
block|{
return|return
name|QSqlRecord
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the \a identifier escaped according to the database rules.     \a identifier can either be a table name or field name, dependent     on \a type.      The default implementation does nothing.     \sa isIdentifierEscaped()  */
end_comment
begin_function
DECL|function|escapeIdentifier
name|QString
name|QSqlDriver
operator|::
name|escapeIdentifier
parameter_list|(
specifier|const
name|QString
modifier|&
name|identifier
parameter_list|,
name|IdentifierType
parameter_list|)
specifier|const
block|{
return|return
name|identifier
return|;
block|}
end_function
begin_comment
comment|/*!     Returns whether \a identifier is escaped according to the database rules.     \a identifier can either be a table name or field name, dependent     on \a type.      Reimplement this function if you want to provide your own implementation in your     QSqlDriver subclass,      \sa stripDelimiters(), escapeIdentifier()  */
end_comment
begin_function
DECL|function|isIdentifierEscaped
name|bool
name|QSqlDriver
operator|::
name|isIdentifierEscaped
parameter_list|(
specifier|const
name|QString
modifier|&
name|identifier
parameter_list|,
name|IdentifierType
name|type
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|identifier
operator|.
name|size
argument_list|()
operator|>
literal|2
operator|&&
name|identifier
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
comment|//left delimited
operator|&&
name|identifier
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
return|;
comment|//right delimited
block|}
end_function
begin_comment
comment|/*!     Returns the \a identifier with the leading and trailing delimiters removed,     \a identifier can either be a table name or field name,     dependent on \a type.  If \a identifier does not have leading     and trailing delimiter characters, \a identifier is returned without     modification.      Reimplement this function if you want to provide your own implementation in your     QSqlDriver subclass,      \since 4.5     \sa isIdentifierEscaped()  */
end_comment
begin_function
DECL|function|stripDelimiters
name|QString
name|QSqlDriver
operator|::
name|stripDelimiters
parameter_list|(
specifier|const
name|QString
modifier|&
name|identifier
parameter_list|,
name|IdentifierType
name|type
parameter_list|)
specifier|const
block|{
name|QString
name|ret
decl_stmt|;
if|if
condition|(
name|isIdentifierEscaped
argument_list|(
name|identifier
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|ret
operator|=
name|identifier
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|identifier
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a SQL statement of type \a type for the table \a tableName     with the values from \a rec. If \a preparedStatement is true, the     string will contain placeholders instead of values.      This method can be used to manipulate tables without having to worry     about database-dependent SQL dialects. For non-prepared statements,     the values will be properly escaped. */
end_comment
begin_function
DECL|function|sqlStatement
name|QString
name|QSqlDriver
operator|::
name|sqlStatement
parameter_list|(
name|StatementType
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|tableName
parameter_list|,
specifier|const
name|QSqlRecord
modifier|&
name|rec
parameter_list|,
name|bool
name|preparedStatement
parameter_list|)
specifier|const
block|{
name|int
name|i
decl_stmt|;
name|QString
name|s
decl_stmt|;
name|s
operator|.
name|reserve
argument_list|(
literal|128
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SelectStatement
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rec
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rec
operator|.
name|isGenerated
argument_list|(
name|i
argument_list|)
condition|)
name|s
operator|.
name|append
argument_list|(
name|prepareIdentifier
argument_list|(
name|rec
operator|.
name|fieldName
argument_list|(
name|i
argument_list|)
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|,
name|this
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|", "
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|s
return|;
name|s
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|s
operator|.
name|prepend
argument_list|(
name|QLatin1String
argument_list|(
literal|"SELECT "
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|" FROM "
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
break|break;
case|case
name|WhereStatement
case|:
if|if
condition|(
name|preparedStatement
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rec
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|s
operator|.
name|append
argument_list|(
name|prepareIdentifier
argument_list|(
name|rec
operator|.
name|fieldName
argument_list|(
name|i
argument_list|)
argument_list|,
name|FieldName
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|.
name|isNull
argument_list|(
name|i
argument_list|)
condition|)
name|s
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|" IS NULL"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|s
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|" = ?"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|" AND "
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rec
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|s
operator|.
name|append
argument_list|(
name|prepareIdentifier
argument_list|(
name|rec
operator|.
name|fieldName
argument_list|(
name|i
argument_list|)
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|val
init|=
name|formatValue
argument_list|(
name|rec
operator|.
name|field
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
name|QLatin1String
argument_list|(
literal|"NULL"
argument_list|)
condition|)
name|s
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|" IS NULL"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|s
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|" = "
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|" AND "
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|s
operator|.
name|prepend
argument_list|(
name|QLatin1String
argument_list|(
literal|"WHERE "
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|chop
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|// remove tailing AND
block|}
break|break;
case|case
name|UpdateStatement
case|:
name|s
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"UPDATE "
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|tableName
argument_list|)
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|" SET "
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rec
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|rec
operator|.
name|isGenerated
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|s
operator|.
name|append
argument_list|(
name|prepareIdentifier
argument_list|(
name|rec
operator|.
name|fieldName
argument_list|(
name|i
argument_list|)
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|,
name|this
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|preparedStatement
condition|)
name|s
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|s
operator|.
name|append
argument_list|(
name|formatValue
argument_list|(
name|rec
operator|.
name|field
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|", "
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|", "
argument_list|)
argument_list|)
condition|)
name|s
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|else
name|s
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
case|case
name|DeleteStatement
case|:
name|s
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"DELETE FROM "
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
break|break;
case|case
name|InsertStatement
case|:
block|{
name|s
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"INSERT INTO "
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|tableName
argument_list|)
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|" ("
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|vals
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rec
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|rec
operator|.
name|isGenerated
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|s
operator|.
name|append
argument_list|(
name|prepareIdentifier
argument_list|(
name|rec
operator|.
name|fieldName
argument_list|(
name|i
argument_list|)
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|,
name|this
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|", "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|preparedStatement
condition|)
name|vals
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|vals
operator|.
name|append
argument_list|(
name|formatValue
argument_list|(
name|rec
operator|.
name|field
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|vals
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|", "
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|s
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|vals
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|// remove trailing comma
name|s
index|[
name|s
operator|.
name|length
argument_list|()
operator|-
literal|2
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"VALUES ("
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|vals
argument_list|)
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a string representation of the \a field value for the     database. This is used, for example, when constructing INSERT and     UPDATE statements.      The default implementation returns the value formatted as a string     according to the following rules:      \list      \li If \a field is character data, the value is returned enclosed     in single quotation marks, which is appropriate for many SQL     databases. Any embedded single-quote characters are escaped     (replaced with two single-quote characters). If \a trimStrings is     true (the default is false), all trailing whitespace is trimmed     from the field.      \li If \a field is date/time data, the value is formatted in ISO     format and enclosed in single quotation marks. If the date/time     data is invalid, "NULL" is returned.      \li If \a field is \l{QByteArray}{bytearray} data, and the     driver can edit binary fields, the value is formatted as a     hexadecimal string.      \li For any other field type, toString() is called on its value     and the result of this is returned.      \endlist      \sa QVariant::toString()  */
end_comment
begin_function
DECL|function|formatValue
name|QString
name|QSqlDriver
operator|::
name|formatValue
parameter_list|(
specifier|const
name|QSqlField
modifier|&
name|field
parameter_list|,
name|bool
name|trimStrings
parameter_list|)
specifier|const
block|{
specifier|const
name|QLatin1String
name|nullTxt
argument_list|(
literal|"NULL"
argument_list|)
decl_stmt|;
name|QString
name|r
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|isNull
argument_list|()
condition|)
name|r
operator|=
name|nullTxt
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|field
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|QVariant
operator|::
name|Int
case|:
case|case
name|QVariant
operator|::
name|UInt
case|:
if|if
condition|(
name|field
operator|.
name|value
argument_list|()
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|Bool
condition|)
name|r
operator|=
name|field
operator|.
name|value
argument_list|()
operator|.
name|toBool
argument_list|()
condition|?
name|QLatin1String
argument_list|(
literal|"1"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|field
operator|.
name|value
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
case|case
name|QVariant
operator|::
name|Date
case|:
if|if
condition|(
name|field
operator|.
name|value
argument_list|()
operator|.
name|toDate
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
name|r
operator|=
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
operator|+
name|field
operator|.
name|value
argument_list|()
operator|.
name|toDate
argument_list|()
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|nullTxt
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Time
case|:
if|if
condition|(
name|field
operator|.
name|value
argument_list|()
operator|.
name|toTime
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
name|r
operator|=
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
operator|+
name|field
operator|.
name|value
argument_list|()
operator|.
name|toTime
argument_list|()
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|nullTxt
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|DateTime
case|:
if|if
condition|(
name|field
operator|.
name|value
argument_list|()
operator|.
name|toDateTime
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
name|r
operator|=
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
operator|+
name|field
operator|.
name|value
argument_list|()
operator|.
name|toDateTime
argument_list|()
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|nullTxt
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QVariant
operator|::
name|String
case|:
case|case
name|QVariant
operator|::
name|Char
case|:
block|{
name|QString
name|result
init|=
name|field
operator|.
name|value
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|trimStrings
condition|)
block|{
name|int
name|end
init|=
name|result
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|end
operator|&&
name|result
operator|.
name|at
argument_list|(
name|end
operator|-
literal|1
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
comment|/* skip white space from end */
name|end
operator|--
expr_stmt|;
name|result
operator|.
name|truncate
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
comment|/* escape the "'" character */
name|result
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"''"
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
operator|+
name|result
operator|+
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|Bool
case|:
name|r
operator|=
name|QString
operator|::
name|number
argument_list|(
name|field
operator|.
name|value
argument_list|()
operator|.
name|toBool
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|ByteArray
case|:
block|{
if|if
condition|(
name|hasFeature
argument_list|(
name|BLOB
argument_list|)
condition|)
block|{
name|QByteArray
name|ba
init|=
name|field
operator|.
name|value
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|QString
name|res
decl_stmt|;
specifier|static
specifier|const
name|char
name|hexchars
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ba
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|uchar
name|s
init|=
operator|(
name|uchar
operator|)
name|ba
index|[
name|i
index|]
decl_stmt|;
name|res
operator|+=
name|QLatin1Char
argument_list|(
name|hexchars
index|[
name|s
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|res
operator|+=
name|QLatin1Char
argument_list|(
name|hexchars
index|[
name|s
operator|&
literal|0x0f
index|]
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
operator|+
name|res
operator|+
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
default|default:
name|r
operator|=
name|field
operator|.
name|value
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
name|r
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the low-level database handle wrapped in a QVariant or an     invalid variant if there is no handle.      \warning Use this with uttermost care and only if you know what you're doing.      \warning The handle returned here can become a stale pointer if the connection     is modified (for example, if you close the connection).      \warning The handle can be NULL if the connection is not open yet.      The handle returned here is database-dependent, you should query the type     name of the variant before accessing it.      This example retrieves the handle for a connection to sqlite:      \snippet code/src_sql_kernel_qsqldriver.cpp 0      This snippet returns the handle for PostgreSQL or MySQL:      \snippet code/src_sql_kernel_qsqldriver.cpp 1      \sa QSqlResult::handle() */
end_comment
begin_function
DECL|function|handle
name|QVariant
name|QSqlDriver
operator|::
name|handle
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     This function is called to subscribe to event notifications from the database.     \a name identifies the event notification.      If successful, return true, otherwise return false.      The database must be open when this function is called. When the database is closed     by calling close() all subscribed event notifications are automatically unsubscribed.     Note that calling open() on an already open database may implicitly cause close() to     be called, which will cause the driver to unsubscribe from all event notifications.      When an event notification identified by \a name is posted by the database the     notification() signal is emitted.      Reimplement this function if you want to provide event notification support in your     own QSqlDriver subclass,      \since 4.4     \sa unsubscribeFromNotification(), subscribedToNotifications(), QSqlDriver::hasFeature() */
end_comment
begin_function
DECL|function|subscribeToNotification
name|bool
name|QSqlDriver
operator|::
name|subscribeToNotification
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     This function is called to unsubscribe from event notifications from the database.     \a name identifies the event notification.      If successful, return true, otherwise return false.      The database must be open when this function is called. All subscribed event     notifications are automatically unsubscribed from when the close() function is called.      After calling \e this function the notification() signal will no longer be emitted     when an event notification identified by \a name is posted by the database.      Reimplement this function if you want to provide event notification support in your     own QSqlDriver subclass,      \since 4.4     \sa subscribeToNotification(), subscribedToNotifications() */
end_comment
begin_function
DECL|function|unsubscribeFromNotification
name|bool
name|QSqlDriver
operator|::
name|unsubscribeFromNotification
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of the names of the event notifications that are currently subscribed to.      Reimplement this function if you want to provide event notification support in your     own QSqlDriver subclass,      \since 4.4     \sa subscribeToNotification(), unsubscribeFromNotification() */
end_comment
begin_function
DECL|function|subscribedToNotifications
name|QStringList
name|QSqlDriver
operator|::
name|subscribedToNotifications
parameter_list|()
specifier|const
block|{
return|return
name|QStringList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sets the default numerical precision policy used by queries created     by this driver to \a precisionPolicy.      Note: Setting the default precision policy to \a precisionPolicy     doesn't affect any currently active queries.      \sa QSql::NumericalPrecisionPolicy, numericalPrecisionPolicy(),     QSqlQuery::setNumericalPrecisionPolicy(), QSqlQuery::numericalPrecisionPolicy() */
end_comment
begin_function
DECL|function|setNumericalPrecisionPolicy
name|void
name|QSqlDriver
operator|::
name|setNumericalPrecisionPolicy
parameter_list|(
name|QSql
operator|::
name|NumericalPrecisionPolicy
name|precisionPolicy
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|precisionPolicy
operator|=
name|precisionPolicy
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns the current default precision policy for the database connection.      \sa QSql::NumericalPrecisionPolicy, setNumericalPrecisionPolicy(),     QSqlQuery::numericalPrecisionPolicy(), QSqlQuery::setNumericalPrecisionPolicy() */
end_comment
begin_function
DECL|function|numericalPrecisionPolicy
name|QSql
operator|::
name|NumericalPrecisionPolicy
name|QSqlDriver
operator|::
name|numericalPrecisionPolicy
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|precisionPolicy
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     \internal      Tries to cancel the running query, if the underlying driver has the     capability to cancel queries. Returns true on success, otherwise false.      This function can be called from a different thread.      If you use this function as a slot, you need to use a Qt::DirectConnection     from a different thread.      Reimplement this function to support canceling running queries in     your own QSqlDriver subclass. It must be implemented in a thread-safe     manner.      \sa QSqlDriver::hasFeature() */
end_comment
begin_function
DECL|function|cancelQuery
name|bool
name|QSqlDriver
operator|::
name|cancelQuery
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
