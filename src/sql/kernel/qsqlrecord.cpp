begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtSql module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qsqlrecord.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qatomic.h"
end_include
begin_include
include|#
directive|include
file|"qsqlfield.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qvector.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QSqlRecordPrivate
class|class
name|QSqlRecordPrivate
block|{
public|public:
name|QSqlRecordPrivate
parameter_list|()
constructor_decl|;
name|QSqlRecordPrivate
parameter_list|(
specifier|const
name|QSqlRecordPrivate
modifier|&
name|other
parameter_list|)
constructor_decl|;
DECL|function|contains
specifier|inline
name|bool
name|contains
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|fields
operator|.
name|count
argument_list|()
return|;
block|}
name|QString
name|createField
parameter_list|(
name|int
name|index
parameter_list|,
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|)
specifier|const
function_decl|;
DECL|member|fields
name|QVector
argument_list|<
name|QSqlField
argument_list|>
name|fields
decl_stmt|;
DECL|member|ref
name|QAtomicInt
name|ref
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|QSqlRecordPrivate
name|QSqlRecordPrivate
operator|::
name|QSqlRecordPrivate
parameter_list|()
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QSqlRecordPrivate
name|QSqlRecordPrivate
operator|::
name|QSqlRecordPrivate
parameter_list|(
specifier|const
name|QSqlRecordPrivate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|fields
argument_list|(
name|other
operator|.
name|fields
argument_list|)
member_init_list|,
name|ref
argument_list|(
literal|1
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*! \internal     Just for compat */
end_comment
begin_function
DECL|function|createField
name|QString
name|QSqlRecordPrivate
operator|::
name|createField
parameter_list|(
name|int
name|index
parameter_list|,
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|)
specifier|const
block|{
name|QString
name|f
decl_stmt|;
if|if
condition|(
operator|!
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
name|f
operator|=
name|prefix
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|f
operator|+=
name|fields
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|name
argument_list|()
expr_stmt|;
return|return
name|f
return|;
block|}
end_function
begin_comment
comment|/*!     \class QSqlRecord     \brief The QSqlRecord class encapsulates a database record.      \ingroup database     \ingroup shared     \inmodule QtSql      The QSqlRecord class encapsulates the functionality and     characteristics of a database record (usually a row in a table or     view within the database). QSqlRecord supports adding and     removing fields as well as setting and retrieving field values.      The values of a record's fields' can be set by name or position     with setValue(); if you want to set a field to null use     setNull(). To find the position of a field by name use indexOf(),     and to find the name of a field at a particular position use     fieldName(). Use field() to retrieve a QSqlField object for a     given field. Use contains() to see if the record contains a     particular field name.      When queries are generated to be executed on the database only     those fields for which isGenerated() is true are included in the     generated SQL.      A record can have fields added with append() or insert(), replaced     with replace(), and removed with remove(). All the fields can be     removed with clear(). The number of fields is given by count();     all their values can be cleared (to null) using clearValues().      \sa QSqlField, QSqlQuery::record() */
end_comment
begin_comment
comment|/*!     Constructs an empty record.      \sa isEmpty(), append(), insert() */
end_comment
begin_constructor
DECL|function|QSqlRecord
name|QSqlRecord
operator|::
name|QSqlRecord
parameter_list|()
block|{
name|d
operator|=
operator|new
name|QSqlRecordPrivate
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a other.      QSqlRecord is \l{implicitly shared}. This means you can make copies     of a record in \l{constant time}. */
end_comment
begin_constructor
DECL|function|QSqlRecord
name|QSqlRecord
operator|::
name|QSqlRecord
parameter_list|(
specifier|const
name|QSqlRecord
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Sets the record equal to \a other.      QSqlRecord is \l{implicitly shared}. This means you can make copies     of a record in \l{constant time}. */
end_comment
begin_function
DECL|function|operator =
name|QSqlRecord
modifier|&
name|QSqlRecord
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QSqlRecord
modifier|&
name|other
parameter_list|)
block|{
name|qAtomicAssign
argument_list|(
name|d
argument_list|,
name|other
operator|.
name|d
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the object and frees any allocated resources. */
end_comment
begin_destructor
DECL|function|~QSqlRecord
name|QSqlRecord
operator|::
name|~
name|QSqlRecord
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn bool QSqlRecord::operator!=(const QSqlRecord&other) const      Returns true if this object is not identical to \a other;     otherwise returns false.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns true if this object is identical to \a other (i.e., has     the same fields in the same order); otherwise returns false.      \sa operator!=() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QSqlRecord
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QSqlRecord
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|fields
operator|==
name|other
operator|.
name|d
operator|->
name|fields
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the value of the field located at position \a index in     the record. If \a index is out of bounds, an invalid QVariant     is returned.      \sa fieldName(), isNull() */
end_comment
begin_function
DECL|function|value
name|QVariant
name|QSqlRecord
operator|::
name|value
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|fields
operator|.
name|value
argument_list|(
name|index
argument_list|)
operator|.
name|value
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the value of the field called \a name in the record. If     field \a name does not exist an invalid variant is returned.      \sa indexOf() */
end_comment
begin_function
DECL|function|value
name|QVariant
name|QSqlRecord
operator|::
name|value
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|value
argument_list|(
name|indexOf
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the field at position \a index. If the field     does not exist, an empty string is returned.      \sa indexOf() */
end_comment
begin_function
DECL|function|fieldName
name|QString
name|QSqlRecord
operator|::
name|fieldName
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|fields
operator|.
name|value
argument_list|(
name|index
argument_list|)
operator|.
name|name
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the position of the field called \a name within the     record, or -1 if it cannot be found. Field names are not     case-sensitive. If more than one field matches, the first one is     returned.      \sa fieldName() */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QSqlRecord
operator|::
name|indexOf
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|QString
name|nm
init|=
name|name
operator|.
name|toUpper
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|d
operator|->
name|fields
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|name
argument_list|()
operator|.
name|toUpper
argument_list|()
operator|==
name|nm
condition|)
comment|// TODO: case-insensitive comparison
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the field at position \a index. If the \a index     is out of range, function returns     a \l{default-constructed value}.  */
end_comment
begin_function
DECL|function|field
name|QSqlField
name|QSqlRecord
operator|::
name|field
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|fields
operator|.
name|value
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \overload     Returns the field called \a name.  */
end_comment
begin_function
DECL|function|field
name|QSqlField
name|QSqlRecord
operator|::
name|field
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|field
argument_list|(
name|indexOf
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Append a copy of field \a field to the end of the record.      \sa insert(), replace(), remove() */
end_comment
begin_function
DECL|function|append
name|void
name|QSqlRecord
operator|::
name|append
parameter_list|(
specifier|const
name|QSqlField
modifier|&
name|field
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|fields
operator|.
name|append
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Inserts the field \a field at position \a pos in the record.      \sa append(), replace(), remove()  */
end_comment
begin_function
DECL|function|insert
name|void
name|QSqlRecord
operator|::
name|insert
parameter_list|(
name|int
name|pos
parameter_list|,
specifier|const
name|QSqlField
modifier|&
name|field
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|fields
operator|.
name|insert
argument_list|(
name|pos
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Replaces the field at position \a pos with the given \a field. If     \a pos is out of range, nothing happens.      \sa append(), insert(), remove() */
end_comment
begin_function
DECL|function|replace
name|void
name|QSqlRecord
operator|::
name|replace
parameter_list|(
name|int
name|pos
parameter_list|,
specifier|const
name|QSqlField
modifier|&
name|field
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|contains
argument_list|(
name|pos
argument_list|)
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|fields
index|[
name|pos
index|]
operator|=
name|field
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes the field at position \a pos. If \a pos is out of range,     nothing happens.      \sa append(), insert(), replace() */
end_comment
begin_function
DECL|function|remove
name|void
name|QSqlRecord
operator|::
name|remove
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|contains
argument_list|(
name|pos
argument_list|)
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|fields
operator|.
name|remove
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes all the record's fields.      \sa clearValues(), isEmpty() */
end_comment
begin_function
DECL|function|clear
name|void
name|QSqlRecord
operator|::
name|clear
parameter_list|()
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|fields
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if there are no fields in the record; otherwise     returns false.      \sa append(), insert(), clear() */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QSqlRecord
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|fields
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if there is a field in the record called \a name;     otherwise returns false. */
end_comment
begin_function
DECL|function|contains
name|bool
name|QSqlRecord
operator|::
name|contains
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|indexOf
argument_list|(
name|name
argument_list|)
operator|>=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Clears the value of all fields in the record and sets each field     to null.      \sa setValue() */
end_comment
begin_function
DECL|function|clearValues
name|void
name|QSqlRecord
operator|::
name|clearValues
parameter_list|()
block|{
name|detach
argument_list|()
expr_stmt|;
name|int
name|count
init|=
name|d
operator|->
name|fields
operator|.
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|fields
index|[
name|i
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the generated flag for the field called \a name to \a     generated. If the field does not exist, nothing happens. Only     fields that have \a generated set to true are included in the SQL     that is generated by QSqlQueryModel for example.      \sa isGenerated() */
end_comment
begin_function
DECL|function|setGenerated
name|void
name|QSqlRecord
operator|::
name|setGenerated
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|generated
parameter_list|)
block|{
name|setGenerated
argument_list|(
name|indexOf
argument_list|(
name|name
argument_list|)
argument_list|,
name|generated
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the generated flag for the field \a index to \a generated.      \sa isGenerated() */
end_comment
begin_function
DECL|function|setGenerated
name|void
name|QSqlRecord
operator|::
name|setGenerated
parameter_list|(
name|int
name|index
parameter_list|,
name|bool
name|generated
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|contains
argument_list|(
name|index
argument_list|)
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|fields
index|[
name|index
index|]
operator|.
name|setGenerated
argument_list|(
name|generated
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns true if the field \a index is null or if there is no field at     position \a index; otherwise returns false. */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QSqlRecord
operator|::
name|isNull
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|fields
operator|.
name|value
argument_list|(
name|index
argument_list|)
operator|.
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the field called \a name is null or if there is no     field called \a name; otherwise returns false.      \sa setNull() */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QSqlRecord
operator|::
name|isNull
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|isNull
argument_list|(
name|indexOf
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the value of field \a index to null. If the field does not exist,     nothing happens.      \sa setValue() */
end_comment
begin_function
DECL|function|setNull
name|void
name|QSqlRecord
operator|::
name|setNull
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|contains
argument_list|(
name|index
argument_list|)
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|fields
index|[
name|index
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the value of the field called \a name to null. If the field     does not exist, nothing happens. */
end_comment
begin_function
DECL|function|setNull
name|void
name|QSqlRecord
operator|::
name|setNull
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|setNull
argument_list|(
name|indexOf
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the record has a field called \a name and this     field is to be generated (the default); otherwise returns false.      \sa setGenerated() */
end_comment
begin_function
DECL|function|isGenerated
name|bool
name|QSqlRecord
operator|::
name|isGenerated
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|isGenerated
argument_list|(
name|indexOf
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \overload      Returns true if the record has a field at position \a index and this     field is to be generated (the default); otherwise returns false.      \sa setGenerated() */
end_comment
begin_function
DECL|function|isGenerated
name|bool
name|QSqlRecord
operator|::
name|isGenerated
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|fields
operator|.
name|value
argument_list|(
name|index
argument_list|)
operator|.
name|isGenerated
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of fields in the record.      \sa isEmpty() */
end_comment
begin_function
DECL|function|count
name|int
name|QSqlRecord
operator|::
name|count
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|fields
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the value of the field at position \a index to \a val. If the     field does not exist, nothing happens.      \sa setNull() */
end_comment
begin_function
DECL|function|setValue
name|void
name|QSqlRecord
operator|::
name|setValue
parameter_list|(
name|int
name|index
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|val
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|contains
argument_list|(
name|index
argument_list|)
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|fields
index|[
name|index
index|]
operator|.
name|setValue
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the value of the field called \a name to \a val. If the field     does not exist, nothing happens. */
end_comment
begin_function
DECL|function|setValue
name|void
name|QSqlRecord
operator|::
name|setValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|val
parameter_list|)
block|{
name|setValue
argument_list|(
name|indexOf
argument_list|(
name|name
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|detach
name|void
name|QSqlRecord
operator|::
name|detach
parameter_list|()
block|{
name|qAtomicDetach
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QSqlRecord
modifier|&
name|r
parameter_list|)
block|{
name|dbg
operator|<<
literal|"QSqlRecord("
operator|<<
name|r
operator|.
name|count
argument_list|()
operator|<<
literal|')'
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|r
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|dbg
operator|<<
literal|'\n'
operator|<<
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1:"
argument_list|)
operator|.
name|arg
argument_list|(
name|i
argument_list|,
literal|2
argument_list|)
operator|<<
name|r
operator|.
name|field
argument_list|(
name|i
argument_list|)
operator|<<
name|r
operator|.
name|value
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
