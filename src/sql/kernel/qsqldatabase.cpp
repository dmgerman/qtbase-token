begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtSql module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qsqldatabase.h"
end_include
begin_include
include|#
directive|include
file|"qsqlquery.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN32
end_ifdef
begin_comment
comment|// Conflicting declarations of LPCBYTE in sqlfront.h and winscard.h
end_comment
begin_define
DECL|macro|_WINSCARD_H_
define|#
directive|define
name|_WINSCARD_H_
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_SQL_PSQL
end_ifdef
begin_include
include|#
directive|include
file|"../drivers/psql/qsql_psql_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_SQL_MYSQL
end_ifdef
begin_include
include|#
directive|include
file|"../drivers/mysql/qsql_mysql_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_SQL_ODBC
end_ifdef
begin_include
include|#
directive|include
file|"../drivers/odbc/qsql_odbc_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_SQL_OCI
end_ifdef
begin_include
include|#
directive|include
file|"../drivers/oci/qsql_oci_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_SQL_TDS
end_ifdef
begin_comment
comment|// conflicting RETCODE typedef between odbc and freetds
end_comment
begin_define
DECL|macro|RETCODE
define|#
directive|define
name|RETCODE
value|DBRETCODE
end_define
begin_include
include|#
directive|include
file|"../drivers/tds/qsql_tds_p.h"
end_include
begin_undef
DECL|macro|RETCODE
undef|#
directive|undef
name|RETCODE
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_SQL_DB2
end_ifdef
begin_include
include|#
directive|include
file|"../drivers/db2/qsql_db2_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_SQL_SQLITE
end_ifdef
begin_include
include|#
directive|include
file|"../drivers/sqlite/qsql_sqlite_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_SQL_SQLITE2
end_ifdef
begin_include
include|#
directive|include
file|"../drivers/sqlite2/qsql_sqlite2_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_SQL_IBASE
end_ifdef
begin_undef
DECL|macro|SQL_FLOAT
undef|#
directive|undef
name|SQL_FLOAT
end_undef
begin_comment
DECL|macro|SQL_FLOAT
comment|// avoid clash with ODBC
end_comment
begin_undef
DECL|macro|SQL_DOUBLE
undef|#
directive|undef
name|SQL_DOUBLE
end_undef
begin_undef
DECL|macro|SQL_TIMESTAMP
undef|#
directive|undef
name|SQL_TIMESTAMP
end_undef
begin_undef
DECL|macro|SQL_TYPE_TIME
undef|#
directive|undef
name|SQL_TYPE_TIME
end_undef
begin_undef
DECL|macro|SQL_TYPE_DATE
undef|#
directive|undef
name|SQL_TYPE_DATE
end_undef
begin_undef
DECL|macro|SQL_DATE
undef|#
directive|undef
name|SQL_DATE
end_undef
begin_define
DECL|macro|SCHAR
define|#
directive|define
name|SCHAR
value|IBASE_SCHAR
end_define
begin_comment
DECL|macro|SCHAR
comment|// avoid clash with ODBC (older versions of ibase.h with Firebird)
end_comment
begin_include
include|#
directive|include
file|"../drivers/ibase/qsql_ibase_p.h"
end_include
begin_undef
DECL|macro|SCHAR
undef|#
directive|undef
name|SCHAR
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qreadwritelock.h"
end_include
begin_include
include|#
directive|include
file|"qsqlresult.h"
end_include
begin_include
include|#
directive|include
file|"qsqldriver.h"
end_include
begin_include
include|#
directive|include
file|"qsqldriverplugin.h"
end_include
begin_include
include|#
directive|include
file|"qsqlindex.h"
end_include
begin_include
include|#
directive|include
file|"private/qfactoryloader_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qsqlnulldriver_p.h"
end_include
begin_include
include|#
directive|include
file|"qmutex.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
name|QFactoryLoader
argument_list|,
name|loader
argument_list|,
operator|(
name|QSqlDriverFactoryInterface_iid
operator|,
name|QLatin1String
argument_list|(
literal|"/sqldrivers"
argument_list|)
operator|)
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
operator|||
name|_MSC_VER
operator|>=
literal|1900
comment|// ### Qt6: remove the #ifdef
decl|const
endif|#
directive|endif
DECL|member|defaultConnection
name|char
modifier|*
name|QSqlDatabase
operator|::
name|defaultConnection
init|=
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
literal|"qt_sql_default_connection"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_typedef
DECL|typedef|DriverDict
typedef|typedef
name|QHash
argument_list|<
name|QString
argument_list|,
name|QSqlDriverCreatorBase
modifier|*
argument_list|>
name|DriverDict
typedef|;
end_typedef
begin_class
DECL|class|QConnectionDict
class|class
name|QConnectionDict
super|:
specifier|public
name|QHash
argument_list|<
name|QString
argument_list|,
name|QSqlDatabase
argument_list|>
block|{
public|public:
DECL|function|contains_ts
specifier|inline
name|bool
name|contains_ts
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
name|QReadLocker
name|locker
argument_list|(
operator|&
name|lock
argument_list|)
decl_stmt|;
return|return
name|contains
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|function|keys_ts
specifier|inline
name|QStringList
name|keys_ts
parameter_list|()
specifier|const
block|{
name|QReadLocker
name|locker
argument_list|(
operator|&
name|lock
argument_list|)
decl_stmt|;
return|return
name|keys
argument_list|()
return|;
block|}
DECL|member|lock
specifier|mutable
name|QReadWriteLock
name|lock
decl_stmt|;
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QConnectionDict
argument_list|,
argument|dbDict
argument_list|)
end_macro
begin_class
DECL|class|QSqlDatabasePrivate
class|class
name|QSqlDatabasePrivate
block|{
public|public:
DECL|function|QSqlDatabasePrivate
name|QSqlDatabasePrivate
parameter_list|(
name|QSqlDatabase
modifier|*
name|d
parameter_list|,
name|QSqlDriver
modifier|*
name|dr
init|=
literal|0
parameter_list|)
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|q
argument_list|(
name|d
argument_list|)
member_init_list|,
name|driver
argument_list|(
name|dr
argument_list|)
member_init_list|,
name|port
argument_list|(
operator|-
literal|1
argument_list|)
block|{
name|precisionPolicy
operator|=
name|QSql
operator|::
name|LowPrecisionDouble
expr_stmt|;
block|}
name|QSqlDatabasePrivate
parameter_list|(
specifier|const
name|QSqlDatabasePrivate
modifier|&
name|other
parameter_list|)
constructor_decl|;
name|~
name|QSqlDatabasePrivate
parameter_list|()
destructor_decl|;
name|void
name|init
parameter_list|(
specifier|const
name|QString
modifier|&
name|type
parameter_list|)
function_decl|;
name|void
name|copy
parameter_list|(
specifier|const
name|QSqlDatabasePrivate
modifier|*
name|other
parameter_list|)
function_decl|;
name|void
name|disable
parameter_list|()
function_decl|;
DECL|member|ref
name|QAtomicInt
name|ref
decl_stmt|;
DECL|member|q
name|QSqlDatabase
modifier|*
name|q
decl_stmt|;
DECL|member|driver
name|QSqlDriver
modifier|*
name|driver
decl_stmt|;
DECL|member|dbname
name|QString
name|dbname
decl_stmt|;
DECL|member|uname
name|QString
name|uname
decl_stmt|;
DECL|member|pword
name|QString
name|pword
decl_stmt|;
DECL|member|hname
name|QString
name|hname
decl_stmt|;
DECL|member|drvName
name|QString
name|drvName
decl_stmt|;
DECL|member|port
name|int
name|port
decl_stmt|;
DECL|member|connOptions
name|QString
name|connOptions
decl_stmt|;
DECL|member|connName
name|QString
name|connName
decl_stmt|;
DECL|member|precisionPolicy
name|QSql
operator|::
name|NumericalPrecisionPolicy
name|precisionPolicy
decl_stmt|;
specifier|static
name|QSqlDatabasePrivate
modifier|*
name|shared_null
parameter_list|()
function_decl|;
specifier|static
name|QSqlDatabase
name|database
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|open
parameter_list|)
function_decl|;
specifier|static
name|void
name|addDatabase
parameter_list|(
specifier|const
name|QSqlDatabase
modifier|&
name|db
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
function_decl|;
specifier|static
name|void
name|removeDatabase
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
function_decl|;
specifier|static
name|void
name|invalidateDb
parameter_list|(
specifier|const
name|QSqlDatabase
modifier|&
name|db
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|doWarn
init|=
literal|true
parameter_list|)
function_decl|;
specifier|static
name|DriverDict
modifier|&
name|driverDict
parameter_list|()
function_decl|;
specifier|static
name|void
name|cleanConnections
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_constructor
DECL|function|QSqlDatabasePrivate
name|QSqlDatabasePrivate
operator|::
name|QSqlDatabasePrivate
parameter_list|(
specifier|const
name|QSqlDatabasePrivate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
block|{
name|q
operator|=
name|other
operator|.
name|q
expr_stmt|;
name|dbname
operator|=
name|other
operator|.
name|dbname
expr_stmt|;
name|uname
operator|=
name|other
operator|.
name|uname
expr_stmt|;
name|pword
operator|=
name|other
operator|.
name|pword
expr_stmt|;
name|hname
operator|=
name|other
operator|.
name|hname
expr_stmt|;
name|drvName
operator|=
name|other
operator|.
name|drvName
expr_stmt|;
name|port
operator|=
name|other
operator|.
name|port
expr_stmt|;
name|connOptions
operator|=
name|other
operator|.
name|connOptions
expr_stmt|;
name|driver
operator|=
name|other
operator|.
name|driver
expr_stmt|;
name|precisionPolicy
operator|=
name|other
operator|.
name|precisionPolicy
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QSqlDatabasePrivate
name|QSqlDatabasePrivate
operator|::
name|~
name|QSqlDatabasePrivate
parameter_list|()
block|{
if|if
condition|(
name|driver
operator|!=
name|shared_null
argument_list|()
operator|->
name|driver
condition|)
operator|delete
name|driver
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|cleanConnections
name|void
name|QSqlDatabasePrivate
operator|::
name|cleanConnections
parameter_list|()
block|{
name|QConnectionDict
modifier|*
name|dict
init|=
name|dbDict
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|dict
argument_list|)
expr_stmt|;
name|QWriteLocker
name|locker
argument_list|(
operator|&
name|dict
operator|->
name|lock
argument_list|)
decl_stmt|;
name|QConnectionDict
operator|::
name|iterator
name|it
init|=
name|dict
operator|->
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|dict
operator|->
name|end
argument_list|()
condition|)
block|{
name|invalidateDb
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|,
name|it
operator|.
name|key
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
name|dict
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|qDriverDictInit
specifier|static
name|bool
name|qDriverDictInit
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|cleanDriverDict
specifier|static
name|void
name|cleanDriverDict
parameter_list|()
block|{
name|qDeleteAll
argument_list|(
name|QSqlDatabasePrivate
operator|::
name|driverDict
argument_list|()
argument_list|)
expr_stmt|;
name|QSqlDatabasePrivate
operator|::
name|driverDict
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QSqlDatabasePrivate
operator|::
name|cleanConnections
argument_list|()
expr_stmt|;
name|qDriverDictInit
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|driverDict
name|DriverDict
modifier|&
name|QSqlDatabasePrivate
operator|::
name|driverDict
parameter_list|()
block|{
specifier|static
name|DriverDict
name|dict
decl_stmt|;
if|if
condition|(
operator|!
name|qDriverDictInit
condition|)
block|{
name|qDriverDictInit
operator|=
literal|true
expr_stmt|;
name|qAddPostRoutine
argument_list|(
name|cleanDriverDict
argument_list|)
expr_stmt|;
block|}
return|return
name|dict
return|;
block|}
end_function
begin_function
DECL|function|shared_null
name|QSqlDatabasePrivate
modifier|*
name|QSqlDatabasePrivate
operator|::
name|shared_null
parameter_list|()
block|{
specifier|static
name|QSqlNullDriver
name|dr
decl_stmt|;
specifier|static
name|QSqlDatabasePrivate
name|n
argument_list|(
name|NULL
argument_list|,
operator|&
name|dr
argument_list|)
decl_stmt|;
return|return
operator|&
name|n
return|;
block|}
end_function
begin_function
DECL|function|invalidateDb
name|void
name|QSqlDatabasePrivate
operator|::
name|invalidateDb
parameter_list|(
specifier|const
name|QSqlDatabase
modifier|&
name|db
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|doWarn
parameter_list|)
block|{
if|if
condition|(
name|db
operator|.
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
operator|&&
name|doWarn
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSqlDatabasePrivate::removeDatabase: connection '%s' is still in use, "
literal|"all queries will cease to work."
argument_list|,
name|name
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|db
operator|.
name|d
operator|->
name|disable
argument_list|()
expr_stmt|;
name|db
operator|.
name|d
operator|->
name|connName
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|removeDatabase
name|void
name|QSqlDatabasePrivate
operator|::
name|removeDatabase
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QConnectionDict
modifier|*
name|dict
init|=
name|dbDict
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|dict
argument_list|)
expr_stmt|;
name|QWriteLocker
name|locker
argument_list|(
operator|&
name|dict
operator|->
name|lock
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dict
operator|->
name|contains
argument_list|(
name|name
argument_list|)
condition|)
return|return;
name|invalidateDb
argument_list|(
name|dict
operator|->
name|take
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addDatabase
name|void
name|QSqlDatabasePrivate
operator|::
name|addDatabase
parameter_list|(
specifier|const
name|QSqlDatabase
modifier|&
name|db
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QConnectionDict
modifier|*
name|dict
init|=
name|dbDict
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|dict
argument_list|)
expr_stmt|;
name|QWriteLocker
name|locker
argument_list|(
operator|&
name|dict
operator|->
name|lock
argument_list|)
decl_stmt|;
if|if
condition|(
name|dict
operator|->
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|invalidateDb
argument_list|(
name|dict
operator|->
name|take
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"QSqlDatabasePrivate::addDatabase: duplicate connection name '%s', old "
literal|"connection removed."
argument_list|,
name|name
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|dict
operator|->
name|insert
argument_list|(
name|name
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|db
operator|.
name|d
operator|->
name|connName
operator|=
name|name
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|database
name|QSqlDatabase
name|QSqlDatabasePrivate
operator|::
name|database
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|open
parameter_list|)
block|{
specifier|const
name|QConnectionDict
modifier|*
name|dict
init|=
name|dbDict
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|dict
argument_list|)
expr_stmt|;
name|dict
operator|->
name|lock
operator|.
name|lockForRead
argument_list|()
expr_stmt|;
name|QSqlDatabase
name|db
init|=
name|dict
operator|->
name|value
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|dict
operator|->
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|db
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|db
operator|.
name|isOpen
argument_list|()
operator|&&
name|open
condition|)
block|{
if|if
condition|(
operator|!
name|db
operator|.
name|open
argument_list|()
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QSqlDatabasePrivate::database: unable to open database:"
operator|<<
name|db
operator|.
name|lastError
argument_list|()
operator|.
name|text
argument_list|()
expr_stmt|;
block|}
return|return
name|db
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Copies the connection data from \a other. */
end_comment
begin_function
DECL|function|copy
name|void
name|QSqlDatabasePrivate
operator|::
name|copy
parameter_list|(
specifier|const
name|QSqlDatabasePrivate
modifier|*
name|other
parameter_list|)
block|{
name|q
operator|=
name|other
operator|->
name|q
expr_stmt|;
name|dbname
operator|=
name|other
operator|->
name|dbname
expr_stmt|;
name|uname
operator|=
name|other
operator|->
name|uname
expr_stmt|;
name|pword
operator|=
name|other
operator|->
name|pword
expr_stmt|;
name|hname
operator|=
name|other
operator|->
name|hname
expr_stmt|;
name|drvName
operator|=
name|other
operator|->
name|drvName
expr_stmt|;
name|port
operator|=
name|other
operator|->
name|port
expr_stmt|;
name|connOptions
operator|=
name|other
operator|->
name|connOptions
expr_stmt|;
name|precisionPolicy
operator|=
name|other
operator|->
name|precisionPolicy
expr_stmt|;
block|}
end_function
begin_function
DECL|function|disable
name|void
name|QSqlDatabasePrivate
operator|::
name|disable
parameter_list|()
block|{
if|if
condition|(
name|driver
operator|!=
name|shared_null
argument_list|()
operator|->
name|driver
condition|)
block|{
operator|delete
name|driver
expr_stmt|;
name|driver
operator|=
name|shared_null
argument_list|()
operator|->
name|driver
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QSqlDriverCreatorBase     \brief The QSqlDriverCreatorBase class is the base class for     SQL driver factories.      \ingroup database     \inmodule QtSql      Reimplement createObject() to return an instance of the specific     QSqlDriver subclass that you want to provide.      See QSqlDatabase::registerSqlDriver() for details.      \sa QSqlDriverCreator */
end_comment
begin_comment
comment|/*!     \fn QSqlDriverCreatorBase::~QSqlDriverCreatorBase()      Destroys the SQL driver creator object. */
end_comment
begin_comment
comment|/*!     \fn QSqlDriver *QSqlDriverCreatorBase::createObject() const      Reimplement this function to returns a new instance of a     QSqlDriver subclass. */
end_comment
begin_comment
comment|/*!     \class QSqlDriverCreator     \brief The QSqlDriverCreator class is a template class that     provides a SQL driver factory for a specific driver type.      \ingroup database     \inmodule QtSql      QSqlDriverCreator<T> instantiates objects of type T, where T is a     QSqlDriver subclass.      See QSqlDatabase::registerSqlDriver() for details. */
end_comment
begin_comment
comment|/*!     \fn QSqlDriver *QSqlDriverCreator::createObject() const     \reimp */
end_comment
begin_comment
comment|/*!     \class QSqlDatabase     \brief The QSqlDatabase class represents a connection to     a database.      \ingroup database      \inmodule QtSql      The QSqlDatabase class provides an interface for accessing a     database through a connection. An instance of QSqlDatabase     represents the connection. The connection provides access to the     database via one of the \l{SQL Database Drivers#Supported     Databases} {supported database drivers}, which are derived from     QSqlDriver.  Alternatively, you can subclass your own database     driver from QSqlDriver. See \l{How to Write Your Own Database     Driver} for more information.      Create a connection (i.e., an instance of QSqlDatabase) by calling     one of the static addDatabase() functions, where you specify     \l{SQL Database Drivers#Supported Databases} {the driver or type     of driver} to use (i.e., what kind of database will you access?)     and a connection name. A connection is known by its own name,     \e{not} by the name of the database it connects to. You can have     multiple connections to one database. QSqlDatabase also supports     the concept of a \e{default} connection, which is the unnamed     connection. To create the default connection, don't pass the     connection name argument when you call addDatabase().     Subsequently, when you call any static member function that takes     the connection name argument, if you don't pass the connection     name argument, the default connection is assumed. The following     snippet shows how to create and open a default connection to a     PostgreSQL database:      \snippet sqldatabase/sqldatabase.cpp 0      Once the QSqlDatabase object has been created, set the connection     parameters with setDatabaseName(), setUserName(), setPassword(),     setHostName(), setPort(), and setConnectOptions(). Then call     open() to activate the physical connection to the database. The     connection is not usable until you open it.      The connection defined above will be the \e{default} connection,     because we didn't give a connection name to \l{QSqlDatabase::}     {addDatabase()}. Subsequently, you can get the default connection     by calling database() without the connection name argument:      \snippet sqldatabase/sqldatabase.cpp 1      QSqlDatabase is a value class. Changes made to a database     connection via one instance of QSqlDatabase will affect other     instances of QSqlDatabase that represent the same connection. Use     cloneDatabase() to create an independent database connection based     on an existing one.      If you create multiple database connections, specify a unique     connection name for each one, when you call addDatabase(). Use     database() with a connection name to get that connection. Use     removeDatabase() with a connection name to remove a connection.     QSqlDatabase outputs a warning if you try to remove a connection     referenced by other QSqlDatabase objects. Use contains() to see if     a given connection name is in the list of connections.      Once a connection is established, you can call tables() to get the     list of tables in the database, call primaryIndex() to get a     table's primary index, and call record() to get meta-information     about a table's fields (e.g., field names).      \note QSqlDatabase::exec() is deprecated. Use QSqlQuery::exec()     instead.      If the driver supports transactions, use transaction() to start a     transaction, and commit() or rollback() to complete it. Use     \l{QSqlDriver::} {hasFeature()} to ask if the driver supports     transactions. \note When using transactions, you must start the     transaction before you create your query.      If an error occurs, lastError() will return information about it.      Get the names of the available SQL drivers with drivers().  Check     for the presence of a particular driver with isDriverAvailable().     If you have created your own custom driver, you must register it     with registerSqlDriver().      \sa QSqlDriver, QSqlQuery, {Qt SQL}, {Threads and the SQL Module} */
end_comment
begin_comment
comment|/*! \fn QSqlDatabase QSqlDatabase::addDatabase(const QString&type, const QString&connectionName)     \threadsafe      Adds a database to the list of database connections using the     driver \a type and the connection name \a connectionName. If     there already exists a database connection called \a     connectionName, that connection is removed.      The database connection is referred to by \a connectionName. The     newly added database connection is returned.      If \a type is not available or could not be loaded, isValid() returns \c false.      If \a connectionName is not specified, the new connection becomes     the default connection for the application, and subsequent calls     to database() without the connection name argument will return the     default connection. If a \a connectionName is provided here, use     database(\a connectionName) to retrieve the connection.      \warning If you add a connection with the same name as an existing     connection, the new connection replaces the old one.  If you call     this function more than once without specifying \a connectionName,     the default connection will be the one replaced.      Before using the connection, it must be initialized. e.g., call     some or all of setDatabaseName(), setUserName(), setPassword(),     setHostName(), setPort(), and setConnectOptions(), and, finally,     open().      \sa database(), removeDatabase(), {Threads and the SQL Module} */
end_comment
begin_function
DECL|function|addDatabase
name|QSqlDatabase
name|QSqlDatabase
operator|::
name|addDatabase
parameter_list|(
specifier|const
name|QString
modifier|&
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|connectionName
parameter_list|)
block|{
name|QSqlDatabase
name|db
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|QSqlDatabasePrivate
operator|::
name|addDatabase
argument_list|(
name|db
argument_list|,
name|connectionName
argument_list|)
expr_stmt|;
return|return
name|db
return|;
block|}
end_function
begin_comment
comment|/*!     \threadsafe      Returns the database connection called \a connectionName. The     database connection must have been previously added with     addDatabase(). If \a open is true (the default) and the database     connection is not already open it is opened now. If no \a     connectionName is specified the default connection is used. If \a     connectionName does not exist in the list of databases, an invalid     connection is returned.      \sa isOpen(), {Threads and the SQL Module} */
end_comment
begin_function
DECL|function|database
name|QSqlDatabase
name|QSqlDatabase
operator|::
name|database
parameter_list|(
specifier|const
name|QString
modifier|&
name|connectionName
parameter_list|,
name|bool
name|open
parameter_list|)
block|{
return|return
name|QSqlDatabasePrivate
operator|::
name|database
argument_list|(
name|connectionName
argument_list|,
name|open
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \threadsafe      Removes the database connection \a connectionName from the list of     database connections.      \warning There should be no open queries on the database     connection when this function is called, otherwise a resource leak     will occur.      Example:      \snippet code/src_sql_kernel_qsqldatabase.cpp 0      The correct way to do it:      \snippet code/src_sql_kernel_qsqldatabase.cpp 1      To remove the default connection, which may have been created with a     call to addDatabase() not specifying a connection name, you can     retrieve the default connection name by calling connectionName() on     the database returned by database(). Note that if a default database     hasn't been created an invalid database will be returned.      \sa database(), connectionName(), {Threads and the SQL Module} */
end_comment
begin_function
DECL|function|removeDatabase
name|void
name|QSqlDatabase
operator|::
name|removeDatabase
parameter_list|(
specifier|const
name|QString
modifier|&
name|connectionName
parameter_list|)
block|{
name|QSqlDatabasePrivate
operator|::
name|removeDatabase
argument_list|(
name|connectionName
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all the available database drivers.      \sa registerSqlDriver() */
end_comment
begin_function
DECL|function|drivers
name|QStringList
name|QSqlDatabase
operator|::
name|drivers
parameter_list|()
block|{
name|QStringList
name|list
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_SQL_PSQL
name|list
operator|<<
name|QLatin1String
argument_list|(
literal|"QPSQL7"
argument_list|)
expr_stmt|;
name|list
operator|<<
name|QLatin1String
argument_list|(
literal|"QPSQL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_MYSQL
name|list
operator|<<
name|QLatin1String
argument_list|(
literal|"QMYSQL3"
argument_list|)
expr_stmt|;
name|list
operator|<<
name|QLatin1String
argument_list|(
literal|"QMYSQL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_ODBC
name|list
operator|<<
name|QLatin1String
argument_list|(
literal|"QODBC3"
argument_list|)
expr_stmt|;
name|list
operator|<<
name|QLatin1String
argument_list|(
literal|"QODBC"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_OCI
name|list
operator|<<
name|QLatin1String
argument_list|(
literal|"QOCI8"
argument_list|)
expr_stmt|;
name|list
operator|<<
name|QLatin1String
argument_list|(
literal|"QOCI"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_TDS
name|list
operator|<<
name|QLatin1String
argument_list|(
literal|"QTDS7"
argument_list|)
expr_stmt|;
name|list
operator|<<
name|QLatin1String
argument_list|(
literal|"QTDS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_DB2
name|list
operator|<<
name|QLatin1String
argument_list|(
literal|"QDB2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_SQLITE
name|list
operator|<<
name|QLatin1String
argument_list|(
literal|"QSQLITE"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_SQLITE2
name|list
operator|<<
name|QLatin1String
argument_list|(
literal|"QSQLITE2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_IBASE
name|list
operator|<<
name|QLatin1String
argument_list|(
literal|"QIBASE"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|QFactoryLoader
modifier|*
name|fl
init|=
name|loader
argument_list|()
condition|)
block|{
typedef|typedef
name|QMultiMap
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
name|PluginKeyMap
typedef|;
typedef|typedef
name|PluginKeyMap
operator|::
name|const_iterator
name|PluginKeyMapConstIterator
typedef|;
specifier|const
name|PluginKeyMap
name|keyMap
init|=
name|fl
operator|->
name|keyMap
argument_list|()
decl_stmt|;
specifier|const
name|PluginKeyMapConstIterator
name|cend
init|=
name|keyMap
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
name|PluginKeyMapConstIterator
name|it
init|=
name|keyMap
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|cend
condition|;
operator|++
name|it
control|)
if|if
condition|(
operator|!
name|list
operator|.
name|contains
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|)
condition|)
name|list
operator|<<
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
name|DriverDict
name|dict
init|=
name|QSqlDatabasePrivate
operator|::
name|driverDict
argument_list|()
decl_stmt|;
for|for
control|(
name|DriverDict
operator|::
name|const_iterator
name|i
init|=
name|dict
operator|.
name|constBegin
argument_list|()
init|;
name|i
operator|!=
name|dict
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|list
operator|.
name|contains
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|)
condition|)
name|list
operator|<<
name|i
operator|.
name|key
argument_list|()
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     This function registers a new SQL driver called \a name, within     the SQL framework. This is useful if you have a custom SQL driver     and don't want to compile it as a plugin.      Example:     \snippet code/src_sql_kernel_qsqldatabase.cpp 2      QSqlDatabase takes ownership of the \a creator pointer, so you     mustn't delete it yourself.      \sa drivers() */
end_comment
begin_function
DECL|function|registerSqlDriver
name|void
name|QSqlDatabase
operator|::
name|registerSqlDriver
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|QSqlDriverCreatorBase
modifier|*
name|creator
parameter_list|)
block|{
operator|delete
name|QSqlDatabasePrivate
operator|::
name|driverDict
argument_list|()
operator|.
name|take
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|creator
condition|)
name|QSqlDatabasePrivate
operator|::
name|driverDict
argument_list|()
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|creator
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \threadsafe      Returns \c true if the list of database connections contains \a     connectionName; otherwise returns \c false.      \sa connectionNames(), database(), {Threads and the SQL Module} */
end_comment
begin_function
DECL|function|contains
name|bool
name|QSqlDatabase
operator|::
name|contains
parameter_list|(
specifier|const
name|QString
modifier|&
name|connectionName
parameter_list|)
block|{
return|return
name|dbDict
argument_list|()
operator|->
name|contains_ts
argument_list|(
name|connectionName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \threadsafe      Returns a list containing the names of all connections.      \sa contains(), database(), {Threads and the SQL Module} */
end_comment
begin_function
DECL|function|connectionNames
name|QStringList
name|QSqlDatabase
operator|::
name|connectionNames
parameter_list|()
block|{
return|return
name|dbDict
argument_list|()
operator|->
name|keys_ts
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Creates a QSqlDatabase connection that uses the driver referred     to by \a type. If the \a type is not recognized, the database     connection will have no functionality.      The currently available driver types are:      \table     \header \li Driver Type \li Description     \row \li QDB2     \li IBM DB2     \row \li QIBASE   \li Borland InterBase Driver     \row \li QMYSQL   \li MySQL Driver     \row \li QOCI     \li Oracle Call Interface Driver     \row \li QODBC    \li ODBC Driver (includes Microsoft SQL Server)     \row \li QPSQL    \li PostgreSQL Driver     \row \li QSQLITE  \li SQLite version 3 or above     \row \li QSQLITE2 \li SQLite version 2     \row \li QTDS     \li Sybase Adaptive Server     \endtable      Additional third party drivers, including your own custom     drivers, can be loaded dynamically.      \sa {SQL Database Drivers}, registerSqlDriver(), drivers() */
end_comment
begin_constructor
DECL|function|QSqlDatabase
name|QSqlDatabase
operator|::
name|QSqlDatabase
parameter_list|(
specifier|const
name|QString
modifier|&
name|type
parameter_list|)
block|{
name|d
operator|=
operator|new
name|QSqlDatabasePrivate
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \overload      Creates a database connection using the given \a driver. */
end_comment
begin_constructor
DECL|function|QSqlDatabase
name|QSqlDatabase
operator|::
name|QSqlDatabase
parameter_list|(
name|QSqlDriver
modifier|*
name|driver
parameter_list|)
block|{
name|d
operator|=
operator|new
name|QSqlDatabasePrivate
argument_list|(
name|this
argument_list|,
name|driver
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Creates an empty, invalid QSqlDatabase object. Use addDatabase(),     removeDatabase(), and database() to get valid QSqlDatabase     objects. */
end_comment
begin_constructor
DECL|function|QSqlDatabase
name|QSqlDatabase
operator|::
name|QSqlDatabase
parameter_list|()
block|{
name|d
operator|=
name|QSqlDatabasePrivate
operator|::
name|shared_null
argument_list|()
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Creates a copy of \a other. */
end_comment
begin_constructor
DECL|function|QSqlDatabase
name|QSqlDatabase
operator|::
name|QSqlDatabase
parameter_list|(
specifier|const
name|QSqlDatabase
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns \a other to this object. */
end_comment
begin_function
DECL|function|operator =
name|QSqlDatabase
modifier|&
name|QSqlDatabase
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QSqlDatabase
modifier|&
name|other
parameter_list|)
block|{
name|qAtomicAssign
argument_list|(
name|d
argument_list|,
name|other
operator|.
name|d
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Create the actual driver instance \a type. */
end_comment
begin_function
DECL|function|init
name|void
name|QSqlDatabasePrivate
operator|::
name|init
parameter_list|(
specifier|const
name|QString
modifier|&
name|type
parameter_list|)
block|{
name|drvName
operator|=
name|type
expr_stmt|;
if|if
condition|(
operator|!
name|driver
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_SQL_PSQL
if|if
condition|(
name|type
operator|==
name|QLatin1String
argument_list|(
literal|"QPSQL"
argument_list|)
operator|||
name|type
operator|==
name|QLatin1String
argument_list|(
literal|"QPSQL7"
argument_list|)
condition|)
name|driver
operator|=
operator|new
name|QPSQLDriver
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_MYSQL
if|if
condition|(
name|type
operator|==
name|QLatin1String
argument_list|(
literal|"QMYSQL"
argument_list|)
operator|||
name|type
operator|==
name|QLatin1String
argument_list|(
literal|"QMYSQL3"
argument_list|)
condition|)
name|driver
operator|=
operator|new
name|QMYSQLDriver
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_ODBC
if|if
condition|(
name|type
operator|==
name|QLatin1String
argument_list|(
literal|"QODBC"
argument_list|)
operator|||
name|type
operator|==
name|QLatin1String
argument_list|(
literal|"QODBC3"
argument_list|)
condition|)
name|driver
operator|=
operator|new
name|QODBCDriver
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_OCI
if|if
condition|(
name|type
operator|==
name|QLatin1String
argument_list|(
literal|"QOCI"
argument_list|)
operator|||
name|type
operator|==
name|QLatin1String
argument_list|(
literal|"QOCI8"
argument_list|)
condition|)
name|driver
operator|=
operator|new
name|QOCIDriver
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_TDS
if|if
condition|(
name|type
operator|==
name|QLatin1String
argument_list|(
literal|"QTDS"
argument_list|)
operator|||
name|type
operator|==
name|QLatin1String
argument_list|(
literal|"QTDS7"
argument_list|)
condition|)
name|driver
operator|=
operator|new
name|QTDSDriver
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_DB2
if|if
condition|(
name|type
operator|==
name|QLatin1String
argument_list|(
literal|"QDB2"
argument_list|)
condition|)
name|driver
operator|=
operator|new
name|QDB2Driver
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_SQLITE
if|if
condition|(
name|type
operator|==
name|QLatin1String
argument_list|(
literal|"QSQLITE"
argument_list|)
condition|)
name|driver
operator|=
operator|new
name|QSQLiteDriver
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_SQLITE2
if|if
condition|(
name|type
operator|==
name|QLatin1String
argument_list|(
literal|"QSQLITE2"
argument_list|)
condition|)
name|driver
operator|=
operator|new
name|QSQLite2Driver
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SQL_IBASE
if|if
condition|(
name|type
operator|==
name|QLatin1String
argument_list|(
literal|"QIBASE"
argument_list|)
condition|)
name|driver
operator|=
operator|new
name|QIBaseDriver
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|driver
condition|)
block|{
name|DriverDict
name|dict
init|=
name|QSqlDatabasePrivate
operator|::
name|driverDict
argument_list|()
decl_stmt|;
for|for
control|(
name|DriverDict
operator|::
name|const_iterator
name|it
init|=
name|dict
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|dict
operator|.
name|constEnd
argument_list|()
operator|&&
operator|!
name|driver
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|type
operator|==
name|it
operator|.
name|key
argument_list|()
condition|)
block|{
name|driver
operator|=
operator|(
operator|(
name|QSqlDriverCreatorBase
operator|*
operator|)
operator|(
operator|*
name|it
operator|)
operator|)
operator|->
name|createObject
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|driver
operator|&&
name|loader
argument_list|()
condition|)
name|driver
operator|=
name|qLoadPlugin
argument_list|<
name|QSqlDriver
argument_list|,
name|QSqlDriverPlugin
argument_list|>
argument_list|(
name|loader
argument_list|()
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|driver
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSqlDatabase: %s driver not loaded"
argument_list|,
name|type
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"QSqlDatabase: available drivers: %s"
argument_list|,
name|QSqlDatabase
operator|::
name|drivers
argument_list|()
operator|.
name|join
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|==
literal|0
condition|)
name|qWarning
argument_list|(
literal|"QSqlDatabase: an instance of QCoreApplication is required for loading driver plugins"
argument_list|)
expr_stmt|;
name|driver
operator|=
name|shared_null
argument_list|()
operator|->
name|driver
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Destroys the object and frees any allocated resources.      \sa close() */
end_comment
begin_destructor
DECL|function|~QSqlDatabase
name|QSqlDatabase
operator|::
name|~
name|QSqlDatabase
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
operator|delete
name|d
expr_stmt|;
block|}
block|}
end_destructor
begin_comment
comment|/*!     Executes a SQL statement on the database and returns a QSqlQuery     object. Use lastError() to retrieve error information. If \a     query is empty, an empty, invalid query is returned and     lastError() is not affected.      \sa QSqlQuery, lastError() */
end_comment
begin_function
DECL|function|exec
name|QSqlQuery
name|QSqlDatabase
operator|::
name|exec
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|)
specifier|const
block|{
name|QSqlQuery
name|r
argument_list|(
name|d
operator|->
name|driver
operator|->
name|createResult
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|query
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|r
operator|.
name|exec
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|d
operator|->
name|driver
operator|->
name|setLastError
argument_list|(
name|r
operator|.
name|lastError
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function
begin_comment
comment|/*!     Opens the database connection using the current connection     values. Returns \c true on success; otherwise returns \c false. Error     information can be retrieved using lastError().      \sa lastError(), setDatabaseName(), setUserName(), setPassword(),         setHostName(), setPort(), setConnectOptions() */
end_comment
begin_function
DECL|function|open
name|bool
name|QSqlDatabase
operator|::
name|open
parameter_list|()
block|{
return|return
name|d
operator|->
name|driver
operator|->
name|open
argument_list|(
name|d
operator|->
name|dbname
argument_list|,
name|d
operator|->
name|uname
argument_list|,
name|d
operator|->
name|pword
argument_list|,
name|d
operator|->
name|hname
argument_list|,
name|d
operator|->
name|port
argument_list|,
name|d
operator|->
name|connOptions
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Opens the database connection using the given \a user name and \a     password. Returns \c true on success; otherwise returns \c false. Error     information can be retrieved using the lastError() function.      This function does not store the password it is given. Instead,     the password is passed directly to the driver for opening the     connection and it is then discarded.      \sa lastError() */
end_comment
begin_function
DECL|function|open
name|bool
name|QSqlDatabase
operator|::
name|open
parameter_list|(
specifier|const
name|QString
modifier|&
name|user
parameter_list|,
specifier|const
name|QString
modifier|&
name|password
parameter_list|)
block|{
name|setUserName
argument_list|(
name|user
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|driver
operator|->
name|open
argument_list|(
name|d
operator|->
name|dbname
argument_list|,
name|user
argument_list|,
name|password
argument_list|,
name|d
operator|->
name|hname
argument_list|,
name|d
operator|->
name|port
argument_list|,
name|d
operator|->
name|connOptions
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Closes the database connection, freeing any resources acquired, and     invalidating any existing QSqlQuery objects that are used with the     database.      This will also affect copies of this QSqlDatabase object.      \sa removeDatabase() */
end_comment
begin_function
DECL|function|close
name|void
name|QSqlDatabase
operator|::
name|close
parameter_list|()
block|{
name|d
operator|->
name|driver
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the database connection is currently open;     otherwise returns \c false. */
end_comment
begin_function
DECL|function|isOpen
name|bool
name|QSqlDatabase
operator|::
name|isOpen
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|driver
operator|->
name|isOpen
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if there was an error opening the database     connection; otherwise returns \c false. Error information can be     retrieved using the lastError() function. */
end_comment
begin_function
DECL|function|isOpenError
name|bool
name|QSqlDatabase
operator|::
name|isOpenError
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|driver
operator|->
name|isOpenError
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Begins a transaction on the database if the driver supports   transactions. Returns \c{true} if the operation succeeded.   Otherwise it returns \c{false}.    \sa QSqlDriver::hasFeature(), commit(), rollback() */
end_comment
begin_function
DECL|function|transaction
name|bool
name|QSqlDatabase
operator|::
name|transaction
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|driver
operator|->
name|hasFeature
argument_list|(
name|QSqlDriver
operator|::
name|Transactions
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|driver
operator|->
name|beginTransaction
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Commits a transaction to the database if the driver supports   transactions and a transaction() has been started. Returns \c{true}   if the operation succeeded. Otherwise it returns \c{false}.    \note For some databases, the commit will fail and return \c{false}   if there is an \l{QSqlQuery::isActive()} {active query} using the   database for a \c{SELECT}. Make the query \l{QSqlQuery::isActive()}   {inactive} before doing the commit.    Call lastError() to get information about errors.    \sa QSqlQuery::isActive(), QSqlDriver::hasFeature(), rollback() */
end_comment
begin_function
DECL|function|commit
name|bool
name|QSqlDatabase
operator|::
name|commit
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|driver
operator|->
name|hasFeature
argument_list|(
name|QSqlDriver
operator|::
name|Transactions
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|driver
operator|->
name|commitTransaction
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Rolls back a transaction on the database, if the driver supports   transactions and a transaction() has been started. Returns \c{true}   if the operation succeeded. Otherwise it returns \c{false}.    \note For some databases, the rollback will fail and return   \c{false} if there is an \l{QSqlQuery::isActive()} {active query}   using the database for a \c{SELECT}. Make the query   \l{QSqlQuery::isActive()} {inactive} before doing the rollback.    Call lastError() to get information about errors.    \sa QSqlQuery::isActive(), QSqlDriver::hasFeature(), commit() */
end_comment
begin_function
DECL|function|rollback
name|bool
name|QSqlDatabase
operator|::
name|rollback
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|driver
operator|->
name|hasFeature
argument_list|(
name|QSqlDriver
operator|::
name|Transactions
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|driver
operator|->
name|rollbackTransaction
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the connection's database name to \a name. To have effect,     the database name must be set \e{before} the connection is     \l{open()} {opened}.  Alternatively, you can close() the     connection, set the database name, and call open() again.  \note     The \e{database name} is not the \e{connection name}. The     connection name must be passed to addDatabase() at connection     object create time.      For the QOCI (Oracle) driver, the database name is the TNS     Service Name.      For the QODBC driver, the \a name can either be a DSN, a DSN     filename (in which case the file must have a \c .dsn extension),     or a connection string.      For example, Microsoft Access users can use the following     connection string to open an \c .mdb file directly, instead of     having to create a DSN entry in the ODBC manager:      \snippet code/src_sql_kernel_qsqldatabase.cpp 3      There is no default value.      \sa databaseName(), setUserName(), setPassword(), setHostName(),         setPort(), setConnectOptions(), open() */
end_comment
begin_function
DECL|function|setDatabaseName
name|void
name|QSqlDatabase
operator|::
name|setDatabaseName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|dbname
operator|=
name|name
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the connection's user name to \a name. To have effect, the     user name must be set \e{before} the connection is \l{open()}     {opened}.  Alternatively, you can close() the connection, set the     user name, and call open() again.      There is no default value.      \sa userName(), setDatabaseName(), setPassword(), setHostName(),         setPort(), setConnectOptions(), open() */
end_comment
begin_function
DECL|function|setUserName
name|void
name|QSqlDatabase
operator|::
name|setUserName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|uname
operator|=
name|name
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the connection's password to \a password. To have effect, the     password must be set \e{before} the connection is \l{open()}     {opened}.  Alternatively, you can close() the connection, set the     password, and call open() again.      There is no default value.      \warning This function stores the password in plain text within     Qt. Use the open() call that takes a password as parameter to     avoid this behavior.      \sa password(), setUserName(), setDatabaseName(), setHostName(),         setPort(), setConnectOptions(), open() */
end_comment
begin_function
DECL|function|setPassword
name|void
name|QSqlDatabase
operator|::
name|setPassword
parameter_list|(
specifier|const
name|QString
modifier|&
name|password
parameter_list|)
block|{
if|if
condition|(
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|pword
operator|=
name|password
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the connection's host name to \a host. To have effect, the     host name must be set \e{before} the connection is \l{open()}     {opened}.  Alternatively, you can close() the connection, set the     host name, and call open() again.      There is no default value.      \sa hostName(), setUserName(), setPassword(), setDatabaseName(),         setPort(), setConnectOptions(), open() */
end_comment
begin_function
DECL|function|setHostName
name|void
name|QSqlDatabase
operator|::
name|setHostName
parameter_list|(
specifier|const
name|QString
modifier|&
name|host
parameter_list|)
block|{
if|if
condition|(
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|hname
operator|=
name|host
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the connection's port number to \a port. To have effect, the     port number must be set \e{before} the connection is \l{open()}     {opened}.  Alternatively, you can close() the connection, set the     port number, and call open() again..      There is no default value.      \sa port(), setUserName(), setPassword(), setHostName(),         setDatabaseName(), setConnectOptions(), open() */
end_comment
begin_function
DECL|function|setPort
name|void
name|QSqlDatabase
operator|::
name|setPort
parameter_list|(
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|port
operator|=
name|port
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the connection's database name, which may be empty.     \note The database name is not the connection name.      \sa setDatabaseName() */
end_comment
begin_function
DECL|function|databaseName
name|QString
name|QSqlDatabase
operator|::
name|databaseName
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|dbname
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the connection's user name; it may be empty.      \sa setUserName() */
end_comment
begin_function
DECL|function|userName
name|QString
name|QSqlDatabase
operator|::
name|userName
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|uname
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the connection's password. If the password was not set     with setPassword(), and if the password was given in the open()     call, or if no password was used, an empty string is returned. */
end_comment
begin_function
DECL|function|password
name|QString
name|QSqlDatabase
operator|::
name|password
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|pword
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the connection's host name; it may be empty.      \sa setHostName() */
end_comment
begin_function
DECL|function|hostName
name|QString
name|QSqlDatabase
operator|::
name|hostName
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|hname
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the connection's driver name.      \sa addDatabase(), driver() */
end_comment
begin_function
DECL|function|driverName
name|QString
name|QSqlDatabase
operator|::
name|driverName
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|drvName
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the connection's port number. The value is undefined if     the port number has not been set.      \sa setPort() */
end_comment
begin_function
DECL|function|port
name|int
name|QSqlDatabase
operator|::
name|port
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|port
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the database driver used to access the database     connection.      \sa addDatabase(), drivers() */
end_comment
begin_function
DECL|function|driver
name|QSqlDriver
modifier|*
name|QSqlDatabase
operator|::
name|driver
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|driver
return|;
block|}
end_function
begin_comment
comment|/*!     Returns information about the last error that occurred on the     database.      Failures that occur in conjunction with an individual query are     reported by QSqlQuery::lastError().      \sa QSqlError, QSqlQuery::lastError() */
end_comment
begin_function
DECL|function|lastError
name|QSqlError
name|QSqlDatabase
operator|::
name|lastError
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|driver
operator|->
name|lastError
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of the database's tables, system tables and views,     as specified by the parameter \a type.      \sa primaryIndex(), record() */
end_comment
begin_function
DECL|function|tables
name|QStringList
name|QSqlDatabase
operator|::
name|tables
parameter_list|(
name|QSql
operator|::
name|TableType
name|type
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|driver
operator|->
name|tables
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the primary index for table \a tablename. If no primary     index exists an empty QSqlIndex is returned.      \sa tables(), record() */
end_comment
begin_function
DECL|function|primaryIndex
name|QSqlIndex
name|QSqlDatabase
operator|::
name|primaryIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|tablename
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|driver
operator|->
name|primaryIndex
argument_list|(
name|tablename
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QSqlRecord populated with the names of all the fields in     the table (or view) called \a tablename. The order in which the     fields appear in the record is undefined. If no such table (or     view) exists, an empty record is returned. */
end_comment
begin_function
DECL|function|record
name|QSqlRecord
name|QSqlDatabase
operator|::
name|record
parameter_list|(
specifier|const
name|QString
modifier|&
name|tablename
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|driver
operator|->
name|record
argument_list|(
name|tablename
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets database-specific \a options. This must be done before the     connection is opened or it has no effect (or you can close() the     connection, call this function and open() the connection again).      The format of the \a options string is a semicolon separated list     of option names or option=value pairs. The options depend on the     database client used:      \table     \header \li ODBC \li MySQL \li PostgreSQL     \row      \li     \list     \li SQL_ATTR_ACCESS_MODE     \li SQL_ATTR_LOGIN_TIMEOUT     \li SQL_ATTR_CONNECTION_TIMEOUT     \li SQL_ATTR_CURRENT_CATALOG     \li SQL_ATTR_METADATA_ID     \li SQL_ATTR_PACKET_SIZE     \li SQL_ATTR_TRACEFILE     \li SQL_ATTR_TRACE     \li SQL_ATTR_CONNECTION_POOLING     \li SQL_ATTR_ODBC_VERSION     \endlist      \li     \list     \li CLIENT_COMPRESS     \li CLIENT_FOUND_ROWS     \li CLIENT_IGNORE_SPACE     \li CLIENT_ODBC     \li CLIENT_NO_SCHEMA     \li CLIENT_INTERACTIVE     \li UNIX_SOCKET     \li MYSQL_OPT_RECONNECT     \li MYSQL_OPT_CONNECT_TIMEOUT     \li MYSQL_OPT_READ_TIMEOUT     \li MYSQL_OPT_WRITE_TIMEOUT     \li SSL_KEY     \li SSL_CERT     \li SSL_CA     \li SSL_CAPATH     \li SSL_CIPHER     \endlist      \li     \list     \li connect_timeout     \li options     \li tty     \li requiressl     \li service     \endlist      \header \li DB2 \li OCI \li TDS     \row      \li     \list     \li SQL_ATTR_ACCESS_MODE     \li SQL_ATTR_LOGIN_TIMEOUT     \endlist      \li     \list     \li OCI_ATTR_PREFETCH_ROWS     \li OCI_ATTR_PREFETCH_MEMORY     \endlist      \li     \e none      \header \li SQLite \li Interbase     \row      \li     \list     \li QSQLITE_BUSY_TIMEOUT     \li QSQLITE_OPEN_READONLY     \li QSQLITE_OPEN_URI     \li QSQLITE_ENABLE_SHARED_CACHE     \endlist      \li     \list     \li ISC_DPB_LC_CTYPE     \li ISC_DPB_SQL_ROLE_NAME     \endlist      \endtable      Examples:     \snippet code/src_sql_kernel_qsqldatabase.cpp 4      Refer to the client library documentation for more information     about the different options.      \sa connectOptions() */
end_comment
begin_function
DECL|function|setConnectOptions
name|void
name|QSqlDatabase
operator|::
name|setConnectOptions
parameter_list|(
specifier|const
name|QString
modifier|&
name|options
parameter_list|)
block|{
if|if
condition|(
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|connOptions
operator|=
name|options
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the connection options string used for this connection.     The string may be empty.      \sa setConnectOptions()  */
end_comment
begin_function
DECL|function|connectOptions
name|QString
name|QSqlDatabase
operator|::
name|connectOptions
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|connOptions
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if a driver called \a name is available; otherwise     returns \c false.      \sa drivers() */
end_comment
begin_function
DECL|function|isDriverAvailable
name|bool
name|QSqlDatabase
operator|::
name|isDriverAvailable
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
return|return
name|drivers
argument_list|()
operator|.
name|contains
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn QSqlDatabase QSqlDatabase::addDatabase(QSqlDriver* driver, const QString& connectionName)      This overload is useful when you want to create a database     connection with a \l{QSqlDriver} {driver} you instantiated     yourself. It might be your own database driver, or you might just     need to instantiate one of the Qt drivers yourself. If you do     this, it is recommended that you include the driver code in your     application. For example, you can create a PostgreSQL connection     with your own QPSQL driver like this:      \snippet code/src_sql_kernel_qsqldatabase.cpp 5     \codeline     \snippet code/src_sql_kernel_qsqldatabase.cpp 6      The above code sets up a PostgreSQL connection and instantiates a     QPSQLDriver object. Next, addDatabase() is called to add the     connection to the known connections so that it can be used by the     Qt SQL classes. When a driver is instantiated with a connection     handle (or set of handles), Qt assumes that you have already     opened the database connection.      \note We assume that \c qtdir is the directory where Qt is     installed. This will pull in the code that is needed to use the     PostgreSQL client library and to instantiate a QPSQLDriver object,     assuming that you have the PostgreSQL headers somewhere in your     include search path.      Remember that you must link your application against the database     client library. Make sure the client library is in your linker's     search path, and add lines like these to your \c{.pro} file:      \snippet code/src_sql_kernel_qsqldatabase.cpp 7      The method described works for all the supplied drivers.  The only     difference will be in the driver constructor arguments.  Here is a     table of the drivers included with Qt, their source code files,     and their constructor arguments:      \table     \header \li Driver \li Class name \li Constructor arguments \li File to include     \row     \li QPSQL     \li QPSQLDriver     \li PGconn *connection     \li \c qsql_psql.cpp     \row     \li QMYSQL     \li QMYSQLDriver     \li MYSQL *connection     \li \c qsql_mysql.cpp     \row     \li QOCI     \li QOCIDriver     \li OCIEnv *environment, OCISvcCtx *serviceContext     \li \c qsql_oci.cpp     \row     \li QODBC     \li QODBCDriver     \li SQLHANDLE environment, SQLHANDLE connection     \li \c qsql_odbc.cpp     \row     \li QDB2     \li QDB2     \li SQLHANDLE environment, SQLHANDLE connection     \li \c qsql_db2.cpp     \row     \li QTDS     \li QTDSDriver     \li LOGINREC *loginRecord, DBPROCESS *dbProcess, const QString&hostName     \li \c qsql_tds.cpp     \row     \li QSQLITE     \li QSQLiteDriver     \li sqlite *connection     \li \c qsql_sqlite.cpp     \row     \li QIBASE     \li QIBaseDriver     \li isc_db_handle connection     \li \c qsql_ibase.cpp     \endtable      The host name (or service name) is needed when constructing the     QTDSDriver for creating new connections for internal queries. This     is to prevent blocking when several QSqlQuery objects are used     simultaneously.      \warning Adding a database connection with the same connection     name as an existing connection, causes the existing connection to     be replaced by the new one.      \warning The SQL framework takes ownership of the \a driver. It     must not be deleted. To remove the connection, use     removeDatabase().      \sa drivers() */
end_comment
begin_function
DECL|function|addDatabase
name|QSqlDatabase
name|QSqlDatabase
operator|::
name|addDatabase
parameter_list|(
name|QSqlDriver
modifier|*
name|driver
parameter_list|,
specifier|const
name|QString
modifier|&
name|connectionName
parameter_list|)
block|{
name|QSqlDatabase
name|db
argument_list|(
name|driver
argument_list|)
decl_stmt|;
name|QSqlDatabasePrivate
operator|::
name|addDatabase
argument_list|(
name|db
argument_list|,
name|connectionName
argument_list|)
expr_stmt|;
return|return
name|db
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the QSqlDatabase has a valid driver.      Example:     \snippet code/src_sql_kernel_qsqldatabase.cpp 8 */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QSqlDatabase
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|driver
operator|&&
name|d
operator|->
name|driver
operator|!=
name|d
operator|->
name|shared_null
argument_list|()
operator|->
name|driver
return|;
block|}
end_function
begin_comment
comment|/*!     Clones the database connection \a other and stores it as \a     connectionName. All the settings from the original database, e.g.     databaseName(), hostName(), etc., are copied across. Does nothing     if \a other is an invalid database. Returns the newly created     database connection.      \note The new connection has not been opened. Before using the new     connection, you must call open(). */
end_comment
begin_function
DECL|function|cloneDatabase
name|QSqlDatabase
name|QSqlDatabase
operator|::
name|cloneDatabase
parameter_list|(
specifier|const
name|QSqlDatabase
modifier|&
name|other
parameter_list|,
specifier|const
name|QString
modifier|&
name|connectionName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|other
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QSqlDatabase
argument_list|()
return|;
name|QSqlDatabase
name|db
argument_list|(
name|other
operator|.
name|driverName
argument_list|()
argument_list|)
decl_stmt|;
name|db
operator|.
name|d
operator|->
name|copy
argument_list|(
name|other
operator|.
name|d
argument_list|)
expr_stmt|;
name|QSqlDatabasePrivate
operator|::
name|addDatabase
argument_list|(
name|db
argument_list|,
name|connectionName
argument_list|)
expr_stmt|;
return|return
name|db
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the connection name, which may be empty.  \note The     connection name is not the \l{databaseName()} {database name}.      \sa addDatabase() */
end_comment
begin_function
DECL|function|connectionName
name|QString
name|QSqlDatabase
operator|::
name|connectionName
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|connName
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sets the default numerical precision policy used by queries created     on this database connection to \a precisionPolicy.      Note: Drivers that don't support fetching numerical values with low     precision will ignore the precision policy. You can use     QSqlDriver::hasFeature() to find out whether a driver supports this     feature.      Note: Setting the default precision policy to \a precisionPolicy     doesn't affect any currently active queries.      \sa QSql::NumericalPrecisionPolicy, numericalPrecisionPolicy(),         QSqlQuery::setNumericalPrecisionPolicy(), QSqlQuery::numericalPrecisionPolicy() */
end_comment
begin_function
DECL|function|setNumericalPrecisionPolicy
name|void
name|QSqlDatabase
operator|::
name|setNumericalPrecisionPolicy
parameter_list|(
name|QSql
operator|::
name|NumericalPrecisionPolicy
name|precisionPolicy
parameter_list|)
block|{
if|if
condition|(
name|driver
argument_list|()
condition|)
name|driver
argument_list|()
operator|->
name|setNumericalPrecisionPolicy
argument_list|(
name|precisionPolicy
argument_list|)
expr_stmt|;
name|d
operator|->
name|precisionPolicy
operator|=
name|precisionPolicy
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns the current default precision policy for the database connection.      \sa QSql::NumericalPrecisionPolicy, setNumericalPrecisionPolicy(),         QSqlQuery::numericalPrecisionPolicy(), QSqlQuery::setNumericalPrecisionPolicy() */
end_comment
begin_function
DECL|function|numericalPrecisionPolicy
name|QSql
operator|::
name|NumericalPrecisionPolicy
name|QSqlDatabase
operator|::
name|numericalPrecisionPolicy
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|driver
argument_list|()
condition|)
return|return
name|driver
argument_list|()
operator|->
name|numericalPrecisionPolicy
argument_list|()
return|;
else|else
return|return
name|d
operator|->
name|precisionPolicy
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QSqlDatabase
modifier|&
name|d
parameter_list|)
block|{
name|QDebugStateSaver
name|saver
argument_list|(
name|dbg
argument_list|)
decl_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
expr_stmt|;
name|dbg
operator|.
name|noquote
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|dbg
operator|<<
literal|"QSqlDatabase(invalid)"
expr_stmt|;
return|return
name|dbg
return|;
block|}
name|dbg
operator|<<
literal|"QSqlDatabase(driver=\""
operator|<<
name|d
operator|.
name|driverName
argument_list|()
operator|<<
literal|"\", database=\""
operator|<<
name|d
operator|.
name|databaseName
argument_list|()
operator|<<
literal|"\", host=\""
operator|<<
name|d
operator|.
name|hostName
argument_list|()
operator|<<
literal|"\", port="
operator|<<
name|d
operator|.
name|port
argument_list|()
operator|<<
literal|", user=\""
operator|<<
name|d
operator|.
name|userName
argument_list|()
operator|<<
literal|"\", open="
operator|<<
name|d
operator|.
name|isOpen
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
