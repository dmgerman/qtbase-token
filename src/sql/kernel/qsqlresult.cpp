begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtSql module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qsqlresult.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|"qregexp.h"
end_include
begin_include
include|#
directive|include
file|"qsqlerror.h"
end_include
begin_include
include|#
directive|include
file|"qsqlfield.h"
end_include
begin_include
include|#
directive|include
file|"qsqlrecord.h"
end_include
begin_include
include|#
directive|include
file|"qvector.h"
end_include
begin_include
include|#
directive|include
file|"qsqldriver.h"
end_include
begin_include
include|#
directive|include
file|"qpointer.h"
end_include
begin_include
include|#
directive|include
file|"qsqlresult_p.h"
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|holderAt
name|QString
name|QSqlResultPrivate
operator|::
name|holderAt
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|holders
operator|.
name|size
argument_list|()
operator|>
name|index
condition|?
name|holders
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|holderName
else|:
name|fieldSerial
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// return a unique id for bound names
end_comment
begin_function
DECL|function|fieldSerial
name|QString
name|QSqlResultPrivate
operator|::
name|fieldSerial
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|ushort
name|arr
index|[]
init|=
block|{
literal|':'
block|,
literal|'f'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|ushort
modifier|*
name|ptr
init|=
operator|&
name|arr
index|[
literal|1
index|]
decl_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|=
literal|'a'
operator|+
name|i
operator|%
literal|16
expr_stmt|;
name|i
operator|>>=
literal|4
expr_stmt|;
block|}
return|return
name|QString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|arr
argument_list|)
argument_list|,
name|int
argument_list|(
name|ptr
operator|-
name|arr
argument_list|)
operator|+
literal|1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qIsAlnum
specifier|static
name|bool
name|qIsAlnum
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
name|uint
name|u
init|=
name|uint
argument_list|(
name|ch
operator|.
name|unicode
argument_list|()
argument_list|)
decl_stmt|;
comment|// matches [a-zA-Z0-9_]
return|return
name|u
operator|-
literal|'a'
operator|<
literal|26
operator|||
name|u
operator|-
literal|'A'
operator|<
literal|26
operator|||
name|u
operator|-
literal|'0'
operator|<
literal|10
operator|||
name|u
operator|==
literal|'_'
return|;
block|}
end_function
begin_function
DECL|function|positionalToNamedBinding
name|QString
name|QSqlResultPrivate
operator|::
name|positionalToNamedBinding
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|)
block|{
name|int
name|n
init|=
name|query
operator|.
name|size
argument_list|()
decl_stmt|;
name|QString
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|n
operator|*
literal|5
operator|/
literal|4
argument_list|)
expr_stmt|;
name|bool
name|inQuote
init|=
literal|false
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|ch
init|=
name|query
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
operator|&&
operator|!
name|inQuote
condition|)
block|{
name|result
operator|+=
name|fieldSerial
argument_list|(
name|count
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
condition|)
name|inQuote
operator|=
operator|!
name|inQuote
expr_stmt|;
name|result
operator|+=
name|ch
expr_stmt|;
block|}
block|}
name|result
operator|.
name|squeeze
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|namedToPositionalBinding
name|QString
name|QSqlResultPrivate
operator|::
name|namedToPositionalBinding
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|)
block|{
name|int
name|n
init|=
name|query
operator|.
name|size
argument_list|()
decl_stmt|;
name|QString
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|bool
name|inQuote
init|=
literal|false
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|QChar
name|ch
init|=
name|query
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|&&
operator|!
name|inQuote
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|query
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|)
operator|&&
operator|(
name|i
operator|+
literal|1
operator|<
name|n
operator|&&
name|qIsAlnum
argument_list|(
name|query
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|int
name|pos
init|=
name|i
operator|+
literal|2
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|n
operator|&&
name|qIsAlnum
argument_list|(
name|query
operator|.
name|at
argument_list|(
name|pos
argument_list|)
argument_list|)
condition|)
operator|++
name|pos
expr_stmt|;
name|QString
name|holder
argument_list|(
name|query
operator|.
name|mid
argument_list|(
name|i
argument_list|,
name|pos
operator|-
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|indexes
index|[
name|holder
index|]
operator|.
name|append
argument_list|(
name|count
operator|++
argument_list|)
expr_stmt|;
name|holders
operator|.
name|append
argument_list|(
name|QHolder
argument_list|(
name|holder
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
name|i
operator|=
name|pos
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
condition|)
name|inQuote
operator|=
operator|!
name|inQuote
expr_stmt|;
name|result
operator|+=
name|ch
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
name|result
operator|.
name|squeeze
argument_list|()
expr_stmt|;
name|values
operator|.
name|resize
argument_list|(
name|holders
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \class QSqlResult     \brief The QSqlResult class provides an abstract interface for     accessing data from specific SQL databases.      \ingroup database     \inmodule QtSql      Normally, you would use QSqlQuery instead of QSqlResult, since     QSqlQuery provides a generic wrapper for database-specific     implementations of QSqlResult.      If you are implementing your own SQL driver (by subclassing     QSqlDriver), you will need to provide your own QSqlResult     subclass that implements all the pure virtual functions and other     virtual functions that you need.      \sa QSqlDriver */
end_comment
begin_comment
comment|/*!     \enum QSqlResult::BindingSyntax      This enum type specifies the different syntaxes for specifying     placeholders in prepared queries.      \value PositionalBinding Use the ODBC-style positional syntax, with "?" as placeholders.     \value NamedBinding Use the Oracle-style syntax with named placeholders (e.g., ":id")      \sa bindingSyntax() */
end_comment
begin_comment
comment|/*!     \enum QSqlResult::VirtualHookOperation     \internal */
end_comment
begin_comment
comment|/*!     Creates a QSqlResult using database driver \a db. The object is     initialized to an inactive state.      \sa isActive(), driver() */
end_comment
begin_constructor
DECL|function|QSqlResult
name|QSqlResult
operator|::
name|QSqlResult
parameter_list|(
specifier|const
name|QSqlDriver
modifier|*
name|db
parameter_list|)
block|{
name|d
operator|=
operator|new
name|QSqlResultPrivate
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|sqldriver
operator|=
cast|const_cast
argument_list|<
name|QSqlDriver
operator|*
argument_list|>
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
condition|)
block|{
name|setNumericalPrecisionPolicy
argument_list|(
name|db
operator|->
name|numericalPrecisionPolicy
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Destroys the object and frees any allocated resources. */
end_comment
begin_destructor
DECL|function|~QSqlResult
name|QSqlResult
operator|::
name|~
name|QSqlResult
parameter_list|()
block|{
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Sets the current query for the result to \a query. You must call     reset() to execute the query on the database.      \sa reset(), lastQuery() */
end_comment
begin_function
DECL|function|setQuery
name|void
name|QSqlResult
operator|::
name|setQuery
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|)
block|{
name|d
operator|->
name|sql
operator|=
name|query
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current SQL query text, or an empty string if there     isn't one.      \sa setQuery() */
end_comment
begin_function
DECL|function|lastQuery
name|QString
name|QSqlResult
operator|::
name|lastQuery
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sql
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current (zero-based) row position of the result. May     return the special values QSql::BeforeFirstRow or     QSql::AfterLastRow.      \sa setAt(), isValid() */
end_comment
begin_function
DECL|function|at
name|int
name|QSqlResult
operator|::
name|at
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|idx
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the result is positioned on a valid record (that     is, the result is not positioned before the first or after the     last record); otherwise returns false.      \sa at() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QSqlResult
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|idx
operator|!=
name|QSql
operator|::
name|BeforeFirstRow
operator|&&
name|d
operator|->
name|idx
operator|!=
name|QSql
operator|::
name|AfterLastRow
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QSqlResult::isNull(int index)      Returns true if the field at position \a index in the current row     is null; otherwise returns false. */
end_comment
begin_comment
comment|/*!     Returns true if the result has records to be retrieved; otherwise     returns false. */
end_comment
begin_function
DECL|function|isActive
name|bool
name|QSqlResult
operator|::
name|isActive
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|active
return|;
block|}
end_function
begin_comment
comment|/*!     This function is provided for derived classes to set the     internal (zero-based) row position to \a index.      \sa at() */
end_comment
begin_function
DECL|function|setAt
name|void
name|QSqlResult
operator|::
name|setAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|d
operator|->
name|idx
operator|=
name|index
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This function is provided for derived classes to indicate whether     or not the current statement is a SQL \c SELECT statement. The \a     select parameter should be true if the statement is a \c SELECT     statement; otherwise it should be false.      \sa isSelect() */
end_comment
begin_function
DECL|function|setSelect
name|void
name|QSqlResult
operator|::
name|setSelect
parameter_list|(
name|bool
name|select
parameter_list|)
block|{
name|d
operator|->
name|isSel
operator|=
name|select
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the current result is from a \c SELECT statement;     otherwise returns false.      \sa setSelect() */
end_comment
begin_function
DECL|function|isSelect
name|bool
name|QSqlResult
operator|::
name|isSelect
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|isSel
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the driver associated with the result. This is the object     that was passed to the constructor. */
end_comment
begin_function
DECL|function|driver
specifier|const
name|QSqlDriver
modifier|*
name|QSqlResult
operator|::
name|driver
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sqldriver
return|;
block|}
end_function
begin_comment
comment|/*!     This function is provided for derived classes to set the internal     active state to \a active.      \sa isActive() */
end_comment
begin_function
DECL|function|setActive
name|void
name|QSqlResult
operator|::
name|setActive
parameter_list|(
name|bool
name|active
parameter_list|)
block|{
if|if
condition|(
name|active
operator|&&
name|d
operator|->
name|executedQuery
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|executedQuery
operator|=
name|d
operator|->
name|sql
expr_stmt|;
name|d
operator|->
name|active
operator|=
name|active
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This function is provided for derived classes to set the last     error to \a error.      \sa lastError() */
end_comment
begin_function
DECL|function|setLastError
name|void
name|QSqlResult
operator|::
name|setLastError
parameter_list|(
specifier|const
name|QSqlError
modifier|&
name|error
parameter_list|)
block|{
name|d
operator|->
name|error
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the last error associated with the result. */
end_comment
begin_function
DECL|function|lastError
name|QSqlError
name|QSqlResult
operator|::
name|lastError
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|error
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QSqlResult::size()      Returns the size of the \c SELECT result, or -1 if it cannot be     determined or if the query is not a \c SELECT statement.      \sa numRowsAffected() */
end_comment
begin_comment
comment|/*!     \fn int QSqlResult::numRowsAffected()      Returns the number of rows affected by the last query executed, or     -1 if it cannot be determined or if the query is a \c SELECT     statement.      \sa size() */
end_comment
begin_comment
comment|/*!     \fn QVariant QSqlResult::data(int index)      Returns the data for field \a index in the current row as     a QVariant. This function is only called if the result is in     an active state and is positioned on a valid record and \a index is     non-negative. Derived classes must reimplement this function and     return the value of field \a index, or QVariant() if it cannot be     determined. */
end_comment
begin_comment
comment|/*!     \fn  bool QSqlResult::reset(const QString&query)      Sets the result to use the SQL statement \a query for subsequent     data retrieval.      Derived classes must reimplement this function and apply the \a     query to the database. This function is only called after the     result is set to an inactive state and is positioned before the     first record of the new result. Derived classes should return     true if the query was successful and ready to be used, or false     otherwise.      \sa setQuery() */
end_comment
begin_comment
comment|/*!     \fn bool QSqlResult::fetch(int index)      Positions the result to an arbitrary (zero-based) row \a index.      This function is only called if the result is in an active state.     Derived classes must reimplement this function and position the     result to the row \a index, and call setAt() with an appropriate     value. Return true to indicate success, or false to signify     failure.      \sa isActive(), fetchFirst(), fetchLast(), fetchNext(), fetchPrevious() */
end_comment
begin_comment
comment|/*!     \fn bool QSqlResult::fetchFirst()      Positions the result to the first record (row 0) in the result.      This function is only called if the result is in an active state.     Derived classes must reimplement this function and position the     result to the first record, and call setAt() with an appropriate     value. Return true to indicate success, or false to signify     failure.      \sa fetch(), fetchLast() */
end_comment
begin_comment
comment|/*!     \fn bool QSqlResult::fetchLast()      Positions the result to the last record (last row) in the result.      This function is only called if the result is in an active state.     Derived classes must reimplement this function and position the     result to the last record, and call setAt() with an appropriate     value. Return true to indicate success, or false to signify     failure.      \sa fetch(), fetchFirst() */
end_comment
begin_comment
comment|/*!     Positions the result to the next available record (row) in the     result.      This function is only called if the result is in an active     state. The default implementation calls fetch() with the next     index. Derived classes can reimplement this function and position     the result to the next record in some other way, and call setAt()     with an appropriate value. Return true to indicate success, or     false to signify failure.      \sa fetch(), fetchPrevious() */
end_comment
begin_function
DECL|function|fetchNext
name|bool
name|QSqlResult
operator|::
name|fetchNext
parameter_list|()
block|{
return|return
name|fetch
argument_list|(
name|at
argument_list|()
operator|+
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Positions the result to the previous record (row) in the result.      This function is only called if the result is in an active state.     The default implementation calls fetch() with the previous index.     Derived classes can reimplement this function and position the     result to the next record in some other way, and call setAt()     with an appropriate value. Return true to indicate success, or     false to signify failure. */
end_comment
begin_function
DECL|function|fetchPrevious
name|bool
name|QSqlResult
operator|::
name|fetchPrevious
parameter_list|()
block|{
return|return
name|fetch
argument_list|(
name|at
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if you can only scroll forward through the result     set; otherwise returns false.      \sa setForwardOnly() */
end_comment
begin_function
DECL|function|isForwardOnly
name|bool
name|QSqlResult
operator|::
name|isForwardOnly
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|forwardOnly
return|;
block|}
end_function
begin_comment
comment|/*!     Sets forward only mode to \a forward. If \a forward is true, only     fetchNext() is allowed for navigating the results. Forward only     mode needs much less memory since results do not have to be     cached. By default, this feature is disabled.      Setting forward only to false is a suggestion to the database engine,     which has the final say on whether a result set is forward only or     scrollable. isForwardOnly() will always return the correct status of     the result set.      \note Calling setForwardOnly after execution of the query will result     in unexpected results at best, and crashes at worst.      \sa isForwardOnly(), fetchNext(), QSqlQuery::setForwardOnly() */
end_comment
begin_function
DECL|function|setForwardOnly
name|void
name|QSqlResult
operator|::
name|setForwardOnly
parameter_list|(
name|bool
name|forward
parameter_list|)
block|{
name|d
operator|->
name|forwardOnly
operator|=
name|forward
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Prepares the given \a query, using the underlying database     functionality where possible. Returns true if the query is     prepared successfully; otherwise returns false.      Note: This method should have been called "safePrepare()".      \sa prepare() */
end_comment
begin_function
DECL|function|savePrepare
name|bool
name|QSqlResult
operator|::
name|savePrepare
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|)
block|{
if|if
condition|(
operator|!
name|driver
argument_list|()
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|sql
operator|=
name|query
expr_stmt|;
if|if
condition|(
operator|!
name|driver
argument_list|()
operator|->
name|hasFeature
argument_list|(
name|QSqlDriver
operator|::
name|PreparedQueries
argument_list|)
condition|)
return|return
name|prepare
argument_list|(
name|query
argument_list|)
return|;
comment|// parse the query to memorize parameter location
name|d
operator|->
name|executedQuery
operator|=
name|d
operator|->
name|namedToPositionalBinding
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|driver
argument_list|()
operator|->
name|hasFeature
argument_list|(
name|QSqlDriver
operator|::
name|NamedPlaceholders
argument_list|)
condition|)
name|d
operator|->
name|executedQuery
operator|=
name|QSqlResultPrivate
operator|::
name|positionalToNamedBinding
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|prepare
argument_list|(
name|d
operator|->
name|executedQuery
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Prepares the given \a query for execution; the query will normally     use placeholders so that it can be executed repeatedly. Returns     true if the query is prepared successfully; otherwise returns false.      \sa exec() */
end_comment
begin_function
DECL|function|prepare
name|bool
name|QSqlResult
operator|::
name|prepare
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|)
block|{
name|d
operator|->
name|sql
operator|=
name|query
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|holders
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// parse the query to memorize parameter location
name|d
operator|->
name|namedToPositionalBinding
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
comment|// fake prepares should always succeed
block|}
end_function
begin_comment
comment|/*!     Executes the query, returning true if successful; otherwise returns     false.      \sa prepare() */
end_comment
begin_function
DECL|function|exec
name|bool
name|QSqlResult
operator|::
name|exec
parameter_list|()
block|{
name|bool
name|ret
decl_stmt|;
comment|// fake preparation - just replace the placeholders..
name|QString
name|query
init|=
name|lastQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|binds
operator|==
name|NamedBinding
condition|)
block|{
name|int
name|i
decl_stmt|;
name|QVariant
name|val
decl_stmt|;
name|QString
name|holder
decl_stmt|;
for|for
control|(
name|i
operator|=
name|d
operator|->
name|holders
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|holder
operator|=
name|d
operator|->
name|holders
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|holderName
expr_stmt|;
name|val
operator|=
name|d
operator|->
name|values
operator|.
name|value
argument_list|(
name|d
operator|->
name|indexes
operator|.
name|value
argument_list|(
name|holder
argument_list|)
operator|.
name|value
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|QSqlField
name|f
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|val
operator|.
name|type
argument_list|()
argument_list|)
decl_stmt|;
name|f
operator|.
name|setValue
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|query
operator|=
name|query
operator|.
name|replace
argument_list|(
name|d
operator|->
name|holders
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|holderPos
argument_list|,
name|holder
operator|.
name|length
argument_list|()
argument_list|,
name|driver
argument_list|()
operator|->
name|formatValue
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|QString
name|val
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|d
operator|->
name|values
operator|.
name|count
argument_list|()
condition|;
operator|++
name|idx
control|)
block|{
name|i
operator|=
name|query
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|QVariant
name|var
init|=
name|d
operator|->
name|values
operator|.
name|value
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|QSqlField
name|f
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|var
operator|.
name|type
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|var
operator|.
name|isNull
argument_list|()
condition|)
name|f
operator|.
name|clear
argument_list|()
expr_stmt|;
else|else
name|f
operator|.
name|setValue
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|val
operator|=
name|driver
argument_list|()
operator|->
name|formatValue
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|query
operator|=
name|query
operator|.
name|replace
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
name|driver
argument_list|()
operator|->
name|formatValue
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|+=
name|val
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
block|}
comment|// have to retain the original query with placeholders
name|QString
name|orig
init|=
name|lastQuery
argument_list|()
decl_stmt|;
name|ret
operator|=
name|reset
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|d
operator|->
name|executedQuery
operator|=
name|query
expr_stmt|;
name|setQuery
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|d
operator|->
name|resetBindCount
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     Binds the value \a val of parameter type \a paramType to position \a index     in the current record (row).      \sa addBindValue() */
end_comment
begin_function
DECL|function|bindValue
name|void
name|QSqlResult
operator|::
name|bindValue
parameter_list|(
name|int
name|index
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|val
parameter_list|,
name|QSql
operator|::
name|ParamType
name|paramType
parameter_list|)
block|{
name|d
operator|->
name|binds
operator|=
name|PositionalBinding
expr_stmt|;
name|d
operator|->
name|indexes
index|[
name|QSqlResultPrivate
operator|::
name|fieldSerial
argument_list|(
name|index
argument_list|)
index|]
operator|.
name|append
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|values
operator|.
name|count
argument_list|()
operator|<=
name|index
condition|)
name|d
operator|->
name|values
operator|.
name|resize
argument_list|(
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|values
index|[
name|index
index|]
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|paramType
operator|!=
name|QSql
operator|::
name|In
operator|||
operator|!
name|d
operator|->
name|types
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|types
index|[
name|index
index|]
operator|=
name|paramType
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Binds the value \a val of parameter type \a paramType to the \a     placeholder name in the current record (row).     Values cannot be bound to multiple locations in the query, eg:    \code    INSERT INTO testtable (id, name, samename) VALUES (:id, :name, :name)    \endcode    Binding to name will bind to the first :name, but not the second.      \note Binding an undefined placeholder will result in undefined behavior.      \sa QSqlQuery::bindValue() */
end_comment
begin_function
DECL|function|bindValue
name|void
name|QSqlResult
operator|::
name|bindValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|placeholder
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|val
parameter_list|,
name|QSql
operator|::
name|ParamType
name|paramType
parameter_list|)
block|{
name|d
operator|->
name|binds
operator|=
name|NamedBinding
expr_stmt|;
comment|// if the index has already been set when doing emulated named
comment|// bindings - don't reset it
name|QList
argument_list|<
name|int
argument_list|>
name|indexes
init|=
name|d
operator|->
name|indexes
operator|.
name|value
argument_list|(
name|placeholder
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|int
name|idx
decl|,
name|indexes
control|)
block|{
if|if
condition|(
name|d
operator|->
name|values
operator|.
name|count
argument_list|()
operator|<=
name|idx
condition|)
name|d
operator|->
name|values
operator|.
name|resize
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|values
index|[
name|idx
index|]
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|paramType
operator|!=
name|QSql
operator|::
name|In
operator|||
operator|!
name|d
operator|->
name|types
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|types
index|[
name|idx
index|]
operator|=
name|paramType
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Binds the value \a val of parameter type \a paramType to the next     available position in the current record (row).      \sa bindValue() */
end_comment
begin_function
DECL|function|addBindValue
name|void
name|QSqlResult
operator|::
name|addBindValue
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|val
parameter_list|,
name|QSql
operator|::
name|ParamType
name|paramType
parameter_list|)
block|{
name|d
operator|->
name|binds
operator|=
name|PositionalBinding
expr_stmt|;
name|bindValue
argument_list|(
name|d
operator|->
name|bindCount
argument_list|,
name|val
argument_list|,
name|paramType
argument_list|)
expr_stmt|;
operator|++
name|d
operator|->
name|bindCount
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the value bound at position \a index in the current record     (row).      \sa bindValue(), boundValues() */
end_comment
begin_function
DECL|function|boundValue
name|QVariant
name|QSqlResult
operator|::
name|boundValue
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|values
operator|.
name|value
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the value bound by the given \a placeholder name in the     current record (row).      \sa bindValueType() */
end_comment
begin_function
DECL|function|boundValue
name|QVariant
name|QSqlResult
operator|::
name|boundValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|placeholder
parameter_list|)
specifier|const
block|{
name|QList
argument_list|<
name|int
argument_list|>
name|indexes
init|=
name|d
operator|->
name|indexes
operator|.
name|value
argument_list|(
name|placeholder
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|values
operator|.
name|value
argument_list|(
name|indexes
operator|.
name|value
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the parameter type for the value bound at position \a index.      \sa boundValue() */
end_comment
begin_function
DECL|function|bindValueType
name|QSql
operator|::
name|ParamType
name|QSqlResult
operator|::
name|bindValueType
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|types
operator|.
name|value
argument_list|(
name|index
argument_list|,
name|QSql
operator|::
name|In
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the parameter type for the value bound with the given \a     placeholder name. */
end_comment
begin_function
DECL|function|bindValueType
name|QSql
operator|::
name|ParamType
name|QSqlResult
operator|::
name|bindValueType
parameter_list|(
specifier|const
name|QString
modifier|&
name|placeholder
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|types
operator|.
name|value
argument_list|(
name|d
operator|->
name|indexes
operator|.
name|value
argument_list|(
name|placeholder
argument_list|)
operator|.
name|value
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|QSql
operator|::
name|In
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of bound values in the result.      \sa boundValues() */
end_comment
begin_function
DECL|function|boundValueCount
name|int
name|QSqlResult
operator|::
name|boundValueCount
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|values
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a vector of the result's bound values for the current     record (row).      \sa boundValueCount() */
end_comment
begin_function
DECL|function|boundValues
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|QSqlResult
operator|::
name|boundValues
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|values
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the binding syntax used by prepared queries. */
end_comment
begin_function
DECL|function|bindingSyntax
name|QSqlResult
operator|::
name|BindingSyntax
name|QSqlResult
operator|::
name|bindingSyntax
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|binds
return|;
block|}
end_function
begin_comment
comment|/*!     Clears the entire result set and releases any associated     resources. */
end_comment
begin_function
DECL|function|clear
name|void
name|QSqlResult
operator|::
name|clear
parameter_list|()
block|{
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the query that was actually executed. This may differ from     the query that was passed, for example if bound values were used     with a prepared query and the underlying database doesn't support     prepared queries.      \sa exec(), setQuery() */
end_comment
begin_function
DECL|function|executedQuery
name|QString
name|QSqlResult
operator|::
name|executedQuery
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|executedQuery
return|;
block|}
end_function
begin_function
DECL|function|resetBindCount
name|void
name|QSqlResult
operator|::
name|resetBindCount
parameter_list|()
block|{
name|d
operator|->
name|resetBindCount
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the bound value at position \a index in the     current record (row).      \sa boundValue() */
end_comment
begin_function
DECL|function|boundValueName
name|QString
name|QSqlResult
operator|::
name|boundValueName
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|holderAt
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if at least one of the query's bound values is a \c     QSql::Out or a QSql::InOut; otherwise returns false.      \sa bindValueType() */
end_comment
begin_function
DECL|function|hasOutValues
name|bool
name|QSqlResult
operator|::
name|hasOutValues
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|types
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QHash
argument_list|<
name|int
argument_list|,
name|QSql
operator|::
name|ParamType
argument_list|>
operator|::
name|ConstIterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|d
operator|->
name|types
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|d
operator|->
name|types
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|!=
name|QSql
operator|::
name|In
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current record if the query is active; otherwise     returns an empty QSqlRecord.      The default implementation always returns an empty QSqlRecord.      \sa isActive() */
end_comment
begin_function
DECL|function|record
name|QSqlRecord
name|QSqlResult
operator|::
name|record
parameter_list|()
specifier|const
block|{
return|return
name|QSqlRecord
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the object ID of the most recent inserted row if the     database supports it.     An invalid QVariant will be returned if the query did not     insert any value or if the database does not report the id back.     If more than one row was touched by the insert, the behavior is     undefined.      Note that for Oracle databases the row's ROWID will be returned,     while for MySQL databases the row's auto-increment field will     be returned.      \sa QSqlDriver::hasFeature() */
end_comment
begin_function
DECL|function|lastInsertId
name|QVariant
name|QSqlResult
operator|::
name|lastInsertId
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|virtual_hook
name|void
name|QSqlResult
operator|::
name|virtual_hook
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*! \internal     \since 4.2      Executes a prepared query in batch mode if the driver supports it,     otherwise emulates a batch execution using bindValue() and exec().     QSqlDriver::hasFeature() can be used to find out whether a driver     supports batch execution.      Batch execution can be faster for large amounts of data since it     reduces network roundtrips.      For batch executions, bound values have to be provided as lists     of variants (QVariantList).      Each list must contain values of the same type. All lists must     contain equal amount of values (rows).      NULL values are passed in as typed QVariants, for example     \c {QVariant(QVariant::Int)} for an integer NULL value.      Example:      \snippet code/src_sql_kernel_qsqlresult.cpp 0      Here, we insert two rows into a SQL table, with each row containing three values.      \sa exec(), QSqlDriver::hasFeature() */
end_comment
begin_function
DECL|function|execBatch
name|bool
name|QSqlResult
operator|::
name|execBatch
parameter_list|(
name|bool
name|arrayBind
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|arrayBind
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QVariant
argument_list|>
name|values
init|=
name|d
operator|->
name|values
decl_stmt|;
if|if
condition|(
name|values
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toList
argument_list|()
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|values
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
name|bindValue
argument_list|(
name|j
argument_list|,
name|values
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|toList
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|QSql
operator|::
name|In
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exec
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|detachFromResultSet
name|void
name|QSqlResult
operator|::
name|detachFromResultSet
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|setNumericalPrecisionPolicy
name|void
name|QSqlResult
operator|::
name|setNumericalPrecisionPolicy
parameter_list|(
name|QSql
operator|::
name|NumericalPrecisionPolicy
name|policy
parameter_list|)
block|{
name|d
operator|->
name|precisionPolicy
operator|=
name|policy
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|numericalPrecisionPolicy
name|QSql
operator|::
name|NumericalPrecisionPolicy
name|QSqlResult
operator|::
name|numericalPrecisionPolicy
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|precisionPolicy
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|nextResult
name|bool
name|QSqlResult
operator|::
name|nextResult
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the low-level database handle for this result set     wrapped in a QVariant or an invalid QVariant if there is no handle.      \warning Use this with uttermost care and only if you know what you're doing.      \warning The handle returned here can become a stale pointer if the result     is modified (for example, if you clear it).      \warning The handle can be NULL if the result was not executed yet.      The handle returned here is database-dependent, you should query the type     name of the variant before accessing it.      This example retrieves the handle for a sqlite result:      \snippet code/src_sql_kernel_qsqlresult.cpp 1      This snippet returns the handle for PostgreSQL or MySQL:      \snippet code/src_sql_kernel_qsqlresult.cpp 2      \sa QSqlDriver::handle() */
end_comment
begin_function
DECL|function|handle
name|QVariant
name|QSqlResult
operator|::
name|handle
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
