begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtSql module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qsqlrelationaltablemodel.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qsqldatabase.h"
end_include
begin_include
include|#
directive|include
file|"qsqldriver.h"
end_include
begin_include
include|#
directive|include
file|"qsqlerror.h"
end_include
begin_include
include|#
directive|include
file|"qsqlfield.h"
end_include
begin_include
include|#
directive|include
file|"qsqlindex.h"
end_include
begin_include
include|#
directive|include
file|"qsqlquery.h"
end_include
begin_include
include|#
directive|include
file|"qsqlrecord.h"
end_include
begin_include
include|#
directive|include
file|"qsqltablemodel_p.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QSqlRelationalTableModelSql
class|class
name|QSqlRelationalTableModelSql
super|:
specifier|public
name|QSqlTableModelSql
block|{
public|public:
DECL|function|relTablePrefix
specifier|inline
specifier|const
specifier|static
name|QString
name|relTablePrefix
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|QString
operator|::
name|number
argument_list|(
name|i
argument_list|)
operator|.
name|prepend
argument_list|(
name|QLatin1String
argument_list|(
literal|"relTblAl_"
argument_list|)
argument_list|)
return|;
block|}
block|}
class|;
end_class
begin_typedef
DECL|typedef|Sql
typedef|typedef
name|QSqlRelationalTableModelSql
name|Sql
typedef|;
end_typedef
begin_comment
comment|/*!     \class QSqlRelation     \inmodule QtSql     \brief The QSqlRelation class stores information about an SQL foreign key.      QSqlRelation is a helper class for QSqlRelationalTableModel. See     QSqlRelationalTableModel::setRelation() and     QSqlRelationalTableModel::relation() for details.      \sa QSqlRelationalTableModel, QSqlRelationalDelegate,         {Relational Table Model Example} */
end_comment
begin_comment
comment|/*!     \fn QSqlRelation::QSqlRelation()      Constructs an invalid QSqlRelation object.      For such an object, the tableName(), indexColumn(), and     displayColumn() functions return an empty string.      \sa isValid() */
end_comment
begin_comment
comment|/*!     \fn QSqlRelation::QSqlRelation(const QString&tableName, const QString&indexColumn,                                    const QString&displayColumn)      Constructs a QSqlRelation object, where \a tableName is the SQL     table name to which a foreign key refers, \a indexColumn is the     foreign key, and \a displayColumn is the field that should be     presented to the user.      \sa tableName(), indexColumn(), displayColumn() */
end_comment
begin_comment
comment|/*!     \fn QString QSqlRelation::tableName() const      Returns the name of the table to which a foreign key refers. */
end_comment
begin_comment
comment|/*!     \fn QString QSqlRelation::indexColumn() const      Returns the index column from table tableName() to which a     foreign key refers. */
end_comment
begin_comment
comment|/*!     \fn QString QSqlRelation::displayColumn() const      Returns the column from table tableName() that should be     presented to the user instead of a foreign key. */
end_comment
begin_comment
comment|/*!     \fn bool QSqlRelation::isValid() const      Returns true if the QSqlRelation object is valid; otherwise     returns false. */
end_comment
begin_class_decl
class_decl|class
name|QRelatedTableModel
class_decl|;
end_class_decl
begin_struct
DECL|struct|QRelation
struct|struct
name|QRelation
block|{
public|public:
DECL|function|QRelation
name|QRelation
parameter_list|()
member_init_list|:
name|model
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_parent
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_dictInitialized
argument_list|(
literal|false
argument_list|)
block|{}
name|void
name|init
parameter_list|(
name|QSqlRelationalTableModel
modifier|*
name|parent
parameter_list|,
specifier|const
name|QSqlRelation
modifier|&
name|relation
parameter_list|)
function_decl|;
name|void
name|populateModel
parameter_list|()
function_decl|;
name|bool
name|isDictionaryInitialized
parameter_list|()
function_decl|;
name|void
name|populateDictionary
parameter_list|()
function_decl|;
name|void
name|clearDictionary
parameter_list|()
function_decl|;
name|void
name|clear
parameter_list|()
function_decl|;
name|bool
name|isValid
parameter_list|()
function_decl|;
DECL|member|rel
name|QSqlRelation
name|rel
decl_stmt|;
DECL|member|model
name|QRelatedTableModel
modifier|*
name|model
decl_stmt|;
DECL|member|dictionary
name|QHash
argument_list|<
name|QString
argument_list|,
name|QVariant
argument_list|>
name|dictionary
decl_stmt|;
comment|//maps keys to display values
private|private:
DECL|member|m_parent
name|QSqlRelationalTableModel
modifier|*
name|m_parent
decl_stmt|;
DECL|member|m_dictInitialized
name|bool
name|m_dictInitialized
decl_stmt|;
block|}
struct|;
end_struct
begin_class
DECL|class|QRelatedTableModel
class|class
name|QRelatedTableModel
super|:
specifier|public
name|QSqlTableModel
block|{
public|public:
name|QRelatedTableModel
parameter_list|(
name|QRelation
modifier|*
name|rel
parameter_list|,
name|QObject
modifier|*
name|parent
init|=
literal|0
parameter_list|,
name|QSqlDatabase
name|db
init|=
name|QSqlDatabase
argument_list|()
parameter_list|)
constructor_decl|;
name|bool
name|select
parameter_list|()
function_decl|;
private|private:
DECL|member|firstSelect
name|bool
name|firstSelect
decl_stmt|;
DECL|member|relation
name|QRelation
modifier|*
name|relation
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*     A QRelation must be initialized before it is considered valid.     Note: population of the model and dictionary are kept separate           from initialization, and are populated on an as needed basis. */
end_comment
begin_function
DECL|function|init
name|void
name|QRelation
operator|::
name|init
parameter_list|(
name|QSqlRelationalTableModel
modifier|*
name|parent
parameter_list|,
specifier|const
name|QSqlRelation
modifier|&
name|relation
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|parent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|m_parent
operator|=
name|parent
expr_stmt|;
name|rel
operator|=
name|relation
expr_stmt|;
block|}
end_function
begin_function
DECL|function|populateModel
name|void
name|QRelation
operator|::
name|populateModel
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return;
name|Q_ASSERT
argument_list|(
name|m_parent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|model
condition|)
block|{
name|model
operator|=
operator|new
name|QRelatedTableModel
argument_list|(
name|this
argument_list|,
name|m_parent
argument_list|,
name|m_parent
operator|->
name|database
argument_list|()
argument_list|)
expr_stmt|;
name|model
operator|->
name|setTable
argument_list|(
name|rel
operator|.
name|tableName
argument_list|()
argument_list|)
expr_stmt|;
name|model
operator|->
name|select
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|isDictionaryInitialized
name|bool
name|QRelation
operator|::
name|isDictionaryInitialized
parameter_list|()
block|{
return|return
name|m_dictInitialized
return|;
block|}
end_function
begin_function
DECL|function|populateDictionary
name|void
name|QRelation
operator|::
name|populateDictionary
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return;
if|if
condition|(
name|model
operator|==
name|NULL
condition|)
name|populateModel
argument_list|()
expr_stmt|;
name|QSqlRecord
name|record
decl_stmt|;
name|QString
name|indexColumn
decl_stmt|;
name|QString
name|displayColumn
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|model
operator|->
name|rowCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|record
operator|=
name|model
operator|->
name|record
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|indexColumn
operator|=
name|rel
operator|.
name|indexColumn
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_parent
operator|->
name|database
argument_list|()
operator|.
name|driver
argument_list|()
operator|->
name|isIdentifierEscaped
argument_list|(
name|indexColumn
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
condition|)
name|indexColumn
operator|=
name|m_parent
operator|->
name|database
argument_list|()
operator|.
name|driver
argument_list|()
operator|->
name|stripDelimiters
argument_list|(
name|indexColumn
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
expr_stmt|;
name|displayColumn
operator|=
name|rel
operator|.
name|displayColumn
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_parent
operator|->
name|database
argument_list|()
operator|.
name|driver
argument_list|()
operator|->
name|isIdentifierEscaped
argument_list|(
name|displayColumn
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
condition|)
name|displayColumn
operator|=
name|m_parent
operator|->
name|database
argument_list|()
operator|.
name|driver
argument_list|()
operator|->
name|stripDelimiters
argument_list|(
name|displayColumn
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
expr_stmt|;
name|dictionary
index|[
name|record
operator|.
name|field
argument_list|(
name|indexColumn
argument_list|)
operator|.
name|value
argument_list|()
operator|.
name|toString
argument_list|()
index|]
operator|=
name|record
operator|.
name|field
argument_list|(
name|displayColumn
argument_list|)
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
name|m_dictInitialized
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clearDictionary
name|void
name|QRelation
operator|::
name|clearDictionary
parameter_list|()
block|{
name|dictionary
operator|.
name|clear
argument_list|()
expr_stmt|;
name|m_dictInitialized
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clear
name|void
name|QRelation
operator|::
name|clear
parameter_list|()
block|{
operator|delete
name|model
expr_stmt|;
name|model
operator|=
literal|0
expr_stmt|;
name|clearDictionary
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isValid
name|bool
name|QRelation
operator|::
name|isValid
parameter_list|()
block|{
return|return
operator|(
name|rel
operator|.
name|isValid
argument_list|()
operator|&&
name|m_parent
operator|!=
name|NULL
operator|)
return|;
block|}
end_function
begin_constructor
DECL|function|QRelatedTableModel
name|QRelatedTableModel
operator|::
name|QRelatedTableModel
parameter_list|(
name|QRelation
modifier|*
name|rel
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|,
name|QSqlDatabase
name|db
parameter_list|)
member_init_list|:
name|QSqlTableModel
argument_list|(
name|parent
argument_list|,
name|db
argument_list|)
member_init_list|,
name|firstSelect
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|relation
argument_list|(
name|rel
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|select
name|bool
name|QRelatedTableModel
operator|::
name|select
parameter_list|()
block|{
if|if
condition|(
name|firstSelect
condition|)
block|{
name|firstSelect
operator|=
literal|false
expr_stmt|;
return|return
name|QSqlTableModel
operator|::
name|select
argument_list|()
return|;
block|}
name|relation
operator|->
name|clearDictionary
argument_list|()
expr_stmt|;
name|bool
name|res
init|=
name|QSqlTableModel
operator|::
name|select
argument_list|()
decl_stmt|;
if|if
condition|(
name|res
condition|)
name|relation
operator|->
name|populateDictionary
argument_list|()
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_class
DECL|class|QSqlRelationalTableModelPrivate
class|class
name|QSqlRelationalTableModelPrivate
super|:
specifier|public
name|QSqlTableModelPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QSqlRelationalTableModel
parameter_list|)
specifier|public
private|:
DECL|function|QSqlRelationalTableModelPrivate
name|QSqlRelationalTableModelPrivate
parameter_list|()
member_init_list|:
name|QSqlTableModelPrivate
argument_list|()
member_init_list|,
name|joinMode
argument_list|(
name|QSqlRelationalTableModel
operator|::
name|InnerJoin
argument_list|)
block|{}
name|QString
name|fullyQualifiedFieldName
parameter_list|(
specifier|const
name|QString
modifier|&
name|tableName
parameter_list|,
specifier|const
name|QString
modifier|&
name|fieldName
parameter_list|)
specifier|const
function_decl|;
name|int
name|nameToIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
function_decl|;
DECL|member|relations
specifier|mutable
name|QVector
argument_list|<
name|QRelation
argument_list|>
name|relations
decl_stmt|;
DECL|member|baseRec
name|QSqlRecord
name|baseRec
decl_stmt|;
comment|// the record without relations
name|void
name|clearChanges
parameter_list|()
function_decl|;
name|void
name|clearCache
parameter_list|()
function_decl|;
name|void
name|revertCachedRow
parameter_list|(
name|int
name|row
parameter_list|)
function_decl|;
name|void
name|translateFieldNames
parameter_list|(
name|QSqlRecord
modifier|&
name|values
parameter_list|)
specifier|const
function_decl|;
DECL|member|joinMode
name|QSqlRelationalTableModel
operator|::
name|JoinMode
name|joinMode
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|clearChanges
name|void
name|QSqlRelationalTableModelPrivate
operator|::
name|clearChanges
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|relations
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QRelation
modifier|&
name|rel
init|=
name|relations
index|[
name|i
index|]
decl_stmt|;
name|rel
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|revertCachedRow
name|void
name|QSqlRelationalTableModelPrivate
operator|::
name|revertCachedRow
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|QSqlTableModelPrivate
operator|::
name|revertCachedRow
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|nameToIndex
name|int
name|QSqlRelationalTableModelPrivate
operator|::
name|nameToIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
specifier|const
name|QString
name|fieldname
init|=
name|strippedFieldName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|idx
init|=
name|baseRec
operator|.
name|indexOf
argument_list|(
name|fieldname
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
comment|// If the name is an alias we can find it here.
name|idx
operator|=
name|QSqlTableModelPrivate
operator|::
name|nameToIndex
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|idx
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|clearCache
name|void
name|QSqlRelationalTableModelPrivate
operator|::
name|clearCache
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|relations
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|relations
index|[
name|i
index|]
operator|.
name|clearDictionary
argument_list|()
expr_stmt|;
name|QSqlTableModelPrivate
operator|::
name|clearCache
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QSqlRelationalTableModel     \brief The QSqlRelationalTableModel class provides an editable     data model for a single database table, with foreign key support.      \ingroup database     \inmodule QtSql      QSqlRelationalTableModel acts like QSqlTableModel, but allows     columns to be set as foreign keys into other database tables.      \table     \row \li \inlineimage noforeignkeys.png          \li \inlineimage foreignkeys.png     \endtable      The screenshot on the left shows a plain QSqlTableModel in a     QTableView. Foreign keys (\c city and \c country) aren't resolved     to human-readable values. The screenshot on the right shows a     QSqlRelationalTableModel, with foreign keys resolved into     human-readable text strings.      The following code snippet shows how the QSqlRelationalTableModel     was set up:      \snippet relationaltablemodel/relationaltablemodel.cpp 0     \codeline     \snippet relationaltablemodel/relationaltablemodel.cpp 1     \snippet relationaltablemodel/relationaltablemodel.cpp 2      The setRelation() function calls establish a relationship between     two tables. The first call specifies that column 2 in table \c     employee is a foreign key that maps with field \c id of table \c     city, and that the view should present the \c{city}'s \c name     field to the user. The second call does something similar with     column 3.      If you use a read-write QSqlRelationalTableModel, you probably     want to use QSqlRelationalDelegate on the view. Unlike the default     delegate, QSqlRelationalDelegate provides a combobox for fields     that are foreign keys into other tables. To use the class, simply     call QAbstractItemView::setItemDelegate() on the view with an     instance of QSqlRelationalDelegate:      \snippet relationaltablemodel/relationaltablemodel.cpp 4      The \l{relationaltablemodel} example illustrates how to use     QSqlRelationalTableModel in conjunction with     QSqlRelationalDelegate to provide tables with foreign key     support.      \image relationaltable.png      Notes:      \list     \li The table must have a primary key declared.     \li The table's primary key may not contain a relation to        another table.     \li If a relational table contains keys that refer to non-existent        rows in the referenced table, the rows containing the invalid        keys will not be exposed through the model. The user or the        database is responsible for keeping referential integrity.     \li If a relation's display column name is also used as a column        name in the relational table, or if it is used as display column        name in more than one relation it will be aliased. The alias is        the relation's table name, display column name and a unique id        joined by an underscore (e.g. tablename_columnname_id).        QSqlRecord::fieldName() will return the aliased column name.        All occurrences of the duplicate display column name are aliased when        duplication is detected, but no aliasing is done to the column        names in the main table. The aliasing doesn't affect        QSqlRelation, so QSqlRelation::displayColumn() will return the        original display column name.     \li The reference table name is aliased. The alias is the word "relTblAl"        and the relationed column index joined by an underscore        (e.g. relTblAl_2). The alias can be used to filter the table        (For example, setFilter("relTblAl_2='Oslo' OR        relTblAl_3='USA'")).     \li When using setData() the role should always be Qt::EditRole,        and when using data() the role should always be Qt::DisplayRole.     \endlist      \sa QSqlRelation, QSqlRelationalDelegate,         {Relational Table Model Example} */
end_comment
begin_comment
comment|/*!     Creates an empty QSqlRelationalTableModel and sets the parent to \a parent     and the database connection to \a db. If \a db is not valid, the     default database connection will be used. */
end_comment
begin_constructor
DECL|function|QSqlRelationalTableModel
name|QSqlRelationalTableModel
operator|::
name|QSqlRelationalTableModel
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|,
name|QSqlDatabase
name|db
parameter_list|)
member_init_list|:
name|QSqlTableModel
argument_list|(
operator|*
operator|new
name|QSqlRelationalTableModelPrivate
argument_list|,
name|parent
argument_list|,
name|db
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the object and frees any allocated resources. */
end_comment
begin_destructor
DECL|function|~QSqlRelationalTableModel
name|QSqlRelationalTableModel
operator|::
name|~
name|QSqlRelationalTableModel
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|data
name|QVariant
name|QSqlRelationalTableModel
operator|::
name|data
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|int
name|role
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlRelationalTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|role
operator|==
name|Qt
operator|::
name|DisplayRole
operator|&&
name|index
operator|.
name|column
argument_list|()
operator|>=
literal|0
operator|&&
name|index
operator|.
name|column
argument_list|()
operator|<
name|d
operator|->
name|relations
operator|.
name|count
argument_list|()
operator|&&
name|d
operator|->
name|relations
operator|.
name|value
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QRelation
modifier|&
name|relation
init|=
name|d
operator|->
name|relations
index|[
name|index
operator|.
name|column
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|relation
operator|.
name|isDictionaryInitialized
argument_list|()
condition|)
name|relation
operator|.
name|populateDictionary
argument_list|()
expr_stmt|;
comment|//only perform a dictionary lookup for the display value
comment|//when the value at index has been changed or added.
comment|//At an unmodified index, the underlying model will
comment|//already have the correct display value.
if|if
condition|(
name|d
operator|->
name|strategy
operator|!=
name|OnFieldChange
condition|)
block|{
specifier|const
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
name|row
init|=
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|.
name|op
argument_list|()
operator|!=
name|QSqlTableModelPrivate
operator|::
name|None
operator|&&
name|row
operator|.
name|rec
argument_list|()
operator|.
name|isGenerated
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnManualSubmit
operator|||
name|row
operator|.
name|op
argument_list|()
operator|!=
name|QSqlTableModelPrivate
operator|::
name|Delete
condition|)
block|{
name|QVariant
name|v
init|=
name|row
operator|.
name|rec
argument_list|()
operator|.
name|value
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|relation
operator|.
name|dictionary
index|[
name|v
operator|.
name|toString
argument_list|()
index|]
return|;
block|}
block|}
block|}
block|}
return|return
name|QSqlTableModel
operator|::
name|data
argument_list|(
name|index
argument_list|,
name|role
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the data for the \a role in the item with the specified \a     index to the \a value given. Depending on the edit strategy, the     value might be applied to the database at once, or it may be     cached in the model.      Returns true if the value could be set, or false on error (for     example, if \a index is out of bounds).      For relational columns, \a value must be the index, not the     display value. The index must also exist in the referenced     table, otherwise the function returns false.      \sa editStrategy(), data(), submit(), revertRow() */
end_comment
begin_function
DECL|function|setData
name|bool
name|QSqlRelationalTableModel
operator|::
name|setData
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|,
name|int
name|role
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlRelationalTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|role
operator|==
name|Qt
operator|::
name|EditRole
operator|&&
name|index
operator|.
name|column
argument_list|()
operator|>
literal|0
operator|&&
name|index
operator|.
name|column
argument_list|()
operator|<
name|d
operator|->
name|relations
operator|.
name|count
argument_list|()
operator|&&
name|d
operator|->
name|relations
operator|.
name|value
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QRelation
modifier|&
name|relation
init|=
name|d
operator|->
name|relations
index|[
name|index
operator|.
name|column
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|relation
operator|.
name|isDictionaryInitialized
argument_list|()
condition|)
name|relation
operator|.
name|populateDictionary
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|relation
operator|.
name|dictionary
operator|.
name|contains
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
name|QSqlTableModel
operator|::
name|setData
argument_list|(
name|index
argument_list|,
name|value
argument_list|,
name|role
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Lets the specified \a column be a foreign index specified by \a relation.      Example:      \snippet relationaltablemodel/relationaltablemodel.cpp 0     \codeline     \snippet relationaltablemodel/relationaltablemodel.cpp 1      The setRelation() call specifies that column 2 in table \c     employee is a foreign key that maps with field \c id of table \c     city, and that the view should present the \c{city}'s \c name     field to the user.      Note: The table's primary key may not contain a relation to another table.      \sa relation() */
end_comment
begin_function
DECL|function|setRelation
name|void
name|QSqlRelationalTableModel
operator|::
name|setRelation
parameter_list|(
name|int
name|column
parameter_list|,
specifier|const
name|QSqlRelation
modifier|&
name|relation
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlRelationalTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|column
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|relations
operator|.
name|size
argument_list|()
operator|<=
name|column
condition|)
name|d
operator|->
name|relations
operator|.
name|resize
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|relations
index|[
name|column
index|]
operator|.
name|init
argument_list|(
name|this
argument_list|,
name|relation
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the relation for the column \a column, or an invalid     relation if no relation is set.      \sa setRelation(), QSqlRelation::isValid() */
end_comment
begin_function
DECL|function|relation
name|QSqlRelation
name|QSqlRelationalTableModel
operator|::
name|relation
parameter_list|(
name|int
name|column
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlRelationalTableModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|relations
operator|.
name|value
argument_list|(
name|column
argument_list|)
operator|.
name|rel
return|;
block|}
end_function
begin_function
DECL|function|fullyQualifiedFieldName
name|QString
name|QSqlRelationalTableModelPrivate
operator|::
name|fullyQualifiedFieldName
parameter_list|(
specifier|const
name|QString
modifier|&
name|tableName
parameter_list|,
specifier|const
name|QString
modifier|&
name|fieldName
parameter_list|)
specifier|const
block|{
name|QString
name|ret
decl_stmt|;
name|ret
operator|.
name|reserve
argument_list|(
name|tableName
operator|.
name|size
argument_list|()
operator|+
name|fieldName
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|tableName
argument_list|)
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|selectStatement
name|QString
name|QSqlRelationalTableModel
operator|::
name|selectStatement
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlRelationalTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|tableName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|relations
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QSqlTableModel
operator|::
name|selectStatement
argument_list|()
return|;
comment|// Count how many times each field name occurs in the record
name|QHash
argument_list|<
name|QString
argument_list|,
name|int
argument_list|>
name|fieldNames
decl_stmt|;
name|QStringList
name|fieldList
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|baseRec
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSqlRelation
name|relation
init|=
name|d
operator|->
name|relations
operator|.
name|value
argument_list|(
name|i
argument_list|)
operator|.
name|rel
decl_stmt|;
name|QString
name|name
decl_stmt|;
if|if
condition|(
name|relation
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// Count the display column name, not the original foreign key
name|name
operator|=
name|relation
operator|.
name|displayColumn
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|isIdentifierEscaped
argument_list|(
name|name
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
condition|)
name|name
operator|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|stripDelimiters
argument_list|(
name|name
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
expr_stmt|;
specifier|const
name|QSqlRecord
name|rec
init|=
name|database
argument_list|()
operator|.
name|record
argument_list|(
name|relation
operator|.
name|tableName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rec
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|name
operator|.
name|compare
argument_list|(
name|rec
operator|.
name|fieldName
argument_list|(
name|i
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
condition|)
block|{
name|name
operator|=
name|rec
operator|.
name|fieldName
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|name
operator|=
name|d
operator|->
name|baseRec
operator|.
name|fieldName
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|fieldNames
index|[
name|name
index|]
operator|=
name|fieldNames
operator|.
name|value
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fieldList
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|QString
name|fList
decl_stmt|;
name|QString
name|conditions
decl_stmt|;
name|QString
name|from
init|=
name|Sql
operator|::
name|from
argument_list|(
name|tableName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|baseRec
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSqlRelation
name|relation
init|=
name|d
operator|->
name|relations
operator|.
name|value
argument_list|(
name|i
argument_list|)
operator|.
name|rel
decl_stmt|;
specifier|const
name|QString
name|tableField
init|=
name|d
operator|->
name|fullyQualifiedFieldName
argument_list|(
name|tableName
argument_list|()
argument_list|,
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|escapeIdentifier
argument_list|(
name|d
operator|->
name|baseRec
operator|.
name|fieldName
argument_list|(
name|i
argument_list|)
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|relation
operator|.
name|isValid
argument_list|()
condition|)
block|{
specifier|const
name|QString
name|relTableAlias
init|=
name|Sql
operator|::
name|relTablePrefix
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QString
name|displayTableField
init|=
name|d
operator|->
name|fullyQualifiedFieldName
argument_list|(
name|relTableAlias
argument_list|,
name|relation
operator|.
name|displayColumn
argument_list|()
argument_list|)
decl_stmt|;
comment|// Duplicate field names must be aliased
if|if
condition|(
name|fieldNames
operator|.
name|value
argument_list|(
name|fieldList
index|[
name|i
index|]
argument_list|)
operator|>
literal|1
condition|)
block|{
name|QString
name|relTableName
init|=
name|relation
operator|.
name|tableName
argument_list|()
operator|.
name|section
argument_list|(
name|QChar
operator|::
name|fromLatin1
argument_list|(
literal|'.'
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|isIdentifierEscaped
argument_list|(
name|relTableName
argument_list|,
name|QSqlDriver
operator|::
name|TableName
argument_list|)
condition|)
name|relTableName
operator|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|stripDelimiters
argument_list|(
name|relTableName
argument_list|,
name|QSqlDriver
operator|::
name|TableName
argument_list|)
expr_stmt|;
name|QString
name|displayColumn
init|=
name|relation
operator|.
name|displayColumn
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|isIdentifierEscaped
argument_list|(
name|displayColumn
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
condition|)
name|displayColumn
operator|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|stripDelimiters
argument_list|(
name|displayColumn
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
expr_stmt|;
specifier|const
name|QString
name|alias
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1_%2_%3"
argument_list|)
operator|.
name|arg
argument_list|(
name|relTableName
argument_list|)
operator|.
name|arg
argument_list|(
name|displayColumn
argument_list|)
operator|.
name|arg
argument_list|(
name|fieldNames
operator|.
name|value
argument_list|(
name|fieldList
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|displayTableField
operator|=
name|Sql
operator|::
name|as
argument_list|(
name|displayTableField
argument_list|,
name|alias
argument_list|)
expr_stmt|;
operator|--
name|fieldNames
index|[
name|fieldList
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
name|fList
operator|=
name|Sql
operator|::
name|comma
argument_list|(
name|fList
argument_list|,
name|displayTableField
argument_list|)
expr_stmt|;
comment|// Join related table
specifier|const
name|QString
name|tblexpr
init|=
name|Sql
operator|::
name|concat
argument_list|(
name|relation
operator|.
name|tableName
argument_list|()
argument_list|,
name|relTableAlias
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|relTableField
init|=
name|d
operator|->
name|fullyQualifiedFieldName
argument_list|(
name|relTableAlias
argument_list|,
name|relation
operator|.
name|indexColumn
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|cond
init|=
name|Sql
operator|::
name|eq
argument_list|(
name|tableField
argument_list|,
name|relTableField
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|joinMode
operator|==
name|QSqlRelationalTableModel
operator|::
name|InnerJoin
condition|)
block|{
comment|// FIXME: InnerJoin code is known to be broken.
comment|// Use LeftJoin mode if you want correct behavior.
name|from
operator|=
name|Sql
operator|::
name|comma
argument_list|(
name|from
argument_list|,
name|tblexpr
argument_list|)
expr_stmt|;
name|conditions
operator|=
name|Sql
operator|::
name|et
argument_list|(
name|conditions
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|from
operator|=
name|Sql
operator|::
name|concat
argument_list|(
name|from
argument_list|,
name|Sql
operator|::
name|leftJoin
argument_list|(
name|tblexpr
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|Sql
operator|::
name|concat
argument_list|(
name|from
argument_list|,
name|Sql
operator|::
name|on
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fList
operator|=
name|Sql
operator|::
name|comma
argument_list|(
name|fList
argument_list|,
name|tableField
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fList
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
specifier|const
name|QString
name|stmt
init|=
name|Sql
operator|::
name|concat
argument_list|(
name|Sql
operator|::
name|select
argument_list|(
name|fList
argument_list|)
argument_list|,
name|from
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|where
init|=
name|Sql
operator|::
name|where
argument_list|(
name|Sql
operator|::
name|et
argument_list|(
name|Sql
operator|::
name|paren
argument_list|(
name|conditions
argument_list|)
argument_list|,
name|Sql
operator|::
name|paren
argument_list|(
name|filter
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|Sql
operator|::
name|concat
argument_list|(
name|Sql
operator|::
name|concat
argument_list|(
name|stmt
argument_list|,
name|where
argument_list|)
argument_list|,
name|orderByClause
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QSqlTableModel object for accessing the table for which     \a column is a foreign key, or 0 if there is no relation for the     given \a column.      The returned object is owned by the QSqlRelationalTableModel.      \sa setRelation(), relation() */
end_comment
begin_function
DECL|function|relationModel
name|QSqlTableModel
modifier|*
name|QSqlRelationalTableModel
operator|::
name|relationModel
parameter_list|(
name|int
name|column
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlRelationalTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|column
operator|<
literal|0
operator|||
name|column
operator|>=
name|d
operator|->
name|relations
operator|.
name|count
argument_list|()
condition|)
return|return
literal|0
return|;
name|QRelation
modifier|&
name|relation
init|=
cast|const_cast
argument_list|<
name|QSqlRelationalTableModelPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|relations
index|[
name|column
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|relation
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|relation
operator|.
name|model
condition|)
name|relation
operator|.
name|populateModel
argument_list|()
expr_stmt|;
return|return
name|relation
operator|.
name|model
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|revertRow
name|void
name|QSqlRelationalTableModel
operator|::
name|revertRow
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|QSqlTableModel
operator|::
name|revertRow
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|clear
name|void
name|QSqlRelationalTableModel
operator|::
name|clear
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSqlRelationalTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|clearChanges
argument_list|()
expr_stmt|;
name|d
operator|->
name|relations
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QSqlTableModel
operator|::
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \enum QSqlRelationalTableModel::JoinMode      \value InnerJoin - Inner join mode, return rows when there is at least one match in both tables.     \value LeftJoin - Left join mode, returns all rows from the left table (table_name1), even if there are no matches in the right table (table_name2).      \sa QSqlRelationalTableModel::setJoinMode     \since 4.8 */
end_comment
begin_comment
comment|/*!     Sets the SQL \a joinMode to show or hide rows with NULL foreign keys.     In InnerJoin mode (the default) these rows will not be shown: use the     LeftJoin mode if you want to show them.      \sa QSqlRelationalTableModel::JoinMode     \since 4.8 */
end_comment
begin_function
DECL|function|setJoinMode
name|void
name|QSqlRelationalTableModel
operator|::
name|setJoinMode
parameter_list|(
name|QSqlRelationalTableModel
operator|::
name|JoinMode
name|joinMode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlRelationalTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|joinMode
operator|=
name|joinMode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|select
name|bool
name|QSqlRelationalTableModel
operator|::
name|select
parameter_list|()
block|{
return|return
name|QSqlTableModel
operator|::
name|select
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|setTable
name|void
name|QSqlRelationalTableModel
operator|::
name|setTable
parameter_list|(
specifier|const
name|QString
modifier|&
name|table
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlRelationalTableModel
argument_list|)
expr_stmt|;
comment|// memorize the table before applying the relations
name|d
operator|->
name|baseRec
operator|=
name|d
operator|->
name|db
operator|.
name|record
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|QSqlTableModel
operator|::
name|setTable
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|translateFieldNames
name|void
name|QSqlRelationalTableModelPrivate
operator|::
name|translateFieldNames
parameter_list|(
name|QSqlRecord
modifier|&
name|values
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|relations
operator|.
name|value
argument_list|(
name|i
argument_list|)
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QVariant
name|v
init|=
name|values
operator|.
name|value
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|bool
name|gen
init|=
name|values
operator|.
name|isGenerated
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|values
operator|.
name|replace
argument_list|(
name|i
argument_list|,
name|baseRec
operator|.
name|field
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|setValue
argument_list|(
name|i
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|values
operator|.
name|setGenerated
argument_list|(
name|i
argument_list|,
name|gen
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|updateRowInTable
name|bool
name|QSqlRelationalTableModel
operator|::
name|updateRowInTable
parameter_list|(
name|int
name|row
parameter_list|,
specifier|const
name|QSqlRecord
modifier|&
name|values
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlRelationalTableModel
argument_list|)
expr_stmt|;
name|QSqlRecord
name|rec
init|=
name|values
decl_stmt|;
name|d
operator|->
name|translateFieldNames
argument_list|(
name|rec
argument_list|)
expr_stmt|;
return|return
name|QSqlTableModel
operator|::
name|updateRowInTable
argument_list|(
name|row
argument_list|,
name|rec
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|insertRowIntoTable
name|bool
name|QSqlRelationalTableModel
operator|::
name|insertRowIntoTable
parameter_list|(
specifier|const
name|QSqlRecord
modifier|&
name|values
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlRelationalTableModel
argument_list|)
expr_stmt|;
name|QSqlRecord
name|rec
init|=
name|values
decl_stmt|;
name|d
operator|->
name|translateFieldNames
argument_list|(
name|rec
argument_list|)
expr_stmt|;
return|return
name|QSqlTableModel
operator|::
name|insertRowIntoTable
argument_list|(
name|rec
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|orderByClause
name|QString
name|QSqlRelationalTableModel
operator|::
name|orderByClause
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlRelationalTableModel
argument_list|)
expr_stmt|;
specifier|const
name|QSqlRelation
name|rel
init|=
name|d
operator|->
name|relations
operator|.
name|value
argument_list|(
name|d
operator|->
name|sortColumn
argument_list|)
operator|.
name|rel
decl_stmt|;
if|if
condition|(
operator|!
name|rel
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QSqlTableModel
operator|::
name|orderByClause
argument_list|()
return|;
name|QString
name|f
init|=
name|d
operator|->
name|fullyQualifiedFieldName
argument_list|(
name|Sql
operator|::
name|relTablePrefix
argument_list|(
name|d
operator|->
name|sortColumn
argument_list|)
argument_list|,
name|rel
operator|.
name|displayColumn
argument_list|()
argument_list|)
decl_stmt|;
name|f
operator|=
name|d
operator|->
name|sortOrder
operator|==
name|Qt
operator|::
name|AscendingOrder
condition|?
name|Sql
operator|::
name|asc
argument_list|(
name|f
argument_list|)
else|:
name|Sql
operator|::
name|desc
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|Sql
operator|::
name|orderBy
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|removeColumns
name|bool
name|QSqlRelationalTableModel
operator|::
name|removeColumns
parameter_list|(
name|int
name|column
parameter_list|,
name|int
name|count
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlRelationalTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
operator|||
name|column
argument_list|<
literal|0
operator|||
name|column
operator|+
name|count
argument_list|>
name|d
operator|->
name|rec
operator|.
name|count
argument_list|()
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|->
name|baseRec
operator|.
name|remove
argument_list|(
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|relations
operator|.
name|count
argument_list|()
operator|>
name|column
condition|)
name|d
operator|->
name|relations
operator|.
name|remove
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
return|return
name|QSqlTableModel
operator|::
name|removeColumns
argument_list|(
name|column
argument_list|,
name|count
argument_list|,
name|parent
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
