begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtSql module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qsqltablemodel.h"
end_include
begin_include
include|#
directive|include
file|"qsqldriver.h"
end_include
begin_include
include|#
directive|include
file|"qsqlerror.h"
end_include
begin_include
include|#
directive|include
file|"qsqlfield.h"
end_include
begin_include
include|#
directive|include
file|"qsqlindex.h"
end_include
begin_include
include|#
directive|include
file|"qsqlquery.h"
end_include
begin_include
include|#
directive|include
file|"qsqlrecord.h"
end_include
begin_include
include|#
directive|include
file|"qsqlresult.h"
end_include
begin_include
include|#
directive|include
file|"qsqltablemodel_p.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_typedef
DECL|typedef|Sql
typedef|typedef
name|QSqlTableModelSql
name|Sql
typedef|;
end_typedef
begin_comment
comment|/*! \internal     Populates our record with values. */
end_comment
begin_function
DECL|function|record
name|QSqlRecord
name|QSqlTableModelPrivate
operator|::
name|record
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|values
parameter_list|)
specifier|const
block|{
name|QSqlRecord
name|r
init|=
name|rec
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|r
operator|.
name|count
argument_list|()
operator|&&
name|i
operator|<
name|values
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|r
operator|.
name|setValue
argument_list|(
name|i
argument_list|,
name|values
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|nameToIndex
name|int
name|QSqlTableModelPrivate
operator|::
name|nameToIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|rec
operator|.
name|indexOf
argument_list|(
name|strippedFieldName
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|strippedFieldName
name|QString
name|QSqlTableModelPrivate
operator|::
name|strippedFieldName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|QString
name|fieldname
init|=
name|name
decl_stmt|;
if|if
condition|(
name|db
operator|.
name|driver
argument_list|()
operator|->
name|isIdentifierEscaped
argument_list|(
name|fieldname
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
condition|)
name|fieldname
operator|=
name|db
operator|.
name|driver
argument_list|()
operator|->
name|stripDelimiters
argument_list|(
name|fieldname
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
expr_stmt|;
return|return
name|fieldname
return|;
block|}
end_function
begin_function
DECL|function|insertCount
name|int
name|QSqlTableModelPrivate
operator|::
name|insertCount
parameter_list|(
name|int
name|maxRow
parameter_list|)
specifier|const
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|CacheMap
operator|::
name|ConstIterator
name|i
init|=
name|cache
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|CacheMap
operator|::
name|ConstIterator
name|e
init|=
name|cache
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|i
operator|!=
name|e
operator|&&
operator|(
name|maxRow
operator|<
literal|0
operator|||
name|i
operator|.
name|key
argument_list|()
operator|<=
name|maxRow
operator|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|()
condition|)
operator|++
name|cnt
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function
begin_function
DECL|function|initRecordAndPrimaryIndex
name|void
name|QSqlTableModelPrivate
operator|::
name|initRecordAndPrimaryIndex
parameter_list|()
block|{
name|rec
operator|=
name|db
operator|.
name|record
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|primaryIndex
operator|=
name|db
operator|.
name|primaryIndex
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|initColOffsets
argument_list|(
name|rec
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clear
name|void
name|QSqlTableModelPrivate
operator|::
name|clear
parameter_list|()
block|{
name|sortColumn
operator|=
operator|-
literal|1
expr_stmt|;
name|sortOrder
operator|=
name|Qt
operator|::
name|AscendingOrder
expr_stmt|;
name|tableName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|editQuery
operator|.
name|clear
argument_list|()
expr_stmt|;
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|primaryIndex
operator|.
name|clear
argument_list|()
expr_stmt|;
name|rec
operator|.
name|clear
argument_list|()
expr_stmt|;
name|filter
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clearCache
name|void
name|QSqlTableModelPrivate
operator|::
name|clearCache
parameter_list|()
block|{
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|revertCachedRow
name|void
name|QSqlTableModelPrivate
operator|::
name|revertCachedRow
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|ModifiedRow
name|r
init|=
name|cache
operator|.
name|value
argument_list|(
name|row
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|r
operator|.
name|op
argument_list|()
condition|)
block|{
case|case
name|QSqlTableModelPrivate
operator|::
name|None
case|:
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QSqlTableModelPrivate::revertCachedRow()"
argument_list|,
literal|"Invalid entry in cache map"
argument_list|)
expr_stmt|;
return|return;
case|case
name|QSqlTableModelPrivate
operator|::
name|Update
case|:
case|case
name|QSqlTableModelPrivate
operator|::
name|Delete
case|:
if|if
condition|(
operator|!
name|r
operator|.
name|submitted
argument_list|()
condition|)
block|{
name|cache
index|[
name|row
index|]
operator|.
name|revert
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|dataChanged
argument_list|(
name|q
operator|->
name|createIndex
argument_list|(
name|row
argument_list|,
literal|0
argument_list|)
argument_list|,
name|q
operator|->
name|createIndex
argument_list|(
name|row
argument_list|,
name|q
operator|->
name|columnCount
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
emit|;
block|}
break|break;
case|case
name|QSqlTableModelPrivate
operator|::
name|Insert
case|:
block|{
name|QMap
argument_list|<
name|int
argument_list|,
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|cache
operator|.
name|find
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|cache
operator|.
name|end
argument_list|()
condition|)
return|return;
name|q
operator|->
name|beginRemoveRows
argument_list|(
name|QModelIndex
argument_list|()
argument_list|,
name|row
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|it
operator|=
name|cache
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
while|while
condition|(
name|it
operator|!=
name|cache
operator|.
name|end
argument_list|()
condition|)
block|{
name|int
name|oldKey
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
specifier|const
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
name|oldValue
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|cache
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|it
operator|=
name|cache
operator|.
name|insert
argument_list|(
name|oldKey
operator|-
literal|1
argument_list|,
name|oldValue
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
name|q
operator|->
name|endRemoveRows
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_function
DECL|function|exec
name|bool
name|QSqlTableModelPrivate
operator|::
name|exec
parameter_list|(
specifier|const
name|QString
modifier|&
name|stmt
parameter_list|,
name|bool
name|prepStatement
parameter_list|,
specifier|const
name|QSqlRecord
modifier|&
name|rec
parameter_list|,
specifier|const
name|QSqlRecord
modifier|&
name|whereValues
parameter_list|)
block|{
if|if
condition|(
name|stmt
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// lazy initialization of editQuery
if|if
condition|(
name|editQuery
operator|.
name|driver
argument_list|()
operator|!=
name|db
operator|.
name|driver
argument_list|()
condition|)
name|editQuery
operator|=
name|QSqlQuery
argument_list|(
name|db
argument_list|)
expr_stmt|;
comment|// workaround for In-Process databases - remove all read locks
comment|// from the table to make sure the editQuery succeeds
if|if
condition|(
name|db
operator|.
name|driver
argument_list|()
operator|->
name|hasFeature
argument_list|(
name|QSqlDriver
operator|::
name|SimpleLocking
argument_list|)
condition|)
cast|const_cast
argument_list|<
name|QSqlResult
operator|*
argument_list|>
argument_list|(
name|query
operator|.
name|result
argument_list|()
argument_list|)
operator|->
name|detachFromResultSet
argument_list|()
expr_stmt|;
if|if
condition|(
name|prepStatement
condition|)
block|{
if|if
condition|(
name|editQuery
operator|.
name|lastQuery
argument_list|()
operator|!=
name|stmt
condition|)
block|{
if|if
condition|(
operator|!
name|editQuery
operator|.
name|prepare
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|error
operator|=
name|editQuery
operator|.
name|lastError
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rec
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|rec
operator|.
name|isGenerated
argument_list|(
name|i
argument_list|)
condition|)
name|editQuery
operator|.
name|addBindValue
argument_list|(
name|rec
operator|.
name|value
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|whereValues
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|whereValues
operator|.
name|isGenerated
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|whereValues
operator|.
name|isNull
argument_list|(
name|i
argument_list|)
condition|)
name|editQuery
operator|.
name|addBindValue
argument_list|(
name|whereValues
operator|.
name|value
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|editQuery
operator|.
name|exec
argument_list|()
condition|)
block|{
name|error
operator|=
name|editQuery
operator|.
name|lastError
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|editQuery
operator|.
name|exec
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|error
operator|=
name|editQuery
operator|.
name|lastError
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \class QSqlTableModel     \brief The QSqlTableModel class provides an editable data model     for a single database table.      \ingroup database     \inmodule QtSql      QSqlTableModel is a high-level interface for reading and writing     database records from a single table. It is built on top of the     lower-level QSqlQuery and can be used to provide data to view     classes such as QTableView. For example:      \snippet sqldatabase/sqldatabase.cpp 24      We set the SQL table's name and the edit strategy, then we set up     the labels displayed in the view header. The edit strategy     dictates when the changes done by the user in the view are     actually applied to the database. The possible values are \l     OnFieldChange, \l OnRowChange, and \l OnManualSubmit.      QSqlTableModel can also be used to access a database     programmatically, without binding it to a view:      \snippet sqldatabase/sqldatabase.cpp 21      The code snippet above extracts the \c salary field from record 4 in     the result set of the query \c{SELECT * from employee}.      It is possible to set filters using setFilter(), or modify the     sort order using setSort(). At the end, you must call select() to     populate the model with data.      The \l{tablemodel} example illustrates how to use     QSqlTableModel as the data source for a QTableView.      QSqlTableModel provides no direct support for foreign keys. Use     the QSqlRelationalTableModel and QSqlRelationalDelegate if you     want to resolve foreign keys.      \sa QSqlRelationalTableModel, QSqlQuery, {Model/View Programming},         {Table Model Example}, {Cached Table Example} */
end_comment
begin_comment
comment|/*!     \fn QSqlTableModel::beforeDelete(int row)      This signal is emitted by deleteRowFromTable() before the \a row     is deleted from the currently active database table. */
end_comment
begin_comment
comment|/*!     \fn void QSqlTableModel::primeInsert(int row, QSqlRecord&record)      This signal is emitted by insertRows(), when an insertion is     initiated in the given \a row of the currently active database     table. The \a record parameter can be written to (since it is a     reference), for example to populate some fields with default     values and set the generated flags of the fields. Do not try to     edit the record via other means such as setData() or setRecord()     while handling this signal. */
end_comment
begin_comment
comment|/*!     \fn QSqlTableModel::beforeInsert(QSqlRecord&record)      This signal is emitted by insertRowIntoTable() before a new row is     inserted into the currently active database table. The values that     are about to be inserted are stored in \a record and can be     modified before they will be inserted. */
end_comment
begin_comment
comment|/*!     \fn QSqlTableModel::beforeUpdate(int row, QSqlRecord&record)      This signal is emitted by updateRowInTable() before the \a row is     updated in the currently active database table with the values     from \a record.      Note that only values that are marked as generated will be updated.     The generated flag can be set with \l QSqlRecord::setGenerated()     and checked with \l QSqlRecord::isGenerated().      \sa QSqlRecord::isGenerated() */
end_comment
begin_comment
comment|/*!     Creates an empty QSqlTableModel and sets the parent to \a parent     and the database connection to \a db. If \a db is not valid, the     default database connection will be used.      The default edit strategy is \l OnRowChange. */
end_comment
begin_constructor
DECL|function|QSqlTableModel
name|QSqlTableModel
operator|::
name|QSqlTableModel
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|,
name|QSqlDatabase
name|db
parameter_list|)
member_init_list|:
name|QSqlQueryModel
argument_list|(
operator|*
operator|new
name|QSqlTableModelPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|db
operator|=
name|db
operator|.
name|isValid
argument_list|()
condition|?
name|db
else|:
name|QSqlDatabase
operator|::
name|database
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!  \internal */
end_comment
begin_constructor
DECL|function|QSqlTableModel
name|QSqlTableModel
operator|::
name|QSqlTableModel
parameter_list|(
name|QSqlTableModelPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|,
name|QSqlDatabase
name|db
parameter_list|)
member_init_list|:
name|QSqlQueryModel
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|db
operator|=
name|db
operator|.
name|isValid
argument_list|()
condition|?
name|db
else|:
name|QSqlDatabase
operator|::
name|database
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the object and frees any allocated resources. */
end_comment
begin_destructor
DECL|function|~QSqlTableModel
name|QSqlTableModel
operator|::
name|~
name|QSqlTableModel
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Sets the database table on which the model operates to \a     tableName. Does not select data from the table, but fetches its     field information.      To populate the model with the table's data, call select().      Error information can be retrieved with \l lastError().      \sa select(), setFilter(), lastError() */
end_comment
begin_function
DECL|function|setTable
name|void
name|QSqlTableModel
operator|::
name|setTable
parameter_list|(
specifier|const
name|QString
modifier|&
name|tableName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|tableName
operator|=
name|tableName
expr_stmt|;
name|d
operator|->
name|initRecordAndPrimaryIndex
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rec
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
name|d
operator|->
name|error
operator|=
name|QSqlError
argument_list|(
name|QLatin1String
argument_list|(
literal|"Unable to find table "
argument_list|)
operator|+
name|d
operator|->
name|tableName
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|)
expr_stmt|;
comment|// Remember the auto index column if there is one now.
comment|// The record that will be obtained from the query after select lacks this feature.
name|d
operator|->
name|autoColumn
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|d
operator|->
name|rec
operator|.
name|count
argument_list|()
condition|;
operator|++
name|c
control|)
block|{
if|if
condition|(
name|d
operator|->
name|rec
operator|.
name|field
argument_list|(
name|c
argument_list|)
operator|.
name|isAutoValue
argument_list|()
condition|)
block|{
name|d
operator|->
name|autoColumn
operator|=
name|d
operator|->
name|rec
operator|.
name|fieldName
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the name of the currently selected table. */
end_comment
begin_function
DECL|function|tableName
name|QString
name|QSqlTableModel
operator|::
name|tableName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|tableName
return|;
block|}
end_function
begin_comment
comment|/*!     Populates the model with data from the table that was set via setTable(), using the     specified filter and sort condition, and returns \c true if successful; otherwise     returns \c false.      \note Calling select() will revert any unsubmitted changes and remove any inserted columns.      \sa setTable(), setFilter(), selectStatement() */
end_comment
begin_function
DECL|function|select
name|bool
name|QSqlTableModel
operator|::
name|select
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
specifier|const
name|QString
name|query
init|=
name|selectStatement
argument_list|()
decl_stmt|;
if|if
condition|(
name|query
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|beginResetModel
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearCache
argument_list|()
expr_stmt|;
name|QSqlQuery
name|qu
argument_list|(
name|query
argument_list|,
name|d
operator|->
name|db
argument_list|)
decl_stmt|;
name|setQuery
argument_list|(
name|qu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qu
operator|.
name|isActive
argument_list|()
operator|||
name|lastError
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// something went wrong - revert to non-select state
name|d
operator|->
name|initRecordAndPrimaryIndex
argument_list|()
expr_stmt|;
name|endResetModel
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|endResetModel
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Refreshes \a row in the model with values from the database table row matching     on primary key values. Without a primary key, all column values must match. If     no matching row is found, the model will show an empty row.      Returns \c true if successful; otherwise returns \c false.      \sa select() */
end_comment
begin_function
DECL|function|selectRow
name|bool
name|QSqlTableModel
operator|::
name|selectRow
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|<
literal|0
operator|||
name|row
operator|>=
name|rowCount
argument_list|()
condition|)
return|return
literal|false
return|;
specifier|const
name|int
name|table_sort_col
init|=
name|d
operator|->
name|sortColumn
decl_stmt|;
name|d
operator|->
name|sortColumn
operator|=
operator|-
literal|1
expr_stmt|;
specifier|const
name|QString
name|table_filter
init|=
name|d
operator|->
name|filter
decl_stmt|;
name|d
operator|->
name|filter
operator|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|sqlStatement
argument_list|(
name|QSqlDriver
operator|::
name|WhereStatement
argument_list|,
name|d
operator|->
name|tableName
argument_list|,
name|primaryValues
argument_list|(
name|row
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|QString
name|wh
init|=
name|Sql
operator|::
name|where
argument_list|()
operator|+
name|Sql
operator|::
name|sp
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|filter
operator|.
name|startsWith
argument_list|(
name|wh
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
name|d
operator|->
name|filter
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|wh
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|stmt
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|filter
operator|.
name|isEmpty
argument_list|()
condition|)
name|stmt
operator|=
name|selectStatement
argument_list|()
expr_stmt|;
name|d
operator|->
name|sortColumn
operator|=
name|table_sort_col
expr_stmt|;
name|d
operator|->
name|filter
operator|=
name|table_filter
expr_stmt|;
if|if
condition|(
name|stmt
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|bool
name|exists
decl_stmt|;
name|QSqlRecord
name|newValues
decl_stmt|;
block|{
name|QSqlQuery
name|q
argument_list|(
name|d
operator|->
name|db
argument_list|)
decl_stmt|;
name|q
operator|.
name|setForwardOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|.
name|exec
argument_list|(
name|stmt
argument_list|)
condition|)
return|return
literal|false
return|;
name|exists
operator|=
name|q
operator|.
name|next
argument_list|()
expr_stmt|;
name|newValues
operator|=
name|q
operator|.
name|record
argument_list|()
expr_stmt|;
block|}
name|bool
name|needsAddingToCache
init|=
operator|!
name|exists
operator|||
name|d
operator|->
name|cache
operator|.
name|contains
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|needsAddingToCache
condition|)
block|{
specifier|const
name|QSqlRecord
name|curValues
init|=
name|record
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|needsAddingToCache
operator|=
name|curValues
operator|.
name|count
argument_list|()
operator|!=
name|newValues
operator|.
name|count
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|needsAddingToCache
condition|)
block|{
comment|// Look for changed values. Primary key fields are customarily first
comment|// and probably change less often than other fields, so start at the end.
for|for
control|(
name|int
name|f
init|=
name|curValues
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|f
operator|>=
literal|0
condition|;
operator|--
name|f
control|)
block|{
if|if
condition|(
name|curValues
operator|.
name|value
argument_list|(
name|f
argument_list|)
operator|!=
name|newValues
operator|.
name|value
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|needsAddingToCache
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|needsAddingToCache
condition|)
block|{
name|d
operator|->
name|cache
index|[
name|row
index|]
operator|.
name|refresh
argument_list|(
name|exists
argument_list|,
name|newValues
argument_list|)
expr_stmt|;
emit|emit
name|headerDataChanged
argument_list|(
name|Qt
operator|::
name|Vertical
argument_list|,
name|row
argument_list|,
name|row
argument_list|)
emit|;
emit|emit
name|dataChanged
argument_list|(
name|createIndex
argument_list|(
name|row
argument_list|,
literal|0
argument_list|)
argument_list|,
name|createIndex
argument_list|(
name|row
argument_list|,
name|columnCount
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
emit|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|data
name|QVariant
name|QSqlTableModel
operator|::
name|data
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|int
name|role
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
operator|||
operator|(
name|role
operator|!=
name|Qt
operator|::
name|DisplayRole
operator|&&
name|role
operator|!=
name|Qt
operator|::
name|EditRole
operator|)
condition|)
return|return
name|QVariant
argument_list|()
return|;
specifier|const
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
name|mrow
init|=
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|mrow
operator|.
name|op
argument_list|()
operator|!=
name|QSqlTableModelPrivate
operator|::
name|None
condition|)
return|return
name|mrow
operator|.
name|rec
argument_list|()
operator|.
name|value
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
return|;
return|return
name|QSqlQueryModel
operator|::
name|data
argument_list|(
name|index
argument_list|,
name|role
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|headerData
name|QVariant
name|QSqlTableModel
operator|::
name|headerData
parameter_list|(
name|int
name|section
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|,
name|int
name|role
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Vertical
operator|&&
name|role
operator|==
name|Qt
operator|::
name|DisplayRole
condition|)
block|{
specifier|const
name|QSqlTableModelPrivate
operator|::
name|Op
name|op
init|=
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|section
argument_list|)
operator|.
name|op
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
return|return
name|QLatin1String
argument_list|(
literal|"*"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op
operator|==
name|QSqlTableModelPrivate
operator|::
name|Delete
condition|)
return|return
name|QLatin1String
argument_list|(
literal|"!"
argument_list|)
return|;
block|}
return|return
name|QSqlQueryModel
operator|::
name|headerData
argument_list|(
name|section
argument_list|,
name|orientation
argument_list|,
name|role
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 5.0      Returns \c true if the model contains modified values that have not been     committed to the datase, otherwise false. */
end_comment
begin_function
DECL|function|isDirty
name|bool
name|QSqlTableModel
operator|::
name|isDirty
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|QSqlTableModelPrivate
operator|::
name|CacheMap
operator|::
name|ConstIterator
name|i
init|=
name|d
operator|->
name|cache
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|QSqlTableModelPrivate
operator|::
name|CacheMap
operator|::
name|ConstIterator
name|e
init|=
name|d
operator|->
name|cache
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|i
operator|!=
name|e
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|i
operator|.
name|value
argument_list|()
operator|.
name|submitted
argument_list|()
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the value at the index \a index is dirty, otherwise false.     Dirty values are values that were modified in the model     but not yet written into the database.      If \a index is invalid or points to a non-existing row, false is returned. */
end_comment
begin_function
DECL|function|isDirty
name|bool
name|QSqlTableModel
operator|::
name|isDirty
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
specifier|const
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
name|row
init|=
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|.
name|submitted
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|row
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Insert
operator|||
name|row
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Delete
operator|||
operator|(
name|row
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Update
operator|&&
name|row
operator|.
name|rec
argument_list|()
operator|.
name|isGenerated
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the data for the item \a index for the role \a role to \a     value.      For edit strategy OnFieldChange, an index may receive a change     only if no other index has a cached change. Changes are     submitted immediately. However, rows that have not yet been     inserted in the database may be freely changed and are not     submitted automatically. Submitted changes are not reverted upon     failure.      For OnRowChange, an index may receive a change only if no other     row has a cached change. Changes are not submitted automatically.      Returns \c true if \a value is equal to the current value. However,     the value will not be submitted to the database.      Returns \c true if the value could be set or false on error, for     example if \a index is out of bounds.      \sa editStrategy(), data(), submit(), submitAll(), revertRow() */
end_comment
begin_function
DECL|function|setData
name|bool
name|QSqlTableModel
operator|::
name|setData
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|,
name|int
name|role
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|busyInsertingRows
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|role
operator|!=
name|Qt
operator|::
name|EditRole
condition|)
return|return
name|QSqlQueryModel
operator|::
name|setData
argument_list|(
name|index
argument_list|,
name|value
argument_list|,
name|role
argument_list|)
return|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
operator|||
name|index
operator|.
name|column
argument_list|()
operator|>=
name|d
operator|->
name|rec
operator|.
name|count
argument_list|()
operator|||
name|index
operator|.
name|row
argument_list|()
operator|>=
name|rowCount
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
operator|(
name|flags
argument_list|(
name|index
argument_list|)
operator|&
name|Qt
operator|::
name|ItemIsEditable
operator|)
condition|)
return|return
literal|false
return|;
specifier|const
name|QVariant
name|oldValue
init|=
name|QSqlTableModel
operator|::
name|data
argument_list|(
name|index
argument_list|,
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|oldValue
operator|&&
name|value
operator|.
name|isNull
argument_list|()
operator|==
name|oldValue
operator|.
name|isNull
argument_list|()
operator|&&
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
operator|.
name|op
argument_list|()
operator|!=
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
return|return
literal|true
return|;
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
modifier|&
name|row
init|=
name|d
operator|->
name|cache
index|[
name|index
operator|.
name|row
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|row
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|None
condition|)
name|row
operator|=
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
argument_list|(
name|QSqlTableModelPrivate
operator|::
name|Update
argument_list|,
name|QSqlQueryModel
operator|::
name|record
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|row
operator|.
name|setValue
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
emit|emit
name|dataChanged
argument_list|(
name|index
argument_list|,
name|index
argument_list|)
emit|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnFieldChange
operator|&&
name|row
operator|.
name|op
argument_list|()
operator|!=
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
return|return
name|submit
argument_list|()
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     This function simply calls QSqlQueryModel::setQuery(\a query).     You should normally not call it on a QSqlTableModel. Instead, use     setTable(), setSort(), setFilter(), etc., to set up the query.      \sa selectStatement() */
end_comment
begin_function
DECL|function|setQuery
name|void
name|QSqlTableModel
operator|::
name|setQuery
parameter_list|(
specifier|const
name|QSqlQuery
modifier|&
name|query
parameter_list|)
block|{
name|QSqlQueryModel
operator|::
name|setQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Updates the given \a row in the currently active database table     with the specified \a values. Returns \c true if successful; otherwise     returns \c false.      This is a low-level method that operates directly on the database     and should not be called directly. Use setData() to update values.     The model will decide depending on its edit strategy when to modify     the database.      Note that only values that have the generated-flag set are updated.     The generated-flag can be set with QSqlRecord::setGenerated() and     tested with QSqlRecord::isGenerated().      \sa QSqlRecord::isGenerated(), setData() */
end_comment
begin_function
DECL|function|updateRowInTable
name|bool
name|QSqlTableModel
operator|::
name|updateRowInTable
parameter_list|(
name|int
name|row
parameter_list|,
specifier|const
name|QSqlRecord
modifier|&
name|values
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|QSqlRecord
name|rec
argument_list|(
name|values
argument_list|)
decl_stmt|;
emit|emit
name|beforeUpdate
argument_list|(
name|row
argument_list|,
name|rec
argument_list|)
emit|;
specifier|const
name|QSqlRecord
name|whereValues
init|=
name|primaryValues
argument_list|(
name|row
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|prepStatement
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|hasFeature
argument_list|(
name|QSqlDriver
operator|::
name|PreparedQueries
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|stmt
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|sqlStatement
argument_list|(
name|QSqlDriver
operator|::
name|UpdateStatement
argument_list|,
name|d
operator|->
name|tableName
argument_list|,
name|rec
argument_list|,
name|prepStatement
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|where
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|sqlStatement
argument_list|(
name|QSqlDriver
operator|::
name|WhereStatement
argument_list|,
name|d
operator|->
name|tableName
argument_list|,
name|whereValues
argument_list|,
name|prepStatement
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|.
name|isEmpty
argument_list|()
operator|||
name|where
operator|.
name|isEmpty
argument_list|()
operator|||
name|row
operator|<
literal|0
operator|||
name|row
operator|>=
name|rowCount
argument_list|()
condition|)
block|{
name|d
operator|->
name|error
operator|=
name|QSqlError
argument_list|(
name|QLatin1String
argument_list|(
literal|"No Fields to update"
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|exec
argument_list|(
name|Sql
operator|::
name|concat
argument_list|(
name|stmt
argument_list|,
name|where
argument_list|)
argument_list|,
name|prepStatement
argument_list|,
name|rec
argument_list|,
name|whereValues
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts the values \a values into the currently active database table.      This is a low-level method that operates directly on the database     and should not be called directly. Use insertRow() and setData()     to insert values. The model will decide depending on its edit strategy     when to modify the database.      Returns \c true if the values could be inserted, otherwise false.     Error information can be retrieved with \l lastError().      \sa lastError(), insertRow(), insertRows() */
end_comment
begin_function
DECL|function|insertRowIntoTable
name|bool
name|QSqlTableModel
operator|::
name|insertRowIntoTable
parameter_list|(
specifier|const
name|QSqlRecord
modifier|&
name|values
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|QSqlRecord
name|rec
init|=
name|values
decl_stmt|;
emit|emit
name|beforeInsert
argument_list|(
name|rec
argument_list|)
emit|;
specifier|const
name|bool
name|prepStatement
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|hasFeature
argument_list|(
name|QSqlDriver
operator|::
name|PreparedQueries
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|stmt
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|sqlStatement
argument_list|(
name|QSqlDriver
operator|::
name|InsertStatement
argument_list|,
name|d
operator|->
name|tableName
argument_list|,
name|rec
argument_list|,
name|prepStatement
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|error
operator|=
name|QSqlError
argument_list|(
name|QLatin1String
argument_list|(
literal|"No Fields to update"
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|exec
argument_list|(
name|stmt
argument_list|,
name|prepStatement
argument_list|,
name|rec
argument_list|,
name|QSqlRecord
argument_list|()
comment|/* no where values */
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Deletes the given \a row from the currently active database table.      This is a low-level method that operates directly on the database     and should not be called directly. Use removeRow() or removeRows()     to delete values. The model will decide depending on its edit strategy     when to modify the database.      Returns \c true if the row was deleted; otherwise returns \c false.      \sa removeRow(), removeRows() */
end_comment
begin_function
DECL|function|deleteRowFromTable
name|bool
name|QSqlTableModel
operator|::
name|deleteRowFromTable
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
emit|emit
name|beforeDelete
argument_list|(
name|row
argument_list|)
emit|;
specifier|const
name|QSqlRecord
name|whereValues
init|=
name|primaryValues
argument_list|(
name|row
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|prepStatement
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|hasFeature
argument_list|(
name|QSqlDriver
operator|::
name|PreparedQueries
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|stmt
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|sqlStatement
argument_list|(
name|QSqlDriver
operator|::
name|DeleteStatement
argument_list|,
name|d
operator|->
name|tableName
argument_list|,
name|QSqlRecord
argument_list|()
argument_list|,
name|prepStatement
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|where
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|sqlStatement
argument_list|(
name|QSqlDriver
operator|::
name|WhereStatement
argument_list|,
name|d
operator|->
name|tableName
argument_list|,
name|whereValues
argument_list|,
name|prepStatement
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|.
name|isEmpty
argument_list|()
operator|||
name|where
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|error
operator|=
name|QSqlError
argument_list|(
name|QLatin1String
argument_list|(
literal|"Unable to delete row"
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|exec
argument_list|(
name|Sql
operator|::
name|concat
argument_list|(
name|stmt
argument_list|,
name|where
argument_list|)
argument_list|,
name|prepStatement
argument_list|,
name|QSqlRecord
argument_list|()
comment|/* no new values */
argument_list|,
name|whereValues
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Submits all pending changes and returns \c true on success.     Returns \c false on error, detailed error information can be     obtained with lastError().      In OnManualSubmit, on success the model will be repopulated.     Any views presenting it will lose their selections.      Note: In OnManualSubmit mode, already submitted changes won't     be cleared from the cache when submitAll() fails. This allows     transactions to be rolled back and resubmitted without     losing data.      \sa revertAll(), lastError() */
end_comment
begin_function
DECL|function|submitAll
name|bool
name|QSqlTableModel
operator|::
name|submitAll
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|bool
name|success
init|=
literal|true
decl_stmt|;
foreach|foreach
control|(
name|int
name|row
decl|,
name|d
operator|->
name|cache
operator|.
name|keys
argument_list|()
control|)
block|{
comment|// be sure cache *still* contains the row since overridden selectRow() could have called select()
name|QSqlTableModelPrivate
operator|::
name|CacheMap
operator|::
name|iterator
name|it
init|=
name|d
operator|->
name|cache
operator|.
name|find
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|d
operator|->
name|cache
operator|.
name|end
argument_list|()
condition|)
continue|continue;
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
modifier|&
name|mrow
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|mrow
operator|.
name|submitted
argument_list|()
condition|)
continue|continue;
switch|switch
condition|(
name|mrow
operator|.
name|op
argument_list|()
condition|)
block|{
case|case
name|QSqlTableModelPrivate
operator|::
name|Insert
case|:
name|success
operator|=
name|insertRowIntoTable
argument_list|(
name|mrow
operator|.
name|rec
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSqlTableModelPrivate
operator|::
name|Update
case|:
name|success
operator|=
name|updateRowInTable
argument_list|(
name|row
argument_list|,
name|mrow
operator|.
name|rec
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSqlTableModelPrivate
operator|::
name|Delete
case|:
name|success
operator|=
name|deleteRowFromTable
argument_list|(
name|row
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSqlTableModelPrivate
operator|::
name|None
case|:
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QSqlTableModel::submitAll()"
argument_list|,
literal|"Invalid cache operation"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|strategy
operator|!=
name|OnManualSubmit
operator|&&
name|mrow
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
block|{
name|int
name|c
init|=
name|mrow
operator|.
name|rec
argument_list|()
operator|.
name|indexOf
argument_list|(
name|d
operator|->
name|autoColumn
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|mrow
operator|.
name|rec
argument_list|()
operator|.
name|isGenerated
argument_list|(
name|c
argument_list|)
condition|)
name|mrow
operator|.
name|setValue
argument_list|(
name|c
argument_list|,
name|d
operator|->
name|editQuery
operator|.
name|lastInsertId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|mrow
operator|.
name|setSubmitted
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|!=
name|OnManualSubmit
condition|)
name|success
operator|=
name|selectRow
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
break|break;
block|}
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnManualSubmit
condition|)
name|success
operator|=
name|select
argument_list|()
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
end_function
begin_comment
comment|/*!     This reimplemented slot is called by the item delegates when the     user stopped editing the current row.      Submits the currently edited row if the model's strategy is set     to OnRowChange or OnFieldChange. Does nothing for the OnManualSubmit     strategy.      Use submitAll() to submit all pending changes for the     OnManualSubmit strategy.      Returns \c true on success; otherwise returns \c false. Use lastError()     to query detailed error information.      Does not automatically repopulate the model. Submitted rows are     refreshed from the database on success.      \sa revert(), revertRow(), submitAll(), revertAll(), lastError() */
end_comment
begin_function
DECL|function|submit
name|bool
name|QSqlTableModel
operator|::
name|submit
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnRowChange
operator|||
name|d
operator|->
name|strategy
operator|==
name|OnFieldChange
condition|)
return|return
name|submitAll
argument_list|()
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     This reimplemented slot is called by the item delegates when the     user canceled editing the current row.      Reverts the changes if the model's strategy is set to     OnRowChange or OnFieldChange. Does nothing for the OnManualSubmit     strategy.      Use revertAll() to revert all pending changes for the     OnManualSubmit strategy or revertRow() to revert a specific row.      \sa submit(), submitAll(), revertRow(), revertAll() */
end_comment
begin_function
DECL|function|revert
name|void
name|QSqlTableModel
operator|::
name|revert
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnRowChange
operator|||
name|d
operator|->
name|strategy
operator|==
name|OnFieldChange
condition|)
name|revertAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \enum QSqlTableModel::EditStrategy      This enum type describes which strategy to choose when editing values in the database.      \value OnFieldChange  All changes to the model will be applied immediately to the database.     \value OnRowChange  Changes to a row will be applied when the user selects a different row.     \value OnManualSubmit  All changes will be cached in the model until either submitAll()                            or revertAll() is called.      Note: To prevent inserting only partly initialized rows into the database,     \c OnFieldChange will behave like \c OnRowChange for newly inserted rows.      \sa setEditStrategy() */
end_comment
begin_comment
comment|/*!     Sets the strategy for editing values in the database to \a     strategy.      This will revert any pending changes.      \sa editStrategy(), revertAll() */
end_comment
begin_function
DECL|function|setEditStrategy
name|void
name|QSqlTableModel
operator|::
name|setEditStrategy
parameter_list|(
name|EditStrategy
name|strategy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|revertAll
argument_list|()
expr_stmt|;
name|d
operator|->
name|strategy
operator|=
name|strategy
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current edit strategy.      \sa setEditStrategy() */
end_comment
begin_function
DECL|function|editStrategy
name|QSqlTableModel
operator|::
name|EditStrategy
name|QSqlTableModel
operator|::
name|editStrategy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|strategy
return|;
block|}
end_function
begin_comment
comment|/*!     Reverts all pending changes.      \sa revert(), revertRow(), submitAll() */
end_comment
begin_function
DECL|function|revertAll
name|void
name|QSqlTableModel
operator|::
name|revertAll
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
specifier|const
name|QList
argument_list|<
name|int
argument_list|>
name|rows
argument_list|(
name|d
operator|->
name|cache
operator|.
name|keys
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|rows
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|revertRow
argument_list|(
name|rows
operator|.
name|value
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Reverts all changes for the specified \a row.      \sa revert(), revertAll(), submit(), submitAll() */
end_comment
begin_function
DECL|function|revertRow
name|void
name|QSqlTableModel
operator|::
name|revertRow
parameter_list|(
name|int
name|row
parameter_list|)
block|{
if|if
condition|(
name|row
operator|<
literal|0
condition|)
return|return;
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|revertCachedRow
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the primary key for the current table, or an empty     QSqlIndex if the table is not set or has no primary key.      \sa setTable(), setPrimaryKey(), QSqlDatabase::primaryIndex() */
end_comment
begin_function
DECL|function|primaryKey
name|QSqlIndex
name|QSqlTableModel
operator|::
name|primaryKey
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|primaryIndex
return|;
block|}
end_function
begin_comment
comment|/*!     Protected method that allows subclasses to set the primary key to     \a key.      Normally, the primary index is set automatically whenever you     call setTable().      \sa primaryKey(), QSqlDatabase::primaryIndex() */
end_comment
begin_function
DECL|function|setPrimaryKey
name|void
name|QSqlTableModel
operator|::
name|setPrimaryKey
parameter_list|(
specifier|const
name|QSqlIndex
modifier|&
name|key
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|primaryIndex
operator|=
name|key
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the used QSqlDatabase or 0 if no database was set. */
end_comment
begin_function
DECL|function|database
name|QSqlDatabase
name|QSqlTableModel
operator|::
name|database
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|db
return|;
block|}
end_function
begin_comment
comment|/*!     Sorts the data by \a column with the sort order \a order.     This will immediately select data, use setSort()     to set a sort order without populating the model with data.      \sa setSort(), select(), orderByClause() */
end_comment
begin_function
DECL|function|sort
name|void
name|QSqlTableModel
operator|::
name|sort
parameter_list|(
name|int
name|column
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|)
block|{
name|setSort
argument_list|(
name|column
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|select
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the sort order for \a column to \a order. This does not     affect the current data, to refresh the data using the new     sort order, call select().      \sa select(), orderByClause() */
end_comment
begin_function
DECL|function|setSort
name|void
name|QSqlTableModel
operator|::
name|setSort
parameter_list|(
name|int
name|column
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|sortColumn
operator|=
name|column
expr_stmt|;
name|d
operator|->
name|sortOrder
operator|=
name|order
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns an SQL \c{ORDER BY} clause based on the currently set     sort order.      \sa setSort(), selectStatement() */
end_comment
begin_function
DECL|function|orderByClause
name|QString
name|QSqlTableModel
operator|::
name|orderByClause
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|QSqlField
name|f
init|=
name|d
operator|->
name|rec
operator|.
name|field
argument_list|(
name|d
operator|->
name|sortColumn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
comment|//we can safely escape the field because it would have been obtained from the database
comment|//and have the correct case
name|QString
name|field
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|escapeIdentifier
argument_list|(
name|f
operator|.
name|name
argument_list|()
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
decl_stmt|;
name|field
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
operator|.
name|prepend
argument_list|(
name|d
operator|->
name|tableName
argument_list|)
expr_stmt|;
name|field
operator|=
name|d
operator|->
name|sortOrder
operator|==
name|Qt
operator|::
name|AscendingOrder
condition|?
name|Sql
operator|::
name|asc
argument_list|(
name|field
argument_list|)
else|:
name|Sql
operator|::
name|desc
argument_list|(
name|field
argument_list|)
expr_stmt|;
return|return
name|Sql
operator|::
name|orderBy
argument_list|(
name|field
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the index of the field \a fieldName, or -1 if no corresponding field     exists in the model. */
end_comment
begin_function
DECL|function|fieldIndex
name|int
name|QSqlTableModel
operator|::
name|fieldIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|fieldName
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|rec
operator|.
name|indexOf
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the SQL \c SELECT statement used internally to populate     the model. The statement includes the filter and the \c{ORDER BY}     clause.      \sa filter(), orderByClause() */
end_comment
begin_function
DECL|function|selectStatement
name|QString
name|QSqlTableModel
operator|::
name|selectStatement
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tableName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|error
operator|=
name|QSqlError
argument_list|(
name|QLatin1String
argument_list|(
literal|"No table name given"
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
if|if
condition|(
name|d
operator|->
name|rec
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|error
operator|=
name|QSqlError
argument_list|(
name|QLatin1String
argument_list|(
literal|"Unable to find table "
argument_list|)
operator|+
name|d
operator|->
name|tableName
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
specifier|const
name|QString
name|stmt
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|sqlStatement
argument_list|(
name|QSqlDriver
operator|::
name|SelectStatement
argument_list|,
name|d
operator|->
name|tableName
argument_list|,
name|d
operator|->
name|rec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|error
operator|=
name|QSqlError
argument_list|(
name|QLatin1String
argument_list|(
literal|"Unable to select fields from table "
argument_list|)
operator|+
name|d
operator|->
name|tableName
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|)
expr_stmt|;
return|return
name|stmt
return|;
block|}
return|return
name|Sql
operator|::
name|concat
argument_list|(
name|Sql
operator|::
name|concat
argument_list|(
name|stmt
argument_list|,
name|Sql
operator|::
name|where
argument_list|(
name|d
operator|->
name|filter
argument_list|)
argument_list|)
argument_list|,
name|orderByClause
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Removes \a count columns from the \a parent model, starting at     index \a column.      Returns if the columns were successfully removed; otherwise     returns \c false.      \sa removeRows() */
end_comment
begin_function
DECL|function|removeColumns
name|bool
name|QSqlTableModel
operator|::
name|removeColumns
parameter_list|(
name|int
name|column
parameter_list|,
name|int
name|count
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
operator|||
name|column
argument_list|<
literal|0
operator|||
name|column
operator|+
name|count
argument_list|>
name|d
operator|->
name|rec
operator|.
name|count
argument_list|()
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|rec
operator|.
name|remove
argument_list|(
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|query
operator|.
name|isActive
argument_list|()
condition|)
return|return
name|select
argument_list|()
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Removes \a count rows starting at \a row. Since this model     does not support hierarchical structures, \a parent must be     an invalid model index.      When the edit strategy is OnManualSubmit, deletion of rows from     the database is delayed until submitAll() is called.      For OnFieldChange and OnRowChange, only one row may be deleted     at a time and only if no other row has a cached change. Deletions     are submitted immediately to the database. The model retains a     blank row for successfully deleted row until refreshed with select().      After failed deletion, the operation is not reverted in the model.     The application may resubmit or revert.      Inserted but not yet successfully submitted rows in the range to be     removed are immediately removed from the model.      Before a row is deleted from the database, the beforeDelete()     signal is emitted.      If row< 0 or row + count> rowCount(), no action is taken and     false is returned. Returns \c true if all rows could be removed;     otherwise returns \c false. Detailed database error information     can be retrieved using lastError().      \sa removeColumns(), insertRows() */
end_comment
begin_function
DECL|function|removeRows
name|bool
name|QSqlTableModel
operator|::
name|removeRows
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|count
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
operator|||
name|row
operator|<
literal|0
operator|||
name|count
operator|<=
literal|0
condition|)
return|return
literal|false
return|;
elseif|else
if|if
condition|(
name|row
operator|+
name|count
operator|>
name|rowCount
argument_list|()
condition|)
return|return
literal|false
return|;
elseif|else
if|if
condition|(
operator|!
name|count
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|!=
name|OnManualSubmit
condition|)
if|if
condition|(
name|count
operator|>
literal|1
operator|||
operator|(
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|row
argument_list|)
operator|.
name|submitted
argument_list|()
operator|&&
name|isDirty
argument_list|()
operator|)
condition|)
return|return
literal|false
return|;
comment|// Iterate backwards so we don't have to worry about removed rows causing
comment|// higher cache entries to shift downwards.
for|for
control|(
name|int
name|idx
init|=
name|row
operator|+
name|count
operator|-
literal|1
init|;
name|idx
operator|>=
name|row
condition|;
operator|--
name|idx
control|)
block|{
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
modifier|&
name|mrow
init|=
name|d
operator|->
name|cache
index|[
name|idx
index|]
decl_stmt|;
if|if
condition|(
name|mrow
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
block|{
name|revertRow
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mrow
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|None
condition|)
name|mrow
operator|=
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
argument_list|(
name|QSqlTableModelPrivate
operator|::
name|Delete
argument_list|,
name|QSqlQueryModel
operator|::
name|record
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|mrow
operator|.
name|setOp
argument_list|(
name|QSqlTableModelPrivate
operator|::
name|Delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnManualSubmit
condition|)
emit|emit
name|headerDataChanged
argument_list|(
name|Qt
operator|::
name|Vertical
argument_list|,
name|idx
argument_list|,
name|idx
argument_list|)
emit|;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|strategy
operator|!=
name|OnManualSubmit
condition|)
return|return
name|submit
argument_list|()
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts \a count empty rows at position \a row. Note that \a     parent must be invalid, since this model does not support     parent-child relations.      For edit strategies OnFieldChange and OnRowChange, only one row     may be inserted at a time and the model may not contain other     cached changes.      The primeInsert() signal will be emitted for each new row.     Connect to it if you want to initialize the new row with default     values.      Does not submit rows, regardless of edit strategy.      Returns \c false if the parameters are out of bounds or the row cannot be     inserted; otherwise returns \c true.      \sa primeInsert(), insertRecord() */
end_comment
begin_function
DECL|function|insertRows
name|bool
name|QSqlTableModel
operator|::
name|insertRows
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|count
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
argument_list|<
literal|0
operator|||
name|count
operator|<=
literal|0
operator|||
name|row
argument_list|>
name|rowCount
argument_list|()
operator|||
name|parent
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|!=
name|OnManualSubmit
condition|)
if|if
condition|(
name|count
operator|!=
literal|1
operator|||
name|isDirty
argument_list|()
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|busyInsertingRows
operator|=
literal|true
expr_stmt|;
name|beginInsertRows
argument_list|(
name|parent
argument_list|,
name|row
argument_list|,
name|row
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|!=
name|OnManualSubmit
condition|)
name|d
operator|->
name|cache
operator|.
name|empty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|cache
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QMap
argument_list|<
name|int
argument_list|,
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|cache
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|cache
operator|.
name|begin
argument_list|()
operator|&&
operator|(
operator|--
name|it
operator|)
operator|.
name|key
argument_list|()
operator|>=
name|row
condition|)
block|{
name|int
name|oldKey
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
specifier|const
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
name|oldValue
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|d
operator|->
name|cache
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|it
operator|=
name|d
operator|->
name|cache
operator|.
name|insert
argument_list|(
name|oldKey
operator|+
name|count
argument_list|,
name|oldValue
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|->
name|cache
index|[
name|row
operator|+
name|i
index|]
operator|=
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
argument_list|(
name|QSqlTableModelPrivate
operator|::
name|Insert
argument_list|,
name|d
operator|->
name|rec
argument_list|)
expr_stmt|;
emit|emit
name|primeInsert
argument_list|(
name|row
operator|+
name|i
argument_list|,
name|d
operator|->
name|cache
index|[
name|row
operator|+
name|i
index|]
operator|.
name|recRef
argument_list|()
argument_list|)
emit|;
block|}
name|endInsertRows
argument_list|()
expr_stmt|;
name|d
operator|->
name|busyInsertingRows
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts the \a record at position \a row. If \a row is negative,     the record will be appended to the end. Calls insertRows() and     setRecord() internally.      Returns \c true if the record could be inserted, otherwise false.      Changes are submitted immediately for OnFieldChange and     OnRowChange. Failure does not leave a new row in the model.      \sa insertRows(), removeRows(), setRecord() */
end_comment
begin_function
DECL|function|insertRecord
name|bool
name|QSqlTableModel
operator|::
name|insertRecord
parameter_list|(
name|int
name|row
parameter_list|,
specifier|const
name|QSqlRecord
modifier|&
name|record
parameter_list|)
block|{
if|if
condition|(
name|row
operator|<
literal|0
condition|)
name|row
operator|=
name|rowCount
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|insertRow
argument_list|(
name|row
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|setRecord
argument_list|(
name|row
argument_list|,
name|record
argument_list|)
condition|)
block|{
name|revertRow
argument_list|(
name|row
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|rowCount
name|int
name|QSqlTableModel
operator|::
name|rowCount
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|QSqlQueryModel
operator|::
name|rowCount
argument_list|()
operator|+
name|d
operator|->
name|insertCount
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the index of the value in the database result set for the     given \a item in the model.      The return value is identical to \a item if no columns or rows     have been inserted, removed, or moved around.      Returns an invalid model index if \a item is out of bounds or if     \a item does not point to a value in the result set.      \sa QSqlQueryModel::indexInQuery() */
end_comment
begin_function
DECL|function|indexInQuery
name|QModelIndex
name|QSqlTableModel
operator|::
name|indexInQuery
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|item
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|item
operator|.
name|row
argument_list|()
argument_list|)
operator|.
name|insert
argument_list|()
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
specifier|const
name|int
name|rowOffset
init|=
name|d
operator|->
name|insertCount
argument_list|(
name|item
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|QSqlQueryModel
operator|::
name|indexInQuery
argument_list|(
name|createIndex
argument_list|(
name|item
operator|.
name|row
argument_list|()
operator|-
name|rowOffset
argument_list|,
name|item
operator|.
name|column
argument_list|()
argument_list|,
name|item
operator|.
name|internalPointer
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the currently set filter.      \sa setFilter(), select() */
end_comment
begin_function
DECL|function|filter
name|QString
name|QSqlTableModel
operator|::
name|filter
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|filter
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the current filter to \a filter.      The filter is a SQL \c WHERE clause without the keyword \c WHERE     (for example, \c{name='Josephine')}.      If the model is already populated with data from a database,     the model re-selects it with the new filter. Otherwise, the filter     will be applied the next time select() is called.      \sa filter(), select(), selectStatement(), orderByClause() */
end_comment
begin_function
DECL|function|setFilter
name|void
name|QSqlTableModel
operator|::
name|setFilter
parameter_list|(
specifier|const
name|QString
modifier|&
name|filter
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|filter
operator|=
name|filter
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|query
operator|.
name|isActive
argument_list|()
condition|)
name|select
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|clear
name|void
name|QSqlTableModel
operator|::
name|clear
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
name|QSqlQueryModel
operator|::
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|flags
name|Qt
operator|::
name|ItemFlags
name|QSqlTableModel
operator|::
name|flags
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|.
name|internalPointer
argument_list|()
operator|||
name|index
operator|.
name|column
argument_list|()
operator|<
literal|0
operator|||
name|index
operator|.
name|column
argument_list|()
operator|>=
name|d
operator|->
name|rec
operator|.
name|count
argument_list|()
operator|||
name|index
operator|.
name|row
argument_list|()
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|bool
name|editable
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|rec
operator|.
name|field
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
name|editable
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
name|mrow
init|=
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|mrow
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Delete
condition|)
block|{
name|editable
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnFieldChange
condition|)
block|{
if|if
condition|(
name|mrow
operator|.
name|op
argument_list|()
operator|!=
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
if|if
condition|(
operator|!
name|isDirty
argument_list|(
name|index
argument_list|)
operator|&&
name|isDirty
argument_list|()
condition|)
name|editable
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnRowChange
condition|)
block|{
if|if
condition|(
name|mrow
operator|.
name|submitted
argument_list|()
operator|&&
name|isDirty
argument_list|()
condition|)
name|editable
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|editable
condition|)
return|return
name|QSqlQueryModel
operator|::
name|flags
argument_list|(
name|index
argument_list|)
return|;
else|else
return|return
name|QSqlQueryModel
operator|::
name|flags
argument_list|(
name|index
argument_list|)
operator||
name|Qt
operator|::
name|ItemIsEditable
return|;
block|}
end_function
begin_function
DECL|function|record
name|QSqlRecord
name|QSqlTableModel
operator|::
name|record
parameter_list|()
specifier|const
block|{
return|return
name|QSqlQueryModel
operator|::
name|record
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \since 5.0     Returns the record at \a row in the model.      If \a row is the index of a valid row, the record     will be populated with values from that row.      If the model is not initialized, an empty record will be     returned.      \sa QSqlRecord::isEmpty() */
end_comment
begin_function
DECL|function|record
name|QSqlRecord
name|QSqlTableModel
operator|::
name|record
parameter_list|(
name|int
name|row
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
comment|// the query gets the values from virtual data()
name|QSqlRecord
name|rec
init|=
name|QSqlQueryModel
operator|::
name|record
argument_list|(
name|row
argument_list|)
decl_stmt|;
comment|// get generated flags from the cache
specifier|const
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
name|mrow
init|=
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|mrow
operator|.
name|op
argument_list|()
operator|!=
name|QSqlTableModelPrivate
operator|::
name|None
condition|)
block|{
specifier|const
name|QSqlRecord
name|crec
init|=
name|mrow
operator|.
name|rec
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|cnt
init|=
name|rec
operator|.
name|count
argument_list|()
init|;
name|i
operator|<
name|cnt
condition|;
operator|++
name|i
control|)
name|rec
operator|.
name|setGenerated
argument_list|(
name|i
argument_list|,
name|crec
operator|.
name|isGenerated
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rec
return|;
block|}
end_function
begin_comment
comment|/*!     Applies \a values to the \a row in the model. The source and     target fields are mapped by field name, not by position in     the record.      Note that the generated flags in \a values are preserved     and determine whether the corresponding fields are used when     changes are submitted to the database. The caller should     remember to set the generated flag to FALSE for fields     where the database is meant to supply the value, such as an     automatically incremented ID.      For edit strategies OnFieldChange and OnRowChange, a row may     receive a change only if no other row has a cached change.     Changes are submitted immediately. Submitted changes are not     reverted upon failure.      Returns \c true if all the values could be set; otherwise returns     false.      \sa record(), editStrategy() */
end_comment
begin_function
DECL|function|setRecord
name|bool
name|QSqlTableModel
operator|::
name|setRecord
parameter_list|(
name|int
name|row
parameter_list|,
specifier|const
name|QSqlRecord
modifier|&
name|values
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
name|row
operator|>=
literal|0
argument_list|,
literal|"QSqlTableModel::setRecord()"
argument_list|,
literal|"Cannot set a record to a row less than 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|busyInsertingRows
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|row
operator|>=
name|rowCount
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|row
argument_list|)
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Delete
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|!=
name|OnManualSubmit
operator|&&
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|row
argument_list|)
operator|.
name|submitted
argument_list|()
operator|&&
name|isDirty
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// Check field names and remember mapping
typedef|typedef
name|QMap
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|Map
typedef|;
name|Map
name|map
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|idx
init|=
name|d
operator|->
name|nameToIndex
argument_list|(
name|values
operator|.
name|fieldName
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
name|map
index|[
name|i
index|]
operator|=
name|idx
expr_stmt|;
block|}
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
modifier|&
name|mrow
init|=
name|d
operator|->
name|cache
index|[
name|row
index|]
decl_stmt|;
if|if
condition|(
name|mrow
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|None
condition|)
name|mrow
operator|=
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
argument_list|(
name|QSqlTableModelPrivate
operator|::
name|Update
argument_list|,
name|QSqlQueryModel
operator|::
name|record
argument_list|(
name|row
argument_list|)
argument_list|)
expr_stmt|;
name|Map
operator|::
name|const_iterator
name|i
init|=
name|map
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|Map
operator|::
name|const_iterator
name|e
init|=
name|map
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
comment|// have to use virtual setData() here rather than mrow.setValue()
name|EditStrategy
name|strategy
init|=
name|d
operator|->
name|strategy
decl_stmt|;
name|d
operator|->
name|strategy
operator|=
name|OnManualSubmit
expr_stmt|;
name|QModelIndex
name|cIndex
init|=
name|createIndex
argument_list|(
name|row
argument_list|,
name|i
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
name|setData
argument_list|(
name|cIndex
argument_list|,
name|values
operator|.
name|value
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|strategy
operator|=
name|strategy
expr_stmt|;
comment|// setData() sets generated to TRUE, but source record should prevail.
if|if
condition|(
operator|!
name|values
operator|.
name|isGenerated
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|)
condition|)
name|mrow
operator|.
name|recRef
argument_list|()
operator|.
name|setGenerated
argument_list|(
name|i
operator|.
name|value
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|strategy
operator|!=
name|OnManualSubmit
condition|)
return|return
name|submit
argument_list|()
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.1     Returns a record containing the fields represented in the primary key set to the values     at \a row. If no primary key is defined, the returned record will contain all fields.      \sa primaryKey() */
end_comment
begin_function
DECL|function|primaryValues
name|QSqlRecord
name|QSqlTableModel
operator|::
name|primaryValues
parameter_list|(
name|int
name|row
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
specifier|const
name|QSqlRecord
modifier|&
name|pIndex
init|=
name|d
operator|->
name|primaryIndex
operator|.
name|isEmpty
argument_list|()
condition|?
name|d
operator|->
name|rec
else|:
name|d
operator|->
name|primaryIndex
decl_stmt|;
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
name|mr
init|=
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|mr
operator|.
name|op
argument_list|()
operator|!=
name|QSqlTableModelPrivate
operator|::
name|None
condition|)
return|return
name|mr
operator|.
name|primaryValues
argument_list|(
name|pIndex
argument_list|)
return|;
else|else
return|return
name|QSqlQueryModel
operator|::
name|record
argument_list|(
name|row
argument_list|)
operator|.
name|keyValues
argument_list|(
name|pIndex
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
