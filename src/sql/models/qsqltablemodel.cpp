begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtSql module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qsqltablemodel.h"
end_include
begin_include
include|#
directive|include
file|"qsqldriver.h"
end_include
begin_include
include|#
directive|include
file|"qsqlerror.h"
end_include
begin_include
include|#
directive|include
file|"qsqlfield.h"
end_include
begin_include
include|#
directive|include
file|"qsqlindex.h"
end_include
begin_include
include|#
directive|include
file|"qsqlquery.h"
end_include
begin_include
include|#
directive|include
file|"qsqlrecord.h"
end_include
begin_include
include|#
directive|include
file|"qsqlresult.h"
end_include
begin_include
include|#
directive|include
file|"qsqltablemodel_p.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*! \internal     Populates our record with values. */
DECL|function|record
name|QSqlRecord
name|QSqlTableModelPrivate
operator|::
name|record
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|values
parameter_list|)
specifier|const
block|{
name|QSqlRecord
name|r
init|=
name|rec
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|r
operator|.
name|count
argument_list|()
operator|&&
name|i
operator|<
name|values
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|r
operator|.
name|setValue
argument_list|(
name|i
argument_list|,
name|values
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|nameToIndex
name|int
name|QSqlTableModelPrivate
operator|::
name|nameToIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|rec
operator|.
name|indexOf
argument_list|(
name|strippedFieldName
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|strippedFieldName
name|QString
name|QSqlTableModelPrivate
operator|::
name|strippedFieldName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|QString
name|fieldname
init|=
name|name
decl_stmt|;
if|if
condition|(
name|db
operator|.
name|driver
argument_list|()
operator|->
name|isIdentifierEscaped
argument_list|(
name|fieldname
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
condition|)
name|fieldname
operator|=
name|db
operator|.
name|driver
argument_list|()
operator|->
name|stripDelimiters
argument_list|(
name|fieldname
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
expr_stmt|;
return|return
name|fieldname
return|;
block|}
end_function
begin_function
DECL|function|initRecordAndPrimaryIndex
name|void
name|QSqlTableModelPrivate
operator|::
name|initRecordAndPrimaryIndex
parameter_list|()
block|{
name|rec
operator|=
name|db
operator|.
name|record
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|primaryIndex
operator|=
name|db
operator|.
name|primaryIndex
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clear
name|void
name|QSqlTableModelPrivate
operator|::
name|clear
parameter_list|()
block|{
name|sortColumn
operator|=
operator|-
literal|1
expr_stmt|;
name|sortOrder
operator|=
name|Qt
operator|::
name|AscendingOrder
expr_stmt|;
name|tableName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|editQuery
operator|.
name|clear
argument_list|()
expr_stmt|;
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|primaryIndex
operator|.
name|clear
argument_list|()
expr_stmt|;
name|rec
operator|.
name|clear
argument_list|()
expr_stmt|;
name|filter
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clearCache
name|void
name|QSqlTableModelPrivate
operator|::
name|clearCache
parameter_list|()
block|{
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|revertCachedRow
name|void
name|QSqlTableModelPrivate
operator|::
name|revertCachedRow
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|ModifiedRow
name|r
init|=
name|cache
operator|.
name|value
argument_list|(
name|row
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|r
operator|.
name|op
argument_list|()
condition|)
block|{
case|case
name|QSqlTableModelPrivate
operator|::
name|None
case|:
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QSqlTableModelPrivate::revertCachedRow()"
argument_list|,
literal|"Invalid entry in cache map"
argument_list|)
expr_stmt|;
return|return;
case|case
name|QSqlTableModelPrivate
operator|::
name|Update
case|:
case|case
name|QSqlTableModelPrivate
operator|::
name|Delete
case|:
name|cache
operator|.
name|remove
argument_list|(
name|row
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|dataChanged
argument_list|(
name|q
operator|->
name|createIndex
argument_list|(
name|row
argument_list|,
literal|0
argument_list|)
argument_list|,
name|q
operator|->
name|createIndex
argument_list|(
name|row
argument_list|,
name|q
operator|->
name|columnCount
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
emit|;
break|break;
case|case
name|QSqlTableModelPrivate
operator|::
name|Insert
case|:
block|{
name|QMap
argument_list|<
name|int
argument_list|,
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|cache
operator|.
name|find
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|cache
operator|.
name|end
argument_list|()
condition|)
return|return;
name|q
operator|->
name|beginRemoveRows
argument_list|(
name|QModelIndex
argument_list|()
argument_list|,
name|row
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|it
operator|=
name|cache
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
while|while
condition|(
name|it
operator|!=
name|cache
operator|.
name|end
argument_list|()
condition|)
block|{
name|int
name|oldKey
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
specifier|const
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
name|oldValue
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|cache
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|it
operator|=
name|cache
operator|.
name|insert
argument_list|(
name|oldKey
operator|-
literal|1
argument_list|,
name|oldValue
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
name|q
operator|->
name|endRemoveRows
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_function
DECL|function|exec
name|bool
name|QSqlTableModelPrivate
operator|::
name|exec
parameter_list|(
specifier|const
name|QString
modifier|&
name|stmt
parameter_list|,
name|bool
name|prepStatement
parameter_list|,
specifier|const
name|QSqlRecord
modifier|&
name|rec
parameter_list|,
specifier|const
name|QSqlRecord
modifier|&
name|whereValues
parameter_list|)
block|{
if|if
condition|(
name|stmt
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// lazy initialization of editQuery
if|if
condition|(
name|editQuery
operator|.
name|driver
argument_list|()
operator|!=
name|db
operator|.
name|driver
argument_list|()
condition|)
name|editQuery
operator|=
name|QSqlQuery
argument_list|(
name|db
argument_list|)
expr_stmt|;
comment|// workaround for In-Process databases - remove all read locks
comment|// from the table to make sure the editQuery succeeds
if|if
condition|(
name|db
operator|.
name|driver
argument_list|()
operator|->
name|hasFeature
argument_list|(
name|QSqlDriver
operator|::
name|SimpleLocking
argument_list|)
condition|)
cast|const_cast
argument_list|<
name|QSqlResult
operator|*
argument_list|>
argument_list|(
name|query
operator|.
name|result
argument_list|()
argument_list|)
operator|->
name|detachFromResultSet
argument_list|()
expr_stmt|;
if|if
condition|(
name|prepStatement
condition|)
block|{
if|if
condition|(
name|editQuery
operator|.
name|lastQuery
argument_list|()
operator|!=
name|stmt
condition|)
block|{
if|if
condition|(
operator|!
name|editQuery
operator|.
name|prepare
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|error
operator|=
name|editQuery
operator|.
name|lastError
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rec
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rec
operator|.
name|isGenerated
argument_list|(
name|i
argument_list|)
condition|)
name|editQuery
operator|.
name|addBindValue
argument_list|(
name|rec
operator|.
name|value
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|whereValues
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|whereValues
operator|.
name|isGenerated
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|whereValues
operator|.
name|isNull
argument_list|(
name|i
argument_list|)
condition|)
name|editQuery
operator|.
name|addBindValue
argument_list|(
name|whereValues
operator|.
name|value
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|editQuery
operator|.
name|exec
argument_list|()
condition|)
block|{
name|error
operator|=
name|editQuery
operator|.
name|lastError
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|editQuery
operator|.
name|exec
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|error
operator|=
name|editQuery
operator|.
name|lastError
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|primaryValues
name|QSqlRecord
name|QSqlTableModelPrivate
operator|::
name|primaryValues
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|QSqlRecord
name|record
decl_stmt|;
if|if
condition|(
operator|!
name|query
operator|.
name|seek
argument_list|(
name|row
argument_list|)
condition|)
block|{
name|error
operator|=
name|query
operator|.
name|lastError
argument_list|()
expr_stmt|;
return|return
name|record
return|;
block|}
if|if
condition|(
name|primaryIndex
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|record
operator|=
name|rec
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|record
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|record
operator|.
name|setValue
argument_list|(
name|i
argument_list|,
name|query
operator|.
name|value
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|record
operator|=
name|primaryIndex
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|record
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|record
operator|.
name|setValue
argument_list|(
name|i
argument_list|,
name|query
operator|.
name|value
argument_list|(
name|rec
operator|.
name|indexOf
argument_list|(
name|record
operator|.
name|fieldName
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|record
return|;
block|}
end_function
begin_comment
comment|/*!     \class QSqlTableModel     \brief The QSqlTableModel class provides an editable data model     for a single database table.      \ingroup database     \inmodule QtSql      QSqlTableModel is a high-level interface for reading and writing     database records from a single table. It is build on top of the     lower-level QSqlQuery and can be used to provide data to view     classes such as QTableView. For example:      \snippet doc/src/snippets/sqldatabase/sqldatabase.cpp 24      We set the SQL table's name and the edit strategy, then we set up     the labels displayed in the view header. The edit strategy     dictates when the changes done by the user in the view are     actually applied to the database. The possible values are \l     OnFieldChange, \l OnRowChange, and \l OnManualSubmit.      QSqlTableModel can also be used to access a database     programmatically, without binding it to a view:      \snippet doc/src/snippets/sqldatabase/sqldatabase.cpp 21      The code snippet above extracts the \c salary field from record 4 in     the result set of the query \c{SELECT * from employee}.      It is possible to set filters using setFilter(), or modify the     sort order using setSort(). At the end, you must call select() to     populate the model with data.      The \l{sql/tablemodel} example illustrates how to use     QSqlTableModel as the data source for a QTableView.      QSqlTableModel provides no direct support for foreign keys. Use     the QSqlRelationalTableModel and QSqlRelationalDelegate if you     want to resolve foreign keys.      \sa QSqlRelationalTableModel, QSqlQuery, {Model/View Programming},         {Table Model Example}, {Cached Table Example} */
end_comment
begin_comment
comment|/*!     \fn QSqlTableModel::beforeDelete(int row)      This signal is emitted by deleteRowFromTable() before the \a row     is deleted from the currently active database table. */
end_comment
begin_comment
comment|/*!     \fn void QSqlTableModel::primeInsert(int row, QSqlRecord&record)      This signal is emitted by insertRows(), when an insertion is     initiated in the given \a row of the currently active database     table. The \a record parameter can be written to (since it is a     reference), for example to populate some fields with default     values. */
end_comment
begin_comment
comment|/*!     \fn QSqlTableModel::beforeInsert(QSqlRecord&record)      This signal is emitted by insertRowIntoTable() before a new row is     inserted into the currently active database table. The values that     are about to be inserted are stored in \a record and can be     modified before they will be inserted. */
end_comment
begin_comment
comment|/*!     \fn QSqlTableModel::beforeUpdate(int row, QSqlRecord&record)      This signal is emitted by updateRowInTable() before the \a row is     updated in the currently active database table with the values     from \a record.      Note that only values that are marked as generated will be updated.     The generated flag can be set with \l QSqlRecord::setGenerated()     and checked with \l QSqlRecord::isGenerated().      \sa QSqlRecord::isGenerated() */
end_comment
begin_comment
comment|/*!     Creates an empty QSqlTableModel and sets the parent to \a parent     and the database connection to \a db. If \a db is not valid, the     default database connection will be used.      The default edit strategy is \l OnRowChange. */
end_comment
begin_constructor
DECL|function|QSqlTableModel
name|QSqlTableModel
operator|::
name|QSqlTableModel
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|,
name|QSqlDatabase
name|db
parameter_list|)
member_init_list|:
name|QSqlQueryModel
argument_list|(
operator|*
operator|new
name|QSqlTableModelPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|db
operator|=
name|db
operator|.
name|isValid
argument_list|()
condition|?
name|db
else|:
name|QSqlDatabase
operator|::
name|database
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!  \internal */
end_comment
begin_constructor
DECL|function|QSqlTableModel
name|QSqlTableModel
operator|::
name|QSqlTableModel
parameter_list|(
name|QSqlTableModelPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|,
name|QSqlDatabase
name|db
parameter_list|)
member_init_list|:
name|QSqlQueryModel
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|db
operator|=
name|db
operator|.
name|isValid
argument_list|()
condition|?
name|db
else|:
name|QSqlDatabase
operator|::
name|database
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the object and frees any allocated resources. */
end_comment
begin_destructor
DECL|function|~QSqlTableModel
name|QSqlTableModel
operator|::
name|~
name|QSqlTableModel
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Sets the database table on which the model operates to \a     tableName. Does not select data from the table, but fetches its     field information.      To populate the model with the table's data, call select().      Error information can be retrieved with \l lastError().      \sa select(), setFilter(), lastError() */
end_comment
begin_function
DECL|function|setTable
name|void
name|QSqlTableModel
operator|::
name|setTable
parameter_list|(
specifier|const
name|QString
modifier|&
name|tableName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|tableName
operator|=
name|tableName
expr_stmt|;
name|d
operator|->
name|initRecordAndPrimaryIndex
argument_list|()
expr_stmt|;
name|d
operator|->
name|initColOffsets
argument_list|(
name|d
operator|->
name|rec
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rec
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
name|d
operator|->
name|error
operator|=
name|QSqlError
argument_list|(
name|QLatin1String
argument_list|(
literal|"Unable to find table "
argument_list|)
operator|+
name|d
operator|->
name|tableName
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the currently selected table. */
end_comment
begin_function
DECL|function|tableName
name|QString
name|QSqlTableModel
operator|::
name|tableName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|tableName
return|;
block|}
end_function
begin_comment
comment|/*!     Populates the model with data from the table that was set via setTable(), using the     specified filter and sort condition, and returns true if successful; otherwise     returns false.      \note Calling select() will revert any unsubmitted changes and remove any inserted columns.      \sa setTable(), setFilter(), selectStatement() */
end_comment
begin_function
DECL|function|select
name|bool
name|QSqlTableModel
operator|::
name|select
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|QString
name|query
init|=
name|selectStatement
argument_list|()
decl_stmt|;
if|if
condition|(
name|query
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|revertAll
argument_list|()
expr_stmt|;
name|QSqlQuery
name|qu
argument_list|(
name|query
argument_list|,
name|d
operator|->
name|db
argument_list|)
decl_stmt|;
name|setQuery
argument_list|(
name|qu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qu
operator|.
name|isActive
argument_list|()
operator|||
name|lastError
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// something went wrong - revert to non-select state
name|d
operator|->
name|initRecordAndPrimaryIndex
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|data
name|QVariant
name|QSqlTableModel
operator|::
name|data
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|int
name|role
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
operator|||
operator|(
name|role
operator|!=
name|Qt
operator|::
name|DisplayRole
operator|&&
name|role
operator|!=
name|Qt
operator|::
name|EditRole
operator|)
condition|)
return|return
name|QVariant
argument_list|()
return|;
comment|// Problem.. we need to use QSQM::indexInQuery to handle inserted columns
comment|// but inserted rows we need to handle
comment|// and indexInQuery is not virtual (grrr) so any values we pass to QSQM need
comment|// to handle the insertedRows
name|QModelIndex
name|item
init|=
name|indexInQuery
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|cache
operator|.
name|contains
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
condition|)
block|{
specifier|const
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
name|row
init|=
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|strategy
condition|)
block|{
case|case
name|OnFieldChange
case|:
case|case
name|OnRowChange
case|:
if|if
condition|(
name|row
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
block|{
if|if
condition|(
name|item
operator|.
name|column
argument_list|()
operator|<
literal|0
operator|||
name|item
operator|.
name|column
argument_list|()
operator|>=
name|row
operator|.
name|rec
argument_list|()
operator|.
name|count
argument_list|()
condition|)
return|return
name|QVariant
argument_list|()
return|;
return|return
name|row
operator|.
name|rec
argument_list|()
operator|.
name|value
argument_list|(
name|item
operator|.
name|column
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|row
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Update
condition|)
block|{
if|if
condition|(
name|row
operator|.
name|rec
argument_list|()
operator|.
name|isGenerated
argument_list|(
name|item
operator|.
name|column
argument_list|()
argument_list|)
condition|)
return|return
name|row
operator|.
name|rec
argument_list|()
operator|.
name|value
argument_list|(
name|item
operator|.
name|column
argument_list|()
argument_list|)
return|;
block|}
break|break;
case|case
name|OnManualSubmit
case|:
if|if
condition|(
name|row
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Insert
operator|||
operator|(
name|row
operator|.
name|op
argument_list|()
operator|!=
name|QSqlTableModelPrivate
operator|::
name|None
operator|&&
name|row
operator|.
name|rec
argument_list|()
operator|.
name|isGenerated
argument_list|(
name|item
operator|.
name|column
argument_list|()
argument_list|)
operator|)
condition|)
return|return
name|row
operator|.
name|rec
argument_list|()
operator|.
name|value
argument_list|(
name|item
operator|.
name|column
argument_list|()
argument_list|)
return|;
break|break;
block|}
block|}
comment|// We need to handle row mapping here, but not column mapping
return|return
name|QSqlQueryModel
operator|::
name|data
argument_list|(
name|index
operator|.
name|sibling
argument_list|(
name|item
operator|.
name|row
argument_list|()
argument_list|,
name|index
operator|.
name|column
argument_list|()
argument_list|)
argument_list|,
name|role
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|headerData
name|QVariant
name|QSqlTableModel
operator|::
name|headerData
parameter_list|(
name|int
name|section
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|,
name|int
name|role
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Vertical
operator|&&
name|role
operator|==
name|Qt
operator|::
name|DisplayRole
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|cache
operator|.
name|contains
argument_list|(
name|section
argument_list|)
condition|)
block|{
specifier|const
name|QSqlTableModelPrivate
operator|::
name|Op
name|op
init|=
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|section
argument_list|)
operator|.
name|op
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
return|return
name|QLatin1String
argument_list|(
literal|"*"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op
operator|==
name|QSqlTableModelPrivate
operator|::
name|Delete
condition|)
return|return
name|QLatin1String
argument_list|(
literal|"!"
argument_list|)
return|;
block|}
block|}
return|return
name|QSqlQueryModel
operator|::
name|headerData
argument_list|(
name|section
argument_list|,
name|orientation
argument_list|,
name|role
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the value at the index \a index is dirty, otherwise false.     Dirty values are values that were modified in the model     but not yet written into the database.      If \a index is invalid or points to a non-existing row, false is returned. */
end_comment
begin_function
DECL|function|isDirty
name|bool
name|QSqlTableModel
operator|::
name|isDirty
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
switch|switch
condition|(
name|d
operator|->
name|strategy
condition|)
block|{
case|case
name|OnFieldChange
case|:
return|return
literal|false
return|;
case|case
name|OnRowChange
case|:
block|{
specifier|const
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
name|row
init|=
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|row
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Update
operator|&&
name|row
operator|.
name|rec
argument_list|()
operator|.
name|isGenerated
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
return|;
block|}
case|case
name|OnManualSubmit
case|:
block|{
specifier|const
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
name|row
init|=
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|row
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Insert
operator|||
name|row
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Delete
operator|||
operator|(
name|row
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Update
operator|&&
name|row
operator|.
name|rec
argument_list|()
operator|.
name|isGenerated
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
operator|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the data for the item \a index for the role \a role to \a     value. Depending on the edit strategy, the value might be applied     to the database at once or cached in the model.      Returns true if the value could be set or false on error, for     example if \a index is out of bounds.      \sa editStrategy(), data(), submit(), submitAll(), revertRow() */
end_comment
begin_function
DECL|function|setData
name|bool
name|QSqlTableModel
operator|::
name|setData
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|,
name|int
name|role
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|role
operator|!=
name|Qt
operator|::
name|EditRole
condition|)
return|return
name|QSqlQueryModel
operator|::
name|setData
argument_list|(
name|index
argument_list|,
name|value
argument_list|,
name|role
argument_list|)
return|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
operator|||
name|index
operator|.
name|column
argument_list|()
operator|>=
name|d
operator|->
name|rec
operator|.
name|count
argument_list|()
operator|||
name|index
operator|.
name|row
argument_list|()
operator|>=
name|rowCount
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnFieldChange
operator|&&
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
operator|.
name|op
argument_list|()
operator|!=
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
block|{
name|d
operator|->
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnRowChange
operator|&&
operator|!
name|d
operator|->
name|cache
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|cache
operator|.
name|contains
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
condition|)
block|{
name|submit
argument_list|()
expr_stmt|;
name|d
operator|->
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
modifier|&
name|row
init|=
name|d
operator|->
name|cache
index|[
name|index
operator|.
name|row
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|row
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|None
condition|)
block|{
name|row
operator|=
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
argument_list|(
name|QSqlTableModelPrivate
operator|::
name|Update
argument_list|,
name|d
operator|->
name|rec
argument_list|,
name|d
operator|->
name|primaryValues
argument_list|(
name|indexInQuery
argument_list|(
name|index
argument_list|)
operator|.
name|row
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|row
operator|.
name|setValue
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|bool
name|isOk
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnFieldChange
operator|&&
name|row
operator|.
name|op
argument_list|()
operator|!=
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
block|{
comment|// historical bug: bad style to call updateRowInTable.
comment|// Should call submit(), but maybe the author wanted to avoid
comment|// clearing the cache on failure.
name|isOk
operator|=
name|updateRowInTable
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|,
name|row
operator|.
name|rec
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOk
condition|)
name|select
argument_list|()
expr_stmt|;
block|}
comment|// historical bug: dataChanged() is suppressed for OnFieldChange and OnRowChange
comment|// when operating on an "insert" record. This is to accomodate
comment|// applications that call setData() while handling primeInsert().
comment|// Otherwise dataChanged() would be emitted between beginInsert()
comment|// and endInsert().
comment|// The price of this workaround is that, although the view making
comment|// the change will already display the new value, other views connected
comment|// to the model probably will not.
comment|// It's not clear why OnManualSubmit is excluded from this workaround.
comment|// Calling setData() while handling primeInsert() is arguably very wrong anyway.
comment|// primeInsert() provides a ref to the record for settings values.
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnManualSubmit
operator|||
name|row
operator|.
name|op
argument_list|()
operator|!=
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
emit|emit
name|dataChanged
argument_list|(
name|index
argument_list|,
name|index
argument_list|)
emit|;
return|return
name|isOk
return|;
block|}
end_function
begin_comment
comment|/*!     This function simply calls QSqlQueryModel::setQuery(\a query).     You should normally not call it on a QSqlTableModel. Instead, use     setTable(), setSort(), setFilter(), etc., to set up the query.      \sa selectStatement() */
end_comment
begin_function
DECL|function|setQuery
name|void
name|QSqlTableModel
operator|::
name|setQuery
parameter_list|(
specifier|const
name|QSqlQuery
modifier|&
name|query
parameter_list|)
block|{
name|QSqlQueryModel
operator|::
name|setQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Updates the given \a row in the currently active database table     with the specified \a values. Returns true if successful; otherwise     returns false.      This is a low-level method that operates directly on the database     and should not be called directly. Use setData() to update values.     The model will decide depending on its edit strategy when to modify     the database.      Note that only values that have the generated-flag set are updated.     The generated-flag can be set with QSqlRecord::setGenerated() and     tested with QSqlRecord::isGenerated().      \sa QSqlRecord::isGenerated(), setData() */
end_comment
begin_function
DECL|function|updateRowInTable
name|bool
name|QSqlTableModel
operator|::
name|updateRowInTable
parameter_list|(
name|int
name|row
parameter_list|,
specifier|const
name|QSqlRecord
modifier|&
name|values
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|QSqlRecord
name|rec
argument_list|(
name|values
argument_list|)
decl_stmt|;
emit|emit
name|beforeUpdate
argument_list|(
name|row
argument_list|,
name|rec
argument_list|)
emit|;
specifier|const
name|QSqlRecord
name|whereValues
init|=
name|d
operator|->
name|strategy
operator|==
name|OnManualSubmit
condition|?
name|d
operator|->
name|cache
index|[
name|row
index|]
operator|.
name|primaryValues
argument_list|()
else|:
name|d
operator|->
name|primaryValues
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|bool
name|prepStatement
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|hasFeature
argument_list|(
name|QSqlDriver
operator|::
name|PreparedQueries
argument_list|)
decl_stmt|;
name|QString
name|stmt
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|sqlStatement
argument_list|(
name|QSqlDriver
operator|::
name|UpdateStatement
argument_list|,
name|d
operator|->
name|tableName
argument_list|,
name|rec
argument_list|,
name|prepStatement
argument_list|)
decl_stmt|;
name|QString
name|where
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|sqlStatement
argument_list|(
name|QSqlDriver
operator|::
name|WhereStatement
argument_list|,
name|d
operator|->
name|tableName
argument_list|,
name|whereValues
argument_list|,
name|prepStatement
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|.
name|isEmpty
argument_list|()
operator|||
name|where
operator|.
name|isEmpty
argument_list|()
operator|||
name|row
operator|<
literal|0
operator|||
name|row
operator|>=
name|rowCount
argument_list|()
condition|)
block|{
name|d
operator|->
name|error
operator|=
name|QSqlError
argument_list|(
name|QLatin1String
argument_list|(
literal|"No Fields to update"
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|stmt
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|where
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|exec
argument_list|(
name|stmt
argument_list|,
name|prepStatement
argument_list|,
name|rec
argument_list|,
name|whereValues
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts the values \a values into the currently active database table.      This is a low-level method that operates directly on the database     and should not be called directly. Use insertRow() and setData()     to insert values. The model will decide depending on its edit strategy     when to modify the database.      Returns true if the values could be inserted, otherwise false.     Error information can be retrieved with \l lastError().      \sa lastError(), insertRow(), insertRows() */
end_comment
begin_function
DECL|function|insertRowIntoTable
name|bool
name|QSqlTableModel
operator|::
name|insertRowIntoTable
parameter_list|(
specifier|const
name|QSqlRecord
modifier|&
name|values
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|QSqlRecord
name|rec
init|=
name|values
decl_stmt|;
emit|emit
name|beforeInsert
argument_list|(
name|rec
argument_list|)
emit|;
name|bool
name|prepStatement
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|hasFeature
argument_list|(
name|QSqlDriver
operator|::
name|PreparedQueries
argument_list|)
decl_stmt|;
name|QString
name|stmt
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|sqlStatement
argument_list|(
name|QSqlDriver
operator|::
name|InsertStatement
argument_list|,
name|d
operator|->
name|tableName
argument_list|,
name|rec
argument_list|,
name|prepStatement
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|error
operator|=
name|QSqlError
argument_list|(
name|QLatin1String
argument_list|(
literal|"No Fields to update"
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|exec
argument_list|(
name|stmt
argument_list|,
name|prepStatement
argument_list|,
name|rec
argument_list|,
name|QSqlRecord
argument_list|()
comment|/* no where values */
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Deletes the given \a row from the currently active database table.      This is a low-level method that operates directly on the database     and should not be called directly. Use removeRow() or removeRows()     to delete values. The model will decide depending on its edit strategy     when to modify the database.      Returns true if the row was deleted; otherwise returns false.      \sa removeRow(), removeRows() */
end_comment
begin_function
DECL|function|deleteRowFromTable
name|bool
name|QSqlTableModel
operator|::
name|deleteRowFromTable
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
emit|emit
name|beforeDelete
argument_list|(
name|row
argument_list|)
emit|;
specifier|const
name|QSqlRecord
name|whereValues
init|=
name|d
operator|->
name|strategy
operator|==
name|OnManualSubmit
condition|?
name|d
operator|->
name|cache
index|[
name|row
index|]
operator|.
name|primaryValues
argument_list|()
else|:
name|d
operator|->
name|primaryValues
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|bool
name|prepStatement
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|hasFeature
argument_list|(
name|QSqlDriver
operator|::
name|PreparedQueries
argument_list|)
decl_stmt|;
name|QString
name|stmt
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|sqlStatement
argument_list|(
name|QSqlDriver
operator|::
name|DeleteStatement
argument_list|,
name|d
operator|->
name|tableName
argument_list|,
name|QSqlRecord
argument_list|()
argument_list|,
name|prepStatement
argument_list|)
decl_stmt|;
name|QString
name|where
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|sqlStatement
argument_list|(
name|QSqlDriver
operator|::
name|WhereStatement
argument_list|,
name|d
operator|->
name|tableName
argument_list|,
name|whereValues
argument_list|,
name|prepStatement
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|.
name|isEmpty
argument_list|()
operator|||
name|where
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|error
operator|=
name|QSqlError
argument_list|(
name|QLatin1String
argument_list|(
literal|"Unable to delete row"
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|stmt
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|where
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|exec
argument_list|(
name|stmt
argument_list|,
name|prepStatement
argument_list|,
name|QSqlRecord
argument_list|()
comment|/* no new values */
argument_list|,
name|whereValues
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Submits all pending changes and returns true on success.     Returns false on error, detailed error information can be     obtained with lastError().      On success the model will be repopulated. Any views      presenting it will lose their selections.      Note: In OnManualSubmit mode, already submitted changes won't     be cleared from the cache when submitAll() fails. This allows     transactions to be rolled back and resubmitted again without     losing data.      \sa revertAll(), lastError() */
end_comment
begin_function
DECL|function|submitAll
name|bool
name|QSqlTableModel
operator|::
name|submitAll
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
for|for
control|(
name|QSqlTableModelPrivate
operator|::
name|CacheMap
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|cache
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|d
operator|->
name|cache
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
switch|switch
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|op
argument_list|()
condition|)
block|{
case|case
name|QSqlTableModelPrivate
operator|::
name|Insert
case|:
if|if
condition|(
operator|!
name|insertRowIntoTable
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|rec
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|bottom
operator|=
name|d
operator|->
name|bottom
operator|.
name|sibling
argument_list|(
name|d
operator|->
name|bottom
operator|.
name|row
argument_list|()
operator|+
literal|1
argument_list|,
name|d
operator|->
name|bottom
operator|.
name|column
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSqlTableModelPrivate
operator|::
name|Update
case|:
if|if
condition|(
operator|!
name|updateRowInTable
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
operator|.
name|rec
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
break|break;
case|case
name|QSqlTableModelPrivate
operator|::
name|Delete
case|:
if|if
condition|(
operator|!
name|deleteRowFromTable
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
break|break;
case|case
name|QSqlTableModelPrivate
operator|::
name|None
case|:
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QSqlTableModel::submitAll()"
argument_list|,
literal|"Invalid cache operation"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|d
operator|->
name|clearCache
argument_list|()
expr_stmt|;
return|return
name|select
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     This reimplemented slot is called by the item delegates when the     user stopped editing the current row.      Submits the currently edited row if the model's strategy is set     to OnRowChange or OnFieldChange. Does nothing for the OnManualSubmit     strategy.      Use submitAll() to submit all pending changes for the     OnManualSubmit strategy.      Returns true on success; otherwise returns false. Use lastError()     to query detailed error information.      On success the model will be repopulated. Any views      presenting it will lose their selections.      \sa revert(), revertRow(), submitAll(), revertAll(), lastError() */
end_comment
begin_function
DECL|function|submit
name|bool
name|QSqlTableModel
operator|::
name|submit
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnRowChange
operator|||
name|d
operator|->
name|strategy
operator|==
name|OnFieldChange
condition|)
return|return
name|submitAll
argument_list|()
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     This reimplemented slot is called by the item delegates when the     user canceled editing the current row.      Reverts the changes if the model's strategy is set to     OnRowChange. Does nothing for the other edit strategies.      Use revertAll() to revert all pending changes for the     OnManualSubmit strategy or revertRow() to revert a specific row.      \sa submit(), submitAll(), revertRow(), revertAll() */
end_comment
begin_function
DECL|function|revert
name|void
name|QSqlTableModel
operator|::
name|revert
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnRowChange
condition|)
name|revertAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \enum QSqlTableModel::EditStrategy      This enum type describes which strategy to choose when editing values in the database.      \value OnFieldChange  All changes to the model will be applied immediately to the database.     \value OnRowChange  Changes to a row will be applied when the user selects a different row.     \value OnManualSubmit  All changes will be cached in the model until either submitAll()                            or revertAll() is called.      Note: To prevent inserting only partly initialized rows into the database,     \c OnFieldChange will behave like \c OnRowChange for newly inserted rows.      \sa setEditStrategy() */
end_comment
begin_comment
comment|/*!     Sets the strategy for editing values in the database to \a     strategy.      This will revert any pending changes.      \sa editStrategy(), revertAll() */
end_comment
begin_function
DECL|function|setEditStrategy
name|void
name|QSqlTableModel
operator|::
name|setEditStrategy
parameter_list|(
name|EditStrategy
name|strategy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|revertAll
argument_list|()
expr_stmt|;
name|d
operator|->
name|strategy
operator|=
name|strategy
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current edit strategy.      \sa setEditStrategy() */
end_comment
begin_function
DECL|function|editStrategy
name|QSqlTableModel
operator|::
name|EditStrategy
name|QSqlTableModel
operator|::
name|editStrategy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|strategy
return|;
block|}
end_function
begin_comment
comment|/*!     Reverts all pending changes.      \sa revert(), revertRow(), submitAll() */
end_comment
begin_function
DECL|function|revertAll
name|void
name|QSqlTableModel
operator|::
name|revertAll
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|d
operator|->
name|cache
operator|.
name|isEmpty
argument_list|()
condition|)
name|revertRow
argument_list|(
name|d
operator|->
name|cache
operator|.
name|constBegin
argument_list|()
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Reverts all changes for the specified \a row.      \sa revert(), revertAll(), submit(), submitAll() */
end_comment
begin_function
DECL|function|revertRow
name|void
name|QSqlTableModel
operator|::
name|revertRow
parameter_list|(
name|int
name|row
parameter_list|)
block|{
if|if
condition|(
name|row
operator|<
literal|0
condition|)
return|return;
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|revertCachedRow
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the primary key for the current table, or an empty     QSqlIndex if the table is not set or has no primary key.      \sa setTable(), setPrimaryKey(), QSqlDatabase::primaryIndex() */
end_comment
begin_function
DECL|function|primaryKey
name|QSqlIndex
name|QSqlTableModel
operator|::
name|primaryKey
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|primaryIndex
return|;
block|}
end_function
begin_comment
comment|/*!     Protected method that allows subclasses to set the primary key to     \a key.      Normally, the primary index is set automatically whenever you     call setTable().      \sa primaryKey(), QSqlDatabase::primaryIndex() */
end_comment
begin_function
DECL|function|setPrimaryKey
name|void
name|QSqlTableModel
operator|::
name|setPrimaryKey
parameter_list|(
specifier|const
name|QSqlIndex
modifier|&
name|key
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|primaryIndex
operator|=
name|key
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the used QSqlDatabase or 0 if no database was set. */
end_comment
begin_function
DECL|function|database
name|QSqlDatabase
name|QSqlTableModel
operator|::
name|database
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|db
return|;
block|}
end_function
begin_comment
comment|/*!     Sorts the data by \a column with the sort order \a order.     This will immediately select data, use setSort()     to set a sort order without populating the model with data.      \sa setSort(), select(), orderByClause() */
end_comment
begin_function
DECL|function|sort
name|void
name|QSqlTableModel
operator|::
name|sort
parameter_list|(
name|int
name|column
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|)
block|{
name|setSort
argument_list|(
name|column
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|select
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the sort order for \a column to \a order. This does not     affect the current data, to refresh the data using the new     sort order, call select().      \sa select(), orderByClause() */
end_comment
begin_function
DECL|function|setSort
name|void
name|QSqlTableModel
operator|::
name|setSort
parameter_list|(
name|int
name|column
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|sortColumn
operator|=
name|column
expr_stmt|;
name|d
operator|->
name|sortOrder
operator|=
name|order
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns an SQL \c{ORDER BY} clause based on the currently set     sort order.      \sa setSort(), selectStatement() */
end_comment
begin_function
DECL|function|orderByClause
name|QString
name|QSqlTableModel
operator|::
name|orderByClause
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|QString
name|s
decl_stmt|;
name|QSqlField
name|f
init|=
name|d
operator|->
name|rec
operator|.
name|field
argument_list|(
name|d
operator|->
name|sortColumn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|s
return|;
name|QString
name|table
init|=
name|d
operator|->
name|tableName
decl_stmt|;
comment|//we can safely escape the field because it would have been obtained from the database
comment|//and have the correct case
name|QString
name|field
init|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|escapeIdentifier
argument_list|(
name|f
operator|.
name|name
argument_list|()
argument_list|,
name|QSqlDriver
operator|::
name|FieldName
argument_list|)
decl_stmt|;
name|s
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"ORDER BY "
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|table
argument_list|)
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|s
operator|+=
name|d
operator|->
name|sortOrder
operator|==
name|Qt
operator|::
name|AscendingOrder
condition|?
name|QLatin1String
argument_list|(
literal|" ASC"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|" DESC"
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the index of the field \a fieldName, or -1 if no corresponding field     exists in the model. */
end_comment
begin_function
DECL|function|fieldIndex
name|int
name|QSqlTableModel
operator|::
name|fieldIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|fieldName
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|rec
operator|.
name|indexOf
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the SQL \c SELECT statement used internally to populate     the model. The statement includes the filter and the \c{ORDER BY}     clause.      \sa filter(), orderByClause() */
end_comment
begin_function
DECL|function|selectStatement
name|QString
name|QSqlTableModel
operator|::
name|selectStatement
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|QString
name|query
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|tableName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|error
operator|=
name|QSqlError
argument_list|(
name|QLatin1String
argument_list|(
literal|"No table name given"
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|)
expr_stmt|;
return|return
name|query
return|;
block|}
if|if
condition|(
name|d
operator|->
name|rec
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|error
operator|=
name|QSqlError
argument_list|(
name|QLatin1String
argument_list|(
literal|"Unable to find table "
argument_list|)
operator|+
name|d
operator|->
name|tableName
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|)
expr_stmt|;
return|return
name|query
return|;
block|}
name|query
operator|=
name|d
operator|->
name|db
operator|.
name|driver
argument_list|()
operator|->
name|sqlStatement
argument_list|(
name|QSqlDriver
operator|::
name|SelectStatement
argument_list|,
name|d
operator|->
name|tableName
argument_list|,
name|d
operator|->
name|rec
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|error
operator|=
name|QSqlError
argument_list|(
name|QLatin1String
argument_list|(
literal|"Unable to select fields from table "
argument_list|)
operator|+
name|d
operator|->
name|tableName
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|)
expr_stmt|;
return|return
name|query
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|filter
operator|.
name|isEmpty
argument_list|()
condition|)
name|query
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|" WHERE "
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|d
operator|->
name|filter
argument_list|)
expr_stmt|;
name|QString
name|orderBy
argument_list|(
name|orderByClause
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|orderBy
operator|.
name|isEmpty
argument_list|()
condition|)
name|query
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|orderBy
argument_list|)
expr_stmt|;
return|return
name|query
return|;
block|}
end_function
begin_comment
comment|/*!     Removes \a count columns from the \a parent model, starting at     index \a column.      Returns if the columns were successfully removed; otherwise     returns false.      \sa removeRows() */
end_comment
begin_function
DECL|function|removeColumns
name|bool
name|QSqlTableModel
operator|::
name|removeColumns
parameter_list|(
name|int
name|column
parameter_list|,
name|int
name|count
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
operator|||
name|column
argument_list|<
literal|0
operator|||
name|column
operator|+
name|count
argument_list|>
name|d
operator|->
name|rec
operator|.
name|count
argument_list|()
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|rec
operator|.
name|remove
argument_list|(
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|query
operator|.
name|isActive
argument_list|()
condition|)
return|return
name|select
argument_list|()
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Removes \a count rows starting at \a row. Since this model     does not support hierarchical structures, \a parent must be     an invalid model index.      Emits the beforeDelete() signal before a row is deleted. When     the edit strategy is OnManualSubmit signal emission is delayed     until submitAll() is called.      Returns true if all rows could be removed; otherwise returns     false. Detailed error information can be retrieved using     lastError().      \sa removeColumns(), insertRows() */
end_comment
begin_function
DECL|function|removeRows
name|bool
name|QSqlTableModel
operator|::
name|removeRows
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|count
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
operator|||
name|row
operator|<
literal|0
operator|||
name|count
operator|<=
literal|0
condition|)
return|return
literal|false
return|;
name|int
name|initialRowCount
init|=
name|rowCount
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
operator|&&
name|row
operator|+
name|i
operator|<
name|rowCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|idx
init|=
name|row
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|idx
argument_list|)
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
block|{
name|revertRow
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|// Reverting a row means all the other cache entries have been adjusted downwards
comment|// so fake this by adjusting row
operator|--
name|row
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|cache
index|[
name|idx
index|]
operator|=
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
argument_list|(
name|QSqlTableModelPrivate
operator|::
name|Delete
argument_list|,
name|QSqlRecord
argument_list|()
argument_list|,
name|d
operator|->
name|primaryValues
argument_list|(
name|indexInQuery
argument_list|(
name|createIndex
argument_list|(
name|idx
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|.
name|row
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnManualSubmit
condition|)
emit|emit
name|headerDataChanged
argument_list|(
name|Qt
operator|::
name|Vertical
argument_list|,
name|idx
argument_list|,
name|idx
argument_list|)
emit|;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|strategy
operator|!=
name|OnManualSubmit
operator|&&
name|i
operator|>
literal|0
condition|)
name|submit
argument_list|()
expr_stmt|;
comment|// historical bug: emit beforeDelete for 1st row beyond end
if|if
condition|(
name|d
operator|->
name|strategy
operator|!=
name|OnManualSubmit
condition|)
block|{
if|if
condition|(
name|row
operator|+
name|count
operator|>
name|initialRowCount
condition|)
emit|emit
name|beforeDelete
argument_list|(
name|qMax
argument_list|(
name|initialRowCount
argument_list|,
name|row
argument_list|)
argument_list|)
emit|;
block|}
if|if
condition|(
name|i
operator|<
name|count
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts \a count empty rows at position \a row. Note that \a     parent must be invalid, since this model does not support     parent-child relations.      Only one row at a time can be inserted when using the     OnFieldChange or OnRowChange update strategies.      The primeInsert() signal will be emitted for each new row.     Connect to it if you want to initialize the new row with default     values.      Returns false if the parameters are out of bounds; otherwise     returns true.      \sa primeInsert(), insertRecord() */
end_comment
begin_function
DECL|function|insertRows
name|bool
name|QSqlTableModel
operator|::
name|insertRows
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|count
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
argument_list|<
literal|0
operator|||
name|count
operator|<=
literal|0
operator|||
name|row
argument_list|>
name|rowCount
argument_list|()
operator|||
name|parent
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|!=
name|OnManualSubmit
operator|&&
name|count
operator|!=
literal|1
condition|)
return|return
literal|false
return|;
name|beginInsertRows
argument_list|(
name|parent
argument_list|,
name|row
argument_list|,
name|row
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|!=
name|OnManualSubmit
condition|)
name|d
operator|->
name|cache
operator|.
name|empty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|cache
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QMap
argument_list|<
name|int
argument_list|,
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|cache
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|cache
operator|.
name|begin
argument_list|()
operator|&&
operator|(
operator|--
name|it
operator|)
operator|.
name|key
argument_list|()
operator|>=
name|row
condition|)
block|{
name|int
name|oldKey
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
specifier|const
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
name|oldValue
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|d
operator|->
name|cache
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|it
operator|=
name|d
operator|->
name|cache
operator|.
name|insert
argument_list|(
name|oldKey
operator|+
name|count
argument_list|,
name|oldValue
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|->
name|cache
index|[
name|row
operator|+
name|i
index|]
operator|=
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
argument_list|(
name|QSqlTableModelPrivate
operator|::
name|Insert
argument_list|,
name|d
operator|->
name|rec
argument_list|)
expr_stmt|;
emit|emit
name|primeInsert
argument_list|(
name|row
operator|+
name|i
argument_list|,
name|d
operator|->
name|cache
index|[
name|row
operator|+
name|i
index|]
operator|.
name|recRef
argument_list|()
argument_list|)
emit|;
block|}
name|endInsertRows
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts the \a record after \a row. If \a row is negative, the     record will be appended to the end. Calls insertRows() and     setRecord() internally.      Returns true if the row could be inserted, otherwise false.      \sa insertRows(), removeRows() */
end_comment
begin_function
DECL|function|insertRecord
name|bool
name|QSqlTableModel
operator|::
name|insertRecord
parameter_list|(
name|int
name|row
parameter_list|,
specifier|const
name|QSqlRecord
modifier|&
name|record
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|<
literal|0
condition|)
name|row
operator|=
name|rowCount
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|insertRow
argument_list|(
name|row
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|setRecord
argument_list|(
name|row
argument_list|,
name|record
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnFieldChange
operator|||
name|d
operator|->
name|strategy
operator|==
name|OnRowChange
condition|)
return|return
name|submit
argument_list|()
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|rowCount
name|int
name|QSqlTableModel
operator|::
name|rowCount
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|rc
init|=
name|QSqlQueryModel
operator|::
name|rowCount
argument_list|()
decl_stmt|;
for|for
control|(
name|QSqlTableModelPrivate
operator|::
name|CacheMap
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|cache
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|d
operator|->
name|cache
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
operator|++
name|rc
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the index of the value in the database result set for the     given \a item in the model.      The return value is identical to \a item if no columns or rows     have been inserted, removed, or moved around.      Returns an invalid model index if \a item is out of bounds or if     \a item does not point to a value in the result set.      \sa QSqlQueryModel::indexInQuery() */
end_comment
begin_function
DECL|function|indexInQuery
name|QModelIndex
name|QSqlTableModel
operator|::
name|indexInQuery
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|item
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
specifier|const
name|QModelIndex
name|it
init|=
name|QSqlQueryModel
operator|::
name|indexInQuery
argument_list|(
name|item
argument_list|)
decl_stmt|;
comment|// this adjusts columns only
name|int
name|rowOffset
init|=
literal|0
decl_stmt|;
name|QSqlTableModelPrivate
operator|::
name|CacheMap
operator|::
name|ConstIterator
name|i
init|=
name|d
operator|->
name|cache
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|d
operator|->
name|cache
operator|.
name|constEnd
argument_list|()
operator|&&
name|i
operator|.
name|key
argument_list|()
operator|<=
name|it
operator|.
name|row
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
operator|++
name|rowOffset
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return
name|createIndex
argument_list|(
name|it
operator|.
name|row
argument_list|()
operator|-
name|rowOffset
argument_list|,
name|it
operator|.
name|column
argument_list|()
argument_list|,
name|it
operator|.
name|internalPointer
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the currently set filter.      \sa setFilter(), select() */
end_comment
begin_function
DECL|function|filter
name|QString
name|QSqlTableModel
operator|::
name|filter
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|filter
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the current filter to \a filter.      The filter is a SQL \c WHERE clause without the keyword \c WHERE     (for example, \c{name='Josephine')}.      If the model is already populated with data from a database,     the model re-selects it with the new filter. Otherwise, the filter     will be applied the next time select() is called.      \sa filter(), select(), selectStatement(), orderByClause() */
end_comment
begin_function
DECL|function|setFilter
name|void
name|QSqlTableModel
operator|::
name|setFilter
parameter_list|(
specifier|const
name|QString
modifier|&
name|filter
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|filter
operator|=
name|filter
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|query
operator|.
name|isActive
argument_list|()
condition|)
name|select
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|clear
name|void
name|QSqlTableModel
operator|::
name|clear
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
name|QSqlQueryModel
operator|::
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|flags
name|Qt
operator|::
name|ItemFlags
name|QSqlTableModel
operator|::
name|flags
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSqlTableModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|.
name|internalPointer
argument_list|()
operator|||
name|index
operator|.
name|column
argument_list|()
operator|<
literal|0
operator|||
name|index
operator|.
name|column
argument_list|()
operator|>=
name|d
operator|->
name|rec
operator|.
name|count
argument_list|()
operator|||
name|index
operator|.
name|row
argument_list|()
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d
operator|->
name|rec
operator|.
name|field
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
operator|.
name|isReadOnly
argument_list|()
condition|)
return|return
name|Qt
operator|::
name|ItemIsSelectable
operator||
name|Qt
operator|::
name|ItemIsEnabled
return|;
return|return
name|Qt
operator|::
name|ItemIsSelectable
operator||
name|Qt
operator|::
name|ItemIsEnabled
operator||
name|Qt
operator|::
name|ItemIsEditable
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the values at the specified \a row to the values of \a     record. Returns true if all the values could be set; otherwise     returns false.      \sa record() */
end_comment
begin_function
DECL|function|setRecord
name|bool
name|QSqlTableModel
operator|::
name|setRecord
parameter_list|(
name|int
name|row
parameter_list|,
specifier|const
name|QSqlRecord
modifier|&
name|record
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSqlTableModel
argument_list|)
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
name|row
operator|>=
literal|0
argument_list|,
literal|"QSqlTableModel::setRecord()"
argument_list|,
literal|"Cannot set a record to a row less than 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|>=
name|rowCount
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnFieldChange
operator|&&
name|d
operator|->
name|cache
operator|.
name|value
argument_list|(
name|row
argument_list|)
operator|.
name|op
argument_list|()
operator|!=
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
name|d
operator|->
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnRowChange
operator|&&
operator|!
name|d
operator|->
name|cache
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|cache
operator|.
name|contains
argument_list|(
name|row
argument_list|)
condition|)
name|submit
argument_list|()
expr_stmt|;
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
modifier|&
name|mrow
init|=
name|d
operator|->
name|cache
index|[
name|row
index|]
decl_stmt|;
if|if
condition|(
name|mrow
operator|.
name|op
argument_list|()
operator|==
name|QSqlTableModelPrivate
operator|::
name|None
condition|)
name|mrow
operator|=
name|QSqlTableModelPrivate
operator|::
name|ModifiedRow
argument_list|(
name|QSqlTableModelPrivate
operator|::
name|Update
argument_list|,
name|d
operator|->
name|rec
argument_list|,
name|d
operator|->
name|primaryValues
argument_list|(
name|indexInQuery
argument_list|(
name|createIndex
argument_list|(
name|row
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|.
name|row
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|isOk
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|record
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|idx
init|=
name|d
operator|->
name|nameToIndex
argument_list|(
name|record
operator|.
name|fieldName
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
name|isOk
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|strategy
operator|!=
name|OnManualSubmit
condition|)
block|{
comment|// historical bug: this could all be simple like OnManualSubmit, but isn't
specifier|const
name|QModelIndex
name|cIndex
init|=
name|createIndex
argument_list|(
name|row
argument_list|,
name|idx
argument_list|)
decl_stmt|;
comment|// historical bug: comparing EditRole with DisplayRole values here
specifier|const
name|QVariant
name|oldValue
init|=
name|data
argument_list|(
name|cIndex
argument_list|)
decl_stmt|;
specifier|const
name|QVariant
name|value
init|=
name|record
operator|.
name|value
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// historical bug: it's a bad idea to check for change here
comment|// historical bug: should test oldValue.isNull() != value.isNull()
if|if
condition|(
name|oldValue
operator|.
name|isNull
argument_list|()
operator|||
name|oldValue
operator|!=
name|value
condition|)
block|{
comment|// historical bug: dataChanged() is suppressed for Insert. See also setData().
name|mrow
operator|.
name|setValue
argument_list|(
name|idx
argument_list|,
name|record
operator|.
name|value
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrow
operator|.
name|op
argument_list|()
operator|!=
name|QSqlTableModelPrivate
operator|::
name|Insert
condition|)
emit|emit
name|dataChanged
argument_list|(
name|cIndex
argument_list|,
name|cIndex
argument_list|)
emit|;
block|}
block|}
else|else
block|{
name|mrow
operator|.
name|setValue
argument_list|(
name|idx
argument_list|,
name|record
operator|.
name|value
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnManualSubmit
operator|&&
name|isOk
condition|)
emit|emit
name|dataChanged
argument_list|(
name|createIndex
argument_list|(
name|row
argument_list|,
literal|0
argument_list|)
argument_list|,
name|createIndex
argument_list|(
name|row
argument_list|,
name|columnCount
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
emit|;
elseif|else
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnFieldChange
condition|)
return|return
name|submitAll
argument_list|()
return|;
elseif|else
if|if
condition|(
name|d
operator|->
name|strategy
operator|==
name|OnManualSubmit
condition|)
return|return
name|isOk
return|;
return|return
literal|true
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
