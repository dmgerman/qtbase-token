begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtSql module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qsql_oci.h"
end_include
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<qvariant.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<qmetatype.h>
end_include
begin_include
include|#
directive|include
file|<qregexp.h>
end_include
begin_include
include|#
directive|include
file|<qshareddata.h>
end_include
begin_include
include|#
directive|include
file|<qsqlerror.h>
end_include
begin_include
include|#
directive|include
file|<qsqlfield.h>
end_include
begin_include
include|#
directive|include
file|<qsqlindex.h>
end_include
begin_include
include|#
directive|include
file|<qsqlquery.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<qvector.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_comment
comment|// This is needed for oracle oci when compiling with mingw-w64 headers
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MINGW64_VERSION_MAJOR
argument_list|)
operator|&&
name|defined
argument_list|(
name|_WIN64
argument_list|)
end_if
begin_define
DECL|macro|_int64
define|#
directive|define
name|_int64
value|__int64
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<oci.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|max
end_ifdef
begin_undef
DECL|macro|max
undef|#
directive|undef
name|max
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|min
end_ifdef
begin_undef
DECL|macro|min
undef|#
directive|undef
name|min
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_define
DECL|macro|QOCI_DYNAMIC_CHUNK_SIZE
define|#
directive|define
name|QOCI_DYNAMIC_CHUNK_SIZE
value|65535
end_define
begin_define
DECL|macro|QOCI_PREFETCH_MEM
define|#
directive|define
name|QOCI_PREFETCH_MEM
value|10240
end_define
begin_comment
comment|// setting this define will allow using a query from a different
end_comment
begin_comment
comment|// thread than its database connection.
end_comment
begin_comment
comment|// warning - this is not fully tested and can lead to race conditions
end_comment
begin_define
DECL|macro|QOCI_THREADED
define|#
directive|define
name|QOCI_THREADED
end_define
begin_comment
comment|//#define QOCI_DEBUG
end_comment
begin_macro
name|Q_DECLARE_METATYPE
argument_list|(
argument|OCIEnv*
argument_list|)
end_macro
begin_macro
name|Q_DECLARE_METATYPE
argument_list|(
argument|OCIStmt*
argument_list|)
end_macro
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_LITTLE_ENDIAN
DECL|enumerator|QOCIEncoding
name|enum
type|{
name|QOCIEncoding
init|=
literal|2002
end_decl_stmt
begin_comment
DECL|enumerator|QOCIEncoding
unit|};
comment|// AL16UTF16LE
end_comment
begin_else
else|#
directive|else
end_else
begin_enum
enum|enum
block|{
name|QOCIEncoding
init|=
literal|2000
block|}
enum|;
end_enum
begin_comment
comment|// AL16UTF16
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|OCI_ATTR_CHARSET_FORM
end_ifdef
begin_comment
comment|// Always set the OCI_ATTR_CHARSET_FORM to SQLCS_NCHAR is safe
end_comment
begin_comment
comment|// because Oracle server will deal with the implicit Conversion
end_comment
begin_comment
comment|// Between CHAR and NCHAR.
end_comment
begin_comment
comment|// see: http://download.oracle.com/docs/cd/A91202_01/901_doc/appdev.901/a89857/oci05bnd.htm#422705
end_comment
begin_decl_stmt
DECL|variable|qOraCharsetForm
specifier|static
specifier|const
name|ub1
name|qOraCharsetForm
init|=
name|SQLCS_NCHAR
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|OCI_UTF16ID
argument_list|)
end_if
begin_decl_stmt
DECL|variable|qOraCharset
specifier|static
specifier|const
name|ub2
name|qOraCharset
init|=
name|OCI_UTF16ID
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|variable|qOraCharset
specifier|static
specifier|const
name|ub2
name|qOraCharset
init|=
name|OCI_UCS2ID
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|IndicatorArray
typedef|typedef
name|QVarLengthArray
argument_list|<
name|sb2
argument_list|,
literal|32
argument_list|>
name|IndicatorArray
typedef|;
end_typedef
begin_typedef
DECL|typedef|SizeArray
typedef|typedef
name|QVarLengthArray
argument_list|<
name|ub2
argument_list|,
literal|32
argument_list|>
name|SizeArray
typedef|;
end_typedef
begin_function_decl
specifier|static
name|QByteArray
name|qMakeOraDate
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|dt
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|QDateTime
name|qMakeDate
parameter_list|(
specifier|const
name|char
modifier|*
name|oraDate
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|QByteArray
name|qMakeOCINumber
parameter_list|(
specifier|const
name|qlonglong
modifier|&
name|ll
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|QByteArray
name|qMakeOCINumber
parameter_list|(
specifier|const
name|qulonglong
modifier|&
name|ull
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|qlonglong
name|qMakeLongLong
parameter_list|(
specifier|const
name|char
modifier|*
name|ociNumber
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|qulonglong
name|qMakeULongLong
parameter_list|(
specifier|const
name|char
modifier|*
name|ociNumber
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|QString
name|qOraWarn
parameter_list|(
name|OCIError
modifier|*
name|err
parameter_list|,
name|int
modifier|*
name|errorCode
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl
begin_ifndef
ifndef|#
directive|ifndef
name|Q_CC_SUN
end_ifndef
begin_function_decl
specifier|static
comment|// for some reason, Sun CC can't use qOraWarning when it's declared static
endif|#
directive|endif
name|void
name|qOraWarning
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|QSqlError
name|qMakeError
parameter_list|(
specifier|const
name|QString
modifier|&
name|errString
parameter_list|,
name|QSqlError
operator|::
name|ErrorType
name|type
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl
begin_class
DECL|class|QOCIRowId
class|class
name|QOCIRowId
super|:
specifier|public
name|QSharedData
block|{
public|public:
name|QOCIRowId
parameter_list|(
name|OCIEnv
modifier|*
name|env
parameter_list|)
constructor_decl|;
name|~
name|QOCIRowId
parameter_list|()
destructor_decl|;
DECL|member|id
name|OCIRowid
modifier|*
name|id
decl_stmt|;
private|private:
DECL|function|QOCIRowId
name|QOCIRowId
parameter_list|(
specifier|const
name|QOCIRowId
modifier|&
name|other
parameter_list|)
member_init_list|:
name|QSharedData
argument_list|(
name|other
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
class|;
end_class
begin_constructor
DECL|function|QOCIRowId
name|QOCIRowId
operator|::
name|QOCIRowId
parameter_list|(
name|OCIEnv
modifier|*
name|env
parameter_list|)
member_init_list|:
name|id
argument_list|(
literal|0
argument_list|)
block|{
name|OCIDescriptorAlloc
argument_list|(
name|env
argument_list|,
cast|reinterpret_cast
argument_list|<
name|dvoid
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|id
argument_list|)
argument_list|,
name|OCI_DTYPE_ROWID
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QOCIRowId
name|QOCIRowId
operator|::
name|~
name|QOCIRowId
parameter_list|()
block|{
if|if
condition|(
name|id
condition|)
name|OCIDescriptorFree
argument_list|(
name|id
argument_list|,
name|OCI_DTYPE_ROWID
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_typedef
DECL|typedef|QOCIRowIdPointer
typedef|typedef
name|QSharedDataPointer
argument_list|<
name|QOCIRowId
argument_list|>
name|QOCIRowIdPointer
typedef|;
end_typedef
begin_decl_stmt
name|QT_BEGIN_INCLUDE_NAMESPACE
name|Q_DECLARE_METATYPE
argument_list|(
name|QOCIRowIdPointer
argument_list|)
name|QT_END_INCLUDE_NAMESPACE
name|class
name|QOCICols
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|QOCIResultPrivate
struct|struct
name|QOCIResultPrivate
block|{
name|QOCIResultPrivate
parameter_list|(
name|QOCIResult
modifier|*
name|result
parameter_list|,
specifier|const
name|QOCIDriverPrivate
modifier|*
name|driver
parameter_list|)
constructor_decl|;
name|~
name|QOCIResultPrivate
parameter_list|()
destructor_decl|;
DECL|member|cols
name|QOCICols
modifier|*
name|cols
decl_stmt|;
DECL|member|q
name|QOCIResult
modifier|*
name|q
decl_stmt|;
DECL|member|env
name|OCIEnv
modifier|*
name|env
decl_stmt|;
DECL|member|err
name|OCIError
modifier|*
name|err
decl_stmt|;
DECL|member|svc
name|OCISvcCtx
modifier|*
modifier|&
name|svc
decl_stmt|;
DECL|member|sql
name|OCIStmt
modifier|*
name|sql
decl_stmt|;
DECL|member|transaction
name|bool
name|transaction
decl_stmt|;
DECL|member|serverVersion
name|int
name|serverVersion
decl_stmt|;
DECL|member|prefetchRows
DECL|member|prefetchMem
name|int
name|prefetchRows
decl_stmt|,
name|prefetchMem
decl_stmt|;
name|void
name|setStatementAttributes
parameter_list|()
function_decl|;
name|int
name|bindValue
parameter_list|(
name|OCIStmt
modifier|*
name|sql
parameter_list|,
name|OCIBind
modifier|*
modifier|*
name|hbnd
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|,
name|int
name|pos
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|val
parameter_list|,
name|dvoid
modifier|*
name|indPtr
parameter_list|,
name|ub2
modifier|*
name|tmpSize
parameter_list|,
name|QList
argument_list|<
name|QByteArray
argument_list|>
modifier|&
name|tmpStorage
parameter_list|)
function_decl|;
name|int
name|bindValues
parameter_list|(
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|values
parameter_list|,
name|IndicatorArray
modifier|&
name|indicators
parameter_list|,
name|SizeArray
modifier|&
name|tmpSizes
parameter_list|,
name|QList
argument_list|<
name|QByteArray
argument_list|>
modifier|&
name|tmpStorage
parameter_list|)
function_decl|;
name|void
name|outValues
parameter_list|(
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|values
parameter_list|,
name|IndicatorArray
modifier|&
name|indicators
parameter_list|,
name|QList
argument_list|<
name|QByteArray
argument_list|>
modifier|&
name|tmpStorage
parameter_list|)
function_decl|;
DECL|function|isOutValue
specifier|inline
name|bool
name|isOutValue
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
return|return
name|q
operator|->
name|bindValueType
argument_list|(
name|i
argument_list|)
operator|&
name|QSql
operator|::
name|Out
return|;
block|}
DECL|function|isBinaryValue
specifier|inline
name|bool
name|isBinaryValue
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
return|return
name|q
operator|->
name|bindValueType
argument_list|(
name|i
argument_list|)
operator|&
name|QSql
operator|::
name|Binary
return|;
block|}
DECL|function|setCharset
name|void
name|setCharset
parameter_list|(
name|dvoid
modifier|*
name|handle
parameter_list|,
name|ub4
name|type
parameter_list|)
specifier|const
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|handle
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OCI_ATTR_CHARSET_FORM
name|r
operator|=
name|OCIAttrSet
argument_list|(
name|handle
argument_list|,
name|type
argument_list|,
comment|// this const cast is safe since OCI doesn't touch
comment|// the charset.
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|void
operator|*
argument_list|>
argument_list|(
operator|&
name|qOraCharsetForm
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_CHARSET_FORM
argument_list|,
comment|//Strange Oracle bug: some Oracle servers crash the server process with non-zero error handle (mostly for 10g).
comment|//So ignore the error message here.
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QOCI_DEBUG
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qWarning
argument_list|(
literal|"QOCIResultPrivate::setCharset: Couldn't set OCI_ATTR_CHARSET_FORM."
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|r
operator|=
name|OCIAttrSet
argument_list|(
name|handle
argument_list|,
name|type
argument_list|,
comment|// this const cast is safe since OCI doesn't touch
comment|// the charset.
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|void
operator|*
argument_list|>
argument_list|(
operator|&
name|qOraCharset
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_CHARSET_ID
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qOraWarning
argument_list|(
literal|"QOCIResultPrivate::setCharsetI Couldn't set OCI_ATTR_CHARSET_ID: "
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
struct|;
end_struct
begin_function
DECL|function|setStatementAttributes
name|void
name|QOCIResultPrivate
operator|::
name|setStatementAttributes
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|sql
argument_list|)
expr_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|prefetchRows
operator|>=
literal|0
condition|)
block|{
name|r
operator|=
name|OCIAttrSet
argument_list|(
name|sql
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
operator|&
name|prefetchRows
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_PREFETCH_ROWS
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qOraWarning
argument_list|(
literal|"QOCIResultPrivate::setStatementAttributes:"
literal|" Couldn't set OCI_ATTR_PREFETCH_ROWS: "
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prefetchMem
operator|>=
literal|0
condition|)
block|{
name|r
operator|=
name|OCIAttrSet
argument_list|(
name|sql
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
operator|&
name|prefetchMem
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_PREFETCH_MEMORY
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qOraWarning
argument_list|(
literal|"QOCIResultPrivate::setStatementAttributes:"
literal|" Couldn't set OCI_ATTR_PREFETCH_MEMORY: "
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|bindValue
name|int
name|QOCIResultPrivate
operator|::
name|bindValue
parameter_list|(
name|OCIStmt
modifier|*
name|sql
parameter_list|,
name|OCIBind
modifier|*
modifier|*
name|hbnd
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|,
name|int
name|pos
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|val
parameter_list|,
name|dvoid
modifier|*
name|indPtr
parameter_list|,
name|ub2
modifier|*
name|tmpSize
parameter_list|,
name|QList
argument_list|<
name|QByteArray
argument_list|>
modifier|&
name|tmpStorage
parameter_list|)
block|{
name|int
name|r
init|=
name|OCI_SUCCESS
decl_stmt|;
name|void
modifier|*
name|data
init|=
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|val
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|val
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|QVariant
operator|::
name|ByteArray
case|:
name|r
operator|=
name|OCIBindByPos
argument_list|(
name|sql
argument_list|,
name|hbnd
argument_list|,
name|err
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|isOutValue
argument_list|(
name|pos
argument_list|)
condition|?
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
name|QByteArray
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
operator|->
name|constData
argument_list|()
argument_list|)
else|:
cast|reinterpret_cast
argument_list|<
name|QByteArray
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
operator|->
name|data
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|QByteArray
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
operator|->
name|size
argument_list|()
argument_list|,
name|SQLT_BIN
argument_list|,
name|indPtr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Time
case|:
case|case
name|QVariant
operator|::
name|Date
case|:
case|case
name|QVariant
operator|::
name|DateTime
case|:
block|{
name|QByteArray
name|ba
init|=
name|qMakeOraDate
argument_list|(
name|val
operator|.
name|toDateTime
argument_list|()
argument_list|)
decl_stmt|;
name|r
operator|=
name|OCIBindByPos
argument_list|(
name|sql
argument_list|,
name|hbnd
argument_list|,
name|err
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|ba
operator|.
name|data
argument_list|()
argument_list|,
name|ba
operator|.
name|size
argument_list|()
argument_list|,
name|SQLT_DAT
argument_list|,
name|indPtr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
name|tmpStorage
operator|.
name|append
argument_list|(
name|ba
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|Int
case|:
name|r
operator|=
name|OCIBindByPos
argument_list|(
name|sql
argument_list|,
name|hbnd
argument_list|,
name|err
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
comment|// if it's an out value, the data is already detached
comment|// so the const cast is safe.
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|SQLT_INT
argument_list|,
name|indPtr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|UInt
case|:
name|r
operator|=
name|OCIBindByPos
argument_list|(
name|sql
argument_list|,
name|hbnd
argument_list|,
name|err
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
comment|// if it's an out value, the data is already detached
comment|// so the const cast is safe.
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
argument_list|,
name|SQLT_UIN
argument_list|,
name|indPtr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|LongLong
case|:
block|{
name|QByteArray
name|ba
init|=
name|qMakeOCINumber
argument_list|(
name|val
operator|.
name|toLongLong
argument_list|()
argument_list|,
name|err
argument_list|)
decl_stmt|;
name|r
operator|=
name|OCIBindByPos
argument_list|(
name|sql
argument_list|,
name|hbnd
argument_list|,
name|err
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|ba
operator|.
name|data
argument_list|()
argument_list|,
name|ba
operator|.
name|size
argument_list|()
argument_list|,
name|SQLT_VNU
argument_list|,
name|indPtr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
name|tmpStorage
operator|.
name|append
argument_list|(
name|ba
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|ULongLong
case|:
block|{
name|QByteArray
name|ba
init|=
name|qMakeOCINumber
argument_list|(
name|val
operator|.
name|toULongLong
argument_list|()
argument_list|,
name|err
argument_list|)
decl_stmt|;
name|r
operator|=
name|OCIBindByPos
argument_list|(
name|sql
argument_list|,
name|hbnd
argument_list|,
name|err
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|ba
operator|.
name|data
argument_list|()
argument_list|,
name|ba
operator|.
name|size
argument_list|()
argument_list|,
name|SQLT_VNU
argument_list|,
name|indPtr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
name|tmpStorage
operator|.
name|append
argument_list|(
name|ba
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|Double
case|:
name|r
operator|=
name|OCIBindByPos
argument_list|(
name|sql
argument_list|,
name|hbnd
argument_list|,
name|err
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
comment|// if it's an out value, the data is already detached
comment|// so the const cast is safe.
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|,
name|SQLT_FLT
argument_list|,
name|indPtr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|UserType
case|:
if|if
condition|(
name|val
operator|.
name|canConvert
argument_list|<
name|QOCIRowIdPointer
argument_list|>
argument_list|()
operator|&&
operator|!
name|isOutValue
argument_list|(
name|pos
argument_list|)
condition|)
block|{
comment|// use a const pointer to prevent a detach
specifier|const
name|QOCIRowIdPointer
name|rptr
init|=
name|qvariant_cast
argument_list|<
name|QOCIRowIdPointer
argument_list|>
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|r
operator|=
name|OCIBindByPos
argument_list|(
name|sql
argument_list|,
name|hbnd
argument_list|,
name|err
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
comment|// it's an IN value, so const_cast is ok
cast|const_cast
argument_list|<
name|OCIRowid
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|rptr
operator|->
name|id
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLT_RDD
argument_list|,
name|indPtr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Unknown bind variable"
argument_list|)
expr_stmt|;
name|r
operator|=
name|OCI_ERROR
expr_stmt|;
block|}
break|break;
case|case
name|QVariant
operator|::
name|String
case|:
block|{
specifier|const
name|QString
name|s
init|=
name|val
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|isBinaryValue
argument_list|(
name|pos
argument_list|)
condition|)
block|{
name|r
operator|=
name|OCIBindByPos
argument_list|(
name|sql
argument_list|,
name|hbnd
argument_list|,
name|err
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
cast|const_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|s
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|,
name|SQLT_LNG
argument_list|,
name|indPtr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|isOutValue
argument_list|(
name|pos
argument_list|)
condition|)
block|{
comment|// don't detach the string
name|r
operator|=
name|OCIBindByPos
argument_list|(
name|sql
argument_list|,
name|hbnd
argument_list|,
name|err
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
comment|// safe since oracle doesn't touch OUT values
cast|const_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|s
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|,
operator|(
name|s
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|,
name|SQLT_STR
argument_list|,
name|indPtr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
name|setCharset
argument_list|(
operator|*
name|hbnd
argument_list|,
name|OCI_HTYPE_BIND
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// fall through for OUT values
default|default:
block|{
specifier|const
name|QString
name|s
init|=
name|val
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// create a deep-copy
name|QByteArray
name|ba
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|s
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|,
operator|(
name|s
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|isOutValue
argument_list|(
name|pos
argument_list|)
condition|)
block|{
name|ba
operator|.
name|reserve
argument_list|(
operator|(
name|s
operator|.
name|capacity
argument_list|()
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tmpSize
operator|=
name|ba
operator|.
name|size
argument_list|()
expr_stmt|;
name|r
operator|=
name|OCIBindByPos
argument_list|(
name|sql
argument_list|,
name|hbnd
argument_list|,
name|err
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|ba
operator|.
name|data
argument_list|()
argument_list|,
name|ba
operator|.
name|capacity
argument_list|()
argument_list|,
name|SQLT_STR
argument_list|,
name|indPtr
argument_list|,
name|tmpSize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|OCIBindByPos
argument_list|(
name|sql
argument_list|,
name|hbnd
argument_list|,
name|err
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|ba
operator|.
name|data
argument_list|()
argument_list|,
name|ba
operator|.
name|size
argument_list|()
argument_list|,
name|SQLT_STR
argument_list|,
name|indPtr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
name|setCharset
argument_list|(
operator|*
name|hbnd
argument_list|,
name|OCI_HTYPE_BIND
argument_list|)
expr_stmt|;
name|tmpStorage
operator|.
name|append
argument_list|(
name|ba
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// default case
block|}
comment|// switch
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
condition|)
name|qOraWarning
argument_list|(
literal|"QOCIResultPrivate::bindValue:"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|bindValues
name|int
name|QOCIResultPrivate
operator|::
name|bindValues
parameter_list|(
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|values
parameter_list|,
name|IndicatorArray
modifier|&
name|indicators
parameter_list|,
name|SizeArray
modifier|&
name|tmpSizes
parameter_list|,
name|QList
argument_list|<
name|QByteArray
argument_list|>
modifier|&
name|tmpStorage
parameter_list|)
block|{
name|int
name|r
init|=
name|OCI_SUCCESS
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|isOutValue
argument_list|(
name|i
argument_list|)
condition|)
name|values
index|[
name|i
index|]
operator|.
name|detach
argument_list|()
expr_stmt|;
specifier|const
name|QVariant
modifier|&
name|val
init|=
name|values
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|OCIBind
modifier|*
name|hbnd
init|=
literal|0
decl_stmt|;
comment|// Oracle handles these automatically
name|sb2
modifier|*
name|indPtr
init|=
operator|&
name|indicators
index|[
name|i
index|]
decl_stmt|;
operator|*
name|indPtr
operator|=
name|val
operator|.
name|isNull
argument_list|()
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|bindValue
argument_list|(
name|sql
argument_list|,
operator|&
name|hbnd
argument_list|,
name|err
argument_list|,
name|i
argument_list|,
name|val
argument_list|,
name|indPtr
argument_list|,
operator|&
name|tmpSizes
index|[
name|i
index|]
argument_list|,
name|tmpStorage
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function
begin_comment
comment|// will assign out value and remove its temp storage.
end_comment
begin_function
DECL|function|qOraOutValue
specifier|static
name|void
name|qOraOutValue
parameter_list|(
name|QVariant
modifier|&
name|value
parameter_list|,
name|QList
argument_list|<
name|QByteArray
argument_list|>
modifier|&
name|storage
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|)
block|{
switch|switch
condition|(
name|value
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|QVariant
operator|::
name|Time
case|:
name|value
operator|=
name|qMakeDate
argument_list|(
name|storage
operator|.
name|takeFirst
argument_list|()
argument_list|)
operator|.
name|time
argument_list|()
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Date
case|:
name|value
operator|=
name|qMakeDate
argument_list|(
name|storage
operator|.
name|takeFirst
argument_list|()
argument_list|)
operator|.
name|date
argument_list|()
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|DateTime
case|:
name|value
operator|=
name|qMakeDate
argument_list|(
name|storage
operator|.
name|takeFirst
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|LongLong
case|:
name|value
operator|=
name|qMakeLongLong
argument_list|(
name|storage
operator|.
name|takeFirst
argument_list|()
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|ULongLong
case|:
name|value
operator|=
name|qMakeULongLong
argument_list|(
name|storage
operator|.
name|takeFirst
argument_list|()
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|String
case|:
name|value
operator|=
name|QString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|storage
operator|.
name|takeFirst
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
comment|//nothing
block|}
block|}
end_function
begin_function
DECL|function|outValues
name|void
name|QOCIResultPrivate
operator|::
name|outValues
parameter_list|(
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|values
parameter_list|,
name|IndicatorArray
modifier|&
name|indicators
parameter_list|,
name|QList
argument_list|<
name|QByteArray
argument_list|>
modifier|&
name|tmpStorage
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|isOutValue
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|qOraOutValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|tmpStorage
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|QVariant
operator|::
name|Type
name|typ
init|=
name|values
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|indicators
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
comment|// NULL
name|values
index|[
name|i
index|]
operator|=
name|QVariant
argument_list|(
name|typ
argument_list|)
expr_stmt|;
else|else
name|values
index|[
name|i
index|]
operator|=
name|QVariant
argument_list|(
name|typ
argument_list|,
name|values
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_struct
DECL|struct|QOCIDriverPrivate
struct|struct
name|QOCIDriverPrivate
block|{
name|QOCIDriverPrivate
parameter_list|()
constructor_decl|;
DECL|member|env
name|OCIEnv
modifier|*
name|env
decl_stmt|;
DECL|member|svc
name|OCISvcCtx
modifier|*
name|svc
decl_stmt|;
DECL|member|srvhp
name|OCIServer
modifier|*
name|srvhp
decl_stmt|;
DECL|member|authp
name|OCISession
modifier|*
name|authp
decl_stmt|;
DECL|member|err
name|OCIError
modifier|*
name|err
decl_stmt|;
DECL|member|transaction
name|bool
name|transaction
decl_stmt|;
DECL|member|serverVersion
name|int
name|serverVersion
decl_stmt|;
DECL|member|prefetchRows
name|ub4
name|prefetchRows
decl_stmt|;
DECL|member|prefetchMem
name|ub2
name|prefetchMem
decl_stmt|;
DECL|member|user
name|QString
name|user
decl_stmt|;
name|void
name|allocErrorHandle
parameter_list|()
function_decl|;
block|}
struct|;
end_struct
begin_constructor
DECL|function|QOCIDriverPrivate
name|QOCIDriverPrivate
operator|::
name|QOCIDriverPrivate
parameter_list|()
member_init_list|:
name|env
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|svc
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|srvhp
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|authp
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|err
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|transaction
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|serverVersion
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|prefetchRows
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|prefetchMem
argument_list|(
name|QOCI_PREFETCH_MEM
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|allocErrorHandle
name|void
name|QOCIDriverPrivate
operator|::
name|allocErrorHandle
parameter_list|()
block|{
name|int
name|r
init|=
name|OCIHandleAlloc
argument_list|(
name|env
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|err
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qWarning
argument_list|(
literal|"QOCIDriver: unable to allocate error handle"
argument_list|)
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|OraFieldInfo
struct|struct
name|OraFieldInfo
block|{
DECL|member|name
name|QString
name|name
decl_stmt|;
DECL|member|type
name|QVariant
operator|::
name|Type
name|type
decl_stmt|;
DECL|member|oraIsNull
name|ub1
name|oraIsNull
decl_stmt|;
DECL|member|oraType
name|ub4
name|oraType
decl_stmt|;
DECL|member|oraScale
name|sb1
name|oraScale
decl_stmt|;
DECL|member|oraLength
name|ub4
name|oraLength
decl_stmt|;
comment|// size in bytes
DECL|member|oraFieldLength
name|ub4
name|oraFieldLength
decl_stmt|;
comment|// amount of characters
DECL|member|oraPrecision
name|sb2
name|oraPrecision
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|qOraWarn
name|QString
name|qOraWarn
parameter_list|(
name|OCIError
modifier|*
name|err
parameter_list|,
name|int
modifier|*
name|errorCode
parameter_list|)
block|{
name|sb4
name|errcode
decl_stmt|;
name|text
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|errbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|errbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|OCIErrorGet
argument_list|(
name|err
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|errcode
argument_list|,
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorCode
condition|)
operator|*
name|errorCode
operator|=
name|errcode
expr_stmt|;
return|return
name|QString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|errbuf
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qOraWarning
name|void
name|qOraWarning
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QOCI_DEBUG
name|qWarning
argument_list|(
literal|"%s %s"
argument_list|,
name|msg
argument_list|,
name|qPrintable
argument_list|(
name|qOraWarn
argument_list|(
name|err
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|qOraErrorNumber
specifier|static
name|int
name|qOraErrorNumber
parameter_list|(
name|OCIError
modifier|*
name|err
parameter_list|)
block|{
name|sb4
name|errcode
decl_stmt|;
name|OCIErrorGet
argument_list|(
name|err
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|errcode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
return|return
name|errcode
return|;
block|}
end_function
begin_function
DECL|function|qMakeError
name|QSqlError
name|qMakeError
parameter_list|(
specifier|const
name|QString
modifier|&
name|errString
parameter_list|,
name|QSqlError
operator|::
name|ErrorType
name|type
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|)
block|{
name|int
name|errorCode
init|=
literal|0
decl_stmt|;
specifier|const
name|QString
name|oraErrorString
init|=
name|qOraWarn
argument_list|(
name|err
argument_list|,
operator|&
name|errorCode
argument_list|)
decl_stmt|;
return|return
name|QSqlError
argument_list|(
name|errString
argument_list|,
name|oraErrorString
argument_list|,
name|type
argument_list|,
name|errorCode
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qDecodeOCIType
name|QVariant
operator|::
name|Type
name|qDecodeOCIType
parameter_list|(
specifier|const
name|QString
modifier|&
name|ocitype
parameter_list|,
name|QSql
operator|::
name|NumericalPrecisionPolicy
name|precisionPolicy
parameter_list|)
block|{
name|QVariant
operator|::
name|Type
name|type
init|=
name|QVariant
operator|::
name|Invalid
decl_stmt|;
if|if
condition|(
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"VARCHAR2"
argument_list|)
operator|||
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"VARCHAR"
argument_list|)
operator|||
name|ocitype
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"INTERVAL"
argument_list|)
argument_list|)
operator|||
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"CHAR"
argument_list|)
operator|||
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"NVARCHAR2"
argument_list|)
operator|||
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"NCHAR"
argument_list|)
condition|)
name|type
operator|=
name|QVariant
operator|::
name|String
expr_stmt|;
elseif|else
if|if
condition|(
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"NUMBER"
argument_list|)
operator|||
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"FLOAT"
argument_list|)
operator|||
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"BINARY_FLOAT"
argument_list|)
operator|||
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"BINARY_DOUBLE"
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|precisionPolicy
condition|)
block|{
case|case
name|QSql
operator|::
name|LowPrecisionInt32
case|:
name|type
operator|=
name|QVariant
operator|::
name|Int
expr_stmt|;
break|break;
case|case
name|QSql
operator|::
name|LowPrecisionInt64
case|:
name|type
operator|=
name|QVariant
operator|::
name|LongLong
expr_stmt|;
break|break;
case|case
name|QSql
operator|::
name|LowPrecisionDouble
case|:
name|type
operator|=
name|QVariant
operator|::
name|Double
expr_stmt|;
break|break;
case|case
name|QSql
operator|::
name|HighPrecision
case|:
default|default:
name|type
operator|=
name|QVariant
operator|::
name|String
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"LONG"
argument_list|)
operator|||
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"NCLOB"
argument_list|)
operator|||
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"CLOB"
argument_list|)
condition|)
name|type
operator|=
name|QVariant
operator|::
name|ByteArray
expr_stmt|;
elseif|else
if|if
condition|(
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"RAW"
argument_list|)
operator|||
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"LONG RAW"
argument_list|)
operator|||
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"ROWID"
argument_list|)
operator|||
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"BLOB"
argument_list|)
operator|||
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"CFILE"
argument_list|)
operator|||
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"BFILE"
argument_list|)
condition|)
name|type
operator|=
name|QVariant
operator|::
name|ByteArray
expr_stmt|;
elseif|else
if|if
condition|(
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"DATE"
argument_list|)
operator|||
name|ocitype
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"TIME"
argument_list|)
argument_list|)
condition|)
name|type
operator|=
name|QVariant
operator|::
name|DateTime
expr_stmt|;
elseif|else
if|if
condition|(
name|ocitype
operator|==
name|QLatin1String
argument_list|(
literal|"UNDEFINED"
argument_list|)
condition|)
name|type
operator|=
name|QVariant
operator|::
name|Invalid
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|QVariant
operator|::
name|Invalid
condition|)
name|qWarning
argument_list|(
literal|"qDecodeOCIType: unknown type: %s"
argument_list|,
name|ocitype
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function
begin_function
DECL|function|qDecodeOCIType
name|QVariant
operator|::
name|Type
name|qDecodeOCIType
parameter_list|(
name|int
name|ocitype
parameter_list|,
name|QSql
operator|::
name|NumericalPrecisionPolicy
name|precisionPolicy
parameter_list|)
block|{
name|QVariant
operator|::
name|Type
name|type
init|=
name|QVariant
operator|::
name|Invalid
decl_stmt|;
switch|switch
condition|(
name|ocitype
condition|)
block|{
case|case
name|SQLT_STR
case|:
case|case
name|SQLT_VST
case|:
case|case
name|SQLT_CHR
case|:
case|case
name|SQLT_AFC
case|:
case|case
name|SQLT_VCS
case|:
case|case
name|SQLT_AVC
case|:
case|case
name|SQLT_RDD
case|:
case|case
name|SQLT_LNG
case|:
ifdef|#
directive|ifdef
name|SQLT_INTERVAL_YM
case|case
name|SQLT_INTERVAL_YM
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SQLT_INTERVAL_DS
case|case
name|SQLT_INTERVAL_DS
case|:
endif|#
directive|endif
name|type
operator|=
name|QVariant
operator|::
name|String
expr_stmt|;
break|break;
case|case
name|SQLT_INT
case|:
name|type
operator|=
name|QVariant
operator|::
name|Int
expr_stmt|;
break|break;
case|case
name|SQLT_FLT
case|:
case|case
name|SQLT_NUM
case|:
case|case
name|SQLT_VNU
case|:
case|case
name|SQLT_UIN
case|:
switch|switch
condition|(
name|precisionPolicy
condition|)
block|{
case|case
name|QSql
operator|::
name|LowPrecisionInt32
case|:
name|type
operator|=
name|QVariant
operator|::
name|Int
expr_stmt|;
break|break;
case|case
name|QSql
operator|::
name|LowPrecisionInt64
case|:
name|type
operator|=
name|QVariant
operator|::
name|LongLong
expr_stmt|;
break|break;
case|case
name|QSql
operator|::
name|LowPrecisionDouble
case|:
name|type
operator|=
name|QVariant
operator|::
name|Double
expr_stmt|;
break|break;
case|case
name|QSql
operator|::
name|HighPrecision
case|:
default|default:
name|type
operator|=
name|QVariant
operator|::
name|String
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SQLT_VBI
case|:
case|case
name|SQLT_BIN
case|:
case|case
name|SQLT_LBI
case|:
case|case
name|SQLT_LVC
case|:
case|case
name|SQLT_LVB
case|:
case|case
name|SQLT_BLOB
case|:
case|case
name|SQLT_CLOB
case|:
case|case
name|SQLT_FILE
case|:
case|case
name|SQLT_NTY
case|:
case|case
name|SQLT_REF
case|:
case|case
name|SQLT_RID
case|:
name|type
operator|=
name|QVariant
operator|::
name|ByteArray
expr_stmt|;
break|break;
case|case
name|SQLT_DAT
case|:
case|case
name|SQLT_ODT
case|:
ifdef|#
directive|ifdef
name|SQLT_TIMESTAMP
case|case
name|SQLT_TIMESTAMP
case|:
case|case
name|SQLT_TIMESTAMP_TZ
case|:
case|case
name|SQLT_TIMESTAMP_LTZ
case|:
endif|#
directive|endif
name|type
operator|=
name|QVariant
operator|::
name|DateTime
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|QVariant
operator|::
name|Invalid
expr_stmt|;
name|qWarning
argument_list|(
literal|"qDecodeOCIType: unknown OCI datatype: %d"
argument_list|,
name|ocitype
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|type
return|;
block|}
end_function
begin_function
DECL|function|qFromOraInf
specifier|static
name|QSqlField
name|qFromOraInf
parameter_list|(
specifier|const
name|OraFieldInfo
modifier|&
name|ofi
parameter_list|)
block|{
name|QSqlField
name|f
argument_list|(
name|ofi
operator|.
name|name
argument_list|,
name|ofi
operator|.
name|type
argument_list|)
decl_stmt|;
name|f
operator|.
name|setRequired
argument_list|(
name|ofi
operator|.
name|oraIsNull
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofi
operator|.
name|type
operator|==
name|QVariant
operator|::
name|String
operator|&&
name|ofi
operator|.
name|oraType
operator|!=
name|SQLT_NUM
operator|&&
name|ofi
operator|.
name|oraType
operator|!=
name|SQLT_VNU
condition|)
name|f
operator|.
name|setLength
argument_list|(
name|ofi
operator|.
name|oraFieldLength
argument_list|)
expr_stmt|;
else|else
name|f
operator|.
name|setLength
argument_list|(
name|ofi
operator|.
name|oraPrecision
operator|==
literal|0
condition|?
literal|38
else|:
name|int
argument_list|(
name|ofi
operator|.
name|oraPrecision
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|.
name|setPrecision
argument_list|(
name|ofi
operator|.
name|oraScale
argument_list|)
expr_stmt|;
name|f
operator|.
name|setSqlType
argument_list|(
name|int
argument_list|(
name|ofi
operator|.
name|oraType
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Convert QDateTime to the internal Oracle DATE format NB!     It does not handle BCE dates. */
end_comment
begin_function
DECL|function|qMakeOraDate
name|QByteArray
name|qMakeOraDate
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|dt
parameter_list|)
block|{
name|QByteArray
name|ba
decl_stmt|;
name|ba
operator|.
name|resize
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|int
name|year
init|=
name|dt
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
decl_stmt|;
name|ba
index|[
literal|0
index|]
operator|=
operator|(
name|year
operator|/
literal|100
operator|)
operator|+
literal|100
expr_stmt|;
comment|// century
name|ba
index|[
literal|1
index|]
operator|=
operator|(
name|year
operator|%
literal|100
operator|)
operator|+
literal|100
expr_stmt|;
comment|// year
name|ba
index|[
literal|2
index|]
operator|=
name|dt
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
expr_stmt|;
name|ba
index|[
literal|3
index|]
operator|=
name|dt
operator|.
name|date
argument_list|()
operator|.
name|day
argument_list|()
expr_stmt|;
name|ba
index|[
literal|4
index|]
operator|=
name|dt
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
operator|+
literal|1
expr_stmt|;
name|ba
index|[
literal|5
index|]
operator|=
name|dt
operator|.
name|time
argument_list|()
operator|.
name|minute
argument_list|()
operator|+
literal|1
expr_stmt|;
name|ba
index|[
literal|6
index|]
operator|=
name|dt
operator|.
name|time
argument_list|()
operator|.
name|second
argument_list|()
operator|+
literal|1
expr_stmt|;
return|return
name|ba
return|;
block|}
end_function
begin_comment
comment|/*!   \internal     Convert qlonglong to the internal Oracle OCINumber format.   */
end_comment
begin_function
DECL|function|qMakeOCINumber
name|QByteArray
name|qMakeOCINumber
parameter_list|(
specifier|const
name|qlonglong
modifier|&
name|ll
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|)
block|{
name|QByteArray
name|ba
argument_list|(
sizeof|sizeof
argument_list|(
name|OCINumber
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|OCINumberFromInt
argument_list|(
name|err
argument_list|,
operator|&
name|ll
argument_list|,
sizeof|sizeof
argument_list|(
name|qlonglong
argument_list|)
argument_list|,
name|OCI_NUMBER_SIGNED
argument_list|,
cast|reinterpret_cast
argument_list|<
name|OCINumber
operator|*
argument_list|>
argument_list|(
name|ba
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ba
return|;
block|}
end_function
begin_comment
comment|/*!   \internal     Convert qulonglong to the internal Oracle OCINumber format.   */
end_comment
begin_function
DECL|function|qMakeOCINumber
name|QByteArray
name|qMakeOCINumber
parameter_list|(
specifier|const
name|qulonglong
modifier|&
name|ull
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|)
block|{
name|QByteArray
name|ba
argument_list|(
sizeof|sizeof
argument_list|(
name|OCINumber
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|OCINumberFromInt
argument_list|(
name|err
argument_list|,
operator|&
name|ull
argument_list|,
sizeof|sizeof
argument_list|(
name|qlonglong
argument_list|)
argument_list|,
name|OCI_NUMBER_UNSIGNED
argument_list|,
cast|reinterpret_cast
argument_list|<
name|OCINumber
operator|*
argument_list|>
argument_list|(
name|ba
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ba
return|;
block|}
end_function
begin_function
DECL|function|qMakeLongLong
name|qlonglong
name|qMakeLongLong
parameter_list|(
specifier|const
name|char
modifier|*
name|ociNumber
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|)
block|{
name|qlonglong
name|qll
init|=
literal|0
decl_stmt|;
name|OCINumberToInt
argument_list|(
name|err
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|OCINumber
operator|*
argument_list|>
argument_list|(
name|ociNumber
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|qlonglong
argument_list|)
argument_list|,
name|OCI_NUMBER_SIGNED
argument_list|,
operator|&
name|qll
argument_list|)
expr_stmt|;
return|return
name|qll
return|;
block|}
end_function
begin_function
DECL|function|qMakeULongLong
name|qulonglong
name|qMakeULongLong
parameter_list|(
specifier|const
name|char
modifier|*
name|ociNumber
parameter_list|,
name|OCIError
modifier|*
name|err
parameter_list|)
block|{
name|qulonglong
name|qull
init|=
literal|0
decl_stmt|;
name|OCINumberToInt
argument_list|(
name|err
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|OCINumber
operator|*
argument_list|>
argument_list|(
name|ociNumber
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|qulonglong
argument_list|)
argument_list|,
name|OCI_NUMBER_UNSIGNED
argument_list|,
operator|&
name|qull
argument_list|)
expr_stmt|;
return|return
name|qull
return|;
block|}
end_function
begin_function
DECL|function|qMakeDate
name|QDateTime
name|qMakeDate
parameter_list|(
specifier|const
name|char
modifier|*
name|oraDate
parameter_list|)
block|{
name|int
name|century
init|=
name|uchar
argument_list|(
name|oraDate
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|century
operator|>=
literal|100
condition|)
block|{
name|int
name|year
init|=
name|uchar
argument_list|(
name|oraDate
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|year
operator|=
operator|(
operator|(
name|century
operator|-
literal|100
operator|)
operator|*
literal|100
operator|)
operator|+
operator|(
name|year
operator|-
literal|100
operator|)
expr_stmt|;
name|int
name|month
init|=
name|oraDate
index|[
literal|2
index|]
decl_stmt|;
name|int
name|day
init|=
name|oraDate
index|[
literal|3
index|]
decl_stmt|;
name|int
name|hour
init|=
name|oraDate
index|[
literal|4
index|]
operator|-
literal|1
decl_stmt|;
name|int
name|min
init|=
name|oraDate
index|[
literal|5
index|]
operator|-
literal|1
decl_stmt|;
name|int
name|sec
init|=
name|oraDate
index|[
literal|6
index|]
operator|-
literal|1
decl_stmt|;
return|return
name|QDateTime
argument_list|(
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
argument_list|,
name|QTime
argument_list|(
name|hour
argument_list|,
name|min
argument_list|,
name|sec
argument_list|)
argument_list|)
return|;
block|}
return|return
name|QDateTime
argument_list|()
return|;
block|}
end_function
begin_class
DECL|class|QOCICols
class|class
name|QOCICols
block|{
public|public:
name|QOCICols
parameter_list|(
name|int
name|size
parameter_list|,
name|QOCIResultPrivate
modifier|*
name|dp
parameter_list|)
constructor_decl|;
name|~
name|QOCICols
parameter_list|()
destructor_decl|;
name|int
name|readPiecewise
parameter_list|(
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|values
parameter_list|,
name|int
name|index
init|=
literal|0
parameter_list|)
function_decl|;
name|int
name|readLOBs
parameter_list|(
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|values
parameter_list|,
name|int
name|index
init|=
literal|0
parameter_list|)
function_decl|;
name|int
name|fieldFromDefine
parameter_list|(
name|OCIDefine
modifier|*
name|d
parameter_list|)
function_decl|;
name|void
name|getValues
parameter_list|(
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|v
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
DECL|function|size
specifier|inline
name|int
name|size
parameter_list|()
block|{
return|return
name|fieldInf
operator|.
name|size
argument_list|()
return|;
block|}
specifier|static
name|bool
name|execBatch
parameter_list|(
name|QOCIResultPrivate
modifier|*
name|d
parameter_list|,
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|boundValues
parameter_list|,
name|bool
name|arrayBind
parameter_list|)
function_decl|;
DECL|member|rec
name|QSqlRecord
name|rec
decl_stmt|;
private|private:
name|char
modifier|*
name|create
parameter_list|(
name|int
name|position
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
name|OCILobLocator
modifier|*
modifier|*
name|createLobLocator
parameter_list|(
name|int
name|position
parameter_list|,
name|OCIEnv
modifier|*
name|env
parameter_list|)
function_decl|;
name|OraFieldInfo
name|qMakeOraField
parameter_list|(
specifier|const
name|QOCIResultPrivate
modifier|*
name|p
parameter_list|,
name|OCIParam
modifier|*
name|param
parameter_list|)
specifier|const
function_decl|;
DECL|class|OraFieldInf
class|class
name|OraFieldInf
block|{
public|public:
DECL|function|OraFieldInf
name|OraFieldInf
parameter_list|()
member_init_list|:
name|data
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|len
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ind
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|typ
argument_list|(
name|QVariant
operator|::
name|Invalid
argument_list|)
member_init_list|,
name|oraType
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|def
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lob
argument_list|(
literal|0
argument_list|)
block|{}
name|~
name|OraFieldInf
parameter_list|()
destructor_decl|;
DECL|member|data
name|char
modifier|*
name|data
decl_stmt|;
DECL|member|len
name|int
name|len
decl_stmt|;
DECL|member|ind
name|sb2
name|ind
decl_stmt|;
DECL|member|typ
name|QVariant
operator|::
name|Type
name|typ
decl_stmt|;
DECL|member|oraType
name|ub4
name|oraType
decl_stmt|;
DECL|member|def
name|OCIDefine
modifier|*
name|def
decl_stmt|;
DECL|member|lob
name|OCILobLocator
modifier|*
name|lob
decl_stmt|;
block|}
class|;
DECL|member|fieldInf
name|QVector
argument_list|<
name|OraFieldInf
argument_list|>
name|fieldInf
decl_stmt|;
DECL|member|d
specifier|const
name|QOCIResultPrivate
modifier|*
specifier|const
name|d
decl_stmt|;
block|}
class|;
end_class
begin_destructor
DECL|function|~OraFieldInf
name|QOCICols
operator|::
name|OraFieldInf
operator|::
name|~
name|OraFieldInf
parameter_list|()
block|{
operator|delete
index|[]
name|data
expr_stmt|;
if|if
condition|(
name|lob
condition|)
block|{
name|int
name|r
init|=
name|OCIDescriptorFree
argument_list|(
name|lob
argument_list|,
name|OCI_DTYPE_LOB
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qWarning
argument_list|(
literal|"QOCICols: Cannot free LOB descriptor"
argument_list|)
expr_stmt|;
block|}
block|}
end_destructor
begin_constructor
DECL|function|QOCICols
name|QOCICols
operator|::
name|QOCICols
parameter_list|(
name|int
name|size
parameter_list|,
name|QOCIResultPrivate
modifier|*
name|dp
parameter_list|)
member_init_list|:
name|fieldInf
argument_list|(
name|size
argument_list|)
member_init_list|,
name|d
argument_list|(
name|dp
argument_list|)
block|{
name|ub4
name|dataSize
init|=
literal|0
decl_stmt|;
name|OCIDefine
modifier|*
name|dfn
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
name|OCIParam
modifier|*
name|param
init|=
literal|0
decl_stmt|;
name|sb4
name|parmStatus
init|=
literal|0
decl_stmt|;
name|ub4
name|count
init|=
literal|1
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|parmStatus
operator|=
name|OCIParamGet
argument_list|(
name|d
operator|->
name|sql
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
name|d
operator|->
name|err
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|param
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
while|while
condition|(
name|parmStatus
operator|==
name|OCI_SUCCESS
condition|)
block|{
name|OraFieldInfo
name|ofi
init|=
name|qMakeOraField
argument_list|(
name|d
argument_list|,
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
name|ofi
operator|.
name|oraType
operator|==
name|SQLT_RDD
condition|)
name|dataSize
operator|=
literal|50
expr_stmt|;
ifdef|#
directive|ifdef
name|SQLT_INTERVAL_YM
ifdef|#
directive|ifdef
name|SQLT_INTERVAL_DS
elseif|else
if|if
condition|(
name|ofi
operator|.
name|oraType
operator|==
name|SQLT_INTERVAL_YM
operator|||
name|ofi
operator|.
name|oraType
operator|==
name|SQLT_INTERVAL_DS
condition|)
comment|// since we are binding interval datatype as string,
comment|// we are not interested in the number of bytes but characters.
name|dataSize
operator|=
literal|50
expr_stmt|;
comment|// magic number
endif|#
directive|endif
comment|//SQLT_INTERVAL_DS
endif|#
directive|endif
comment|//SQLT_INTERVAL_YM
elseif|else
if|if
condition|(
name|ofi
operator|.
name|oraType
operator|==
name|SQLT_NUM
operator|||
name|ofi
operator|.
name|oraType
operator|==
name|SQLT_VNU
condition|)
block|{
if|if
condition|(
name|ofi
operator|.
name|oraPrecision
operator|>
literal|0
condition|)
name|dataSize
operator|=
operator|(
name|ofi
operator|.
name|oraPrecision
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|utext
argument_list|)
expr_stmt|;
else|else
name|dataSize
operator|=
operator|(
literal|38
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|utext
argument_list|)
expr_stmt|;
block|}
else|else
name|dataSize
operator|=
name|ofi
operator|.
name|oraLength
expr_stmt|;
name|fieldInf
index|[
name|idx
index|]
operator|.
name|typ
operator|=
name|ofi
operator|.
name|type
expr_stmt|;
name|fieldInf
index|[
name|idx
index|]
operator|.
name|oraType
operator|=
name|ofi
operator|.
name|oraType
expr_stmt|;
name|rec
operator|.
name|append
argument_list|(
name|qFromOraInf
argument_list|(
name|ofi
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ofi
operator|.
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|DateTime
case|:
name|r
operator|=
name|OCIDefineByPos
argument_list|(
name|d
operator|->
name|sql
argument_list|,
operator|&
name|dfn
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|count
argument_list|,
name|create
argument_list|(
name|idx
argument_list|,
name|dataSize
operator|+
literal|1
argument_list|)
argument_list|,
name|dataSize
operator|+
literal|1
argument_list|,
name|SQLT_DAT
argument_list|,
operator|&
operator|(
name|fieldInf
index|[
name|idx
index|]
operator|.
name|ind
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Double
case|:
name|r
operator|=
name|OCIDefineByPos
argument_list|(
name|d
operator|->
name|sql
argument_list|,
operator|&
name|dfn
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|count
argument_list|,
name|create
argument_list|(
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|,
name|SQLT_FLT
argument_list|,
operator|&
operator|(
name|fieldInf
index|[
name|idx
index|]
operator|.
name|ind
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Int
case|:
name|r
operator|=
name|OCIDefineByPos
argument_list|(
name|d
operator|->
name|sql
argument_list|,
operator|&
name|dfn
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|count
argument_list|,
name|create
argument_list|(
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|qint32
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|qint32
argument_list|)
argument_list|,
name|SQLT_INT
argument_list|,
operator|&
operator|(
name|fieldInf
index|[
name|idx
index|]
operator|.
name|ind
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|LongLong
case|:
name|r
operator|=
name|OCIDefineByPos
argument_list|(
name|d
operator|->
name|sql
argument_list|,
operator|&
name|dfn
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|count
argument_list|,
name|create
argument_list|(
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|OCINumber
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|OCINumber
argument_list|)
argument_list|,
name|SQLT_VNU
argument_list|,
operator|&
operator|(
name|fieldInf
index|[
name|idx
index|]
operator|.
name|ind
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|ByteArray
case|:
comment|// RAW and LONG RAW fields can't be bound to LOB locators
if|if
condition|(
name|ofi
operator|.
name|oraType
operator|==
name|SQLT_BIN
condition|)
block|{
comment|//                                qDebug("binding SQLT_BIN");
name|r
operator|=
name|OCIDefineByPos
argument_list|(
name|d
operator|->
name|sql
argument_list|,
operator|&
name|dfn
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|count
argument_list|,
name|create
argument_list|(
name|idx
argument_list|,
name|dataSize
argument_list|)
argument_list|,
name|dataSize
argument_list|,
name|SQLT_BIN
argument_list|,
operator|&
operator|(
name|fieldInf
index|[
name|idx
index|]
operator|.
name|ind
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DYNAMIC_FETCH
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ofi
operator|.
name|oraType
operator|==
name|SQLT_LBI
condition|)
block|{
comment|//                                    qDebug("binding SQLT_LBI");
name|r
operator|=
name|OCIDefineByPos
argument_list|(
name|d
operator|->
name|sql
argument_list|,
operator|&
name|dfn
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
name|SB4MAXVAL
argument_list|,
name|SQLT_LBI
argument_list|,
operator|&
operator|(
name|fieldInf
index|[
name|idx
index|]
operator|.
name|ind
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DYNAMIC_FETCH
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ofi
operator|.
name|oraType
operator|==
name|SQLT_CLOB
condition|)
block|{
name|r
operator|=
name|OCIDefineByPos
argument_list|(
name|d
operator|->
name|sql
argument_list|,
operator|&
name|dfn
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|count
argument_list|,
name|createLobLocator
argument_list|(
name|idx
argument_list|,
name|d
operator|->
name|env
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLT_CLOB
argument_list|,
operator|&
operator|(
name|fieldInf
index|[
name|idx
index|]
operator|.
name|ind
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//                 qDebug("binding SQLT_BLOB");
name|r
operator|=
name|OCIDefineByPos
argument_list|(
name|d
operator|->
name|sql
argument_list|,
operator|&
name|dfn
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|count
argument_list|,
name|createLobLocator
argument_list|(
name|idx
argument_list|,
name|d
operator|->
name|env
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLT_BLOB
argument_list|,
operator|&
operator|(
name|fieldInf
index|[
name|idx
index|]
operator|.
name|ind
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QVariant
operator|::
name|String
case|:
if|if
condition|(
name|ofi
operator|.
name|oraType
operator|==
name|SQLT_LNG
condition|)
block|{
name|r
operator|=
name|OCIDefineByPos
argument_list|(
name|d
operator|->
name|sql
argument_list|,
operator|&
name|dfn
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
name|SB4MAXVAL
argument_list|,
name|SQLT_LNG
argument_list|,
operator|&
operator|(
name|fieldInf
index|[
name|idx
index|]
operator|.
name|ind
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DYNAMIC_FETCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dataSize
operator|+=
name|dataSize
operator|+
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
expr_stmt|;
comment|//qDebug("OCIDefineByPosStr(%d): %d", count, dataSize);
name|r
operator|=
name|OCIDefineByPos
argument_list|(
name|d
operator|->
name|sql
argument_list|,
operator|&
name|dfn
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|count
argument_list|,
name|create
argument_list|(
name|idx
argument_list|,
name|dataSize
argument_list|)
argument_list|,
name|dataSize
argument_list|,
name|SQLT_STR
argument_list|,
operator|&
operator|(
name|fieldInf
index|[
name|idx
index|]
operator|.
name|ind
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|d
operator|->
name|setCharset
argument_list|(
name|dfn
argument_list|,
name|OCI_HTYPE_DEFINE
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|// this should make enough space even with character encoding
name|dataSize
operator|=
operator|(
name|dataSize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|utext
argument_list|)
expr_stmt|;
comment|//qDebug("OCIDefineByPosDef(%d): %d", count, dataSize);
name|r
operator|=
name|OCIDefineByPos
argument_list|(
name|d
operator|->
name|sql
argument_list|,
operator|&
name|dfn
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|count
argument_list|,
name|create
argument_list|(
name|idx
argument_list|,
name|dataSize
argument_list|)
argument_list|,
name|dataSize
operator|+
literal|1
argument_list|,
name|SQLT_STR
argument_list|,
operator|&
operator|(
name|fieldInf
index|[
name|idx
index|]
operator|.
name|ind
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qOraWarning
argument_list|(
literal|"QOCICols::bind:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|fieldInf
index|[
name|idx
index|]
operator|.
name|def
operator|=
name|dfn
expr_stmt|;
operator|++
name|count
expr_stmt|;
operator|++
name|idx
expr_stmt|;
name|parmStatus
operator|=
name|OCIParamGet
argument_list|(
name|d
operator|->
name|sql
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
name|d
operator|->
name|err
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|param
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_destructor
DECL|function|~QOCICols
name|QOCICols
operator|::
name|~
name|QOCICols
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|create
name|char
modifier|*
name|QOCICols
operator|::
name|create
parameter_list|(
name|int
name|position
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|c
init|=
operator|new
name|char
index|[
name|size
operator|+
literal|1
index|]
decl_stmt|;
comment|// Oracle may not fill fixed width fields
name|memset
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fieldInf
index|[
name|position
index|]
operator|.
name|data
operator|=
name|c
expr_stmt|;
name|fieldInf
index|[
name|position
index|]
operator|.
name|len
operator|=
name|size
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|createLobLocator
name|OCILobLocator
modifier|*
modifier|*
name|QOCICols
operator|::
name|createLobLocator
parameter_list|(
name|int
name|position
parameter_list|,
name|OCIEnv
modifier|*
name|env
parameter_list|)
block|{
name|OCILobLocator
modifier|*
modifier|&
name|lob
init|=
name|fieldInf
index|[
name|position
index|]
operator|.
name|lob
decl_stmt|;
name|int
name|r
init|=
name|OCIDescriptorAlloc
argument_list|(
name|env
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|lob
argument_list|)
argument_list|,
name|OCI_DTYPE_LOB
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOCICols: Cannot create LOB locator"
argument_list|)
expr_stmt|;
name|lob
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|&
name|lob
return|;
block|}
end_function
begin_function
DECL|function|readPiecewise
name|int
name|QOCICols
operator|::
name|readPiecewise
parameter_list|(
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|values
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|OCIDefine
modifier|*
name|dfn
decl_stmt|;
name|ub4
name|typep
decl_stmt|;
name|ub1
name|in_outp
decl_stmt|;
name|ub4
name|iterp
decl_stmt|;
name|ub4
name|idxp
decl_stmt|;
name|ub1
name|piecep
decl_stmt|;
name|sword
name|status
decl_stmt|;
name|text
name|col
index|[
name|QOCI_DYNAMIC_CHUNK_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|fieldNum
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|bool
name|nullField
decl_stmt|;
do|do
block|{
name|r
operator|=
name|OCIStmtGetPieceInfo
argument_list|(
name|d
operator|->
name|sql
argument_list|,
name|d
operator|->
name|err
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|dfn
argument_list|)
argument_list|,
operator|&
name|typep
argument_list|,
operator|&
name|in_outp
argument_list|,
operator|&
name|iterp
argument_list|,
operator|&
name|idxp
argument_list|,
operator|&
name|piecep
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
condition|)
name|qOraWarning
argument_list|(
literal|"OCIResultPrivate::readPiecewise: unable to get piece info:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|fieldNum
operator|=
name|fieldFromDefine
argument_list|(
name|dfn
argument_list|)
expr_stmt|;
name|bool
name|isStringField
init|=
name|fieldInf
operator|.
name|at
argument_list|(
name|fieldNum
argument_list|)
operator|.
name|oraType
operator|==
name|SQLT_LNG
decl_stmt|;
name|ub4
name|chunkSize
init|=
name|QOCI_DYNAMIC_CHUNK_SIZE
decl_stmt|;
name|nullField
operator|=
literal|false
expr_stmt|;
name|r
operator|=
name|OCIStmtSetPieceInfo
argument_list|(
name|dfn
argument_list|,
name|OCI_HTYPE_DEFINE
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|col
argument_list|,
operator|&
name|chunkSize
argument_list|,
name|piecep
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
condition|)
name|qOraWarning
argument_list|(
literal|"OCIResultPrivate::readPiecewise: unable to set piece info:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|status
operator|=
name|OCIStmtFetch
argument_list|(
name|d
operator|->
name|sql
argument_list|,
name|d
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|OCI_FETCH_NEXT
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|sb4
name|errcode
decl_stmt|;
name|OCIErrorGet
argument_list|(
name|d
operator|->
name|err
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|errcode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errcode
condition|)
block|{
case|case
literal|1405
case|:
comment|/* NULL */
name|nullField
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|qOraWarning
argument_list|(
literal|"OCIResultPrivate::readPiecewise: unable to fetch next:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|OCI_NO_DATA
condition|)
break|break;
if|if
condition|(
name|nullField
operator|||
operator|!
name|chunkSize
condition|)
block|{
name|fieldInf
index|[
name|fieldNum
index|]
operator|.
name|ind
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isStringField
condition|)
block|{
name|QString
name|str
init|=
name|values
operator|.
name|at
argument_list|(
name|fieldNum
operator|+
name|index
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|str
operator|+=
name|QString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|col
argument_list|)
argument_list|,
name|chunkSize
operator|/
literal|2
argument_list|)
expr_stmt|;
name|values
index|[
name|fieldNum
operator|+
name|index
index|]
operator|=
name|str
expr_stmt|;
name|fieldInf
index|[
name|fieldNum
index|]
operator|.
name|ind
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|QByteArray
name|ba
init|=
name|values
operator|.
name|at
argument_list|(
name|fieldNum
operator|+
name|index
argument_list|)
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|int
name|sz
init|=
name|ba
operator|.
name|size
argument_list|()
decl_stmt|;
name|ba
operator|.
name|resize
argument_list|(
name|sz
operator|+
name|chunkSize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ba
operator|.
name|data
argument_list|()
operator|+
name|sz
argument_list|,
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|col
argument_list|)
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|values
index|[
name|fieldNum
operator|+
name|index
index|]
operator|=
name|ba
expr_stmt|;
name|fieldInf
index|[
name|fieldNum
index|]
operator|.
name|ind
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|status
operator|==
name|OCI_SUCCESS_WITH_INFO
operator|||
name|status
operator|==
name|OCI_NEED_DATA
condition|)
do|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|qMakeOraField
name|OraFieldInfo
name|QOCICols
operator|::
name|qMakeOraField
parameter_list|(
specifier|const
name|QOCIResultPrivate
modifier|*
name|p
parameter_list|,
name|OCIParam
modifier|*
name|param
parameter_list|)
specifier|const
block|{
name|OraFieldInfo
name|ofi
decl_stmt|;
name|ub2
name|colType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|text
modifier|*
name|colName
init|=
literal|0
decl_stmt|;
name|ub4
name|colNameLen
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|sb1
name|colScale
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ub2
name|colLength
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ub2
name|colFieldLength
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|sb2
name|colPrecision
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ub1
name|colIsNull
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|r
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QVariant
operator|::
name|Type
name|type
argument_list|(
name|QVariant
operator|::
name|Invalid
argument_list|)
decl_stmt|;
name|r
operator|=
name|OCIAttrGet
argument_list|(
name|param
argument_list|,
name|OCI_DTYPE_PARAM
argument_list|,
operator|&
name|colType
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_DATA_TYPE
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qOraWarning
argument_list|(
literal|"qMakeOraField:"
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
name|r
operator|=
name|OCIAttrGet
argument_list|(
name|param
argument_list|,
name|OCI_DTYPE_PARAM
argument_list|,
operator|&
name|colName
argument_list|,
operator|&
name|colNameLen
argument_list|,
name|OCI_ATTR_NAME
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qOraWarning
argument_list|(
literal|"qMakeOraField:"
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
name|r
operator|=
name|OCIAttrGet
argument_list|(
name|param
argument_list|,
name|OCI_DTYPE_PARAM
argument_list|,
operator|&
name|colLength
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_DATA_SIZE
argument_list|,
comment|/* in bytes */
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qOraWarning
argument_list|(
literal|"qMakeOraField:"
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OCI_ATTR_CHAR_SIZE
name|r
operator|=
name|OCIAttrGet
argument_list|(
name|param
argument_list|,
name|OCI_DTYPE_PARAM
argument_list|,
operator|&
name|colFieldLength
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_CHAR_SIZE
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qOraWarning
argument_list|(
literal|"qMakeOraField:"
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// for Oracle8.
name|colFieldLength
operator|=
name|colLength
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|OCIAttrGet
argument_list|(
name|param
argument_list|,
name|OCI_DTYPE_PARAM
argument_list|,
operator|&
name|colPrecision
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_PRECISION
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qOraWarning
argument_list|(
literal|"qMakeOraField:"
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
name|r
operator|=
name|OCIAttrGet
argument_list|(
name|param
argument_list|,
name|OCI_DTYPE_PARAM
argument_list|,
operator|&
name|colScale
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_SCALE
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qOraWarning
argument_list|(
literal|"qMakeOraField:"
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
name|r
operator|=
name|OCIAttrGet
argument_list|(
name|param
argument_list|,
name|OCI_DTYPE_PARAM
argument_list|,
operator|&
name|colType
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_DATA_TYPE
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qOraWarning
argument_list|(
literal|"qMakeOraField:"
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
name|r
operator|=
name|OCIAttrGet
argument_list|(
name|param
argument_list|,
name|OCI_DTYPE_PARAM
argument_list|,
operator|&
name|colIsNull
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_IS_NULL
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qOraWarning
argument_list|(
literal|"qMakeOraField:"
argument_list|,
name|p
operator|->
name|err
argument_list|)
expr_stmt|;
name|type
operator|=
name|qDecodeOCIType
argument_list|(
name|colType
argument_list|,
name|p
operator|->
name|q
operator|->
name|numericalPrecisionPolicy
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|QVariant
operator|::
name|Int
condition|)
block|{
if|if
condition|(
name|colLength
operator|==
literal|22
operator|&&
name|colPrecision
operator|==
literal|0
operator|&&
name|colScale
operator|==
literal|0
condition|)
name|type
operator|=
name|QVariant
operator|::
name|String
expr_stmt|;
if|if
condition|(
name|colScale
operator|>
literal|0
condition|)
name|type
operator|=
name|QVariant
operator|::
name|String
expr_stmt|;
block|}
comment|// bind as double if the precision policy asks for it
if|if
condition|(
operator|(
operator|(
name|colType
operator|==
name|SQLT_FLT
operator|)
operator|||
operator|(
name|colType
operator|==
name|SQLT_NUM
operator|)
operator|)
operator|&&
operator|(
name|p
operator|->
name|q
operator|->
name|numericalPrecisionPolicy
argument_list|()
operator|==
name|QSql
operator|::
name|LowPrecisionDouble
operator|)
condition|)
block|{
name|type
operator|=
name|QVariant
operator|::
name|Double
expr_stmt|;
block|}
comment|// bind as int32 or int64 if the precision policy asks for it
if|if
condition|(
operator|(
name|colType
operator|==
name|SQLT_NUM
operator|)
operator|||
operator|(
name|colType
operator|==
name|SQLT_VNU
operator|)
operator|||
operator|(
name|colType
operator|==
name|SQLT_UIN
operator|)
operator|||
operator|(
name|colType
operator|==
name|SQLT_INT
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|q
operator|->
name|numericalPrecisionPolicy
argument_list|()
operator|==
name|QSql
operator|::
name|LowPrecisionInt64
condition|)
name|type
operator|=
name|QVariant
operator|::
name|LongLong
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|q
operator|->
name|numericalPrecisionPolicy
argument_list|()
operator|==
name|QSql
operator|::
name|LowPrecisionInt32
condition|)
name|type
operator|=
name|QVariant
operator|::
name|Int
expr_stmt|;
block|}
if|if
condition|(
name|colType
operator|==
name|SQLT_BLOB
condition|)
name|colLength
operator|=
literal|0
expr_stmt|;
comment|// colNameLen is length in bytes
name|ofi
operator|.
name|name
operator|=
name|QString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|colName
argument_list|)
argument_list|,
name|colNameLen
operator|/
literal|2
argument_list|)
expr_stmt|;
name|ofi
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|ofi
operator|.
name|oraType
operator|=
name|colType
expr_stmt|;
name|ofi
operator|.
name|oraFieldLength
operator|=
name|colFieldLength
expr_stmt|;
name|ofi
operator|.
name|oraLength
operator|=
name|colLength
expr_stmt|;
name|ofi
operator|.
name|oraScale
operator|=
name|colScale
expr_stmt|;
name|ofi
operator|.
name|oraPrecision
operator|=
name|colPrecision
expr_stmt|;
name|ofi
operator|.
name|oraIsNull
operator|=
name|colIsNull
expr_stmt|;
return|return
name|ofi
return|;
block|}
end_function
begin_struct
DECL|struct|QOCIBatchColumn
struct|struct
name|QOCIBatchColumn
block|{
DECL|function|QOCIBatchColumn
specifier|inline
name|QOCIBatchColumn
parameter_list|()
member_init_list|:
name|bindh
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bindAs
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|maxLen
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|recordCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|data
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lengths
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|indicators
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|maxarr_len
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|curelep
argument_list|(
literal|0
argument_list|)
block|{}
DECL|member|bindh
name|OCIBind
modifier|*
name|bindh
decl_stmt|;
DECL|member|bindAs
name|ub2
name|bindAs
decl_stmt|;
DECL|member|maxLen
name|ub4
name|maxLen
decl_stmt|;
DECL|member|recordCount
name|ub4
name|recordCount
decl_stmt|;
DECL|member|data
name|char
modifier|*
name|data
decl_stmt|;
DECL|member|lengths
name|ub2
modifier|*
name|lengths
decl_stmt|;
DECL|member|indicators
name|sb2
modifier|*
name|indicators
decl_stmt|;
DECL|member|maxarr_len
name|ub4
name|maxarr_len
decl_stmt|;
DECL|member|curelep
name|ub4
name|curelep
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|QOCIBatchCleanupHandler
struct|struct
name|QOCIBatchCleanupHandler
block|{
DECL|function|QOCIBatchCleanupHandler
specifier|inline
name|QOCIBatchCleanupHandler
parameter_list|(
name|QVector
argument_list|<
name|QOCIBatchColumn
argument_list|>
modifier|&
name|columns
parameter_list|)
member_init_list|:
name|col
argument_list|(
name|columns
argument_list|)
block|{}
DECL|function|~QOCIBatchCleanupHandler
name|~
name|QOCIBatchCleanupHandler
parameter_list|()
block|{
comment|// deleting storage, length and indicator arrays
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|col
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
operator|delete
index|[]
name|col
index|[
name|j
index|]
operator|.
name|lengths
expr_stmt|;
operator|delete
index|[]
name|col
index|[
name|j
index|]
operator|.
name|indicators
expr_stmt|;
operator|delete
index|[]
name|col
index|[
name|j
index|]
operator|.
name|data
expr_stmt|;
block|}
block|}
DECL|member|col
name|QVector
argument_list|<
name|QOCIBatchColumn
argument_list|>
modifier|&
name|col
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|execBatch
name|bool
name|QOCICols
operator|::
name|execBatch
parameter_list|(
name|QOCIResultPrivate
modifier|*
name|d
parameter_list|,
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|boundValues
parameter_list|,
name|bool
name|arrayBind
parameter_list|)
block|{
name|int
name|columnCount
init|=
name|boundValues
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|boundValues
operator|.
name|isEmpty
argument_list|()
operator|||
name|columnCount
operator|==
literal|0
condition|)
return|return
literal|false
return|;
ifdef|#
directive|ifdef
name|QOCI_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"columnCount:"
operator|<<
name|columnCount
operator|<<
name|boundValues
expr_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|sword
name|r
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|QVariant
operator|::
name|Type
argument_list|>
name|fieldTypes
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|columnCount
condition|;
operator|++
name|i
control|)
block|{
name|QVariant
operator|::
name|Type
name|tp
init|=
name|boundValues
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|type
argument_list|()
decl_stmt|;
name|fieldTypes
operator|.
name|append
argument_list|(
name|tp
operator|==
name|QVariant
operator|::
name|List
condition|?
name|boundValues
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toList
argument_list|()
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|type
argument_list|()
else|:
name|tp
argument_list|)
expr_stmt|;
block|}
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|tmpStorage
decl_stmt|;
name|SizeArray
name|tmpSizes
argument_list|(
name|columnCount
argument_list|)
decl_stmt|;
name|QVector
argument_list|<
name|QOCIBatchColumn
argument_list|>
name|columns
argument_list|(
name|columnCount
argument_list|)
decl_stmt|;
name|QOCIBatchCleanupHandler
name|cleaner
argument_list|(
name|columns
argument_list|)
decl_stmt|;
comment|// figuring out buffer sizes
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|columnCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|boundValues
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|type
argument_list|()
operator|!=
name|QVariant
operator|::
name|List
condition|)
block|{
comment|// not a list - create a deep-copy of the single value
name|QOCIBatchColumn
modifier|&
name|singleCol
init|=
name|columns
index|[
name|i
index|]
decl_stmt|;
name|singleCol
operator|.
name|indicators
operator|=
operator|new
name|sb2
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|singleCol
operator|.
name|indicators
operator|=
name|boundValues
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isNull
argument_list|()
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|r
operator|=
name|d
operator|->
name|bindValue
argument_list|(
name|d
operator|->
name|sql
argument_list|,
operator|&
name|singleCol
operator|.
name|bindh
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|i
argument_list|,
name|boundValues
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|singleCol
operator|.
name|indicators
argument_list|,
operator|&
name|tmpSizes
index|[
name|i
index|]
argument_list|,
name|tmpStorage
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
operator|&&
name|r
operator|!=
name|OCI_SUCCESS_WITH_INFO
condition|)
block|{
name|qOraWarning
argument_list|(
literal|"QOCIPrivate::execBatch: unable to bind column:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|d
operator|->
name|q
operator|->
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QOCIResult"
argument_list|,
literal|"Unable to bind column for batch execute"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
continue|continue;
block|}
name|QOCIBatchColumn
modifier|&
name|col
init|=
name|columns
index|[
name|i
index|]
decl_stmt|;
name|col
operator|.
name|recordCount
operator|=
name|boundValues
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toList
argument_list|()
operator|.
name|count
argument_list|()
expr_stmt|;
name|col
operator|.
name|lengths
operator|=
operator|new
name|ub2
index|[
name|col
operator|.
name|recordCount
index|]
expr_stmt|;
name|col
operator|.
name|indicators
operator|=
operator|new
name|sb2
index|[
name|col
operator|.
name|recordCount
index|]
expr_stmt|;
name|col
operator|.
name|maxarr_len
operator|=
name|col
operator|.
name|recordCount
expr_stmt|;
name|col
operator|.
name|curelep
operator|=
name|col
operator|.
name|recordCount
expr_stmt|;
switch|switch
condition|(
name|fieldTypes
index|[
name|i
index|]
condition|)
block|{
case|case
name|QVariant
operator|::
name|Time
case|:
case|case
name|QVariant
operator|::
name|Date
case|:
case|case
name|QVariant
operator|::
name|DateTime
case|:
name|col
operator|.
name|bindAs
operator|=
name|SQLT_DAT
expr_stmt|;
name|col
operator|.
name|maxLen
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Int
case|:
name|col
operator|.
name|bindAs
operator|=
name|SQLT_INT
expr_stmt|;
name|col
operator|.
name|maxLen
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|UInt
case|:
name|col
operator|.
name|bindAs
operator|=
name|SQLT_UIN
expr_stmt|;
name|col
operator|.
name|maxLen
operator|=
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|LongLong
case|:
name|col
operator|.
name|bindAs
operator|=
name|SQLT_VNU
expr_stmt|;
name|col
operator|.
name|maxLen
operator|=
sizeof|sizeof
argument_list|(
name|OCINumber
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|ULongLong
case|:
name|col
operator|.
name|bindAs
operator|=
name|SQLT_VNU
expr_stmt|;
name|col
operator|.
name|maxLen
operator|=
sizeof|sizeof
argument_list|(
name|OCINumber
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Double
case|:
name|col
operator|.
name|bindAs
operator|=
name|SQLT_FLT
expr_stmt|;
name|col
operator|.
name|maxLen
operator|=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|UserType
case|:
name|col
operator|.
name|bindAs
operator|=
name|SQLT_RDD
expr_stmt|;
name|col
operator|.
name|maxLen
operator|=
sizeof|sizeof
argument_list|(
name|OCIRowid
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|String
case|:
block|{
name|col
operator|.
name|bindAs
operator|=
name|SQLT_STR
expr_stmt|;
for|for
control|(
name|uint
name|j
init|=
literal|0
init|;
name|j
operator|<
name|col
operator|.
name|recordCount
condition|;
operator|++
name|j
control|)
block|{
name|uint
name|len
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|isOutValue
argument_list|(
name|i
argument_list|)
condition|)
name|len
operator|=
name|boundValues
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toList
argument_list|()
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|capacity
argument_list|()
operator|+
literal|1
expr_stmt|;
else|else
name|len
operator|=
name|boundValues
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toList
argument_list|()
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|col
operator|.
name|maxLen
condition|)
name|col
operator|.
name|maxLen
operator|=
name|len
expr_stmt|;
block|}
name|col
operator|.
name|maxLen
operator|*=
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|ByteArray
case|:
default|default:
block|{
name|col
operator|.
name|bindAs
operator|=
name|SQLT_LBI
expr_stmt|;
for|for
control|(
name|uint
name|j
init|=
literal|0
init|;
name|j
operator|<
name|col
operator|.
name|recordCount
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|d
operator|->
name|isOutValue
argument_list|(
name|i
argument_list|)
condition|)
name|col
operator|.
name|lengths
index|[
name|j
index|]
operator|=
name|boundValues
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toList
argument_list|()
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|toByteArray
argument_list|()
operator|.
name|capacity
argument_list|()
expr_stmt|;
else|else
name|col
operator|.
name|lengths
index|[
name|j
index|]
operator|=
name|boundValues
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toList
argument_list|()
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|toByteArray
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|col
operator|.
name|lengths
index|[
name|j
index|]
operator|>
name|col
operator|.
name|maxLen
condition|)
name|col
operator|.
name|maxLen
operator|=
name|col
operator|.
name|lengths
index|[
name|j
index|]
expr_stmt|;
block|}
break|break;
block|}
block|}
name|col
operator|.
name|data
operator|=
operator|new
name|char
index|[
name|col
operator|.
name|maxLen
operator|*
name|col
operator|.
name|recordCount
index|]
expr_stmt|;
name|memset
argument_list|(
name|col
operator|.
name|data
argument_list|,
literal|0
argument_list|,
name|col
operator|.
name|maxLen
operator|*
name|col
operator|.
name|recordCount
argument_list|)
expr_stmt|;
comment|// we may now populate column with data
for|for
control|(
name|uint
name|row
init|=
literal|0
init|;
name|row
operator|<
name|col
operator|.
name|recordCount
condition|;
operator|++
name|row
control|)
block|{
specifier|const
name|QVariant
modifier|&
name|val
init|=
name|boundValues
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toList
argument_list|()
operator|.
name|at
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|columns
index|[
name|i
index|]
operator|.
name|indicators
index|[
name|row
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|columns
index|[
name|i
index|]
operator|.
name|lengths
index|[
name|row
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|columns
index|[
name|i
index|]
operator|.
name|indicators
index|[
name|row
index|]
operator|=
literal|0
expr_stmt|;
name|char
modifier|*
name|dataPtr
init|=
name|columns
index|[
name|i
index|]
operator|.
name|data
operator|+
operator|(
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
operator|*
name|row
operator|)
decl_stmt|;
switch|switch
condition|(
name|fieldTypes
index|[
name|i
index|]
condition|)
block|{
case|case
name|QVariant
operator|::
name|Time
case|:
case|case
name|QVariant
operator|::
name|Date
case|:
case|case
name|QVariant
operator|::
name|DateTime
case|:
block|{
name|columns
index|[
name|i
index|]
operator|.
name|lengths
index|[
name|row
index|]
operator|=
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
expr_stmt|;
specifier|const
name|QByteArray
name|ba
init|=
name|qMakeOraDate
argument_list|(
name|val
operator|.
name|toDateTime
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ba
operator|.
name|size
argument_list|()
operator|==
name|int
argument_list|(
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dataPtr
argument_list|,
name|ba
operator|.
name|constData
argument_list|()
argument_list|,
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|Int
case|:
name|columns
index|[
name|i
index|]
operator|.
name|lengths
index|[
name|row
index|]
operator|=
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
expr_stmt|;
operator|*
cast|reinterpret_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|dataPtr
argument_list|)
operator|=
name|val
operator|.
name|toInt
argument_list|()
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|UInt
case|:
name|columns
index|[
name|i
index|]
operator|.
name|lengths
index|[
name|row
index|]
operator|=
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
expr_stmt|;
operator|*
cast|reinterpret_cast
argument_list|<
name|uint
operator|*
argument_list|>
argument_list|(
name|dataPtr
argument_list|)
operator|=
name|val
operator|.
name|toUInt
argument_list|()
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|LongLong
case|:
block|{
name|columns
index|[
name|i
index|]
operator|.
name|lengths
index|[
name|row
index|]
operator|=
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
expr_stmt|;
specifier|const
name|QByteArray
name|ba
init|=
name|qMakeOCINumber
argument_list|(
name|val
operator|.
name|toLongLong
argument_list|()
argument_list|,
name|d
operator|->
name|err
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ba
operator|.
name|size
argument_list|()
operator|==
name|int
argument_list|(
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dataPtr
argument_list|,
name|ba
operator|.
name|constData
argument_list|()
argument_list|,
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|ULongLong
case|:
block|{
name|columns
index|[
name|i
index|]
operator|.
name|lengths
index|[
name|row
index|]
operator|=
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
expr_stmt|;
specifier|const
name|QByteArray
name|ba
init|=
name|qMakeOCINumber
argument_list|(
name|val
operator|.
name|toULongLong
argument_list|()
argument_list|,
name|d
operator|->
name|err
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ba
operator|.
name|size
argument_list|()
operator|==
name|int
argument_list|(
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dataPtr
argument_list|,
name|ba
operator|.
name|constData
argument_list|()
argument_list|,
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|Double
case|:
name|columns
index|[
name|i
index|]
operator|.
name|lengths
index|[
name|row
index|]
operator|=
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
expr_stmt|;
operator|*
cast|reinterpret_cast
argument_list|<
name|double
operator|*
argument_list|>
argument_list|(
name|dataPtr
argument_list|)
operator|=
name|val
operator|.
name|toDouble
argument_list|()
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|String
case|:
block|{
specifier|const
name|QString
name|s
init|=
name|val
operator|.
name|toString
argument_list|()
decl_stmt|;
name|columns
index|[
name|i
index|]
operator|.
name|lengths
index|[
name|row
index|]
operator|=
operator|(
name|s
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dataPtr
argument_list|,
name|s
operator|.
name|utf16
argument_list|()
argument_list|,
name|columns
index|[
name|i
index|]
operator|.
name|lengths
index|[
name|row
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|UserType
case|:
if|if
condition|(
name|val
operator|.
name|canConvert
argument_list|<
name|QOCIRowIdPointer
argument_list|>
argument_list|()
condition|)
block|{
specifier|const
name|QOCIRowIdPointer
name|rptr
init|=
name|qvariant_cast
argument_list|<
name|QOCIRowIdPointer
argument_list|>
argument_list|(
name|val
argument_list|)
decl_stmt|;
operator|*
cast|reinterpret_cast
argument_list|<
name|OCIRowid
operator|*
operator|*
argument_list|>
argument_list|(
name|dataPtr
argument_list|)
operator|=
name|rptr
operator|->
name|id
expr_stmt|;
name|columns
index|[
name|i
index|]
operator|.
name|lengths
index|[
name|row
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|ByteArray
case|:
default|default:
block|{
specifier|const
name|QByteArray
name|ba
init|=
name|val
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|columns
index|[
name|i
index|]
operator|.
name|lengths
index|[
name|row
index|]
operator|=
name|ba
operator|.
name|size
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|dataPtr
argument_list|,
name|ba
operator|.
name|constData
argument_list|()
argument_list|,
name|ba
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|QOCIBatchColumn
modifier|&
name|bindColumn
init|=
name|columns
index|[
name|i
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|QOCI_DEBUG
name|qDebug
argument_list|(
literal|"OCIBindByPos(%p, %p, %p, %d, %p, %d, %d, %p, %p, 0, %d, %p, OCI_DEFAULT)"
argument_list|,
name|d
operator|->
name|sql
argument_list|,
operator|&
name|bindColumn
operator|.
name|bindh
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|bindColumn
operator|.
name|data
argument_list|,
name|bindColumn
operator|.
name|maxLen
argument_list|,
name|bindColumn
operator|.
name|bindAs
argument_list|,
name|bindColumn
operator|.
name|indicators
argument_list|,
name|bindColumn
operator|.
name|lengths
argument_list|,
name|arrayBind
condition|?
name|bindColumn
operator|.
name|maxarr_len
else|:
literal|0
argument_list|,
name|arrayBind
condition|?
operator|&
name|bindColumn
operator|.
name|curelep
else|:
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
operator|(
name|int
operator|)
name|bindColumn
operator|.
name|recordCount
condition|;
operator|++
name|ii
control|)
block|{
name|qDebug
argument_list|(
literal|" record %d: indicator %d, length %d"
argument_list|,
name|ii
argument_list|,
name|bindColumn
operator|.
name|indicators
index|[
name|ii
index|]
argument_list|,
name|bindColumn
operator|.
name|lengths
index|[
name|ii
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// binding the column
name|r
operator|=
name|OCIBindByPos
argument_list|(
name|d
operator|->
name|sql
argument_list|,
operator|&
name|bindColumn
operator|.
name|bindh
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|bindColumn
operator|.
name|data
argument_list|,
name|bindColumn
operator|.
name|maxLen
argument_list|,
name|bindColumn
operator|.
name|bindAs
argument_list|,
name|bindColumn
operator|.
name|indicators
argument_list|,
name|bindColumn
operator|.
name|lengths
argument_list|,
literal|0
argument_list|,
name|arrayBind
condition|?
name|bindColumn
operator|.
name|maxarr_len
else|:
literal|0
argument_list|,
name|arrayBind
condition|?
operator|&
name|bindColumn
operator|.
name|curelep
else|:
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QOCI_DEBUG
name|qDebug
argument_list|(
literal|"After OCIBindByPos: r = %d, bindh = %p"
argument_list|,
name|r
argument_list|,
name|bindColumn
operator|.
name|bindh
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
operator|&&
name|r
operator|!=
name|OCI_SUCCESS_WITH_INFO
condition|)
block|{
name|qOraWarning
argument_list|(
literal|"QOCIPrivate::execBatch: unable to bind column:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|d
operator|->
name|q
operator|->
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QOCIResult"
argument_list|,
literal|"Unable to bind column for batch execute"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|r
operator|=
name|OCIBindArrayOfStruct
argument_list|(
name|columns
index|[
name|i
index|]
operator|.
name|bindh
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|,
sizeof|sizeof
argument_list|(
name|columns
index|[
name|i
index|]
operator|.
name|indicators
index|[
literal|0
index|]
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|columns
index|[
name|i
index|]
operator|.
name|lengths
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
operator|&&
name|r
operator|!=
name|OCI_SUCCESS_WITH_INFO
condition|)
block|{
name|qOraWarning
argument_list|(
literal|"QOCIPrivate::execBatch: unable to bind column:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|d
operator|->
name|q
operator|->
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QOCIResult"
argument_list|,
literal|"Unable to bind column for batch execute"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|//finaly we can execute
name|r
operator|=
name|OCIStmtExecute
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|d
operator|->
name|sql
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|arrayBind
condition|?
literal|1
else|:
name|columns
index|[
literal|0
index|]
operator|.
name|recordCount
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|d
operator|->
name|transaction
condition|?
name|OCI_DEFAULT
else|:
name|OCI_COMMIT_ON_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
operator|&&
name|r
operator|!=
name|OCI_SUCCESS_WITH_INFO
condition|)
block|{
name|qOraWarning
argument_list|(
literal|"QOCIPrivate::execBatch: unable to execute batch statement:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|d
operator|->
name|q
operator|->
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QOCIResult"
argument_list|,
literal|"Unable to execute batch statement"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// for out parameters we copy data back to value vector
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|columnCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|isOutValue
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|QVariant
operator|::
name|Type
name|tp
init|=
name|boundValues
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|tp
operator|!=
name|QVariant
operator|::
name|List
condition|)
block|{
name|qOraOutValue
argument_list|(
name|boundValues
index|[
name|i
index|]
argument_list|,
name|tmpStorage
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|columns
index|[
name|i
index|]
operator|.
name|indicators
operator|==
operator|-
literal|1
condition|)
name|boundValues
index|[
name|i
index|]
operator|=
name|QVariant
argument_list|(
name|tp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|QVariantList
modifier|*
name|list
init|=
cast|static_cast
argument_list|<
name|QVariantList
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|boundValues
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|columns
index|[
name|i
index|]
operator|.
name|data
decl_stmt|;
for|for
control|(
name|uint
name|r
init|=
literal|0
init|;
name|r
operator|<
name|columns
index|[
name|i
index|]
operator|.
name|recordCount
condition|;
operator|++
name|r
control|)
block|{
if|if
condition|(
name|columns
index|[
name|i
index|]
operator|.
name|indicators
index|[
name|r
index|]
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
operator|*
name|list
operator|)
index|[
name|r
index|]
operator|=
name|QVariant
argument_list|()
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|columns
index|[
name|i
index|]
operator|.
name|bindAs
condition|)
block|{
case|case
name|SQLT_DAT
case|:
operator|(
operator|*
name|list
operator|)
index|[
name|r
index|]
operator|=
name|qMakeDate
argument_list|(
name|data
operator|+
name|r
operator|*
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|)
expr_stmt|;
break|break;
case|case
name|SQLT_INT
case|:
operator|(
operator|*
name|list
operator|)
index|[
name|r
index|]
operator|=
operator|*
cast|reinterpret_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|data
operator|+
name|r
operator|*
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|)
expr_stmt|;
break|break;
case|case
name|SQLT_UIN
case|:
operator|(
operator|*
name|list
operator|)
index|[
name|r
index|]
operator|=
operator|*
cast|reinterpret_cast
argument_list|<
name|uint
operator|*
argument_list|>
argument_list|(
name|data
operator|+
name|r
operator|*
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|)
expr_stmt|;
break|break;
case|case
name|SQLT_VNU
case|:
block|{
switch|switch
condition|(
name|boundValues
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|QVariant
operator|::
name|LongLong
case|:
operator|(
operator|*
name|list
operator|)
index|[
name|r
index|]
operator|=
name|qMakeLongLong
argument_list|(
name|data
operator|+
name|r
operator|*
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|ULongLong
case|:
operator|(
operator|*
name|list
operator|)
index|[
name|r
index|]
operator|=
name|qMakeULongLong
argument_list|(
name|data
operator|+
name|r
operator|*
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
block|}
case|case
name|SQLT_FLT
case|:
operator|(
operator|*
name|list
operator|)
index|[
name|r
index|]
operator|=
operator|*
cast|reinterpret_cast
argument_list|<
name|double
operator|*
argument_list|>
argument_list|(
name|data
operator|+
name|r
operator|*
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|)
expr_stmt|;
break|break;
case|case
name|SQLT_STR
case|:
operator|(
operator|*
name|list
operator|)
index|[
name|r
index|]
operator|=
name|QString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|data
operator|+
name|r
operator|*
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
operator|*
name|list
operator|)
index|[
name|r
index|]
operator|=
name|QByteArray
argument_list|(
name|data
operator|+
name|r
operator|*
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|,
name|columns
index|[
name|i
index|]
operator|.
name|maxLen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|d
operator|->
name|q
operator|->
name|setSelect
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|q
operator|->
name|setAt
argument_list|(
name|QSql
operator|::
name|BeforeFirstRow
argument_list|)
expr_stmt|;
name|d
operator|->
name|q
operator|->
name|setActive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|class
name|T
parameter_list|,
name|int
name|sz
parameter_list|>
DECL|function|qReadLob
name|int
name|qReadLob
parameter_list|(
name|T
modifier|&
name|buf
parameter_list|,
specifier|const
name|QOCIResultPrivate
modifier|*
name|d
parameter_list|,
name|OCILobLocator
modifier|*
name|lob
parameter_list|)
block|{
name|ub1
name|csfrm
decl_stmt|;
name|ub4
name|amount
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|// Read this from the database, don't assume we know what it is set to
name|r
operator|=
name|OCILobCharSetForm
argument_list|(
name|d
operator|->
name|env
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|lob
argument_list|,
operator|&
name|csfrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
condition|)
block|{
name|qOraWarning
argument_list|(
literal|"OCIResultPrivate::readLobs: Couldn't get LOB char set form: "
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|csfrm
operator|=
literal|0
expr_stmt|;
block|}
comment|// Get the length of the LOB (this is in characters)
name|r
operator|=
name|OCILobGetLength
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|lob
argument_list|,
operator|&
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
block|{
if|if
condition|(
name|amount
operator|==
literal|0
condition|)
block|{
comment|// Short cut for null LOBs
name|buf
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|OCI_SUCCESS
return|;
block|}
block|}
else|else
block|{
name|qOraWarning
argument_list|(
literal|"OCIResultPrivate::readLobs: Couldn't get LOB length: "
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|// Resize the buffer to hold the LOB contents
name|buf
operator|.
name|resize
argument_list|(
name|amount
argument_list|)
expr_stmt|;
comment|// Read the LOB into the buffer
name|r
operator|=
name|OCILobRead
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|lob
argument_list|,
operator|&
name|amount
argument_list|,
literal|1
argument_list|,
name|buf
operator|.
name|data
argument_list|()
argument_list|,
name|buf
operator|.
name|size
argument_list|()
operator|*
name|sz
argument_list|,
comment|// this argument is in bytes, not characters
literal|0
argument_list|,
literal|0
argument_list|,
comment|// Extract the data from a CLOB in UTF-16 (ie. what QString uses internally)
name|sz
operator|==
literal|1
condition|?
name|ub2
argument_list|(
literal|0
argument_list|)
else|:
name|ub2
argument_list|(
name|QOCIEncoding
argument_list|)
argument_list|,
name|csfrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
condition|)
name|qOraWarning
argument_list|(
literal|"OCIResultPrivate::readLOBs: Cannot read LOB: "
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|readLOBs
name|int
name|QOCICols
operator|::
name|readLOBs
parameter_list|(
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|values
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|OCILobLocator
modifier|*
name|lob
decl_stmt|;
name|int
name|r
init|=
name|OCI_SUCCESS
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|OraFieldInf
modifier|&
name|fi
init|=
name|fieldInf
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|ind
operator|==
operator|-
literal|1
operator|||
operator|!
operator|(
name|lob
operator|=
name|fi
operator|.
name|lob
operator|)
condition|)
continue|continue;
name|bool
name|isClob
init|=
name|fi
operator|.
name|oraType
operator|==
name|SQLT_CLOB
decl_stmt|;
name|QVariant
name|var
decl_stmt|;
if|if
condition|(
name|isClob
condition|)
block|{
name|QString
name|str
decl_stmt|;
name|r
operator|=
name|qReadLob
operator|<
name|QString
operator|,
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
operator|>
operator|(
name|str
operator|,
name|d
operator|,
name|lob
operator|)
expr_stmt|;
name|var
operator|=
name|str
expr_stmt|;
block|}
else|else
block|{
name|QByteArray
name|buf
decl_stmt|;
name|r
operator|=
name|qReadLob
operator|<
name|QByteArray
operator|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|>
operator|(
name|buf
operator|,
name|d
operator|,
name|lob
operator|)
expr_stmt|;
name|var
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
name|values
index|[
name|index
operator|+
name|i
index|]
operator|=
name|var
expr_stmt|;
else|else
break|break;
block|}
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|fieldFromDefine
name|int
name|QOCICols
operator|::
name|fieldFromDefine
parameter_list|(
name|OCIDefine
modifier|*
name|d
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldInf
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fieldInf
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|def
operator|==
name|d
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|getValues
name|void
name|QOCICols
operator|::
name|getValues
parameter_list|(
name|QVector
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|v
parameter_list|,
name|int
name|index
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldInf
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|OraFieldInf
modifier|&
name|fld
init|=
name|fieldInf
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|fld
operator|.
name|ind
operator|==
operator|-
literal|1
condition|)
block|{
comment|// got a NULL value
name|v
index|[
name|index
operator|+
name|i
index|]
operator|=
name|QVariant
argument_list|(
name|fld
operator|.
name|typ
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fld
operator|.
name|oraType
operator|==
name|SQLT_BIN
operator|||
name|fld
operator|.
name|oraType
operator|==
name|SQLT_LBI
operator|||
name|fld
operator|.
name|oraType
operator|==
name|SQLT_LNG
condition|)
continue|continue;
comment|// already fetched piecewise
switch|switch
condition|(
name|fld
operator|.
name|typ
condition|)
block|{
case|case
name|QVariant
operator|::
name|DateTime
case|:
name|v
index|[
name|index
operator|+
name|i
index|]
operator|=
name|QVariant
argument_list|(
name|qMakeDate
argument_list|(
name|fld
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Double
case|:
case|case
name|QVariant
operator|::
name|Int
case|:
case|case
name|QVariant
operator|::
name|LongLong
case|:
if|if
condition|(
name|d
operator|->
name|q
operator|->
name|numericalPrecisionPolicy
argument_list|()
operator|!=
name|QSql
operator|::
name|HighPrecision
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|q
operator|->
name|numericalPrecisionPolicy
argument_list|()
operator|==
name|QSql
operator|::
name|LowPrecisionDouble
operator|)
operator|&&
operator|(
name|fld
operator|.
name|typ
operator|==
name|QVariant
operator|::
name|Double
operator|)
condition|)
block|{
name|v
index|[
name|index
operator|+
name|i
index|]
operator|=
operator|*
cast|reinterpret_cast
argument_list|<
name|double
operator|*
argument_list|>
argument_list|(
name|fld
operator|.
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|d
operator|->
name|q
operator|->
name|numericalPrecisionPolicy
argument_list|()
operator|==
name|QSql
operator|::
name|LowPrecisionInt64
operator|)
operator|&&
operator|(
name|fld
operator|.
name|typ
operator|==
name|QVariant
operator|::
name|LongLong
operator|)
condition|)
block|{
name|qint64
name|qll
init|=
literal|0
decl_stmt|;
name|int
name|r
init|=
name|OCINumberToInt
argument_list|(
name|d
operator|->
name|err
argument_list|,
cast|reinterpret_cast
argument_list|<
name|OCINumber
operator|*
argument_list|>
argument_list|(
name|fld
operator|.
name|data
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|qint64
argument_list|)
argument_list|,
name|OCI_NUMBER_SIGNED
argument_list|,
operator|&
name|qll
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
name|v
index|[
name|index
operator|+
name|i
index|]
operator|=
name|qll
expr_stmt|;
else|else
name|v
index|[
name|index
operator|+
name|i
index|]
operator|=
name|QVariant
argument_list|()
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|d
operator|->
name|q
operator|->
name|numericalPrecisionPolicy
argument_list|()
operator|==
name|QSql
operator|::
name|LowPrecisionInt32
operator|)
operator|&&
operator|(
name|fld
operator|.
name|typ
operator|==
name|QVariant
operator|::
name|Int
operator|)
condition|)
block|{
name|v
index|[
name|index
operator|+
name|i
index|]
operator|=
operator|*
cast|reinterpret_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|fld
operator|.
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// else fall through
case|case
name|QVariant
operator|::
name|String
case|:
name|v
index|[
name|index
operator|+
name|i
index|]
operator|=
name|QString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|fld
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|ByteArray
case|:
if|if
condition|(
name|fld
operator|.
name|len
operator|>
literal|0
condition|)
name|v
index|[
name|index
operator|+
name|i
index|]
operator|=
name|QByteArray
argument_list|(
name|fld
operator|.
name|data
argument_list|,
name|fld
operator|.
name|len
argument_list|)
expr_stmt|;
else|else
name|v
index|[
name|index
operator|+
name|i
index|]
operator|=
name|QVariant
argument_list|(
name|QVariant
operator|::
name|ByteArray
argument_list|)
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QOCICols::value: unknown data type"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_constructor
DECL|function|QOCIResultPrivate
name|QOCIResultPrivate
operator|::
name|QOCIResultPrivate
parameter_list|(
name|QOCIResult
modifier|*
name|result
parameter_list|,
specifier|const
name|QOCIDriverPrivate
modifier|*
name|driver
parameter_list|)
member_init_list|:
name|cols
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|q
argument_list|(
name|result
argument_list|)
member_init_list|,
name|env
argument_list|(
name|driver
operator|->
name|env
argument_list|)
member_init_list|,
name|err
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|svc
argument_list|(
cast|const_cast
argument_list|<
name|OCISvcCtx
operator|*
operator|&
argument_list|>
argument_list|(
name|driver
operator|->
name|svc
argument_list|)
argument_list|)
member_init_list|,
name|sql
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|transaction
argument_list|(
name|driver
operator|->
name|transaction
argument_list|)
member_init_list|,
name|serverVersion
argument_list|(
name|driver
operator|->
name|serverVersion
argument_list|)
member_init_list|,
name|prefetchRows
argument_list|(
name|driver
operator|->
name|prefetchRows
argument_list|)
member_init_list|,
name|prefetchMem
argument_list|(
name|driver
operator|->
name|prefetchMem
argument_list|)
block|{
name|int
name|r
init|=
name|OCIHandleAlloc
argument_list|(
name|env
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|err
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qWarning
argument_list|(
literal|"QOCIResult: unable to alloc error handle"
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QOCIResultPrivate
name|QOCIResultPrivate
operator|::
name|~
name|QOCIResultPrivate
parameter_list|()
block|{
operator|delete
name|cols
expr_stmt|;
name|int
name|r
init|=
name|OCIHandleFree
argument_list|(
name|err
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qWarning
argument_list|(
literal|"~QOCIResult: unable to free statement handle"
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|////////////////////////////////////////////////////////////////////////////
end_comment
begin_constructor
DECL|function|QOCIResult
name|QOCIResult
operator|::
name|QOCIResult
parameter_list|(
specifier|const
name|QOCIDriver
modifier|*
name|db
parameter_list|,
specifier|const
name|QOCIDriverPrivate
modifier|*
name|p
parameter_list|)
member_init_list|:
name|QSqlCachedResult
argument_list|(
name|db
argument_list|)
block|{
name|d
operator|=
operator|new
name|QOCIResultPrivate
argument_list|(
name|this
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QOCIResult
name|QOCIResult
operator|::
name|~
name|QOCIResult
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|sql
condition|)
block|{
name|int
name|r
init|=
name|OCIHandleFree
argument_list|(
name|d
operator|->
name|sql
argument_list|,
name|OCI_HTYPE_STMT
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|qWarning
argument_list|(
literal|"~QOCIResult: unable to free statement handle"
argument_list|)
expr_stmt|;
block|}
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|handle
name|QVariant
name|QOCIResult
operator|::
name|handle
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
operator|::
name|fromValue
argument_list|(
name|d
operator|->
name|sql
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|reset
name|bool
name|QOCIResult
operator|::
name|reset
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|)
block|{
if|if
condition|(
operator|!
name|prepare
argument_list|(
name|query
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
name|exec
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|gotoNext
name|bool
name|QOCIResult
operator|::
name|gotoNext
parameter_list|(
name|QSqlCachedResult
operator|::
name|ValueCache
modifier|&
name|values
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|at
argument_list|()
operator|==
name|QSql
operator|::
name|AfterLastRow
condition|)
return|return
literal|false
return|;
name|bool
name|piecewise
init|=
literal|false
decl_stmt|;
name|int
name|r
init|=
name|OCI_SUCCESS
decl_stmt|;
name|r
operator|=
name|OCIStmtFetch
argument_list|(
name|d
operator|->
name|sql
argument_list|,
name|d
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|OCI_FETCH_NEXT
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
comment|//not interested in values
return|return
name|r
operator|==
name|OCI_SUCCESS
operator|||
name|r
operator|==
name|OCI_SUCCESS_WITH_INFO
return|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
break|break;
case|case
name|OCI_SUCCESS_WITH_INFO
case|:
name|qOraWarning
argument_list|(
literal|"QOCIResult::gotoNext: SuccessWithInfo: "
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|r
operator|=
name|OCI_SUCCESS
expr_stmt|;
comment|//ignore it
break|break;
case|case
name|OCI_NO_DATA
case|:
comment|// end of rowset
return|return
literal|false
return|;
case|case
name|OCI_NEED_DATA
case|:
name|piecewise
operator|=
literal|true
expr_stmt|;
name|r
operator|=
name|OCI_SUCCESS
expr_stmt|;
break|break;
case|case
name|OCI_ERROR
case|:
if|if
condition|(
name|qOraErrorNumber
argument_list|(
name|d
operator|->
name|err
argument_list|)
operator|==
literal|1406
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOCI Warning: data truncated for %s"
argument_list|,
name|lastQuery
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|r
operator|=
name|OCI_SUCCESS
expr_stmt|;
comment|/* ignore it */
break|break;
block|}
comment|// fall through
default|default:
name|qOraWarning
argument_list|(
literal|"QOCIResult::gotoNext: "
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QOCIResult"
argument_list|,
literal|"Unable to goto next"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// need to read piecewise before assigning values
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
operator|&&
name|piecewise
condition|)
name|r
operator|=
name|d
operator|->
name|cols
operator|->
name|readPiecewise
argument_list|(
name|values
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
name|d
operator|->
name|cols
operator|->
name|getValues
argument_list|(
name|values
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
name|r
operator|=
name|d
operator|->
name|cols
operator|->
name|readLOBs
argument_list|(
name|values
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
condition|)
name|setAt
argument_list|(
name|QSql
operator|::
name|AfterLastRow
argument_list|)
expr_stmt|;
return|return
name|r
operator|==
name|OCI_SUCCESS
operator|||
name|r
operator|==
name|OCI_SUCCESS_WITH_INFO
return|;
block|}
end_function
begin_function
DECL|function|size
name|int
name|QOCIResult
operator|::
name|size
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|numRowsAffected
name|int
name|QOCIResult
operator|::
name|numRowsAffected
parameter_list|()
block|{
name|int
name|rowCount
decl_stmt|;
name|OCIAttrGet
argument_list|(
name|d
operator|->
name|sql
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
operator|&
name|rowCount
argument_list|,
name|NULL
argument_list|,
name|OCI_ATTR_ROW_COUNT
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|rowCount
return|;
block|}
end_function
begin_function
DECL|function|prepare
name|bool
name|QOCIResult
operator|::
name|prepare
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|QSqlResult
operator|::
name|prepare
argument_list|(
name|query
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|cols
expr_stmt|;
name|d
operator|->
name|cols
operator|=
literal|0
expr_stmt|;
name|QSqlCachedResult
operator|::
name|cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|sql
condition|)
block|{
name|r
operator|=
name|OCIHandleFree
argument_list|(
name|d
operator|->
name|sql
argument_list|,
name|OCI_HTYPE_STMT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
condition|)
name|qOraWarning
argument_list|(
literal|"QOCIResult::prepare: unable to free statement handle:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|query
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|r
operator|=
name|OCIHandleAlloc
argument_list|(
name|d
operator|->
name|env
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|d
operator|->
name|sql
argument_list|)
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
condition|)
block|{
name|qOraWarning
argument_list|(
literal|"QOCIResult::prepare: unable to alloc statement:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QOCIResult"
argument_list|,
literal|"Unable to alloc statement"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|setStatementAttributes
argument_list|()
expr_stmt|;
specifier|const
name|OraText
modifier|*
name|txt
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|OraText
operator|*
argument_list|>
argument_list|(
name|query
operator|.
name|utf16
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|len
init|=
name|query
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
decl_stmt|;
name|r
operator|=
name|OCIStmtPrepare
argument_list|(
name|d
operator|->
name|sql
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|txt
argument_list|,
name|len
argument_list|,
name|OCI_NTV_SYNTAX
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
condition|)
block|{
name|qOraWarning
argument_list|(
literal|"QOCIResult::prepare: unable to prepare statement:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QOCIResult"
argument_list|,
literal|"Unable to prepare statement"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|exec
name|bool
name|QOCIResult
operator|::
name|exec
parameter_list|()
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|ub2
name|stmtType
init|=
literal|0
decl_stmt|;
name|ub4
name|iters
decl_stmt|;
name|ub4
name|mode
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|tmpStorage
decl_stmt|;
name|IndicatorArray
name|indicators
argument_list|(
name|boundValueCount
argument_list|()
argument_list|)
decl_stmt|;
name|SizeArray
name|tmpSizes
argument_list|(
name|boundValueCount
argument_list|()
argument_list|)
decl_stmt|;
name|r
operator|=
name|OCIAttrGet
argument_list|(
name|d
operator|->
name|sql
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
operator|&
name|stmtType
argument_list|,
name|NULL
argument_list|,
name|OCI_ATTR_STMT_TYPE
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
operator|&&
name|r
operator|!=
name|OCI_SUCCESS_WITH_INFO
condition|)
block|{
name|qOraWarning
argument_list|(
literal|"QOCIResult::exec: Unable to get statement type:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QOCIResult"
argument_list|,
literal|"Unable to get statement type"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QOCI_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"lastQuery()"
operator|<<
name|lastQuery
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
if|if
condition|(
name|stmtType
operator|==
name|OCI_STMT_SELECT
condition|)
block|{
name|iters
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
name|OCI_DEFAULT
expr_stmt|;
block|}
else|else
block|{
name|iters
operator|=
literal|1
expr_stmt|;
name|mode
operator|=
name|d
operator|->
name|transaction
condition|?
name|OCI_DEFAULT
else|:
name|OCI_COMMIT_ON_SUCCESS
expr_stmt|;
block|}
comment|// bind placeholders
if|if
condition|(
name|boundValueCount
argument_list|()
operator|>
literal|0
operator|&&
name|d
operator|->
name|bindValues
argument_list|(
name|boundValues
argument_list|()
argument_list|,
name|indicators
argument_list|,
name|tmpSizes
argument_list|,
name|tmpStorage
argument_list|)
operator|!=
name|OCI_SUCCESS
condition|)
block|{
name|qOraWarning
argument_list|(
literal|"QOCIResult::exec: unable to bind value: "
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QOCIResult"
argument_list|,
literal|"Unable to bind value"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QOCI_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"lastQuery()"
operator|<<
name|lastQuery
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
comment|// execute
name|r
operator|=
name|OCIStmtExecute
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|d
operator|->
name|sql
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|iters
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
operator|&&
name|r
operator|!=
name|OCI_SUCCESS_WITH_INFO
condition|)
block|{
name|qOraWarning
argument_list|(
literal|"QOCIResult::exec: unable to execute statement:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QOCIResult"
argument_list|,
literal|"Unable to execute statement"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|StatementError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QOCI_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"lastQuery()"
operator|<<
name|lastQuery
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
if|if
condition|(
name|stmtType
operator|==
name|OCI_STMT_SELECT
condition|)
block|{
name|ub4
name|parmCount
init|=
literal|0
decl_stmt|;
name|int
name|r
init|=
name|OCIAttrGet
argument_list|(
name|d
operator|->
name|sql
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|parmCount
argument_list|)
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_PARAM_COUNT
argument_list|,
name|d
operator|->
name|err
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
operator|!
name|d
operator|->
name|cols
condition|)
name|d
operator|->
name|cols
operator|=
operator|new
name|QOCICols
argument_list|(
name|parmCount
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|setSelect
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QSqlCachedResult
operator|::
name|init
argument_list|(
name|parmCount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* non-SELECT */
name|setSelect
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|setAt
argument_list|(
name|QSql
operator|::
name|BeforeFirstRow
argument_list|)
expr_stmt|;
name|setActive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasOutValues
argument_list|()
condition|)
name|d
operator|->
name|outValues
argument_list|(
name|boundValues
argument_list|()
argument_list|,
name|indicators
argument_list|,
name|tmpStorage
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|record
name|QSqlRecord
name|QOCIResult
operator|::
name|record
parameter_list|()
specifier|const
block|{
name|QSqlRecord
name|inf
decl_stmt|;
if|if
condition|(
operator|!
name|isActive
argument_list|()
operator|||
operator|!
name|isSelect
argument_list|()
operator|||
operator|!
name|d
operator|->
name|cols
condition|)
return|return
name|inf
return|;
return|return
name|d
operator|->
name|cols
operator|->
name|rec
return|;
block|}
end_function
begin_function
DECL|function|lastInsertId
name|QVariant
name|QOCIResult
operator|::
name|lastInsertId
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isActive
argument_list|()
condition|)
block|{
name|QOCIRowIdPointer
name|ptr
argument_list|(
operator|new
name|QOCIRowId
argument_list|(
name|d
operator|->
name|env
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|OCIAttrGet
argument_list|(
name|d
operator|->
name|sql
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
name|ptr
operator|.
name|constData
argument_list|()
operator|->
name|id
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_ROWID
argument_list|,
name|d
operator|->
name|err
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
return|return
name|QVariant
operator|::
name|fromValue
argument_list|(
name|ptr
argument_list|)
return|;
block|}
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|virtual_hook
name|void
name|QOCIResult
operator|::
name|virtual_hook
parameter_list|(
name|int
name|id
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|QSqlResult
operator|::
name|BatchOperation
case|:
name|QOCICols
operator|::
name|execBatch
argument_list|(
name|d
argument_list|,
name|boundValues
argument_list|()
argument_list|,
operator|*
cast|reinterpret_cast
argument_list|<
name|bool
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|QSqlCachedResult
operator|::
name|virtual_hook
argument_list|(
name|id
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|////////////////////////////////////////////////////////////////////////////
end_comment
begin_constructor
DECL|function|QOCIDriver
name|QOCIDriver
operator|::
name|QOCIDriver
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QSqlDriver
argument_list|(
name|parent
argument_list|)
block|{
name|d
operator|=
operator|new
name|QOCIDriverPrivate
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QOCI_THREADED
specifier|const
name|ub4
name|mode
init|=
name|OCI_UTF16
operator||
name|OCI_OBJECT
operator||
name|OCI_THREADED
decl_stmt|;
else|#
directive|else
specifier|const
name|ub4
name|mode
init|=
name|OCI_UTF16
operator||
name|OCI_OBJECT
decl_stmt|;
endif|#
directive|endif
name|int
name|r
init|=
name|OCIEnvCreate
argument_list|(
operator|&
name|d
operator|->
name|env
argument_list|,
name|mode
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOCIDriver: unable to create environment"
argument_list|)
expr_stmt|;
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|tr
argument_list|(
literal|"Unable to initialize"
argument_list|,
literal|"QOCIDriver"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|ConnectionError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|allocErrorHandle
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QOCIDriver
name|QOCIDriver
operator|::
name|QOCIDriver
parameter_list|(
name|OCIEnv
modifier|*
name|env
parameter_list|,
name|OCISvcCtx
modifier|*
name|ctx
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QSqlDriver
argument_list|(
name|parent
argument_list|)
block|{
name|d
operator|=
operator|new
name|QOCIDriverPrivate
argument_list|()
expr_stmt|;
name|d
operator|->
name|env
operator|=
name|env
expr_stmt|;
name|d
operator|->
name|svc
operator|=
name|ctx
expr_stmt|;
name|d
operator|->
name|allocErrorHandle
argument_list|()
expr_stmt|;
if|if
condition|(
name|env
operator|&&
name|ctx
condition|)
block|{
name|setOpen
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setOpenError
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_destructor
DECL|function|~QOCIDriver
name|QOCIDriver
operator|::
name|~
name|QOCIDriver
parameter_list|()
block|{
if|if
condition|(
name|isOpen
argument_list|()
condition|)
name|close
argument_list|()
expr_stmt|;
name|int
name|r
init|=
name|OCIHandleFree
argument_list|(
name|d
operator|->
name|err
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
condition|)
name|qWarning
argument_list|(
literal|"Unable to free Error handle: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|OCIHandleFree
argument_list|(
name|d
operator|->
name|env
argument_list|,
name|OCI_HTYPE_ENV
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
condition|)
name|qWarning
argument_list|(
literal|"Unable to free Environment handle: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|hasFeature
name|bool
name|QOCIDriver
operator|::
name|hasFeature
parameter_list|(
name|DriverFeature
name|f
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|Transactions
case|:
case|case
name|LastInsertId
case|:
case|case
name|BLOB
case|:
case|case
name|PreparedQueries
case|:
case|case
name|NamedPlaceholders
case|:
case|case
name|BatchOperations
case|:
case|case
name|LowPrecisionNumbers
case|:
return|return
literal|true
return|;
case|case
name|QuerySize
case|:
case|case
name|PositionalPlaceholders
case|:
case|case
name|SimpleLocking
case|:
case|case
name|EventNotifications
case|:
case|case
name|FinishQuery
case|:
case|case
name|MultipleResultSets
case|:
return|return
literal|false
return|;
case|case
name|Unicode
case|:
return|return
name|d
operator|->
name|serverVersion
operator|>=
literal|9
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|qParseOpts
specifier|static
name|void
name|qParseOpts
parameter_list|(
specifier|const
name|QString
modifier|&
name|options
parameter_list|,
name|QOCIDriverPrivate
modifier|*
name|d
parameter_list|)
block|{
specifier|const
name|QStringList
name|opts
argument_list|(
name|options
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|opts
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
name|tmp
argument_list|(
name|opts
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
operator|(
name|idx
operator|=
name|tmp
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOCIDriver::parseArgs: Invalid parameter: '%s'"
argument_list|,
name|tmp
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
specifier|const
name|QString
name|opt
init|=
name|tmp
operator|.
name|left
argument_list|(
name|idx
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|val
init|=
name|tmp
operator|.
name|mid
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
operator|.
name|simplified
argument_list|()
decl_stmt|;
name|bool
name|ok
decl_stmt|;
if|if
condition|(
name|opt
operator|==
name|QLatin1String
argument_list|(
literal|"OCI_ATTR_PREFETCH_ROWS"
argument_list|)
condition|)
block|{
name|d
operator|->
name|prefetchRows
operator|=
name|val
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|d
operator|->
name|prefetchRows
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|==
name|QLatin1String
argument_list|(
literal|"OCI_ATTR_PREFETCH_MEMORY"
argument_list|)
condition|)
block|{
name|d
operator|->
name|prefetchMem
operator|=
name|val
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|d
operator|->
name|prefetchMem
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QOCIDriver::parseArgs: Invalid parameter: '%s'"
argument_list|,
name|opt
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|open
name|bool
name|QOCIDriver
operator|::
name|open
parameter_list|(
specifier|const
name|QString
modifier|&
name|db
parameter_list|,
specifier|const
name|QString
modifier|&
name|user
parameter_list|,
specifier|const
name|QString
modifier|&
name|password
parameter_list|,
specifier|const
name|QString
modifier|&
name|hostname
parameter_list|,
name|int
name|port
parameter_list|,
specifier|const
name|QString
modifier|&
name|opts
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|isOpen
argument_list|()
condition|)
name|close
argument_list|()
expr_stmt|;
name|qParseOpts
argument_list|(
name|opts
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|// Connect without tnsnames.ora if a hostname is given
name|QString
name|connectionString
init|=
name|db
decl_stmt|;
if|if
condition|(
operator|!
name|hostname
operator|.
name|isEmpty
argument_list|()
condition|)
name|connectionString
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(Host=%1)(Port=%2))"
literal|"(CONNECT_DATA=(SID=%3)))"
argument_list|)
operator|.
name|arg
argument_list|(
name|hostname
argument_list|)
operator|.
name|arg
argument_list|(
operator|(
name|port
operator|>
operator|-
literal|1
condition|?
name|port
else|:
literal|1521
operator|)
argument_list|)
operator|.
name|arg
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|r
operator|=
name|OCIHandleAlloc
argument_list|(
name|d
operator|->
name|env
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|d
operator|->
name|srvhp
argument_list|)
argument_list|,
name|OCI_HTYPE_SERVER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
name|r
operator|=
name|OCIServerAttach
argument_list|(
name|d
operator|->
name|srvhp
argument_list|,
name|d
operator|->
name|err
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|OraText
operator|*
argument_list|>
argument_list|(
name|connectionString
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|,
name|connectionString
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
operator|||
name|r
operator|==
name|OCI_SUCCESS_WITH_INFO
condition|)
name|r
operator|=
name|OCIHandleAlloc
argument_list|(
name|d
operator|->
name|env
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|d
operator|->
name|svc
argument_list|)
argument_list|,
name|OCI_HTYPE_SVCCTX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
name|r
operator|=
name|OCIAttrSet
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|OCI_HTYPE_SVCCTX
argument_list|,
name|d
operator|->
name|srvhp
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_SERVER
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
name|r
operator|=
name|OCIHandleAlloc
argument_list|(
name|d
operator|->
name|env
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|d
operator|->
name|authp
argument_list|)
argument_list|,
name|OCI_HTYPE_SESSION
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
name|r
operator|=
name|OCIAttrSet
argument_list|(
name|d
operator|->
name|authp
argument_list|,
name|OCI_HTYPE_SESSION
argument_list|,
cast|const_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|user
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|,
name|user
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|,
name|OCI_ATTR_USERNAME
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
name|r
operator|=
name|OCIAttrSet
argument_list|(
name|d
operator|->
name|authp
argument_list|,
name|OCI_HTYPE_SESSION
argument_list|,
cast|const_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|password
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|,
name|password
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|,
name|OCI_ATTR_PASSWORD
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|OCITrans
modifier|*
name|trans
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
name|r
operator|=
name|OCIHandleAlloc
argument_list|(
name|d
operator|->
name|env
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|trans
argument_list|)
argument_list|,
name|OCI_HTYPE_TRANS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
name|r
operator|=
name|OCIAttrSet
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|OCI_HTYPE_SVCCTX
argument_list|,
name|trans
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_TRANS
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
condition|)
block|{
if|if
condition|(
name|user
operator|.
name|isEmpty
argument_list|()
operator|&&
name|password
operator|.
name|isEmpty
argument_list|()
condition|)
name|r
operator|=
name|OCISessionBegin
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|d
operator|->
name|authp
argument_list|,
name|OCI_CRED_EXT
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|OCISessionBegin
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|d
operator|->
name|authp
argument_list|,
name|OCI_CRED_RDBMS
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|OCI_SUCCESS
operator|||
name|r
operator|==
name|OCI_SUCCESS_WITH_INFO
condition|)
name|r
operator|=
name|OCIAttrSet
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|OCI_HTYPE_SVCCTX
argument_list|,
name|d
operator|->
name|authp
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_SESSION
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|OCI_SUCCESS
condition|)
block|{
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|tr
argument_list|(
literal|"Unable to logon"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|ConnectionError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|setOpenError
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|authp
condition|)
name|OCIHandleFree
argument_list|(
name|d
operator|->
name|authp
argument_list|,
name|OCI_HTYPE_SESSION
argument_list|)
expr_stmt|;
name|d
operator|->
name|authp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|srvhp
condition|)
name|OCIHandleFree
argument_list|(
name|d
operator|->
name|srvhp
argument_list|,
name|OCI_HTYPE_SERVER
argument_list|)
expr_stmt|;
name|d
operator|->
name|srvhp
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// get server version
name|char
name|vertxt
index|[
literal|512
index|]
decl_stmt|;
name|r
operator|=
name|OCIServerVersion
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|d
operator|->
name|err
argument_list|,
cast|reinterpret_cast
argument_list|<
name|OraText
operator|*
argument_list|>
argument_list|(
name|vertxt
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vertxt
argument_list|)
argument_list|,
name|OCI_HTYPE_SVCCTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOCIDriver::open: could not get Oracle server version."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|versionStr
decl_stmt|;
name|versionStr
operator|=
name|QString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|vertxt
argument_list|)
argument_list|)
expr_stmt|;
name|QRegExp
name|vers
argument_list|(
name|QLatin1String
argument_list|(
literal|"([0-9]+)\\.[0-9\\.]+[0-9]"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|vers
operator|.
name|indexIn
argument_list|(
name|versionStr
argument_list|)
operator|>=
literal|0
condition|)
name|d
operator|->
name|serverVersion
operator|=
name|vers
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|serverVersion
operator|==
literal|0
condition|)
name|d
operator|->
name|serverVersion
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|setOpen
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setOpenError
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|user
operator|=
name|user
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|close
name|void
name|QOCIDriver
operator|::
name|close
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isOpen
argument_list|()
condition|)
return|return;
name|OCISessionEnd
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|d
operator|->
name|authp
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
name|OCIServerDetach
argument_list|(
name|d
operator|->
name|srvhp
argument_list|,
name|d
operator|->
name|err
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
name|OCIHandleFree
argument_list|(
name|d
operator|->
name|authp
argument_list|,
name|OCI_HTYPE_SESSION
argument_list|)
expr_stmt|;
name|d
operator|->
name|authp
operator|=
literal|0
expr_stmt|;
name|OCIHandleFree
argument_list|(
name|d
operator|->
name|srvhp
argument_list|,
name|OCI_HTYPE_SERVER
argument_list|)
expr_stmt|;
name|d
operator|->
name|srvhp
operator|=
literal|0
expr_stmt|;
name|OCIHandleFree
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|OCI_HTYPE_SVCCTX
argument_list|)
expr_stmt|;
name|d
operator|->
name|svc
operator|=
literal|0
expr_stmt|;
name|setOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|setOpenError
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|createResult
name|QSqlResult
modifier|*
name|QOCIDriver
operator|::
name|createResult
parameter_list|()
specifier|const
block|{
return|return
operator|new
name|QOCIResult
argument_list|(
name|this
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|beginTransaction
name|bool
name|QOCIDriver
operator|::
name|beginTransaction
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOCIDriver::beginTransaction: Database not open"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|r
init|=
name|OCITransStart
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|d
operator|->
name|err
argument_list|,
literal|2
argument_list|,
name|OCI_TRANS_READWRITE
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_ERROR
condition|)
block|{
name|qOraWarning
argument_list|(
literal|"QOCIDriver::beginTransaction: "
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QOCIDriver"
argument_list|,
literal|"Unable to begin transaction"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|TransactionError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|transaction
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|commitTransaction
name|bool
name|QOCIDriver
operator|::
name|commitTransaction
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOCIDriver::commitTransaction: Database not open"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|r
init|=
name|OCITransCommit
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|d
operator|->
name|err
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_ERROR
condition|)
block|{
name|qOraWarning
argument_list|(
literal|"QOCIDriver::commitTransaction:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QOCIDriver"
argument_list|,
literal|"Unable to commit transaction"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|TransactionError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|transaction
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|rollbackTransaction
name|bool
name|QOCIDriver
operator|::
name|rollbackTransaction
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOCIDriver::rollbackTransaction: Database not open"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|r
init|=
name|OCITransRollback
argument_list|(
name|d
operator|->
name|svc
argument_list|,
name|d
operator|->
name|err
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|OCI_ERROR
condition|)
block|{
name|qOraWarning
argument_list|(
literal|"QOCIDriver::rollbackTransaction:"
argument_list|,
name|d
operator|->
name|err
argument_list|)
expr_stmt|;
name|setLastError
argument_list|(
name|qMakeError
argument_list|(
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QOCIDriver"
argument_list|,
literal|"Unable to rollback transaction"
argument_list|)
argument_list|,
name|QSqlError
operator|::
name|TransactionError
argument_list|,
name|d
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|transaction
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|tables
name|QStringList
name|QOCIDriver
operator|::
name|tables
parameter_list|(
name|QSql
operator|::
name|TableType
name|type
parameter_list|)
specifier|const
block|{
name|QStringList
name|tl
decl_stmt|;
name|QStringList
name|sysUsers
init|=
name|QStringList
argument_list|()
operator|<<
name|QLatin1String
argument_list|(
literal|"MDSYS"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"LBACSYS"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"SYS"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"SYSTEM"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"WKSYS"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"CTXSYS"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"WMSYS"
argument_list|)
decl_stmt|;
name|QString
name|user
init|=
name|d
operator|->
name|user
decl_stmt|;
if|if
condition|(
name|isIdentifierEscaped
argument_list|(
name|user
argument_list|,
name|QSqlDriver
operator|::
name|TableName
argument_list|)
condition|)
name|user
operator|=
name|stripDelimiters
argument_list|(
name|user
argument_list|,
name|QSqlDriver
operator|::
name|TableName
argument_list|)
expr_stmt|;
else|else
name|user
operator|=
name|user
operator|.
name|toUpper
argument_list|()
expr_stmt|;
if|if
condition|(
name|sysUsers
operator|.
name|contains
argument_list|(
name|user
argument_list|)
condition|)
name|sysUsers
operator|.
name|removeAll
argument_list|(
name|user
argument_list|)
expr_stmt|;
empty_stmt|;
if|if
condition|(
operator|!
name|isOpen
argument_list|()
condition|)
return|return
name|tl
return|;
name|QSqlQuery
name|t
argument_list|(
name|createResult
argument_list|()
argument_list|)
decl_stmt|;
name|t
operator|.
name|setForwardOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|QSql
operator|::
name|Tables
condition|)
block|{
name|QString
name|query
init|=
name|QLatin1String
argument_list|(
literal|"select owner, table_name from all_tables where "
argument_list|)
decl_stmt|;
name|QStringList
name|whereList
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|sysUserName
decl|,
name|sysUsers
control|)
name|whereList
operator|<<
name|QLatin1String
argument_list|(
literal|"owner != '"
argument_list|)
operator|+
name|sysUserName
operator|+
name|QLatin1String
argument_list|(
literal|"' "
argument_list|)
expr_stmt|;
name|t
operator|.
name|exec
argument_list|(
name|query
operator|+
name|whereList
operator|.
name|join
argument_list|(
name|QLatin1String
argument_list|(
literal|" and "
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|next
argument_list|()
condition|)
block|{
if|if
condition|(
name|t
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|toUpper
argument_list|()
operator|!=
name|user
operator|.
name|toUpper
argument_list|()
condition|)
name|tl
operator|.
name|append
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|t
operator|.
name|value
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|tl
operator|.
name|append
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// list all table synonyms as well
name|query
operator|=
name|QLatin1String
argument_list|(
literal|"select owner, synonym_name from all_synonyms where "
argument_list|)
expr_stmt|;
name|t
operator|.
name|exec
argument_list|(
name|query
operator|+
name|whereList
operator|.
name|join
argument_list|(
name|QLatin1String
argument_list|(
literal|" and "
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|next
argument_list|()
condition|)
block|{
if|if
condition|(
name|t
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
operator|!=
name|d
operator|->
name|user
condition|)
name|tl
operator|.
name|append
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|t
operator|.
name|value
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|tl
operator|.
name|append
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|&
name|QSql
operator|::
name|Views
condition|)
block|{
name|QString
name|query
init|=
name|QLatin1String
argument_list|(
literal|"select owner, view_name from all_views where "
argument_list|)
decl_stmt|;
name|QStringList
name|whereList
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|sysUserName
decl|,
name|sysUsers
control|)
name|whereList
operator|<<
name|QLatin1String
argument_list|(
literal|"owner != '"
argument_list|)
operator|+
name|sysUserName
operator|+
name|QLatin1String
argument_list|(
literal|"' "
argument_list|)
expr_stmt|;
name|t
operator|.
name|exec
argument_list|(
name|query
operator|+
name|whereList
operator|.
name|join
argument_list|(
name|QLatin1String
argument_list|(
literal|" and "
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|next
argument_list|()
condition|)
block|{
if|if
condition|(
name|t
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|toUpper
argument_list|()
operator|!=
name|d
operator|->
name|user
operator|.
name|toUpper
argument_list|()
condition|)
name|tl
operator|.
name|append
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|t
operator|.
name|value
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|tl
operator|.
name|append
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|&
name|QSql
operator|::
name|SystemTables
condition|)
block|{
name|t
operator|.
name|exec
argument_list|(
name|QLatin1String
argument_list|(
literal|"select table_name from dictionary"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|next
argument_list|()
condition|)
block|{
name|tl
operator|.
name|append
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QString
name|query
init|=
name|QLatin1String
argument_list|(
literal|"select owner, table_name from all_tables where "
argument_list|)
decl_stmt|;
name|QStringList
name|whereList
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|sysUserName
decl|,
name|sysUsers
control|)
name|whereList
operator|<<
name|QLatin1String
argument_list|(
literal|"owner = '"
argument_list|)
operator|+
name|sysUserName
operator|+
name|QLatin1String
argument_list|(
literal|"' "
argument_list|)
expr_stmt|;
name|t
operator|.
name|exec
argument_list|(
name|query
operator|+
name|whereList
operator|.
name|join
argument_list|(
name|QLatin1String
argument_list|(
literal|" or "
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|next
argument_list|()
condition|)
block|{
if|if
condition|(
name|t
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|toUpper
argument_list|()
operator|!=
name|user
operator|.
name|toUpper
argument_list|()
condition|)
name|tl
operator|.
name|append
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|t
operator|.
name|value
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|tl
operator|.
name|append
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// list all table synonyms as well
name|query
operator|=
name|QLatin1String
argument_list|(
literal|"select owner, synonym_name from all_synonyms where "
argument_list|)
expr_stmt|;
name|t
operator|.
name|exec
argument_list|(
name|query
operator|+
name|whereList
operator|.
name|join
argument_list|(
name|QLatin1String
argument_list|(
literal|" or "
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|next
argument_list|()
condition|)
block|{
if|if
condition|(
name|t
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
operator|!=
name|d
operator|->
name|user
condition|)
name|tl
operator|.
name|append
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|"."
argument_list|)
operator|+
name|t
operator|.
name|value
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|tl
operator|.
name|append
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tl
return|;
block|}
end_function
begin_function
DECL|function|qSplitTableAndOwner
name|void
name|qSplitTableAndOwner
parameter_list|(
specifier|const
name|QString
modifier|&
name|tname
parameter_list|,
name|QString
modifier|*
name|tbl
parameter_list|,
name|QString
modifier|*
name|owner
parameter_list|)
block|{
name|int
name|i
init|=
name|tname
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
comment|// prefixed with owner?
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|tbl
operator|=
name|tname
operator|.
name|right
argument_list|(
name|tname
operator|.
name|length
argument_list|()
operator|-
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|owner
operator|=
name|tname
operator|.
name|left
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tbl
operator|=
name|tname
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|record
name|QSqlRecord
name|QOCIDriver
operator|::
name|record
parameter_list|(
specifier|const
name|QString
modifier|&
name|tablename
parameter_list|)
specifier|const
block|{
name|QSqlRecord
name|fil
decl_stmt|;
if|if
condition|(
operator|!
name|isOpen
argument_list|()
condition|)
return|return
name|fil
return|;
name|QSqlQuery
name|t
argument_list|(
name|createResult
argument_list|()
argument_list|)
decl_stmt|;
comment|// using two separate queries for this is A LOT faster than using
comment|// eg. a sub-query on the sys.synonyms table
name|QString
name|stmt
argument_list|(
name|QLatin1String
argument_list|(
literal|"select column_name, data_type, data_length, "
literal|"data_precision, data_scale, nullable, data_default%1"
literal|"from all_tab_columns a "
literal|"where a.table_name=%2"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|serverVersion
operator|>=
literal|9
condition|)
name|stmt
operator|=
name|stmt
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
literal|", char_length "
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|stmt
operator|=
name|stmt
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|buildRecordInfo
init|=
literal|false
decl_stmt|;
name|QString
name|table
decl_stmt|,
name|owner
decl_stmt|,
name|tmpStmt
decl_stmt|;
name|qSplitTableAndOwner
argument_list|(
name|tablename
argument_list|,
operator|&
name|table
argument_list|,
operator|&
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIdentifierEscaped
argument_list|(
name|table
argument_list|,
name|QSqlDriver
operator|::
name|TableName
argument_list|)
condition|)
name|table
operator|=
name|stripDelimiters
argument_list|(
name|table
argument_list|,
name|QSqlDriver
operator|::
name|TableName
argument_list|)
expr_stmt|;
else|else
name|table
operator|=
name|table
operator|.
name|toUpper
argument_list|()
expr_stmt|;
name|tmpStmt
operator|=
name|stmt
operator|.
name|arg
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
operator|+
name|table
operator|+
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|owner
operator|=
name|d
operator|->
name|user
expr_stmt|;
block|}
if|if
condition|(
name|isIdentifierEscaped
argument_list|(
name|owner
argument_list|,
name|QSqlDriver
operator|::
name|TableName
argument_list|)
condition|)
name|owner
operator|=
name|stripDelimiters
argument_list|(
name|owner
argument_list|,
name|QSqlDriver
operator|::
name|TableName
argument_list|)
expr_stmt|;
else|else
name|owner
operator|=
name|owner
operator|.
name|toUpper
argument_list|()
expr_stmt|;
name|tmpStmt
operator|+=
name|QLatin1String
argument_list|(
literal|" and a.owner='"
argument_list|)
operator|+
name|owner
operator|+
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|t
operator|.
name|setForwardOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|exec
argument_list|(
name|tmpStmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|next
argument_list|()
condition|)
block|{
comment|// try and see if the tablename is a synonym
name|stmt
operator|=
name|stmt
operator|+
name|QLatin1String
argument_list|(
literal|" join all_synonyms b "
literal|"on a.owner=b.table_owner and a.table_name=b.table_name "
literal|"where b.owner='"
argument_list|)
operator|+
name|owner
operator|+
name|QLatin1String
argument_list|(
literal|"' and b.synonym_name='"
argument_list|)
operator|+
name|table
operator|+
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|t
operator|.
name|setForwardOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|exec
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|next
argument_list|()
condition|)
name|buildRecordInfo
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|buildRecordInfo
operator|=
literal|true
expr_stmt|;
block|}
name|QStringList
name|keywords
init|=
name|QStringList
argument_list|()
operator|<<
name|QLatin1String
argument_list|(
literal|"NUMBER"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"FLOAT"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"BINARY_FLOAT"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"BINARY_DOUBLE"
argument_list|)
decl_stmt|;
if|if
condition|(
name|buildRecordInfo
condition|)
block|{
do|do
block|{
name|QVariant
operator|::
name|Type
name|ty
init|=
name|qDecodeOCIType
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|t
operator|.
name|numericalPrecisionPolicy
argument_list|()
argument_list|)
decl_stmt|;
name|QSqlField
name|f
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|ty
argument_list|)
decl_stmt|;
name|f
operator|.
name|setRequired
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|5
argument_list|)
operator|.
name|toString
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"N"
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|.
name|setPrecision
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|4
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|serverVersion
operator|>=
literal|9
operator|&&
operator|(
name|ty
operator|==
name|QVariant
operator|::
name|String
operator|)
operator|&&
operator|!
name|t
operator|.
name|isNull
argument_list|(
literal|3
argument_list|)
operator|&&
operator|!
name|keywords
operator|.
name|contains
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
comment|// Oracle9: data_length == size in bytes, char_length == amount of characters
name|f
operator|.
name|setLength
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|7
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|.
name|setLength
argument_list|(
name|t
operator|.
name|value
argument_list|(
name|t
operator|.
name|isNull
argument_list|(
literal|3
argument_list|)
condition|?
literal|2
else|:
literal|3
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|f
operator|.
name|setDefaultValue
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|fil
operator|.
name|append
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|.
name|next
argument_list|()
condition|)
do|;
block|}
return|return
name|fil
return|;
block|}
end_function
begin_function
DECL|function|primaryIndex
name|QSqlIndex
name|QOCIDriver
operator|::
name|primaryIndex
parameter_list|(
specifier|const
name|QString
modifier|&
name|tablename
parameter_list|)
specifier|const
block|{
name|QSqlIndex
name|idx
argument_list|(
name|tablename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isOpen
argument_list|()
condition|)
return|return
name|idx
return|;
name|QSqlQuery
name|t
argument_list|(
name|createResult
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|stmt
argument_list|(
name|QLatin1String
argument_list|(
literal|"select b.column_name, b.index_name, a.table_name, a.owner "
literal|"from all_constraints a, all_ind_columns b "
literal|"where a.constraint_type='P' "
literal|"and b.index_name = a.constraint_name "
literal|"and b.index_owner = a.owner"
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|buildIndex
init|=
literal|false
decl_stmt|;
name|QString
name|table
decl_stmt|,
name|owner
decl_stmt|,
name|tmpStmt
decl_stmt|;
name|qSplitTableAndOwner
argument_list|(
name|tablename
argument_list|,
operator|&
name|table
argument_list|,
operator|&
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIdentifierEscaped
argument_list|(
name|table
argument_list|,
name|QSqlDriver
operator|::
name|TableName
argument_list|)
condition|)
name|table
operator|=
name|stripDelimiters
argument_list|(
name|table
argument_list|,
name|QSqlDriver
operator|::
name|TableName
argument_list|)
expr_stmt|;
else|else
name|table
operator|=
name|table
operator|.
name|toUpper
argument_list|()
expr_stmt|;
name|tmpStmt
operator|=
name|stmt
operator|+
name|QLatin1String
argument_list|(
literal|" and a.table_name='"
argument_list|)
operator|+
name|table
operator|+
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|owner
operator|=
name|d
operator|->
name|user
expr_stmt|;
block|}
if|if
condition|(
name|isIdentifierEscaped
argument_list|(
name|owner
argument_list|,
name|QSqlDriver
operator|::
name|TableName
argument_list|)
condition|)
name|owner
operator|=
name|stripDelimiters
argument_list|(
name|owner
argument_list|,
name|QSqlDriver
operator|::
name|TableName
argument_list|)
expr_stmt|;
else|else
name|owner
operator|=
name|owner
operator|.
name|toUpper
argument_list|()
expr_stmt|;
name|tmpStmt
operator|+=
name|QLatin1String
argument_list|(
literal|" and a.owner='"
argument_list|)
operator|+
name|owner
operator|+
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|t
operator|.
name|setForwardOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|exec
argument_list|(
name|tmpStmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|next
argument_list|()
condition|)
block|{
name|stmt
operator|+=
name|QLatin1String
argument_list|(
literal|" and a.table_name=(select tname from sys.synonyms "
literal|"where sname='"
argument_list|)
operator|+
name|table
operator|+
name|QLatin1String
argument_list|(
literal|"' and creator=a.owner)"
argument_list|)
expr_stmt|;
name|t
operator|.
name|setForwardOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|exec
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|next
argument_list|()
condition|)
block|{
name|owner
operator|=
name|t
operator|.
name|value
argument_list|(
literal|3
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
name|buildIndex
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|buildIndex
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|buildIndex
condition|)
block|{
name|QSqlQuery
name|tt
argument_list|(
name|createResult
argument_list|()
argument_list|)
decl_stmt|;
name|tt
operator|.
name|setForwardOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|idx
operator|.
name|setName
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
do|do
block|{
name|tt
operator|.
name|exec
argument_list|(
name|QLatin1String
argument_list|(
literal|"select data_type from all_tab_columns where table_name='"
argument_list|)
operator|+
name|t
operator|.
name|value
argument_list|(
literal|2
argument_list|)
operator|.
name|toString
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|"' and column_name='"
argument_list|)
operator|+
name|t
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|"' and owner='"
argument_list|)
operator|+
name|owner
operator|+
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tt
operator|.
name|next
argument_list|()
condition|)
block|{
return|return
name|QSqlIndex
argument_list|()
return|;
block|}
name|QSqlField
name|f
argument_list|(
name|t
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|qDecodeOCIType
argument_list|(
name|tt
operator|.
name|value
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|t
operator|.
name|numericalPrecisionPolicy
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|idx
operator|.
name|append
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|.
name|next
argument_list|()
condition|)
do|;
return|return
name|idx
return|;
block|}
return|return
name|QSqlIndex
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|formatValue
name|QString
name|QOCIDriver
operator|::
name|formatValue
parameter_list|(
specifier|const
name|QSqlField
modifier|&
name|field
parameter_list|,
name|bool
name|trimStrings
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|field
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|QVariant
operator|::
name|DateTime
case|:
block|{
name|QDateTime
name|datetime
init|=
name|field
operator|.
name|value
argument_list|()
operator|.
name|toDateTime
argument_list|()
decl_stmt|;
name|QString
name|datestring
decl_stmt|;
if|if
condition|(
name|datetime
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|datestring
operator|=
name|QLatin1String
argument_list|(
literal|"TO_DATE('"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|datetime
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|datetime
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|datetime
operator|.
name|date
argument_list|()
operator|.
name|day
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|datetime
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|datetime
operator|.
name|time
argument_list|()
operator|.
name|minute
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|datetime
operator|.
name|time
argument_list|()
operator|.
name|second
argument_list|()
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"','YYYY-MM-DD HH24:MI:SS')"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|datestring
operator|=
name|QLatin1String
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
block|}
return|return
name|datestring
return|;
block|}
case|case
name|QVariant
operator|::
name|Time
case|:
block|{
name|QDateTime
name|datetime
init|=
name|field
operator|.
name|value
argument_list|()
operator|.
name|toDateTime
argument_list|()
decl_stmt|;
name|QString
name|datestring
decl_stmt|;
if|if
condition|(
name|datetime
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|datestring
operator|=
name|QLatin1String
argument_list|(
literal|"TO_DATE('"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|datetime
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|datetime
operator|.
name|time
argument_list|()
operator|.
name|minute
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|datetime
operator|.
name|time
argument_list|()
operator|.
name|second
argument_list|()
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"','HH24:MI:SS')"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|datestring
operator|=
name|QLatin1String
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
block|}
return|return
name|datestring
return|;
block|}
case|case
name|QVariant
operator|::
name|Date
case|:
block|{
name|QDate
name|date
init|=
name|field
operator|.
name|value
argument_list|()
operator|.
name|toDate
argument_list|()
decl_stmt|;
name|QString
name|datestring
decl_stmt|;
if|if
condition|(
name|date
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|datestring
operator|=
name|QLatin1String
argument_list|(
literal|"TO_DATE('"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|date
operator|.
name|year
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|date
operator|.
name|month
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|date
operator|.
name|day
argument_list|()
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"','YYYY-MM-DD')"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|datestring
operator|=
name|QLatin1String
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
block|}
return|return
name|datestring
return|;
block|}
default|default:
break|break;
block|}
return|return
name|QSqlDriver
operator|::
name|formatValue
argument_list|(
name|field
argument_list|,
name|trimStrings
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|handle
name|QVariant
name|QOCIDriver
operator|::
name|handle
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
operator|::
name|fromValue
argument_list|(
name|d
operator|->
name|env
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|escapeIdentifier
name|QString
name|QOCIDriver
operator|::
name|escapeIdentifier
parameter_list|(
specifier|const
name|QString
modifier|&
name|identifier
parameter_list|,
name|IdentifierType
name|type
parameter_list|)
specifier|const
block|{
name|QString
name|res
init|=
name|identifier
decl_stmt|;
if|if
condition|(
operator|!
name|identifier
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|isIdentifierEscaped
argument_list|(
name|identifier
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|res
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"\"\""
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"\".\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
