begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtXml module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qplatformdefs.h>
end_include
begin_include
include|#
directive|include
file|<qdom.h>
end_include
begin_include
include|#
directive|include
file|"private/qxmlutils_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DOM
end_ifndef
begin_include
include|#
directive|include
file|<qatomic.h>
end_include
begin_include
include|#
directive|include
file|<qbuffer.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<qiodevice.h>
end_include
begin_include
include|#
directive|include
file|<qlist.h>
end_include
begin_include
include|#
directive|include
file|<qregexp.h>
end_include
begin_include
include|#
directive|include
file|<qtextcodec.h>
end_include
begin_include
include|#
directive|include
file|<qtextstream.h>
end_include
begin_include
include|#
directive|include
file|<qxml.h>
end_include
begin_include
include|#
directive|include
file|<qvariant.h>
end_include
begin_include
include|#
directive|include
file|<qmap.h>
end_include
begin_include
include|#
directive|include
file|<qshareddata.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*   ### old todo comments -- I don't know if they still apply...    If the document dies, remove all pointers to it from children   which can not be deleted at this time.    If a node dies and has direct children which can not be deleted,   then remove the pointer to the parent.    createElement and friends create double reference counts. */
comment|/* ##### new TODOs:    Remove emtpy emthods in the *Private classes    Make a lot of the (mostly empty) methods in the public classes inline.   Specially constructors assignment operators and comparison operators are candidates.    The virtual isXxx functions in *Private can probably be replaced by inline methods checking the nodeType(). */
comment|/*   Reference counting:    Some simple rules:   1) If an intern object returns a pointer to another intern object      then the reference count of the returned object is not increased.   2) If an extern object is created and gets a pointer to some intern      object, then the extern object increases the intern objects reference count.   3) If an extern object is deleted, then it decreases the reference count      on its associated intern object and deletes it if nobody else hold references      on the intern object. */
comment|/*   Helper to split a qualified name in the prefix and local name. */
DECL|function|qt_split_namespace
specifier|static
name|void
name|qt_split_namespace
parameter_list|(
name|QString
modifier|&
name|prefix
parameter_list|,
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|,
name|bool
name|hasURI
parameter_list|)
block|{
name|int
name|i
init|=
name|qName
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|hasURI
condition|)
name|prefix
operator|=
name|QLatin1String
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
name|prefix
operator|.
name|clear
argument_list|()
expr_stmt|;
name|name
operator|=
name|qName
expr_stmt|;
block|}
else|else
block|{
name|prefix
operator|=
name|qName
operator|.
name|left
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|name
operator|=
name|qName
operator|.
name|mid
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/**************************************************************  *  * Private class declerations  *  **************************************************************/
end_comment
begin_class
DECL|class|QDomImplementationPrivate
class|class
name|QDomImplementationPrivate
block|{
public|public:
DECL|function|QDomImplementationPrivate
specifier|inline
name|QDomImplementationPrivate
parameter_list|()
block|{}
name|QDomImplementationPrivate
modifier|*
name|clone
parameter_list|()
function_decl|;
DECL|member|ref
name|QAtomicInt
name|ref
decl_stmt|;
DECL|member|invalidDataPolicy
specifier|static
name|QDomImplementation
operator|::
name|InvalidDataPolicy
name|invalidDataPolicy
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QDomNodePrivate
class|class
name|QDomNodePrivate
block|{
public|public:
name|QDomNodePrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
init|=
literal|0
parameter_list|)
constructor_decl|;
name|QDomNodePrivate
parameter_list|(
name|QDomNodePrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
constructor_decl|;
specifier|virtual
name|~
name|QDomNodePrivate
parameter_list|()
destructor_decl|;
DECL|function|nodeName
name|QString
name|nodeName
parameter_list|()
specifier|const
block|{
return|return
name|name
return|;
block|}
DECL|function|nodeValue
name|QString
name|nodeValue
parameter_list|()
specifier|const
block|{
return|return
name|value
return|;
block|}
DECL|function|setNodeValue
specifier|virtual
name|void
name|setNodeValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|v
parameter_list|)
block|{
name|value
operator|=
name|v
expr_stmt|;
block|}
name|QDomDocumentPrivate
modifier|*
name|ownerDocument
parameter_list|()
function_decl|;
name|void
name|setOwnerDocument
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|doc
parameter_list|)
function_decl|;
specifier|virtual
name|QDomNodePrivate
modifier|*
name|insertBefore
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|,
name|QDomNodePrivate
modifier|*
name|refChild
parameter_list|)
function_decl|;
specifier|virtual
name|QDomNodePrivate
modifier|*
name|insertAfter
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|,
name|QDomNodePrivate
modifier|*
name|refChild
parameter_list|)
function_decl|;
specifier|virtual
name|QDomNodePrivate
modifier|*
name|replaceChild
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|,
name|QDomNodePrivate
modifier|*
name|oldChild
parameter_list|)
function_decl|;
specifier|virtual
name|QDomNodePrivate
modifier|*
name|removeChild
parameter_list|(
name|QDomNodePrivate
modifier|*
name|oldChild
parameter_list|)
function_decl|;
specifier|virtual
name|QDomNodePrivate
modifier|*
name|appendChild
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|)
function_decl|;
name|QDomNodePrivate
modifier|*
name|namedItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
function_decl|;
specifier|virtual
name|QDomNodePrivate
modifier|*
name|cloneNode
parameter_list|(
name|bool
name|deep
init|=
literal|true
parameter_list|)
function_decl|;
specifier|virtual
name|void
name|normalize
parameter_list|()
function_decl|;
specifier|virtual
name|void
name|clear
parameter_list|()
function_decl|;
DECL|function|parent
specifier|inline
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|()
specifier|const
block|{
return|return
name|hasParent
condition|?
name|ownerNode
else|:
literal|0
return|;
block|}
DECL|function|setParent
specifier|inline
name|void
name|setParent
parameter_list|(
name|QDomNodePrivate
modifier|*
name|p
parameter_list|)
block|{
name|ownerNode
operator|=
name|p
expr_stmt|;
name|hasParent
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|setNoParent
name|void
name|setNoParent
parameter_list|()
block|{
name|ownerNode
operator|=
name|hasParent
condition|?
operator|(
name|QDomNodePrivate
operator|*
operator|)
name|ownerDocument
argument_list|()
else|:
literal|0
expr_stmt|;
name|hasParent
operator|=
literal|false
expr_stmt|;
block|}
comment|// Dynamic cast
DECL|function|isAttr
specifier|virtual
name|bool
name|isAttr
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|isCDATASection
specifier|virtual
name|bool
name|isCDATASection
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|isDocumentFragment
specifier|virtual
name|bool
name|isDocumentFragment
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|isDocument
specifier|virtual
name|bool
name|isDocument
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|isDocumentType
specifier|virtual
name|bool
name|isDocumentType
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|isElement
specifier|virtual
name|bool
name|isElement
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|isEntityReference
specifier|virtual
name|bool
name|isEntityReference
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|isText
specifier|virtual
name|bool
name|isText
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|isEntity
specifier|virtual
name|bool
name|isEntity
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|isNotation
specifier|virtual
name|bool
name|isNotation
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|isProcessingInstruction
specifier|virtual
name|bool
name|isProcessingInstruction
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|isCharacterData
specifier|virtual
name|bool
name|isCharacterData
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|isComment
specifier|virtual
name|bool
name|isComment
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|nodeType
specifier|virtual
name|QDomNode
operator|::
name|NodeType
name|nodeType
parameter_list|()
specifier|const
block|{
return|return
name|QDomNode
operator|::
name|BaseNode
return|;
block|}
specifier|virtual
name|void
name|save
parameter_list|(
name|QTextStream
modifier|&
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
function_decl|;
name|void
name|setLocation
parameter_list|(
name|int
name|lineNumber
parameter_list|,
name|int
name|columnNumber
parameter_list|)
function_decl|;
comment|// Variables
DECL|member|ref
name|QAtomicInt
name|ref
decl_stmt|;
DECL|member|prev
name|QDomNodePrivate
modifier|*
name|prev
decl_stmt|;
DECL|member|next
name|QDomNodePrivate
modifier|*
name|next
decl_stmt|;
DECL|member|ownerNode
name|QDomNodePrivate
modifier|*
name|ownerNode
decl_stmt|;
comment|// either the node's parent or the node's owner document
DECL|member|first
name|QDomNodePrivate
modifier|*
name|first
decl_stmt|;
DECL|member|last
name|QDomNodePrivate
modifier|*
name|last
decl_stmt|;
DECL|member|name
name|QString
name|name
decl_stmt|;
comment|// this is the local name if prefix != null
DECL|member|value
name|QString
name|value
decl_stmt|;
DECL|member|prefix
name|QString
name|prefix
decl_stmt|;
comment|// set this only for ElementNode and AttributeNode
DECL|member|namespaceURI
name|QString
name|namespaceURI
decl_stmt|;
comment|// set this only for ElementNode and AttributeNode
name|bool
name|createdWithDom1Interface
range|:
literal|1
decl_stmt|;
name|bool
name|hasParent
range|:
literal|1
decl_stmt|;
DECL|member|lineNumber
name|int
name|lineNumber
decl_stmt|;
DECL|member|columnNumber
name|int
name|columnNumber
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QDomNodeListPrivate
class|class
name|QDomNodeListPrivate
block|{
public|public:
name|QDomNodeListPrivate
parameter_list|(
name|QDomNodePrivate
modifier|*
parameter_list|)
constructor_decl|;
name|QDomNodeListPrivate
parameter_list|(
name|QDomNodePrivate
modifier|*
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
constructor_decl|;
name|QDomNodeListPrivate
parameter_list|(
name|QDomNodePrivate
modifier|*
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
constructor_decl|;
name|~
name|QDomNodeListPrivate
parameter_list|()
destructor_decl|;
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QDomNodeListPrivate
modifier|&
parameter_list|)
specifier|const
function_decl|;
name|bool
name|operator
name|!=
parameter_list|(
specifier|const
name|QDomNodeListPrivate
modifier|&
parameter_list|)
specifier|const
function_decl|;
name|void
name|createList
parameter_list|()
function_decl|;
name|QDomNodePrivate
modifier|*
name|item
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
name|uint
name|length
parameter_list|()
specifier|const
function_decl|;
DECL|member|ref
name|QAtomicInt
name|ref
decl_stmt|;
comment|/*       This list contains the children of this node.      */
DECL|member|node_impl
name|QDomNodePrivate
modifier|*
name|node_impl
decl_stmt|;
DECL|member|tagname
name|QString
name|tagname
decl_stmt|;
DECL|member|nsURI
name|QString
name|nsURI
decl_stmt|;
DECL|member|list
name|QList
argument_list|<
name|QDomNodePrivate
modifier|*
argument_list|>
name|list
decl_stmt|;
DECL|member|timestamp
name|long
name|timestamp
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QDomNamedNodeMapPrivate
class|class
name|QDomNamedNodeMapPrivate
block|{
public|public:
name|QDomNamedNodeMapPrivate
parameter_list|(
name|QDomNodePrivate
modifier|*
parameter_list|)
constructor_decl|;
name|~
name|QDomNamedNodeMapPrivate
parameter_list|()
destructor_decl|;
name|QDomNodePrivate
modifier|*
name|namedItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
function_decl|;
name|QDomNodePrivate
modifier|*
name|namedItemNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
specifier|const
function_decl|;
name|QDomNodePrivate
modifier|*
name|setNamedItem
parameter_list|(
name|QDomNodePrivate
modifier|*
name|arg
parameter_list|)
function_decl|;
name|QDomNodePrivate
modifier|*
name|setNamedItemNS
parameter_list|(
name|QDomNodePrivate
modifier|*
name|arg
parameter_list|)
function_decl|;
name|QDomNodePrivate
modifier|*
name|removeNamedItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
function_decl|;
name|QDomNodePrivate
modifier|*
name|item
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
function_decl|;
name|uint
name|length
parameter_list|()
specifier|const
function_decl|;
name|bool
name|contains
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
function_decl|;
name|bool
name|containsNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
specifier|const
function_decl|;
comment|/**      * Remove all children from the map.      */
name|void
name|clearMap
parameter_list|()
function_decl|;
DECL|function|isReadOnly
name|bool
name|isReadOnly
parameter_list|()
block|{
return|return
name|readonly
return|;
block|}
DECL|function|setReadOnly
name|void
name|setReadOnly
parameter_list|(
name|bool
name|r
parameter_list|)
block|{
name|readonly
operator|=
name|r
expr_stmt|;
block|}
DECL|function|isAppendToParent
name|bool
name|isAppendToParent
parameter_list|()
block|{
return|return
name|appendToParent
return|;
block|}
comment|/**      * If true, then the node will redirect insert/remove calls      * to its parent by calling QDomNodePrivate::appendChild or removeChild.      * In addition the map wont increase or decrease the reference count      * of the nodes it contains.      *      * By default this value is false and the map will handle reference counting      * by itself.      */
DECL|function|setAppendToParent
name|void
name|setAppendToParent
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|appendToParent
operator|=
name|b
expr_stmt|;
block|}
comment|/**      * Creates a copy of the map. It is a deep copy      * that means that all children are cloned.      */
name|QDomNamedNodeMapPrivate
modifier|*
name|clone
parameter_list|(
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|)
function_decl|;
comment|// Variables
DECL|member|ref
name|QAtomicInt
name|ref
decl_stmt|;
DECL|member|map
name|QHash
argument_list|<
name|QString
argument_list|,
name|QDomNodePrivate
modifier|*
argument_list|>
name|map
decl_stmt|;
DECL|member|parent
name|QDomNodePrivate
modifier|*
name|parent
decl_stmt|;
DECL|member|readonly
name|bool
name|readonly
decl_stmt|;
DECL|member|appendToParent
name|bool
name|appendToParent
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QDomDocumentTypePrivate
class|class
name|QDomDocumentTypePrivate
super|:
specifier|public
name|QDomNodePrivate
block|{
public|public:
name|QDomDocumentTypePrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
init|=
literal|0
parameter_list|)
constructor_decl|;
name|QDomDocumentTypePrivate
parameter_list|(
name|QDomDocumentTypePrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
constructor_decl|;
name|~
name|QDomDocumentTypePrivate
parameter_list|()
destructor_decl|;
name|void
name|init
parameter_list|()
function_decl|;
comment|// Reimplemented from QDomNodePrivate
name|QDomNodePrivate
modifier|*
name|cloneNode
parameter_list|(
name|bool
name|deep
init|=
literal|true
parameter_list|)
function_decl|;
name|QDomNodePrivate
modifier|*
name|insertBefore
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|,
name|QDomNodePrivate
modifier|*
name|refChild
parameter_list|)
function_decl|;
name|QDomNodePrivate
modifier|*
name|insertAfter
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|,
name|QDomNodePrivate
modifier|*
name|refChild
parameter_list|)
function_decl|;
name|QDomNodePrivate
modifier|*
name|replaceChild
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|,
name|QDomNodePrivate
modifier|*
name|oldChild
parameter_list|)
function_decl|;
name|QDomNodePrivate
modifier|*
name|removeChild
parameter_list|(
name|QDomNodePrivate
modifier|*
name|oldChild
parameter_list|)
function_decl|;
name|QDomNodePrivate
modifier|*
name|appendChild
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|)
function_decl|;
DECL|function|isDocumentType
specifier|virtual
name|bool
name|isDocumentType
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|nodeType
parameter_list|()
specifier|const
block|{
return|return
name|QDomNode
operator|::
name|DocumentTypeNode
return|;
block|}
name|void
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
function_decl|;
comment|// Variables
DECL|member|entities
name|QDomNamedNodeMapPrivate
modifier|*
name|entities
decl_stmt|;
DECL|member|notations
name|QDomNamedNodeMapPrivate
modifier|*
name|notations
decl_stmt|;
DECL|member|publicId
name|QString
name|publicId
decl_stmt|;
DECL|member|systemId
name|QString
name|systemId
decl_stmt|;
DECL|member|internalSubset
name|QString
name|internalSubset
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QDomDocumentFragmentPrivate
class|class
name|QDomDocumentFragmentPrivate
super|:
specifier|public
name|QDomNodePrivate
block|{
public|public:
name|QDomDocumentFragmentPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
init|=
literal|0
parameter_list|)
constructor_decl|;
name|QDomDocumentFragmentPrivate
parameter_list|(
name|QDomNodePrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
constructor_decl|;
comment|// Reimplemented from QDomNodePrivate
specifier|virtual
name|QDomNodePrivate
modifier|*
name|cloneNode
parameter_list|(
name|bool
name|deep
init|=
literal|true
parameter_list|)
function_decl|;
DECL|function|isDocumentFragment
specifier|virtual
name|bool
name|isDocumentFragment
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|nodeType
parameter_list|()
specifier|const
block|{
return|return
name|QDomNode
operator|::
name|DocumentFragmentNode
return|;
block|}
block|}
class|;
end_class
begin_class
DECL|class|QDomCharacterDataPrivate
class|class
name|QDomCharacterDataPrivate
super|:
specifier|public
name|QDomNodePrivate
block|{
public|public:
name|QDomCharacterDataPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
constructor_decl|;
name|QDomCharacterDataPrivate
parameter_list|(
name|QDomCharacterDataPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
constructor_decl|;
name|uint
name|dataLength
parameter_list|()
specifier|const
function_decl|;
name|QString
name|substringData
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|count
parameter_list|)
specifier|const
function_decl|;
name|void
name|appendData
parameter_list|(
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
function_decl|;
name|void
name|insertData
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
function_decl|;
name|void
name|deleteData
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|count
parameter_list|)
function_decl|;
name|void
name|replaceData
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|count
parameter_list|,
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
function_decl|;
comment|// Reimplemented from QDomNodePrivate
DECL|function|isCharacterData
specifier|virtual
name|bool
name|isCharacterData
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|nodeType
parameter_list|()
specifier|const
block|{
return|return
name|QDomNode
operator|::
name|CharacterDataNode
return|;
block|}
name|QDomNodePrivate
modifier|*
name|cloneNode
parameter_list|(
name|bool
name|deep
init|=
literal|true
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_class
DECL|class|QDomTextPrivate
class|class
name|QDomTextPrivate
super|:
specifier|public
name|QDomCharacterDataPrivate
block|{
public|public:
name|QDomTextPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|val
parameter_list|)
constructor_decl|;
name|QDomTextPrivate
parameter_list|(
name|QDomTextPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
constructor_decl|;
name|QDomTextPrivate
modifier|*
name|splitText
parameter_list|(
name|int
name|offset
parameter_list|)
function_decl|;
comment|// Reimplemented from QDomNodePrivate
name|QDomNodePrivate
modifier|*
name|cloneNode
parameter_list|(
name|bool
name|deep
init|=
literal|true
parameter_list|)
function_decl|;
DECL|function|isText
specifier|virtual
name|bool
name|isText
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|nodeType
parameter_list|()
specifier|const
block|{
return|return
name|QDomNode
operator|::
name|TextNode
return|;
block|}
specifier|virtual
name|void
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
function_decl|;
block|}
class|;
end_class
begin_class
DECL|class|QDomAttrPrivate
class|class
name|QDomAttrPrivate
super|:
specifier|public
name|QDomNodePrivate
block|{
public|public:
name|QDomAttrPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
constructor_decl|;
name|QDomAttrPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
parameter_list|,
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|)
constructor_decl|;
name|QDomAttrPrivate
parameter_list|(
name|QDomAttrPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
constructor_decl|;
name|bool
name|specified
parameter_list|()
specifier|const
function_decl|;
comment|// Reimplemented from QDomNodePrivate
name|void
name|setNodeValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|v
parameter_list|)
function_decl|;
name|QDomNodePrivate
modifier|*
name|cloneNode
parameter_list|(
name|bool
name|deep
init|=
literal|true
parameter_list|)
function_decl|;
DECL|function|isAttr
specifier|virtual
name|bool
name|isAttr
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|nodeType
parameter_list|()
specifier|const
block|{
return|return
name|QDomNode
operator|::
name|AttributeNode
return|;
block|}
specifier|virtual
name|void
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
function_decl|;
comment|// Variables
DECL|member|m_specified
name|bool
name|m_specified
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QDomElementPrivate
class|class
name|QDomElementPrivate
super|:
specifier|public
name|QDomNodePrivate
block|{
public|public:
name|QDomElementPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
constructor_decl|;
name|QDomElementPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|)
constructor_decl|;
name|QDomElementPrivate
parameter_list|(
name|QDomElementPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
constructor_decl|;
name|~
name|QDomElementPrivate
parameter_list|()
destructor_decl|;
name|QString
name|attribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|defValue
parameter_list|)
specifier|const
function_decl|;
name|QString
name|attributeNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|,
specifier|const
name|QString
modifier|&
name|defValue
parameter_list|)
specifier|const
function_decl|;
name|void
name|setAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
function_decl|;
name|void
name|setAttributeNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|,
specifier|const
name|QString
modifier|&
name|newValue
parameter_list|)
function_decl|;
name|void
name|removeAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
function_decl|;
name|QDomAttrPrivate
modifier|*
name|attributeNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
function_decl|;
name|QDomAttrPrivate
modifier|*
name|attributeNodeNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
function_decl|;
name|QDomAttrPrivate
modifier|*
name|setAttributeNode
parameter_list|(
name|QDomAttrPrivate
modifier|*
name|newAttr
parameter_list|)
function_decl|;
name|QDomAttrPrivate
modifier|*
name|setAttributeNodeNS
parameter_list|(
name|QDomAttrPrivate
modifier|*
name|newAttr
parameter_list|)
function_decl|;
name|QDomAttrPrivate
modifier|*
name|removeAttributeNode
parameter_list|(
name|QDomAttrPrivate
modifier|*
name|oldAttr
parameter_list|)
function_decl|;
name|bool
name|hasAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
function_decl|;
name|bool
name|hasAttributeNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
function_decl|;
name|QString
name|text
parameter_list|()
function_decl|;
comment|// Reimplemented from QDomNodePrivate
DECL|function|attributes
name|QDomNamedNodeMapPrivate
modifier|*
name|attributes
parameter_list|()
block|{
return|return
name|m_attr
return|;
block|}
DECL|function|hasAttributes
name|bool
name|hasAttributes
parameter_list|()
block|{
return|return
operator|(
name|m_attr
operator|->
name|length
argument_list|()
operator|>
literal|0
operator|)
return|;
block|}
DECL|function|isElement
specifier|virtual
name|bool
name|isElement
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|nodeType
parameter_list|()
specifier|const
block|{
return|return
name|QDomNode
operator|::
name|ElementNode
return|;
block|}
name|QDomNodePrivate
modifier|*
name|cloneNode
parameter_list|(
name|bool
name|deep
init|=
literal|true
parameter_list|)
function_decl|;
specifier|virtual
name|void
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
function_decl|;
comment|// Variables
DECL|member|m_attr
name|QDomNamedNodeMapPrivate
modifier|*
name|m_attr
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QDomCommentPrivate
class|class
name|QDomCommentPrivate
super|:
specifier|public
name|QDomCharacterDataPrivate
block|{
public|public:
name|QDomCommentPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|val
parameter_list|)
constructor_decl|;
name|QDomCommentPrivate
parameter_list|(
name|QDomCommentPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
constructor_decl|;
comment|// Reimplemented from QDomNodePrivate
name|QDomNodePrivate
modifier|*
name|cloneNode
parameter_list|(
name|bool
name|deep
init|=
literal|true
parameter_list|)
function_decl|;
DECL|function|isComment
specifier|virtual
name|bool
name|isComment
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|nodeType
parameter_list|()
specifier|const
block|{
return|return
name|QDomNode
operator|::
name|CommentNode
return|;
block|}
specifier|virtual
name|void
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
function_decl|;
block|}
class|;
end_class
begin_class
DECL|class|QDomCDATASectionPrivate
class|class
name|QDomCDATASectionPrivate
super|:
specifier|public
name|QDomTextPrivate
block|{
public|public:
name|QDomCDATASectionPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|val
parameter_list|)
constructor_decl|;
name|QDomCDATASectionPrivate
parameter_list|(
name|QDomCDATASectionPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
constructor_decl|;
comment|// Reimplemented from QDomNodePrivate
name|QDomNodePrivate
modifier|*
name|cloneNode
parameter_list|(
name|bool
name|deep
init|=
literal|true
parameter_list|)
function_decl|;
DECL|function|isCDATASection
specifier|virtual
name|bool
name|isCDATASection
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|nodeType
parameter_list|()
specifier|const
block|{
return|return
name|QDomNode
operator|::
name|CDATASectionNode
return|;
block|}
specifier|virtual
name|void
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
function_decl|;
block|}
class|;
end_class
begin_class
DECL|class|QDomNotationPrivate
class|class
name|QDomNotationPrivate
super|:
specifier|public
name|QDomNodePrivate
block|{
public|public:
name|QDomNotationPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|pub
parameter_list|,
specifier|const
name|QString
modifier|&
name|sys
parameter_list|)
constructor_decl|;
name|QDomNotationPrivate
parameter_list|(
name|QDomNotationPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
constructor_decl|;
comment|// Reimplemented from QDomNodePrivate
name|QDomNodePrivate
modifier|*
name|cloneNode
parameter_list|(
name|bool
name|deep
init|=
literal|true
parameter_list|)
function_decl|;
DECL|function|isNotation
specifier|virtual
name|bool
name|isNotation
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|nodeType
parameter_list|()
specifier|const
block|{
return|return
name|QDomNode
operator|::
name|NotationNode
return|;
block|}
specifier|virtual
name|void
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
function_decl|;
comment|// Variables
DECL|member|m_sys
name|QString
name|m_sys
decl_stmt|;
DECL|member|m_pub
name|QString
name|m_pub
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QDomEntityPrivate
class|class
name|QDomEntityPrivate
super|:
specifier|public
name|QDomNodePrivate
block|{
public|public:
name|QDomEntityPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|pub
parameter_list|,
specifier|const
name|QString
modifier|&
name|sys
parameter_list|,
specifier|const
name|QString
modifier|&
name|notation
parameter_list|)
constructor_decl|;
name|QDomEntityPrivate
parameter_list|(
name|QDomEntityPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
constructor_decl|;
comment|// Reimplemented from QDomNodePrivate
name|QDomNodePrivate
modifier|*
name|cloneNode
parameter_list|(
name|bool
name|deep
init|=
literal|true
parameter_list|)
function_decl|;
DECL|function|isEntity
specifier|virtual
name|bool
name|isEntity
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|nodeType
parameter_list|()
specifier|const
block|{
return|return
name|QDomNode
operator|::
name|EntityNode
return|;
block|}
specifier|virtual
name|void
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
function_decl|;
comment|// Variables
DECL|member|m_sys
name|QString
name|m_sys
decl_stmt|;
DECL|member|m_pub
name|QString
name|m_pub
decl_stmt|;
DECL|member|m_notationName
name|QString
name|m_notationName
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QDomEntityReferencePrivate
class|class
name|QDomEntityReferencePrivate
super|:
specifier|public
name|QDomNodePrivate
block|{
public|public:
name|QDomEntityReferencePrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
constructor_decl|;
name|QDomEntityReferencePrivate
parameter_list|(
name|QDomNodePrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
constructor_decl|;
comment|// Reimplemented from QDomNodePrivate
name|QDomNodePrivate
modifier|*
name|cloneNode
parameter_list|(
name|bool
name|deep
init|=
literal|true
parameter_list|)
function_decl|;
DECL|function|isEntityReference
name|bool
name|isEntityReference
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|nodeType
parameter_list|()
specifier|const
block|{
return|return
name|QDomNode
operator|::
name|EntityReferenceNode
return|;
block|}
specifier|virtual
name|void
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
function_decl|;
block|}
class|;
end_class
begin_class
DECL|class|QDomProcessingInstructionPrivate
class|class
name|QDomProcessingInstructionPrivate
super|:
specifier|public
name|QDomNodePrivate
block|{
public|public:
name|QDomProcessingInstructionPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
constructor_decl|;
name|QDomProcessingInstructionPrivate
parameter_list|(
name|QDomProcessingInstructionPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
constructor_decl|;
comment|// Reimplemented from QDomNodePrivate
name|QDomNodePrivate
modifier|*
name|cloneNode
parameter_list|(
name|bool
name|deep
init|=
literal|true
parameter_list|)
function_decl|;
DECL|function|isProcessingInstruction
specifier|virtual
name|bool
name|isProcessingInstruction
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|nodeType
parameter_list|()
specifier|const
block|{
return|return
name|QDomNode
operator|::
name|ProcessingInstructionNode
return|;
block|}
specifier|virtual
name|void
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
function_decl|;
block|}
class|;
end_class
begin_class
DECL|class|QDomDocumentPrivate
class|class
name|QDomDocumentPrivate
super|:
specifier|public
name|QDomNodePrivate
block|{
public|public:
name|QDomDocumentPrivate
parameter_list|()
constructor_decl|;
name|QDomDocumentPrivate
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
constructor_decl|;
name|QDomDocumentPrivate
parameter_list|(
name|QDomDocumentTypePrivate
modifier|*
name|dt
parameter_list|)
constructor_decl|;
name|QDomDocumentPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
constructor_decl|;
name|~
name|QDomDocumentPrivate
parameter_list|()
destructor_decl|;
name|bool
name|setContent
parameter_list|(
name|QXmlInputSource
modifier|*
name|source
parameter_list|,
name|bool
name|namespaceProcessing
parameter_list|,
name|QString
modifier|*
name|errorMsg
parameter_list|,
name|int
modifier|*
name|errorLine
parameter_list|,
name|int
modifier|*
name|errorColumn
parameter_list|)
function_decl|;
name|bool
name|setContent
parameter_list|(
name|QXmlInputSource
modifier|*
name|source
parameter_list|,
name|QXmlReader
modifier|*
name|reader
parameter_list|,
name|QString
modifier|*
name|errorMsg
parameter_list|,
name|int
modifier|*
name|errorLine
parameter_list|,
name|int
modifier|*
name|errorColumn
parameter_list|)
function_decl|;
comment|// Attributes
DECL|function|doctype
name|QDomDocumentTypePrivate
modifier|*
name|doctype
parameter_list|()
block|{
return|return
name|type
operator|.
name|data
argument_list|()
return|;
block|}
DECL|function|implementation
name|QDomImplementationPrivate
modifier|*
name|implementation
parameter_list|()
block|{
return|return
name|impl
operator|.
name|data
argument_list|()
return|;
block|}
name|QDomElementPrivate
modifier|*
name|documentElement
parameter_list|()
function_decl|;
comment|// Factories
name|QDomElementPrivate
modifier|*
name|createElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|tagName
parameter_list|)
function_decl|;
name|QDomElementPrivate
modifier|*
name|createElementNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|)
function_decl|;
name|QDomDocumentFragmentPrivate
modifier|*
name|createDocumentFragment
parameter_list|()
function_decl|;
name|QDomTextPrivate
modifier|*
name|createTextNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
function_decl|;
name|QDomCommentPrivate
modifier|*
name|createComment
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
function_decl|;
name|QDomCDATASectionPrivate
modifier|*
name|createCDATASection
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
function_decl|;
name|QDomProcessingInstructionPrivate
modifier|*
name|createProcessingInstruction
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
function_decl|;
name|QDomAttrPrivate
modifier|*
name|createAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
function_decl|;
name|QDomAttrPrivate
modifier|*
name|createAttributeNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|)
function_decl|;
name|QDomEntityReferencePrivate
modifier|*
name|createEntityReference
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
function_decl|;
name|QDomNodePrivate
modifier|*
name|importNode
parameter_list|(
specifier|const
name|QDomNodePrivate
modifier|*
name|importedNode
parameter_list|,
name|bool
name|deep
parameter_list|)
function_decl|;
comment|// Reimplemented from QDomNodePrivate
name|QDomNodePrivate
modifier|*
name|cloneNode
parameter_list|(
name|bool
name|deep
init|=
literal|true
parameter_list|)
function_decl|;
DECL|function|isDocument
name|bool
name|isDocument
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|nodeType
parameter_list|()
specifier|const
block|{
return|return
name|QDomNode
operator|::
name|DocumentNode
return|;
block|}
name|void
name|clear
parameter_list|()
function_decl|;
comment|// Variables
DECL|member|impl
name|QExplicitlySharedDataPointer
argument_list|<
name|QDomImplementationPrivate
argument_list|>
name|impl
decl_stmt|;
DECL|member|type
name|QExplicitlySharedDataPointer
argument_list|<
name|QDomDocumentTypePrivate
argument_list|>
name|type
decl_stmt|;
name|void
name|saveDocument
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|,
specifier|const
name|int
name|indent
parameter_list|,
name|QDomNode
operator|::
name|EncodingPolicy
name|encUsed
parameter_list|)
specifier|const
function_decl|;
comment|/* \internal        Counter for the QDomNodeListPrivate timestamps.         This is a cache optimization, that might in some cases be effective. The        dilemma is that QDomNode::childNodes() returns a list, but the        implementation stores the children in a linked list. Hence, in order to        get the children out through childNodes(), a list must be populated each        time, which is O(N).         DOM has the requirement of node references being live, see DOM Core        Level 3, 1.1.1 The DOM Structure Model, which means that changes to the        underlying documents must be reflected in node lists.         This mechanism, nodeListTime, is a caching optimization that reduces the        amount of times the node list is rebuilt, by only doing so when the        document actually changes. However, a change to anywhere in any document        invalidate all lists, since no dependency tracking is done.         It functions by that all modifying functions(insertBefore() and so on)        increment the count; each QDomNodeListPrivate copies nodeListTime on        construction, and compares its own value to nodeListTime in order to        determine whether it needs to rebuild.         This is reentrant. The nodeListTime may overflow, but that's ok since we        check for equalness, not whether nodeListTime is smaller than the list's        stored timestamp.     */
DECL|member|nodeListTime
name|long
name|nodeListTime
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/**************************************************************  *  * QDomHandler  *  **************************************************************/
end_comment
begin_class
DECL|class|QDomHandler
class|class
name|QDomHandler
super|:
specifier|public
name|QXmlDefaultHandler
block|{
public|public:
name|QDomHandler
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|d
parameter_list|,
name|bool
name|namespaceProcessing
parameter_list|)
constructor_decl|;
name|~
name|QDomHandler
parameter_list|()
destructor_decl|;
comment|// content handler
name|bool
name|endDocument
parameter_list|()
function_decl|;
name|bool
name|startElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|,
specifier|const
name|QXmlAttributes
modifier|&
name|atts
parameter_list|)
function_decl|;
name|bool
name|endElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|)
function_decl|;
name|bool
name|characters
parameter_list|(
specifier|const
name|QString
modifier|&
name|ch
parameter_list|)
function_decl|;
name|bool
name|processingInstruction
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
function_decl|;
name|bool
name|skippedEntity
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
function_decl|;
comment|// error handler
name|bool
name|fatalError
parameter_list|(
specifier|const
name|QXmlParseException
modifier|&
name|exception
parameter_list|)
function_decl|;
comment|// lexical handler
name|bool
name|startCDATA
parameter_list|()
function_decl|;
name|bool
name|endCDATA
parameter_list|()
function_decl|;
name|bool
name|startEntity
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
function_decl|;
name|bool
name|endEntity
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
function_decl|;
name|bool
name|startDTD
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|publicId
parameter_list|,
specifier|const
name|QString
modifier|&
name|systemId
parameter_list|)
function_decl|;
name|bool
name|comment
parameter_list|(
specifier|const
name|QString
modifier|&
name|ch
parameter_list|)
function_decl|;
comment|// decl handler
name|bool
name|externalEntityDecl
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|publicId
parameter_list|,
specifier|const
name|QString
modifier|&
name|systemId
parameter_list|)
function_decl|;
comment|// DTD handler
name|bool
name|notationDecl
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|publicId
parameter_list|,
specifier|const
name|QString
modifier|&
name|systemId
parameter_list|)
function_decl|;
name|bool
name|unparsedEntityDecl
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|publicId
parameter_list|,
specifier|const
name|QString
modifier|&
name|systemId
parameter_list|,
specifier|const
name|QString
modifier|&
name|notationName
parameter_list|)
function_decl|;
name|void
name|setDocumentLocator
parameter_list|(
name|QXmlLocator
modifier|*
name|locator
parameter_list|)
function_decl|;
DECL|member|errorMsg
name|QString
name|errorMsg
decl_stmt|;
DECL|member|errorLine
name|int
name|errorLine
decl_stmt|;
DECL|member|errorColumn
name|int
name|errorColumn
decl_stmt|;
private|private:
DECL|member|doc
name|QDomDocumentPrivate
modifier|*
name|doc
decl_stmt|;
DECL|member|node
name|QDomNodePrivate
modifier|*
name|node
decl_stmt|;
DECL|member|entityName
name|QString
name|entityName
decl_stmt|;
DECL|member|cdata
name|bool
name|cdata
decl_stmt|;
DECL|member|nsProcessing
name|bool
name|nsProcessing
decl_stmt|;
DECL|member|locator
name|QXmlLocator
modifier|*
name|locator
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
comment|// Workaround crash in elf2e32 under Wine.
DECL|function|dummy
specifier|virtual
name|void
name|dummy
parameter_list|()
block|{}
endif|#
directive|endif
block|}
class|;
end_class
begin_comment
comment|/**************************************************************  *  * Functions for verifying legal data  *  **************************************************************/
end_comment
begin_decl_stmt
DECL|member|invalidDataPolicy
name|QDomImplementation
operator|::
name|InvalidDataPolicy
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
init|=
name|QDomImplementation
operator|::
name|AcceptInvalidChars
decl_stmt|;
end_decl_stmt
begin_comment
comment|// [5] Name ::= (Letter | '_' | ':') (NameChar)*
end_comment
begin_function
DECL|function|fixedXmlName
specifier|static
name|QString
name|fixedXmlName
parameter_list|(
specifier|const
name|QString
modifier|&
name|_name
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|,
name|bool
name|namespaces
init|=
literal|false
parameter_list|)
block|{
name|QString
name|name
decl_stmt|,
name|prefix
decl_stmt|;
if|if
condition|(
name|namespaces
condition|)
name|qt_split_namespace
argument_list|(
name|prefix
argument_list|,
name|name
argument_list|,
name|_name
argument_list|,
literal|true
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|_name
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|AcceptInvalidChars
condition|)
block|{
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|_name
return|;
block|}
name|QString
name|result
decl_stmt|;
name|bool
name|firstChar
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|name
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|c
init|=
name|name
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstChar
condition|)
block|{
if|if
condition|(
name|QXmlUtils
operator|::
name|isLetter
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|.
name|unicode
argument_list|()
operator|==
literal|'_'
operator|||
name|c
operator|.
name|unicode
argument_list|()
operator|==
literal|':'
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|firstChar
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|ReturnNullNode
condition|)
block|{
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|QXmlUtils
operator|::
name|isNameChar
argument_list|(
name|c
argument_list|)
condition|)
name|result
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|ReturnNullNode
condition|)
block|{
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
block|}
block|}
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|namespaces
operator|&&
operator|!
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|prefix
operator|+
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|+
name|result
return|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|// [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)
end_comment
begin_comment
comment|// '<', '&' and "]]>" will be escaped when writing
end_comment
begin_function
DECL|function|fixedCharData
specifier|static
name|QString
name|fixedCharData
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|AcceptInvalidChars
condition|)
block|{
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|data
return|;
block|}
name|QString
name|result
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|c
init|=
name|data
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|QXmlUtils
operator|::
name|isChar
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|ReturnNullNode
condition|)
block|{
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
block|}
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|// [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
end_comment
begin_comment
comment|// can't escape "--", since entities are not recognised within comments
end_comment
begin_function
DECL|function|fixedComment
specifier|static
name|QString
name|fixedComment
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|AcceptInvalidChars
condition|)
block|{
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|data
return|;
block|}
name|QString
name|fixedData
init|=
name|fixedCharData
argument_list|(
name|data
argument_list|,
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|ok
condition|)
return|return
name|QString
argument_list|()
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|idx
init|=
name|fixedData
operator|.
name|indexOf
argument_list|(
name|QLatin1String
argument_list|(
literal|"--"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|ReturnNullNode
condition|)
block|{
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|fixedData
operator|.
name|remove
argument_list|(
name|idx
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|fixedData
return|;
block|}
end_function
begin_comment
comment|// [20] CData ::= (Char* - (Char* ']]>' Char*))
end_comment
begin_comment
comment|// can't escape "]]>", since entities are not recognised within comments
end_comment
begin_function
DECL|function|fixedCDataSection
specifier|static
name|QString
name|fixedCDataSection
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|AcceptInvalidChars
condition|)
block|{
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|data
return|;
block|}
name|QString
name|fixedData
init|=
name|fixedCharData
argument_list|(
name|data
argument_list|,
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|ok
condition|)
return|return
name|QString
argument_list|()
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|idx
init|=
name|fixedData
operator|.
name|indexOf
argument_list|(
name|QLatin1String
argument_list|(
literal|"]]>"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|ReturnNullNode
condition|)
block|{
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|fixedData
operator|.
name|remove
argument_list|(
name|idx
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|fixedData
return|;
block|}
end_function
begin_comment
comment|// [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
end_comment
begin_function
DECL|function|fixedPIData
specifier|static
name|QString
name|fixedPIData
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|AcceptInvalidChars
condition|)
block|{
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|data
return|;
block|}
name|QString
name|fixedData
init|=
name|fixedCharData
argument_list|(
name|data
argument_list|,
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|ok
condition|)
return|return
name|QString
argument_list|()
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|idx
init|=
name|fixedData
operator|.
name|indexOf
argument_list|(
name|QLatin1String
argument_list|(
literal|"?>"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|ReturnNullNode
condition|)
block|{
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|fixedData
operator|.
name|remove
argument_list|(
name|idx
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|fixedData
return|;
block|}
end_function
begin_comment
comment|// [12] PubidLiteral ::= '"' PubidChar* '"' | "'" (PubidChar - "'")* "'"
end_comment
begin_comment
comment|// The correct quote will be chosen when writing
end_comment
begin_function
DECL|function|fixedPubidLiteral
specifier|static
name|QString
name|fixedPubidLiteral
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|AcceptInvalidChars
condition|)
block|{
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|data
return|;
block|}
name|QString
name|result
decl_stmt|;
if|if
condition|(
name|QXmlUtils
operator|::
name|isPublicID
argument_list|(
name|data
argument_list|)
condition|)
name|result
operator|=
name|data
expr_stmt|;
elseif|else
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|ReturnNullNode
condition|)
block|{
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
if|if
condition|(
name|result
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|result
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|ReturnNullNode
condition|)
block|{
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
else|else
block|{
name|result
operator|.
name|remove
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|// [11] SystemLiteral ::= ('"' [^"]* '"') | ("'" [^']* "'")
end_comment
begin_comment
comment|// The correct quote will be chosen when writing
end_comment
begin_function
DECL|function|fixedSystemLiteral
specifier|static
name|QString
name|fixedSystemLiteral
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|AcceptInvalidChars
condition|)
block|{
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|data
return|;
block|}
name|QString
name|result
init|=
name|data
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|result
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|==
name|QDomImplementation
operator|::
name|ReturnNullNode
condition|)
block|{
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
else|else
block|{
name|result
operator|.
name|remove
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomImplementationPrivate  *  **************************************************************/
end_comment
begin_function
DECL|function|clone
name|QDomImplementationPrivate
modifier|*
name|QDomImplementationPrivate
operator|::
name|clone
parameter_list|()
block|{
return|return
operator|new
name|QDomImplementationPrivate
return|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomImplementation  *  **************************************************************/
end_comment
begin_comment
comment|/*!     \class QDomImplementation     \reentrant     \brief The QDomImplementation class provides information about the     features of the DOM implementation.      \inmodule QtXml     \ingroup xml-tools      This class describes the features that are supported by the DOM     implementation. Currently the XML subset of DOM Level 1 and DOM     Level 2 Core are supported.      Normally you will use the function QDomDocument::implementation()     to get the implementation object.      You can create a new document type with createDocumentType() and a     new document with createDocument().      For further information about the Document Object Model see     \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and     \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}. For a more     general introduction of the DOM implementation see the QDomDocument     documentation.      The QDom classes have a few issues of nonconformance with the XML     specifications that cannot be fixed in Qt 4 without breaking backward     compatibility. The QtXmlPatterns module and the QXmlStreamReader and     QXmlStreamWriter classes have a higher degree of a conformance.      \sa hasFeature() */
end_comment
begin_comment
comment|/*!     Constructs a QDomImplementation object. */
end_comment
begin_constructor
DECL|function|QDomImplementation
name|QDomImplementation
operator|::
name|QDomImplementation
parameter_list|()
block|{
name|impl
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a x. */
end_comment
begin_constructor
DECL|function|QDomImplementation
name|QDomImplementation
operator|::
name|QDomImplementation
parameter_list|(
specifier|const
name|QDomImplementation
modifier|&
name|x
parameter_list|)
block|{
name|impl
operator|=
name|x
operator|.
name|impl
expr_stmt|;
if|if
condition|(
name|impl
condition|)
name|impl
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_constructor
DECL|function|QDomImplementation
name|QDomImplementation
operator|::
name|QDomImplementation
parameter_list|(
name|QDomImplementationPrivate
modifier|*
name|p
parameter_list|)
block|{
comment|// We want to be co-owners, so increase the reference count
name|impl
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|impl
condition|)
name|impl
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns \a x to this DOM implementation. */
end_comment
begin_function
DECL|function|operator =
name|QDomImplementation
modifier|&
name|QDomImplementation
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomImplementation
modifier|&
name|x
parameter_list|)
block|{
if|if
condition|(
name|x
operator|.
name|impl
condition|)
name|x
operator|.
name|impl
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|impl
operator|&&
operator|!
name|impl
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|impl
expr_stmt|;
name|impl
operator|=
name|x
operator|.
name|impl
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if \a x and this DOM implementation object were     created from the same QDomDocument; otherwise returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QDomImplementation
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QDomImplementation
modifier|&
name|x
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|impl
operator|==
name|x
operator|.
name|impl
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if \a x and this DOM implementation object were     created from different QDomDocuments; otherwise returns false. */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QDomImplementation
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QDomImplementation
modifier|&
name|x
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|impl
operator|!=
name|x
operator|.
name|impl
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the object and frees its resources. */
end_comment
begin_destructor
DECL|function|~QDomImplementation
name|QDomImplementation
operator|::
name|~
name|QDomImplementation
parameter_list|()
block|{
if|if
condition|(
name|impl
operator|&&
operator|!
name|impl
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|impl
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     The function returns true if QDom implements the requested \a     version of a \a feature; otherwise returns false.      The currently supported features and their versions:     \table     \header \i Feature \i Version     \row \i XML \i 1.0     \endtable */
end_comment
begin_function
DECL|function|hasFeature
name|bool
name|QDomImplementation
operator|::
name|hasFeature
parameter_list|(
specifier|const
name|QString
modifier|&
name|feature
parameter_list|,
specifier|const
name|QString
modifier|&
name|version
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|feature
operator|==
name|QLatin1String
argument_list|(
literal|"XML"
argument_list|)
condition|)
block|{
if|if
condition|(
name|version
operator|.
name|isEmpty
argument_list|()
operator|||
name|version
operator|==
name|QLatin1String
argument_list|(
literal|"1.0"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|// ### add DOM level 2 features
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a document type node for the name \a qName.      \a publicId specifies the public identifier of the external     subset. If you specify an empty string (QString()) as the \a     publicId, this means that the document type has no public     identifier.      \a systemId specifies the system identifier of the external     subset. If you specify an empty string as the \a systemId, this     means that the document type has no system identifier.      Since you cannot have a public identifier without a system     identifier, the public identifier is set to an empty string if     there is no system identifier.      DOM level 2 does not support any other document type declaration     features.      The only way you can use a document type that was created this     way, is in combination with the createDocument() function to     create a QDomDocument with this document type.      In the DOM specification, this is the only way to create a non-null     document. For historical reasons, Qt also allows to create the     document using the default empty constructor. The resulting document     is null, but becomes non-null when a factory function, for example     QDomDocument::createElement(), is called. The document also becomes     non-null when setContent() is called.      \sa createDocument() */
end_comment
begin_function
DECL|function|createDocumentType
name|QDomDocumentType
name|QDomImplementation
operator|::
name|createDocumentType
parameter_list|(
specifier|const
name|QString
modifier|&
name|qName
parameter_list|,
specifier|const
name|QString
modifier|&
name|publicId
parameter_list|,
specifier|const
name|QString
modifier|&
name|systemId
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|QString
name|fixedName
init|=
name|fixedXmlName
argument_list|(
name|qName
argument_list|,
operator|&
name|ok
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDomDocumentType
argument_list|()
return|;
name|QString
name|fixedPublicId
init|=
name|fixedPubidLiteral
argument_list|(
name|publicId
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDomDocumentType
argument_list|()
return|;
name|QString
name|fixedSystemId
init|=
name|fixedSystemLiteral
argument_list|(
name|systemId
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDomDocumentType
argument_list|()
return|;
name|QDomDocumentTypePrivate
modifier|*
name|dt
init|=
operator|new
name|QDomDocumentTypePrivate
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|dt
operator|->
name|name
operator|=
name|fixedName
expr_stmt|;
if|if
condition|(
name|systemId
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|dt
operator|->
name|publicId
operator|.
name|clear
argument_list|()
expr_stmt|;
name|dt
operator|->
name|systemId
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dt
operator|->
name|publicId
operator|=
name|fixedPublicId
expr_stmt|;
name|dt
operator|->
name|systemId
operator|=
name|fixedSystemId
expr_stmt|;
block|}
name|dt
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|QDomDocumentType
argument_list|(
name|dt
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a DOM document with the document type \a doctype. This     function also adds a root element node with the qualified name \a     qName and the namespace URI \a nsURI. */
end_comment
begin_function
DECL|function|createDocument
name|QDomDocument
name|QDomImplementation
operator|::
name|createDocument
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|,
specifier|const
name|QDomDocumentType
modifier|&
name|doctype
parameter_list|)
block|{
name|QDomDocument
name|doc
argument_list|(
name|doctype
argument_list|)
decl_stmt|;
name|QDomElement
name|root
init|=
name|doc
operator|.
name|createElementNS
argument_list|(
name|nsURI
argument_list|,
name|qName
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QDomDocument
argument_list|()
return|;
name|doc
operator|.
name|appendChild
argument_list|(
name|root
argument_list|)
expr_stmt|;
return|return
name|doc
return|;
block|}
end_function
begin_comment
comment|/*!     Returns false if the object was created by     QDomDocument::implementation(); otherwise returns true. */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QDomImplementation
operator|::
name|isNull
parameter_list|()
block|{
return|return
operator|(
name|impl
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QDomImplementation::InvalidDataPolicy      This enum specifies what should be done when a factory function     in QDomDocument is called with invalid data.     \value AcceptInvalidChars The data should be stored in the DOM object         anyway. In this case the resulting XML document might not be well-formed.         This is the default value and QDom's behavior in Qt< 4.1.     \value DropInvalidChars The invalid characters should be removed from         the data.     \value ReturnNullNode The factory function should return a null node.      \sa setInvalidDataPolicy() invalidDataPolicy() */
end_comment
begin_comment
comment|/*!    \enum QDomNode::EncodingPolicy    \since 4.3     This enum specifies how QDomNode::save() determines what encoding to use    when serializing.     \value EncodingFromDocument The encoding is fetched from the document.    \value EncodingFromTextStream The encoding is fetched from the QTextStream.     See also the overload of the save() function that takes an EncodingPolicy. */
end_comment
begin_comment
comment|/*!     \since 4.1     \nonreentrant      Returns the invalid data policy, which specifies what should be done when     a factory function in QDomDocument is passed invalid data.      \sa setInvalidDataPolicy() InvalidDataPolicy */
end_comment
begin_function
DECL|function|invalidDataPolicy
name|QDomImplementation
operator|::
name|InvalidDataPolicy
name|QDomImplementation
operator|::
name|invalidDataPolicy
parameter_list|()
block|{
return|return
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1     \nonreentrant      Sets the invalid data policy, which specifies what should be done when     a factory function in QDomDocument is passed invalid data.      The \a policy is set for all instances of QDomDocument which already     exist and which will be created in the future.      \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 0      \sa invalidDataPolicy() InvalidDataPolicy */
end_comment
begin_function
DECL|function|setInvalidDataPolicy
name|void
name|QDomImplementation
operator|::
name|setInvalidDataPolicy
parameter_list|(
name|InvalidDataPolicy
name|policy
parameter_list|)
block|{
name|QDomImplementationPrivate
operator|::
name|invalidDataPolicy
operator|=
name|policy
expr_stmt|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomNodeListPrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomNodeListPrivate
name|QDomNodeListPrivate
operator|::
name|QDomNodeListPrivate
parameter_list|(
name|QDomNodePrivate
modifier|*
name|n_impl
parameter_list|)
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
block|{
name|node_impl
operator|=
name|n_impl
expr_stmt|;
if|if
condition|(
name|node_impl
condition|)
name|node_impl
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|timestamp
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomNodeListPrivate
name|QDomNodeListPrivate
operator|::
name|QDomNodeListPrivate
parameter_list|(
name|QDomNodePrivate
modifier|*
name|n_impl
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
block|{
name|node_impl
operator|=
name|n_impl
expr_stmt|;
if|if
condition|(
name|node_impl
condition|)
name|node_impl
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|tagname
operator|=
name|name
expr_stmt|;
name|timestamp
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomNodeListPrivate
name|QDomNodeListPrivate
operator|::
name|QDomNodeListPrivate
parameter_list|(
name|QDomNodePrivate
modifier|*
name|n_impl
parameter_list|,
specifier|const
name|QString
modifier|&
name|_nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
block|{
name|node_impl
operator|=
name|n_impl
expr_stmt|;
if|if
condition|(
name|node_impl
condition|)
name|node_impl
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|tagname
operator|=
name|localName
expr_stmt|;
name|nsURI
operator|=
name|_nsURI
expr_stmt|;
name|timestamp
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QDomNodeListPrivate
name|QDomNodeListPrivate
operator|::
name|~
name|QDomNodeListPrivate
parameter_list|()
block|{
if|if
condition|(
name|node_impl
operator|&&
operator|!
name|node_impl
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|node_impl
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|operator ==
name|bool
name|QDomNodeListPrivate
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QDomNodeListPrivate
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|node_impl
operator|==
name|other
operator|.
name|node_impl
operator|)
operator|&&
operator|(
name|tagname
operator|==
name|other
operator|.
name|tagname
operator|)
return|;
block|}
end_function
begin_function
DECL|function|operator !=
name|bool
name|QDomNodeListPrivate
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QDomNodeListPrivate
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|node_impl
operator|!=
name|other
operator|.
name|node_impl
operator|)
operator|||
operator|(
name|tagname
operator|!=
name|other
operator|.
name|tagname
operator|)
return|;
block|}
end_function
begin_function
DECL|function|createList
name|void
name|QDomNodeListPrivate
operator|::
name|createList
parameter_list|()
block|{
if|if
condition|(
operator|!
name|node_impl
condition|)
return|return;
specifier|const
name|QDomDocumentPrivate
modifier|*
specifier|const
name|doc
init|=
name|node_impl
operator|->
name|ownerDocument
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
operator|&&
name|timestamp
operator|!=
name|doc
operator|->
name|nodeListTime
condition|)
name|timestamp
operator|=
name|doc
operator|->
name|nodeListTime
expr_stmt|;
name|QDomNodePrivate
modifier|*
name|p
init|=
name|node_impl
operator|->
name|first
decl_stmt|;
name|list
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|tagname
operator|.
name|isNull
argument_list|()
condition|)
block|{
while|while
condition|(
name|p
condition|)
block|{
name|list
operator|.
name|append
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nsURI
operator|.
name|isNull
argument_list|()
condition|)
block|{
while|while
condition|(
name|p
operator|&&
name|p
operator|!=
name|node_impl
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|isElement
argument_list|()
operator|&&
name|p
operator|->
name|nodeName
argument_list|()
operator|==
name|tagname
condition|)
block|{
name|list
operator|.
name|append
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|first
condition|)
name|p
operator|=
name|p
operator|->
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|next
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
block|{
name|p
operator|=
name|p
operator|->
name|parent
argument_list|()
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|!=
name|node_impl
operator|&&
operator|!
name|p
operator|->
name|next
condition|)
name|p
operator|=
name|p
operator|->
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|!=
name|node_impl
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|p
operator|&&
name|p
operator|!=
name|node_impl
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|isElement
argument_list|()
operator|&&
name|p
operator|->
name|name
operator|==
name|tagname
operator|&&
name|p
operator|->
name|namespaceURI
operator|==
name|nsURI
condition|)
block|{
name|list
operator|.
name|append
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|first
condition|)
name|p
operator|=
name|p
operator|->
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|next
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
block|{
name|p
operator|=
name|p
operator|->
name|parent
argument_list|()
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|!=
name|node_impl
operator|&&
operator|!
name|p
operator|->
name|next
condition|)
name|p
operator|=
name|p
operator|->
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|!=
name|node_impl
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|item
name|QDomNodePrivate
modifier|*
name|QDomNodeListPrivate
operator|::
name|item
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node_impl
condition|)
return|return
literal|0
return|;
specifier|const
name|QDomDocumentPrivate
modifier|*
specifier|const
name|doc
init|=
name|node_impl
operator|->
name|ownerDocument
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|doc
operator|||
name|timestamp
operator|!=
name|doc
operator|->
name|nodeListTime
condition|)
name|createList
argument_list|()
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|list
operator|.
name|size
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|list
operator|.
name|at
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|length
name|uint
name|QDomNodeListPrivate
operator|::
name|length
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|node_impl
condition|)
return|return
literal|0
return|;
specifier|const
name|QDomDocumentPrivate
modifier|*
specifier|const
name|doc
init|=
name|node_impl
operator|->
name|ownerDocument
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|doc
operator|||
name|timestamp
operator|!=
name|doc
operator|->
name|nodeListTime
condition|)
block|{
name|QDomNodeListPrivate
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QDomNodeListPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|createList
argument_list|()
expr_stmt|;
block|}
return|return
name|list
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomNodeList  *  **************************************************************/
end_comment
begin_comment
comment|/*!     \class QDomNodeList     \reentrant     \brief The QDomNodeList class is a list of QDomNode objects.      \inmodule QtXml     \ingroup xml-tools      Lists can be obtained by QDomDocument::elementsByTagName() and     QDomNode::childNodes(). The Document Object Model (DOM) requires     these lists to be "live": whenever you change the underlying     document, the contents of the list will get updated.      You can get a particular node from the list with item(). The     number of items in the list is returned by length().      For further information about the Document Object Model see     \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and     \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.     For a more general introduction of the DOM implementation see the     QDomDocument documentation.      \sa QDomNode::childNodes() QDomDocument::elementsByTagName() */
end_comment
begin_comment
comment|/*!     Creates an empty node list. */
end_comment
begin_constructor
DECL|function|QDomNodeList
name|QDomNodeList
operator|::
name|QDomNodeList
parameter_list|()
block|{
name|impl
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomNodeList
name|QDomNodeList
operator|::
name|QDomNodeList
parameter_list|(
name|QDomNodeListPrivate
modifier|*
name|p
parameter_list|)
block|{
name|impl
operator|=
name|p
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a n. */
end_comment
begin_constructor
DECL|function|QDomNodeList
name|QDomNodeList
operator|::
name|QDomNodeList
parameter_list|(
specifier|const
name|QDomNodeList
modifier|&
name|n
parameter_list|)
block|{
name|impl
operator|=
name|n
operator|.
name|impl
expr_stmt|;
if|if
condition|(
name|impl
condition|)
name|impl
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns \a n to this node list. */
end_comment
begin_function
DECL|function|operator =
name|QDomNodeList
modifier|&
name|QDomNodeList
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomNodeList
modifier|&
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|.
name|impl
condition|)
name|n
operator|.
name|impl
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|impl
operator|&&
operator|!
name|impl
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|impl
expr_stmt|;
name|impl
operator|=
name|n
operator|.
name|impl
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node list \a n and this node list are equal;     otherwise returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QDomNodeList
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QDomNodeList
modifier|&
name|n
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|impl
operator|==
name|n
operator|.
name|impl
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|impl
operator|||
operator|!
name|n
operator|.
name|impl
condition|)
return|return
literal|false
return|;
return|return
operator|(
operator|*
name|impl
operator|==
operator|*
name|n
operator|.
name|impl
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true the node list \a n and this node list are not equal;     otherwise returns false. */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QDomNodeList
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QDomNodeList
modifier|&
name|n
parameter_list|)
specifier|const
block|{
return|return
operator|!
name|operator
name|==
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the object and frees its resources. */
end_comment
begin_destructor
DECL|function|~QDomNodeList
name|QDomNodeList
operator|::
name|~
name|QDomNodeList
parameter_list|()
block|{
if|if
condition|(
name|impl
operator|&&
operator|!
name|impl
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|impl
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns the node at position \a index.      If \a index is negative or if \a index>= length() then a null     node is returned (i.e. a node for which QDomNode::isNull() returns     true).      \sa length() */
end_comment
begin_function
DECL|function|item
name|QDomNode
name|QDomNodeList
operator|::
name|item
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|impl
operator|->
name|item
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of nodes in the list. */
end_comment
begin_function
DECL|function|length
name|uint
name|QDomNodeList
operator|::
name|length
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
literal|0
return|;
return|return
name|impl
operator|->
name|length
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QDomNodeList::isEmpty() const      Returns true if the list contains no items; otherwise returns false.     This function is provided for Qt API consistency. */
end_comment
begin_comment
comment|/*!     \fn int QDomNodeList::count() const      This function is provided for Qt API consistency. It is equivalent to length(). */
end_comment
begin_comment
comment|/*!     \fn int QDomNodeList::size() const      This function is provided for Qt API consistency. It is equivalent to length(). */
end_comment
begin_comment
comment|/*!     \fn QDomNode QDomNodeList::at(int index) const      This function is provided for Qt API consistency. It is equivalent     to item().      If \a index is negative or if \a index>= length() then a null     node is returned (i.e. a node for which QDomNode::isNull() returns     true). */
end_comment
begin_comment
comment|/**************************************************************  *  * QDomNodePrivate  *  **************************************************************/
end_comment
begin_function
DECL|function|setOwnerDocument
specifier|inline
name|void
name|QDomNodePrivate
operator|::
name|setOwnerDocument
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|doc
parameter_list|)
block|{
name|ownerNode
operator|=
name|doc
expr_stmt|;
name|hasParent
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QDomNodePrivate
name|QDomNodePrivate
operator|::
name|QDomNodePrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|doc
parameter_list|,
name|QDomNodePrivate
modifier|*
name|par
parameter_list|)
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
block|{
if|if
condition|(
name|par
condition|)
name|setParent
argument_list|(
name|par
argument_list|)
expr_stmt|;
else|else
name|setOwnerDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|prev
operator|=
literal|0
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
name|createdWithDom1Interface
operator|=
literal|true
expr_stmt|;
name|lineNumber
operator|=
operator|-
literal|1
expr_stmt|;
name|columnNumber
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomNodePrivate
name|QDomNodePrivate
operator|::
name|QDomNodePrivate
parameter_list|(
name|QDomNodePrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
block|{
name|setOwnerDocument
argument_list|(
name|n
operator|->
name|ownerDocument
argument_list|()
argument_list|)
expr_stmt|;
name|prev
operator|=
literal|0
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|n
operator|->
name|name
expr_stmt|;
name|value
operator|=
name|n
operator|->
name|value
expr_stmt|;
name|prefix
operator|=
name|n
operator|->
name|prefix
expr_stmt|;
name|namespaceURI
operator|=
name|n
operator|->
name|namespaceURI
expr_stmt|;
name|createdWithDom1Interface
operator|=
name|n
operator|->
name|createdWithDom1Interface
expr_stmt|;
name|lineNumber
operator|=
operator|-
literal|1
expr_stmt|;
name|columnNumber
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|deep
condition|)
return|return;
for|for
control|(
name|QDomNodePrivate
modifier|*
name|x
init|=
name|n
operator|->
name|first
init|;
name|x
condition|;
name|x
operator|=
name|x
operator|->
name|next
control|)
name|appendChild
argument_list|(
name|x
operator|->
name|cloneNode
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QDomNodePrivate
name|QDomNodePrivate
operator|::
name|~
name|QDomNodePrivate
parameter_list|()
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
name|first
decl_stmt|;
name|QDomNodePrivate
modifier|*
name|n
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|n
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|p
expr_stmt|;
else|else
name|p
operator|->
name|setNoParent
argument_list|()
expr_stmt|;
name|p
operator|=
name|n
expr_stmt|;
block|}
name|first
operator|=
literal|0
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|clear
name|void
name|QDomNodePrivate
operator|::
name|clear
parameter_list|()
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
name|first
decl_stmt|;
name|QDomNodePrivate
modifier|*
name|n
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|n
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|p
expr_stmt|;
name|p
operator|=
name|n
expr_stmt|;
block|}
name|first
operator|=
literal|0
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|namedItem
name|QDomNodePrivate
modifier|*
name|QDomNodePrivate
operator|::
name|namedItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|n
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
name|first
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|nodeName
argument_list|()
operator|==
name|n
condition|)
return|return
name|p
return|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|insertBefore
name|QDomNodePrivate
modifier|*
name|QDomNodePrivate
operator|::
name|insertBefore
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|,
name|QDomNodePrivate
modifier|*
name|refChild
parameter_list|)
block|{
comment|// Error check
if|if
condition|(
operator|!
name|newChild
condition|)
return|return
literal|0
return|;
comment|// Error check
if|if
condition|(
name|newChild
operator|==
name|refChild
condition|)
return|return
literal|0
return|;
comment|// Error check
if|if
condition|(
name|refChild
operator|&&
name|refChild
operator|->
name|parent
argument_list|()
operator|!=
name|this
condition|)
return|return
literal|0
return|;
comment|// "mark lists as dirty"
name|QDomDocumentPrivate
modifier|*
specifier|const
name|doc
init|=
name|ownerDocument
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
condition|)
name|doc
operator|->
name|nodeListTime
operator|++
expr_stmt|;
comment|// Special handling for inserting a fragment. We just insert
comment|// all elements of the fragment instead of the fragment itself.
if|if
condition|(
name|newChild
operator|->
name|isDocumentFragment
argument_list|()
condition|)
block|{
comment|// Fragment is empty ?
if|if
condition|(
name|newChild
operator|->
name|first
operator|==
literal|0
condition|)
return|return
name|newChild
return|;
comment|// New parent
name|QDomNodePrivate
modifier|*
name|n
init|=
name|newChild
operator|->
name|first
decl_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
comment|// Insert at the beginning ?
if|if
condition|(
operator|!
name|refChild
operator|||
name|refChild
operator|->
name|prev
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|->
name|prev
operator|=
name|newChild
operator|->
name|last
expr_stmt|;
name|newChild
operator|->
name|last
operator|->
name|next
operator|=
name|first
expr_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
name|last
operator|=
name|newChild
operator|->
name|last
expr_stmt|;
name|first
operator|=
name|newChild
operator|->
name|first
expr_stmt|;
block|}
else|else
block|{
comment|// Insert in the middle
name|newChild
operator|->
name|last
operator|->
name|next
operator|=
name|refChild
expr_stmt|;
name|newChild
operator|->
name|first
operator|->
name|prev
operator|=
name|refChild
operator|->
name|prev
expr_stmt|;
name|refChild
operator|->
name|prev
operator|->
name|next
operator|=
name|newChild
operator|->
name|first
expr_stmt|;
name|refChild
operator|->
name|prev
operator|=
name|newChild
operator|->
name|last
expr_stmt|;
block|}
comment|// No need to increase the reference since QDomDocumentFragment
comment|// does not decrease the reference.
comment|// Remove the nodes from the fragment
name|newChild
operator|->
name|first
operator|=
literal|0
expr_stmt|;
name|newChild
operator|->
name|last
operator|=
literal|0
expr_stmt|;
return|return
name|newChild
return|;
block|}
comment|// No more errors can occur now, so we take
comment|// ownership of the node.
name|newChild
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|newChild
operator|->
name|parent
argument_list|()
condition|)
name|newChild
operator|->
name|parent
argument_list|()
operator|->
name|removeChild
argument_list|(
name|newChild
argument_list|)
expr_stmt|;
name|newChild
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refChild
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|->
name|prev
operator|=
name|newChild
expr_stmt|;
name|newChild
operator|->
name|next
operator|=
name|first
expr_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
name|last
operator|=
name|newChild
expr_stmt|;
name|first
operator|=
name|newChild
expr_stmt|;
return|return
name|newChild
return|;
block|}
if|if
condition|(
name|refChild
operator|->
name|prev
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|->
name|prev
operator|=
name|newChild
expr_stmt|;
name|newChild
operator|->
name|next
operator|=
name|first
expr_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
name|last
operator|=
name|newChild
expr_stmt|;
name|first
operator|=
name|newChild
expr_stmt|;
return|return
name|newChild
return|;
block|}
name|newChild
operator|->
name|next
operator|=
name|refChild
expr_stmt|;
name|newChild
operator|->
name|prev
operator|=
name|refChild
operator|->
name|prev
expr_stmt|;
name|refChild
operator|->
name|prev
operator|->
name|next
operator|=
name|newChild
expr_stmt|;
name|refChild
operator|->
name|prev
operator|=
name|newChild
expr_stmt|;
return|return
name|newChild
return|;
block|}
end_function
begin_function
DECL|function|insertAfter
name|QDomNodePrivate
modifier|*
name|QDomNodePrivate
operator|::
name|insertAfter
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|,
name|QDomNodePrivate
modifier|*
name|refChild
parameter_list|)
block|{
comment|// Error check
if|if
condition|(
operator|!
name|newChild
condition|)
return|return
literal|0
return|;
comment|// Error check
if|if
condition|(
name|newChild
operator|==
name|refChild
condition|)
return|return
literal|0
return|;
comment|// Error check
if|if
condition|(
name|refChild
operator|&&
name|refChild
operator|->
name|parent
argument_list|()
operator|!=
name|this
condition|)
return|return
literal|0
return|;
comment|// "mark lists as dirty"
name|QDomDocumentPrivate
modifier|*
specifier|const
name|doc
init|=
name|ownerDocument
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
condition|)
name|doc
operator|->
name|nodeListTime
operator|++
expr_stmt|;
comment|// Special handling for inserting a fragment. We just insert
comment|// all elements of the fragment instead of the fragment itself.
if|if
condition|(
name|newChild
operator|->
name|isDocumentFragment
argument_list|()
condition|)
block|{
comment|// Fragment is empty ?
if|if
condition|(
name|newChild
operator|->
name|first
operator|==
literal|0
condition|)
return|return
name|newChild
return|;
comment|// New parent
name|QDomNodePrivate
modifier|*
name|n
init|=
name|newChild
operator|->
name|first
decl_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
comment|// Insert at the end
if|if
condition|(
operator|!
name|refChild
operator|||
name|refChild
operator|->
name|next
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|last
condition|)
name|last
operator|->
name|next
operator|=
name|newChild
operator|->
name|first
expr_stmt|;
name|newChild
operator|->
name|first
operator|->
name|prev
operator|=
name|last
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
name|first
operator|=
name|newChild
operator|->
name|first
expr_stmt|;
name|last
operator|=
name|newChild
operator|->
name|last
expr_stmt|;
block|}
else|else
block|{
comment|// Insert in the middle
name|newChild
operator|->
name|first
operator|->
name|prev
operator|=
name|refChild
expr_stmt|;
name|newChild
operator|->
name|last
operator|->
name|next
operator|=
name|refChild
operator|->
name|next
expr_stmt|;
name|refChild
operator|->
name|next
operator|->
name|prev
operator|=
name|newChild
operator|->
name|last
expr_stmt|;
name|refChild
operator|->
name|next
operator|=
name|newChild
operator|->
name|first
expr_stmt|;
block|}
comment|// No need to increase the reference since QDomDocumentFragment
comment|// does not decrease the reference.
comment|// Remove the nodes from the fragment
name|newChild
operator|->
name|first
operator|=
literal|0
expr_stmt|;
name|newChild
operator|->
name|last
operator|=
literal|0
expr_stmt|;
return|return
name|newChild
return|;
block|}
comment|// Release new node from its current parent
if|if
condition|(
name|newChild
operator|->
name|parent
argument_list|()
condition|)
name|newChild
operator|->
name|parent
argument_list|()
operator|->
name|removeChild
argument_list|(
name|newChild
argument_list|)
expr_stmt|;
comment|// No more errors can occur now, so we take
comment|// ownership of the node
name|newChild
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|newChild
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Insert at the end
if|if
condition|(
operator|!
name|refChild
condition|)
block|{
if|if
condition|(
name|last
condition|)
name|last
operator|->
name|next
operator|=
name|newChild
expr_stmt|;
name|newChild
operator|->
name|prev
operator|=
name|last
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
name|first
operator|=
name|newChild
expr_stmt|;
name|last
operator|=
name|newChild
expr_stmt|;
return|return
name|newChild
return|;
block|}
if|if
condition|(
name|refChild
operator|->
name|next
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|last
condition|)
name|last
operator|->
name|next
operator|=
name|newChild
expr_stmt|;
name|newChild
operator|->
name|prev
operator|=
name|last
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
name|first
operator|=
name|newChild
expr_stmt|;
name|last
operator|=
name|newChild
expr_stmt|;
return|return
name|newChild
return|;
block|}
name|newChild
operator|->
name|prev
operator|=
name|refChild
expr_stmt|;
name|newChild
operator|->
name|next
operator|=
name|refChild
operator|->
name|next
expr_stmt|;
name|refChild
operator|->
name|next
operator|->
name|prev
operator|=
name|newChild
expr_stmt|;
name|refChild
operator|->
name|next
operator|=
name|newChild
expr_stmt|;
return|return
name|newChild
return|;
block|}
end_function
begin_function
DECL|function|replaceChild
name|QDomNodePrivate
modifier|*
name|QDomNodePrivate
operator|::
name|replaceChild
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|,
name|QDomNodePrivate
modifier|*
name|oldChild
parameter_list|)
block|{
if|if
condition|(
operator|!
name|newChild
operator|||
operator|!
name|oldChild
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|oldChild
operator|->
name|parent
argument_list|()
operator|!=
name|this
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|newChild
operator|==
name|oldChild
condition|)
return|return
literal|0
return|;
comment|// mark lists as dirty
name|QDomDocumentPrivate
modifier|*
specifier|const
name|doc
init|=
name|ownerDocument
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
condition|)
name|doc
operator|->
name|nodeListTime
operator|++
expr_stmt|;
comment|// Special handling for inserting a fragment. We just insert
comment|// all elements of the fragment instead of the fragment itself.
if|if
condition|(
name|newChild
operator|->
name|isDocumentFragment
argument_list|()
condition|)
block|{
comment|// Fragment is empty ?
if|if
condition|(
name|newChild
operator|->
name|first
operator|==
literal|0
condition|)
return|return
name|newChild
return|;
comment|// New parent
name|QDomNodePrivate
modifier|*
name|n
init|=
name|newChild
operator|->
name|first
decl_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|oldChild
operator|->
name|next
condition|)
name|oldChild
operator|->
name|next
operator|->
name|prev
operator|=
name|newChild
operator|->
name|last
expr_stmt|;
if|if
condition|(
name|oldChild
operator|->
name|prev
condition|)
name|oldChild
operator|->
name|prev
operator|->
name|next
operator|=
name|newChild
operator|->
name|first
expr_stmt|;
name|newChild
operator|->
name|last
operator|->
name|next
operator|=
name|oldChild
operator|->
name|next
expr_stmt|;
name|newChild
operator|->
name|first
operator|->
name|prev
operator|=
name|oldChild
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|oldChild
condition|)
name|first
operator|=
name|newChild
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|oldChild
condition|)
name|last
operator|=
name|newChild
operator|->
name|last
expr_stmt|;
name|oldChild
operator|->
name|setNoParent
argument_list|()
expr_stmt|;
name|oldChild
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|oldChild
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
comment|// No need to increase the reference since QDomDocumentFragment
comment|// does not decrease the reference.
comment|// Remove the nodes from the fragment
name|newChild
operator|->
name|first
operator|=
literal|0
expr_stmt|;
name|newChild
operator|->
name|last
operator|=
literal|0
expr_stmt|;
comment|// We are no longer interested in the old node
if|if
condition|(
name|oldChild
condition|)
name|oldChild
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|oldChild
return|;
block|}
comment|// No more errors can occur now, so we take
comment|// ownership of the node
name|newChild
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
comment|// Release new node from its current parent
if|if
condition|(
name|newChild
operator|->
name|parent
argument_list|()
condition|)
name|newChild
operator|->
name|parent
argument_list|()
operator|->
name|removeChild
argument_list|(
name|newChild
argument_list|)
expr_stmt|;
name|newChild
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldChild
operator|->
name|next
condition|)
name|oldChild
operator|->
name|next
operator|->
name|prev
operator|=
name|newChild
expr_stmt|;
if|if
condition|(
name|oldChild
operator|->
name|prev
condition|)
name|oldChild
operator|->
name|prev
operator|->
name|next
operator|=
name|newChild
expr_stmt|;
name|newChild
operator|->
name|next
operator|=
name|oldChild
operator|->
name|next
expr_stmt|;
name|newChild
operator|->
name|prev
operator|=
name|oldChild
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|oldChild
condition|)
name|first
operator|=
name|newChild
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|oldChild
condition|)
name|last
operator|=
name|newChild
expr_stmt|;
name|oldChild
operator|->
name|setNoParent
argument_list|()
expr_stmt|;
name|oldChild
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|oldChild
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
comment|// We are no longer interested in the old node
if|if
condition|(
name|oldChild
condition|)
name|oldChild
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|oldChild
return|;
block|}
end_function
begin_function
DECL|function|removeChild
name|QDomNodePrivate
modifier|*
name|QDomNodePrivate
operator|::
name|removeChild
parameter_list|(
name|QDomNodePrivate
modifier|*
name|oldChild
parameter_list|)
block|{
comment|// Error check
if|if
condition|(
name|oldChild
operator|->
name|parent
argument_list|()
operator|!=
name|this
condition|)
return|return
literal|0
return|;
comment|// "mark lists as dirty"
name|QDomDocumentPrivate
modifier|*
specifier|const
name|doc
init|=
name|ownerDocument
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
condition|)
name|doc
operator|->
name|nodeListTime
operator|++
expr_stmt|;
comment|// Perhaps oldChild was just created with "createElement" or that. In this case
comment|// its parent is QDomDocument but it is not part of the documents child list.
if|if
condition|(
name|oldChild
operator|->
name|next
operator|==
literal|0
operator|&&
name|oldChild
operator|->
name|prev
operator|==
literal|0
operator|&&
name|first
operator|!=
name|oldChild
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|oldChild
operator|->
name|next
condition|)
name|oldChild
operator|->
name|next
operator|->
name|prev
operator|=
name|oldChild
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|oldChild
operator|->
name|prev
condition|)
name|oldChild
operator|->
name|prev
operator|->
name|next
operator|=
name|oldChild
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|oldChild
condition|)
name|last
operator|=
name|oldChild
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|oldChild
condition|)
name|first
operator|=
name|oldChild
operator|->
name|next
expr_stmt|;
name|oldChild
operator|->
name|setNoParent
argument_list|()
expr_stmt|;
name|oldChild
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|oldChild
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
comment|// We are no longer interested in the old node
name|oldChild
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|oldChild
return|;
block|}
end_function
begin_function
DECL|function|appendChild
name|QDomNodePrivate
modifier|*
name|QDomNodePrivate
operator|::
name|appendChild
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|)
block|{
comment|// No reference manipulation needed. Done in insertAfter.
return|return
name|insertAfter
argument_list|(
name|newChild
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ownerDocument
name|QDomDocumentPrivate
modifier|*
name|QDomNodePrivate
operator|::
name|ownerDocument
parameter_list|()
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
name|this
decl_stmt|;
while|while
condition|(
name|p
operator|&&
operator|!
name|p
operator|->
name|isDocument
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|hasParent
condition|)
return|return
operator|(
name|QDomDocumentPrivate
operator|*
operator|)
name|p
operator|->
name|ownerNode
return|;
name|p
operator|=
name|p
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
return|return
cast|static_cast
argument_list|<
name|QDomDocumentPrivate
operator|*
argument_list|>
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|cloneNode
name|QDomNodePrivate
modifier|*
name|QDomNodePrivate
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
operator|new
name|QDomNodePrivate
argument_list|(
name|this
argument_list|,
name|deep
argument_list|)
decl_stmt|;
comment|// We are not interested in this node
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|qNormalizeNode
specifier|static
name|void
name|qNormalizeNode
parameter_list|(
name|QDomNodePrivate
modifier|*
name|n
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
name|n
operator|->
name|first
decl_stmt|;
name|QDomTextPrivate
modifier|*
name|t
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|isText
argument_list|()
condition|)
block|{
if|if
condition|(
name|t
condition|)
block|{
name|QDomNodePrivate
modifier|*
name|tmp
init|=
name|p
operator|->
name|next
decl_stmt|;
name|t
operator|->
name|appendData
argument_list|(
name|p
operator|->
name|nodeValue
argument_list|()
argument_list|)
expr_stmt|;
name|n
operator|->
name|removeChild
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
operator|(
name|QDomTextPrivate
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|normalize
name|void
name|QDomNodePrivate
operator|::
name|normalize
parameter_list|()
block|{
comment|// ### This one has moved from QDomElementPrivate to this position. It is
comment|// not tested.
name|qNormalizeNode
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal   \a depth is used for indentation, it seems.  */
end_comment
begin_function
DECL|function|save
name|void
name|QDomNodePrivate
operator|::
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|indent
parameter_list|)
specifier|const
block|{
specifier|const
name|QDomNodePrivate
modifier|*
name|n
init|=
name|first
decl_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|save
argument_list|(
name|s
argument_list|,
name|depth
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setLocation
name|void
name|QDomNodePrivate
operator|::
name|setLocation
parameter_list|(
name|int
name|lineNumber
parameter_list|,
name|int
name|columnNumber
parameter_list|)
block|{
name|this
operator|->
name|lineNumber
operator|=
name|lineNumber
expr_stmt|;
name|this
operator|->
name|columnNumber
operator|=
name|columnNumber
expr_stmt|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomNode  *  **************************************************************/
end_comment
begin_define
DECL|macro|IMPL
define|#
directive|define
name|IMPL
value|((QDomNodePrivate*)impl)
end_define
begin_comment
comment|/*!     \class QDomNode     \reentrant     \brief The QDomNode class is the base class for all the nodes in a DOM tree.      \inmodule QtXml     \ingroup xml-tools       Many functions in the DOM return a QDomNode.      You can find out the type of a node using isAttr(),     isCDATASection(), isDocumentFragment(), isDocument(),     isDocumentType(), isElement(), isEntityReference(), isText(),     isEntity(), isNotation(), isProcessingInstruction(),     isCharacterData() and isComment().      A QDomNode can be converted into one of its subclasses using     toAttr(), toCDATASection(), toDocumentFragment(), toDocument(),     toDocumentType(), toElement(), toEntityReference(), toText(),     toEntity(), toNotation(), toProcessingInstruction(),     toCharacterData() or toComment(). You can convert a node to a null     node with clear().      Copies of the QDomNode class share their data using explicit     sharing. This means that modifying one node will change all     copies. This is especially useful in combination with functions     which return a QDomNode, e.g. firstChild(). You can make an     independent (deep) copy of the node with cloneNode().      A QDomNode can be null, much like a null pointer. Creating a copy     of a null node results in another null node. It is not     possible to modify a null node, but it is possible to assign another,     possibly non-null node to it. In this case, the copy of the null node     will remain null. You can check if a QDomNode is null by calling isNull().     The empty constructor of a QDomNode (or any of the derived classes) creates     a null node.      Nodes are inserted with insertBefore(), insertAfter() or     appendChild(). You can replace one node with another using     replaceChild() and remove a node with removeChild().      To traverse nodes use firstChild() to get a node's first child (if     any), and nextSibling() to traverse. QDomNode also provides     lastChild(), previousSibling() and parentNode(). To find the first     child node with a particular node name use namedItem().      To find out if a node has children use hasChildNodes() and to get     a list of all of a node's children use childNodes().      The node's name and value (the meaning of which varies depending     on its type) is returned by nodeName() and nodeValue()     respectively. The node's type is returned by nodeType(). The     node's value can be set with setNodeValue().      The document to which the node belongs is returned by     ownerDocument().      Adjacent QDomText nodes can be merged into a single node with     normalize().      \l QDomElement nodes have attributes which can be retrieved with     attributes().      QDomElement and QDomAttr nodes can have namespaces which can be     retrieved with namespaceURI(). Their local name is retrieved with     localName(), and their prefix with prefix(). The prefix can be set     with setPrefix().      You can write the XML representation of the node to a text stream     with save().      The following example looks for the first element in an XML document and     prints the names of all the elements that are its direct children.     \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 1      For further information about the Document Object Model see     \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and     \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.     For a more general introduction of the DOM implementation see the     QDomDocument documentation. */
end_comment
begin_comment
comment|/*!     Constructs a \link isNull() null\endlink node. */
end_comment
begin_constructor
DECL|function|QDomNode
name|QDomNode
operator|::
name|QDomNode
parameter_list|()
block|{
name|impl
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a n.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_constructor
DECL|function|QDomNode
name|QDomNode
operator|::
name|QDomNode
parameter_list|(
specifier|const
name|QDomNode
modifier|&
name|n
parameter_list|)
block|{
name|impl
operator|=
name|n
operator|.
name|impl
expr_stmt|;
if|if
condition|(
name|impl
condition|)
name|impl
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!  \internal   Constructs a new node for the data \a n. */
end_comment
begin_constructor
DECL|function|QDomNode
name|QDomNode
operator|::
name|QDomNode
parameter_list|(
name|QDomNodePrivate
modifier|*
name|n
parameter_list|)
block|{
name|impl
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|impl
condition|)
name|impl
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns a copy of \a n to this DOM node.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_function
DECL|function|operator =
name|QDomNode
modifier|&
name|QDomNode
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomNode
modifier|&
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|.
name|impl
condition|)
name|n
operator|.
name|impl
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|impl
operator|&&
operator|!
name|impl
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|impl
expr_stmt|;
name|impl
operator|=
name|n
operator|.
name|impl
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if \a n and this DOM node are equal; otherwise     returns false.      Any instance of QDomNode acts as a reference to an underlying data     structure in QDomDocument. The test for equality checks if the two     references point to the same underlying node. For example:      \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 2      The two nodes (QDomElement is a QDomNode subclass) both refer to     the document's root element, and \c {element1 == element2} will     return true. On the other hand:      \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 3      Even though both nodes are empty elements carrying the same name,     \c {element3 == element4} will return false because they refer to     two different nodes in the underlying data structure. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QDomNode
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QDomNode
modifier|&
name|n
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|impl
operator|==
name|n
operator|.
name|impl
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if \a n and this DOM node are not equal; otherwise     returns false. */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QDomNode
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QDomNode
modifier|&
name|n
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|impl
operator|!=
name|n
operator|.
name|impl
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the object and frees its resources. */
end_comment
begin_destructor
DECL|function|~QDomNode
name|QDomNode
operator|::
name|~
name|QDomNode
parameter_list|()
block|{
if|if
condition|(
name|impl
operator|&&
operator|!
name|impl
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|impl
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns the name of the node.      The meaning of the name depends on the subclass:      \table     \header \i Name \i Meaning     \row \i QDomAttr \i The name of the attribute     \row \i QDomCDATASection \i The string "#cdata-section"     \row \i QDomComment \i The string "#comment"     \row \i QDomDocument \i The string "#document"     \row \i QDomDocumentFragment \i The string "#document-fragment"     \row \i QDomDocumentType \i The name of the document type     \row \i QDomElement \i The tag name     \row \i QDomEntity \i The name of the entity     \row \i QDomEntityReference \i The name of the referenced entity     \row \i QDomNotation \i The name of the notation     \row \i QDomProcessingInstruction \i The target of the processing instruction     \row \i QDomText \i The string "#text"     \endtable      \bold{Note:} This function does not take the presence of namespaces into account     when processing the names of element and attribute nodes. As a result, the     returned name can contain any namespace prefix that may be present.     To obtain the node name of an element or attribute, use localName(); to     obtain the namespace prefix, use namespaceURI().      \sa nodeValue() */
end_comment
begin_function
DECL|function|nodeName
name|QString
name|QDomNode
operator|::
name|nodeName
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|IMPL
operator|->
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|IMPL
operator|->
name|prefix
operator|+
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|+
name|IMPL
operator|->
name|name
return|;
return|return
name|IMPL
operator|->
name|name
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the value of the node.      The meaning of the value depends on the subclass:     \table     \header \i Name \i Meaning     \row \i QDomAttr \i The attribute value     \row \i QDomCDATASection \i The content of the CDATA section     \row \i QDomComment \i The comment     \row \i QDomProcessingInstruction \i The data of the processing instruction     \row \i QDomText \i The text     \endtable      All the other subclasses do not have a node value and will return     an empty string.      \sa setNodeValue() nodeName() */
end_comment
begin_function
DECL|function|nodeValue
name|QString
name|QDomNode
operator|::
name|nodeValue
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|value
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the node's value to \a v.      \sa nodeValue() */
end_comment
begin_function
DECL|function|setNodeValue
name|void
name|QDomNode
operator|::
name|setNodeValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|v
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|IMPL
operator|->
name|setNodeValue
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \enum QDomNode::NodeType      This enum defines the type of the node:     \value ElementNode     \value AttributeNode     \value TextNode     \value CDATASectionNode     \value EntityReferenceNode     \value EntityNode     \value ProcessingInstructionNode     \value CommentNode     \value DocumentNode     \value DocumentTypeNode     \value DocumentFragmentNode     \value NotationNode     \value BaseNode  A QDomNode object, i.e. not a QDomNode subclass.     \value CharacterDataNode */
end_comment
begin_comment
comment|/*!     Returns the type of the node.      \sa toAttr(), toCDATASection(), toDocumentFragment(),     toDocument() toDocumentType(), toElement(), toEntityReference(),     toText(), toEntity() toNotation(), toProcessingInstruction(),     toCharacterData(), toComment() */
end_comment
begin_function
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|QDomNode
operator|::
name|nodeType
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
operator|::
name|BaseNode
return|;
return|return
name|IMPL
operator|->
name|nodeType
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the parent node. If this node has no parent, a null node     is returned (i.e. a node for which isNull() returns true). */
end_comment
begin_function
DECL|function|parentNode
name|QDomNode
name|QDomNode
operator|::
name|parentNode
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|parent
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all direct child nodes.      Most often you will call this function on a QDomElement object.      For example, if the XML document looks like this:     \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 4     Then the list of child nodes for the "body"-element will contain     the node created by the&lt;h1&gt; tag and the node created by the&lt;p&gt; tag.      The nodes in the list are not copied; so changing the nodes in the     list will also change the children of this node.      \sa firstChild() lastChild() */
end_comment
begin_function
DECL|function|childNodes
name|QDomNodeList
name|QDomNode
operator|::
name|childNodes
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNodeList
argument_list|()
return|;
return|return
name|QDomNodeList
argument_list|(
operator|new
name|QDomNodeListPrivate
argument_list|(
name|impl
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the first child of the node. If there is no child node, a     \link isNull() null node\endlink is returned. Changing the     returned node will also change the node in the document tree.      \sa lastChild() childNodes() */
end_comment
begin_function
DECL|function|firstChild
name|QDomNode
name|QDomNode
operator|::
name|firstChild
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|first
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the last child of the node. If there is no child node, a     \link isNull() null node\endlink is returned. Changing the     returned node will also change the node in the document tree.      \sa firstChild() childNodes() */
end_comment
begin_function
DECL|function|lastChild
name|QDomNode
name|QDomNode
operator|::
name|lastChild
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|last
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the previous sibling in the document tree. Changing the     returned node will also change the node in the document tree.      For example, if you have XML like this:     \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 5     and this QDomNode represents the&lt;p&gt; tag, previousSibling()     will return the node representing the&lt;h1&gt; tag.      \sa nextSibling() */
end_comment
begin_function
DECL|function|previousSibling
name|QDomNode
name|QDomNode
operator|::
name|previousSibling
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|prev
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the next sibling in the document tree. Changing the     returned node will also change the node in the document tree.      If you have XML like this:     \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 6     and this QDomNode represents the<p> tag, nextSibling() will     return the node representing the<h2> tag.      \sa previousSibling() */
end_comment
begin_function
DECL|function|nextSibling
name|QDomNode
name|QDomNode
operator|::
name|nextSibling
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|next
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// ###### don't think this is part of the DOM and
end_comment
begin_comment
comment|/*!     Returns a named node map of all attributes. Attributes are only     provided for \l{QDomElement}s.      Changing the attributes in the map will also change the attributes     of this QDomNode. */
end_comment
begin_function
DECL|function|attributes
name|QDomNamedNodeMap
name|QDomNode
operator|::
name|attributes
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
operator|||
operator|!
name|impl
operator|->
name|isElement
argument_list|()
condition|)
return|return
name|QDomNamedNodeMap
argument_list|()
return|;
return|return
name|QDomNamedNodeMap
argument_list|(
cast|static_cast
argument_list|<
name|QDomElementPrivate
operator|*
argument_list|>
argument_list|(
name|impl
argument_list|)
operator|->
name|attributes
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the document to which this node belongs. */
end_comment
begin_function
DECL|function|ownerDocument
name|QDomDocument
name|QDomNode
operator|::
name|ownerDocument
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomDocument
argument_list|()
return|;
return|return
name|QDomDocument
argument_list|(
name|IMPL
operator|->
name|ownerDocument
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a deep (not shallow) copy of the QDomNode.      If \a deep is true, then the cloning is done recursively which     means that all the node's children are deep copied too. If \a deep     is false only the node itself is copied and the copy will have no     child nodes. */
end_comment
begin_function
DECL|function|cloneNode
name|QDomNode
name|QDomNode
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|cloneNode
argument_list|(
name|deep
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Calling normalize() on an element converts all its children into a     standard form. This means that adjacent QDomText objects will be     merged into a single text object (QDomCDATASection nodes are not     merged). */
end_comment
begin_function
DECL|function|normalize
name|void
name|QDomNode
operator|::
name|normalize
parameter_list|()
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|IMPL
operator|->
name|normalize
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the DOM implementation implements the feature \a     feature and this feature is supported by this node in the version     \a version; otherwise returns false.      \sa QDomImplementation::hasFeature() */
end_comment
begin_function
DECL|function|isSupported
name|bool
name|QDomNode
operator|::
name|isSupported
parameter_list|(
specifier|const
name|QString
modifier|&
name|feature
parameter_list|,
specifier|const
name|QString
modifier|&
name|version
parameter_list|)
specifier|const
block|{
name|QDomImplementation
name|i
decl_stmt|;
return|return
name|i
operator|.
name|hasFeature
argument_list|(
name|feature
argument_list|,
name|version
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the namespace URI of this node or an empty string if the     node has no namespace URI.      Only nodes of type \link QDomNode::NodeType ElementNode\endlink or     \link QDomNode::NodeType AttributeNode\endlink can have     namespaces. A namespace URI must be specified at creation time and     cannot be changed later.      \sa prefix() localName() QDomDocument::createElementNS()     QDomDocument::createAttributeNS() */
end_comment
begin_function
DECL|function|namespaceURI
name|QString
name|QDomNode
operator|::
name|namespaceURI
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|namespaceURI
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the namespace prefix of the node or an empty string if the     node has no namespace prefix.      Only nodes of type \link QDomNode::NodeType ElementNode\endlink or     \link QDomNode::NodeType AttributeNode\endlink can have     namespaces. A namespace prefix must be specified at creation time.     If a node was created with a namespace prefix, you can change it     later with setPrefix().      If you create an element or attribute with     QDomDocument::createElement() or QDomDocument::createAttribute(),     the prefix will be an empty string. If you use     QDomDocument::createElementNS() or     QDomDocument::createAttributeNS() instead, the prefix will not be     an empty string; but it might be an empty string if the name does     not have a prefix.      \sa setPrefix() localName() namespaceURI()     QDomDocument::createElementNS() QDomDocument::createAttributeNS() */
end_comment
begin_function
DECL|function|prefix
name|QString
name|QDomNode
operator|::
name|prefix
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|prefix
return|;
block|}
end_function
begin_comment
comment|/*!     If the node has a namespace prefix, this function changes the     namespace prefix of the node to \a pre. Otherwise this function     does nothing.      Only nodes of type \link QDomNode::NodeType ElementNode\endlink or     \link QDomNode::NodeType AttributeNode\endlink can have     namespaces. A namespace prefix must have be specified at creation     time; it is not possible to add a namespace prefix afterwards.      \sa prefix() localName() namespaceURI()     QDomDocument::createElementNS() QDomDocument::createAttributeNS() */
end_comment
begin_function
DECL|function|setPrefix
name|void
name|QDomNode
operator|::
name|setPrefix
parameter_list|(
specifier|const
name|QString
modifier|&
name|pre
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
operator|||
name|IMPL
operator|->
name|prefix
operator|.
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
name|isAttr
argument_list|()
operator|||
name|isElement
argument_list|()
condition|)
name|IMPL
operator|->
name|prefix
operator|=
name|pre
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If the node uses namespaces, this function returns the local name     of the node; otherwise it returns an empty string.      Only nodes of type \link QDomNode::NodeType ElementNode\endlink or     \link QDomNode::NodeType AttributeNode\endlink can have     namespaces. A namespace must have been specified at creation time;     it is not possible to add a namespace afterwards.      \sa prefix() namespaceURI() QDomDocument::createElementNS()     QDomDocument::createAttributeNS() */
end_comment
begin_function
DECL|function|localName
name|QString
name|QDomNode
operator|::
name|localName
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
operator|||
name|IMPL
operator|->
name|createdWithDom1Interface
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|name
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node has attributes; otherwise returns false.      \sa attributes() */
end_comment
begin_function
DECL|function|hasAttributes
name|bool
name|QDomNode
operator|::
name|hasAttributes
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
operator|||
operator|!
name|impl
operator|->
name|isElement
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
cast|static_cast
argument_list|<
name|QDomElementPrivate
operator|*
argument_list|>
argument_list|(
name|impl
argument_list|)
operator|->
name|hasAttributes
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts the node \a newChild before the child node \a refChild.     \a refChild must be a direct child of this node. If \a refChild is     \link isNull() null\endlink then \a newChild is inserted as the     node's first child.      If \a newChild is the child of another node, it is reparented to     this node. If \a newChild is a child of this node, then its     position in the list of children is changed.      If \a newChild is a QDomDocumentFragment, then the children of the     fragment are removed from the fragment and inserted before \a     refChild.      Returns a new reference to \a newChild on success or a \link     isNull() null node\endlink on failure.      The DOM specification disallow inserting attribute nodes, but due     to historical reasons QDom accept them nevertheless.      \sa insertAfter() replaceChild() removeChild() appendChild() */
end_comment
begin_function
DECL|function|insertBefore
name|QDomNode
name|QDomNode
operator|::
name|insertBefore
parameter_list|(
specifier|const
name|QDomNode
modifier|&
name|newChild
parameter_list|,
specifier|const
name|QDomNode
modifier|&
name|refChild
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|insertBefore
argument_list|(
name|newChild
operator|.
name|impl
argument_list|,
name|refChild
operator|.
name|impl
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts the node \a newChild after the child node \a refChild. \a     refChild must be a direct child of this node. If \a refChild is     \link isNull() null\endlink then \a newChild is appended as this     node's last child.      If \a newChild is the child of another node, it is reparented to     this node. If \a newChild is a child of this node, then its     position in the list of children is changed.      If \a newChild is a QDomDocumentFragment, then the children of the     fragment are removed from the fragment and inserted after \a     refChild.      Returns a new reference to \a newChild on success or a \link     isNull() null node\endlink on failure.      The DOM specification disallow inserting attribute nodes, but due     to historical reasons QDom accept them nevertheless.      \sa insertBefore() replaceChild() removeChild() appendChild() */
end_comment
begin_function
DECL|function|insertAfter
name|QDomNode
name|QDomNode
operator|::
name|insertAfter
parameter_list|(
specifier|const
name|QDomNode
modifier|&
name|newChild
parameter_list|,
specifier|const
name|QDomNode
modifier|&
name|refChild
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|insertAfter
argument_list|(
name|newChild
operator|.
name|impl
argument_list|,
name|refChild
operator|.
name|impl
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Replaces \a oldChild with \a newChild. \a oldChild must be a     direct child of this node.      If \a newChild is the child of another node, it is reparented to     this node. If \a newChild is a child of this node, then its     position in the list of children is changed.      If \a newChild is a QDomDocumentFragment, then \a oldChild is     replaced by all of the children of the fragment.      Returns a new reference to \a oldChild on success or a \link     isNull() null node\endlink an failure.      \sa insertBefore() insertAfter() removeChild() appendChild() */
end_comment
begin_function
DECL|function|replaceChild
name|QDomNode
name|QDomNode
operator|::
name|replaceChild
parameter_list|(
specifier|const
name|QDomNode
modifier|&
name|newChild
parameter_list|,
specifier|const
name|QDomNode
modifier|&
name|oldChild
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
operator|||
operator|!
name|newChild
operator|.
name|impl
operator|||
operator|!
name|oldChild
operator|.
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|replaceChild
argument_list|(
name|newChild
operator|.
name|impl
argument_list|,
name|oldChild
operator|.
name|impl
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Removes \a oldChild from the list of children. \a oldChild must be     a direct child of this node.      Returns a new reference to \a oldChild on success or a \link     isNull() null node\endlink on failure.      \sa insertBefore() insertAfter() replaceChild() appendChild() */
end_comment
begin_function
DECL|function|removeChild
name|QDomNode
name|QDomNode
operator|::
name|removeChild
parameter_list|(
specifier|const
name|QDomNode
modifier|&
name|oldChild
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
if|if
condition|(
name|oldChild
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|removeChild
argument_list|(
name|oldChild
operator|.
name|impl
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Appends \a newChild as the node's last child.      If \a newChild is the child of another node, it is reparented to     this node. If \a newChild is a child of this node, then its     position in the list of children is changed.      If \a newChild is a QDomDocumentFragment, then the children of the     fragment are removed from the fragment and appended.      If \a newChild is a QDomElement and this node is a QDomDocument that     already has an element node as a child, \a newChild is not added as     a child and a null node is returned.      Returns a new reference to \a newChild on success or a \link     isNull() null node\endlink on failure.      Calling this function on a null node(created, for example, with     the default constructor) does nothing and returns a \link isNull()     null node\endlink.      The DOM specification disallow inserting attribute nodes, but for     historical reasons, QDom accepts them anyway.      \sa insertBefore() insertAfter() replaceChild() removeChild() */
end_comment
begin_function
DECL|function|appendChild
name|QDomNode
name|QDomNode
operator|::
name|appendChild
parameter_list|(
specifier|const
name|QDomNode
modifier|&
name|newChild
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
block|{
name|qWarning
argument_list|(
literal|"Calling appendChild() on a null node does nothing."
argument_list|)
expr_stmt|;
return|return
name|QDomNode
argument_list|()
return|;
block|}
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|appendChild
argument_list|(
name|newChild
operator|.
name|impl
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node has one or more children; otherwise     returns false. */
end_comment
begin_function
DECL|function|hasChildNodes
name|bool
name|QDomNode
operator|::
name|hasChildNodes
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
literal|false
return|;
return|return
name|IMPL
operator|->
name|first
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this node is null (i.e. if it has no type or     contents); otherwise returns false. */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QDomNode
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|impl
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Converts the node into a null node; if it was not a null node     before, its type and contents are deleted.      \sa isNull() */
end_comment
begin_function
DECL|function|clear
name|void
name|QDomNode
operator|::
name|clear
parameter_list|()
block|{
if|if
condition|(
name|impl
operator|&&
operator|!
name|impl
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|impl
expr_stmt|;
name|impl
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the first direct child node for which nodeName() equals \a     name.      If no such direct child exists, a \link isNull() null node\endlink     is returned.      \sa nodeName() */
end_comment
begin_function
DECL|function|namedItem
name|QDomNode
name|QDomNode
operator|::
name|namedItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|impl
operator|->
name|namedItem
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Writes the XML representation of the node and all its children to     the stream \a str. This function uses \a indent as the amount of     space to indent the node.      If this node is a document node, the encoding of text stream \a str's encoding is     set by treating a processing instruction by name "xml" as an XML declaration, if such a one exists,     and otherwise defaults to UTF-8. XML declarations are not processing instructions, but this     behavior exists for historical reasons. If this node is not a document node,     the text stream's encoding is used.      If the document contains invalid XML characters or characters that cannot be     encoded in the given encoding, the result and behavior is undefined.  */
end_comment
begin_function
DECL|function|save
name|void
name|QDomNode
operator|::
name|save
parameter_list|(
name|QTextStream
modifier|&
name|str
parameter_list|,
name|int
name|indent
parameter_list|)
specifier|const
block|{
name|save
argument_list|(
name|str
argument_list|,
name|indent
argument_list|,
name|QDomNode
operator|::
name|EncodingFromDocument
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If \a encodingPolicy is QDomNode::EncodingFromDocument, this function behaves as save(QTextStream&str, int indent).      If \a encodingPolicy is EncodingFromTextStream and this node is a document node, this     function behaves as save(QTextStream&str, int indent) with the exception that the encoding     specified in the text stream \a str is used.      If the document contains invalid XML characters or characters that cannot be     encoded in the given encoding, the result and behavior is undefined.      \since 4.2  */
end_comment
begin_function
DECL|function|save
name|void
name|QDomNode
operator|::
name|save
parameter_list|(
name|QTextStream
modifier|&
name|str
parameter_list|,
name|int
name|indent
parameter_list|,
name|EncodingPolicy
name|encodingPolicy
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
if|if
condition|(
name|isDocument
argument_list|()
condition|)
cast|static_cast
argument_list|<
specifier|const
name|QDomDocumentPrivate
operator|*
argument_list|>
argument_list|(
name|impl
argument_list|)
operator|->
name|saveDocument
argument_list|(
name|str
argument_list|,
name|indent
argument_list|,
name|encodingPolicy
argument_list|)
expr_stmt|;
else|else
name|IMPL
operator|->
name|save
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \relates QDomNode      Writes the XML representation of the node \a node and all its     children to the stream \a str. */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QTextStream
modifier|&
name|str
parameter_list|,
specifier|const
name|QDomNode
modifier|&
name|node
parameter_list|)
block|{
name|node
operator|.
name|save
argument_list|(
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node is an attribute; otherwise returns false.      If this function returns true, it does not imply that this object     is a QDomAttribute; you can get the QDomAttribute with     toAttribute().      \sa toAttr() */
end_comment
begin_function
DECL|function|isAttr
name|bool
name|QDomNode
operator|::
name|isAttr
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
condition|)
return|return
name|impl
operator|->
name|isAttr
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node is a CDATA section; otherwise returns     false.      If this function returns true, it does not imply that this object     is a QDomCDATASection; you can get the QDomCDATASection with     toCDATASection().      \sa toCDATASection() */
end_comment
begin_function
DECL|function|isCDATASection
name|bool
name|QDomNode
operator|::
name|isCDATASection
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
condition|)
return|return
name|impl
operator|->
name|isCDATASection
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node is a document fragment; otherwise returns     false.      If this function returns true, it does not imply that this object     is a QDomDocumentFragment; you can get the QDomDocumentFragment     with toDocumentFragment().      \sa toDocumentFragment() */
end_comment
begin_function
DECL|function|isDocumentFragment
name|bool
name|QDomNode
operator|::
name|isDocumentFragment
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
condition|)
return|return
name|impl
operator|->
name|isDocumentFragment
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node is a document; otherwise returns false.      If this function returns true, it does not imply that this object     is a QDomDocument; you can get the QDomDocument with toDocument().      \sa toDocument() */
end_comment
begin_function
DECL|function|isDocument
name|bool
name|QDomNode
operator|::
name|isDocument
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
condition|)
return|return
name|impl
operator|->
name|isDocument
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node is a document type; otherwise returns     false.      If this function returns true, it does not imply that this object     is a QDomDocumentType; you can get the QDomDocumentType with     toDocumentType().      \sa toDocumentType() */
end_comment
begin_function
DECL|function|isDocumentType
name|bool
name|QDomNode
operator|::
name|isDocumentType
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
condition|)
return|return
name|impl
operator|->
name|isDocumentType
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node is an element; otherwise returns false.      If this function returns true, it does not imply that this object     is a QDomElement; you can get the QDomElement with toElement().      \sa toElement() */
end_comment
begin_function
DECL|function|isElement
name|bool
name|QDomNode
operator|::
name|isElement
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
condition|)
return|return
name|impl
operator|->
name|isElement
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node is an entity reference; otherwise returns     false.      If this function returns true, it does not imply that this object     is a QDomEntityReference; you can get the QDomEntityReference with     toEntityReference().      \sa toEntityReference() */
end_comment
begin_function
DECL|function|isEntityReference
name|bool
name|QDomNode
operator|::
name|isEntityReference
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
condition|)
return|return
name|impl
operator|->
name|isEntityReference
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node is a text node; otherwise returns false.      If this function returns true, it does not imply that this object     is a QDomText; you can get the QDomText with toText().      \sa toText() */
end_comment
begin_function
DECL|function|isText
name|bool
name|QDomNode
operator|::
name|isText
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
condition|)
return|return
name|impl
operator|->
name|isText
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node is an entity; otherwise returns false.      If this function returns true, it does not imply that this object     is a QDomEntity; you can get the QDomEntity with toEntity().      \sa toEntity() */
end_comment
begin_function
DECL|function|isEntity
name|bool
name|QDomNode
operator|::
name|isEntity
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
condition|)
return|return
name|impl
operator|->
name|isEntity
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node is a notation; otherwise returns false.      If this function returns true, it does not imply that this object     is a QDomNotation; you can get the QDomNotation with toNotation().      \sa toNotation() */
end_comment
begin_function
DECL|function|isNotation
name|bool
name|QDomNode
operator|::
name|isNotation
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
condition|)
return|return
name|impl
operator|->
name|isNotation
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node is a processing instruction; otherwise     returns false.      If this function returns true, it does not imply that this object     is a QDomProcessingInstruction; you can get the     QProcessingInstruction with toProcessingInstruction().      \sa toProcessingInstruction() */
end_comment
begin_function
DECL|function|isProcessingInstruction
name|bool
name|QDomNode
operator|::
name|isProcessingInstruction
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
condition|)
return|return
name|impl
operator|->
name|isProcessingInstruction
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node is a character data node; otherwise     returns false.      If this function returns true, it does not imply that this object     is a QDomCharacterData; you can get the QDomCharacterData with     toCharacterData().      \sa toCharacterData() */
end_comment
begin_function
DECL|function|isCharacterData
name|bool
name|QDomNode
operator|::
name|isCharacterData
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
condition|)
return|return
name|impl
operator|->
name|isCharacterData
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the node is a comment; otherwise returns false.      If this function returns true, it does not imply that this object     is a QDomComment; you can get the QDomComment with toComment().      \sa toComment() */
end_comment
begin_function
DECL|function|isComment
name|bool
name|QDomNode
operator|::
name|isComment
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
condition|)
return|return
name|impl
operator|->
name|isComment
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_undef
DECL|macro|IMPL
undef|#
directive|undef
name|IMPL
end_undef
begin_comment
comment|/*!     Returns the first child element with tag name \a tagName if tagName is non-empty;     otherwise returns the first child element.  Returns a null element if no     such child exists.      \sa lastChildElement() previousSiblingElement() nextSiblingElement() */
end_comment
begin_function
DECL|function|firstChildElement
name|QDomElement
name|QDomNode
operator|::
name|firstChildElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|tagName
parameter_list|)
specifier|const
block|{
for|for
control|(
name|QDomNode
name|child
init|=
name|firstChild
argument_list|()
init|;
operator|!
name|child
operator|.
name|isNull
argument_list|()
condition|;
name|child
operator|=
name|child
operator|.
name|nextSibling
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|.
name|isElement
argument_list|()
condition|)
block|{
name|QDomElement
name|elt
init|=
name|child
operator|.
name|toElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|tagName
operator|.
name|isEmpty
argument_list|()
operator|||
name|elt
operator|.
name|tagName
argument_list|()
operator|==
name|tagName
condition|)
return|return
name|elt
return|;
block|}
block|}
return|return
name|QDomElement
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the last child element with tag name \a tagName if tagName is non-empty;     otherwise returns the first child element. Returns a null element if no     such child exists.      \sa firstChildElement() previousSiblingElement() nextSiblingElement() */
end_comment
begin_function
DECL|function|lastChildElement
name|QDomElement
name|QDomNode
operator|::
name|lastChildElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|tagName
parameter_list|)
specifier|const
block|{
for|for
control|(
name|QDomNode
name|child
init|=
name|lastChild
argument_list|()
init|;
operator|!
name|child
operator|.
name|isNull
argument_list|()
condition|;
name|child
operator|=
name|child
operator|.
name|previousSibling
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|.
name|isElement
argument_list|()
condition|)
block|{
name|QDomElement
name|elt
init|=
name|child
operator|.
name|toElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|tagName
operator|.
name|isEmpty
argument_list|()
operator|||
name|elt
operator|.
name|tagName
argument_list|()
operator|==
name|tagName
condition|)
return|return
name|elt
return|;
block|}
block|}
return|return
name|QDomElement
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the next sibling element with tag name \a tagName if \a tagName     is non-empty; otherwise returns any next sibling element.     Returns a null element if no such sibling exists.      \sa firstChildElement() previousSiblingElement() lastChildElement() */
end_comment
begin_function
DECL|function|nextSiblingElement
name|QDomElement
name|QDomNode
operator|::
name|nextSiblingElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|tagName
parameter_list|)
specifier|const
block|{
for|for
control|(
name|QDomNode
name|sib
init|=
name|nextSibling
argument_list|()
init|;
operator|!
name|sib
operator|.
name|isNull
argument_list|()
condition|;
name|sib
operator|=
name|sib
operator|.
name|nextSibling
argument_list|()
control|)
block|{
if|if
condition|(
name|sib
operator|.
name|isElement
argument_list|()
condition|)
block|{
name|QDomElement
name|elt
init|=
name|sib
operator|.
name|toElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|tagName
operator|.
name|isEmpty
argument_list|()
operator|||
name|elt
operator|.
name|tagName
argument_list|()
operator|==
name|tagName
condition|)
return|return
name|elt
return|;
block|}
block|}
return|return
name|QDomElement
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the previous sibilng element with tag name \a tagName if \a tagName     is non-empty; otherwise returns any previous sibling element.     Returns a null element if no such sibling exists.      \sa firstChildElement(), nextSiblingElement(), lastChildElement() */
end_comment
begin_function
DECL|function|previousSiblingElement
name|QDomElement
name|QDomNode
operator|::
name|previousSiblingElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|tagName
parameter_list|)
specifier|const
block|{
for|for
control|(
name|QDomNode
name|sib
init|=
name|previousSibling
argument_list|()
init|;
operator|!
name|sib
operator|.
name|isNull
argument_list|()
condition|;
name|sib
operator|=
name|sib
operator|.
name|previousSibling
argument_list|()
control|)
block|{
if|if
condition|(
name|sib
operator|.
name|isElement
argument_list|()
condition|)
block|{
name|QDomElement
name|elt
init|=
name|sib
operator|.
name|toElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|tagName
operator|.
name|isEmpty
argument_list|()
operator|||
name|elt
operator|.
name|tagName
argument_list|()
operator|==
name|tagName
condition|)
return|return
name|elt
return|;
block|}
block|}
return|return
name|QDomElement
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      For nodes created by QDomDocument::setContent(), this function     returns the line number in the XML document where the node was parsed.     Otherwise, -1 is returned.      \sa columnNumber(), QDomDocument::setContent() */
end_comment
begin_function
DECL|function|lineNumber
name|int
name|QDomNode
operator|::
name|lineNumber
parameter_list|()
specifier|const
block|{
return|return
name|impl
condition|?
name|impl
operator|->
name|lineNumber
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      For nodes created by QDomDocument::setContent(), this function     returns the column number in the XML document where the node was parsed.     Otherwise, -1 is returned.      \sa lineNumber(), QDomDocument::setContent() */
end_comment
begin_function
DECL|function|columnNumber
name|int
name|QDomNode
operator|::
name|columnNumber
parameter_list|()
specifier|const
block|{
return|return
name|impl
condition|?
name|impl
operator|->
name|columnNumber
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomNamedNodeMapPrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomNamedNodeMapPrivate
name|QDomNamedNodeMapPrivate
operator|::
name|QDomNamedNodeMapPrivate
parameter_list|(
name|QDomNodePrivate
modifier|*
name|n
parameter_list|)
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
block|{
name|readonly
operator|=
literal|false
expr_stmt|;
name|parent
operator|=
name|n
expr_stmt|;
name|appendToParent
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QDomNamedNodeMapPrivate
name|QDomNamedNodeMapPrivate
operator|::
name|~
name|QDomNamedNodeMapPrivate
parameter_list|()
block|{
name|clearMap
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|clone
name|QDomNamedNodeMapPrivate
modifier|*
name|QDomNamedNodeMapPrivate
operator|::
name|clone
parameter_list|(
name|QDomNodePrivate
modifier|*
name|p
parameter_list|)
block|{
name|QScopedPointer
argument_list|<
name|QDomNamedNodeMapPrivate
argument_list|>
name|m
argument_list|(
operator|new
name|QDomNamedNodeMapPrivate
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|m
operator|->
name|readonly
operator|=
name|readonly
expr_stmt|;
name|m
operator|->
name|appendToParent
operator|=
name|appendToParent
expr_stmt|;
name|QHash
argument_list|<
name|QString
argument_list|,
name|QDomNodePrivate
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|map
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|map
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QDomNodePrivate
modifier|*
name|new_node
init|=
operator|(
operator|*
name|it
operator|)
operator|->
name|cloneNode
argument_list|()
decl_stmt|;
name|new_node
operator|->
name|setParent
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|m
operator|->
name|setNamedItem
argument_list|(
name|new_node
argument_list|)
expr_stmt|;
block|}
comment|// we are no longer interested in ownership
name|m
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|m
operator|.
name|take
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|clearMap
name|void
name|QDomNamedNodeMapPrivate
operator|::
name|clearMap
parameter_list|()
block|{
comment|// Dereference all of our children if we took references
if|if
condition|(
operator|!
name|appendToParent
condition|)
block|{
name|QHash
argument_list|<
name|QString
argument_list|,
name|QDomNodePrivate
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|map
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|map
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
if|if
condition|(
operator|!
operator|(
operator|*
name|it
operator|)
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
operator|*
name|it
expr_stmt|;
block|}
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|namedItem
name|QDomNodePrivate
modifier|*
name|QDomNamedNodeMapPrivate
operator|::
name|namedItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
name|map
index|[
name|name
index|]
decl_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|namedItemNS
name|QDomNodePrivate
modifier|*
name|QDomNamedNodeMapPrivate
operator|::
name|namedItemNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
specifier|const
block|{
name|QHash
argument_list|<
name|QString
argument_list|,
name|QDomNodePrivate
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|map
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QDomNodePrivate
modifier|*
name|n
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|map
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|n
operator|=
operator|*
name|it
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|prefix
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// node has a namespace
if|if
condition|(
name|n
operator|->
name|namespaceURI
operator|==
name|nsURI
operator|&&
name|n
operator|->
name|name
operator|==
name|localName
condition|)
return|return
name|n
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|setNamedItem
name|QDomNodePrivate
modifier|*
name|QDomNamedNodeMapPrivate
operator|::
name|setNamedItem
parameter_list|(
name|QDomNodePrivate
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|readonly
operator|||
operator|!
name|arg
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|appendToParent
condition|)
return|return
name|parent
operator|->
name|appendChild
argument_list|(
name|arg
argument_list|)
return|;
name|QDomNodePrivate
modifier|*
name|n
init|=
name|map
operator|.
name|value
argument_list|(
name|arg
operator|->
name|nodeName
argument_list|()
argument_list|)
decl_stmt|;
comment|// We take a reference
name|arg
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|map
operator|.
name|insertMulti
argument_list|(
name|arg
operator|->
name|nodeName
argument_list|()
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_function
DECL|function|setNamedItemNS
name|QDomNodePrivate
modifier|*
name|QDomNamedNodeMapPrivate
operator|::
name|setNamedItemNS
parameter_list|(
name|QDomNodePrivate
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|readonly
operator|||
operator|!
name|arg
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|appendToParent
condition|)
return|return
name|parent
operator|->
name|appendChild
argument_list|(
name|arg
argument_list|)
return|;
if|if
condition|(
operator|!
name|arg
operator|->
name|prefix
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// node has a namespace
name|QDomNodePrivate
modifier|*
name|n
init|=
name|namedItemNS
argument_list|(
name|arg
operator|->
name|namespaceURI
argument_list|,
name|arg
operator|->
name|name
argument_list|)
decl_stmt|;
comment|// We take a reference
name|arg
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|map
operator|.
name|insertMulti
argument_list|(
name|arg
operator|->
name|nodeName
argument_list|()
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
else|else
block|{
comment|// ### check the following code if it is ok
return|return
name|setNamedItem
argument_list|(
name|arg
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|removeNamedItem
name|QDomNodePrivate
modifier|*
name|QDomNamedNodeMapPrivate
operator|::
name|removeNamedItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|readonly
condition|)
return|return
literal|0
return|;
name|QDomNodePrivate
modifier|*
name|p
init|=
name|namedItem
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|appendToParent
condition|)
return|return
name|parent
operator|->
name|removeChild
argument_list|(
name|p
argument_list|)
return|;
name|map
operator|.
name|remove
argument_list|(
name|p
operator|->
name|nodeName
argument_list|()
argument_list|)
expr_stmt|;
comment|// We took a reference, so we have to free one here
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|item
name|QDomNodePrivate
modifier|*
name|QDomNamedNodeMapPrivate
operator|::
name|item
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|(
name|uint
operator|)
name|index
operator|>=
name|length
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
operator|*
operator|(
name|map
operator|.
name|constBegin
argument_list|()
operator|+
name|index
operator|)
return|;
block|}
end_function
begin_comment
comment|// ### Qt 5: convert all length/size() functions in QDom to use int instead of uint.
end_comment
begin_function
DECL|function|length
name|uint
name|QDomNamedNodeMapPrivate
operator|::
name|length
parameter_list|()
specifier|const
block|{
return|return
name|map
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|contains
name|bool
name|QDomNamedNodeMapPrivate
operator|::
name|contains
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|map
operator|.
name|value
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function
begin_function
DECL|function|containsNS
name|bool
name|QDomNamedNodeMapPrivate
operator|::
name|containsNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
specifier|const
block|{
return|return
name|namedItemNS
argument_list|(
name|nsURI
argument_list|,
name|localName
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomNamedNodeMap  *  **************************************************************/
end_comment
begin_define
DECL|macro|IMPL
define|#
directive|define
name|IMPL
value|((QDomNamedNodeMapPrivate*)impl)
end_define
begin_comment
comment|/*!     \class QDomNamedNodeMap     \reentrant     \brief The QDomNamedNodeMap class contains a collection of nodes     that can be accessed by name.      \inmodule QtXml     \ingroup xml-tools      Note that QDomNamedNodeMap does not inherit from QDomNodeList.     QDomNamedNodeMaps do not provide any specific node ordering.     Although nodes in a QDomNamedNodeMap may be accessed by an ordinal     index, this is simply to allow a convenient enumeration of the     contents of a QDomNamedNodeMap, and does not imply that the DOM     specifies an ordering of the nodes.      The QDomNamedNodeMap is used in three places:     \list 1     \i QDomDocumentType::entities() returns a map of all entities         described in the DTD.     \i QDomDocumentType::notations() returns a map of all notations         described in the DTD.     \i QDomNode::attributes() returns a map of all attributes of an         element.     \endlist      Items in the map are identified by the name which QDomNode::name()     returns. Nodes are retrieved using namedItem(), namedItemNS() or     item(). New nodes are inserted with setNamedItem() or     setNamedItemNS() and removed with removeNamedItem() or     removeNamedItemNS(). Use contains() to see if an item with the     given name is in the named node map. The number of items is     returned by length().      Terminology: in this class we use "item" and "node"     interchangeably. */
end_comment
begin_comment
comment|/*!     Constructs an empty named node map. */
end_comment
begin_constructor
DECL|function|QDomNamedNodeMap
name|QDomNamedNodeMap
operator|::
name|QDomNamedNodeMap
parameter_list|()
block|{
name|impl
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a n. */
end_comment
begin_constructor
DECL|function|QDomNamedNodeMap
name|QDomNamedNodeMap
operator|::
name|QDomNamedNodeMap
parameter_list|(
specifier|const
name|QDomNamedNodeMap
modifier|&
name|n
parameter_list|)
block|{
name|impl
operator|=
name|n
operator|.
name|impl
expr_stmt|;
if|if
condition|(
name|impl
condition|)
name|impl
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_constructor
DECL|function|QDomNamedNodeMap
name|QDomNamedNodeMap
operator|::
name|QDomNamedNodeMap
parameter_list|(
name|QDomNamedNodeMapPrivate
modifier|*
name|n
parameter_list|)
block|{
name|impl
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|impl
condition|)
name|impl
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns \a n to this named node map. */
end_comment
begin_function
DECL|function|operator =
name|QDomNamedNodeMap
modifier|&
name|QDomNamedNodeMap
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomNamedNodeMap
modifier|&
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|.
name|impl
condition|)
name|n
operator|.
name|impl
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|impl
operator|&&
operator|!
name|impl
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|impl
expr_stmt|;
name|impl
operator|=
name|n
operator|.
name|impl
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if \a n and this named node map are equal; otherwise     returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QDomNamedNodeMap
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QDomNamedNodeMap
modifier|&
name|n
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|impl
operator|==
name|n
operator|.
name|impl
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if \a n and this named node map are not equal;     otherwise returns false. */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QDomNamedNodeMap
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QDomNamedNodeMap
modifier|&
name|n
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|impl
operator|!=
name|n
operator|.
name|impl
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the object and frees its resources. */
end_comment
begin_destructor
DECL|function|~QDomNamedNodeMap
name|QDomNamedNodeMap
operator|::
name|~
name|QDomNamedNodeMap
parameter_list|()
block|{
if|if
condition|(
name|impl
operator|&&
operator|!
name|impl
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|impl
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns the node called \a name.      If the named node map does not contain such a node, a \link     QDomNode::isNull() null node\endlink is returned. A node's name is     the name returned by QDomNode::nodeName().      \sa setNamedItem() namedItemNS() */
end_comment
begin_function
DECL|function|namedItem
name|QDomNode
name|QDomNamedNodeMap
operator|::
name|namedItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|namedItem
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts the node \a newNode into the named node map. The name used     by the map is the node name of \a newNode as returned by     QDomNode::nodeName().      If the new node replaces an existing node, i.e. the map contains a     node with the same name, the replaced node is returned.      \sa namedItem() removeNamedItem() setNamedItemNS() */
end_comment
begin_function
DECL|function|setNamedItem
name|QDomNode
name|QDomNamedNodeMap
operator|::
name|setNamedItem
parameter_list|(
specifier|const
name|QDomNode
modifier|&
name|newNode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|setNamedItem
argument_list|(
operator|(
name|QDomNodePrivate
operator|*
operator|)
name|newNode
operator|.
name|impl
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the node called \a name from the map.      The function returns the removed node or a \link     QDomNode::isNull() null node\endlink if the map did not contain a     node called \a name.      \sa setNamedItem() namedItem() removeNamedItemNS() */
end_comment
begin_function
DECL|function|removeNamedItem
name|QDomNode
name|QDomNamedNodeMap
operator|::
name|removeNamedItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|removeNamedItem
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Retrieves the node at position \a index.      This can be used to iterate over the map. Note that the nodes in     the map are ordered arbitrarily.      \sa length() */
end_comment
begin_function
DECL|function|item
name|QDomNode
name|QDomNamedNodeMap
operator|::
name|item
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|item
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the node associated with the local name \a localName and     the namespace URI \a nsURI.      If the map does not contain such a node, a \link     QDomNode::isNull() null node\endlink is returned.      \sa setNamedItemNS() namedItem() */
end_comment
begin_function
DECL|function|namedItemNS
name|QDomNode
name|QDomNamedNodeMap
operator|::
name|namedItemNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|namedItemNS
argument_list|(
name|nsURI
argument_list|,
name|localName
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts the node \a newNode in the map. If a node with the same     namespace URI and the same local name already exists in the map,     it is replaced by \a newNode. If the new node replaces an existing     node, the replaced node is returned.      \sa namedItemNS() removeNamedItemNS() setNamedItem() */
end_comment
begin_function
DECL|function|setNamedItemNS
name|QDomNode
name|QDomNamedNodeMap
operator|::
name|setNamedItemNS
parameter_list|(
specifier|const
name|QDomNode
modifier|&
name|newNode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|setNamedItemNS
argument_list|(
operator|(
name|QDomNodePrivate
operator|*
operator|)
name|newNode
operator|.
name|impl
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the node with the local name \a localName and the     namespace URI \a nsURI from the map.      The function returns the removed node or a \link     QDomNode::isNull() null node\endlink if the map did not contain a     node with the local name \a localName and the namespace URI \a     nsURI.      \sa setNamedItemNS() namedItemNS() removeNamedItem() */
end_comment
begin_function
DECL|function|removeNamedItemNS
name|QDomNode
name|QDomNamedNodeMap
operator|::
name|removeNamedItemNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNode
argument_list|()
return|;
name|QDomNodePrivate
modifier|*
name|n
init|=
name|IMPL
operator|->
name|namedItemNS
argument_list|(
name|nsURI
argument_list|,
name|localName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|QDomNode
argument_list|()
return|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|removeNamedItem
argument_list|(
name|n
operator|->
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of nodes in the map.      \sa item() */
end_comment
begin_function
DECL|function|length
name|uint
name|QDomNamedNodeMap
operator|::
name|length
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
literal|0
return|;
return|return
name|IMPL
operator|->
name|length
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QDomNamedNodeMap::isEmpty() const      Returns true if the map is empty; otherwise returns false. This function is     provided for Qt API consistency. */
end_comment
begin_comment
comment|/*!     \fn int QDomNamedNodeMap::count() const      This function is provided for Qt API consistency. It is equivalent to length(). */
end_comment
begin_comment
comment|/*!     \fn int QDomNamedNodeMap::size() const      This function is provided for Qt API consistency. It is equivalent to length(). */
end_comment
begin_comment
comment|/*!     Returns true if the map contains a node called \a name; otherwise     returns false.      \bold{Note:} This function does not take the presence of namespaces into account.     Use namedItemNS() to test whether the map contains a node with a specific namespace     URI and name. */
end_comment
begin_function
DECL|function|contains
name|bool
name|QDomNamedNodeMap
operator|::
name|contains
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
literal|false
return|;
return|return
name|IMPL
operator|->
name|contains
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_undef
DECL|macro|IMPL
undef|#
directive|undef
name|IMPL
end_undef
begin_comment
comment|/**************************************************************  *  * QDomDocumentTypePrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomDocumentTypePrivate
name|QDomDocumentTypePrivate
operator|::
name|QDomDocumentTypePrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|doc
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|doc
argument_list|,
name|parent
argument_list|)
block|{
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomDocumentTypePrivate
name|QDomDocumentTypePrivate
operator|::
name|QDomDocumentTypePrivate
parameter_list|(
name|QDomDocumentTypePrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|n
argument_list|,
name|deep
argument_list|)
block|{
name|init
argument_list|()
expr_stmt|;
comment|// Refill the maps with our new children
name|QDomNodePrivate
modifier|*
name|p
init|=
name|first
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|isEntity
argument_list|()
condition|)
comment|// Dont use normal insert function since we would create infinite recursion
name|entities
operator|->
name|map
operator|.
name|insertMulti
argument_list|(
name|p
operator|->
name|nodeName
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|isNotation
argument_list|()
condition|)
comment|// Dont use normal insert function since we would create infinite recursion
name|notations
operator|->
name|map
operator|.
name|insertMulti
argument_list|(
name|p
operator|->
name|nodeName
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
end_constructor
begin_destructor
DECL|function|~QDomDocumentTypePrivate
name|QDomDocumentTypePrivate
operator|::
name|~
name|QDomDocumentTypePrivate
parameter_list|()
block|{
if|if
condition|(
operator|!
name|entities
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|entities
expr_stmt|;
if|if
condition|(
operator|!
name|notations
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|notations
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|init
name|void
name|QDomDocumentTypePrivate
operator|::
name|init
parameter_list|()
block|{
name|entities
operator|=
operator|new
name|QDomNamedNodeMapPrivate
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QT_TRY
block|{
name|notations
operator|=
operator|new
name|QDomNamedNodeMapPrivate
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|publicId
operator|.
name|clear
argument_list|()
expr_stmt|;
name|systemId
operator|.
name|clear
argument_list|()
expr_stmt|;
name|internalSubset
operator|.
name|clear
argument_list|()
expr_stmt|;
name|entities
operator|->
name|setAppendToParent
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|notations
operator|->
name|setAppendToParent
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
operator|delete
name|entities
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|cloneNode
name|QDomNodePrivate
modifier|*
name|QDomDocumentTypePrivate
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
operator|new
name|QDomDocumentTypePrivate
argument_list|(
name|this
argument_list|,
name|deep
argument_list|)
decl_stmt|;
comment|// We are not interested in this node
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|insertBefore
name|QDomNodePrivate
modifier|*
name|QDomDocumentTypePrivate
operator|::
name|insertBefore
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|,
name|QDomNodePrivate
modifier|*
name|refChild
parameter_list|)
block|{
comment|// Call the origianl implementation
name|QDomNodePrivate
modifier|*
name|p
init|=
name|QDomNodePrivate
operator|::
name|insertBefore
argument_list|(
name|newChild
argument_list|,
name|refChild
argument_list|)
decl_stmt|;
comment|// Update the maps
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|isEntity
argument_list|()
condition|)
name|entities
operator|->
name|map
operator|.
name|insertMulti
argument_list|(
name|p
operator|->
name|nodeName
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|isNotation
argument_list|()
condition|)
name|notations
operator|->
name|map
operator|.
name|insertMulti
argument_list|(
name|p
operator|->
name|nodeName
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|insertAfter
name|QDomNodePrivate
modifier|*
name|QDomDocumentTypePrivate
operator|::
name|insertAfter
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|,
name|QDomNodePrivate
modifier|*
name|refChild
parameter_list|)
block|{
comment|// Call the origianl implementation
name|QDomNodePrivate
modifier|*
name|p
init|=
name|QDomNodePrivate
operator|::
name|insertAfter
argument_list|(
name|newChild
argument_list|,
name|refChild
argument_list|)
decl_stmt|;
comment|// Update the maps
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|isEntity
argument_list|()
condition|)
name|entities
operator|->
name|map
operator|.
name|insertMulti
argument_list|(
name|p
operator|->
name|nodeName
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|isNotation
argument_list|()
condition|)
name|notations
operator|->
name|map
operator|.
name|insertMulti
argument_list|(
name|p
operator|->
name|nodeName
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|replaceChild
name|QDomNodePrivate
modifier|*
name|QDomDocumentTypePrivate
operator|::
name|replaceChild
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|,
name|QDomNodePrivate
modifier|*
name|oldChild
parameter_list|)
block|{
comment|// Call the origianl implementation
name|QDomNodePrivate
modifier|*
name|p
init|=
name|QDomNodePrivate
operator|::
name|replaceChild
argument_list|(
name|newChild
argument_list|,
name|oldChild
argument_list|)
decl_stmt|;
comment|// Update the maps
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|oldChild
operator|&&
name|oldChild
operator|->
name|isEntity
argument_list|()
condition|)
name|entities
operator|->
name|map
operator|.
name|remove
argument_list|(
name|oldChild
operator|->
name|nodeName
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oldChild
operator|&&
name|oldChild
operator|->
name|isNotation
argument_list|()
condition|)
name|notations
operator|->
name|map
operator|.
name|remove
argument_list|(
name|oldChild
operator|->
name|nodeName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|isEntity
argument_list|()
condition|)
name|entities
operator|->
name|map
operator|.
name|insertMulti
argument_list|(
name|p
operator|->
name|nodeName
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|isNotation
argument_list|()
condition|)
name|notations
operator|->
name|map
operator|.
name|insertMulti
argument_list|(
name|p
operator|->
name|nodeName
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|removeChild
name|QDomNodePrivate
modifier|*
name|QDomDocumentTypePrivate
operator|::
name|removeChild
parameter_list|(
name|QDomNodePrivate
modifier|*
name|oldChild
parameter_list|)
block|{
comment|// Call the origianl implementation
name|QDomNodePrivate
modifier|*
name|p
init|=
name|QDomNodePrivate
operator|::
name|removeChild
argument_list|(
name|oldChild
argument_list|)
decl_stmt|;
comment|// Update the maps
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|isEntity
argument_list|()
condition|)
name|entities
operator|->
name|map
operator|.
name|remove
argument_list|(
name|p
operator|->
name|nodeName
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|isNotation
argument_list|()
condition|)
name|notations
operator|->
name|map
operator|.
name|remove
argument_list|(
name|p
operator|->
name|nodeName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|appendChild
name|QDomNodePrivate
modifier|*
name|QDomDocumentTypePrivate
operator|::
name|appendChild
parameter_list|(
name|QDomNodePrivate
modifier|*
name|newChild
parameter_list|)
block|{
return|return
name|insertAfter
argument_list|(
name|newChild
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|quotedValue
specifier|static
name|QString
name|quotedValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
block|{
name|QChar
name|quote
init|=
name|data
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|?
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
else|:
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
decl_stmt|;
return|return
name|quote
operator|+
name|data
operator|+
name|quote
return|;
block|}
end_function
begin_function
DECL|function|save
name|void
name|QDomDocumentTypePrivate
operator|::
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
name|indent
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|s
operator|<<
literal|"<!DOCTYPE "
operator|<<
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|publicId
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|s
operator|<<
literal|" PUBLIC "
operator|<<
name|quotedValue
argument_list|(
name|publicId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|systemId
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|s
operator|<<
literal|' '
operator|<<
name|quotedValue
argument_list|(
name|systemId
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|systemId
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|s
operator|<<
literal|" SYSTEM "
operator|<<
name|quotedValue
argument_list|(
name|systemId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entities
operator|->
name|length
argument_list|()
operator|>
literal|0
operator|||
name|notations
operator|->
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|s
operator|<<
literal|" ["
operator|<<
name|endl
expr_stmt|;
name|QHash
argument_list|<
name|QString
argument_list|,
name|QDomNodePrivate
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it2
init|=
name|notations
operator|->
name|map
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it2
operator|!=
name|notations
operator|->
name|map
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it2
control|)
operator|(
operator|*
name|it2
operator|)
operator|->
name|save
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|QHash
argument_list|<
name|QString
argument_list|,
name|QDomNodePrivate
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|entities
operator|->
name|map
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|entities
operator|->
name|map
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
operator|(
operator|*
name|it
operator|)
operator|->
name|save
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|s
operator|<<
literal|']'
expr_stmt|;
block|}
name|s
operator|<<
literal|'>'
operator|<<
name|endl
expr_stmt|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomDocumentType  *  **************************************************************/
end_comment
begin_define
DECL|macro|IMPL
define|#
directive|define
name|IMPL
value|((QDomDocumentTypePrivate*)impl)
end_define
begin_comment
comment|/*!     \class QDomDocumentType     \reentrant     \brief The QDomDocumentType class is the representation of the DTD     in the document tree.      \inmodule QtXml     \ingroup xml-tools      The QDomDocumentType class allows read-only access to some of the     data structures in the DTD: it can return a map of all entities()     and notations(). In addition the function name() returns the name     of the document type as specified in the&lt;!DOCTYPE name&gt;     tag. This class also provides the publicId(), systemId() and     internalSubset() functions.      \sa QDomDocument */
end_comment
begin_comment
comment|/*!     Creates an empty QDomDocumentType object. */
end_comment
begin_constructor
DECL|function|QDomDocumentType
name|QDomDocumentType
operator|::
name|QDomDocumentType
parameter_list|()
member_init_list|:
name|QDomNode
argument_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a n.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_constructor
DECL|function|QDomDocumentType
name|QDomDocumentType
operator|::
name|QDomDocumentType
parameter_list|(
specifier|const
name|QDomDocumentType
modifier|&
name|n
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|n
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QDomDocumentType
name|QDomDocumentType
operator|::
name|QDomDocumentType
parameter_list|(
name|QDomDocumentTypePrivate
modifier|*
name|n
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|n
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns \a n to this document type.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_function
DECL|function|operator =
name|QDomDocumentType
modifier|&
name|QDomDocumentType
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomDocumentType
modifier|&
name|n
parameter_list|)
block|{
return|return
operator|(
name|QDomDocumentType
operator|&
operator|)
name|QDomNode
operator|::
name|operator
name|=
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the document type as specified in the&lt;!DOCTYPE name&gt; tag.      \sa nodeName() */
end_comment
begin_function
DECL|function|name
name|QString
name|QDomDocumentType
operator|::
name|name
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|nodeName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a map of all entities described in the DTD. */
end_comment
begin_function
DECL|function|entities
name|QDomNamedNodeMap
name|QDomDocumentType
operator|::
name|entities
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNamedNodeMap
argument_list|()
return|;
return|return
name|QDomNamedNodeMap
argument_list|(
name|IMPL
operator|->
name|entities
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a map of all notations described in the DTD. */
end_comment
begin_function
DECL|function|notations
name|QDomNamedNodeMap
name|QDomDocumentType
operator|::
name|notations
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNamedNodeMap
argument_list|()
return|;
return|return
name|QDomNamedNodeMap
argument_list|(
name|IMPL
operator|->
name|notations
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the public identifier of the external DTD subset or     an empty string if there is no public identifier.      \sa systemId() internalSubset() QDomImplementation::createDocumentType() */
end_comment
begin_function
DECL|function|publicId
name|QString
name|QDomDocumentType
operator|::
name|publicId
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|publicId
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the system identifier of the external DTD subset or     an empty string if there is no system identifier.      \sa publicId() internalSubset() QDomImplementation::createDocumentType() */
end_comment
begin_function
DECL|function|systemId
name|QString
name|QDomDocumentType
operator|::
name|systemId
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|systemId
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the internal subset of the document type or an empty     string if there is no internal subset.      \sa publicId() systemId() */
end_comment
begin_function
DECL|function|internalSubset
name|QString
name|QDomDocumentType
operator|::
name|internalSubset
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|internalSubset
return|;
block|}
end_function
begin_comment
comment|/*     Are these needed at all? The only difference when removing these     two methods in all subclasses is that we'd get a different type     for null nodes. */
end_comment
begin_comment
comment|/*!     \fn QDomNode::NodeType QDomDocumentType::nodeType() const      Returns \c DocumentTypeNode.      \sa isDocumentType() QDomNode::toDocumentType() */
end_comment
begin_undef
DECL|macro|IMPL
undef|#
directive|undef
name|IMPL
end_undef
begin_comment
comment|/**************************************************************  *  * QDomDocumentFragmentPrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomDocumentFragmentPrivate
name|QDomDocumentFragmentPrivate
operator|::
name|QDomDocumentFragmentPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|doc
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|doc
argument_list|,
name|parent
argument_list|)
block|{
name|name
operator|=
name|QLatin1String
argument_list|(
literal|"#document-fragment"
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomDocumentFragmentPrivate
name|QDomDocumentFragmentPrivate
operator|::
name|QDomDocumentFragmentPrivate
parameter_list|(
name|QDomNodePrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|n
argument_list|,
name|deep
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|cloneNode
name|QDomNodePrivate
modifier|*
name|QDomDocumentFragmentPrivate
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
operator|new
name|QDomDocumentFragmentPrivate
argument_list|(
name|this
argument_list|,
name|deep
argument_list|)
decl_stmt|;
comment|// We are not interested in this node
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomDocumentFragment  *  **************************************************************/
end_comment
begin_comment
comment|/*!     \class QDomDocumentFragment     \reentrant     \brief The QDomDocumentFragment class is a tree of QDomNodes which is not usually a complete QDomDocument.      \inmodule QtXml     \ingroup xml-tools      If you want to do complex tree operations it is useful to have a     lightweight class to store nodes and their relations.     QDomDocumentFragment stores a subtree of a document which does not     necessarily represent a well-formed XML document.      QDomDocumentFragment is also useful if you want to group several     nodes in a list and insert them all together as children of some     node. In these cases QDomDocumentFragment can be used as a     temporary container for this list of children.      The most important feature of QDomDocumentFragment is that it is     treated in a special way by QDomNode::insertAfter(),     QDomNode::insertBefore(), QDomNode::replaceChild() and     QDomNode::appendChild(): instead of inserting the fragment itself, all     the fragment's children are inserted. */
end_comment
begin_comment
comment|/*!     Constructs an empty document fragment. */
end_comment
begin_constructor
DECL|function|QDomDocumentFragment
name|QDomDocumentFragment
operator|::
name|QDomDocumentFragment
parameter_list|()
block|{ }
end_constructor
begin_constructor
DECL|function|QDomDocumentFragment
name|QDomDocumentFragment
operator|::
name|QDomDocumentFragment
parameter_list|(
name|QDomDocumentFragmentPrivate
modifier|*
name|n
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|n
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a x.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_constructor
DECL|function|QDomDocumentFragment
name|QDomDocumentFragment
operator|::
name|QDomDocumentFragment
parameter_list|(
specifier|const
name|QDomDocumentFragment
modifier|&
name|x
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|x
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns \a x to this DOM document fragment.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_function
DECL|function|operator =
name|QDomDocumentFragment
modifier|&
name|QDomDocumentFragment
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomDocumentFragment
modifier|&
name|x
parameter_list|)
block|{
return|return
operator|(
name|QDomDocumentFragment
operator|&
operator|)
name|QDomNode
operator|::
name|operator
name|=
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDomNode::NodeType QDomDocumentFragment::nodeType() const      Returns \c DocumentFragment.      \sa isDocumentFragment() QDomNode::toDocumentFragment() */
end_comment
begin_comment
comment|/**************************************************************  *  * QDomCharacterDataPrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomCharacterDataPrivate
name|QDomCharacterDataPrivate
operator|::
name|QDomCharacterDataPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|d
parameter_list|,
name|QDomNodePrivate
modifier|*
name|p
parameter_list|,
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|d
argument_list|,
name|p
argument_list|)
block|{
name|value
operator|=
name|data
expr_stmt|;
name|name
operator|=
name|QLatin1String
argument_list|(
literal|"#character-data"
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomCharacterDataPrivate
name|QDomCharacterDataPrivate
operator|::
name|QDomCharacterDataPrivate
parameter_list|(
name|QDomCharacterDataPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|n
argument_list|,
name|deep
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|cloneNode
name|QDomNodePrivate
modifier|*
name|QDomCharacterDataPrivate
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
operator|new
name|QDomCharacterDataPrivate
argument_list|(
name|this
argument_list|,
name|deep
argument_list|)
decl_stmt|;
comment|// We are not interested in this node
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|dataLength
name|uint
name|QDomCharacterDataPrivate
operator|::
name|dataLength
parameter_list|()
specifier|const
block|{
return|return
name|value
operator|.
name|length
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|substringData
name|QString
name|QDomCharacterDataPrivate
operator|::
name|substringData
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|n
parameter_list|)
specifier|const
block|{
return|return
name|value
operator|.
name|mid
argument_list|(
name|offset
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|insertData
name|void
name|QDomCharacterDataPrivate
operator|::
name|insertData
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
block|{
name|value
operator|.
name|insert
argument_list|(
name|offset
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|deleteData
name|void
name|QDomCharacterDataPrivate
operator|::
name|deleteData
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|n
parameter_list|)
block|{
name|value
operator|.
name|remove
argument_list|(
name|offset
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|replaceData
name|void
name|QDomCharacterDataPrivate
operator|::
name|replaceData
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|n
parameter_list|,
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
block|{
name|value
operator|.
name|replace
argument_list|(
name|offset
argument_list|,
name|n
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendData
name|void
name|QDomCharacterDataPrivate
operator|::
name|appendData
parameter_list|(
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
block|{
name|value
operator|+=
name|arg
expr_stmt|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomCharacterData  *  **************************************************************/
end_comment
begin_define
DECL|macro|IMPL
define|#
directive|define
name|IMPL
value|((QDomCharacterDataPrivate*)impl)
end_define
begin_comment
comment|/*!     \class QDomCharacterData     \reentrant     \brief The QDomCharacterData class represents a generic string in the DOM.      \inmodule QtXml     \ingroup xml-tools      Character data as used in XML specifies a generic data string.     More specialized versions of this class are QDomText, QDomComment     and QDomCDATASection.      The data string is set with setData() and retrieved with data().     You can retrieve a portion of the data string using     substringData(). Extra data can be appended with appendData(), or     inserted with insertData(). Portions of the data string can be     deleted with deleteData() or replaced with replaceData(). The     length of the data string is returned by length().      The node type of the node containing this character data is     returned by nodeType().      \sa QDomText QDomComment QDomCDATASection */
end_comment
begin_comment
comment|/*!     Constructs an empty character data object. */
end_comment
begin_constructor
DECL|function|QDomCharacterData
name|QDomCharacterData
operator|::
name|QDomCharacterData
parameter_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a x.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_constructor
DECL|function|QDomCharacterData
name|QDomCharacterData
operator|::
name|QDomCharacterData
parameter_list|(
specifier|const
name|QDomCharacterData
modifier|&
name|x
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|x
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QDomCharacterData
name|QDomCharacterData
operator|::
name|QDomCharacterData
parameter_list|(
name|QDomCharacterDataPrivate
modifier|*
name|n
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|n
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns \a x to this character data.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_function
DECL|function|operator =
name|QDomCharacterData
modifier|&
name|QDomCharacterData
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomCharacterData
modifier|&
name|x
parameter_list|)
block|{
return|return
operator|(
name|QDomCharacterData
operator|&
operator|)
name|QDomNode
operator|::
name|operator
name|=
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string stored in this object.      If the node is a \link isNull() null node\endlink, it will return     an empty string. */
end_comment
begin_function
DECL|function|data
name|QString
name|QDomCharacterData
operator|::
name|data
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|impl
operator|->
name|nodeValue
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets this object's string to \a v. */
end_comment
begin_function
DECL|function|setData
name|void
name|QDomCharacterData
operator|::
name|setData
parameter_list|(
specifier|const
name|QString
modifier|&
name|v
parameter_list|)
block|{
if|if
condition|(
name|impl
condition|)
name|impl
operator|->
name|setNodeValue
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the length of the stored string. */
end_comment
begin_function
DECL|function|length
name|uint
name|QDomCharacterData
operator|::
name|length
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
condition|)
return|return
name|IMPL
operator|->
name|dataLength
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the substring of length \a count from position \a offset. */
end_comment
begin_function
DECL|function|substringData
name|QString
name|QDomCharacterData
operator|::
name|substringData
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|count
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|substringData
argument_list|(
name|offset
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Appends the string \a arg to the stored string. */
end_comment
begin_function
DECL|function|appendData
name|void
name|QDomCharacterData
operator|::
name|appendData
parameter_list|(
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
block|{
if|if
condition|(
name|impl
condition|)
name|IMPL
operator|->
name|appendData
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Inserts the string \a arg into the stored string at position \a offset. */
end_comment
begin_function
DECL|function|insertData
name|void
name|QDomCharacterData
operator|::
name|insertData
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
block|{
if|if
condition|(
name|impl
condition|)
name|IMPL
operator|->
name|insertData
argument_list|(
name|offset
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Deletes a substring of length \a count from position \a offset. */
end_comment
begin_function
DECL|function|deleteData
name|void
name|QDomCharacterData
operator|::
name|deleteData
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|count
parameter_list|)
block|{
if|if
condition|(
name|impl
condition|)
name|IMPL
operator|->
name|deleteData
argument_list|(
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Replaces the substring of length \a count starting at position \a     offset with the string \a arg. */
end_comment
begin_function
DECL|function|replaceData
name|void
name|QDomCharacterData
operator|::
name|replaceData
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|count
parameter_list|,
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
block|{
if|if
condition|(
name|impl
condition|)
name|IMPL
operator|->
name|replaceData
argument_list|(
name|offset
argument_list|,
name|count
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the type of node this object refers to (i.e. \c TextNode,     \c CDATASectionNode, \c CommentNode or \c CharacterDataNode). For     a \link isNull() null node\endlink, returns \c CharacterDataNode. */
end_comment
begin_function
DECL|function|nodeType
name|QDomNode
operator|::
name|NodeType
name|QDomCharacterData
operator|::
name|nodeType
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|CharacterDataNode
return|;
return|return
name|QDomNode
operator|::
name|nodeType
argument_list|()
return|;
block|}
end_function
begin_undef
DECL|macro|IMPL
undef|#
directive|undef
name|IMPL
end_undef
begin_comment
comment|/**************************************************************  *  * QDomAttrPrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomAttrPrivate
name|QDomAttrPrivate
operator|::
name|QDomAttrPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|d
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name_
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|d
argument_list|,
name|parent
argument_list|)
block|{
name|name
operator|=
name|name_
expr_stmt|;
name|m_specified
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomAttrPrivate
name|QDomAttrPrivate
operator|::
name|QDomAttrPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|d
parameter_list|,
name|QDomNodePrivate
modifier|*
name|p
parameter_list|,
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|d
argument_list|,
name|p
argument_list|)
block|{
name|qt_split_namespace
argument_list|(
name|prefix
argument_list|,
name|name
argument_list|,
name|qName
argument_list|,
operator|!
name|nsURI
operator|.
name|isNull
argument_list|()
argument_list|)
expr_stmt|;
name|namespaceURI
operator|=
name|nsURI
expr_stmt|;
name|createdWithDom1Interface
operator|=
literal|false
expr_stmt|;
name|m_specified
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomAttrPrivate
name|QDomAttrPrivate
operator|::
name|QDomAttrPrivate
parameter_list|(
name|QDomAttrPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|n
argument_list|,
name|deep
argument_list|)
block|{
name|m_specified
operator|=
name|n
operator|->
name|specified
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|setNodeValue
name|void
name|QDomAttrPrivate
operator|::
name|setNodeValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|v
parameter_list|)
block|{
name|value
operator|=
name|v
expr_stmt|;
name|QDomTextPrivate
modifier|*
name|t
init|=
operator|new
name|QDomTextPrivate
argument_list|(
literal|0
argument_list|,
name|this
argument_list|,
name|v
argument_list|)
decl_stmt|;
comment|// keep the refcount balanced: appendChild() does a ref anyway.
name|t
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
operator|delete
name|removeChild
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
name|appendChild
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cloneNode
name|QDomNodePrivate
modifier|*
name|QDomAttrPrivate
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
operator|new
name|QDomAttrPrivate
argument_list|(
name|this
argument_list|,
name|deep
argument_list|)
decl_stmt|;
comment|// We are not interested in this node
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|specified
name|bool
name|QDomAttrPrivate
operator|::
name|specified
parameter_list|()
specifier|const
block|{
return|return
name|m_specified
return|;
block|}
end_function
begin_comment
comment|/* \internal   Encode& escape \a str. Yes, it makes no sense to return a QString,   but is so for legacy reasons.    Remember that content produced should be able to roundtrip with 2.11 End-of-Line Handling   and 3.3.3 Attribute-Value Normalization.    If \a performAVN is true, characters will be escaped to survive Attribute Value Normalization.   If \a encodeEOLs is true, characters will be escaped to survive End-of-Line Handling. */
end_comment
begin_function
DECL|function|encodeText
specifier|static
name|QString
name|encodeText
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|QTextStream
modifier|&
name|s
parameter_list|,
specifier|const
name|bool
name|encodeQuotes
init|=
literal|true
parameter_list|,
specifier|const
name|bool
name|performAVN
init|=
literal|false
parameter_list|,
specifier|const
name|bool
name|encodeEOLs
init|=
literal|false
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_TEXTCODEC
name|Q_UNUSED
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|const
name|QTextCodec
modifier|*
specifier|const
name|codec
init|=
name|s
operator|.
name|codec
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|codec
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QString
name|retval
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|retval
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|len
condition|)
block|{
specifier|const
name|QChar
name|ati
argument_list|(
name|retval
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ati
operator|==
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|retval
operator|.
name|replace
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
name|QLatin1String
argument_list|(
literal|"&lt;"
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|3
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encodeQuotes
operator|&&
operator|(
name|ati
operator|==
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
operator|)
condition|)
block|{
name|retval
operator|.
name|replace
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
name|QLatin1String
argument_list|(
literal|"&quot;"
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|5
expr_stmt|;
name|i
operator|+=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ati
operator|==
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
condition|)
block|{
name|retval
operator|.
name|replace
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
name|QLatin1String
argument_list|(
literal|"&amp;"
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|4
expr_stmt|;
name|i
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ati
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
operator|&&
name|i
operator|>=
literal|2
operator|&&
name|retval
index|[
name|i
operator|-
literal|1
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
operator|&&
name|retval
index|[
name|i
operator|-
literal|2
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
name|retval
operator|.
name|replace
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
name|QLatin1String
argument_list|(
literal|"&gt;"
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|3
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|performAVN
operator|&&
operator|(
name|ati
operator|==
name|QChar
argument_list|(
literal|0xA
argument_list|)
operator|||
name|ati
operator|==
name|QChar
argument_list|(
literal|0xD
argument_list|)
operator|||
name|ati
operator|==
name|QChar
argument_list|(
literal|0x9
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|QString
name|replacement
argument_list|(
name|QLatin1String
argument_list|(
literal|"&#x"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|ati
operator|.
name|unicode
argument_list|()
argument_list|,
literal|16
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
decl_stmt|;
name|retval
operator|.
name|replace
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
name|i
operator|+=
name|replacement
operator|.
name|length
argument_list|()
expr_stmt|;
name|len
operator|+=
name|replacement
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encodeEOLs
operator|&&
name|ati
operator|==
name|QChar
argument_list|(
literal|0xD
argument_list|)
condition|)
block|{
name|retval
operator|.
name|replace
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
name|QLatin1String
argument_list|(
literal|"&#xd;"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Replace a single 0xD with a ref for 0xD
name|len
operator|+=
literal|4
expr_stmt|;
name|i
operator|+=
literal|5
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
if|if
condition|(
name|codec
operator|->
name|canEncode
argument_list|(
name|ati
argument_list|)
condition|)
operator|++
name|i
expr_stmt|;
else|else
endif|#
directive|endif
block|{
comment|// We have to use a character reference to get it through.
specifier|const
name|ushort
name|codepoint
argument_list|(
name|ati
operator|.
name|unicode
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|replacement
argument_list|(
name|QLatin1String
argument_list|(
literal|"&#x"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|codepoint
argument_list|,
literal|16
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
decl_stmt|;
name|retval
operator|.
name|replace
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
name|i
operator|+=
name|replacement
operator|.
name|length
argument_list|()
expr_stmt|;
name|len
operator|+=
name|replacement
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|save
name|void
name|QDomAttrPrivate
operator|::
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|namespaceURI
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|s
operator|<<
name|name
operator|<<
literal|"=\""
operator|<<
name|encodeText
argument_list|(
name|value
argument_list|,
name|s
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
operator|<<
literal|'\"'
expr_stmt|;
block|}
else|else
block|{
name|s
operator|<<
name|prefix
operator|<<
literal|':'
operator|<<
name|name
operator|<<
literal|"=\""
operator|<<
name|encodeText
argument_list|(
name|value
argument_list|,
name|s
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
operator|<<
literal|'\"'
expr_stmt|;
comment|/* This is a fix for 138243, as good as it gets.          *          * QDomElementPrivate::save() output a namespace declaration if          * the element is in a namespace, no matter what. This function do as well, meaning          * that we get two identical namespace declaration if we don't have the if-          * statement below.          *          * This doesn't work when the parent element has the same prefix as us but          * a different namespace. However, this can only occur by the user modifying the element,          * and we don't do fixups by that anyway, and hence it's the user responsibility to not          * arrive in those situations. */
if|if
condition|(
operator|!
name|ownerNode
operator|||
name|ownerNode
operator|->
name|prefix
operator|!=
name|prefix
condition|)
block|{
name|s
operator|<<
literal|" xmlns:"
operator|<<
name|prefix
operator|<<
literal|"=\""
operator|<<
name|encodeText
argument_list|(
name|namespaceURI
argument_list|,
name|s
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
operator|<<
literal|'\"'
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomAttr  *  **************************************************************/
end_comment
begin_define
DECL|macro|IMPL
define|#
directive|define
name|IMPL
value|((QDomAttrPrivate*)impl)
end_define
begin_comment
comment|/*!     \class QDomAttr     \reentrant     \brief The QDomAttr class represents one attribute of a QDomElement.      \inmodule QtXml     \ingroup xml-tools      For example, the following piece of XML produces an element with     no children, but two attributes:      \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 7      You can access the attributes of an element with code like this:      \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 8      This example also shows that changing an attribute received from     an element changes the attribute of the element. If you do not     want to change the value of the element's attribute you must     use cloneNode() to get an independent copy of the attribute.      QDomAttr can return the name() and value() of an attribute. An     attribute's value is set with setValue(). If specified() returns     true the value was set with setValue(). The node this     attribute is attached to (if any) is returned by ownerElement().      For further information about the Document Object Model see     \l{http://www.w3.org/TR/REC-DOM-Level-1/} and     \l{http://www.w3.org/TR/DOM-Level-2-Core/}.     For a more general introduction of the DOM implementation see the     QDomDocument documentation. */
end_comment
begin_comment
comment|/*!     Constructs an empty attribute. */
end_comment
begin_constructor
DECL|function|QDomAttr
name|QDomAttr
operator|::
name|QDomAttr
parameter_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a x.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_constructor
DECL|function|QDomAttr
name|QDomAttr
operator|::
name|QDomAttr
parameter_list|(
specifier|const
name|QDomAttr
modifier|&
name|x
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|x
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QDomAttr
name|QDomAttr
operator|::
name|QDomAttr
parameter_list|(
name|QDomAttrPrivate
modifier|*
name|n
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|n
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns \a x to this DOM attribute.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_function
DECL|function|operator =
name|QDomAttr
modifier|&
name|QDomAttr
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomAttr
modifier|&
name|x
parameter_list|)
block|{
return|return
operator|(
name|QDomAttr
operator|&
operator|)
name|QDomNode
operator|::
name|operator
name|=
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the attribute's name. */
end_comment
begin_function
DECL|function|name
name|QString
name|QDomAttr
operator|::
name|name
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|impl
operator|->
name|nodeName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the attribute has been set by the user with setValue().     Returns false if the value hasn't been specified or set.      \sa setValue() */
end_comment
begin_function
DECL|function|specified
name|bool
name|QDomAttr
operator|::
name|specified
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
literal|false
return|;
return|return
name|IMPL
operator|->
name|specified
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the element node this attribute is attached to or a \link     QDomNode::isNull() null node\endlink if this attribute is not     attached to any element. */
end_comment
begin_function
DECL|function|ownerElement
name|QDomElement
name|QDomAttr
operator|::
name|ownerElement
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|impl
operator|->
name|parent
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|impl
operator|->
name|parent
argument_list|()
operator|->
name|isElement
argument_list|()
condition|)
return|return
name|QDomElement
argument_list|()
return|;
return|return
name|QDomElement
argument_list|(
operator|(
name|QDomElementPrivate
operator|*
operator|)
operator|(
name|impl
operator|->
name|parent
argument_list|()
operator|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the value of the attribute or an empty string if the     attribute has not been specified.      \sa specified() setValue() */
end_comment
begin_function
DECL|function|value
name|QString
name|QDomAttr
operator|::
name|value
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|impl
operator|->
name|nodeValue
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the attribute's value to \a v.      \sa value() */
end_comment
begin_function
DECL|function|setValue
name|void
name|QDomAttr
operator|::
name|setValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|v
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|impl
operator|->
name|setNodeValue
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|IMPL
operator|->
name|m_specified
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QDomNode::NodeType QDomAttr::nodeType() const      Returns \link QDomNode::NodeType AttributeNode\endlink. */
end_comment
begin_undef
DECL|macro|IMPL
undef|#
directive|undef
name|IMPL
end_undef
begin_comment
comment|/**************************************************************  *  * QDomElementPrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomElementPrivate
name|QDomElementPrivate
operator|::
name|QDomElementPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|d
parameter_list|,
name|QDomNodePrivate
modifier|*
name|p
parameter_list|,
specifier|const
name|QString
modifier|&
name|tagname
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|d
argument_list|,
name|p
argument_list|)
block|{
name|name
operator|=
name|tagname
expr_stmt|;
name|m_attr
operator|=
operator|new
name|QDomNamedNodeMapPrivate
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomElementPrivate
name|QDomElementPrivate
operator|::
name|QDomElementPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|d
parameter_list|,
name|QDomNodePrivate
modifier|*
name|p
parameter_list|,
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|d
argument_list|,
name|p
argument_list|)
block|{
name|qt_split_namespace
argument_list|(
name|prefix
argument_list|,
name|name
argument_list|,
name|qName
argument_list|,
operator|!
name|nsURI
operator|.
name|isNull
argument_list|()
argument_list|)
expr_stmt|;
name|namespaceURI
operator|=
name|nsURI
expr_stmt|;
name|createdWithDom1Interface
operator|=
literal|false
expr_stmt|;
name|m_attr
operator|=
operator|new
name|QDomNamedNodeMapPrivate
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomElementPrivate
name|QDomElementPrivate
operator|::
name|QDomElementPrivate
parameter_list|(
name|QDomElementPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|n
argument_list|,
name|deep
argument_list|)
block|{
name|m_attr
operator|=
name|n
operator|->
name|m_attr
operator|->
name|clone
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Reference is down to 0, so we set it to 1 here.
name|m_attr
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_destructor
DECL|function|~QDomElementPrivate
name|QDomElementPrivate
operator|::
name|~
name|QDomElementPrivate
parameter_list|()
block|{
if|if
condition|(
operator|!
name|m_attr
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|m_attr
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|cloneNode
name|QDomNodePrivate
modifier|*
name|QDomElementPrivate
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
operator|new
name|QDomElementPrivate
argument_list|(
name|this
argument_list|,
name|deep
argument_list|)
decl_stmt|;
comment|// We are not interested in this node
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|attribute
name|QString
name|QDomElementPrivate
operator|::
name|attribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name_
parameter_list|,
specifier|const
name|QString
modifier|&
name|defValue
parameter_list|)
specifier|const
block|{
name|QDomNodePrivate
modifier|*
name|n
init|=
name|m_attr
operator|->
name|namedItem
argument_list|(
name|name_
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|defValue
return|;
return|return
name|n
operator|->
name|nodeValue
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|attributeNS
name|QString
name|QDomElementPrivate
operator|::
name|attributeNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|,
specifier|const
name|QString
modifier|&
name|defValue
parameter_list|)
specifier|const
block|{
name|QDomNodePrivate
modifier|*
name|n
init|=
name|m_attr
operator|->
name|namedItemNS
argument_list|(
name|nsURI
argument_list|,
name|localName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|defValue
return|;
return|return
name|n
operator|->
name|nodeValue
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setAttribute
name|void
name|QDomElementPrivate
operator|::
name|setAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|aname
parameter_list|,
specifier|const
name|QString
modifier|&
name|newValue
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|n
init|=
name|m_attr
operator|->
name|namedItem
argument_list|(
name|aname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|n
operator|=
operator|new
name|QDomAttrPrivate
argument_list|(
name|ownerDocument
argument_list|()
argument_list|,
name|this
argument_list|,
name|aname
argument_list|)
expr_stmt|;
name|n
operator|->
name|setNodeValue
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
comment|// Referencing is done by the map, so we set the reference counter back
comment|// to 0 here. This is ok since we created the QDomAttrPrivate.
name|n
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
name|m_attr
operator|->
name|setNamedItem
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|->
name|setNodeValue
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setAttributeNS
name|void
name|QDomElementPrivate
operator|::
name|setAttributeNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|,
specifier|const
name|QString
modifier|&
name|newValue
parameter_list|)
block|{
name|QString
name|prefix
decl_stmt|,
name|localName
decl_stmt|;
name|qt_split_namespace
argument_list|(
name|prefix
argument_list|,
name|localName
argument_list|,
name|qName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QDomNodePrivate
modifier|*
name|n
init|=
name|m_attr
operator|->
name|namedItemNS
argument_list|(
name|nsURI
argument_list|,
name|localName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|n
operator|=
operator|new
name|QDomAttrPrivate
argument_list|(
name|ownerDocument
argument_list|()
argument_list|,
name|this
argument_list|,
name|nsURI
argument_list|,
name|qName
argument_list|)
expr_stmt|;
name|n
operator|->
name|setNodeValue
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
comment|// Referencing is done by the map, so we set the reference counter back
comment|// to 0 here. This is ok since we created the QDomAttrPrivate.
name|n
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
name|m_attr
operator|->
name|setNamedItem
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|->
name|setNodeValue
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
name|n
operator|->
name|prefix
operator|=
name|prefix
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|removeAttribute
name|void
name|QDomElementPrivate
operator|::
name|removeAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|aname
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
name|m_attr
operator|->
name|removeNamedItem
argument_list|(
name|aname
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|0
condition|)
operator|delete
name|p
expr_stmt|;
block|}
end_function
begin_function
DECL|function|attributeNode
name|QDomAttrPrivate
modifier|*
name|QDomElementPrivate
operator|::
name|attributeNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|aname
parameter_list|)
block|{
return|return
operator|(
name|QDomAttrPrivate
operator|*
operator|)
name|m_attr
operator|->
name|namedItem
argument_list|(
name|aname
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|attributeNodeNS
name|QDomAttrPrivate
modifier|*
name|QDomElementPrivate
operator|::
name|attributeNodeNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
block|{
return|return
operator|(
name|QDomAttrPrivate
operator|*
operator|)
name|m_attr
operator|->
name|namedItemNS
argument_list|(
name|nsURI
argument_list|,
name|localName
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setAttributeNode
name|QDomAttrPrivate
modifier|*
name|QDomElementPrivate
operator|::
name|setAttributeNode
parameter_list|(
name|QDomAttrPrivate
modifier|*
name|newAttr
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|n
init|=
name|m_attr
operator|->
name|namedItem
argument_list|(
name|newAttr
operator|->
name|nodeName
argument_list|()
argument_list|)
decl_stmt|;
comment|// Referencing is done by the maps
name|m_attr
operator|->
name|setNamedItem
argument_list|(
name|newAttr
argument_list|)
expr_stmt|;
name|newAttr
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
operator|(
name|QDomAttrPrivate
operator|*
operator|)
name|n
return|;
block|}
end_function
begin_function
DECL|function|setAttributeNodeNS
name|QDomAttrPrivate
modifier|*
name|QDomElementPrivate
operator|::
name|setAttributeNodeNS
parameter_list|(
name|QDomAttrPrivate
modifier|*
name|newAttr
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|newAttr
operator|->
name|prefix
operator|.
name|isNull
argument_list|()
condition|)
name|n
operator|=
name|m_attr
operator|->
name|namedItemNS
argument_list|(
name|newAttr
operator|->
name|namespaceURI
argument_list|,
name|newAttr
operator|->
name|name
argument_list|)
expr_stmt|;
comment|// Referencing is done by the maps
name|m_attr
operator|->
name|setNamedItem
argument_list|(
name|newAttr
argument_list|)
expr_stmt|;
return|return
operator|(
name|QDomAttrPrivate
operator|*
operator|)
name|n
return|;
block|}
end_function
begin_function
DECL|function|removeAttributeNode
name|QDomAttrPrivate
modifier|*
name|QDomElementPrivate
operator|::
name|removeAttributeNode
parameter_list|(
name|QDomAttrPrivate
modifier|*
name|oldAttr
parameter_list|)
block|{
return|return
operator|(
name|QDomAttrPrivate
operator|*
operator|)
name|m_attr
operator|->
name|removeNamedItem
argument_list|(
name|oldAttr
operator|->
name|nodeName
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|hasAttribute
name|bool
name|QDomElementPrivate
operator|::
name|hasAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|aname
parameter_list|)
block|{
return|return
name|m_attr
operator|->
name|contains
argument_list|(
name|aname
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|hasAttributeNS
name|bool
name|QDomElementPrivate
operator|::
name|hasAttributeNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
block|{
return|return
name|m_attr
operator|->
name|containsNS
argument_list|(
name|nsURI
argument_list|,
name|localName
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|text
name|QString
name|QDomElementPrivate
operator|::
name|text
parameter_list|()
block|{
name|QString
name|t
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|)
decl_stmt|;
name|QDomNodePrivate
modifier|*
name|p
init|=
name|first
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|isText
argument_list|()
operator|||
name|p
operator|->
name|isCDATASection
argument_list|()
condition|)
name|t
operator|+=
name|p
operator|->
name|nodeValue
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|isElement
argument_list|()
condition|)
name|t
operator|+=
operator|(
operator|(
name|QDomElementPrivate
operator|*
operator|)
name|p
operator|)
operator|->
name|text
argument_list|()
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function
begin_function
DECL|function|save
name|void
name|QDomElementPrivate
operator|::
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|indent
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
operator|(
name|prev
operator|&&
name|prev
operator|->
name|isText
argument_list|()
operator|)
condition|)
name|s
operator|<<
name|QString
argument_list|(
name|indent
operator|<
literal|1
condition|?
literal|0
else|:
name|depth
operator|*
name|indent
argument_list|,
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|qName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|QString
name|nsDecl
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|namespaceURI
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|/** ### Qt 5:          *          * If we still have QDom, optimize this so that we only declare namespaces that are not          * yet declared. We loose default namespace mappings, so maybe we should rather store          * the information that we get from startPrefixMapping()/endPrefixMapping() and use them.          * Modifications becomes more complex then, however.          *          * We cannot do this during the Qt 4 series because it would require too invasive changes, and          * hence possibly behavioral changes.          */
if|if
condition|(
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|nsDecl
operator|=
name|QLatin1String
argument_list|(
literal|" xmlns"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qName
operator|=
name|prefix
operator|+
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|+
name|name
expr_stmt|;
name|nsDecl
operator|=
name|QLatin1String
argument_list|(
literal|" xmlns:"
argument_list|)
operator|+
name|prefix
expr_stmt|;
block|}
name|nsDecl
operator|+=
name|QLatin1String
argument_list|(
literal|"=\""
argument_list|)
operator|+
name|encodeText
argument_list|(
name|namespaceURI
argument_list|,
name|s
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
block|}
name|s
operator|<<
literal|'<'
operator|<<
name|qName
operator|<<
name|nsDecl
expr_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|outputtedPrefixes
decl_stmt|;
comment|/* Write out attributes. */
if|if
condition|(
operator|!
name|m_attr
operator|->
name|map
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QHash
argument_list|<
name|QString
argument_list|,
name|QDomNodePrivate
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|m_attr
operator|->
name|map
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|m_attr
operator|->
name|map
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|s
operator|<<
literal|' '
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|namespaceURI
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|s
operator|<<
name|it
operator|.
name|value
argument_list|()
operator|->
name|name
operator|<<
literal|"=\""
operator|<<
name|encodeText
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|value
argument_list|,
name|s
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
operator|<<
literal|'\"'
expr_stmt|;
block|}
else|else
block|{
name|s
operator|<<
name|it
operator|.
name|value
argument_list|()
operator|->
name|prefix
operator|<<
literal|':'
operator|<<
name|it
operator|.
name|value
argument_list|()
operator|->
name|name
operator|<<
literal|"=\""
operator|<<
name|encodeText
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|value
argument_list|,
name|s
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
operator|<<
literal|'\"'
expr_stmt|;
comment|/* This is a fix for 138243, as good as it gets.                  *                  * QDomElementPrivate::save() output a namespace declaration if                  * the element is in a namespace, no matter what. This function do as well, meaning                  * that we get two identical namespace declaration if we don't have the if-                  * statement below.                  *                  * This doesn't work when the parent element has the same prefix as us but                  * a different namespace. However, this can only occur by the user modifying the element,                  * and we don't do fixups by that anyway, and hence it's the user responsibility to not                  * arrive in those situations. */
if|if
condition|(
operator|(
operator|!
name|it
operator|.
name|value
argument_list|()
operator|->
name|ownerNode
operator|||
name|it
operator|.
name|value
argument_list|()
operator|->
name|ownerNode
operator|->
name|prefix
operator|!=
name|it
operator|.
name|value
argument_list|()
operator|->
name|prefix
operator|)
operator|&&
operator|!
name|outputtedPrefixes
operator|.
name|contains
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|prefix
argument_list|)
condition|)
block|{
name|s
operator|<<
literal|" xmlns:"
operator|<<
name|it
operator|.
name|value
argument_list|()
operator|->
name|prefix
operator|<<
literal|"=\""
operator|<<
name|encodeText
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|namespaceURI
argument_list|,
name|s
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
operator|<<
literal|'\"'
expr_stmt|;
name|outputtedPrefixes
operator|.
name|insert
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|prefix
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|last
condition|)
block|{
comment|// has child nodes
if|if
condition|(
name|first
operator|->
name|isText
argument_list|()
condition|)
name|s
operator|<<
literal|'>'
expr_stmt|;
else|else
block|{
name|s
operator|<<
literal|'>'
expr_stmt|;
comment|/* -1 disables new lines. */
if|if
condition|(
name|indent
operator|!=
operator|-
literal|1
condition|)
name|s
operator|<<
name|endl
expr_stmt|;
block|}
name|QDomNodePrivate
operator|::
name|save
argument_list|(
name|s
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|last
operator|->
name|isText
argument_list|()
condition|)
name|s
operator|<<
name|QString
argument_list|(
name|indent
operator|<
literal|1
condition|?
literal|0
else|:
name|depth
operator|*
name|indent
argument_list|,
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|<<
literal|"</"
operator|<<
name|qName
operator|<<
literal|'>'
expr_stmt|;
block|}
else|else
block|{
name|s
operator|<<
literal|"/>"
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|next
operator|&&
name|next
operator|->
name|isText
argument_list|()
operator|)
condition|)
block|{
comment|/* -1 disables new lines. */
if|if
condition|(
name|indent
operator|!=
operator|-
literal|1
condition|)
name|s
operator|<<
name|endl
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomElement  *  **************************************************************/
end_comment
begin_define
DECL|macro|IMPL
define|#
directive|define
name|IMPL
value|((QDomElementPrivate*)impl)
end_define
begin_comment
comment|/*!     \class QDomElement     \reentrant     \brief The QDomElement class represents one element in the DOM tree.      \inmodule QtXml     \ingroup xml-tools      Elements have a tagName() and zero or more attributes associated     with them. The tag name can be changed with setTagName().      Element attributes are represented by QDomAttr objects that can     be queried using the attribute() and attributeNode() functions.     You can set attributes with the setAttribute() and     setAttributeNode() functions. Attributes can be removed with     removeAttribute(). There are namespace-aware equivalents to these     functions, i.e. setAttributeNS(), setAttributeNodeNS() and     removeAttributeNS().      If you want to access the text of a node use text(), e.g.     \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 9     The text() function operates recursively to find the text (since     not all elements contain text). If you want to find all the text     in all of a node's children, iterate over the children looking for     QDomText nodes, e.g.     \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 10     Note that we attempt to convert each node to a text node and use     text() rather than using firstChild().toText().data() or     n.toText().data() directly on the node, because the node may not     be a text element.      You can get a list of all the decendents of an element which have     a specified tag name with elementsByTagName() or     elementsByTagNameNS().      To browse the elements of a dom document use firstChildElement(), lastChildElement(),     nextSiblingElement() and previousSiblingElement(). For example, to iterate over all     child elements called "entry" in a root element called "database", you can use:     \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 11      For further information about the Document Object Model see     \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and     \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.     For a more general introduction of the DOM implementation see the     QDomDocument documentation. */
end_comment
begin_comment
comment|/*!     Constructs an empty element. Use the QDomDocument::createElement()     function to construct elements with content. */
end_comment
begin_constructor
DECL|function|QDomElement
name|QDomElement
operator|::
name|QDomElement
parameter_list|()
member_init_list|:
name|QDomNode
argument_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a x.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_constructor
DECL|function|QDomElement
name|QDomElement
operator|::
name|QDomElement
parameter_list|(
specifier|const
name|QDomElement
modifier|&
name|x
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|x
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QDomElement
name|QDomElement
operator|::
name|QDomElement
parameter_list|(
name|QDomElementPrivate
modifier|*
name|n
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|n
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns \a x to this DOM element.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_function
DECL|function|operator =
name|QDomElement
modifier|&
name|QDomElement
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomElement
modifier|&
name|x
parameter_list|)
block|{
return|return
operator|(
name|QDomElement
operator|&
operator|)
name|QDomNode
operator|::
name|operator
name|=
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDomNode::NodeType QDomElement::nodeType() const      Returns \c ElementNode. */
end_comment
begin_comment
comment|/*!     Sets this element's tag name to \a name.      \sa tagName() */
end_comment
begin_function
DECL|function|setTagName
name|void
name|QDomElement
operator|::
name|setTagName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|impl
condition|)
name|impl
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the tag name of this element. For an XML element like this:      \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 12      the tagname would return "img".      \sa setTagName() */
end_comment
begin_function
DECL|function|tagName
name|QString
name|QDomElement
operator|::
name|tagName
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|impl
operator|->
name|nodeName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDomNamedNodeMap containing all this element's attributes.      \sa attribute() setAttribute() attributeNode() setAttributeNode() */
end_comment
begin_function
DECL|function|attributes
name|QDomNamedNodeMap
name|QDomElement
operator|::
name|attributes
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomNamedNodeMap
argument_list|()
return|;
return|return
name|QDomNamedNodeMap
argument_list|(
name|IMPL
operator|->
name|attributes
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the attribute called \a name. If the attribute does not     exist \a defValue is returned.      \sa setAttribute() attributeNode() setAttributeNode() attributeNS() */
end_comment
begin_function
DECL|function|attribute
name|QString
name|QDomElement
operator|::
name|attribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|defValue
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|defValue
return|;
return|return
name|IMPL
operator|->
name|attribute
argument_list|(
name|name
argument_list|,
name|defValue
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Adds an attribute called \a name with value \a value. If an     attribute with the same name exists, its value is replaced by \a     value.      \sa attribute() setAttributeNode() setAttributeNS() */
end_comment
begin_function
DECL|function|setAttribute
name|void
name|QDomElement
operator|::
name|setAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|IMPL
operator|->
name|setAttribute
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \fn void QDomElement::setAttribute(const QString& name, int value)      \overload     The number is formatted according to the current locale. */
end_comment
begin_comment
comment|/*!   \fn void QDomElement::setAttribute(const QString& name, uint value)      \overload     The number is formatted according to the current locale. */
end_comment
begin_comment
comment|/*!     \overload      The number is formatted according to the current locale. */
end_comment
begin_function
DECL|function|setAttribute
name|void
name|QDomElement
operator|::
name|setAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|qlonglong
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|QString
name|x
decl_stmt|;
name|x
operator|.
name|setNum
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|IMPL
operator|->
name|setAttribute
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      The number is formatted according to the current locale. */
end_comment
begin_function
DECL|function|setAttribute
name|void
name|QDomElement
operator|::
name|setAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|qulonglong
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|QString
name|x
decl_stmt|;
name|x
operator|.
name|setNum
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|IMPL
operator|->
name|setAttribute
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      The number is formatted according to the current locale. */
end_comment
begin_function
DECL|function|setAttribute
name|void
name|QDomElement
operator|::
name|setAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|float
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|QString
name|x
decl_stmt|;
name|x
operator|.
name|setNum
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|IMPL
operator|->
name|setAttribute
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      The number is formatted according to the current locale. */
end_comment
begin_function
DECL|function|setAttribute
name|void
name|QDomElement
operator|::
name|setAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|double
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|QString
name|x
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|count
init|=
name|qsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%.16g"
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|x
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|else
name|x
operator|.
name|setNum
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|// Fallback
name|IMPL
operator|->
name|setAttribute
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes the attribute called name \a name from this element.      \sa setAttribute() attribute() removeAttributeNS() */
end_comment
begin_function
DECL|function|removeAttribute
name|void
name|QDomElement
operator|::
name|removeAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|IMPL
operator|->
name|removeAttribute
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the QDomAttr object that corresponds to the attribute     called \a name. If no such attribute exists a \link     QDomNode::isNull() null attribute\endlink is returned.      \sa setAttributeNode() attribute() setAttribute() attributeNodeNS() */
end_comment
begin_function
DECL|function|attributeNode
name|QDomAttr
name|QDomElement
operator|::
name|attributeNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomAttr
argument_list|()
return|;
return|return
name|QDomAttr
argument_list|(
name|IMPL
operator|->
name|attributeNode
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Adds the attribute \a newAttr to this element.      If the element has another attribute that has the same name as \a     newAttr, this function replaces that attribute and returns it;     otherwise the function returns a \link QDomNode::isNull() null     attribute\endlink.      \sa attributeNode() setAttribute() setAttributeNodeNS() */
end_comment
begin_function
DECL|function|setAttributeNode
name|QDomAttr
name|QDomElement
operator|::
name|setAttributeNode
parameter_list|(
specifier|const
name|QDomAttr
modifier|&
name|newAttr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomAttr
argument_list|()
return|;
return|return
name|QDomAttr
argument_list|(
name|IMPL
operator|->
name|setAttributeNode
argument_list|(
operator|(
operator|(
name|QDomAttrPrivate
operator|*
operator|)
name|newAttr
operator|.
name|impl
operator|)
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the attribute \a oldAttr from the element and returns it.      \sa attributeNode() setAttributeNode() */
end_comment
begin_function
DECL|function|removeAttributeNode
name|QDomAttr
name|QDomElement
operator|::
name|removeAttributeNode
parameter_list|(
specifier|const
name|QDomAttr
modifier|&
name|oldAttr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomAttr
argument_list|()
return|;
comment|// ### should this return oldAttr?
return|return
name|QDomAttr
argument_list|(
name|IMPL
operator|->
name|removeAttributeNode
argument_list|(
operator|(
operator|(
name|QDomAttrPrivate
operator|*
operator|)
name|oldAttr
operator|.
name|impl
operator|)
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a QDomNodeList containing all descendants of this element   named \a tagname encountered during a preorder traversal of the   element subtree with this element as its root. The order of the   elements in the returned list is the order they are encountered   during the preorder traversal.    \sa elementsByTagNameNS() QDomDocument::elementsByTagName() */
end_comment
begin_function
DECL|function|elementsByTagName
name|QDomNodeList
name|QDomElement
operator|::
name|elementsByTagName
parameter_list|(
specifier|const
name|QString
modifier|&
name|tagname
parameter_list|)
specifier|const
block|{
return|return
name|QDomNodeList
argument_list|(
operator|new
name|QDomNodeListPrivate
argument_list|(
name|impl
argument_list|,
name|tagname
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if this element has an attribute called \a name;   otherwise returns false.    \bold{Note:} This function does not take the presence of namespaces   into account.  As a result, the specified name will be tested   against fully-qualified attribute names that include any namespace   prefixes that may be present.    Use hasAttributeNS() to explicitly test for attributes with specific   namespaces and names. */
end_comment
begin_function
DECL|function|hasAttribute
name|bool
name|QDomElement
operator|::
name|hasAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
literal|false
return|;
return|return
name|IMPL
operator|->
name|hasAttribute
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the attribute with the local name \a localName and the     namespace URI \a nsURI. If the attribute does not exist \a     defValue is returned.      \sa setAttributeNS() attributeNodeNS() setAttributeNodeNS() attribute() */
end_comment
begin_function
DECL|function|attributeNS
name|QString
name|QDomElement
operator|::
name|attributeNS
parameter_list|(
specifier|const
name|QString
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|,
specifier|const
name|QString
modifier|&
name|defValue
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|defValue
return|;
return|return
name|IMPL
operator|->
name|attributeNS
argument_list|(
name|nsURI
argument_list|,
name|localName
argument_list|,
name|defValue
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Adds an attribute with the qualified name \a qName and the     namespace URI \a nsURI with the value \a value. If an attribute     with the same local name and namespace URI exists, its prefix is     replaced by the prefix of \a qName and its value is repaced by \a     value.      Although \a qName is the qualified name, the local name is used to     decide if an existing attribute's value should be replaced.      \sa attributeNS() setAttributeNodeNS() setAttribute() */
end_comment
begin_function
DECL|function|setAttributeNS
name|void
name|QDomElement
operator|::
name|setAttributeNS
parameter_list|(
specifier|const
name|QString
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|IMPL
operator|->
name|setAttributeNS
argument_list|(
name|nsURI
argument_list|,
name|qName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \fn void QDomElement::setAttributeNS(const QString nsURI, const QString& qName, int value)      \overload */
end_comment
begin_comment
comment|/*!   \fn void QDomElement::setAttributeNS(const QString nsURI, const QString& qName, uint value)      \overload */
end_comment
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|setAttributeNS
name|void
name|QDomElement
operator|::
name|setAttributeNS
parameter_list|(
specifier|const
name|QString
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|,
name|qlonglong
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|QString
name|x
decl_stmt|;
name|x
operator|.
name|setNum
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|IMPL
operator|->
name|setAttributeNS
argument_list|(
name|nsURI
argument_list|,
name|qName
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|setAttributeNS
name|void
name|QDomElement
operator|::
name|setAttributeNS
parameter_list|(
specifier|const
name|QString
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|,
name|qulonglong
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|QString
name|x
decl_stmt|;
name|x
operator|.
name|setNum
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|IMPL
operator|->
name|setAttributeNS
argument_list|(
name|nsURI
argument_list|,
name|qName
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|setAttributeNS
name|void
name|QDomElement
operator|::
name|setAttributeNS
parameter_list|(
specifier|const
name|QString
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|,
name|double
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|QString
name|x
decl_stmt|;
name|x
operator|.
name|setNum
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|IMPL
operator|->
name|setAttributeNS
argument_list|(
name|nsURI
argument_list|,
name|qName
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes the attribute with the local name \a localName and the     namespace URI \a nsURI from this element.      \sa setAttributeNS() attributeNS() removeAttribute() */
end_comment
begin_function
DECL|function|removeAttributeNS
name|void
name|QDomElement
operator|::
name|removeAttributeNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|QDomNodePrivate
modifier|*
name|n
init|=
name|IMPL
operator|->
name|attributeNodeNS
argument_list|(
name|nsURI
argument_list|,
name|localName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return;
name|IMPL
operator|->
name|removeAttribute
argument_list|(
name|n
operator|->
name|nodeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the QDomAttr object that corresponds to the attribute     with the local name \a localName and the namespace URI \a nsURI.     If no such attribute exists a \l{QDomNode::isNull()}{null     attribute} is returned.      \sa setAttributeNode() attribute() setAttribute() */
end_comment
begin_function
DECL|function|attributeNodeNS
name|QDomAttr
name|QDomElement
operator|::
name|attributeNodeNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomAttr
argument_list|()
return|;
return|return
name|QDomAttr
argument_list|(
name|IMPL
operator|->
name|attributeNodeNS
argument_list|(
name|nsURI
argument_list|,
name|localName
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Adds the attribute \a newAttr to this element.      If the element has another attribute that has the same local name     and namespace URI as \a newAttr, this function replaces that     attribute and returns it; otherwise the function returns a \link     QDomNode::isNull() null attribute\endlink.      \sa attributeNodeNS() setAttributeNS() setAttributeNode() */
end_comment
begin_function
DECL|function|setAttributeNodeNS
name|QDomAttr
name|QDomElement
operator|::
name|setAttributeNodeNS
parameter_list|(
specifier|const
name|QDomAttr
modifier|&
name|newAttr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomAttr
argument_list|()
return|;
return|return
name|QDomAttr
argument_list|(
name|IMPL
operator|->
name|setAttributeNodeNS
argument_list|(
operator|(
operator|(
name|QDomAttrPrivate
operator|*
operator|)
name|newAttr
operator|.
name|impl
operator|)
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a QDomNodeList containing all descendants of this element   with local name \a localName and namespace URI \a nsURI encountered   during a preorder traversal of the element subtree with this element   as its root. The order of the elements in the returned list is the   order they are encountered during the preorder traversal.    \sa elementsByTagName() QDomDocument::elementsByTagNameNS() */
end_comment
begin_function
DECL|function|elementsByTagNameNS
name|QDomNodeList
name|QDomElement
operator|::
name|elementsByTagNameNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
specifier|const
block|{
return|return
name|QDomNodeList
argument_list|(
operator|new
name|QDomNodeListPrivate
argument_list|(
name|impl
argument_list|,
name|nsURI
argument_list|,
name|localName
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this element has an attribute with the local name     \a localName and the namespace URI \a nsURI; otherwise returns     false. */
end_comment
begin_function
DECL|function|hasAttributeNS
name|bool
name|QDomElement
operator|::
name|hasAttributeNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
literal|false
return|;
return|return
name|IMPL
operator|->
name|hasAttributeNS
argument_list|(
name|nsURI
argument_list|,
name|localName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the element's text or an empty string.      Example:     \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 13      The function text() of the QDomElement for the \c{<h1>} tag,     will return the following text:      \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 14      Comments are ignored by this function. It only evaluates QDomText     and QDomCDATASection objects. */
end_comment
begin_function
DECL|function|text
name|QString
name|QDomElement
operator|::
name|text
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|text
argument_list|()
return|;
block|}
end_function
begin_undef
DECL|macro|IMPL
undef|#
directive|undef
name|IMPL
end_undef
begin_comment
comment|/**************************************************************  *  * QDomTextPrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomTextPrivate
name|QDomTextPrivate
operator|::
name|QDomTextPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|d
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|val
parameter_list|)
member_init_list|:
name|QDomCharacterDataPrivate
argument_list|(
name|d
argument_list|,
name|parent
argument_list|,
name|val
argument_list|)
block|{
name|name
operator|=
name|QLatin1String
argument_list|(
literal|"#text"
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomTextPrivate
name|QDomTextPrivate
operator|::
name|QDomTextPrivate
parameter_list|(
name|QDomTextPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
member_init_list|:
name|QDomCharacterDataPrivate
argument_list|(
name|n
argument_list|,
name|deep
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|cloneNode
name|QDomNodePrivate
modifier|*
name|QDomTextPrivate
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
operator|new
name|QDomTextPrivate
argument_list|(
name|this
argument_list|,
name|deep
argument_list|)
decl_stmt|;
comment|// We are not interested in this node
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|splitText
name|QDomTextPrivate
modifier|*
name|QDomTextPrivate
operator|::
name|splitText
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
name|parent
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDomText::splitText  The node has no parent. So I can not split"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|QDomTextPrivate
modifier|*
name|t
init|=
operator|new
name|QDomTextPrivate
argument_list|(
name|ownerDocument
argument_list|()
argument_list|,
literal|0
argument_list|,
name|value
operator|.
name|mid
argument_list|(
name|offset
argument_list|)
argument_list|)
decl_stmt|;
name|value
operator|.
name|truncate
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|parent
argument_list|()
operator|->
name|insertAfter
argument_list|(
name|t
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function
begin_function
DECL|function|save
name|void
name|QDomTextPrivate
operator|::
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
block|{
name|QDomTextPrivate
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QDomTextPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|s
operator|<<
name|encodeText
argument_list|(
name|value
argument_list|,
name|s
argument_list|,
operator|!
operator|(
name|that
operator|->
name|parent
argument_list|()
operator|&&
name|that
operator|->
name|parent
argument_list|()
operator|->
name|isElement
argument_list|()
operator|)
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomText  *  **************************************************************/
end_comment
begin_define
DECL|macro|IMPL
define|#
directive|define
name|IMPL
value|((QDomTextPrivate*)impl)
end_define
begin_comment
comment|/*!     \class QDomText     \reentrant     \brief The QDomText class represents text data in the parsed XML document.      \inmodule QtXml     \ingroup xml-tools      You can split the text in a QDomText object over two QDomText     objecs with splitText().      For further information about the Document Object Model see     \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and     \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.     For a more general introduction of the DOM implementation see the     QDomDocument documentation. */
end_comment
begin_comment
comment|/*!     Constructs an empty QDomText object.      To construct a QDomText with content, use QDomDocument::createTextNode(). */
end_comment
begin_constructor
DECL|function|QDomText
name|QDomText
operator|::
name|QDomText
parameter_list|()
member_init_list|:
name|QDomCharacterData
argument_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a x.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_constructor
DECL|function|QDomText
name|QDomText
operator|::
name|QDomText
parameter_list|(
specifier|const
name|QDomText
modifier|&
name|x
parameter_list|)
member_init_list|:
name|QDomCharacterData
argument_list|(
name|x
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QDomText
name|QDomText
operator|::
name|QDomText
parameter_list|(
name|QDomTextPrivate
modifier|*
name|n
parameter_list|)
member_init_list|:
name|QDomCharacterData
argument_list|(
name|n
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns \a x to this DOM text.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_function
DECL|function|operator =
name|QDomText
modifier|&
name|QDomText
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomText
modifier|&
name|x
parameter_list|)
block|{
return|return
operator|(
name|QDomText
operator|&
operator|)
name|QDomNode
operator|::
name|operator
name|=
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDomNode::NodeType QDomText::nodeType() const      Returns \c TextNode. */
end_comment
begin_comment
comment|/*!     Splits this DOM text object into two QDomText objects. This object     keeps its first \a offset characters and the second (newly     created) object is inserted into the document tree after this     object with the remaining characters.      The function returns the newly created object.      \sa QDomNode::normalize() */
end_comment
begin_function
DECL|function|splitText
name|QDomText
name|QDomText
operator|::
name|splitText
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomText
argument_list|()
return|;
return|return
name|QDomText
argument_list|(
name|IMPL
operator|->
name|splitText
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_undef
DECL|macro|IMPL
undef|#
directive|undef
name|IMPL
end_undef
begin_comment
comment|/**************************************************************  *  * QDomCommentPrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomCommentPrivate
name|QDomCommentPrivate
operator|::
name|QDomCommentPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|d
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|val
parameter_list|)
member_init_list|:
name|QDomCharacterDataPrivate
argument_list|(
name|d
argument_list|,
name|parent
argument_list|,
name|val
argument_list|)
block|{
name|name
operator|=
name|QLatin1String
argument_list|(
literal|"#comment"
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomCommentPrivate
name|QDomCommentPrivate
operator|::
name|QDomCommentPrivate
parameter_list|(
name|QDomCommentPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
member_init_list|:
name|QDomCharacterDataPrivate
argument_list|(
name|n
argument_list|,
name|deep
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|cloneNode
name|QDomNodePrivate
modifier|*
name|QDomCommentPrivate
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
operator|new
name|QDomCommentPrivate
argument_list|(
name|this
argument_list|,
name|deep
argument_list|)
decl_stmt|;
comment|// We are not interested in this node
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|save
name|void
name|QDomCommentPrivate
operator|::
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|indent
parameter_list|)
specifier|const
block|{
comment|/* We don't output whitespace if we would pollute a text node. */
if|if
condition|(
operator|!
operator|(
name|prev
operator|&&
name|prev
operator|->
name|isText
argument_list|()
operator|)
condition|)
name|s
operator|<<
name|QString
argument_list|(
name|indent
operator|<
literal|1
condition|?
literal|0
else|:
name|depth
operator|*
name|indent
argument_list|,
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|<<
literal|"<!--"
operator|<<
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
condition|)
name|s
operator|<<
literal|' '
expr_stmt|;
comment|// Ensures that XML comment doesn't end with --->
name|s
operator|<<
literal|"-->"
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|next
operator|&&
name|next
operator|->
name|isText
argument_list|()
operator|)
condition|)
name|s
operator|<<
name|endl
expr_stmt|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomComment  *  **************************************************************/
end_comment
begin_comment
comment|/*!     \class QDomComment     \reentrant     \brief The QDomComment class represents an XML comment.      \inmodule QtXml     \ingroup xml-tools      A comment in the parsed XML such as this:     \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 15     is represented by QDomComment objects in the parsed Dom tree.      For further information about the Document Object Model see     \l{http://www.w3.org/TR/REC-DOM-Level-1/} and     \l{http://www.w3.org/TR/DOM-Level-2-Core/}.     For a more general introduction of the DOM implementation see the     QDomDocument documentation. */
end_comment
begin_comment
comment|/*!     Constructs an empty comment. To construct a comment with content,     use the QDomDocument::createComment() function. */
end_comment
begin_constructor
DECL|function|QDomComment
name|QDomComment
operator|::
name|QDomComment
parameter_list|()
member_init_list|:
name|QDomCharacterData
argument_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a x.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_constructor
DECL|function|QDomComment
name|QDomComment
operator|::
name|QDomComment
parameter_list|(
specifier|const
name|QDomComment
modifier|&
name|x
parameter_list|)
member_init_list|:
name|QDomCharacterData
argument_list|(
name|x
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QDomComment
name|QDomComment
operator|::
name|QDomComment
parameter_list|(
name|QDomCommentPrivate
modifier|*
name|n
parameter_list|)
member_init_list|:
name|QDomCharacterData
argument_list|(
name|n
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns \a x to this DOM comment.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_function
DECL|function|operator =
name|QDomComment
modifier|&
name|QDomComment
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomComment
modifier|&
name|x
parameter_list|)
block|{
return|return
operator|(
name|QDomComment
operator|&
operator|)
name|QDomNode
operator|::
name|operator
name|=
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDomNode::NodeType QDomComment::nodeType() const      Returns \c CommentNode. */
end_comment
begin_comment
comment|/**************************************************************  *  * QDomCDATASectionPrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomCDATASectionPrivate
name|QDomCDATASectionPrivate
operator|::
name|QDomCDATASectionPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|d
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|val
parameter_list|)
member_init_list|:
name|QDomTextPrivate
argument_list|(
name|d
argument_list|,
name|parent
argument_list|,
name|val
argument_list|)
block|{
name|name
operator|=
name|QLatin1String
argument_list|(
literal|"#cdata-section"
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomCDATASectionPrivate
name|QDomCDATASectionPrivate
operator|::
name|QDomCDATASectionPrivate
parameter_list|(
name|QDomCDATASectionPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
member_init_list|:
name|QDomTextPrivate
argument_list|(
name|n
argument_list|,
name|deep
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|cloneNode
name|QDomNodePrivate
modifier|*
name|QDomCDATASectionPrivate
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
operator|new
name|QDomCDATASectionPrivate
argument_list|(
name|this
argument_list|,
name|deep
argument_list|)
decl_stmt|;
comment|// We are not interested in this node
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|save
name|void
name|QDomCDATASectionPrivate
operator|::
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
block|{
comment|// ### How do we escape "]]>" ?
comment|// "]]>" is not allowed; so there should be none in value anyway
name|s
operator|<<
literal|"<![CDATA["
operator|<<
name|value
operator|<<
literal|"]]>"
expr_stmt|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomCDATASection  *  **************************************************************/
end_comment
begin_comment
comment|/*!     \class QDomCDATASection     \reentrant     \brief The QDomCDATASection class represents an XML CDATA section.      \inmodule QtXml     \ingroup xml-tools      CDATA sections are used to escape blocks of text containing     characters that would otherwise be regarded as markup. The only     delimiter that is recognized in a CDATA section is the "]]&gt;"     string that terminates the CDATA section. CDATA sections cannot be     nested. Their primary purpose is for including material such as     XML fragments, without needing to escape all the delimiters.      Adjacent QDomCDATASection nodes are not merged by the     QDomNode::normalize() function.      For further information about the Document Object Model see     \l{http://www.w3.org/TR/REC-DOM-Level-1/} and     \l{http://www.w3.org/TR/DOM-Level-2-Core/}.     For a more general introduction of the DOM implementation see the     QDomDocument documentation. */
end_comment
begin_comment
comment|/*!     Constructs an empty CDATA section. To create a CDATA section with     content, use the QDomDocument::createCDATASection() function. */
end_comment
begin_constructor
DECL|function|QDomCDATASection
name|QDomCDATASection
operator|::
name|QDomCDATASection
parameter_list|()
member_init_list|:
name|QDomText
argument_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a x.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_constructor
DECL|function|QDomCDATASection
name|QDomCDATASection
operator|::
name|QDomCDATASection
parameter_list|(
specifier|const
name|QDomCDATASection
modifier|&
name|x
parameter_list|)
member_init_list|:
name|QDomText
argument_list|(
name|x
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QDomCDATASection
name|QDomCDATASection
operator|::
name|QDomCDATASection
parameter_list|(
name|QDomCDATASectionPrivate
modifier|*
name|n
parameter_list|)
member_init_list|:
name|QDomText
argument_list|(
name|n
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns \a x to this CDATA section.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_function
DECL|function|operator =
name|QDomCDATASection
modifier|&
name|QDomCDATASection
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomCDATASection
modifier|&
name|x
parameter_list|)
block|{
return|return
operator|(
name|QDomCDATASection
operator|&
operator|)
name|QDomNode
operator|::
name|operator
name|=
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDomNode::NodeType QDomCDATASection::nodeType() const      Returns \c CDATASection. */
end_comment
begin_comment
comment|/**************************************************************  *  * QDomNotationPrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomNotationPrivate
name|QDomNotationPrivate
operator|::
name|QDomNotationPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|d
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|aname
parameter_list|,
specifier|const
name|QString
modifier|&
name|pub
parameter_list|,
specifier|const
name|QString
modifier|&
name|sys
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|d
argument_list|,
name|parent
argument_list|)
block|{
name|name
operator|=
name|aname
expr_stmt|;
name|m_pub
operator|=
name|pub
expr_stmt|;
name|m_sys
operator|=
name|sys
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomNotationPrivate
name|QDomNotationPrivate
operator|::
name|QDomNotationPrivate
parameter_list|(
name|QDomNotationPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|n
argument_list|,
name|deep
argument_list|)
block|{
name|m_sys
operator|=
name|n
operator|->
name|m_sys
expr_stmt|;
name|m_pub
operator|=
name|n
operator|->
name|m_pub
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|cloneNode
name|QDomNodePrivate
modifier|*
name|QDomNotationPrivate
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
operator|new
name|QDomNotationPrivate
argument_list|(
name|this
argument_list|,
name|deep
argument_list|)
decl_stmt|;
comment|// We are not interested in this node
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|save
name|void
name|QDomNotationPrivate
operator|::
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
block|{
name|s
operator|<<
literal|"<!NOTATION "
operator|<<
name|name
operator|<<
literal|' '
expr_stmt|;
if|if
condition|(
operator|!
name|m_pub
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|s
operator|<<
literal|"PUBLIC "
operator|<<
name|quotedValue
argument_list|(
name|m_pub
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_sys
operator|.
name|isNull
argument_list|()
condition|)
name|s
operator|<<
literal|' '
operator|<<
name|quotedValue
argument_list|(
name|m_sys
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|<<
literal|"SYSTEM "
operator|<<
name|quotedValue
argument_list|(
name|m_sys
argument_list|)
expr_stmt|;
block|}
name|s
operator|<<
literal|'>'
operator|<<
name|endl
expr_stmt|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomNotation  *  **************************************************************/
end_comment
begin_define
DECL|macro|IMPL
define|#
directive|define
name|IMPL
value|((QDomNotationPrivate*)impl)
end_define
begin_comment
comment|/*!     \class QDomNotation     \reentrant     \brief The QDomNotation class represents an XML notation.      \inmodule QtXml     \ingroup xml-tools      A notation either declares, by name, the format of an unparsed     entity (see section 4.7 of the XML 1.0 specification), or is used     for formal declaration of processing instruction targets (see     section 2.6 of the XML 1.0 specification).      DOM does not support editing notation nodes; they are therefore     read-only.      A notation node does not have any parent.      You can retrieve the publicId() and systemId() from a notation     node.      For further information about the Document Object Model see     \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and     \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.     For a more general introduction of the DOM implementation see the     QDomDocument documentation. */
end_comment
begin_comment
comment|/*!     Constructor. */
end_comment
begin_constructor
DECL|function|QDomNotation
name|QDomNotation
operator|::
name|QDomNotation
parameter_list|()
member_init_list|:
name|QDomNode
argument_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a x.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_constructor
DECL|function|QDomNotation
name|QDomNotation
operator|::
name|QDomNotation
parameter_list|(
specifier|const
name|QDomNotation
modifier|&
name|x
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|x
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QDomNotation
name|QDomNotation
operator|::
name|QDomNotation
parameter_list|(
name|QDomNotationPrivate
modifier|*
name|n
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|n
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns \a x to this DOM notation.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_function
DECL|function|operator =
name|QDomNotation
modifier|&
name|QDomNotation
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomNotation
modifier|&
name|x
parameter_list|)
block|{
return|return
operator|(
name|QDomNotation
operator|&
operator|)
name|QDomNode
operator|::
name|operator
name|=
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDomNode::NodeType QDomNotation::nodeType() const      Returns \c NotationNode. */
end_comment
begin_comment
comment|/*!     Returns the public identifier of this notation. */
end_comment
begin_function
DECL|function|publicId
name|QString
name|QDomNotation
operator|::
name|publicId
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|m_pub
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the system identifier of this notation. */
end_comment
begin_function
DECL|function|systemId
name|QString
name|QDomNotation
operator|::
name|systemId
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|m_sys
return|;
block|}
end_function
begin_undef
DECL|macro|IMPL
undef|#
directive|undef
name|IMPL
end_undef
begin_comment
comment|/**************************************************************  *  * QDomEntityPrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomEntityPrivate
name|QDomEntityPrivate
operator|::
name|QDomEntityPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|d
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|aname
parameter_list|,
specifier|const
name|QString
modifier|&
name|pub
parameter_list|,
specifier|const
name|QString
modifier|&
name|sys
parameter_list|,
specifier|const
name|QString
modifier|&
name|notation
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|d
argument_list|,
name|parent
argument_list|)
block|{
name|name
operator|=
name|aname
expr_stmt|;
name|m_pub
operator|=
name|pub
expr_stmt|;
name|m_sys
operator|=
name|sys
expr_stmt|;
name|m_notationName
operator|=
name|notation
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomEntityPrivate
name|QDomEntityPrivate
operator|::
name|QDomEntityPrivate
parameter_list|(
name|QDomEntityPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|n
argument_list|,
name|deep
argument_list|)
block|{
name|m_sys
operator|=
name|n
operator|->
name|m_sys
expr_stmt|;
name|m_pub
operator|=
name|n
operator|->
name|m_pub
expr_stmt|;
name|m_notationName
operator|=
name|n
operator|->
name|m_notationName
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|cloneNode
name|QDomNodePrivate
modifier|*
name|QDomEntityPrivate
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
operator|new
name|QDomEntityPrivate
argument_list|(
name|this
argument_list|,
name|deep
argument_list|)
decl_stmt|;
comment|// We are not interested in this node
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_comment
comment|/*   Encode an entity value upon saving. */
end_comment
begin_function
DECL|function|encodeEntity
specifier|static
name|QByteArray
name|encodeEntity
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|str
parameter_list|)
block|{
name|QByteArray
name|tmp
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|uint
name|len
init|=
name|tmp
operator|.
name|size
argument_list|()
decl_stmt|;
name|uint
name|i
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
init|=
name|tmp
operator|.
name|data
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|d
index|[
name|i
index|]
operator|==
literal|'%'
condition|)
block|{
name|tmp
operator|.
name|replace
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
literal|"&#60;"
argument_list|)
expr_stmt|;
name|d
operator|=
name|tmp
expr_stmt|;
name|len
operator|+=
literal|4
expr_stmt|;
name|i
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
index|[
name|i
index|]
operator|==
literal|'"'
condition|)
block|{
name|tmp
operator|.
name|replace
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
literal|"&#34;"
argument_list|)
expr_stmt|;
name|d
operator|=
name|tmp
expr_stmt|;
name|len
operator|+=
literal|4
expr_stmt|;
name|i
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
index|[
name|i
index|]
operator|==
literal|'&'
operator|&&
name|i
operator|+
literal|1
operator|<
name|len
operator|&&
name|d
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'#'
condition|)
block|{
comment|// Dont encode&lt; or&quot; or&custom;.
comment|// Only encode character references
name|tmp
operator|.
name|replace
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
literal|"&#38;"
argument_list|)
expr_stmt|;
name|d
operator|=
name|tmp
expr_stmt|;
name|len
operator|+=
literal|4
expr_stmt|;
name|i
operator|+=
literal|5
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
return|return
name|tmp
return|;
block|}
end_function
begin_function
DECL|function|save
name|void
name|QDomEntityPrivate
operator|::
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
block|{
name|QString
name|_name
init|=
name|name
decl_stmt|;
if|if
condition|(
name|_name
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
argument_list|)
condition|)
name|_name
operator|=
name|QLatin1String
argument_list|(
literal|"% "
argument_list|)
operator|+
name|_name
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_sys
operator|.
name|isNull
argument_list|()
operator|&&
name|m_pub
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|s
operator|<<
literal|"<!ENTITY "
operator|<<
name|_name
operator|<<
literal|" \""
operator|<<
name|encodeEntity
argument_list|(
name|value
operator|.
name|toUtf8
argument_list|()
argument_list|)
operator|<<
literal|"\">"
operator|<<
name|endl
expr_stmt|;
block|}
else|else
block|{
name|s
operator|<<
literal|"<!ENTITY "
operator|<<
name|_name
operator|<<
literal|' '
expr_stmt|;
if|if
condition|(
name|m_pub
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|s
operator|<<
literal|"SYSTEM "
operator|<<
name|quotedValue
argument_list|(
name|m_sys
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|<<
literal|"PUBLIC "
operator|<<
name|quotedValue
argument_list|(
name|m_pub
argument_list|)
operator|<<
literal|' '
operator|<<
name|quotedValue
argument_list|(
name|m_sys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|m_notationName
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|s
operator|<<
literal|" NDATA "
operator|<<
name|m_notationName
expr_stmt|;
block|}
name|s
operator|<<
literal|'>'
operator|<<
name|endl
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomEntity  *  **************************************************************/
end_comment
begin_define
DECL|macro|IMPL
define|#
directive|define
name|IMPL
value|((QDomEntityPrivate*)impl)
end_define
begin_comment
comment|/*!     \class QDomEntity     \reentrant     \brief The QDomEntity class represents an XML entity.      \inmodule QtXml     \ingroup xml-tools      This class represents an entity in an XML document, either parsed     or unparsed. Note that this models the entity itself not the     entity declaration.      DOM does not support editing entity nodes; if a user wants to make     changes to the contents of an entity, every related     QDomEntityReference node must be replaced in the DOM tree by a     clone of the entity's contents, and then the desired changes must     be made to each of the clones instead. All the descendants of an     entity node are read-only.      An entity node does not have any parent.      You can access the entity's publicId(), systemId() and     notationName() when available.      For further information about the Document Object Model see     \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and     \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.     For a more general introduction of the DOM implementation see the     QDomDocument documentation. */
end_comment
begin_comment
comment|/*!     Constructs an empty entity. */
end_comment
begin_constructor
DECL|function|QDomEntity
name|QDomEntity
operator|::
name|QDomEntity
parameter_list|()
member_init_list|:
name|QDomNode
argument_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a x.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_constructor
DECL|function|QDomEntity
name|QDomEntity
operator|::
name|QDomEntity
parameter_list|(
specifier|const
name|QDomEntity
modifier|&
name|x
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|x
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QDomEntity
name|QDomEntity
operator|::
name|QDomEntity
parameter_list|(
name|QDomEntityPrivate
modifier|*
name|n
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|n
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns \a x to this DOM entity.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_function
DECL|function|operator =
name|QDomEntity
modifier|&
name|QDomEntity
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomEntity
modifier|&
name|x
parameter_list|)
block|{
return|return
operator|(
name|QDomEntity
operator|&
operator|)
name|QDomNode
operator|::
name|operator
name|=
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDomNode::NodeType QDomEntity::nodeType() const      Returns \c EntityNode. */
end_comment
begin_comment
comment|/*!     Returns the public identifier associated with this entity. If the     public identifier was not specified an empty string is returned. */
end_comment
begin_function
DECL|function|publicId
name|QString
name|QDomEntity
operator|::
name|publicId
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|m_pub
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the system identifier associated with this entity. If the     system identifier was not specified an empty string is returned. */
end_comment
begin_function
DECL|function|systemId
name|QString
name|QDomEntity
operator|::
name|systemId
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|m_sys
return|;
block|}
end_function
begin_comment
comment|/*!     For unparsed entities this function returns the name of the     notation for the entity. For parsed entities this function returns     an empty string. */
end_comment
begin_function
DECL|function|notationName
name|QString
name|QDomEntity
operator|::
name|notationName
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|IMPL
operator|->
name|m_notationName
return|;
block|}
end_function
begin_undef
DECL|macro|IMPL
undef|#
directive|undef
name|IMPL
end_undef
begin_comment
comment|/**************************************************************  *  * QDomEntityReferencePrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomEntityReferencePrivate
name|QDomEntityReferencePrivate
operator|::
name|QDomEntityReferencePrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|d
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|aname
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|d
argument_list|,
name|parent
argument_list|)
block|{
name|name
operator|=
name|aname
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomEntityReferencePrivate
name|QDomEntityReferencePrivate
operator|::
name|QDomEntityReferencePrivate
parameter_list|(
name|QDomNodePrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|n
argument_list|,
name|deep
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|cloneNode
name|QDomNodePrivate
modifier|*
name|QDomEntityReferencePrivate
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
operator|new
name|QDomEntityReferencePrivate
argument_list|(
name|this
argument_list|,
name|deep
argument_list|)
decl_stmt|;
comment|// We are not interested in this node
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|save
name|void
name|QDomEntityReferencePrivate
operator|::
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
block|{
name|s
operator|<<
literal|'&'
operator|<<
name|name
operator|<<
literal|';'
expr_stmt|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomEntityReference  *  **************************************************************/
end_comment
begin_comment
comment|/*!     \class QDomEntityReference     \reentrant     \brief The QDomEntityReference class represents an XML entity reference.      \inmodule QtXml     \ingroup xml-tools      A QDomEntityReference object may be inserted into the DOM tree     when an entity reference is in the source document, or when the     user wishes to insert an entity reference.      Note that character references and references to predefined     entities are expanded by the XML processor so that characters are     represented by their Unicode equivalent rather than by an entity     reference.      Moreover, the XML processor may completely expand references to     entities while building the DOM tree, instead of providing     QDomEntityReference objects.      If it does provide such objects, then for a given entity reference     node, it may be that there is no entity node representing the     referenced entity; but if such an entity exists, then the child     list of the entity reference node is the same as that of the     entity  node. As with the entity node, all descendants of the     entity reference are read-only.      For further information about the Document Object Model see     \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and     \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.     For a more general introduction of the DOM implementation see the     QDomDocument documentation. */
end_comment
begin_comment
comment|/*!     Constructs an empty entity reference. Use     QDomDocument::createEntityReference() to create a entity reference     with content. */
end_comment
begin_constructor
DECL|function|QDomEntityReference
name|QDomEntityReference
operator|::
name|QDomEntityReference
parameter_list|()
member_init_list|:
name|QDomNode
argument_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a x.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_constructor
DECL|function|QDomEntityReference
name|QDomEntityReference
operator|::
name|QDomEntityReference
parameter_list|(
specifier|const
name|QDomEntityReference
modifier|&
name|x
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|x
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QDomEntityReference
name|QDomEntityReference
operator|::
name|QDomEntityReference
parameter_list|(
name|QDomEntityReferencePrivate
modifier|*
name|n
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|n
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns \a x to this entity reference.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_function
DECL|function|operator =
name|QDomEntityReference
modifier|&
name|QDomEntityReference
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomEntityReference
modifier|&
name|x
parameter_list|)
block|{
return|return
operator|(
name|QDomEntityReference
operator|&
operator|)
name|QDomNode
operator|::
name|operator
name|=
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDomNode::NodeType QDomEntityReference::nodeType() const      Returns \c EntityReference. */
end_comment
begin_comment
comment|/**************************************************************  *  * QDomProcessingInstructionPrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomProcessingInstructionPrivate
name|QDomProcessingInstructionPrivate
operator|::
name|QDomProcessingInstructionPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|d
parameter_list|,
name|QDomNodePrivate
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|d
argument_list|,
name|parent
argument_list|)
block|{
name|name
operator|=
name|target
expr_stmt|;
name|value
operator|=
name|data
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomProcessingInstructionPrivate
name|QDomProcessingInstructionPrivate
operator|::
name|QDomProcessingInstructionPrivate
parameter_list|(
name|QDomProcessingInstructionPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|n
argument_list|,
name|deep
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|cloneNode
name|QDomNodePrivate
modifier|*
name|QDomProcessingInstructionPrivate
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
operator|new
name|QDomProcessingInstructionPrivate
argument_list|(
name|this
argument_list|,
name|deep
argument_list|)
decl_stmt|;
comment|// We are not interested in this node
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|save
name|void
name|QDomProcessingInstructionPrivate
operator|::
name|save
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
block|{
name|s
operator|<<
literal|"<?"
operator|<<
name|name
operator|<<
literal|' '
operator|<<
name|value
operator|<<
literal|"?>"
operator|<<
name|endl
expr_stmt|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomProcessingInstruction  *  **************************************************************/
end_comment
begin_comment
comment|/*!     \class QDomProcessingInstruction     \reentrant     \brief The QDomProcessingInstruction class represents an XML processing     instruction.      \inmodule QtXml     \ingroup xml-tools      Processing instructions are used in XML to keep processor-specific     information in the text of the document.      The XML declaration that appears at the top of an XML document,     typically \tt{<?xml version='1.0' encoding='UTF-8'?>}, is treated by QDom as a     processing instruction. This is unfortunate, since the XML declaration is     not a processing instruction; among other differences, it cannot be     inserted into a document anywhere but on the first line.      Do not use this function to create an xml declaration, since although it     has the same syntax as a processing instruction, it isn't, and might not     be treated by QDom as such.      The content of the processing instruction is retrieved with data()     and set with setData(). The processing instruction's target is     retrieved with target().      For further information about the Document Object Model see     \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and     \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}.     For a more general introduction of the DOM implementation see the     QDomDocument documentation. */
end_comment
begin_comment
comment|/*!     Constructs an empty processing instruction. Use     QDomDocument::createProcessingInstruction() to create a processing     instruction with content. */
end_comment
begin_constructor
DECL|function|QDomProcessingInstruction
name|QDomProcessingInstruction
operator|::
name|QDomProcessingInstruction
parameter_list|()
member_init_list|:
name|QDomNode
argument_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a x.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_constructor
DECL|function|QDomProcessingInstruction
name|QDomProcessingInstruction
operator|::
name|QDomProcessingInstruction
parameter_list|(
specifier|const
name|QDomProcessingInstruction
modifier|&
name|x
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|x
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QDomProcessingInstruction
name|QDomProcessingInstruction
operator|::
name|QDomProcessingInstruction
parameter_list|(
name|QDomProcessingInstructionPrivate
modifier|*
name|n
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|n
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns \a x to this processing instruction.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_function
DECL|function|operator =
name|QDomProcessingInstruction
modifier|&
name|QDomProcessingInstruction
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomProcessingInstruction
modifier|&
name|x
parameter_list|)
block|{
return|return
operator|(
name|QDomProcessingInstruction
operator|&
operator|)
name|QDomNode
operator|::
name|operator
name|=
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDomNode::NodeType QDomProcessingInstruction::nodeType() const      Returns \c ProcessingInstructionNode. */
end_comment
begin_comment
comment|/*!     Returns the target of this processing instruction.      \sa data() */
end_comment
begin_function
DECL|function|target
name|QString
name|QDomProcessingInstruction
operator|::
name|target
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|impl
operator|->
name|nodeName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the content of this processing instruction.      \sa setData() target() */
end_comment
begin_function
DECL|function|data
name|QString
name|QDomProcessingInstruction
operator|::
name|data
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|impl
operator|->
name|nodeValue
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the data contained in the processing instruction to \a d.      \sa data() */
end_comment
begin_function
DECL|function|setData
name|void
name|QDomProcessingInstruction
operator|::
name|setData
parameter_list|(
specifier|const
name|QString
modifier|&
name|d
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return;
name|impl
operator|->
name|setNodeValue
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomDocumentPrivate  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomDocumentPrivate
name|QDomDocumentPrivate
operator|::
name|QDomDocumentPrivate
parameter_list|()
member_init_list|:
name|QDomNodePrivate
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|impl
argument_list|(
operator|new
name|QDomImplementationPrivate
argument_list|)
member_init_list|,
name|nodeListTime
argument_list|(
literal|1
argument_list|)
block|{
name|type
operator|=
operator|new
name|QDomDocumentTypePrivate
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|type
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
name|name
operator|=
name|QLatin1String
argument_list|(
literal|"#document"
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomDocumentPrivate
name|QDomDocumentPrivate
operator|::
name|QDomDocumentPrivate
parameter_list|(
specifier|const
name|QString
modifier|&
name|aname
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|impl
argument_list|(
operator|new
name|QDomImplementationPrivate
argument_list|)
member_init_list|,
name|nodeListTime
argument_list|(
literal|1
argument_list|)
block|{
name|type
operator|=
operator|new
name|QDomDocumentTypePrivate
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|type
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
name|type
operator|->
name|name
operator|=
name|aname
expr_stmt|;
name|name
operator|=
name|QLatin1String
argument_list|(
literal|"#document"
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomDocumentPrivate
name|QDomDocumentPrivate
operator|::
name|QDomDocumentPrivate
parameter_list|(
name|QDomDocumentTypePrivate
modifier|*
name|dt
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|impl
argument_list|(
operator|new
name|QDomImplementationPrivate
argument_list|)
member_init_list|,
name|nodeListTime
argument_list|(
literal|1
argument_list|)
block|{
if|if
condition|(
name|dt
operator|!=
literal|0
condition|)
block|{
name|type
operator|=
name|dt
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
operator|new
name|QDomDocumentTypePrivate
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|type
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
block|}
name|name
operator|=
name|QLatin1String
argument_list|(
literal|"#document"
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDomDocumentPrivate
name|QDomDocumentPrivate
operator|::
name|QDomDocumentPrivate
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|n
parameter_list|,
name|bool
name|deep
parameter_list|)
member_init_list|:
name|QDomNodePrivate
argument_list|(
name|n
argument_list|,
name|deep
argument_list|)
member_init_list|,
name|impl
argument_list|(
name|n
operator|->
name|impl
operator|->
name|clone
argument_list|()
argument_list|)
member_init_list|,
name|nodeListTime
argument_list|(
literal|1
argument_list|)
block|{
name|type
operator|=
cast|static_cast
argument_list|<
name|QDomDocumentTypePrivate
operator|*
argument_list|>
argument_list|(
name|n
operator|->
name|type
operator|->
name|cloneNode
argument_list|()
argument_list|)
expr_stmt|;
name|type
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QDomDocumentPrivate
name|QDomDocumentPrivate
operator|::
name|~
name|QDomDocumentPrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|clear
name|void
name|QDomDocumentPrivate
operator|::
name|clear
parameter_list|()
block|{
name|impl
operator|.
name|reset
argument_list|()
expr_stmt|;
name|type
operator|.
name|reset
argument_list|()
expr_stmt|;
name|QDomNodePrivate
operator|::
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initializeReader
specifier|static
name|void
name|initializeReader
parameter_list|(
name|QXmlSimpleReader
modifier|&
name|reader
parameter_list|,
name|bool
name|namespaceProcessing
parameter_list|)
block|{
name|reader
operator|.
name|setFeature
argument_list|(
name|QLatin1String
argument_list|(
literal|"http://xml.org/sax/features/namespaces"
argument_list|)
argument_list|,
name|namespaceProcessing
argument_list|)
expr_stmt|;
name|reader
operator|.
name|setFeature
argument_list|(
name|QLatin1String
argument_list|(
literal|"http://xml.org/sax/features/namespace-prefixes"
argument_list|)
argument_list|,
operator|!
name|namespaceProcessing
argument_list|)
expr_stmt|;
name|reader
operator|.
name|setFeature
argument_list|(
name|QLatin1String
argument_list|(
literal|"http://trolltech.com/xml/features/report-whitespace-only-CharData"
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Shouldn't change in Qt 4
block|}
end_function
begin_function
DECL|function|setContent
name|bool
name|QDomDocumentPrivate
operator|::
name|setContent
parameter_list|(
name|QXmlInputSource
modifier|*
name|source
parameter_list|,
name|bool
name|namespaceProcessing
parameter_list|,
name|QString
modifier|*
name|errorMsg
parameter_list|,
name|int
modifier|*
name|errorLine
parameter_list|,
name|int
modifier|*
name|errorColumn
parameter_list|)
block|{
name|QXmlSimpleReader
name|reader
decl_stmt|;
name|initializeReader
argument_list|(
name|reader
argument_list|,
name|namespaceProcessing
argument_list|)
expr_stmt|;
return|return
name|setContent
argument_list|(
name|source
argument_list|,
operator|&
name|reader
argument_list|,
name|errorMsg
argument_list|,
name|errorLine
argument_list|,
name|errorColumn
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setContent
name|bool
name|QDomDocumentPrivate
operator|::
name|setContent
parameter_list|(
name|QXmlInputSource
modifier|*
name|source
parameter_list|,
name|QXmlReader
modifier|*
name|reader
parameter_list|,
name|QString
modifier|*
name|errorMsg
parameter_list|,
name|int
modifier|*
name|errorLine
parameter_list|,
name|int
modifier|*
name|errorColumn
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|impl
operator|=
operator|new
name|QDomImplementationPrivate
expr_stmt|;
name|type
operator|=
operator|new
name|QDomDocumentTypePrivate
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|type
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
name|bool
name|namespaceProcessing
init|=
name|reader
operator|->
name|feature
argument_list|(
name|QLatin1String
argument_list|(
literal|"http://xml.org/sax/features/namespaces"
argument_list|)
argument_list|)
operator|&&
operator|!
name|reader
operator|->
name|feature
argument_list|(
name|QLatin1String
argument_list|(
literal|"http://xml.org/sax/features/namespace-prefixes"
argument_list|)
argument_list|)
decl_stmt|;
name|QDomHandler
name|hnd
argument_list|(
name|this
argument_list|,
name|namespaceProcessing
argument_list|)
decl_stmt|;
name|reader
operator|->
name|setContentHandler
argument_list|(
operator|&
name|hnd
argument_list|)
expr_stmt|;
name|reader
operator|->
name|setErrorHandler
argument_list|(
operator|&
name|hnd
argument_list|)
expr_stmt|;
name|reader
operator|->
name|setLexicalHandler
argument_list|(
operator|&
name|hnd
argument_list|)
expr_stmt|;
name|reader
operator|->
name|setDeclHandler
argument_list|(
operator|&
name|hnd
argument_list|)
expr_stmt|;
name|reader
operator|->
name|setDTDHandler
argument_list|(
operator|&
name|hnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reader
operator|->
name|parse
argument_list|(
name|source
argument_list|)
condition|)
block|{
if|if
condition|(
name|errorMsg
condition|)
operator|*
name|errorMsg
operator|=
name|hnd
operator|.
name|errorMsg
expr_stmt|;
if|if
condition|(
name|errorLine
condition|)
operator|*
name|errorLine
operator|=
name|hnd
operator|.
name|errorLine
expr_stmt|;
if|if
condition|(
name|errorColumn
condition|)
operator|*
name|errorColumn
operator|=
name|hnd
operator|.
name|errorColumn
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|cloneNode
name|QDomNodePrivate
modifier|*
name|QDomDocumentPrivate
operator|::
name|cloneNode
parameter_list|(
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
operator|new
name|QDomDocumentPrivate
argument_list|(
name|this
argument_list|,
name|deep
argument_list|)
decl_stmt|;
comment|// We are not interested in this node
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|documentElement
name|QDomElementPrivate
modifier|*
name|QDomDocumentPrivate
operator|::
name|documentElement
parameter_list|()
block|{
name|QDomNodePrivate
modifier|*
name|p
init|=
name|first
decl_stmt|;
while|while
condition|(
name|p
operator|&&
operator|!
name|p
operator|->
name|isElement
argument_list|()
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|QDomElementPrivate
operator|*
argument_list|>
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|createElement
name|QDomElementPrivate
modifier|*
name|QDomDocumentPrivate
operator|::
name|createElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|tagName
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|QString
name|fixedName
init|=
name|fixedXmlName
argument_list|(
name|tagName
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
name|QDomElementPrivate
modifier|*
name|e
init|=
operator|new
name|QDomElementPrivate
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|fixedName
argument_list|)
decl_stmt|;
name|e
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|e
return|;
block|}
end_function
begin_function
DECL|function|createElementNS
name|QDomElementPrivate
modifier|*
name|QDomDocumentPrivate
operator|::
name|createElementNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|QString
name|fixedName
init|=
name|fixedXmlName
argument_list|(
name|qName
argument_list|,
operator|&
name|ok
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
name|QDomElementPrivate
modifier|*
name|e
init|=
operator|new
name|QDomElementPrivate
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|nsURI
argument_list|,
name|fixedName
argument_list|)
decl_stmt|;
name|e
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|e
return|;
block|}
end_function
begin_function
DECL|function|createDocumentFragment
name|QDomDocumentFragmentPrivate
modifier|*
name|QDomDocumentPrivate
operator|::
name|createDocumentFragment
parameter_list|()
block|{
name|QDomDocumentFragmentPrivate
modifier|*
name|f
init|=
operator|new
name|QDomDocumentFragmentPrivate
argument_list|(
name|this
argument_list|,
operator|(
name|QDomNodePrivate
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
name|f
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|f
return|;
block|}
end_function
begin_function
DECL|function|createTextNode
name|QDomTextPrivate
modifier|*
name|QDomDocumentPrivate
operator|::
name|createTextNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|QString
name|fixedData
init|=
name|fixedCharData
argument_list|(
name|data
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
name|QDomTextPrivate
modifier|*
name|t
init|=
operator|new
name|QDomTextPrivate
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|fixedData
argument_list|)
decl_stmt|;
name|t
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function
begin_function
DECL|function|createComment
name|QDomCommentPrivate
modifier|*
name|QDomDocumentPrivate
operator|::
name|createComment
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|QString
name|fixedData
init|=
name|fixedComment
argument_list|(
name|data
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
name|QDomCommentPrivate
modifier|*
name|c
init|=
operator|new
name|QDomCommentPrivate
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|fixedData
argument_list|)
decl_stmt|;
name|c
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|createCDATASection
name|QDomCDATASectionPrivate
modifier|*
name|QDomDocumentPrivate
operator|::
name|createCDATASection
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|QString
name|fixedData
init|=
name|fixedCDataSection
argument_list|(
name|data
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
name|QDomCDATASectionPrivate
modifier|*
name|c
init|=
operator|new
name|QDomCDATASectionPrivate
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|fixedData
argument_list|)
decl_stmt|;
name|c
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|createProcessingInstruction
name|QDomProcessingInstructionPrivate
modifier|*
name|QDomDocumentPrivate
operator|::
name|createProcessingInstruction
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|QString
name|fixedData
init|=
name|fixedPIData
argument_list|(
name|data
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
comment|// [17] PITarget ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))
name|QString
name|fixedTarget
init|=
name|fixedXmlName
argument_list|(
name|target
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
name|QDomProcessingInstructionPrivate
modifier|*
name|p
init|=
operator|new
name|QDomProcessingInstructionPrivate
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|fixedTarget
argument_list|,
name|fixedData
argument_list|)
decl_stmt|;
name|p
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|createAttribute
name|QDomAttrPrivate
modifier|*
name|QDomDocumentPrivate
operator|::
name|createAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|aname
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|QString
name|fixedName
init|=
name|fixedXmlName
argument_list|(
name|aname
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
name|QDomAttrPrivate
modifier|*
name|a
init|=
operator|new
name|QDomAttrPrivate
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|fixedName
argument_list|)
decl_stmt|;
name|a
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|createAttributeNS
name|QDomAttrPrivate
modifier|*
name|QDomDocumentPrivate
operator|::
name|createAttributeNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|QString
name|fixedName
init|=
name|fixedXmlName
argument_list|(
name|qName
argument_list|,
operator|&
name|ok
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
name|QDomAttrPrivate
modifier|*
name|a
init|=
operator|new
name|QDomAttrPrivate
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|nsURI
argument_list|,
name|fixedName
argument_list|)
decl_stmt|;
name|a
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|createEntityReference
name|QDomEntityReferencePrivate
modifier|*
name|QDomDocumentPrivate
operator|::
name|createEntityReference
parameter_list|(
specifier|const
name|QString
modifier|&
name|aname
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|QString
name|fixedName
init|=
name|fixedXmlName
argument_list|(
name|aname
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
name|QDomEntityReferencePrivate
modifier|*
name|e
init|=
operator|new
name|QDomEntityReferencePrivate
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|fixedName
argument_list|)
decl_stmt|;
name|e
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
return|return
name|e
return|;
block|}
end_function
begin_function
DECL|function|importNode
name|QDomNodePrivate
modifier|*
name|QDomDocumentPrivate
operator|::
name|importNode
parameter_list|(
specifier|const
name|QDomNodePrivate
modifier|*
name|importedNode
parameter_list|,
name|bool
name|deep
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|node
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|importedNode
operator|->
name|nodeType
argument_list|()
condition|)
block|{
case|case
name|QDomNode
operator|::
name|AttributeNode
case|:
name|node
operator|=
operator|new
name|QDomAttrPrivate
argument_list|(
operator|(
name|QDomAttrPrivate
operator|*
operator|)
name|importedNode
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDomNode
operator|::
name|DocumentFragmentNode
case|:
name|node
operator|=
operator|new
name|QDomDocumentFragmentPrivate
argument_list|(
operator|(
name|QDomDocumentFragmentPrivate
operator|*
operator|)
name|importedNode
argument_list|,
name|deep
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDomNode
operator|::
name|ElementNode
case|:
name|node
operator|=
operator|new
name|QDomElementPrivate
argument_list|(
operator|(
name|QDomElementPrivate
operator|*
operator|)
name|importedNode
argument_list|,
name|deep
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDomNode
operator|::
name|EntityNode
case|:
name|node
operator|=
operator|new
name|QDomEntityPrivate
argument_list|(
operator|(
name|QDomEntityPrivate
operator|*
operator|)
name|importedNode
argument_list|,
name|deep
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDomNode
operator|::
name|EntityReferenceNode
case|:
name|node
operator|=
operator|new
name|QDomEntityReferencePrivate
argument_list|(
operator|(
name|QDomEntityReferencePrivate
operator|*
operator|)
name|importedNode
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDomNode
operator|::
name|NotationNode
case|:
name|node
operator|=
operator|new
name|QDomNotationPrivate
argument_list|(
operator|(
name|QDomNotationPrivate
operator|*
operator|)
name|importedNode
argument_list|,
name|deep
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDomNode
operator|::
name|ProcessingInstructionNode
case|:
name|node
operator|=
operator|new
name|QDomProcessingInstructionPrivate
argument_list|(
operator|(
name|QDomProcessingInstructionPrivate
operator|*
operator|)
name|importedNode
argument_list|,
name|deep
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDomNode
operator|::
name|TextNode
case|:
name|node
operator|=
operator|new
name|QDomTextPrivate
argument_list|(
operator|(
name|QDomTextPrivate
operator|*
operator|)
name|importedNode
argument_list|,
name|deep
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDomNode
operator|::
name|CDATASectionNode
case|:
name|node
operator|=
operator|new
name|QDomCDATASectionPrivate
argument_list|(
operator|(
name|QDomCDATASectionPrivate
operator|*
operator|)
name|importedNode
argument_list|,
name|deep
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDomNode
operator|::
name|CommentNode
case|:
name|node
operator|=
operator|new
name|QDomCommentPrivate
argument_list|(
operator|(
name|QDomCommentPrivate
operator|*
operator|)
name|importedNode
argument_list|,
name|deep
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|node
condition|)
block|{
name|node
operator|->
name|setOwnerDocument
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// The QDomNode constructor increases the refcount, so deref first to
comment|// keep refcount balanced.
name|node
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|saveDocument
name|void
name|QDomDocumentPrivate
operator|::
name|saveDocument
parameter_list|(
name|QTextStream
modifier|&
name|s
parameter_list|,
specifier|const
name|int
name|indent
parameter_list|,
name|QDomNode
operator|::
name|EncodingPolicy
name|encUsed
parameter_list|)
specifier|const
block|{
specifier|const
name|QDomNodePrivate
modifier|*
name|n
init|=
name|first
decl_stmt|;
if|if
condition|(
name|encUsed
operator|==
name|QDomNode
operator|::
name|EncodingFromDocument
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
specifier|const
name|QDomNodePrivate
modifier|*
name|n
init|=
name|first
decl_stmt|;
name|QTextCodec
modifier|*
name|codec
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|n
operator|&&
name|n
operator|->
name|isProcessingInstruction
argument_list|()
operator|&&
name|n
operator|->
name|nodeName
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"xml"
argument_list|)
condition|)
block|{
comment|// we have an XML declaration
name|QString
name|data
init|=
name|n
operator|->
name|nodeValue
argument_list|()
decl_stmt|;
name|QRegExp
name|encoding
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"encoding\\s*=\\s*((\"([^\"]*)\")|('([^']*)'))"
argument_list|)
argument_list|)
decl_stmt|;
name|encoding
operator|.
name|indexIn
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|QString
name|enc
init|=
name|encoding
operator|.
name|cap
argument_list|(
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|enc
operator|.
name|isEmpty
argument_list|()
condition|)
name|enc
operator|=
name|encoding
operator|.
name|cap
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enc
operator|.
name|isEmpty
argument_list|()
condition|)
name|codec
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|enc
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|codec
condition|)
name|codec
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
condition|)
name|s
operator|.
name|setCodec
argument_list|(
name|codec
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bool
name|doc
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|n
condition|)
block|{
if|if
condition|(
operator|!
name|doc
operator|&&
operator|!
operator|(
name|n
operator|->
name|isProcessingInstruction
argument_list|()
operator|&&
name|n
operator|->
name|nodeName
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"xml"
argument_list|)
operator|)
condition|)
block|{
comment|// save doctype after XML declaration
name|type
operator|->
name|save
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|doc
operator|=
literal|true
expr_stmt|;
block|}
name|n
operator|->
name|save
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Write out the XML declaration.
ifdef|#
directive|ifdef
name|QT_NO_TEXTCODEC
specifier|const
name|QLatin1String
name|codecName
argument_list|(
literal|"iso-8859-1"
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|const
name|QTextCodec
modifier|*
specifier|const
name|codec
init|=
name|s
operator|.
name|codec
argument_list|()
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
name|codec
argument_list|,
literal|"QDomNode::save()"
argument_list|,
literal|"A codec must be specified in the text stream."
argument_list|)
expr_stmt|;
specifier|const
name|QByteArray
name|codecName
init|=
name|codec
operator|->
name|name
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|s
operator|<<
literal|"<?xml version=\"1.0\" encoding=\""
operator|<<
name|codecName
operator|<<
literal|"\"?>\n"
expr_stmt|;
comment|//  Skip the first processing instruction by name "xml", if any such exists.
specifier|const
name|QDomNodePrivate
modifier|*
name|startNode
init|=
name|n
decl_stmt|;
comment|// First, we try to find the PI and sets the startNode to the one appearing after it.
while|while
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|isProcessingInstruction
argument_list|()
operator|&&
name|n
operator|->
name|nodeName
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"xml"
argument_list|)
condition|)
block|{
name|startNode
operator|=
name|n
operator|->
name|next
expr_stmt|;
break|break;
block|}
else|else
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
comment|// Now we serialize all the nodes after the faked XML declaration(the PI).
while|while
condition|(
name|startNode
condition|)
block|{
name|startNode
operator|->
name|save
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|startNode
operator|=
name|startNode
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomDocument  *  **************************************************************/
end_comment
begin_define
DECL|macro|IMPL
define|#
directive|define
name|IMPL
value|((QDomDocumentPrivate*)impl)
end_define
begin_comment
comment|/*!     \class QDomDocument     \reentrant     \brief The QDomDocument class represents an XML document.      \inmodule QtXml      \ingroup xml-tools      The QDomDocument class represents the entire XML document.     Conceptually, it is the root of the document tree, and provides     the primary access to the document's data.      Since elements, text nodes, comments, processing instructions,     etc., cannot exist outside the context of a document, the document     class also contains the factory functions needed to create these     objects. The node objects created have an ownerDocument() function     which associates them with the document within whose context they     were created. The DOM classes that will be used most often are     QDomNode, QDomDocument, QDomElement and QDomText.      The parsed XML is represented internally by a tree of objects that     can be accessed using the various QDom classes. All QDom classes     only \e reference objects in the internal tree. The internal     objects in the DOM tree will get deleted once the last QDom     object referencing them and the QDomDocument itself are deleted.      Creation of elements, text nodes, etc. is done using the various     factory functions provided in this class. Using the default     constructors of the QDom classes will only result in empty     objects that cannot be manipulated or inserted into the Document.      The QDomDocument class has several functions for creating document     data, for example, createElement(), createTextNode(),     createComment(), createCDATASection(),     createProcessingInstruction(), createAttribute() and     createEntityReference(). Some of these functions have versions     that support namespaces, i.e. createElementNS() and     createAttributeNS(). The createDocumentFragment() function is used     to hold parts of the document; this is useful for manipulating for     complex documents.      The entire content of the document is set with setContent(). This     function parses the string it is passed as an XML document and     creates the DOM tree that represents the document. The root     element is available using documentElement(). The textual     representation of the document can be obtained using toString().      It is possible to insert a node from another document into the     document using importNode().      You can obtain a list of all the elements that have a particular     tag with elementsByTagName() or with elementsByTagNameNS().      The QDom classes are typically used as follows:     \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 16      Once \c doc and \c elem go out of scope, the whole internal tree     representing the XML document is deleted.      To create a document using DOM use code like this:     \snippet doc/src/snippets/code/src_xml_dom_qdom.cpp 17      For further information about the Document Object Model see     the Document Object Model (DOM)     \l{http://www.w3.org/TR/REC-DOM-Level-1/}{Level 1} and     \l{http://www.w3.org/TR/DOM-Level-2-Core/}{Level 2 Core}     Specifications.      \sa {DOM Bookmarks Example}, {Simple DOM Model Example} */
end_comment
begin_comment
comment|/*!     Constructs an empty document. */
end_comment
begin_constructor
DECL|function|QDomDocument
name|QDomDocument
operator|::
name|QDomDocument
parameter_list|()
block|{
name|impl
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Creates a document and sets the name of the document type to \a     name. */
end_comment
begin_constructor
DECL|function|QDomDocument
name|QDomDocument
operator|::
name|QDomDocument
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
comment|// We take over ownership
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Creates a document with the document type \a doctype.      \sa QDomImplementation::createDocumentType() */
end_comment
begin_constructor
DECL|function|QDomDocument
name|QDomDocument
operator|::
name|QDomDocument
parameter_list|(
specifier|const
name|QDomDocumentType
modifier|&
name|doctype
parameter_list|)
block|{
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|(
operator|(
name|QDomDocumentTypePrivate
operator|*
operator|)
operator|(
name|doctype
operator|.
name|impl
operator|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a x.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_constructor
DECL|function|QDomDocument
name|QDomDocument
operator|::
name|QDomDocument
parameter_list|(
specifier|const
name|QDomDocument
modifier|&
name|x
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|x
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QDomDocument
name|QDomDocument
operator|::
name|QDomDocument
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|x
parameter_list|)
member_init_list|:
name|QDomNode
argument_list|(
name|x
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns \a x to this DOM document.      The data of the copy is shared (shallow copy): modifying one node     will also change the other. If you want to make a deep copy, use     cloneNode(). */
end_comment
begin_function
DECL|function|operator =
name|QDomDocument
modifier|&
name|QDomDocument
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDomDocument
modifier|&
name|x
parameter_list|)
block|{
return|return
operator|(
name|QDomDocument
operator|&
operator|)
name|QDomNode
operator|::
name|operator
name|=
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the object and frees its resources. */
end_comment
begin_destructor
DECL|function|~QDomDocument
name|QDomDocument
operator|::
name|~
name|QDomDocument
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \overload      This function reads the XML document from the string \a text, returning     true if the content was successfully parsed; otherwise returns false.     Since \a text is already a Unicode string, no encoding detection     is done. */
end_comment
begin_function
DECL|function|setContent
name|bool
name|QDomDocument
operator|::
name|setContent
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|bool
name|namespaceProcessing
parameter_list|,
name|QString
modifier|*
name|errorMsg
parameter_list|,
name|int
modifier|*
name|errorLine
parameter_list|,
name|int
modifier|*
name|errorColumn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
name|QXmlInputSource
name|source
decl_stmt|;
name|source
operator|.
name|setData
argument_list|(
name|text
argument_list|)
expr_stmt|;
return|return
name|IMPL
operator|->
name|setContent
argument_list|(
operator|&
name|source
argument_list|,
name|namespaceProcessing
argument_list|,
name|errorMsg
argument_list|,
name|errorLine
argument_list|,
name|errorColumn
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \nonreentrant      This function parses the XML document from the byte array \a     data and sets it as the content of the document. It tries to     detect the encoding of the document as required by the XML     specification.      If \a namespaceProcessing is true, the parser recognizes     namespaces in the XML file and sets the prefix name, local name     and namespace URI to appropriate values. If \a namespaceProcessing     is false, the parser does no namespace processing when it reads     the XML file.      If a parse error occurs, this function returns false and the error     message is placed in \c{*}\a{errorMsg}, the line number in     \c{*}\a{errorLine} and the column number in \c{*}\a{errorColumn}     (unless the associated pointer is set to 0); otherwise this     function returns true. The various error messages are described in     the QXmlParseException class documentation. Note that, if you     want to display these error messages to your application's users,     they will be displayed in English unless they are explicitly     translated.      If \a namespaceProcessing is true, the function QDomNode::prefix()     returns a string for all elements and attributes. It returns an     empty string if the element or attribute has no prefix.      Text nodes consisting only of whitespace are stripped and won't     appear in the QDomDocument. If this behavior is not desired,     one can use the setContent() overload that allows a QXmlReader to be     supplied.      If \a namespaceProcessing is false, the functions     QDomNode::prefix(), QDomNode::localName() and     QDomNode::namespaceURI() return an empty string.      Entity references are handled as follows:     \list     \o References to internal general entities and character entities occurring in the         content are included. The result is a QDomText node with the references replaced         by their corresponding entity values.     \o References to parameter entities occurring in the internal subset are included.         The result is a QDomDocumentType node which contains entity and notation declarations         with the references replaced by their corresponding entity values.     \o Any general parsed entity reference which is not defined in the internal subset and         which occurs in the content is represented as a QDomEntityReference node.     \o Any parsed entity reference which is not defined in the internal subset and which         occurs outside of the content is replaced with an empty string.     \o Any unparsed entity reference is replaced with an empty string.     \endlist      \sa QDomNode::namespaceURI() QDomNode::localName()     QDomNode::prefix() QString::isNull() QString::isEmpty() */
end_comment
begin_function
DECL|function|setContent
name|bool
name|QDomDocument
operator|::
name|setContent
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|bool
name|namespaceProcessing
parameter_list|,
name|QString
modifier|*
name|errorMsg
parameter_list|,
name|int
modifier|*
name|errorLine
parameter_list|,
name|int
modifier|*
name|errorColumn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
name|QBuffer
name|buf
decl_stmt|;
name|buf
operator|.
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|QXmlInputSource
name|source
argument_list|(
operator|&
name|buf
argument_list|)
decl_stmt|;
return|return
name|IMPL
operator|->
name|setContent
argument_list|(
operator|&
name|source
argument_list|,
name|namespaceProcessing
argument_list|,
name|errorMsg
argument_list|,
name|errorLine
argument_list|,
name|errorColumn
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      This function reads the XML document from the IO device \a dev, returning     true if the content was successfully parsed; otherwise returns false. */
end_comment
begin_function
DECL|function|setContent
name|bool
name|QDomDocument
operator|::
name|setContent
parameter_list|(
name|QIODevice
modifier|*
name|dev
parameter_list|,
name|bool
name|namespaceProcessing
parameter_list|,
name|QString
modifier|*
name|errorMsg
parameter_list|,
name|int
modifier|*
name|errorLine
parameter_list|,
name|int
modifier|*
name|errorColumn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
name|QXmlInputSource
name|source
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
name|IMPL
operator|->
name|setContent
argument_list|(
operator|&
name|source
argument_list|,
name|namespaceProcessing
argument_list|,
name|errorMsg
argument_list|,
name|errorLine
argument_list|,
name|errorColumn
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.5      This function reads the XML document from the QXmlInputSource \a source,     returning true if the content was successfully parsed; otherwise returns false.  */
end_comment
begin_function
DECL|function|setContent
name|bool
name|QDomDocument
operator|::
name|setContent
parameter_list|(
name|QXmlInputSource
modifier|*
name|source
parameter_list|,
name|bool
name|namespaceProcessing
parameter_list|,
name|QString
modifier|*
name|errorMsg
parameter_list|,
name|int
modifier|*
name|errorLine
parameter_list|,
name|int
modifier|*
name|errorColumn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
name|QXmlSimpleReader
name|reader
decl_stmt|;
name|initializeReader
argument_list|(
name|reader
argument_list|,
name|namespaceProcessing
argument_list|)
expr_stmt|;
return|return
name|IMPL
operator|->
name|setContent
argument_list|(
name|source
argument_list|,
operator|&
name|reader
argument_list|,
name|errorMsg
argument_list|,
name|errorLine
argument_list|,
name|errorColumn
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      This function reads the XML document from the string \a text, returning     true if the content was successfully parsed; otherwise returns false.     Since \a text is already a Unicode string, no encoding detection     is performed.      No namespace processing is performed either. */
end_comment
begin_function
DECL|function|setContent
name|bool
name|QDomDocument
operator|::
name|setContent
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|QString
modifier|*
name|errorMsg
parameter_list|,
name|int
modifier|*
name|errorLine
parameter_list|,
name|int
modifier|*
name|errorColumn
parameter_list|)
block|{
return|return
name|setContent
argument_list|(
name|text
argument_list|,
literal|false
argument_list|,
name|errorMsg
argument_list|,
name|errorLine
argument_list|,
name|errorColumn
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      This function reads the XML document from the byte array \a buffer,     returning true if the content was successfully parsed; otherwise returns     false.      No namespace processing is performed. */
end_comment
begin_function
DECL|function|setContent
name|bool
name|QDomDocument
operator|::
name|setContent
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|buffer
parameter_list|,
name|QString
modifier|*
name|errorMsg
parameter_list|,
name|int
modifier|*
name|errorLine
parameter_list|,
name|int
modifier|*
name|errorColumn
parameter_list|)
block|{
return|return
name|setContent
argument_list|(
name|buffer
argument_list|,
literal|false
argument_list|,
name|errorMsg
argument_list|,
name|errorLine
argument_list|,
name|errorColumn
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      This function reads the XML document from the IO device \a dev, returning     true if the content was successfully parsed; otherwise returns false.      No namespace processing is performed. */
end_comment
begin_function
DECL|function|setContent
name|bool
name|QDomDocument
operator|::
name|setContent
parameter_list|(
name|QIODevice
modifier|*
name|dev
parameter_list|,
name|QString
modifier|*
name|errorMsg
parameter_list|,
name|int
modifier|*
name|errorLine
parameter_list|,
name|int
modifier|*
name|errorColumn
parameter_list|)
block|{
return|return
name|setContent
argument_list|(
name|dev
argument_list|,
literal|false
argument_list|,
name|errorMsg
argument_list|,
name|errorLine
argument_list|,
name|errorColumn
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      This function reads the XML document from the QXmlInputSource \a source and     parses it with the QXmlReader \a reader, returning true if the content was     successfully parsed; otherwise returns false.      This function doesn't change the features of the \a reader. If you want to     use certain features for parsing you can use this function to set up the     reader appropriately.      \sa QXmlSimpleReader */
end_comment
begin_function
DECL|function|setContent
name|bool
name|QDomDocument
operator|::
name|setContent
parameter_list|(
name|QXmlInputSource
modifier|*
name|source
parameter_list|,
name|QXmlReader
modifier|*
name|reader
parameter_list|,
name|QString
modifier|*
name|errorMsg
parameter_list|,
name|int
modifier|*
name|errorLine
parameter_list|,
name|int
modifier|*
name|errorColumn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
return|return
name|IMPL
operator|->
name|setContent
argument_list|(
name|source
argument_list|,
name|reader
argument_list|,
name|errorMsg
argument_list|,
name|errorLine
argument_list|,
name|errorColumn
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Converts the parsed document back to its textual representation.      This function uses \a indent as the amount of space to indent     subelements.      If \a indent is -1, no whitespace at all is added. */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDomDocument
operator|::
name|toString
parameter_list|(
name|int
name|indent
parameter_list|)
specifier|const
block|{
name|QString
name|str
decl_stmt|;
name|QTextStream
name|s
argument_list|(
operator|&
name|str
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|save
argument_list|(
name|s
argument_list|,
name|indent
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function
begin_comment
comment|/*!     Converts the parsed document back to its textual representation     and returns a QByteArray containing the data encoded as UTF-8.      This function uses \a indent as the amount of space to indent     subelements.      \sa toString() */
end_comment
begin_function
DECL|function|toByteArray
name|QByteArray
name|QDomDocument
operator|::
name|toByteArray
parameter_list|(
name|int
name|indent
parameter_list|)
specifier|const
block|{
comment|// ### if there is an encoding specified in the xml declaration, this
comment|// encoding declaration should be changed to utf8
return|return
name|toString
argument_list|(
name|indent
argument_list|)
operator|.
name|toUtf8
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the document type of this document. */
end_comment
begin_function
DECL|function|doctype
name|QDomDocumentType
name|QDomDocument
operator|::
name|doctype
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomDocumentType
argument_list|()
return|;
return|return
name|QDomDocumentType
argument_list|(
name|IMPL
operator|->
name|doctype
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDomImplementation object. */
end_comment
begin_function
DECL|function|implementation
name|QDomImplementation
name|QDomDocument
operator|::
name|implementation
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomImplementation
argument_list|()
return|;
return|return
name|QDomImplementation
argument_list|(
name|IMPL
operator|->
name|implementation
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the root element of the document. */
end_comment
begin_function
DECL|function|documentElement
name|QDomElement
name|QDomDocument
operator|::
name|documentElement
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|impl
condition|)
return|return
name|QDomElement
argument_list|()
return|;
return|return
name|QDomElement
argument_list|(
name|IMPL
operator|->
name|documentElement
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a new element called \a tagName that can be inserted into     the DOM tree, e.g. using QDomNode::appendChild().      If \a tagName is not a valid XML name, the behavior of this function is governed     by QDomImplementation::InvalidDataPolicy.      \sa createElementNS() QDomNode::appendChild() QDomNode::insertBefore()     QDomNode::insertAfter() */
end_comment
begin_function
DECL|function|createElement
name|QDomElement
name|QDomDocument
operator|::
name|createElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|tagName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
return|return
name|QDomElement
argument_list|(
name|IMPL
operator|->
name|createElement
argument_list|(
name|tagName
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a new document fragment, that can be used to hold parts of     the document, e.g. when doing complex manipulations of the     document tree. */
end_comment
begin_function
DECL|function|createDocumentFragment
name|QDomDocumentFragment
name|QDomDocument
operator|::
name|createDocumentFragment
parameter_list|()
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
return|return
name|QDomDocumentFragment
argument_list|(
name|IMPL
operator|->
name|createDocumentFragment
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a text node for the string \a value that can be inserted     into the document tree, e.g. using QDomNode::appendChild().      If \a value contains characters which cannot be stored as character     data of an XML document (even in the form of character references), the     behavior of this function is governed by QDomImplementation::InvalidDataPolicy.      \sa QDomNode::appendChild() QDomNode::insertBefore() QDomNode::insertAfter() */
end_comment
begin_function
DECL|function|createTextNode
name|QDomText
name|QDomDocument
operator|::
name|createTextNode
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
return|return
name|QDomText
argument_list|(
name|IMPL
operator|->
name|createTextNode
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a new comment for the string \a value that can be inserted     into the document, e.g. using QDomNode::appendChild().      If \a value contains characters which cannot be stored in an XML comment,     the behavior of this function is governed by QDomImplementation::InvalidDataPolicy.      \sa QDomNode::appendChild() QDomNode::insertBefore() QDomNode::insertAfter() */
end_comment
begin_function
DECL|function|createComment
name|QDomComment
name|QDomDocument
operator|::
name|createComment
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
return|return
name|QDomComment
argument_list|(
name|IMPL
operator|->
name|createComment
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a new CDATA section for the string \a value that can be     inserted into the document, e.g. using QDomNode::appendChild().      If \a value contains characters which cannot be stored in a CDATA section,     the behavior of this function is governed by     QDomImplementation::InvalidDataPolicy.      \sa QDomNode::appendChild() QDomNode::insertBefore() QDomNode::insertAfter() */
end_comment
begin_function
DECL|function|createCDATASection
name|QDomCDATASection
name|QDomDocument
operator|::
name|createCDATASection
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
return|return
name|QDomCDATASection
argument_list|(
name|IMPL
operator|->
name|createCDATASection
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a new processing instruction that can be inserted into the     document, e.g. using QDomNode::appendChild(). This function sets     the target for the processing instruction to \a target and the     data to \a data.      If \a target is not a valid XML name, or data if contains characters which cannot     appear in a processing instruction, the behavior of this function is governed by     QDomImplementation::InvalidDataPolicy.      \sa QDomNode::appendChild() QDomNode::insertBefore() QDomNode::insertAfter() */
end_comment
begin_function
DECL|function|createProcessingInstruction
name|QDomProcessingInstruction
name|QDomDocument
operator|::
name|createProcessingInstruction
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
return|return
name|QDomProcessingInstruction
argument_list|(
name|IMPL
operator|->
name|createProcessingInstruction
argument_list|(
name|target
argument_list|,
name|data
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a new attribute called \a name that can be inserted into     an element, e.g. using QDomElement::setAttributeNode().      If \a name is not a valid XML name, the behavior of this function is governed by     QDomImplementation::InvalidDataPolicy.      \sa createAttributeNS() */
end_comment
begin_function
DECL|function|createAttribute
name|QDomAttr
name|QDomDocument
operator|::
name|createAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
return|return
name|QDomAttr
argument_list|(
name|IMPL
operator|->
name|createAttribute
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a new entity reference called \a name that can be inserted     into the document, e.g. using QDomNode::appendChild().      If \a name is not a valid XML name, the behavior of this function is governed by     QDomImplementation::InvalidDataPolicy.      \sa QDomNode::appendChild() QDomNode::insertBefore() QDomNode::insertAfter() */
end_comment
begin_function
DECL|function|createEntityReference
name|QDomEntityReference
name|QDomDocument
operator|::
name|createEntityReference
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
return|return
name|QDomEntityReference
argument_list|(
name|IMPL
operator|->
name|createEntityReference
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDomNodeList, that contains all the elements in the     document with the name \a tagname. The order of the node list is     the order they are encountered in a preorder traversal of the     element tree.      \sa elementsByTagNameNS() QDomElement::elementsByTagName() */
end_comment
begin_function
DECL|function|elementsByTagName
name|QDomNodeList
name|QDomDocument
operator|::
name|elementsByTagName
parameter_list|(
specifier|const
name|QString
modifier|&
name|tagname
parameter_list|)
specifier|const
block|{
return|return
name|QDomNodeList
argument_list|(
operator|new
name|QDomNodeListPrivate
argument_list|(
name|impl
argument_list|,
name|tagname
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Imports the node \a importedNode from another document to this     document. \a importedNode remains in the original document; this     function creates a copy that can be used within this document.      This function returns the imported node that belongs to this     document. The returned node has no parent. It is not possible to     import QDomDocument and QDomDocumentType nodes. In those cases     this function returns a \link QDomNode::isNull() null node\endlink.      If \a deep is true, this function imports not only the node \a     importedNode but its whole subtree; if it is false, only the \a     importedNode is imported. The argument \a deep has no effect on     QDomAttr and QDomEntityReference nodes, since the descendants of     QDomAttr nodes are always imported and those of     QDomEntityReference nodes are never imported.      The behavior of this function is slightly different depending on     the node types:     \table     \header \i Node Type \i Behavior     \row \i QDomAttr          \i The owner element is set to 0 and the specified flag is             set to true in the generated attribute. The whole subtree             of \a importedNode is always imported for attribute nodes:             \a deep has no effect.     \row \i QDomDocument          \i Document nodes cannot be imported.     \row \i QDomDocumentFragment          \i If \a deep is true, this function imports the whole             document fragment; otherwise it only generates an empty             document fragment.     \row \i QDomDocumentType          \i Document type nodes cannot be imported.     \row \i QDomElement          \i Attributes for which QDomAttr::specified() is true are             also imported, other attributes are not imported. If \a             deep is true, this function also imports the subtree of \a             importedNode; otherwise it imports only the element node             (and some attributes, see above).     \row \i QDomEntity          \i Entity nodes can be imported, but at the moment there is             no way to use them since the document type is read-only in             DOM level 2.     \row \i QDomEntityReference          \i Descendants of entity reference nodes are never imported:             \a deep has no effect.     \row \i QDomNotation          \i Notation nodes can be imported, but at the moment there is             no way to use them since the document type is read-only in             DOM level 2.     \row \i QDomProcessingInstruction          \i The target and value of the processing instruction is             copied to the new node.     \row \i QDomText          \i The text is copied to the new node.     \row \i QDomCDATASection          \i The text is copied to the new node.     \row \i QDomComment          \i The text is copied to the new node.     \endtable      \sa QDomElement::setAttribute() QDomNode::insertBefore()         QDomNode::insertAfter() QDomNode::replaceChild() QDomNode::removeChild()         QDomNode::appendChild() */
end_comment
begin_function
DECL|function|importNode
name|QDomNode
name|QDomDocument
operator|::
name|importNode
parameter_list|(
specifier|const
name|QDomNode
modifier|&
name|importedNode
parameter_list|,
name|bool
name|deep
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
return|return
name|QDomNode
argument_list|(
name|IMPL
operator|->
name|importNode
argument_list|(
name|importedNode
operator|.
name|impl
argument_list|,
name|deep
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a new element with namespace support that can be inserted     into the DOM tree. The name of the element is \a qName and the     namespace URI is \a nsURI. This function also sets     QDomNode::prefix() and QDomNode::localName() to appropriate values     (depending on \a qName).      If \a qName is an empty string, returns a null element regardless of     whether the invalid data policy is set.      \sa createElement() */
end_comment
begin_function
DECL|function|createElementNS
name|QDomElement
name|QDomDocument
operator|::
name|createElementNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
return|return
name|QDomElement
argument_list|(
name|IMPL
operator|->
name|createElementNS
argument_list|(
name|nsURI
argument_list|,
name|qName
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a new attribute with namespace support that can be     inserted into an element. The name of the attribute is \a qName     and the namespace URI is \a nsURI. This function also sets     QDomNode::prefix() and QDomNode::localName() to appropriate values     (depending on \a qName).      If \a qName is not a valid XML name, the behavior of this function is governed by     QDomImplementation::InvalidDataPolicy.      \sa createAttribute() */
end_comment
begin_function
DECL|function|createAttributeNS
name|QDomAttr
name|QDomDocument
operator|::
name|createAttributeNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|new
name|QDomDocumentPrivate
argument_list|()
expr_stmt|;
return|return
name|QDomAttr
argument_list|(
name|IMPL
operator|->
name|createAttributeNS
argument_list|(
name|nsURI
argument_list|,
name|qName
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDomNodeList that contains all the elements in the     document with the local name \a localName and a namespace URI of     \a nsURI. The order of the node list is the order they are     encountered in a preorder traversal of the element tree.      \sa elementsByTagName() QDomElement::elementsByTagNameNS() */
end_comment
begin_function
DECL|function|elementsByTagNameNS
name|QDomNodeList
name|QDomDocument
operator|::
name|elementsByTagNameNS
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
block|{
return|return
name|QDomNodeList
argument_list|(
operator|new
name|QDomNodeListPrivate
argument_list|(
name|impl
argument_list|,
name|nsURI
argument_list|,
name|localName
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the element whose ID is equal to \a elementId. If no     element with the ID was found, this function returns a \link     QDomNode::isNull() null element\endlink.      Since the QDomClasses do not know which attributes are element     IDs, this function returns always a \link QDomNode::isNull() null     element\endlink. This may change in a future version. */
end_comment
begin_function
DECL|function|elementById
name|QDomElement
name|QDomDocument
operator|::
name|elementById
parameter_list|(
specifier|const
name|QString
modifier|&
comment|/*elementId*/
parameter_list|)
block|{
name|qWarning
argument_list|(
literal|"elementById() is not implemented and will always return a null node."
argument_list|)
expr_stmt|;
return|return
name|QDomElement
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDomNode::NodeType QDomDocument::nodeType() const      Returns \c DocumentNode. */
end_comment
begin_undef
DECL|macro|IMPL
undef|#
directive|undef
name|IMPL
end_undef
begin_comment
comment|/**************************************************************  *  * Node casting functions  *  **************************************************************/
end_comment
begin_comment
comment|/*!     Converts a QDomNode into a QDomAttr. If the node is not an     attribute, the returned object will be \link QDomNode::isNull()     null\endlink.      \sa isAttr() */
end_comment
begin_function
DECL|function|toAttr
name|QDomAttr
name|QDomNode
operator|::
name|toAttr
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
operator|&&
name|impl
operator|->
name|isAttr
argument_list|()
condition|)
return|return
name|QDomAttr
argument_list|(
operator|(
operator|(
name|QDomAttrPrivate
operator|*
operator|)
name|impl
operator|)
argument_list|)
return|;
return|return
name|QDomAttr
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Converts a QDomNode into a QDomCDATASection. If the node is not a     CDATA section, the returned object will be \link     QDomNode::isNull() null\endlink.      \sa isCDATASection() */
end_comment
begin_function
DECL|function|toCDATASection
name|QDomCDATASection
name|QDomNode
operator|::
name|toCDATASection
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
operator|&&
name|impl
operator|->
name|isCDATASection
argument_list|()
condition|)
return|return
name|QDomCDATASection
argument_list|(
operator|(
operator|(
name|QDomCDATASectionPrivate
operator|*
operator|)
name|impl
operator|)
argument_list|)
return|;
return|return
name|QDomCDATASection
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Converts a QDomNode into a QDomDocumentFragment. If the node is     not a document fragment the returned object will be \link     QDomNode::isNull() null\endlink.      \sa isDocumentFragment() */
end_comment
begin_function
DECL|function|toDocumentFragment
name|QDomDocumentFragment
name|QDomNode
operator|::
name|toDocumentFragment
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
operator|&&
name|impl
operator|->
name|isDocumentFragment
argument_list|()
condition|)
return|return
name|QDomDocumentFragment
argument_list|(
operator|(
operator|(
name|QDomDocumentFragmentPrivate
operator|*
operator|)
name|impl
operator|)
argument_list|)
return|;
return|return
name|QDomDocumentFragment
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Converts a QDomNode into a QDomDocument. If the node is not a     document the returned object will be \link QDomNode::isNull()     null\endlink.      \sa isDocument() */
end_comment
begin_function
DECL|function|toDocument
name|QDomDocument
name|QDomNode
operator|::
name|toDocument
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
operator|&&
name|impl
operator|->
name|isDocument
argument_list|()
condition|)
return|return
name|QDomDocument
argument_list|(
operator|(
operator|(
name|QDomDocumentPrivate
operator|*
operator|)
name|impl
operator|)
argument_list|)
return|;
return|return
name|QDomDocument
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Converts a QDomNode into a QDomDocumentType. If the node is not a     document type the returned object will be \link QDomNode::isNull()     null\endlink.      \sa isDocumentType() */
end_comment
begin_function
DECL|function|toDocumentType
name|QDomDocumentType
name|QDomNode
operator|::
name|toDocumentType
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
operator|&&
name|impl
operator|->
name|isDocumentType
argument_list|()
condition|)
return|return
name|QDomDocumentType
argument_list|(
operator|(
operator|(
name|QDomDocumentTypePrivate
operator|*
operator|)
name|impl
operator|)
argument_list|)
return|;
return|return
name|QDomDocumentType
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Converts a QDomNode into a QDomElement. If the node is not an     element the returned object will be \link QDomNode::isNull()     null\endlink.      \sa isElement() */
end_comment
begin_function
DECL|function|toElement
name|QDomElement
name|QDomNode
operator|::
name|toElement
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
operator|&&
name|impl
operator|->
name|isElement
argument_list|()
condition|)
return|return
name|QDomElement
argument_list|(
operator|(
operator|(
name|QDomElementPrivate
operator|*
operator|)
name|impl
operator|)
argument_list|)
return|;
return|return
name|QDomElement
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Converts a QDomNode into a QDomEntityReference. If the node is not     an entity reference, the returned object will be \link     QDomNode::isNull() null\endlink.      \sa isEntityReference() */
end_comment
begin_function
DECL|function|toEntityReference
name|QDomEntityReference
name|QDomNode
operator|::
name|toEntityReference
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
operator|&&
name|impl
operator|->
name|isEntityReference
argument_list|()
condition|)
return|return
name|QDomEntityReference
argument_list|(
operator|(
operator|(
name|QDomEntityReferencePrivate
operator|*
operator|)
name|impl
operator|)
argument_list|)
return|;
return|return
name|QDomEntityReference
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Converts a QDomNode into a QDomText. If the node is not a text,     the returned object will be \link QDomNode::isNull() null\endlink.      \sa isText() */
end_comment
begin_function
DECL|function|toText
name|QDomText
name|QDomNode
operator|::
name|toText
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
operator|&&
name|impl
operator|->
name|isText
argument_list|()
condition|)
return|return
name|QDomText
argument_list|(
operator|(
operator|(
name|QDomTextPrivate
operator|*
operator|)
name|impl
operator|)
argument_list|)
return|;
return|return
name|QDomText
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Converts a QDomNode into a QDomEntity. If the node is not an     entity the returned object will be \link QDomNode::isNull()     null\endlink.      \sa isEntity() */
end_comment
begin_function
DECL|function|toEntity
name|QDomEntity
name|QDomNode
operator|::
name|toEntity
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
operator|&&
name|impl
operator|->
name|isEntity
argument_list|()
condition|)
return|return
name|QDomEntity
argument_list|(
operator|(
operator|(
name|QDomEntityPrivate
operator|*
operator|)
name|impl
operator|)
argument_list|)
return|;
return|return
name|QDomEntity
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Converts a QDomNode into a QDomNotation. If the node is not a     notation the returned object will be \link QDomNode::isNull()     null\endlink.      \sa isNotation() */
end_comment
begin_function
DECL|function|toNotation
name|QDomNotation
name|QDomNode
operator|::
name|toNotation
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
operator|&&
name|impl
operator|->
name|isNotation
argument_list|()
condition|)
return|return
name|QDomNotation
argument_list|(
operator|(
operator|(
name|QDomNotationPrivate
operator|*
operator|)
name|impl
operator|)
argument_list|)
return|;
return|return
name|QDomNotation
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Converts a QDomNode into a QDomProcessingInstruction. If the node     is not a processing instruction the returned object will be \link     QDomNode::isNull() null\endlink.      \sa isProcessingInstruction() */
end_comment
begin_function
DECL|function|toProcessingInstruction
name|QDomProcessingInstruction
name|QDomNode
operator|::
name|toProcessingInstruction
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
operator|&&
name|impl
operator|->
name|isProcessingInstruction
argument_list|()
condition|)
return|return
name|QDomProcessingInstruction
argument_list|(
operator|(
operator|(
name|QDomProcessingInstructionPrivate
operator|*
operator|)
name|impl
operator|)
argument_list|)
return|;
return|return
name|QDomProcessingInstruction
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Converts a QDomNode into a QDomCharacterData. If the node is not a     character data node the returned object will be \link     QDomNode::isNull() null\endlink.      \sa isCharacterData() */
end_comment
begin_function
DECL|function|toCharacterData
name|QDomCharacterData
name|QDomNode
operator|::
name|toCharacterData
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
operator|&&
name|impl
operator|->
name|isCharacterData
argument_list|()
condition|)
return|return
name|QDomCharacterData
argument_list|(
operator|(
operator|(
name|QDomCharacterDataPrivate
operator|*
operator|)
name|impl
operator|)
argument_list|)
return|;
return|return
name|QDomCharacterData
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Converts a QDomNode into a QDomComment. If the node is not a     comment the returned object will be \link QDomNode::isNull()     null\endlink.      \sa isComment() */
end_comment
begin_function
DECL|function|toComment
name|QDomComment
name|QDomNode
operator|::
name|toComment
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|impl
operator|&&
name|impl
operator|->
name|isComment
argument_list|()
condition|)
return|return
name|QDomComment
argument_list|(
operator|(
operator|(
name|QDomCommentPrivate
operator|*
operator|)
name|impl
operator|)
argument_list|)
return|;
return|return
name|QDomComment
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/**************************************************************  *  * QDomHandler  *  **************************************************************/
end_comment
begin_constructor
DECL|function|QDomHandler
name|QDomHandler
operator|::
name|QDomHandler
parameter_list|(
name|QDomDocumentPrivate
modifier|*
name|adoc
parameter_list|,
name|bool
name|namespaceProcessing
parameter_list|)
member_init_list|:
name|errorLine
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|errorColumn
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|doc
argument_list|(
name|adoc
argument_list|)
member_init_list|,
name|node
argument_list|(
name|adoc
argument_list|)
member_init_list|,
name|cdata
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|nsProcessing
argument_list|(
name|namespaceProcessing
argument_list|)
member_init_list|,
name|locator
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QDomHandler
name|QDomHandler
operator|::
name|~
name|QDomHandler
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|endDocument
name|bool
name|QDomHandler
operator|::
name|endDocument
parameter_list|()
block|{
comment|// ### is this really necessary? (rms)
if|if
condition|(
name|node
operator|!=
name|doc
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|startDTD
name|bool
name|QDomHandler
operator|::
name|startDTD
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|publicId
parameter_list|,
specifier|const
name|QString
modifier|&
name|systemId
parameter_list|)
block|{
name|doc
operator|->
name|doctype
argument_list|()
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|doc
operator|->
name|doctype
argument_list|()
operator|->
name|publicId
operator|=
name|publicId
expr_stmt|;
name|doc
operator|->
name|doctype
argument_list|()
operator|->
name|systemId
operator|=
name|systemId
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|startElement
name|bool
name|QDomHandler
operator|::
name|startElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|nsURI
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
name|qName
parameter_list|,
specifier|const
name|QXmlAttributes
modifier|&
name|atts
parameter_list|)
block|{
comment|// tag name
name|QDomNodePrivate
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|nsProcessing
condition|)
block|{
name|n
operator|=
name|doc
operator|->
name|createElementNS
argument_list|(
name|nsURI
argument_list|,
name|qName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|doc
operator|->
name|createElement
argument_list|(
name|qName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|false
return|;
name|n
operator|->
name|setLocation
argument_list|(
name|locator
operator|->
name|lineNumber
argument_list|()
argument_list|,
name|locator
operator|->
name|columnNumber
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|->
name|appendChild
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|node
operator|=
name|n
expr_stmt|;
comment|// attributes
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|atts
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nsProcessing
condition|)
block|{
operator|(
operator|(
name|QDomElementPrivate
operator|*
operator|)
name|node
operator|)
operator|->
name|setAttributeNS
argument_list|(
name|atts
operator|.
name|uri
argument_list|(
name|i
argument_list|)
argument_list|,
name|atts
operator|.
name|qName
argument_list|(
name|i
argument_list|)
argument_list|,
name|atts
operator|.
name|value
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|QDomElementPrivate
operator|*
operator|)
name|node
operator|)
operator|->
name|setAttribute
argument_list|(
name|atts
operator|.
name|qName
argument_list|(
name|i
argument_list|)
argument_list|,
name|atts
operator|.
name|value
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|endElement
name|bool
name|QDomHandler
operator|::
name|endElement
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|||
name|node
operator|==
name|doc
condition|)
return|return
literal|false
return|;
name|node
operator|=
name|node
operator|->
name|parent
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|characters
name|bool
name|QDomHandler
operator|::
name|characters
parameter_list|(
specifier|const
name|QString
modifier|&
name|ch
parameter_list|)
block|{
comment|// No text as child of some document
if|if
condition|(
name|node
operator|==
name|doc
condition|)
return|return
literal|false
return|;
name|QScopedPointer
argument_list|<
name|QDomNodePrivate
argument_list|>
name|n
decl_stmt|;
if|if
condition|(
name|cdata
condition|)
block|{
name|n
operator|.
name|reset
argument_list|(
name|doc
operator|->
name|createCDATASection
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|entityName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QScopedPointer
argument_list|<
name|QDomEntityPrivate
argument_list|>
name|e
argument_list|(
operator|new
name|QDomEntityPrivate
argument_list|(
name|doc
argument_list|,
literal|0
argument_list|,
name|entityName
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|e
operator|->
name|value
operator|=
name|ch
expr_stmt|;
name|e
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
name|doc
operator|->
name|doctype
argument_list|()
operator|->
name|appendChild
argument_list|(
name|e
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|take
argument_list|()
expr_stmt|;
name|n
operator|.
name|reset
argument_list|(
name|doc
operator|->
name|createEntityReference
argument_list|(
name|entityName
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|.
name|reset
argument_list|(
name|doc
operator|->
name|createTextNode
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|n
operator|->
name|setLocation
argument_list|(
name|locator
operator|->
name|lineNumber
argument_list|()
argument_list|,
name|locator
operator|->
name|columnNumber
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|->
name|appendChild
argument_list|(
name|n
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|n
operator|.
name|take
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|processingInstruction
name|bool
name|QDomHandler
operator|::
name|processingInstruction
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|doc
operator|->
name|createProcessingInstruction
argument_list|(
name|target
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|setLocation
argument_list|(
name|locator
operator|->
name|lineNumber
argument_list|()
argument_list|,
name|locator
operator|->
name|columnNumber
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|->
name|appendChild
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
return|return
literal|false
return|;
block|}
end_function
begin_decl_stmt
specifier|extern
name|bool
name|qt_xml_skipped_entity_in_content
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|skippedEntity
name|bool
name|QDomHandler
operator|::
name|skippedEntity
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
comment|// we can only handle inserting entity references into content
if|if
condition|(
operator|!
name|qt_xml_skipped_entity_in_content
condition|)
return|return
literal|true
return|;
name|QDomNodePrivate
modifier|*
name|n
init|=
name|doc
operator|->
name|createEntityReference
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|n
operator|->
name|setLocation
argument_list|(
name|locator
operator|->
name|lineNumber
argument_list|()
argument_list|,
name|locator
operator|->
name|columnNumber
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|->
name|appendChild
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|fatalError
name|bool
name|QDomHandler
operator|::
name|fatalError
parameter_list|(
specifier|const
name|QXmlParseException
modifier|&
name|exception
parameter_list|)
block|{
name|errorMsg
operator|=
name|exception
operator|.
name|message
argument_list|()
expr_stmt|;
name|errorLine
operator|=
name|exception
operator|.
name|lineNumber
argument_list|()
expr_stmt|;
name|errorColumn
operator|=
name|exception
operator|.
name|columnNumber
argument_list|()
expr_stmt|;
return|return
name|QXmlDefaultHandler
operator|::
name|fatalError
argument_list|(
name|exception
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|startCDATA
name|bool
name|QDomHandler
operator|::
name|startCDATA
parameter_list|()
block|{
name|cdata
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|endCDATA
name|bool
name|QDomHandler
operator|::
name|endCDATA
parameter_list|()
block|{
name|cdata
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|startEntity
name|bool
name|QDomHandler
operator|::
name|startEntity
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|entityName
operator|=
name|name
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|endEntity
name|bool
name|QDomHandler
operator|::
name|endEntity
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
name|entityName
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|comment
name|bool
name|QDomHandler
operator|::
name|comment
parameter_list|(
specifier|const
name|QString
modifier|&
name|ch
parameter_list|)
block|{
name|QDomNodePrivate
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|doc
operator|->
name|createComment
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|n
operator|->
name|setLocation
argument_list|(
name|locator
operator|->
name|lineNumber
argument_list|()
argument_list|,
name|locator
operator|->
name|columnNumber
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|->
name|appendChild
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|unparsedEntityDecl
name|bool
name|QDomHandler
operator|::
name|unparsedEntityDecl
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|publicId
parameter_list|,
specifier|const
name|QString
modifier|&
name|systemId
parameter_list|,
specifier|const
name|QString
modifier|&
name|notationName
parameter_list|)
block|{
name|QDomEntityPrivate
modifier|*
name|e
init|=
operator|new
name|QDomEntityPrivate
argument_list|(
name|doc
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|publicId
argument_list|,
name|systemId
argument_list|,
name|notationName
argument_list|)
decl_stmt|;
comment|// keep the refcount balanced: appendChild() does a ref anyway.
name|e
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
name|doc
operator|->
name|doctype
argument_list|()
operator|->
name|appendChild
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|externalEntityDecl
name|bool
name|QDomHandler
operator|::
name|externalEntityDecl
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|publicId
parameter_list|,
specifier|const
name|QString
modifier|&
name|systemId
parameter_list|)
block|{
return|return
name|unparsedEntityDecl
argument_list|(
name|name
argument_list|,
name|publicId
argument_list|,
name|systemId
argument_list|,
name|QString
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|notationDecl
name|bool
name|QDomHandler
operator|::
name|notationDecl
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|publicId
parameter_list|,
specifier|const
name|QString
modifier|&
name|systemId
parameter_list|)
block|{
name|QDomNotationPrivate
modifier|*
name|n
init|=
operator|new
name|QDomNotationPrivate
argument_list|(
name|doc
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|publicId
argument_list|,
name|systemId
argument_list|)
decl_stmt|;
comment|// keep the refcount balanced: appendChild() does a ref anyway.
name|n
operator|->
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
name|doc
operator|->
name|doctype
argument_list|()
operator|->
name|appendChild
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setDocumentLocator
name|void
name|QDomHandler
operator|::
name|setDocumentLocator
parameter_list|(
name|QXmlLocator
modifier|*
name|locator
parameter_list|)
block|{
name|this
operator|->
name|locator
operator|=
name|locator
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DOM
end_comment
end_unit
