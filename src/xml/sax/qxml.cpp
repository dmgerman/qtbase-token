begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtXml module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qxml.h"
end_include
begin_include
include|#
directive|include
file|"qtextcodec.h"
end_include
begin_include
include|#
directive|include
file|"qbuffer.h"
end_include
begin_include
include|#
directive|include
file|"qregexp.h"
end_include
begin_include
include|#
directive|include
file|"qmap.h"
end_include
begin_include
include|#
directive|include
file|"qstack.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_CC_BOR
end_ifdef
begin_comment
comment|// borland 6 finds bogus warnings when building this file in uic3
end_comment
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|8080
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//#define QT_QXML_DEBUG
end_comment
begin_comment
comment|// Error strings for the XML reader
end_comment
begin_define
DECL|macro|XMLERR_OK
define|#
directive|define
name|XMLERR_OK
value|QT_TRANSLATE_NOOP("QXml", "no error occurred")
end_define
begin_define
DECL|macro|XMLERR_ERRORBYCONSUMER
define|#
directive|define
name|XMLERR_ERRORBYCONSUMER
value|QT_TRANSLATE_NOOP("QXml", "error triggered by consumer")
end_define
begin_define
DECL|macro|XMLERR_UNEXPECTEDEOF
define|#
directive|define
name|XMLERR_UNEXPECTEDEOF
value|QT_TRANSLATE_NOOP("QXml", "unexpected end of file")
end_define
begin_define
DECL|macro|XMLERR_MORETHANONEDOCTYPE
define|#
directive|define
name|XMLERR_MORETHANONEDOCTYPE
value|QT_TRANSLATE_NOOP("QXml", "more than one document type definition")
end_define
begin_define
DECL|macro|XMLERR_ERRORPARSINGELEMENT
define|#
directive|define
name|XMLERR_ERRORPARSINGELEMENT
value|QT_TRANSLATE_NOOP("QXml", "error occurred while parsing element")
end_define
begin_define
DECL|macro|XMLERR_TAGMISMATCH
define|#
directive|define
name|XMLERR_TAGMISMATCH
value|QT_TRANSLATE_NOOP("QXml", "tag mismatch")
end_define
begin_define
DECL|macro|XMLERR_ERRORPARSINGCONTENT
define|#
directive|define
name|XMLERR_ERRORPARSINGCONTENT
value|QT_TRANSLATE_NOOP("QXml", "error occurred while parsing content")
end_define
begin_define
DECL|macro|XMLERR_UNEXPECTEDCHARACTER
define|#
directive|define
name|XMLERR_UNEXPECTEDCHARACTER
value|QT_TRANSLATE_NOOP("QXml", "unexpected character")
end_define
begin_define
DECL|macro|XMLERR_INVALIDNAMEFORPI
define|#
directive|define
name|XMLERR_INVALIDNAMEFORPI
value|QT_TRANSLATE_NOOP("QXml", "invalid name for processing instruction")
end_define
begin_define
DECL|macro|XMLERR_VERSIONEXPECTED
define|#
directive|define
name|XMLERR_VERSIONEXPECTED
value|QT_TRANSLATE_NOOP("QXml", "version expected while reading the XML declaration")
end_define
begin_define
DECL|macro|XMLERR_WRONGVALUEFORSDECL
define|#
directive|define
name|XMLERR_WRONGVALUEFORSDECL
value|QT_TRANSLATE_NOOP("QXml", "wrong value for standalone declaration")
end_define
begin_define
DECL|macro|XMLERR_EDECLORSDDECLEXPECTED
define|#
directive|define
name|XMLERR_EDECLORSDDECLEXPECTED
value|QT_TRANSLATE_NOOP("QXml", "encoding declaration or standalone declaration expected while reading the XML declaration")
end_define
begin_define
DECL|macro|XMLERR_SDDECLEXPECTED
define|#
directive|define
name|XMLERR_SDDECLEXPECTED
value|QT_TRANSLATE_NOOP("QXml", "standalone declaration expected while reading the XML declaration")
end_define
begin_define
DECL|macro|XMLERR_ERRORPARSINGDOCTYPE
define|#
directive|define
name|XMLERR_ERRORPARSINGDOCTYPE
value|QT_TRANSLATE_NOOP("QXml", "error occurred while parsing document type definition")
end_define
begin_define
DECL|macro|XMLERR_LETTEREXPECTED
define|#
directive|define
name|XMLERR_LETTEREXPECTED
value|QT_TRANSLATE_NOOP("QXml", "letter is expected")
end_define
begin_define
DECL|macro|XMLERR_ERRORPARSINGCOMMENT
define|#
directive|define
name|XMLERR_ERRORPARSINGCOMMENT
value|QT_TRANSLATE_NOOP("QXml", "error occurred while parsing comment")
end_define
begin_define
DECL|macro|XMLERR_ERRORPARSINGREFERENCE
define|#
directive|define
name|XMLERR_ERRORPARSINGREFERENCE
value|QT_TRANSLATE_NOOP("QXml", "error occurred while parsing reference")
end_define
begin_define
DECL|macro|XMLERR_INTERNALGENERALENTITYINDTD
define|#
directive|define
name|XMLERR_INTERNALGENERALENTITYINDTD
value|QT_TRANSLATE_NOOP("QXml", "internal general entity reference not allowed in DTD")
end_define
begin_define
DECL|macro|XMLERR_EXTERNALGENERALENTITYINAV
define|#
directive|define
name|XMLERR_EXTERNALGENERALENTITYINAV
value|QT_TRANSLATE_NOOP("QXml", "external parsed general entity reference not allowed in attribute value")
end_define
begin_define
DECL|macro|XMLERR_EXTERNALGENERALENTITYINDTD
define|#
directive|define
name|XMLERR_EXTERNALGENERALENTITYINDTD
value|QT_TRANSLATE_NOOP("QXml", "external parsed general entity reference not allowed in DTD")
end_define
begin_define
DECL|macro|XMLERR_UNPARSEDENTITYREFERENCE
define|#
directive|define
name|XMLERR_UNPARSEDENTITYREFERENCE
value|QT_TRANSLATE_NOOP("QXml", "unparsed entity reference in wrong context")
end_define
begin_define
DECL|macro|XMLERR_RECURSIVEENTITIES
define|#
directive|define
name|XMLERR_RECURSIVEENTITIES
value|QT_TRANSLATE_NOOP("QXml", "recursive entities")
end_define
begin_define
DECL|macro|XMLERR_ERRORINTEXTDECL
define|#
directive|define
name|XMLERR_ERRORINTEXTDECL
value|QT_TRANSLATE_NOOP("QXml", "error in the text declaration of an external entity")
end_define
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|// the constants for the lookup table
DECL|variable|cltWS
specifier|static
specifier|const
name|signed
name|char
name|cltWS
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cltWS
comment|// white space
end_comment
begin_decl_stmt
DECL|variable|cltPer
specifier|static
specifier|const
name|signed
name|char
name|cltPer
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cltPer
comment|// %
end_comment
begin_decl_stmt
DECL|variable|cltAmp
specifier|static
specifier|const
name|signed
name|char
name|cltAmp
init|=
literal|2
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cltAmp
comment|//&
end_comment
begin_decl_stmt
DECL|variable|cltGt
specifier|static
specifier|const
name|signed
name|char
name|cltGt
init|=
literal|3
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cltGt
comment|//>
end_comment
begin_decl_stmt
DECL|variable|cltLt
specifier|static
specifier|const
name|signed
name|char
name|cltLt
init|=
literal|4
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cltLt
comment|//<
end_comment
begin_decl_stmt
DECL|variable|cltSlash
specifier|static
specifier|const
name|signed
name|char
name|cltSlash
init|=
literal|5
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cltSlash
comment|// /
end_comment
begin_decl_stmt
DECL|variable|cltQm
specifier|static
specifier|const
name|signed
name|char
name|cltQm
init|=
literal|6
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cltQm
comment|// ?
end_comment
begin_decl_stmt
DECL|variable|cltEm
specifier|static
specifier|const
name|signed
name|char
name|cltEm
init|=
literal|7
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cltEm
comment|// !
end_comment
begin_decl_stmt
DECL|variable|cltDash
specifier|static
specifier|const
name|signed
name|char
name|cltDash
init|=
literal|8
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cltDash
comment|// -
end_comment
begin_decl_stmt
DECL|variable|cltCB
specifier|static
specifier|const
name|signed
name|char
name|cltCB
init|=
literal|9
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cltCB
comment|// ]
end_comment
begin_decl_stmt
DECL|variable|cltOB
specifier|static
specifier|const
name|signed
name|char
name|cltOB
init|=
literal|10
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cltOB
comment|// [
end_comment
begin_decl_stmt
DECL|variable|cltEq
specifier|static
specifier|const
name|signed
name|char
name|cltEq
init|=
literal|11
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cltEq
comment|// =
end_comment
begin_decl_stmt
DECL|variable|cltDq
specifier|static
specifier|const
name|signed
name|char
name|cltDq
init|=
literal|12
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cltDq
comment|// "
end_comment
begin_decl_stmt
DECL|variable|cltSq
specifier|static
specifier|const
name|signed
name|char
name|cltSq
init|=
literal|13
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cltSq
comment|// '
end_comment
begin_decl_stmt
DECL|variable|cltUnknown
specifier|static
specifier|const
name|signed
name|char
name|cltUnknown
init|=
literal|14
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Hack for letting QDom know where the skipped entity occurred
end_comment
begin_comment
comment|// ### the use of this variable means the code isn't reentrant.
end_comment
begin_decl_stmt
DECL|variable|qt_xml_skipped_entity_in_content
name|bool
name|qt_xml_skipped_entity_in_content
decl_stmt|;
end_decl_stmt
begin_comment
comment|// character lookup table
end_comment
begin_decl_stmt
DECL|variable|charLookupTable
specifier|static
specifier|const
name|signed
name|char
name|charLookupTable
index|[
literal|256
index|]
init|=
block|{
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x00 - 0x07
name|cltUnknown
block|,
comment|// 0x08
name|cltWS
block|,
comment|// 0x09 \t
name|cltWS
block|,
comment|// 0x0A \n
name|cltUnknown
block|,
comment|// 0x0B
name|cltUnknown
block|,
comment|// 0x0C
name|cltWS
block|,
comment|// 0x0D \r
name|cltUnknown
block|,
comment|// 0x0E
name|cltUnknown
block|,
comment|// 0x0F
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x17 - 0x16
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x18 - 0x1F
name|cltWS
block|,
comment|// 0x20 Space
name|cltEm
block|,
comment|// 0x21 !
name|cltDq
block|,
comment|// 0x22 "
name|cltUnknown
block|,
comment|// 0x23
name|cltUnknown
block|,
comment|// 0x24
name|cltPer
block|,
comment|// 0x25 %
name|cltAmp
block|,
comment|// 0x26&
name|cltSq
block|,
comment|// 0x27 '
name|cltUnknown
block|,
comment|// 0x28
name|cltUnknown
block|,
comment|// 0x29
name|cltUnknown
block|,
comment|// 0x2A
name|cltUnknown
block|,
comment|// 0x2B
name|cltUnknown
block|,
comment|// 0x2C
name|cltDash
block|,
comment|// 0x2D -
name|cltUnknown
block|,
comment|// 0x2E
name|cltSlash
block|,
comment|// 0x2F /
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x30 - 0x37
name|cltUnknown
block|,
comment|// 0x38
name|cltUnknown
block|,
comment|// 0x39
name|cltUnknown
block|,
comment|// 0x3A
name|cltUnknown
block|,
comment|// 0x3B
name|cltLt
block|,
comment|// 0x3C<
name|cltEq
block|,
comment|// 0x3D =
name|cltGt
block|,
comment|// 0x3E>
name|cltQm
block|,
comment|// 0x3F ?
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x40 - 0x47
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x48 - 0x4F
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x50 - 0x57
name|cltUnknown
block|,
comment|// 0x58
name|cltUnknown
block|,
comment|// 0x59
name|cltUnknown
block|,
comment|// 0x5A
name|cltOB
block|,
comment|// 0x5B [
name|cltUnknown
block|,
comment|// 0x5C
name|cltCB
block|,
comment|// 0x5D]
name|cltUnknown
block|,
comment|// 0x5E
name|cltUnknown
block|,
comment|// 0x5F
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x60 - 0x67
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x68 - 0x6F
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x70 - 0x77
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x78 - 0x7F
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x80 - 0x87
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x88 - 0x8F
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x90 - 0x97
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0x98 - 0x9F
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0xA0 - 0xA7
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0xA8 - 0xAF
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0xB0 - 0xB7
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0xB8 - 0xBF
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0xC0 - 0xC7
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0xC8 - 0xCF
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0xD0 - 0xD7
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0xD8 - 0xDF
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0xE0 - 0xE7
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0xE8 - 0xEF
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
comment|// 0xF0 - 0xF7
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
block|,
name|cltUnknown
comment|// 0xF8 - 0xFF
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|//
end_comment
begin_comment
comment|// local helper functions
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|/*   This function strips the TextDecl [77] ("<?xml ...?>") from the string \a   str. The stripped version is stored in \a str. If this function finds an   invalid TextDecl, it returns false, otherwise true.    This function is used for external entities since those can include an   TextDecl that must be stripped before inserting the entity. */
end_comment
begin_function
DECL|function|stripTextDecl
specifier|static
name|bool
name|stripTextDecl
parameter_list|(
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|QString
name|textDeclStart
argument_list|(
name|QLatin1String
argument_list|(
literal|"<?xml"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|.
name|startsWith
argument_list|(
name|textDeclStart
argument_list|)
condition|)
block|{
name|QRegExp
name|textDecl
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"^<\\?xml\\s+"
literal|"(version\\s*=\\s*((['\"])[-a-zA-Z0-9_.:]+\\3))?"
literal|"\\s*"
literal|"(encoding\\s*=\\s*((['\"])[A-Za-z][-a-zA-Z0-9_.]*\\6))?"
literal|"\\s*\\?>"
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|strTmp
init|=
name|str
operator|.
name|replace
argument_list|(
name|textDecl
argument_list|,
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strTmp
operator|.
name|length
argument_list|()
operator|!=
name|str
operator|.
name|length
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// external entity has wrong TextDecl
name|str
operator|=
name|strTmp
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_class
DECL|class|QXmlAttributesPrivate
class|class
name|QXmlAttributesPrivate
block|{
block|}
class|;
end_class
begin_comment
comment|/* \class QXmlInputSourcePrivate     \internal    There's a slight misdesign in this class that can   be worth to keep in mind: the `str' member is   a buffer which QXmlInputSource::next() returns from,   and which is populated from the input device or input   stream. However, when the input is a QString(the user called   QXmlInputSource::setData()), `str' has two roles: it's the   buffer, but also the source. This /seems/ to be no problem   because in the case of having no device or stream, the QString   is read in one go.  */
end_comment
begin_class
DECL|class|QXmlInputSourcePrivate
class|class
name|QXmlInputSourcePrivate
block|{
public|public:
DECL|member|inputDevice
name|QIODevice
modifier|*
name|inputDevice
decl_stmt|;
DECL|member|inputStream
name|QTextStream
modifier|*
name|inputStream
decl_stmt|;
DECL|member|str
name|QString
name|str
decl_stmt|;
DECL|member|unicode
specifier|const
name|QChar
modifier|*
name|unicode
decl_stmt|;
DECL|member|pos
name|int
name|pos
decl_stmt|;
DECL|member|length
name|int
name|length
decl_stmt|;
DECL|member|nextReturnedEndOfData
name|bool
name|nextReturnedEndOfData
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
DECL|member|encMapper
name|QTextDecoder
modifier|*
name|encMapper
decl_stmt|;
endif|#
directive|endif
DECL|member|encodingDeclBytes
name|QByteArray
name|encodingDeclBytes
decl_stmt|;
DECL|member|encodingDeclChars
name|QString
name|encodingDeclChars
decl_stmt|;
DECL|member|lookingForEncodingDecl
name|bool
name|lookingForEncodingDecl
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QXmlParseExceptionPrivate
class|class
name|QXmlParseExceptionPrivate
block|{
public|public:
DECL|function|QXmlParseExceptionPrivate
name|QXmlParseExceptionPrivate
parameter_list|()
member_init_list|:
name|column
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|line
argument_list|(
operator|-
literal|1
argument_list|)
block|{     }
DECL|function|QXmlParseExceptionPrivate
name|QXmlParseExceptionPrivate
parameter_list|(
specifier|const
name|QXmlParseExceptionPrivate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|msg
argument_list|(
name|other
operator|.
name|msg
argument_list|)
member_init_list|,
name|column
argument_list|(
name|other
operator|.
name|column
argument_list|)
member_init_list|,
name|line
argument_list|(
name|other
operator|.
name|line
argument_list|)
member_init_list|,
name|pub
argument_list|(
name|other
operator|.
name|pub
argument_list|)
member_init_list|,
name|sys
argument_list|(
name|other
operator|.
name|sys
argument_list|)
block|{     }
DECL|member|msg
name|QString
name|msg
decl_stmt|;
DECL|member|column
name|int
name|column
decl_stmt|;
DECL|member|line
name|int
name|line
decl_stmt|;
DECL|member|pub
name|QString
name|pub
decl_stmt|;
DECL|member|sys
name|QString
name|sys
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QXmlLocatorPrivate
class|class
name|QXmlLocatorPrivate
block|{
block|}
class|;
end_class
begin_class
DECL|class|QXmlDefaultHandlerPrivate
class|class
name|QXmlDefaultHandlerPrivate
block|{
block|}
class|;
end_class
begin_class
DECL|class|QXmlSimpleReaderPrivate
class|class
name|QXmlSimpleReaderPrivate
block|{
public|public:
name|~
name|QXmlSimpleReaderPrivate
parameter_list|()
destructor_decl|;
private|private:
comment|// functions
name|QXmlSimpleReaderPrivate
parameter_list|(
name|QXmlSimpleReader
modifier|*
name|reader
parameter_list|)
constructor_decl|;
name|void
name|initIncrementalParsing
parameter_list|()
function_decl|;
comment|// used to determine if elements are correctly nested
DECL|member|tags
name|QStack
argument_list|<
name|QString
argument_list|>
name|tags
decl_stmt|;
comment|// used by parseReference() and parsePEReference()
DECL|enum|EntityRecognitionContext
DECL|enumerator|InContent
DECL|enumerator|InAttributeValue
DECL|enumerator|InEntityValue
DECL|enumerator|InDTD
enum|enum
name|EntityRecognitionContext
block|{
name|InContent
block|,
name|InAttributeValue
block|,
name|InEntityValue
block|,
name|InDTD
block|}
enum|;
comment|// used for entity declarations
DECL|struct|ExternParameterEntity
struct|struct
name|ExternParameterEntity
block|{
DECL|function|ExternParameterEntity
name|ExternParameterEntity
parameter_list|()
block|{}
DECL|function|ExternParameterEntity
name|ExternParameterEntity
parameter_list|(
specifier|const
name|QString
modifier|&
name|p
parameter_list|,
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
member_init_list|:
name|publicId
argument_list|(
name|p
argument_list|)
member_init_list|,
name|systemId
argument_list|(
name|s
argument_list|)
block|{}
DECL|member|publicId
name|QString
name|publicId
decl_stmt|;
DECL|member|systemId
name|QString
name|systemId
decl_stmt|;
name|Q_DUMMY_COMPARISON_OPERATOR
argument_list|(
argument|ExternParameterEntity
argument_list|)
block|}
struct|;
DECL|struct|ExternEntity
struct|struct
name|ExternEntity
block|{
DECL|function|ExternEntity
name|ExternEntity
parameter_list|()
block|{}
DECL|function|ExternEntity
name|ExternEntity
parameter_list|(
specifier|const
name|QString
modifier|&
name|p
parameter_list|,
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
specifier|const
name|QString
modifier|&
name|n
parameter_list|)
member_init_list|:
name|publicId
argument_list|(
name|p
argument_list|)
member_init_list|,
name|systemId
argument_list|(
name|s
argument_list|)
member_init_list|,
name|notation
argument_list|(
name|n
argument_list|)
block|{}
DECL|member|publicId
name|QString
name|publicId
decl_stmt|;
DECL|member|systemId
name|QString
name|systemId
decl_stmt|;
DECL|member|notation
name|QString
name|notation
decl_stmt|;
name|Q_DUMMY_COMPARISON_OPERATOR
argument_list|(
argument|ExternEntity
argument_list|)
block|}
struct|;
DECL|member|externParameterEntities
name|QMap
argument_list|<
name|QString
argument_list|,
name|ExternParameterEntity
argument_list|>
name|externParameterEntities
decl_stmt|;
DECL|member|parameterEntities
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|parameterEntities
decl_stmt|;
DECL|member|externEntities
name|QMap
argument_list|<
name|QString
argument_list|,
name|ExternEntity
argument_list|>
name|externEntities
decl_stmt|;
DECL|member|entities
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|entities
decl_stmt|;
comment|// used for parsing of entity references
DECL|struct|XmlRef
struct|struct
name|XmlRef
block|{
DECL|function|XmlRef
name|XmlRef
parameter_list|()
member_init_list|:
name|index
argument_list|(
literal|0
argument_list|)
block|{}
DECL|function|XmlRef
name|XmlRef
parameter_list|(
specifier|const
name|QString
modifier|&
name|_name
parameter_list|,
specifier|const
name|QString
modifier|&
name|_value
parameter_list|)
member_init_list|:
name|name
argument_list|(
name|_name
argument_list|)
member_init_list|,
name|value
argument_list|(
name|_value
argument_list|)
member_init_list|,
name|index
argument_list|(
literal|0
argument_list|)
block|{}
DECL|function|isEmpty
name|bool
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
name|index
operator|==
name|value
operator|.
name|length
argument_list|()
return|;
block|}
DECL|function|next
name|QChar
name|next
parameter_list|()
block|{
return|return
name|value
operator|.
name|at
argument_list|(
name|index
operator|++
argument_list|)
return|;
block|}
DECL|member|name
name|QString
name|name
decl_stmt|;
DECL|member|value
name|QString
name|value
decl_stmt|;
DECL|member|index
name|int
name|index
decl_stmt|;
block|}
struct|;
DECL|member|xmlRefStack
name|QStack
argument_list|<
name|XmlRef
argument_list|>
name|xmlRefStack
decl_stmt|;
comment|// used for standalone declaration
DECL|enum|Standalone
DECL|enumerator|Yes
DECL|enumerator|No
DECL|enumerator|Unknown
enum|enum
name|Standalone
block|{
name|Yes
block|,
name|No
block|,
name|Unknown
block|}
enum|;
DECL|member|doctype
name|QString
name|doctype
decl_stmt|;
comment|// only used for the doctype
DECL|member|xmlVersion
name|QString
name|xmlVersion
decl_stmt|;
comment|// only used to store the version information
DECL|member|encoding
name|QString
name|encoding
decl_stmt|;
comment|// only used to store the encoding
DECL|member|standalone
name|Standalone
name|standalone
decl_stmt|;
comment|// used to store the value of the standalone declaration
DECL|member|publicId
name|QString
name|publicId
decl_stmt|;
comment|// used by parseExternalID() to store the public ID
DECL|member|systemId
name|QString
name|systemId
decl_stmt|;
comment|// used by parseExternalID() to store the system ID
comment|// Since publicId/systemId is used as temporary variables by parseExternalID(), it
comment|// might overwrite the PUBLIC/SYSTEM for the document we're parsing. In effect, we would
comment|// possibly send off an QXmlParseException that has the PUBLIC/SYSTEM of a entity declaration
comment|// instead of those of the current document.
comment|// Hence we have these two variables for storing the document's data.
DECL|member|thisPublicId
name|QString
name|thisPublicId
decl_stmt|;
DECL|member|thisSystemId
name|QString
name|thisSystemId
decl_stmt|;
DECL|member|attDeclEName
name|QString
name|attDeclEName
decl_stmt|;
comment|// use by parseAttlistDecl()
DECL|member|attDeclAName
name|QString
name|attDeclAName
decl_stmt|;
comment|// use by parseAttlistDecl()
comment|// flags for some features support
DECL|member|useNamespaces
name|bool
name|useNamespaces
decl_stmt|;
DECL|member|useNamespacePrefixes
name|bool
name|useNamespacePrefixes
decl_stmt|;
DECL|member|reportWhitespaceCharData
name|bool
name|reportWhitespaceCharData
decl_stmt|;
DECL|member|reportEntities
name|bool
name|reportEntities
decl_stmt|;
comment|// used to build the attribute list
DECL|member|attList
name|QXmlAttributes
name|attList
decl_stmt|;
comment|// used in QXmlSimpleReader::parseContent() to decide whether character
comment|// data was read
DECL|member|contentCharDataRead
name|bool
name|contentCharDataRead
decl_stmt|;
comment|// helper classes
DECL|member|locator
name|QScopedPointer
argument_list|<
name|QXmlLocator
argument_list|>
name|locator
decl_stmt|;
DECL|member|namespaceSupport
name|QXmlNamespaceSupport
name|namespaceSupport
decl_stmt|;
comment|// error string
DECL|member|error
name|QString
name|error
decl_stmt|;
comment|// arguments for parse functions (this is needed to allow incremental
comment|// parsing)
DECL|member|parsePI_xmldecl
name|bool
name|parsePI_xmldecl
decl_stmt|;
DECL|member|parseName_useRef
name|bool
name|parseName_useRef
decl_stmt|;
DECL|member|parseReference_charDataRead
name|bool
name|parseReference_charDataRead
decl_stmt|;
DECL|member|parseReference_context
name|EntityRecognitionContext
name|parseReference_context
decl_stmt|;
DECL|member|parseExternalID_allowPublicID
name|bool
name|parseExternalID_allowPublicID
decl_stmt|;
DECL|member|parsePEReference_context
name|EntityRecognitionContext
name|parsePEReference_context
decl_stmt|;
DECL|member|parseString_s
name|QString
name|parseString_s
decl_stmt|;
comment|// for incremental parsing
DECL|struct|ParseState
struct|struct
name|ParseState
block|{
DECL|typedef|ParseFunction
typedef|typedef
name|bool
function_decl|(
name|QXmlSimpleReaderPrivate
operator|::
modifier|*
name|ParseFunction
function_decl|)
parameter_list|()
function_decl|;
DECL|member|function
name|ParseFunction
name|function
decl_stmt|;
DECL|member|state
name|int
name|state
decl_stmt|;
block|}
struct|;
DECL|member|parseStack
name|QStack
argument_list|<
name|ParseState
argument_list|>
modifier|*
name|parseStack
decl_stmt|;
comment|// used in parseProlog()
DECL|member|xmldecl_possible
name|bool
name|xmldecl_possible
decl_stmt|;
DECL|member|doctype_read
name|bool
name|doctype_read
decl_stmt|;
comment|// used in parseDoctype()
DECL|member|startDTDwasReported
name|bool
name|startDTDwasReported
decl_stmt|;
comment|// used in parseString()
DECL|member|Done
name|signed
name|char
name|Done
decl_stmt|;
comment|// variables
DECL|member|contentHnd
name|QXmlContentHandler
modifier|*
name|contentHnd
decl_stmt|;
DECL|member|errorHnd
name|QXmlErrorHandler
modifier|*
name|errorHnd
decl_stmt|;
DECL|member|dtdHnd
name|QXmlDTDHandler
modifier|*
name|dtdHnd
decl_stmt|;
DECL|member|entityRes
name|QXmlEntityResolver
modifier|*
name|entityRes
decl_stmt|;
DECL|member|lexicalHnd
name|QXmlLexicalHandler
modifier|*
name|lexicalHnd
decl_stmt|;
DECL|member|declHnd
name|QXmlDeclHandler
modifier|*
name|declHnd
decl_stmt|;
DECL|member|inputSource
name|QXmlInputSource
modifier|*
name|inputSource
decl_stmt|;
DECL|member|c
name|QChar
name|c
decl_stmt|;
comment|// the character at reading position
DECL|member|lineNr
name|int
name|lineNr
decl_stmt|;
comment|// number of line
DECL|member|columnNr
name|int
name|columnNr
decl_stmt|;
comment|// position in line
DECL|member|nameArray
name|QChar
name|nameArray
index|[
literal|256
index|]
decl_stmt|;
comment|// only used for names
DECL|member|nameValue
name|QString
name|nameValue
decl_stmt|;
comment|// only used for names
DECL|member|nameArrayPos
name|int
name|nameArrayPos
decl_stmt|;
DECL|member|nameValueLen
name|int
name|nameValueLen
decl_stmt|;
DECL|member|refArray
name|QChar
name|refArray
index|[
literal|256
index|]
decl_stmt|;
comment|// only used for references
DECL|member|refValue
name|QString
name|refValue
decl_stmt|;
comment|// only used for references
DECL|member|refArrayPos
name|int
name|refArrayPos
decl_stmt|;
DECL|member|refValueLen
name|int
name|refValueLen
decl_stmt|;
DECL|member|stringArray
name|QChar
name|stringArray
index|[
literal|256
index|]
decl_stmt|;
comment|// used for any other strings that are parsed
DECL|member|stringValue
name|QString
name|stringValue
decl_stmt|;
comment|// used for any other strings that are parsed
DECL|member|stringArrayPos
name|int
name|stringArrayPos
decl_stmt|;
DECL|member|stringValueLen
name|int
name|stringValueLen
decl_stmt|;
DECL|member|emptyStr
name|QString
name|emptyStr
decl_stmt|;
specifier|const
name|QString
modifier|&
name|string
parameter_list|()
function_decl|;
name|void
name|stringClear
parameter_list|()
function_decl|;
name|void
name|stringAddC
parameter_list|(
name|QChar
parameter_list|)
function_decl|;
DECL|function|stringAddC
specifier|inline
name|void
name|stringAddC
parameter_list|()
block|{
name|stringAddC
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
specifier|const
name|QString
modifier|&
name|name
parameter_list|()
function_decl|;
name|void
name|nameClear
parameter_list|()
function_decl|;
name|void
name|nameAddC
parameter_list|(
name|QChar
parameter_list|)
function_decl|;
DECL|function|nameAddC
specifier|inline
name|void
name|nameAddC
parameter_list|()
block|{
name|nameAddC
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
specifier|const
name|QString
modifier|&
name|ref
parameter_list|()
function_decl|;
name|void
name|refClear
parameter_list|()
function_decl|;
name|void
name|refAddC
parameter_list|(
name|QChar
parameter_list|)
function_decl|;
DECL|function|refAddC
specifier|inline
name|void
name|refAddC
parameter_list|()
block|{
name|refAddC
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|// private functions
name|bool
name|eat_ws
parameter_list|()
function_decl|;
name|bool
name|next_eat_ws
parameter_list|()
function_decl|;
name|void
name|QT_FASTCALL
name|next
parameter_list|()
function_decl|;
name|bool
name|atEnd
parameter_list|()
function_decl|;
name|void
name|init
parameter_list|(
specifier|const
name|QXmlInputSource
modifier|*
name|i
parameter_list|)
function_decl|;
name|void
name|initData
parameter_list|()
function_decl|;
name|bool
name|entityExist
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
specifier|const
function_decl|;
name|bool
name|parseBeginOrContinue
parameter_list|(
name|int
name|state
parameter_list|,
name|bool
name|incremental
parameter_list|)
function_decl|;
name|bool
name|parseProlog
parameter_list|()
function_decl|;
name|bool
name|parseElement
parameter_list|()
function_decl|;
name|bool
name|processElementEmptyTag
parameter_list|()
function_decl|;
name|bool
name|processElementETagBegin2
parameter_list|()
function_decl|;
name|bool
name|processElementAttribute
parameter_list|()
function_decl|;
name|bool
name|parseMisc
parameter_list|()
function_decl|;
name|bool
name|parseContent
parameter_list|()
function_decl|;
name|bool
name|parsePI
parameter_list|()
function_decl|;
name|bool
name|parseDoctype
parameter_list|()
function_decl|;
name|bool
name|parseComment
parameter_list|()
function_decl|;
name|bool
name|parseName
parameter_list|()
function_decl|;
name|bool
name|parseNmtoken
parameter_list|()
function_decl|;
name|bool
name|parseAttribute
parameter_list|()
function_decl|;
name|bool
name|parseReference
parameter_list|()
function_decl|;
name|bool
name|processReference
parameter_list|()
function_decl|;
name|bool
name|parseExternalID
parameter_list|()
function_decl|;
name|bool
name|parsePEReference
parameter_list|()
function_decl|;
name|bool
name|parseMarkupdecl
parameter_list|()
function_decl|;
name|bool
name|parseAttlistDecl
parameter_list|()
function_decl|;
name|bool
name|parseAttType
parameter_list|()
function_decl|;
name|bool
name|parseAttValue
parameter_list|()
function_decl|;
name|bool
name|parseElementDecl
parameter_list|()
function_decl|;
name|bool
name|parseNotationDecl
parameter_list|()
function_decl|;
name|bool
name|parseChoiceSeq
parameter_list|()
function_decl|;
name|bool
name|parseEntityDecl
parameter_list|()
function_decl|;
name|bool
name|parseEntityValue
parameter_list|()
function_decl|;
name|bool
name|parseString
parameter_list|()
function_decl|;
name|bool
name|insertXmlRef
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
name|bool
parameter_list|)
function_decl|;
name|bool
name|reportEndEntities
parameter_list|()
function_decl|;
name|void
name|reportParseError
parameter_list|(
specifier|const
name|QString
modifier|&
name|error
parameter_list|)
function_decl|;
DECL|typedef|ParseFunction
typedef|typedef
name|bool
function_decl|(
name|QXmlSimpleReaderPrivate
operator|::
modifier|*
name|ParseFunction
function_decl|)
parameter_list|()
function_decl|;
name|void
name|unexpectedEof
parameter_list|(
name|ParseFunction
name|where
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
name|void
name|parseFailed
parameter_list|(
name|ParseFunction
name|where
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
name|void
name|pushParseState
parameter_list|(
name|ParseFunction
name|function
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
name|Q_DECLARE_PUBLIC
argument_list|(
argument|QXmlSimpleReader
argument_list|)
DECL|member|q_ptr
name|QXmlSimpleReader
modifier|*
name|q_ptr
decl_stmt|;
friend|friend
class_decl|class
name|QXmlSimpleReaderLocator
class_decl|;
block|}
class|;
end_class
begin_comment
comment|/*!     \class QXmlParseException     \reentrant     \brief The QXmlParseException class is used to report errors with     the QXmlErrorHandler interface.      \inmodule QtXml     \ingroup xml-tools      The XML subsystem constructs an instance of this class when it     detects an error. You can retrieve the place where the error     occurred using systemId(), publicId(), lineNumber() and     columnNumber(), along with the error message(). The possible error     messages are:       \list         \li "no error occurred"         \li "error triggered by consumer"         \li "unexpected end of file"         \li "more than one document type definition"         \li "error occurred while parsing element"         \li "tag mismatch"         \li "error occurred while parsing content"         \li "unexpected character"         \li "invalid name for processing instruction"         \li "version expected while reading the XML declaration"         \li "wrong value for standalone declaration"         \li "encoding declaration or standalone declaration expected while reading the XML declaration"         \li "standalone declaration expected while reading the XML declaration"         \li "error occurred while parsing document type definition"         \li "letter is expected"         \li "error occurred while parsing comment"         \li "error occurred while parsing reference"         \li "internal general entity reference not allowed in DTD"         \li "external parsed general entity reference not allowed in attribute value"         \li "external parsed general entity reference not allowed in DTD"         \li "unparsed entity reference n wrong context"         \li "recursive entities"         \li "error in the text declaration of an external entity"     \endlist      Note that, if you want to display these error messages to your     application's users, they will be displayed in English unless     they are explicitly translated.      \sa QXmlErrorHandler, QXmlReader */
end_comment
begin_comment
comment|/*!     Constructs a parse exception with the error string \a name for     column \a c and line \a l for the public identifier \a p and the     system identifier \a s. */
end_comment
begin_constructor
DECL|function|QXmlParseException
name|QXmlParseException
operator|::
name|QXmlParseException
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|l
parameter_list|,
specifier|const
name|QString
modifier|&
name|p
parameter_list|,
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QXmlParseExceptionPrivate
argument_list|)
block|{
name|d
operator|->
name|msg
operator|=
name|name
expr_stmt|;
name|d
operator|->
name|column
operator|=
name|c
expr_stmt|;
name|d
operator|->
name|line
operator|=
name|l
expr_stmt|;
name|d
operator|->
name|pub
operator|=
name|p
expr_stmt|;
name|d
operator|->
name|sys
operator|=
name|s
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Creates a copy of \a other. */
end_comment
begin_constructor
DECL|function|QXmlParseException
name|QXmlParseException
operator|::
name|QXmlParseException
parameter_list|(
specifier|const
name|QXmlParseException
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QXmlParseExceptionPrivate
argument_list|(
operator|*
name|other
operator|.
name|d
argument_list|)
argument_list|)
block|{  }
end_constructor
begin_comment
comment|/*!     Destroys the QXmlParseException. */
end_comment
begin_destructor
DECL|function|~QXmlParseException
name|QXmlParseException
operator|::
name|~
name|QXmlParseException
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the error message. */
end_comment
begin_function
DECL|function|message
name|QString
name|QXmlParseException
operator|::
name|message
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|msg
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the column number where the error occurred. */
end_comment
begin_function
DECL|function|columnNumber
name|int
name|QXmlParseException
operator|::
name|columnNumber
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|column
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the line number where the error occurred. */
end_comment
begin_function
DECL|function|lineNumber
name|int
name|QXmlParseException
operator|::
name|lineNumber
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|line
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the public identifier where the error occurred. */
end_comment
begin_function
DECL|function|publicId
name|QString
name|QXmlParseException
operator|::
name|publicId
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|pub
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the system identifier where the error occurred. */
end_comment
begin_function
DECL|function|systemId
name|QString
name|QXmlParseException
operator|::
name|systemId
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|sys
return|;
block|}
end_function
begin_comment
comment|/*!     \class QXmlLocator     \reentrant     \brief The QXmlLocator class provides the XML handler classes with     information about the parsing position within a file.      \inmodule QtXml     \ingroup xml-tools      The reader reports a QXmlLocator to the content handler before it     starts to parse the document. This is done with the     QXmlContentHandler::setDocumentLocator() function. The handler     classes can now use this locator to get the position (lineNumber()     and columnNumber()) that the reader has reached. */
end_comment
begin_comment
comment|/*!     Constructor. */
end_comment
begin_constructor
DECL|function|QXmlLocator
name|QXmlLocator
operator|::
name|QXmlLocator
parameter_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     Destructor. */
end_comment
begin_destructor
DECL|function|~QXmlLocator
name|QXmlLocator
operator|::
name|~
name|QXmlLocator
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \fn int QXmlLocator::columnNumber() const      Returns the column number (starting at 1) or -1 if there is no     column number available. */
end_comment
begin_comment
comment|/*!     \fn int QXmlLocator::lineNumber() const      Returns the line number (starting at 1) or -1 if there is no line     number available. */
end_comment
begin_class
DECL|class|QXmlSimpleReaderLocator
class|class
name|QXmlSimpleReaderLocator
super|:
specifier|public
name|QXmlLocator
block|{
public|public:
DECL|function|QXmlSimpleReaderLocator
name|QXmlSimpleReaderLocator
parameter_list|(
name|QXmlSimpleReader
modifier|*
name|parent
parameter_list|)
block|{
name|reader
operator|=
name|parent
expr_stmt|;
block|}
DECL|function|~QXmlSimpleReaderLocator
name|~
name|QXmlSimpleReaderLocator
parameter_list|()
block|{     }
DECL|function|columnNumber
name|int
name|columnNumber
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|reader
operator|->
name|d_ptr
operator|->
name|columnNr
operator|==
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
name|reader
operator|->
name|d_ptr
operator|->
name|columnNr
operator|+
literal|1
operator|)
return|;
block|}
DECL|function|lineNumber
name|int
name|lineNumber
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|reader
operator|->
name|d_ptr
operator|->
name|lineNr
operator|==
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
name|reader
operator|->
name|d_ptr
operator|->
name|lineNr
operator|+
literal|1
operator|)
return|;
block|}
comment|//    QString getPublicId()
comment|//    QString getSystemId()
private|private:
DECL|member|reader
name|QXmlSimpleReader
modifier|*
name|reader
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*********************************************  *  * QXmlNamespaceSupport  *  *********************************************/
end_comment
begin_typedef
DECL|typedef|NamespaceMap
typedef|typedef
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|NamespaceMap
typedef|;
end_typedef
begin_class
DECL|class|QXmlNamespaceSupportPrivate
class|class
name|QXmlNamespaceSupportPrivate
block|{
public|public:
DECL|function|QXmlNamespaceSupportPrivate
name|QXmlNamespaceSupportPrivate
parameter_list|()
block|{
name|ns
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|"xml"
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"http://www.w3.org/XML/1998/namespace"
argument_list|)
argument_list|)
expr_stmt|;
comment|// the XML namespace
block|}
DECL|function|~QXmlNamespaceSupportPrivate
name|~
name|QXmlNamespaceSupportPrivate
parameter_list|()
block|{     }
DECL|member|nsStack
name|QStack
argument_list|<
name|NamespaceMap
argument_list|>
name|nsStack
decl_stmt|;
DECL|member|ns
name|NamespaceMap
name|ns
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     \class QXmlNamespaceSupport     \since 4.4     \reentrant     \brief The QXmlNamespaceSupport class is a helper class for XML     readers which want to include namespace support.      \inmodule QtXml     \ingroup xml-tools      You can set the prefix for the current namespace with setPrefix(),     and get the list of current prefixes (or those for a given URI)     with prefixes(). The namespace URI is available from uri(). Use     pushContext() to start a new namespace context, and popContext()     to return to the previous namespace context. Use splitName() or     processName() to split a name into its prefix and local name.      \sa {Namespace Support via Features} */
end_comment
begin_comment
comment|/*!     Constructs a QXmlNamespaceSupport. */
end_comment
begin_constructor
DECL|function|QXmlNamespaceSupport
name|QXmlNamespaceSupport
operator|::
name|QXmlNamespaceSupport
parameter_list|()
block|{
name|d
operator|=
operator|new
name|QXmlNamespaceSupportPrivate
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys a QXmlNamespaceSupport. */
end_comment
begin_destructor
DECL|function|~QXmlNamespaceSupport
name|QXmlNamespaceSupport
operator|::
name|~
name|QXmlNamespaceSupport
parameter_list|()
block|{
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     This function declares a prefix \a pre in the current namespace     context to be the namespace URI \a uri. The prefix remains in     force until this context is popped, unless it is shadowed in a     descendant context.      Note that there is an asymmetry in this library. prefix() does not     return the default "" prefix, even if you have declared one; to     check for a default prefix, you must look it up explicitly using     uri(). This asymmetry exists to make it easier to look up prefixes     for attribute names, where the default prefix is not allowed. */
end_comment
begin_function
DECL|function|setPrefix
name|void
name|QXmlNamespaceSupport
operator|::
name|setPrefix
parameter_list|(
specifier|const
name|QString
modifier|&
name|pre
parameter_list|,
specifier|const
name|QString
modifier|&
name|uri
parameter_list|)
block|{
if|if
condition|(
name|pre
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|d
operator|->
name|ns
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|uri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|ns
operator|.
name|insert
argument_list|(
name|pre
argument_list|,
name|uri
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns one of the prefixes mapped to the namespace URI \a uri.      If more than one prefix is currently mapped to the same URI, this     function makes an arbitrary selection; if you want all of the     prefixes, use prefixes() instead.      Note: to check for a default prefix, use the uri() function with     an argument of "". */
end_comment
begin_function
DECL|function|prefix
name|QString
name|QXmlNamespaceSupport
operator|::
name|prefix
parameter_list|(
specifier|const
name|QString
modifier|&
name|uri
parameter_list|)
specifier|const
block|{
name|NamespaceMap
operator|::
name|const_iterator
name|itc
decl_stmt|,
name|it
init|=
name|d
operator|->
name|ns
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|itc
operator|=
name|it
operator|)
operator|!=
name|d
operator|->
name|ns
operator|.
name|constEnd
argument_list|()
condition|)
block|{
operator|++
name|it
expr_stmt|;
if|if
condition|(
operator|*
name|itc
operator|==
name|uri
operator|&&
operator|!
name|itc
operator|.
name|key
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|itc
operator|.
name|key
argument_list|()
return|;
block|}
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Looks up the prefix \a prefix in the current context and returns     the currently-mapped namespace URI. Use the empty string ("") for     the default namespace. */
end_comment
begin_function
DECL|function|uri
name|QString
name|QXmlNamespaceSupport
operator|::
name|uri
parameter_list|(
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|ns
index|[
name|prefix
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     Splits the name \a qname at the ':' and returns the prefix in \a     prefix and the local name in \a localname.      \sa processName() */
end_comment
begin_function
DECL|function|splitName
name|void
name|QXmlNamespaceSupport
operator|::
name|splitName
parameter_list|(
specifier|const
name|QString
modifier|&
name|qname
parameter_list|,
name|QString
modifier|&
name|prefix
parameter_list|,
name|QString
modifier|&
name|localname
parameter_list|)
specifier|const
block|{
name|int
name|pos
init|=
name|qname
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
name|pos
operator|=
name|qname
operator|.
name|size
argument_list|()
expr_stmt|;
name|prefix
operator|=
name|qname
operator|.
name|left
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|localname
operator|=
name|qname
operator|.
name|mid
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Processes a raw XML 1.0 name in the current context by removing     the prefix and looking it up among the prefixes currently     declared.      \a qname is the raw XML 1.0 name to be processed. \a isAttribute     is true if the name is an attribute name.      This function stores the namespace URI in \a nsuri (which will be     set to an empty string if the raw name has an undeclared prefix),     and stores the local name (without prefix) in \a localname (which     will be set to an empty string if no namespace is in use).      Note that attribute names are processed differently than element     names: an unprefixed element name gets the default namespace (if     any), while an unprefixed attribute name does not. */
end_comment
begin_function
DECL|function|processName
name|void
name|QXmlNamespaceSupport
operator|::
name|processName
parameter_list|(
specifier|const
name|QString
modifier|&
name|qname
parameter_list|,
name|bool
name|isAttribute
parameter_list|,
name|QString
modifier|&
name|nsuri
parameter_list|,
name|QString
modifier|&
name|localname
parameter_list|)
specifier|const
block|{
name|int
name|len
init|=
name|qname
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|data
init|=
name|qname
operator|.
name|constData
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|len
condition|;
operator|++
name|pos
control|)
block|{
if|if
condition|(
name|data
index|[
name|pos
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
condition|)
block|{
name|nsuri
operator|=
name|uri
argument_list|(
name|qname
operator|.
name|left
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|localname
operator|=
name|qname
operator|.
name|mid
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// there was no ':'
name|nsuri
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// attributes don't take default namespace
if|if
condition|(
operator|!
name|isAttribute
operator|&&
operator|!
name|d
operator|->
name|ns
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|/* 	    We want to access d->ns.value(""), but as an optimization 	    we use the fact that "" compares less than any other 	    string, so it's either first in the map or not there. 	*/
name|NamespaceMap
operator|::
name|const_iterator
name|first
init|=
name|d
operator|->
name|ns
operator|.
name|constBegin
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
operator|.
name|key
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|nsuri
operator|=
name|first
operator|.
name|value
argument_list|()
expr_stmt|;
comment|// get default namespace
block|}
name|localname
operator|=
name|qname
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all the prefixes currently declared.      If there is a default prefix, this function does not return it in     the list; check for the default prefix using uri() with an     argument of "". */
end_comment
begin_function
DECL|function|prefixes
name|QStringList
name|QXmlNamespaceSupport
operator|::
name|prefixes
parameter_list|()
specifier|const
block|{
name|QStringList
name|list
decl_stmt|;
name|NamespaceMap
operator|::
name|const_iterator
name|itc
decl_stmt|,
name|it
init|=
name|d
operator|->
name|ns
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|itc
operator|=
name|it
operator|)
operator|!=
name|d
operator|->
name|ns
operator|.
name|constEnd
argument_list|()
condition|)
block|{
operator|++
name|it
expr_stmt|;
if|if
condition|(
operator|!
name|itc
operator|.
name|key
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|list
operator|.
name|append
argument_list|(
name|itc
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns a list of all prefixes currently declared for the     namespace URI \a uri.      The "xml:" prefix is included. If you only want one prefix that is     mapped to the namespace URI, and you don't care which one you get,     use the prefix() function instead.      Note: The empty (default) prefix is never included in this list;     to check for the presence of a default namespace, call uri() with     "" as the argument. */
end_comment
begin_function
DECL|function|prefixes
name|QStringList
name|QXmlNamespaceSupport
operator|::
name|prefixes
parameter_list|(
specifier|const
name|QString
modifier|&
name|uri
parameter_list|)
specifier|const
block|{
name|QStringList
name|list
decl_stmt|;
name|NamespaceMap
operator|::
name|const_iterator
name|itc
decl_stmt|,
name|it
init|=
name|d
operator|->
name|ns
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|itc
operator|=
name|it
operator|)
operator|!=
name|d
operator|->
name|ns
operator|.
name|constEnd
argument_list|()
condition|)
block|{
operator|++
name|it
expr_stmt|;
if|if
condition|(
operator|*
name|itc
operator|==
name|uri
operator|&&
operator|!
name|itc
operator|.
name|key
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|list
operator|.
name|append
argument_list|(
name|itc
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     Starts a new namespace context.      Normally, you should push a new context at the beginning of each     XML element: the new context automatically inherits the     declarations of its parent context, and it also keeps track of     which declarations were made within this context.      \sa popContext() */
end_comment
begin_function
DECL|function|pushContext
name|void
name|QXmlNamespaceSupport
operator|::
name|pushContext
parameter_list|()
block|{
name|d
operator|->
name|nsStack
operator|.
name|push
argument_list|(
name|d
operator|->
name|ns
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Reverts to the previous namespace context.      Normally, you should pop the context at the end of each XML     element. After popping the context, all namespace prefix mappings     that were previously in force are restored.      \sa pushContext() */
end_comment
begin_function
DECL|function|popContext
name|void
name|QXmlNamespaceSupport
operator|::
name|popContext
parameter_list|()
block|{
name|d
operator|->
name|ns
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|nsStack
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|ns
operator|=
name|d
operator|->
name|nsStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resets this namespace support object ready for reuse. */
end_comment
begin_function
DECL|function|reset
name|void
name|QXmlNamespaceSupport
operator|::
name|reset
parameter_list|()
block|{
name|QXmlNamespaceSupportPrivate
modifier|*
name|newD
init|=
operator|new
name|QXmlNamespaceSupportPrivate
decl_stmt|;
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|newD
expr_stmt|;
block|}
end_function
begin_comment
comment|/*********************************************  *  * QXmlAttributes  *  *********************************************/
end_comment
begin_comment
comment|/*!     \class QXmlAttributes     \reentrant     \brief The QXmlAttributes class provides XML attributes.      \inmodule QtXml     \ingroup xml-tools      If attributes are reported by QXmlContentHandler::startElement()     this class is used to pass the attribute values.      Use index() to locate the position of an attribute in the list,     count() to retrieve the number of attributes, and clear() to     remove the attributes. New attributes can be added with append().     Use type() to get an attribute's type and value() to get its     value. The attribute's name is available from localName() or     qName(), and its namespace URI from uri().  */
end_comment
begin_comment
comment|/*!     \fn QXmlAttributes::QXmlAttributes()      Constructs an empty attribute list. */
end_comment
begin_comment
comment|/*!     \fn QXmlAttributes::~QXmlAttributes()      Destroys the attributes object. */
end_comment
begin_comment
comment|/*!     Looks up the index of an attribute by the qualified name \a qName.      Returns the index of the attribute or -1 if it wasn't found.      \sa {Namespace Support via Features} */
end_comment
begin_function
DECL|function|index
name|int
name|QXmlAttributes
operator|::
name|index
parameter_list|(
specifier|const
name|QString
modifier|&
name|qName
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|attList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|qname
operator|==
name|qName
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*! \overload   */
end_comment
begin_function
DECL|function|index
name|int
name|QXmlAttributes
operator|::
name|index
parameter_list|(
name|QLatin1String
name|qName
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|attList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|qname
operator|==
name|qName
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Looks up the index of an attribute by a namespace name.      \a uri specifies the namespace URI, or an empty string if the name     has no namespace URI. \a localPart specifies the attribute's local     name.      Returns the index of the attribute, or -1 if it wasn't found.      \sa {Namespace Support via Features} */
end_comment
begin_function
DECL|function|index
name|int
name|QXmlAttributes
operator|::
name|index
parameter_list|(
specifier|const
name|QString
modifier|&
name|uri
parameter_list|,
specifier|const
name|QString
modifier|&
name|localPart
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Attribute
modifier|&
name|att
init|=
name|attList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|att
operator|.
name|uri
operator|==
name|uri
operator|&&
name|att
operator|.
name|localname
operator|==
name|localPart
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of attributes in the list.      \sa count() */
end_comment
begin_function
DECL|function|length
name|int
name|QXmlAttributes
operator|::
name|length
parameter_list|()
specifier|const
block|{
return|return
name|attList
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QXmlAttributes::count() const      Returns the number of attributes in the list. This function is     equivalent to length(). */
end_comment
begin_comment
comment|/*!     Looks up an attribute's local name for the attribute at position     \a index. If no namespace processing is done, the local name is     an empty string.      \sa {Namespace Support via Features} */
end_comment
begin_function
DECL|function|localName
name|QString
name|QXmlAttributes
operator|::
name|localName
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|attList
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|localname
return|;
block|}
end_function
begin_comment
comment|/*!     Looks up an attribute's XML 1.0 qualified name for the attribute     at position \a index.      \sa {Namespace Support via Features} */
end_comment
begin_function
DECL|function|qName
name|QString
name|QXmlAttributes
operator|::
name|qName
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|attList
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|qname
return|;
block|}
end_function
begin_comment
comment|/*!     Looks up an attribute's namespace URI for the attribute at     position \a index. If no namespace processing is done or if the     attribute has no namespace, the namespace URI is an empty string.      \sa {Namespace Support via Features} */
end_comment
begin_function
DECL|function|uri
name|QString
name|QXmlAttributes
operator|::
name|uri
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|attList
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|uri
return|;
block|}
end_function
begin_comment
comment|/*!     Looks up an attribute's type for the attribute at position \a     index.      Currently only "CDATA" is returned. */
end_comment
begin_function
DECL|function|type
name|QString
name|QXmlAttributes
operator|::
name|type
parameter_list|(
name|int
parameter_list|)
specifier|const
block|{
return|return
name|QLatin1String
argument_list|(
literal|"CDATA"
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Looks up an attribute's type for the qualified name \a qName.      Currently only "CDATA" is returned. */
end_comment
begin_function
DECL|function|type
name|QString
name|QXmlAttributes
operator|::
name|type
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
specifier|const
block|{
return|return
name|QLatin1String
argument_list|(
literal|"CDATA"
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Looks up an attribute's type by namespace name.      \a uri specifies the namespace URI and \a localName specifies the     local name. If the name has no namespace URI, use an empty string     for \a uri.      Currently only "CDATA" is returned. */
end_comment
begin_function
DECL|function|type
name|QString
name|QXmlAttributes
operator|::
name|type
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
specifier|const
block|{
return|return
name|QLatin1String
argument_list|(
literal|"CDATA"
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an attribute's value for the attribute at position \a     index. The index must be a valid position     (i.e., 0<= \a index< count()). */
end_comment
begin_function
DECL|function|value
name|QString
name|QXmlAttributes
operator|::
name|value
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|attList
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|value
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns an attribute's value for the qualified name \a qName, or an     empty string if no attribute exists for the name given.      \sa {Namespace Support via Features} */
end_comment
begin_function
DECL|function|value
name|QString
name|QXmlAttributes
operator|::
name|value
parameter_list|(
specifier|const
name|QString
modifier|&
name|qName
parameter_list|)
specifier|const
block|{
name|int
name|i
init|=
name|index
argument_list|(
name|qName
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|attList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|value
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns an attribute's value for the qualified name \a qName, or an     empty string if no attribute exists for the name given.      \sa {Namespace Support via Features} */
end_comment
begin_function
DECL|function|value
name|QString
name|QXmlAttributes
operator|::
name|value
parameter_list|(
name|QLatin1String
name|qName
parameter_list|)
specifier|const
block|{
name|int
name|i
init|=
name|index
argument_list|(
name|qName
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|attList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|value
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns an attribute's value by namespace name.      \a uri specifies the namespace URI, or an empty string if the name     has no namespace URI. \a localName specifies the attribute's local     name. */
end_comment
begin_function
DECL|function|value
name|QString
name|QXmlAttributes
operator|::
name|value
parameter_list|(
specifier|const
name|QString
modifier|&
name|uri
parameter_list|,
specifier|const
name|QString
modifier|&
name|localName
parameter_list|)
specifier|const
block|{
name|int
name|i
init|=
name|index
argument_list|(
name|uri
argument_list|,
name|localName
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|attList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|value
return|;
block|}
end_function
begin_comment
comment|/*!     Clears the list of attributes.      \sa append() */
end_comment
begin_function
DECL|function|clear
name|void
name|QXmlAttributes
operator|::
name|clear
parameter_list|()
block|{
name|attList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Appends a new attribute entry to the list of attributes. The     qualified name of the attribute is \a qName, the namespace URI is     \a uri and the local name is \a localPart. The value of the     attribute is \a value.      \sa qName(), uri(), localName(), value() */
end_comment
begin_function
DECL|function|append
name|void
name|QXmlAttributes
operator|::
name|append
parameter_list|(
specifier|const
name|QString
modifier|&
name|qName
parameter_list|,
specifier|const
name|QString
modifier|&
name|uri
parameter_list|,
specifier|const
name|QString
modifier|&
name|localPart
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|Attribute
name|att
decl_stmt|;
name|att
operator|.
name|qname
operator|=
name|qName
expr_stmt|;
name|att
operator|.
name|uri
operator|=
name|uri
expr_stmt|;
name|att
operator|.
name|localname
operator|=
name|localPart
expr_stmt|;
name|att
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|attList
operator|.
name|append
argument_list|(
name|att
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*********************************************  *  * QXmlInputSource  *  *********************************************/
end_comment
begin_comment
comment|/*!     \class QXmlInputSource     \reentrant     \brief The QXmlInputSource class provides the input data for the     QXmlReader subclasses.      \inmodule QtXml     \ingroup xml-tools      All subclasses of QXmlReader read the input XML document from this     class.      This class recognizes the encoding of the data by reading the     encoding declaration in the XML file if it finds one, and reading     the data using the corresponding encoding. If it does not find an     encoding declaration, then it assumes that the data is either in     UTF-8 or UTF-16, depending on whether it can find a byte-order     mark.      There are two ways to populate the input source with data: you can     construct it with a QIODevice* so that the input source reads the     data from that device. Or you can set the data explicitly with one     of the setData() functions.      Usually you either construct a QXmlInputSource that works on a     QIODevice* or you construct an empty QXmlInputSource and set the     data with setData(). There are only rare occasions where you would     want to mix both methods.      The QXmlReader subclasses use the next() function to read the     input character by character. If you want to start from the     beginning again, use reset().      The functions data() and fetchData() are useful if you want to do     something with the data other than parsing, e.g. displaying the     raw XML file. The benefit of using the QXmlInputClass in such     cases is that it tries to use the correct encoding.      \sa QXmlReader, QXmlSimpleReader */
end_comment
begin_comment
comment|// the following two are guaranteed not to be a character
end_comment
begin_decl_stmt
DECL|member|EndOfData
specifier|const
name|ushort
name|QXmlInputSource
operator|::
name|EndOfData
init|=
literal|0xfffe
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|EndOfDocument
specifier|const
name|ushort
name|QXmlInputSource
operator|::
name|EndOfDocument
init|=
literal|0xffff
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*     Common part of the constructors. */
end_comment
begin_function
DECL|function|init
name|void
name|QXmlInputSource
operator|::
name|init
parameter_list|()
block|{
name|d
operator|=
operator|new
name|QXmlInputSourcePrivate
expr_stmt|;
name|QT_TRY
block|{
name|d
operator|->
name|inputDevice
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|inputStream
operator|=
literal|0
expr_stmt|;
name|setData
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|d
operator|->
name|encMapper
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|nextReturnedEndOfData
operator|=
literal|true
expr_stmt|;
comment|// first call to next() will call fetchData()
name|d
operator|->
name|encodingDeclBytes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|encodingDeclChars
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|lookingForEncodingDecl
operator|=
literal|true
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
operator|delete
operator|(
name|d
operator|)
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Constructs an input source which contains no data.      \sa setData() */
end_comment
begin_constructor
DECL|function|QXmlInputSource
name|QXmlInputSource
operator|::
name|QXmlInputSource
parameter_list|()
block|{
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an input source and gets the data from device \a dev.     If \a dev is not open, it is opened in read-only mode. If \a dev     is 0 or it is not possible to read from the device, the input     source will contain no data.      \sa setData(), fetchData(), QIODevice */
end_comment
begin_constructor
DECL|function|QXmlInputSource
name|QXmlInputSource
operator|::
name|QXmlInputSource
parameter_list|(
name|QIODevice
modifier|*
name|dev
parameter_list|)
block|{
name|init
argument_list|()
expr_stmt|;
name|d
operator|->
name|inputDevice
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|isOpen
argument_list|()
condition|)
name|d
operator|->
name|inputDevice
operator|->
name|setTextModeEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destructor. */
end_comment
begin_destructor
DECL|function|~QXmlInputSource
name|QXmlInputSource
operator|::
name|~
name|QXmlInputSource
parameter_list|()
block|{
comment|// ### close the input device.
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
operator|delete
name|d
operator|->
name|encMapper
expr_stmt|;
endif|#
directive|endif
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*! Returns the next character of the input source. If this function reaches the end of available data, it returns QXmlInputSource::EndOfData. If you call next() after that, it tries to fetch more data by calling fetchData(). If the fetchData() call results in new data, this function returns the first character of that data; otherwise it returns QXmlInputSource::EndOfDocument.  Readers, such as QXmlSimpleReader, will assume that the end of the XML document has been reached if the this function returns QXmlInputSource::EndOfDocument, and will check that the supplied input is well-formed. Therefore, when reimplementing this function, it is important to ensure that this behavior is duplicated.  \sa reset(), fetchData(), QXmlSimpleReader::parse(),     QXmlSimpleReader::parseContinue() */
end_comment
begin_function
DECL|function|next
name|QChar
name|QXmlInputSource
operator|::
name|next
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|pos
operator|>=
name|d
operator|->
name|length
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|nextReturnedEndOfData
condition|)
block|{
name|d
operator|->
name|nextReturnedEndOfData
operator|=
literal|false
expr_stmt|;
name|fetchData
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pos
operator|>=
name|d
operator|->
name|length
condition|)
block|{
return|return
name|EndOfDocument
return|;
block|}
return|return
name|next
argument_list|()
return|;
block|}
name|d
operator|->
name|nextReturnedEndOfData
operator|=
literal|true
expr_stmt|;
return|return
name|EndOfData
return|;
block|}
comment|// QXmlInputSource has no way to signal encoding errors. The best we can do
comment|// is return EndOfDocument. We do *not* return EndOfData, because the reader
comment|// will then just call this function again to get the next char.
name|QChar
name|c
init|=
name|d
operator|->
name|unicode
index|[
name|d
operator|->
name|pos
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|unicode
argument_list|()
operator|==
name|EndOfData
condition|)
name|c
operator|=
name|EndOfDocument
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_comment
comment|/*!     This function sets the position used by next() to the beginning of     the data returned by data(). This is useful if you want to use the     input source for more than one parse.      \note In the case that the underlying data source is a QIODevice,     the current position in the device is not automatically set to the     start of input. Call QIODevice::seek(0) on the device to do this.      \sa next() */
end_comment
begin_function
DECL|function|reset
name|void
name|QXmlInputSource
operator|::
name|reset
parameter_list|()
block|{
name|d
operator|->
name|nextReturnedEndOfData
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the data the input source contains or an empty string if the     input source does not contain any data.      \sa setData(), QXmlInputSource(), fetchData() */
end_comment
begin_function
DECL|function|data
name|QString
name|QXmlInputSource
operator|::
name|data
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|nextReturnedEndOfData
condition|)
block|{
name|QXmlInputSource
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QXmlInputSource
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|d
operator|->
name|nextReturnedEndOfData
operator|=
literal|false
expr_stmt|;
name|that
operator|->
name|fetchData
argument_list|()
expr_stmt|;
block|}
return|return
name|d
operator|->
name|str
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the data of the input source to \a dat.      If the input source already contains data, this function deletes     that data first.      \sa data() */
end_comment
begin_function
DECL|function|setData
name|void
name|QXmlInputSource
operator|::
name|setData
parameter_list|(
specifier|const
name|QString
modifier|&
name|dat
parameter_list|)
block|{
name|d
operator|->
name|str
operator|=
name|dat
expr_stmt|;
name|d
operator|->
name|unicode
operator|=
name|dat
operator|.
name|unicode
argument_list|()
expr_stmt|;
name|d
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|length
operator|=
name|d
operator|->
name|str
operator|.
name|length
argument_list|()
expr_stmt|;
name|d
operator|->
name|nextReturnedEndOfData
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      The data \a dat is passed through the correct text-codec, before     it is set. */
end_comment
begin_function
DECL|function|setData
name|void
name|QXmlInputSource
operator|::
name|setData
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|dat
parameter_list|)
block|{
name|setData
argument_list|(
name|fromRawData
argument_list|(
name|dat
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This function reads more data from the device that was set during     construction. If the input source already contained data, this     function deletes that data first.      This object contains no data after a call to this function if the     object was constructed without a device to read data from or if     this function was not able to get more data from the device.      There are two occasions where a fetch is done implicitly by     another function call: during construction (so that the object     starts out with some initial data where available), and during a     call to next() (if the data had run out).      You don't normally need to use this function if you use next().      \sa data(), next(), QXmlInputSource() */
end_comment
begin_function
DECL|function|fetchData
name|void
name|QXmlInputSource
operator|::
name|fetchData
parameter_list|()
block|{
enum|enum
block|{
name|BufferSize
init|=
literal|1024
block|}
enum|;
name|QByteArray
name|rawData
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|inputDevice
operator|||
name|d
operator|->
name|inputStream
condition|)
block|{
name|QIODevice
modifier|*
name|device
init|=
name|d
operator|->
name|inputDevice
condition|?
name|d
operator|->
name|inputDevice
else|:
name|d
operator|->
name|inputStream
operator|->
name|device
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|device
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|inputStream
operator|&&
name|d
operator|->
name|inputStream
operator|->
name|string
argument_list|()
condition|)
block|{
name|QString
modifier|*
name|s
init|=
name|d
operator|->
name|inputStream
operator|->
name|string
argument_list|()
decl_stmt|;
name|rawData
operator|=
name|QByteArray
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|s
operator|->
name|constData
argument_list|()
argument_list|,
name|s
operator|->
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|device
operator|->
name|isOpen
argument_list|()
operator|||
name|device
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|rawData
operator|.
name|resize
argument_list|(
name|BufferSize
argument_list|)
expr_stmt|;
name|qint64
name|size
init|=
name|device
operator|->
name|read
argument_list|(
name|rawData
operator|.
name|data
argument_list|()
argument_list|,
name|BufferSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// We don't want to give fromRawData() less than four bytes if we can avoid it.
while|while
condition|(
name|size
operator|<
literal|4
condition|)
block|{
if|if
condition|(
operator|!
name|device
operator|->
name|waitForReadyRead
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
break|break;
name|int
name|ret
init|=
name|device
operator|->
name|read
argument_list|(
name|rawData
operator|.
name|data
argument_list|()
operator|+
name|size
argument_list|,
name|BufferSize
operator|-
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
break|break;
name|size
operator|+=
name|ret
expr_stmt|;
block|}
block|}
name|rawData
operator|.
name|resize
argument_list|(
name|qMax
argument_list|(
name|qint64
argument_list|(
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We do this inside the "if (d->inputDevice ..." scope          * because if we're not using a stream or device, that is,          * the user set a QString manually, we don't want to set          * d->str. */
name|setData
argument_list|(
name|fromRawData
argument_list|(
name|rawData
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
end_ifndef
begin_function
DECL|function|extractEncodingDecl
specifier|static
name|QString
name|extractEncodingDecl
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|bool
modifier|*
name|needMoreText
parameter_list|)
block|{
operator|*
name|needMoreText
operator|=
literal|false
expr_stmt|;
name|int
name|l
init|=
name|text
operator|.
name|length
argument_list|()
decl_stmt|;
name|QString
name|snip
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"<?xml"
argument_list|)
operator|.
name|left
argument_list|(
name|l
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
operator|&&
operator|!
name|text
operator|.
name|startsWith
argument_list|(
name|snip
argument_list|)
condition|)
return|return
name|QString
argument_list|()
return|;
name|int
name|endPos
init|=
name|text
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|endPos
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|needMoreText
operator|=
name|l
operator|<
literal|255
expr_stmt|;
comment|// we won't look forever
return|return
name|QString
argument_list|()
return|;
block|}
name|int
name|pos
init|=
name|text
operator|.
name|indexOf
argument_list|(
name|QLatin1String
argument_list|(
literal|"encoding"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
operator|||
name|pos
operator|>=
name|endPos
condition|)
return|return
name|QString
argument_list|()
return|;
while|while
condition|(
name|pos
operator|<
name|endPos
condition|)
block|{
name|ushort
name|uc
init|=
name|text
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|uc
operator|==
literal|'\''
operator|||
name|uc
operator|==
literal|'"'
condition|)
break|break;
operator|++
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
name|endPos
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|encoding
decl_stmt|;
operator|++
name|pos
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|endPos
condition|)
block|{
name|ushort
name|uc
init|=
name|text
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|uc
operator|==
literal|'\''
operator|||
name|uc
operator|==
literal|'"'
condition|)
break|break;
name|encoding
operator|.
name|append
argument_list|(
name|uc
argument_list|)
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
return|return
name|encoding
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTCODEC
end_comment
begin_comment
comment|/*!     This function reads the XML file from \a data and tries to     recognize the encoding. It converts the raw data \a data into a     QString and returns it. It tries its best to get the correct     encoding for the XML file.      If \a beginning is true, this function assumes that the data     starts at the beginning of a new XML document and looks for an     encoding declaration. If \a beginning is false, it converts the     raw data using the encoding determined from prior calls. */
end_comment
begin_function
DECL|function|fromRawData
name|QString
name|QXmlInputSource
operator|::
name|fromRawData
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|bool
name|beginning
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_TEXTCODEC
name|Q_UNUSED
argument_list|(
name|beginning
argument_list|)
expr_stmt|;
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|data
operator|.
name|constData
argument_list|()
argument_list|,
name|data
operator|.
name|size
argument_list|()
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|data
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|beginning
condition|)
block|{
operator|delete
name|d
operator|->
name|encMapper
expr_stmt|;
name|d
operator|->
name|encMapper
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|mib
init|=
literal|106
decl_stmt|;
comment|// UTF-8
comment|// This is the initial UTF codec we will read the encoding declaration with
if|if
condition|(
name|d
operator|->
name|encMapper
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|encodingDeclBytes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|encodingDeclChars
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|lookingForEncodingDecl
operator|=
literal|true
expr_stmt|;
comment|// look for byte order mark and read the first 5 characters
if|if
condition|(
name|data
operator|.
name|size
argument_list|()
operator|>=
literal|4
condition|)
block|{
name|uchar
name|ch1
init|=
name|data
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|uchar
name|ch2
init|=
name|data
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|uchar
name|ch3
init|=
name|data
operator|.
name|at
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|uchar
name|ch4
init|=
name|data
operator|.
name|at
argument_list|(
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ch1
operator|==
literal|0
operator|&&
name|ch2
operator|==
literal|0
operator|&&
name|ch3
operator|==
literal|0xfe
operator|&&
name|ch4
operator|==
literal|0xff
operator|)
operator|||
operator|(
name|ch1
operator|==
literal|0xff
operator|&&
name|ch2
operator|==
literal|0xfe
operator|&&
name|ch3
operator|==
literal|0
operator|&&
name|ch4
operator|==
literal|0
operator|)
condition|)
name|mib
operator|=
literal|1017
expr_stmt|;
comment|// UTF-32 with byte order mark
elseif|else
if|if
condition|(
name|ch1
operator|==
literal|0x3c
operator|&&
name|ch2
operator|==
literal|0x00
operator|&&
name|ch3
operator|==
literal|0x00
operator|&&
name|ch4
operator|==
literal|0x00
condition|)
name|mib
operator|=
literal|1019
expr_stmt|;
comment|// UTF-32LE
elseif|else
if|if
condition|(
name|ch1
operator|==
literal|0x00
operator|&&
name|ch2
operator|==
literal|0x00
operator|&&
name|ch3
operator|==
literal|0x00
operator|&&
name|ch4
operator|==
literal|0x3c
condition|)
name|mib
operator|=
literal|1018
expr_stmt|;
comment|// UTF-32BE
block|}
if|if
condition|(
name|mib
operator|==
literal|106
operator|&&
name|data
operator|.
name|size
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|uchar
name|ch1
init|=
name|data
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|uchar
name|ch2
init|=
name|data
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ch1
operator|==
literal|0xfe
operator|&&
name|ch2
operator|==
literal|0xff
operator|)
operator|||
operator|(
name|ch1
operator|==
literal|0xff
operator|&&
name|ch2
operator|==
literal|0xfe
operator|)
condition|)
name|mib
operator|=
literal|1015
expr_stmt|;
comment|// UTF-16 with byte order mark
elseif|else
if|if
condition|(
name|ch1
operator|==
literal|0x3c
operator|&&
name|ch2
operator|==
literal|0x00
condition|)
name|mib
operator|=
literal|1014
expr_stmt|;
comment|// UTF-16LE
elseif|else
if|if
condition|(
name|ch1
operator|==
literal|0x00
operator|&&
name|ch2
operator|==
literal|0x3c
condition|)
name|mib
operator|=
literal|1013
expr_stmt|;
comment|// UTF-16BE
block|}
name|QTextCodec
modifier|*
name|codec
init|=
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
name|mib
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|d
operator|->
name|encMapper
operator|=
name|codec
operator|->
name|makeDecoder
argument_list|()
expr_stmt|;
block|}
name|QString
name|input
init|=
name|d
operator|->
name|encMapper
operator|->
name|toUnicode
argument_list|(
name|data
operator|.
name|constData
argument_list|()
argument_list|,
name|data
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|lookingForEncodingDecl
condition|)
block|{
name|d
operator|->
name|encodingDeclChars
operator|+=
name|input
expr_stmt|;
name|bool
name|needMoreText
decl_stmt|;
name|QString
name|encoding
init|=
name|extractEncodingDecl
argument_list|(
name|d
operator|->
name|encodingDeclChars
argument_list|,
operator|&
name|needMoreText
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|encoding
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|QTextCodec
modifier|*
name|codec
init|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|encoding
operator|.
name|toLatin1
argument_list|()
argument_list|)
condition|)
block|{
comment|/* If the encoding is the same, we don't have to do toUnicode() all over again. */
if|if
condition|(
name|codec
operator|->
name|mibEnum
argument_list|()
operator|!=
name|mib
condition|)
block|{
operator|delete
name|d
operator|->
name|encMapper
expr_stmt|;
name|d
operator|->
name|encMapper
operator|=
name|codec
operator|->
name|makeDecoder
argument_list|()
expr_stmt|;
comment|/* The variable input can potentially be large, so we deallocate                      * it before calling toUnicode() in order to avoid having two                      * large QStrings in memory simultaneously. */
name|input
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// prime the decoder with the data so far
name|d
operator|->
name|encMapper
operator|->
name|toUnicode
argument_list|(
name|d
operator|->
name|encodingDeclBytes
operator|.
name|constData
argument_list|()
argument_list|,
name|d
operator|->
name|encodingDeclBytes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// now feed it the new data
name|input
operator|=
name|d
operator|->
name|encMapper
operator|->
name|toUnicode
argument_list|(
name|data
operator|.
name|constData
argument_list|()
argument_list|,
name|data
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|d
operator|->
name|encodingDeclBytes
operator|+=
name|data
expr_stmt|;
name|d
operator|->
name|lookingForEncodingDecl
operator|=
name|needMoreText
expr_stmt|;
block|}
return|return
name|input
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*********************************************  *  * QXmlDefaultHandler  *  *********************************************/
end_comment
begin_comment
comment|/*!     \class QXmlContentHandler     \reentrant     \brief The QXmlContentHandler class provides an interface to     report the logical content of XML data.      \inmodule QtXml     \ingroup xml-tools      If the application needs to be informed of basic parsing events,     it can implement this interface and activate it using     QXmlReader::setContentHandler(). The reader can then report basic     document-related events like the start and end of elements and     character data through this interface.      The order of events in this interface is very important, and     mirrors the order of information in the document itself. For     example, all of an element's content (character data, processing     instructions, and sub-elements) appears, in order, between the     startElement() event and the corresponding endElement() event.      The class QXmlDefaultHandler provides a default implementation for     this interface; subclassing from the QXmlDefaultHandler class is     very convenient if you only want to be informed of some parsing     events.      The startDocument() function is called at the start of the     document, and endDocument() is called at the end. Before parsing     begins setDocumentLocator() is called. For each element     startElement() is called, with endElement() being called at the     end of each element. The characters() function is called with     chunks of character data; ignorableWhitespace() is called with     chunks of whitespace and processingInstruction() is called with     processing instructions. If an entity is skipped skippedEntity()     is called. At the beginning of prefix-URI scopes     startPrefixMapping() is called.      \sa QXmlDTDHandler, QXmlDeclHandler, QXmlEntityResolver, QXmlErrorHandler,         QXmlLexicalHandler, {Introduction to SAX2} */
end_comment
begin_comment
comment|/*!     \fn QXmlContentHandler::~QXmlContentHandler()      Destroys the content handler. */
end_comment
begin_comment
comment|/*!     \fn void QXmlContentHandler::setDocumentLocator(QXmlLocator* locator)      The reader calls this function before it starts parsing the     document. The argument \a locator is a pointer to a QXmlLocator     which allows the application to get the parsing position within     the document.      Do not destroy the \a locator; it is destroyed when the reader is     destroyed. (Do not use the \a locator after the reader is     destroyed). */
end_comment
begin_comment
comment|/*!     \fn bool QXmlContentHandler::startDocument()      The reader calls this function when it starts parsing the     document. The reader calls this function just once, after the call     to setDocumentLocator(), and before any other functions in this     class or in the QXmlDTDHandler class are called.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message.      \sa endDocument() */
end_comment
begin_comment
comment|/*!     \fn bool QXmlContentHandler::endDocument()      The reader calls this function after it has finished parsing. It     is called just once, and is the last handler function called. It     is called after the reader has read all input or has abandoned     parsing because of a fatal error.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message.      \sa startDocument() */
end_comment
begin_comment
comment|/*!     \fn bool QXmlContentHandler::startPrefixMapping(const QString& prefix, const QString& uri)      The reader calls this function to signal the begin of a prefix-URI     namespace mapping scope. This information is not necessary for     normal namespace processing since the reader automatically     replaces prefixes for element and attribute names.      Note that startPrefixMapping() and endPrefixMapping() calls are     not guaranteed to be properly nested relative to each other: all     startPrefixMapping() events occur before the corresponding     startElement() event, and all endPrefixMapping() events occur     after the corresponding endElement() event, but their order is not     otherwise guaranteed.      The argument \a prefix is the namespace prefix being declared and     the argument \a uri is the namespace URI the prefix is mapped to.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message.      \sa endPrefixMapping(), {Namespace Support via Features} */
end_comment
begin_comment
comment|/*!     \fn bool QXmlContentHandler::endPrefixMapping(const QString& prefix)      The reader calls this function to signal the end of a prefix     mapping for the prefix \a prefix.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message.      \sa startPrefixMapping(), {Namespace Support via Features} */
end_comment
begin_comment
comment|/*!     \fn bool QXmlContentHandler::startElement(const QString& namespaceURI, const QString& localName, const QString& qName, const QXmlAttributes& atts)      The reader calls this function when it has parsed a start element     tag.      There is a corresponding endElement() call when the corresponding     end element tag is read. The startElement() and endElement() calls     are always nested correctly. Empty element tags (e.g. \c{<x/>})     cause a startElement() call to be immediately followed by an     endElement() call.      The attribute list provided only contains attributes with explicit     values. The attribute list contains attributes used for namespace     declaration (i.e. attributes starting with xmlns) only if the     namespace-prefix property of the reader is true.      The argument \a namespaceURI is the namespace URI, or     an empty string if the element has no namespace URI or if no     namespace processing is done. \a localName is the local name     (without prefix), or an empty string if no namespace processing is     done, \a qName is the qualified name (with prefix) and \a atts are     the attributes attached to the element. If there are no     attributes, \a atts is an empty attributes object.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message.      \sa endElement(), {Namespace Support via Features} */
end_comment
begin_comment
comment|/*!     \fn bool QXmlContentHandler::endElement(const QString& namespaceURI, const QString& localName, const QString& qName)      The reader calls this function when it has parsed an end element     tag with the qualified name \a qName, the local name \a localName     and the namespace URI \a namespaceURI.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message.      \sa startElement(), {Namespace Support via Features} */
end_comment
begin_comment
comment|/*!     \fn bool QXmlContentHandler::characters(const QString& ch)      The reader calls this function when it has parsed a chunk of     character data (either normal character data or character data     inside a CDATA section; if you need to distinguish between those     two types you must use QXmlLexicalHandler::startCDATA() and     QXmlLexicalHandler::endCDATA()). The character data is reported in     \a ch.      Some readers report whitespace in element content using the     ignorableWhitespace() function rather than using this one.      A reader may report the character data of an element in more than     one chunk; e.g. a reader might want to report "a\<b" in three     characters() events ("a ", "\<" and " b").      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message. */
end_comment
begin_comment
comment|/*!     \fn bool QXmlContentHandler::ignorableWhitespace(const QString& ch)      Some readers may use this function to report each chunk of     whitespace in element content. The whitespace is reported in \a ch.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message. */
end_comment
begin_comment
comment|/*!     \fn bool QXmlContentHandler::processingInstruction(const QString& target, const QString& data)      The reader calls this function when it has parsed a processing     instruction.      \a target is the target name of the processing instruction and \a     data is the data in the processing instruction.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message. */
end_comment
begin_comment
comment|/*!     \fn bool QXmlContentHandler::skippedEntity(const QString& name)      Some readers may skip entities if they have not seen the     declarations (e.g. because they are in an external DTD). If they     do so they report that they skipped the entity called \a name by     calling this function.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message. */
end_comment
begin_comment
comment|/*!     \fn QString QXmlContentHandler::errorString() const      The reader calls this function to get an error string, e.g. if any     of the handler functions returns false. */
end_comment
begin_comment
comment|/*!     \class QXmlErrorHandler     \reentrant     \brief The QXmlErrorHandler class provides an interface to report     errors in XML data.      \inmodule QtXml     \ingroup xml-tools      If you want your application to report errors to the user or to     perform customized error handling, you should subclass this class.      You can set the error handler with QXmlReader::setErrorHandler().      Errors can be reported using warning(), error() and fatalError(),     with the error text being reported with errorString().      \sa QXmlDTDHandler, QXmlDeclHandler, QXmlContentHandler, QXmlEntityResolver,         QXmlLexicalHandler, {Introduction to SAX2} */
end_comment
begin_comment
comment|/*!     \fn QXmlErrorHandler::~QXmlErrorHandler()      Destroys the error handler. */
end_comment
begin_comment
comment|/*!     \fn bool QXmlErrorHandler::warning(const QXmlParseException& exception)      A reader might use this function to report a warning. Warnings are     conditions that are not errors or fatal errors as defined by the     XML 1.0 specification. Details of the warning are stored in \a     exception.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message. */
end_comment
begin_comment
comment|/*!     \fn bool QXmlErrorHandler::error(const QXmlParseException& exception)      A reader might use this function to report a recoverable error. A     recoverable error corresponds to the definiton of "error" in     section 1.2 of the XML 1.0 specification. Details of the error are     stored in \a exception.      The reader must continue to provide normal parsing events after     invoking this function.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message. */
end_comment
begin_comment
comment|/*! \fn bool QXmlErrorHandler::fatalError(const QXmlParseException& exception)  A reader must use this function to report a non-recoverable error. Details of the error are stored in \a exception.  If this function returns true the reader might try to go on parsing and reporting further errors, but no regular parsing events are reported. */
end_comment
begin_comment
comment|/*!     \fn QString QXmlErrorHandler::errorString() const      The reader calls this function to get an error string if any of     the handler functions returns false. */
end_comment
begin_comment
comment|/*!     \class QXmlDTDHandler     \reentrant     \brief The QXmlDTDHandler class provides an interface to report     DTD content of XML data.      \inmodule QtXml     \ingroup xml-tools      If an application needs information about notations and unparsed     entities, it can implement this interface and register an instance     with QXmlReader::setDTDHandler().      Note that this interface includes only those DTD events that the     XML recommendation requires processors to report, i.e. notation     and unparsed entity declarations using notationDecl() and     unparsedEntityDecl() respectively.      \sa QXmlDeclHandler, QXmlContentHandler, QXmlEntityResolver, QXmlErrorHandler,         QXmlLexicalHandler, {Introduction to SAX2} */
end_comment
begin_comment
comment|/*!     \fn QXmlDTDHandler::~QXmlDTDHandler()      Destroys the DTD handler. */
end_comment
begin_comment
comment|/*!     \fn bool QXmlDTDHandler::notationDecl(const QString& name, const QString& publicId, const QString& systemId)      The reader calls this function when it has parsed a notation     declaration.      The argument \a name is the notation name, \a publicId is the     notation's public identifier and \a systemId is the notation's     system identifier.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message. */
end_comment
begin_comment
comment|/*!     \fn bool QXmlDTDHandler::unparsedEntityDecl(const QString& name, const QString& publicId, const QString& systemId, const QString& notationName)      The reader calls this function when it finds an unparsed entity     declaration.      The argument \a name is the unparsed entity's name, \a publicId is     the entity's public identifier, \a systemId is the entity's system     identifier and \a notationName is the name of the associated     notation.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message. */
end_comment
begin_comment
comment|/*!     \fn QString QXmlDTDHandler::errorString() const      The reader calls this function to get an error string if any of     the handler functions returns false. */
end_comment
begin_comment
comment|/*!     \class QXmlEntityResolver     \reentrant     \brief The QXmlEntityResolver class provides an interface to     resolve external entities contained in XML data.      \inmodule QtXml     \ingroup xml-tools      If an application needs to implement customized handling for     external entities, it must implement this interface, i.e.     resolveEntity(), and register it with     QXmlReader::setEntityResolver().      \sa QXmlDTDHandler, QXmlDeclHandler, QXmlContentHandler, QXmlErrorHandler,         QXmlLexicalHandler, {Introduction to SAX2} */
end_comment
begin_comment
comment|/*!     \fn QXmlEntityResolver::~QXmlEntityResolver()      Destroys the entity resolver. */
end_comment
begin_comment
comment|/*!     \fn bool QXmlEntityResolver::resolveEntity(const QString& publicId, const QString& systemId, QXmlInputSource*& ret)      The reader calls this function before it opens any external     entity, except the top-level document entity. The application may     request the reader to resolve the entity itself (\a ret is 0) or     to use an entirely different input source (\a ret points to the     input source).      The reader deletes the input source \a ret when it no longer needs     it, so you should allocate it on the heap with \c new.      The argument \a publicId is the public identifier of the external     entity, \a systemId is the system identifier of the external     entity and \a ret is the return value of this function. If \a ret     is 0 the reader should resolve the entity itself, if it is     non-zero it must point to an input source which the reader uses     instead.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message. */
end_comment
begin_comment
comment|/*!     \fn QString QXmlEntityResolver::errorString() const      The reader calls this function to get an error string if any of     the handler functions returns false. */
end_comment
begin_comment
comment|/*!     \class QXmlLexicalHandler     \reentrant     \brief The QXmlLexicalHandler class provides an interface to     report the lexical content of XML data.      \inmodule QtXml     \ingroup xml-tools      The events in the lexical handler apply to the entire document,     not just to the document element, and all lexical handler events     appear between the content handler's startDocument and endDocument     events.      You can set the lexical handler with     QXmlReader::setLexicalHandler().      This interface's design is based on the SAX2 extension     LexicalHandler.      The interface provides the startDTD(), endDTD(), startEntity(),     endEntity(), startCDATA(), endCDATA() and comment() functions.      \sa QXmlDTDHandler, QXmlDeclHandler, QXmlContentHandler, QXmlEntityResolver,         QXmlErrorHandler, {Introduction to SAX2} */
end_comment
begin_comment
comment|/*!     \fn QXmlLexicalHandler::~QXmlLexicalHandler()      Destroys the lexical handler. */
end_comment
begin_comment
comment|/*!     \fn bool QXmlLexicalHandler::startDTD(const QString& name, const QString& publicId, const QString& systemId)      The reader calls this function to report the start of a DTD     declaration, if any. It reports the name of the document type in     \a name, the public identifier in \a publicId and the system     identifier in \a systemId.      If the public identifier is missing, \a publicId is set to     an empty string. If the system identifier is missing, \a systemId is     set to an empty string. Note that it is not valid XML to have a     public identifier but no system identifier; in such cases a parse     error will occur.      All declarations reported through QXmlDTDHandler or     QXmlDeclHandler appear between the startDTD() and endDTD() calls.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message.      \sa endDTD() */
end_comment
begin_comment
comment|/*!     \fn bool QXmlLexicalHandler::endDTD()      The reader calls this function to report the end of a DTD     declaration, if any.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message.      \sa startDTD() */
end_comment
begin_comment
comment|/*!     \fn bool QXmlLexicalHandler::startEntity(const QString& name)      The reader calls this function to report the start of an entity     called \a name.      Note that if the entity is unknown, the reader reports it through     QXmlContentHandler::skippedEntity() and not through this     function.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message.      \sa endEntity(), QXmlSimpleReader::setFeature() */
end_comment
begin_comment
comment|/*!     \fn bool QXmlLexicalHandler::endEntity(const QString& name)      The reader calls this function to report the end of an entity     called \a name.      For every startEntity() call, there is a corresponding endEntity()     call. The calls to startEntity() and endEntity() are properly     nested.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message.      \sa startEntity(), QXmlContentHandler::skippedEntity(), QXmlSimpleReader::setFeature() */
end_comment
begin_comment
comment|/*!     \fn bool QXmlLexicalHandler::startCDATA()      The reader calls this function to report the start of a CDATA     section. The content of the CDATA section is reported through the     QXmlContentHandler::characters() function. This function is     intended only to report the boundary.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message.      \sa endCDATA() */
end_comment
begin_comment
comment|/*!     \fn bool QXmlLexicalHandler::endCDATA()      The reader calls this function to report the end of a CDATA     section.      If this function returns false the reader stops parsing and reports     an error. The reader uses the function errorString() to get the error     message.      \sa startCDATA(), QXmlContentHandler::characters() */
end_comment
begin_comment
comment|/*!     \fn bool QXmlLexicalHandler::comment(const QString& ch)      The reader calls this function to report an XML comment anywhere     in the document. It reports the text of the comment in \a ch.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message. */
end_comment
begin_comment
comment|/*!     \fn QString QXmlLexicalHandler::errorString() const      The reader calls this function to get an error string if any of     the handler functions returns false. */
end_comment
begin_comment
comment|/*!     \class QXmlDeclHandler     \reentrant     \brief The QXmlDeclHandler class provides an interface to report declaration     content of XML data.      \inmodule QtXml     \ingroup xml-tools      You can set the declaration handler with     QXmlReader::setDeclHandler().      This interface is based on the SAX2 extension DeclHandler.      The interface provides attributeDecl(), internalEntityDecl() and     externalEntityDecl() functions.      \sa QXmlDTDHandler, QXmlContentHandler, QXmlEntityResolver, QXmlErrorHandler,         QXmlLexicalHandler, {Introduction to SAX2} */
end_comment
begin_comment
comment|/*!     \fn QXmlDeclHandler::~QXmlDeclHandler()      Destroys the declaration handler. */
end_comment
begin_comment
comment|/*!     \fn bool QXmlDeclHandler::attributeDecl(const QString& eName, const QString& aName, const QString& type, const QString& valueDefault, const QString& value)      The reader calls this function to report an attribute type     declaration. Only the effective (first) declaration for an     attribute is reported.      The reader passes the name of the associated element in \a eName     and the name of the attribute in \a aName. It passes a string that     represents the attribute type in \a type and a string that     represents the attribute default in \a valueDefault. This string     is one of "#IMPLIED", "#REQUIRED", "#FIXED" or an empty string (if     none of the others applies). The reader passes the attribute's     default value in \a value. If no default value is specified in the     XML file, \a value is an empty string.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message. */
end_comment
begin_comment
comment|/*!     \fn bool QXmlDeclHandler::internalEntityDecl(const QString& name, const QString& value)      The reader calls this function to report an internal entity     declaration. Only the effective (first) declaration is reported.      The reader passes the name of the entity in \a name and the value     of the entity in \a value.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message. */
end_comment
begin_comment
comment|/*!     \fn bool QXmlDeclHandler::externalEntityDecl(const QString& name, const QString& publicId, const QString& systemId)      The reader calls this function to report a parsed external entity     declaration. Only the effective (first) declaration for each     entity is reported.      The reader passes the name of the entity in \a name, the public     identifier in \a publicId and the system identifier in \a     systemId. If there is no public identifier specified, it passes     an empty string in \a publicId.      If this function returns false the reader stops parsing and     reports an error. The reader uses the function errorString() to     get the error message. */
end_comment
begin_comment
comment|/*!     \fn QString QXmlDeclHandler::errorString() const      The reader calls this function to get an error string if any of     the handler functions returns false. */
end_comment
begin_comment
comment|/*!     \class QXmlDefaultHandler     \reentrant     \brief The QXmlDefaultHandler class provides a default implementation of all     the XML handler classes.      \inmodule QtXml     \ingroup xml-tools      This class gathers together the features of     the specialized handler classes, making it a convenient     starting point when implementing custom handlers for     subclasses of QXmlReader, particularly QXmlSimpleReader.     The virtual functions from each of the base classes are     reimplemented in this class, providing sensible default behavior     for many common cases. By subclassing this class, and     overriding these functions, you can concentrate     on implementing the parts of the handler relevant to your     application.      The XML reader must be told which handler to use for different     kinds of events during parsing. This means that, although     QXmlDefaultHandler provides default implementations of functions     inherited from all its base classes, we can still use specialized     handlers for particular kinds of events.      For example, QXmlDefaultHandler subclasses both     QXmlContentHandler and QXmlErrorHandler, so by subclassing     it we can use the same handler for both of the following     reader functions:      \snippet rsslisting/listing.cpp 0      Since the reader will inform the handler of parsing errors, it is     necessary to reimplement QXmlErrorHandler::fatalError() if, for     example, we want to stop parsing when such an error occurs:      \snippet rsslisting/handler.cpp 0      The above function returns false, which tells the reader to stop     parsing. To continue to use the same reader,     it is necessary to create a new handler instance, and set up the     reader to use it in the manner described above.      It is useful to examine some of the functions inherited by     QXmlDefaultHandler, and consider why they might be     reimplemented in a custom handler.     Custom handlers will typically reimplement     QXmlContentHandler::startDocument() to prepare the handler for     new content. Document elements and the text within them can be     processed by reimplementing QXmlContentHandler::startElement(),     QXmlContentHandler::endElement(), and     QXmlContentHandler::characters().     You may want to reimplement QXmlContentHandler::endDocument()     to perform some finalization or validation on the content once the     document has been read completely.      \sa QXmlDTDHandler, QXmlDeclHandler, QXmlContentHandler, QXmlEntityResolver,         QXmlErrorHandler, QXmlLexicalHandler, {Introduction to SAX2} */
end_comment
begin_comment
comment|/*!     \fn QXmlDefaultHandler::QXmlDefaultHandler()      Constructs a handler for use with subclasses of QXmlReader. */
end_comment
begin_comment
comment|/*!     \fn QXmlDefaultHandler::~QXmlDefaultHandler()      Destroys the handler. */
end_comment
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|setDocumentLocator
name|void
name|QXmlDefaultHandler
operator|::
name|setDocumentLocator
parameter_list|(
name|QXmlLocator
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|startDocument
name|bool
name|QXmlDefaultHandler
operator|::
name|startDocument
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|endDocument
name|bool
name|QXmlDefaultHandler
operator|::
name|endDocument
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|startPrefixMapping
name|bool
name|QXmlDefaultHandler
operator|::
name|startPrefixMapping
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|endPrefixMapping
name|bool
name|QXmlDefaultHandler
operator|::
name|endPrefixMapping
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|startElement
name|bool
name|QXmlDefaultHandler
operator|::
name|startElement
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QXmlAttributes
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|endElement
name|bool
name|QXmlDefaultHandler
operator|::
name|endElement
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|characters
name|bool
name|QXmlDefaultHandler
operator|::
name|characters
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|ignorableWhitespace
name|bool
name|QXmlDefaultHandler
operator|::
name|ignorableWhitespace
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|processingInstruction
name|bool
name|QXmlDefaultHandler
operator|::
name|processingInstruction
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|skippedEntity
name|bool
name|QXmlDefaultHandler
operator|::
name|skippedEntity
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|warning
name|bool
name|QXmlDefaultHandler
operator|::
name|warning
parameter_list|(
specifier|const
name|QXmlParseException
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|error
name|bool
name|QXmlDefaultHandler
operator|::
name|error
parameter_list|(
specifier|const
name|QXmlParseException
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|fatalError
name|bool
name|QXmlDefaultHandler
operator|::
name|fatalError
parameter_list|(
specifier|const
name|QXmlParseException
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|notationDecl
name|bool
name|QXmlDefaultHandler
operator|::
name|notationDecl
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|unparsedEntityDecl
name|bool
name|QXmlDefaultHandler
operator|::
name|unparsedEntityDecl
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      Sets \a ret to 0, so that the reader uses the system identifier     provided in the XML document. */
end_comment
begin_function
DECL|function|resolveEntity
name|bool
name|QXmlDefaultHandler
operator|::
name|resolveEntity
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
name|QXmlInputSource
modifier|*
modifier|&
name|ret
parameter_list|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      Returns the default error string. */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QXmlDefaultHandler
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|XMLERR_ERRORBYCONSUMER
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|startDTD
name|bool
name|QXmlDefaultHandler
operator|::
name|startDTD
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|endDTD
name|bool
name|QXmlDefaultHandler
operator|::
name|endDTD
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|startEntity
name|bool
name|QXmlDefaultHandler
operator|::
name|startEntity
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|endEntity
name|bool
name|QXmlDefaultHandler
operator|::
name|endEntity
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|startCDATA
name|bool
name|QXmlDefaultHandler
operator|::
name|startCDATA
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|endCDATA
name|bool
name|QXmlDefaultHandler
operator|::
name|endCDATA
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|comment
name|bool
name|QXmlDefaultHandler
operator|::
name|comment
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|attributeDecl
name|bool
name|QXmlDefaultHandler
operator|::
name|attributeDecl
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|internalEntityDecl
name|bool
name|QXmlDefaultHandler
operator|::
name|internalEntityDecl
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      This reimplementation does nothing. */
end_comment
begin_function
DECL|function|externalEntityDecl
name|bool
name|QXmlDefaultHandler
operator|::
name|externalEntityDecl
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*********************************************  *  * QXmlSimpleReaderPrivate  *  *********************************************/
end_comment
begin_function
DECL|function|atEnd
specifier|inline
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|atEnd
parameter_list|()
block|{
return|return
operator|(
name|c
operator|.
name|unicode
argument_list|()
operator||
literal|0x0001
operator|)
operator|==
literal|0xffff
return|;
block|}
end_function
begin_function
DECL|function|stringClear
specifier|inline
name|void
name|QXmlSimpleReaderPrivate
operator|::
name|stringClear
parameter_list|()
block|{
name|stringValueLen
operator|=
literal|0
expr_stmt|;
name|stringArrayPos
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|nameClear
specifier|inline
name|void
name|QXmlSimpleReaderPrivate
operator|::
name|nameClear
parameter_list|()
block|{
name|nameValueLen
operator|=
literal|0
expr_stmt|;
name|nameArrayPos
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|refClear
specifier|inline
name|void
name|QXmlSimpleReaderPrivate
operator|::
name|refClear
parameter_list|()
block|{
name|refValueLen
operator|=
literal|0
expr_stmt|;
name|refArrayPos
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QXmlSimpleReaderPrivate
name|QXmlSimpleReaderPrivate
operator|::
name|QXmlSimpleReaderPrivate
parameter_list|(
name|QXmlSimpleReader
modifier|*
name|reader
parameter_list|)
block|{
name|q_ptr
operator|=
name|reader
expr_stmt|;
name|parseStack
operator|=
literal|0
expr_stmt|;
name|locator
operator|.
name|reset
argument_list|(
operator|new
name|QXmlSimpleReaderLocator
argument_list|(
name|reader
argument_list|)
argument_list|)
expr_stmt|;
name|entityRes
operator|=
literal|0
expr_stmt|;
name|dtdHnd
operator|=
literal|0
expr_stmt|;
name|contentHnd
operator|=
literal|0
expr_stmt|;
name|errorHnd
operator|=
literal|0
expr_stmt|;
name|lexicalHnd
operator|=
literal|0
expr_stmt|;
name|declHnd
operator|=
literal|0
expr_stmt|;
comment|// default feature settings
name|useNamespaces
operator|=
literal|true
expr_stmt|;
name|useNamespacePrefixes
operator|=
literal|false
expr_stmt|;
name|reportWhitespaceCharData
operator|=
literal|true
expr_stmt|;
name|reportEntities
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QXmlSimpleReaderPrivate
name|QXmlSimpleReaderPrivate
operator|::
name|~
name|QXmlSimpleReaderPrivate
parameter_list|()
block|{
operator|delete
name|parseStack
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|initIncrementalParsing
name|void
name|QXmlSimpleReaderPrivate
operator|::
name|initIncrementalParsing
parameter_list|()
block|{
if|if
condition|(
name|parseStack
condition|)
name|parseStack
operator|->
name|clear
argument_list|()
expr_stmt|;
else|else
name|parseStack
operator|=
operator|new
name|QStack
argument_list|<
name|ParseState
argument_list|>
expr_stmt|;
block|}
end_function
begin_comment
comment|/*********************************************  *  * QXmlSimpleReader  *  *********************************************/
end_comment
begin_comment
comment|/*!     \class QXmlReader     \reentrant     \brief The QXmlReader class provides an interface for XML readers (i.e.     parsers).      \inmodule QtXml     \ingroup xml-tools      This abstract class provides an interface for all of Qt's XML     readers. Currently there is only one implementation of a reader     included in Qt's XML module: QXmlSimpleReader. In future releases     there might be more readers with different properties available     (e.g. a validating parser).      The design of the XML classes follows the \l{SAX2 Java interface}, with     the names adapted to fit Qt naming conventions. It should be very     easy for anybody who has worked with SAX2 to get started with the     Qt XML classes.      All readers use the class QXmlInputSource to read the input     document. Since you are normally interested in particular content     in the XML document, the reader reports the content through     special handler classes (QXmlDTDHandler, QXmlDeclHandler,     QXmlContentHandler, QXmlEntityResolver, QXmlErrorHandler and     QXmlLexicalHandler), which you must subclass, if you want to     process the contents.      Since the handler classes only describe interfaces you must     implement all the functions. We provide the QXmlDefaultHandler     class to make this easier: it implements a default behavior (do     nothing) for all functions, so you can subclass it and just     implement the functions you are interested in.      Features and properties of the reader can be set with setFeature()     and setProperty() respectively. You can set the reader to use your     own subclasses with setEntityResolver(), setDTDHandler(),     setContentHandler(), setErrorHandler(), setLexicalHandler() and     setDeclHandler(). The parse itself is started with a call to     parse().      \sa QXmlSimpleReader */
end_comment
begin_comment
comment|/*!     \fn QXmlReader::~QXmlReader()      Destroys the reader. */
end_comment
begin_comment
comment|/*!     \fn bool QXmlReader::feature(const QString& name, bool *ok) const      If the reader has the feature called \a name, the feature's value     is returned. If no such feature exists the return value is     undefined.      If \a ok is not 0: \c{*}\a{ok}  is set to true if the reader has the     feature called \a name; otherwise \c{*}\a{ok} is set to false.      \sa setFeature(), hasFeature() */
end_comment
begin_comment
comment|/*!     \fn void QXmlReader::setFeature(const QString& name, bool value)      Sets the feature called \a name to the given \a value. If the     reader doesn't have the feature nothing happens.      \sa feature(), hasFeature() */
end_comment
begin_comment
comment|/*!     \fn bool QXmlReader::hasFeature(const QString& name) const      Returns \c true if the reader has the feature called \a name;     otherwise returns false.      \sa feature(), setFeature() */
end_comment
begin_comment
comment|/*!     \fn void* QXmlReader::property(const QString& name, bool *ok) const      If the reader has the property \a name, this function returns the     value of the property; otherwise the return value is undefined.      If \a ok is not 0: if the reader has the \a name property     \c{*}\a{ok} is set to true; otherwise \c{*}\a{ok} is set to false.      \sa setProperty(), hasProperty() */
end_comment
begin_comment
comment|/*!     \fn void QXmlReader::setProperty(const QString& name, void* value)      Sets the property \a name to \a value. If the reader doesn't have     the property nothing happens.      \sa property(), hasProperty() */
end_comment
begin_comment
comment|/*!     \fn bool QXmlReader::hasProperty(const QString& name) const      Returns true if the reader has the property \a name; otherwise     returns false.      \sa property(), setProperty() */
end_comment
begin_comment
comment|/*!     \fn void QXmlReader::setEntityResolver(QXmlEntityResolver* handler)      Sets the entity resolver to \a handler.      \sa entityResolver() */
end_comment
begin_comment
comment|/*!     \fn QXmlEntityResolver* QXmlReader::entityResolver() const      Returns the entity resolver or 0 if none was set.      \sa setEntityResolver() */
end_comment
begin_comment
comment|/*!     \fn void QXmlReader::setDTDHandler(QXmlDTDHandler* handler)      Sets the DTD handler to \a handler.      \sa DTDHandler() */
end_comment
begin_comment
comment|/*!     \fn QXmlDTDHandler* QXmlReader::DTDHandler() const      Returns the DTD handler or 0 if none was set.      \sa setDTDHandler() */
end_comment
begin_comment
comment|/*!     \fn void QXmlReader::setContentHandler(QXmlContentHandler* handler)      Sets the content handler to \a handler.      \sa contentHandler() */
end_comment
begin_comment
comment|/*!     \fn QXmlContentHandler* QXmlReader::contentHandler() const      Returns the content handler or 0 if none was set.      \sa setContentHandler() */
end_comment
begin_comment
comment|/*!     \fn void QXmlReader::setErrorHandler(QXmlErrorHandler* handler)      Sets the error handler to \a handler. Clears the error handler if     \a handler is 0.      \sa errorHandler() */
end_comment
begin_comment
comment|/*!     \fn QXmlErrorHandler* QXmlReader::errorHandler() const      Returns the error handler or 0 if none is set.      \sa setErrorHandler() */
end_comment
begin_comment
comment|/*!     \fn void QXmlReader::setLexicalHandler(QXmlLexicalHandler* handler)      Sets the lexical handler to \a handler.      \sa lexicalHandler() */
end_comment
begin_comment
comment|/*!     \fn QXmlLexicalHandler* QXmlReader::lexicalHandler() const      Returns the lexical handler or 0 if none was set.      \sa setLexicalHandler() */
end_comment
begin_comment
comment|/*!     \fn void QXmlReader::setDeclHandler(QXmlDeclHandler* handler)      Sets the declaration handler to \a handler.      \sa declHandler() */
end_comment
begin_comment
comment|/*!     \fn QXmlDeclHandler* QXmlReader::declHandler() const      Returns the declaration handler or 0 if none was set.      \sa setDeclHandler() */
end_comment
begin_comment
comment|/*!   \fn bool QXmlReader::parse(const QXmlInputSource&input)    \obsolete    Parses the given \a input. */
end_comment
begin_comment
comment|/*!     \fn bool QXmlReader::parse(const QXmlInputSource *input)      Reads an XML document from \a input and parses it. Returns true if     the parsing was successful; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \class QXmlSimpleReader     \nonreentrant     \brief The QXmlSimpleReader class provides an implementation of a     simple XML parser.      \inmodule QtXml     \ingroup xml-tools       This XML reader is suitable for a wide range of applications. It     is able to parse well-formed XML and can report the namespaces of     elements to a content handler; however, it does not parse any     external entities. For historical reasons, Attribute Value     Normalization and End-of-Line Handling as described in the XML 1.0     specification is not performed.      The easiest pattern of use for this class is to create a reader     instance, define an input source, specify the handlers to be used     by the reader, and parse the data.      For example, we could use a QFile to supply the input. Here, we     create a reader, and define an input source to be used by the     reader:      \snippet simpleparse/main.cpp 0      A handler lets us perform actions when the reader encounters     certain types of content, or if errors in the input are found. The     reader must be told which handler to use for each type of     event. For many common applications, we can create a custom     handler by subclassing QXmlDefaultHandler, and use this to handle     both error and content events:      \snippet simpleparse/main.cpp 1      If you don't set at least the content and error handlers, the     parser will fall back on its default behavior---and will do     nothing.      The most convenient way to handle the input is to read it in a     single pass using the parse() function with an argument that     specifies the input source:      \snippet simpleparse/main.cpp 2      If you can't parse the entire input in one go (for example, it is     huge, or is being delivered over a network connection), data can     be fed to the parser in pieces. This is achieved by telling     parse() to work incrementally, and making subsequent calls to the     parseContinue() function, until all the data has been processed.      A common way to perform incremental parsing is to connect the \c     readyRead() signal of a \l{QNetworkReply} {network reply} a slot,     and handle the incoming data there. See QNetworkAccessManager.          Aspects of the parsing behavior can be adapted using setFeature()     and setProperty().          \snippet code/src_xml_sax_qxml.cpp 0      QXmlSimpleReader is not reentrant. If you want to use the class     in threaded code, lock the code using QXmlSimpleReader with a     locking mechanism, such as a QMutex. */
end_comment
begin_function
DECL|function|is_S
specifier|static
specifier|inline
name|bool
name|is_S
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
name|ushort
name|uc
init|=
name|ch
operator|.
name|unicode
argument_list|()
decl_stmt|;
return|return
operator|(
name|uc
operator|==
literal|' '
operator|||
name|uc
operator|==
literal|'\t'
operator|||
name|uc
operator|==
literal|'\n'
operator|||
name|uc
operator|==
literal|'\r'
operator|)
return|;
block|}
end_function
begin_enum
DECL|enum|NameChar
DECL|enumerator|NameBeginning
DECL|enumerator|NameNotBeginning
DECL|enumerator|NotName
enum|enum
name|NameChar
block|{
name|NameBeginning
block|,
name|NameNotBeginning
block|,
name|NotName
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|Begi
specifier|static
specifier|const
name|char
name|Begi
init|=
operator|(
name|char
operator|)
name|NameBeginning
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|NtBg
specifier|static
specifier|const
name|char
name|NtBg
init|=
operator|(
name|char
operator|)
name|NameNotBeginning
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|NotN
specifier|static
specifier|const
name|char
name|NotN
init|=
operator|(
name|char
operator|)
name|NotName
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|nameCharTable
specifier|static
specifier|const
name|char
name|nameCharTable
index|[
literal|128
index|]
init|=
block|{
comment|// 0x00
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
comment|// 0x10
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
comment|// 0x20 (0x2D is '-', 0x2E is '.')
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NotN
block|,
comment|// 0x30 (0x30..0x39 are '0'..'9', 0x3A is ':')
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|Begi
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
comment|// 0x40 (0x41..0x5A are 'A'..'Z')
name|NotN
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
comment|// 0x50 (0x5F is '_')
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|Begi
block|,
comment|// 0x60 (0x61..0x7A are 'a'..'z')
name|NotN
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
comment|// 0x70
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|fastDetermineNameChar
specifier|static
specifier|inline
name|NameChar
name|fastDetermineNameChar
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
name|ushort
name|uc
init|=
name|ch
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|uc
operator|&
operator|~
literal|0x7f
operator|)
condition|)
comment|// uc< 128
return|return
operator|(
name|NameChar
operator|)
name|nameCharTable
index|[
name|uc
index|]
return|;
name|QChar
operator|::
name|Category
name|cat
init|=
name|ch
operator|.
name|category
argument_list|()
decl_stmt|;
comment|// ### some these categories might be slightly wrong
if|if
condition|(
operator|(
name|cat
operator|>=
name|QChar
operator|::
name|Letter_Uppercase
operator|&&
name|cat
operator|<=
name|QChar
operator|::
name|Letter_Other
operator|)
operator|||
name|cat
operator|==
name|QChar
operator|::
name|Number_Letter
condition|)
return|return
name|NameBeginning
return|;
if|if
condition|(
operator|(
name|cat
operator|>=
name|QChar
operator|::
name|Number_DecimalDigit
operator|&&
name|cat
operator|<=
name|QChar
operator|::
name|Number_Other
operator|)
operator|||
operator|(
name|cat
operator|>=
name|QChar
operator|::
name|Mark_NonSpacing
operator|&&
name|cat
operator|<=
name|QChar
operator|::
name|Mark_Enclosing
operator|)
condition|)
return|return
name|NameNotBeginning
return|;
return|return
name|NotName
return|;
block|}
end_function
begin_function
DECL|function|determineNameChar
specifier|static
name|NameChar
name|determineNameChar
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
return|return
name|fastDetermineNameChar
argument_list|(
name|ch
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a simple XML reader.  */
end_comment
begin_constructor
DECL|function|QXmlSimpleReader
name|QXmlSimpleReader
operator|::
name|QXmlSimpleReader
parameter_list|()
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QXmlSimpleReaderPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the simple XML reader. */
end_comment
begin_destructor
DECL|function|~QXmlSimpleReader
name|QXmlSimpleReader
operator|::
name|~
name|QXmlSimpleReader
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|feature
name|bool
name|QXmlSimpleReader
operator|::
name|feature
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
specifier|const
name|QXmlSimpleReaderPrivate
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://xml.org/sax/features/namespaces"
argument_list|)
condition|)
block|{
return|return
name|d
operator|->
name|useNamespaces
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://xml.org/sax/features/namespace-prefixes"
argument_list|)
condition|)
block|{
return|return
name|d
operator|->
name|useNamespacePrefixes
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://trolltech.com/xml/features/report-whitespace-only-CharData"
argument_list|)
comment|// For compat with Qt 4
operator|||
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://qt-project.org/xml/features/report-whitespace-only-CharData"
argument_list|)
condition|)
block|{
return|return
name|d
operator|->
name|reportWhitespaceCharData
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://trolltech.com/xml/features/report-start-end-entity"
argument_list|)
comment|// For compat with Qt 4
operator|||
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://qt-project.org/xml/features/report-start-end-entity"
argument_list|)
condition|)
block|{
return|return
name|d
operator|->
name|reportEntities
return|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Unknown feature %s"
argument_list|,
name|name
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Turns on the feature \a name if \a enable is true; otherwise turns it off.      The \a name parameter must be one of the following strings:     \table     \header \li Feature \li Default \li Notes     \row \li \e http://xml.org/sax/features/namespaces          \li true          \li If enabled, namespaces are reported to the content handler.     \row \li \e http://xml.org/sax/features/namespace-prefixes          \li false          \li If enabled, the original prefixed names             and attributes used for namespace declarations are             reported.     \row \li \e http://trolltech.com/xml/features/report-whitespace-only-CharData          \li true          \li Obsolete, use the following string instead.             If enabled, CharData that consist of             only whitespace characters are reported             using QXmlContentHandler::characters(). If disabled, whitespace is silently             discarded.     \row \li \e http://qt-project.org/xml/features/report-whitespace-only-CharData          \li true          \li If enabled, CharData that consist of             only whitespace characters are reported             using QXmlContentHandler::characters(). If disabled, whitespace is silently             discarded.     \row \li \e http://trolltech.com/xml/features/report-start-end-entity          \li false          \li Obsolete, use the following string instead.             If enabled, the parser reports             QXmlContentHandler::startEntity() and             QXmlContentHandler::endEntity() events, so character data             might be reported in chunks.             If disabled, the parser does not report these events, but             silently substitutes the entities, and reports the character             data in one chunk.     \row \li \e http://qt-project.org/xml/features/report-start-end-entity          \li false          \li If enabled, the parser reports             QXmlContentHandler::startEntity() and             QXmlContentHandler::endEntity() events, so character data             might be reported in chunks.             If disabled, the parser does not report these events, but             silently substitutes the entities, and reports the character             data in one chunk.     \endtable      \sa feature(), hasFeature(), {SAX2 Features} */
end_comment
begin_function
DECL|function|setFeature
name|void
name|QXmlSimpleReader
operator|::
name|setFeature
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlSimpleReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://xml.org/sax/features/namespaces"
argument_list|)
condition|)
block|{
name|d
operator|->
name|useNamespaces
operator|=
name|enable
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://xml.org/sax/features/namespace-prefixes"
argument_list|)
condition|)
block|{
name|d
operator|->
name|useNamespacePrefixes
operator|=
name|enable
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://trolltech.com/xml/features/report-whitespace-only-CharData"
argument_list|)
comment|// For compat with Qt 4
operator|||
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://qt-project.org/xml/features/report-whitespace-only-CharData"
argument_list|)
condition|)
block|{
name|d
operator|->
name|reportWhitespaceCharData
operator|=
name|enable
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://trolltech.com/xml/features/report-start-end-entity"
argument_list|)
comment|// For compat with Qt 4
operator|||
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://trolltech.com/xml/features/report-start-end-entity"
argument_list|)
condition|)
block|{
name|d
operator|->
name|reportEntities
operator|=
name|enable
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Unknown feature %s"
argument_list|,
name|name
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|hasFeature
name|bool
name|QXmlSimpleReader
operator|::
name|hasFeature
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://xml.org/sax/features/namespaces"
argument_list|)
operator|||
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://xml.org/sax/features/namespace-prefixes"
argument_list|)
operator|||
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://trolltech.com/xml/features/report-whitespace-only-CharData"
argument_list|)
comment|// For compat with Qt 4
operator|||
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://qt-project.org/xml/features/report-whitespace-only-CharData"
argument_list|)
operator|||
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://trolltech.com/xml/features/report-start-end-entity"
argument_list|)
comment|// For compat with Qt 4
operator|||
name|name
operator|==
name|QLatin1String
argument_list|(
literal|"http://qt-project.org/xml/features/report-start-end-entity"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|property
name|void
modifier|*
name|QXmlSimpleReader
operator|::
name|property
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|setProperty
name|void
name|QXmlSimpleReader
operator|::
name|setProperty
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
name|void
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|hasProperty
name|bool
name|QXmlSimpleReader
operator|::
name|hasProperty
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|setEntityResolver
name|void
name|QXmlSimpleReader
operator|::
name|setEntityResolver
parameter_list|(
name|QXmlEntityResolver
modifier|*
name|handler
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlSimpleReader
argument_list|)
expr_stmt|;
name|d
operator|->
name|entityRes
operator|=
name|handler
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|entityResolver
name|QXmlEntityResolver
modifier|*
name|QXmlSimpleReader
operator|::
name|entityResolver
parameter_list|()
specifier|const
block|{
specifier|const
name|QXmlSimpleReaderPrivate
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
return|return
name|d
operator|->
name|entityRes
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|setDTDHandler
name|void
name|QXmlSimpleReader
operator|::
name|setDTDHandler
parameter_list|(
name|QXmlDTDHandler
modifier|*
name|handler
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlSimpleReader
argument_list|)
expr_stmt|;
name|d
operator|->
name|dtdHnd
operator|=
name|handler
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|DTDHandler
name|QXmlDTDHandler
modifier|*
name|QXmlSimpleReader
operator|::
name|DTDHandler
parameter_list|()
specifier|const
block|{
specifier|const
name|QXmlSimpleReaderPrivate
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
return|return
name|d
operator|->
name|dtdHnd
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|setContentHandler
name|void
name|QXmlSimpleReader
operator|::
name|setContentHandler
parameter_list|(
name|QXmlContentHandler
modifier|*
name|handler
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlSimpleReader
argument_list|)
expr_stmt|;
name|d
operator|->
name|contentHnd
operator|=
name|handler
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|contentHandler
name|QXmlContentHandler
modifier|*
name|QXmlSimpleReader
operator|::
name|contentHandler
parameter_list|()
specifier|const
block|{
specifier|const
name|QXmlSimpleReaderPrivate
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
return|return
name|d
operator|->
name|contentHnd
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|setErrorHandler
name|void
name|QXmlSimpleReader
operator|::
name|setErrorHandler
parameter_list|(
name|QXmlErrorHandler
modifier|*
name|handler
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlSimpleReader
argument_list|)
expr_stmt|;
name|d
operator|->
name|errorHnd
operator|=
name|handler
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|errorHandler
name|QXmlErrorHandler
modifier|*
name|QXmlSimpleReader
operator|::
name|errorHandler
parameter_list|()
specifier|const
block|{
specifier|const
name|QXmlSimpleReaderPrivate
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
return|return
name|d
operator|->
name|errorHnd
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|setLexicalHandler
name|void
name|QXmlSimpleReader
operator|::
name|setLexicalHandler
parameter_list|(
name|QXmlLexicalHandler
modifier|*
name|handler
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlSimpleReader
argument_list|)
expr_stmt|;
name|d
operator|->
name|lexicalHnd
operator|=
name|handler
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|lexicalHandler
name|QXmlLexicalHandler
modifier|*
name|QXmlSimpleReader
operator|::
name|lexicalHandler
parameter_list|()
specifier|const
block|{
specifier|const
name|QXmlSimpleReaderPrivate
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
return|return
name|d
operator|->
name|lexicalHnd
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|setDeclHandler
name|void
name|QXmlSimpleReader
operator|::
name|setDeclHandler
parameter_list|(
name|QXmlDeclHandler
modifier|*
name|handler
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlSimpleReader
argument_list|)
expr_stmt|;
name|d
operator|->
name|declHnd
operator|=
name|handler
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|declHandler
name|QXmlDeclHandler
modifier|*
name|QXmlSimpleReader
operator|::
name|declHandler
parameter_list|()
specifier|const
block|{
specifier|const
name|QXmlSimpleReaderPrivate
modifier|*
name|d
init|=
name|d_func
argument_list|()
decl_stmt|;
return|return
name|d
operator|->
name|declHnd
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|parse
name|bool
name|QXmlSimpleReader
operator|::
name|parse
parameter_list|(
specifier|const
name|QXmlInputSource
modifier|&
name|input
parameter_list|)
block|{
return|return
name|parse
argument_list|(
operator|&
name|input
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Reads an XML document from \a input and parses it in one pass (non-incrementally).     Returns true if the parsing was successful; otherwise returns false. */
end_comment
begin_function
DECL|function|parse
name|bool
name|QXmlSimpleReader
operator|::
name|parse
parameter_list|(
specifier|const
name|QXmlInputSource
modifier|*
name|input
parameter_list|)
block|{
return|return
name|parse
argument_list|(
name|input
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Reads an XML document from \a input and parses it. Returns true     if the parsing is completed successfully; otherwise returns false,     indicating that an error occurred.      If \a incremental is false, this function will return false if the XML     file is not read completely. The parsing cannot be continued in this     case.      If \a incremental is true, the parser does not return false if     it reaches the end of the \a input before reaching the end     of the XML file. Instead, it stores the state of the parser so that     parsing can be continued later when more data is available.     In such a case, you can use the function parseContinue() to     continue with parsing. This class stores a pointer to the input     source \a input and the parseContinue() function tries to read from     that input source. Therefore, you should not delete the input     source \a input until you no longer need to call parseContinue().      If this function is called with \a incremental set to true     while an incremental parse is in progress, a new parsing     session will be started, and the previous session will be lost.      \sa parseContinue(), QTcpSocket */
end_comment
begin_function
DECL|function|parse
name|bool
name|QXmlSimpleReader
operator|::
name|parse
parameter_list|(
specifier|const
name|QXmlInputSource
modifier|*
name|input
parameter_list|,
name|bool
name|incremental
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlSimpleReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|incremental
condition|)
block|{
name|d
operator|->
name|initIncrementalParsing
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|delete
name|d
operator|->
name|parseStack
expr_stmt|;
name|d
operator|->
name|parseStack
operator|=
literal|0
expr_stmt|;
block|}
name|d
operator|->
name|init
argument_list|(
name|input
argument_list|)
expr_stmt|;
comment|// call the handler
if|if
condition|(
name|d
operator|->
name|contentHnd
condition|)
block|{
name|d
operator|->
name|contentHnd
operator|->
name|setDocumentLocator
argument_list|(
name|d
operator|->
name|locator
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|contentHnd
operator|->
name|startDocument
argument_list|()
condition|)
block|{
name|d
operator|->
name|reportParseError
argument_list|(
name|d
operator|->
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|tags
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|qt_xml_skipped_entity_in_content
operator|=
literal|false
expr_stmt|;
return|return
name|d
operator|->
name|parseBeginOrContinue
argument_list|(
literal|0
argument_list|,
name|incremental
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Continues incremental parsing, taking input from the     QXmlInputSource that was specified with the most recent     call to parse(). To use this function, you \e must have called     parse() with the incremental argument set to true.      Returns false if a parsing error occurs; otherwise returns true,     even if the end of the XML file has not been reached. You can     continue parsing at a later stage by calling this function again     when there is more data available to parse.      Calling this function when there is no data available in the input     source indicates to the reader that the end of the XML file has     been reached. If the input supplied up to this point was     not well-formed then a parsing error occurs, and false is returned.     If the input supplied was well-formed, true is returned.     It is important to end the input in this way because it allows you     to reuse the reader to parse other XML files.      Calling this function after the end of file has been reached, but     without available data will cause false to be returned whether the     previous input was well-formed or not.      \sa parse(), QXmlInputSource::data(), QXmlInputSource::next() */
end_comment
begin_function
DECL|function|parseContinue
name|bool
name|QXmlSimpleReader
operator|::
name|parseContinue
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QXmlSimpleReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|parseStack
operator|==
literal|0
operator|||
name|d
operator|->
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|initData
argument_list|()
expr_stmt|;
name|int
name|state
init|=
name|d
operator|->
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
decl_stmt|;
return|return
name|d
operator|->
name|parseBeginOrContinue
argument_list|(
name|state
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*   Common part of parse() and parseContinue() */
end_comment
begin_function
DECL|function|parseBeginOrContinue
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseBeginOrContinue
parameter_list|(
name|int
name|state
parameter_list|,
name|bool
name|incremental
parameter_list|)
block|{
name|bool
name|atEndOrig
init|=
name|atEnd
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|parseProlog
argument_list|()
condition|)
block|{
if|if
condition|(
name|incremental
operator|&&
name|error
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|pushParseState
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|tags
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|state
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|parseElement
argument_list|()
condition|)
block|{
if|if
condition|(
name|incremental
operator|&&
name|error
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|pushParseState
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|tags
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|state
operator|=
literal|2
expr_stmt|;
block|}
comment|// parse Misc*
while|while
condition|(
operator|!
name|atEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|parseMisc
argument_list|()
condition|)
block|{
if|if
condition|(
name|incremental
operator|&&
name|error
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|pushParseState
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|tags
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|atEndOrig
operator|&&
name|incremental
condition|)
block|{
comment|// we parsed something at all, so be prepared to come back later
name|pushParseState
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// is stack empty?
if|if
condition|(
operator|!
name|tags
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|error
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNEXPECTEDEOF
argument_list|)
argument_list|)
expr_stmt|;
name|tags
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// call the handler
if|if
condition|(
name|contentHnd
condition|)
block|{
operator|delete
name|parseStack
expr_stmt|;
name|parseStack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|endDocument
argument_list|()
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// The following private parse functions have another semantics for the return
end_comment
begin_comment
comment|// value: They return true iff parsing has finished successfully (i.e. the end
end_comment
begin_comment
comment|// of the XML file must be reached!). If one of these functions return false,
end_comment
begin_comment
comment|// there is only an error when d->error.isNULL() is also false.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|/*   For the incremental parsing, it is very important that the parse...()   functions have a certain structure. Since it might be hard to understand how   they work, here is a description of the layout of these functions:      bool QXmlSimpleReader::parse...()     { (1)        const signed char Init             = 0;         ...  (2)        const signed char Inp...           = 0;         ...  (3)        static const signed char table[3][2] = {         ...         };         signed char state;         signed char input;  (4)        if (d->parseStack == 0 || d->parseStack->isEmpty()) { (4a)        ...         } else { (4b)        ...         }          for (; ;) { (5)            switch (state) {             ...             }  (6) (6a)            if (atEnd()) {                 unexpectedEof(&QXmlSimpleReader::parseNmtoken, state);                 return false;             } (6b)            if (determineNameChar(c) != NotName) {             ...             } (7)            state = table[state][input];  (8)            switch (state) {             ...             }         }     }    Explanation:   ad 1: constants for the states (used in the transition table)   ad 2: constants for the input (used in the transition table)   ad 3: the transition table for the state machine   ad 4: test if we are in a parseContinue() step         a) if no, do inititalizations         b) if yes, restore the state and call parse functions recursively   ad 5: Do some actions according to the state; from the logical execution         order, this code belongs after 8 (see there for an explanation)   ad 6: Check the character that is at the actual "cursor" position:         a) If we reached the EOF, report either error or push the state (in the            case of incremental parsing).         b) Otherwise, set the input character constant for the transition            table.   ad 7: Get the new state according to the input that was read.   ad 8: Do some actions according to the state. The last line in every case         statement reads new data (i.e. it move the cursor). This can also be         done by calling another parse...() function. If you need processing for         this state after that, you have to put it into the switch statement 5.         This ensures that you have a well defined re-entry point, when you ran         out of data. */
end_comment
begin_comment
comment|/*   Parses the prolog [22]. */
end_comment
begin_function
DECL|function|parseProlog
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseProlog
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|EatWS
init|=
literal|1
decl_stmt|;
comment|// eat white spaces
specifier|const
name|signed
name|char
name|Lt
init|=
literal|2
decl_stmt|;
comment|// '<' read
specifier|const
name|signed
name|char
name|Em
init|=
literal|3
decl_stmt|;
comment|// '!' read
specifier|const
name|signed
name|char
name|DocType
init|=
literal|4
decl_stmt|;
comment|// read doctype
specifier|const
name|signed
name|char
name|Comment
init|=
literal|5
decl_stmt|;
comment|// read comment
specifier|const
name|signed
name|char
name|CommentR
init|=
literal|6
decl_stmt|;
comment|// same as Comment, but already reported
specifier|const
name|signed
name|char
name|PInstr
init|=
literal|7
decl_stmt|;
comment|// read PI
specifier|const
name|signed
name|char
name|PInstrR
init|=
literal|8
decl_stmt|;
comment|// same as PInstr, but already reported
specifier|const
name|signed
name|char
name|Done
init|=
literal|9
decl_stmt|;
specifier|const
name|signed
name|char
name|InpWs
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|InpLt
init|=
literal|1
decl_stmt|;
comment|//<
specifier|const
name|signed
name|char
name|InpQm
init|=
literal|2
decl_stmt|;
comment|// ?
specifier|const
name|signed
name|char
name|InpEm
init|=
literal|3
decl_stmt|;
comment|// !
specifier|const
name|signed
name|char
name|InpD
init|=
literal|4
decl_stmt|;
comment|// D
specifier|const
name|signed
name|char
name|InpDash
init|=
literal|5
decl_stmt|;
comment|// -
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|6
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|9
index|]
index|[
literal|7
index|]
init|=
block|{
comment|/*  InpWs   InpLt  InpQm  InpEm  InpD      InpDash  InpUnknown */
block|{
name|EatWS
block|,
name|Lt
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
operator|-
literal|1
block|,
name|Lt
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// EatWS
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|PInstr
block|,
name|Em
block|,
name|Done
block|,
operator|-
literal|1
block|,
name|Done
block|}
block|,
comment|// Lt
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|DocType
block|,
name|Comment
block|,
operator|-
literal|1
block|}
block|,
comment|// Em
block|{
name|EatWS
block|,
name|Lt
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// DocType
block|{
name|EatWS
block|,
name|Lt
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Comment
block|{
name|EatWS
block|,
name|Lt
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// CommentR
block|{
name|EatWS
block|,
name|Lt
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// PInstr
block|{
name|EatWS
block|,
name|Lt
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
comment|// PInstrR
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|xmldecl_possible
operator|=
literal|true
expr_stmt|;
name|doctype_read
operator|=
literal|false
expr_stmt|;
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseProlog (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseProlog
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|DocType
case|:
if|if
condition|(
name|doctype_read
condition|)
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_MORETHANONEDOCTYPE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|doctype_read
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|Comment
case|:
if|if
condition|(
name|lexicalHnd
condition|)
block|{
if|if
condition|(
operator|!
name|lexicalHnd
operator|->
name|comment
argument_list|(
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|lexicalHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|state
operator|=
name|CommentR
expr_stmt|;
break|break;
case|case
name|PInstr
case|:
comment|// call the handler
if|if
condition|(
name|contentHnd
condition|)
block|{
if|if
condition|(
name|xmldecl_possible
operator|&&
operator|!
name|xmlVersion
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"version='"
argument_list|)
argument_list|)
decl_stmt|;
name|value
operator|+=
name|xmlVersion
expr_stmt|;
name|value
operator|+=
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoding
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|value
operator|+=
name|QLatin1String
argument_list|(
literal|" encoding='"
argument_list|)
expr_stmt|;
name|value
operator|+=
name|encoding
expr_stmt|;
name|value
operator|+=
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|standalone
operator|==
name|QXmlSimpleReaderPrivate
operator|::
name|Yes
condition|)
block|{
name|value
operator|+=
name|QLatin1String
argument_list|(
literal|" standalone='yes'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|standalone
operator|==
name|QXmlSimpleReaderPrivate
operator|::
name|No
condition|)
block|{
name|value
operator|+=
name|QLatin1String
argument_list|(
literal|" standalone='no'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|processingInstruction
argument_list|(
name|QLatin1String
argument_list|(
literal|"xml"
argument_list|)
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|processingInstruction
argument_list|(
name|name
argument_list|()
argument_list|,
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// XML declaration only on first position possible
name|xmldecl_possible
operator|=
literal|false
expr_stmt|;
name|state
operator|=
name|PInstrR
expr_stmt|;
break|break;
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_ERRORPARSINGELEMENT
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseProlog
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|is_S
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpWs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpLt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpQm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'!'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpEm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'D'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpDash
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|EatWS
case|:
comment|// XML declaration only on first position possible
name|xmldecl_possible
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseProlog
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Lt
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Em
case|:
comment|// XML declaration only on first position possible
name|xmldecl_possible
operator|=
literal|false
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|DocType
case|:
if|if
condition|(
operator|!
name|parseDoctype
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseProlog
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Comment
case|:
case|case
name|CommentR
case|:
if|if
condition|(
operator|!
name|parseComment
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseProlog
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|PInstr
case|:
case|case
name|PInstrR
case|:
name|parsePI_xmldecl
operator|=
name|xmldecl_possible
expr_stmt|;
if|if
condition|(
operator|!
name|parsePI
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseProlog
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse an element [39].    Precondition: the opening '<' is already read. */
end_comment
begin_function
DECL|function|parseElement
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseElement
parameter_list|()
block|{
specifier|const
name|int
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|ReadName
init|=
literal|1
decl_stmt|;
specifier|const
name|int
name|Ws1
init|=
literal|2
decl_stmt|;
specifier|const
name|int
name|STagEnd
init|=
literal|3
decl_stmt|;
specifier|const
name|int
name|STagEnd2
init|=
literal|4
decl_stmt|;
specifier|const
name|int
name|ETagBegin
init|=
literal|5
decl_stmt|;
specifier|const
name|int
name|ETagBegin2
init|=
literal|6
decl_stmt|;
specifier|const
name|int
name|Ws2
init|=
literal|7
decl_stmt|;
specifier|const
name|int
name|EmptyTag
init|=
literal|8
decl_stmt|;
specifier|const
name|int
name|Attrib
init|=
literal|9
decl_stmt|;
specifier|const
name|int
name|AttribPro
init|=
literal|10
decl_stmt|;
comment|// like Attrib, but processAttribute was already called
specifier|const
name|int
name|Ws3
init|=
literal|11
decl_stmt|;
specifier|const
name|int
name|Done
init|=
literal|12
decl_stmt|;
specifier|const
name|int
name|InpWs
init|=
literal|0
decl_stmt|;
comment|// whitespace
specifier|const
name|int
name|InpNameBe
init|=
literal|1
decl_stmt|;
comment|// NameBeginning
specifier|const
name|int
name|InpGt
init|=
literal|2
decl_stmt|;
comment|//>
specifier|const
name|int
name|InpSlash
init|=
literal|3
decl_stmt|;
comment|// /
specifier|const
name|int
name|InpUnknown
init|=
literal|4
decl_stmt|;
specifier|static
specifier|const
name|int
name|table
index|[
literal|12
index|]
index|[
literal|5
index|]
init|=
block|{
comment|/*  InpWs      InpNameBe    InpGt        InpSlash     InpUnknown */
block|{
operator|-
literal|1
block|,
name|ReadName
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
name|Ws1
block|,
name|Attrib
block|,
name|STagEnd
block|,
name|EmptyTag
block|,
operator|-
literal|1
block|}
block|,
comment|// ReadName
block|{
operator|-
literal|1
block|,
name|Attrib
block|,
name|STagEnd
block|,
name|EmptyTag
block|,
operator|-
literal|1
block|}
block|,
comment|// Ws1
block|{
name|STagEnd2
block|,
name|STagEnd2
block|,
name|STagEnd2
block|,
name|STagEnd2
block|,
name|STagEnd2
block|}
block|,
comment|// STagEnd
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ETagBegin
block|,
operator|-
literal|1
block|}
block|,
comment|// STagEnd2
block|{
operator|-
literal|1
block|,
name|ETagBegin2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// ETagBegin
block|{
name|Ws2
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// ETagBegin2
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Ws2
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// EmptyTag
block|{
name|Ws3
block|,
name|Attrib
block|,
name|STagEnd
block|,
name|EmptyTag
block|,
operator|-
literal|1
block|}
block|,
comment|// Attrib
block|{
name|Ws3
block|,
name|Attrib
block|,
name|STagEnd
block|,
name|EmptyTag
block|,
operator|-
literal|1
block|}
block|,
comment|// AttribPro
block|{
operator|-
literal|1
block|,
name|Attrib
block|,
name|STagEnd
block|,
name|EmptyTag
block|,
operator|-
literal|1
block|}
comment|// Ws3
block|}
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseElement (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElement
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ReadName
case|:
comment|// store it on the stack
name|tags
operator|.
name|push
argument_list|(
name|name
argument_list|()
argument_list|)
expr_stmt|;
comment|// empty the attributes
name|attList
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|useNamespaces
condition|)
name|namespaceSupport
operator|.
name|pushContext
argument_list|()
expr_stmt|;
break|break;
case|case
name|ETagBegin2
case|:
if|if
condition|(
operator|!
name|processElementETagBegin2
argument_list|()
condition|)
return|return
literal|false
return|;
break|break;
case|case
name|Attrib
case|:
if|if
condition|(
operator|!
name|processElementAttribute
argument_list|()
condition|)
return|return
literal|false
return|;
name|state
operator|=
name|AttribPro
expr_stmt|;
break|break;
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_ERRORPARSINGELEMENT
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElement
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fastDetermineNameChar
argument_list|(
name|c
argument_list|)
operator|==
name|NameBeginning
condition|)
block|{
name|input
operator|=
name|InpNameBe
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpGt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_S
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpWs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpSlash
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ReadName
case|:
name|parseName_useRef
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElement
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws1
case|:
case|case
name|Ws2
case|:
case|case
name|Ws3
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElement
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|STagEnd
case|:
comment|// call the handler
if|if
condition|(
name|contentHnd
condition|)
block|{
specifier|const
name|QString
modifier|&
name|tagsTop
init|=
name|tags
operator|.
name|top
argument_list|()
decl_stmt|;
if|if
condition|(
name|useNamespaces
condition|)
block|{
name|QString
name|uri
decl_stmt|,
name|lname
decl_stmt|;
name|namespaceSupport
operator|.
name|processName
argument_list|(
name|tagsTop
argument_list|,
literal|false
argument_list|,
name|uri
argument_list|,
name|lname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|startElement
argument_list|(
name|uri
argument_list|,
name|lname
argument_list|,
name|tagsTop
argument_list|,
name|attList
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|startElement
argument_list|(
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|tagsTop
argument_list|,
name|attList
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|STagEnd2
case|:
if|if
condition|(
operator|!
name|parseContent
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElement
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|ETagBegin
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|ETagBegin2
case|:
comment|// get the name of the tag
name|parseName_useRef
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElement
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EmptyTag
case|:
if|if
condition|(
name|tags
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_TAGMISMATCH
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|processElementEmptyTag
argument_list|()
condition|)
return|return
literal|false
return|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Attrib
case|:
case|case
name|AttribPro
case|:
comment|// get name and value of attribute
if|if
condition|(
operator|!
name|parseAttribute
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElement
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Done
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Helper to break down the size of the code in the case statement.   Return false on error, otherwise true. */
end_comment
begin_function
DECL|function|processElementEmptyTag
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|processElementEmptyTag
parameter_list|()
block|{
name|QString
name|uri
decl_stmt|,
name|lname
decl_stmt|;
comment|// pop the stack and call the handler
if|if
condition|(
name|contentHnd
condition|)
block|{
if|if
condition|(
name|useNamespaces
condition|)
block|{
comment|// report startElement first...
name|namespaceSupport
operator|.
name|processName
argument_list|(
name|tags
operator|.
name|top
argument_list|()
argument_list|,
literal|false
argument_list|,
name|uri
argument_list|,
name|lname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|startElement
argument_list|(
name|uri
argument_list|,
name|lname
argument_list|,
name|tags
operator|.
name|top
argument_list|()
argument_list|,
name|attList
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// ... followed by endElement...
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|endElement
argument_list|(
name|uri
argument_list|,
name|lname
argument_list|,
name|tags
operator|.
name|pop
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// ... followed by endPrefixMapping
name|QStringList
name|prefixesBefore
decl_stmt|,
name|prefixesAfter
decl_stmt|;
if|if
condition|(
name|contentHnd
condition|)
block|{
name|prefixesBefore
operator|=
name|namespaceSupport
operator|.
name|prefixes
argument_list|()
expr_stmt|;
block|}
name|namespaceSupport
operator|.
name|popContext
argument_list|()
expr_stmt|;
comment|// call the handler for prefix mapping
name|prefixesAfter
operator|=
name|namespaceSupport
operator|.
name|prefixes
argument_list|()
expr_stmt|;
for|for
control|(
name|QStringList
operator|::
name|Iterator
name|it
init|=
name|prefixesBefore
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|prefixesBefore
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|!
name|prefixesAfter
operator|.
name|contains
argument_list|(
operator|*
name|it
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|endPrefixMapping
argument_list|(
operator|*
name|it
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// report startElement first...
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|startElement
argument_list|(
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|tags
operator|.
name|top
argument_list|()
argument_list|,
name|attList
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// ... followed by endElement
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|endElement
argument_list|(
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|tags
operator|.
name|pop
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
name|tags
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|namespaceSupport
operator|.
name|popContext
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*   Helper to break down the size of the code in the case statement.   Return false on error, otherwise true. */
end_comment
begin_function
DECL|function|processElementETagBegin2
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|processElementETagBegin2
parameter_list|()
block|{
specifier|const
name|QString
modifier|&
name|name
init|=
name|QXmlSimpleReaderPrivate
operator|::
name|name
argument_list|()
decl_stmt|;
comment|// pop the stack and compare it with the name
if|if
condition|(
name|tags
operator|.
name|pop
argument_list|()
operator|!=
name|name
condition|)
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_TAGMISMATCH
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// call the handler
if|if
condition|(
name|contentHnd
condition|)
block|{
name|QString
name|uri
decl_stmt|,
name|lname
decl_stmt|;
if|if
condition|(
name|useNamespaces
condition|)
name|namespaceSupport
operator|.
name|processName
argument_list|(
name|name
argument_list|,
literal|false
argument_list|,
name|uri
argument_list|,
name|lname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|endElement
argument_list|(
name|uri
argument_list|,
name|lname
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|useNamespaces
condition|)
block|{
name|NamespaceMap
name|prefixesBefore
decl_stmt|,
name|prefixesAfter
decl_stmt|;
if|if
condition|(
name|contentHnd
condition|)
name|prefixesBefore
operator|=
name|namespaceSupport
operator|.
name|d
operator|->
name|ns
expr_stmt|;
name|namespaceSupport
operator|.
name|popContext
argument_list|()
expr_stmt|;
comment|// call the handler for prefix mapping
if|if
condition|(
name|contentHnd
condition|)
block|{
name|prefixesAfter
operator|=
name|namespaceSupport
operator|.
name|d
operator|->
name|ns
expr_stmt|;
if|if
condition|(
name|prefixesBefore
operator|.
name|size
argument_list|()
operator|!=
name|prefixesAfter
operator|.
name|size
argument_list|()
condition|)
block|{
for|for
control|(
name|NamespaceMap
operator|::
name|const_iterator
name|it
init|=
name|prefixesBefore
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|prefixesBefore
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|!
name|it
operator|.
name|key
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|prefixesAfter
operator|.
name|contains
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|endPrefixMapping
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*   Helper to break down the size of the code in the case statement.   Return false on error, otherwise true. */
end_comment
begin_function
DECL|function|processElementAttribute
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|processElementAttribute
parameter_list|()
block|{
name|QString
name|uri
decl_stmt|,
name|lname
decl_stmt|,
name|prefix
decl_stmt|;
specifier|const
name|QString
modifier|&
name|name
init|=
name|QXmlSimpleReaderPrivate
operator|::
name|name
argument_list|()
decl_stmt|;
specifier|const
name|QString
modifier|&
name|string
init|=
name|QXmlSimpleReaderPrivate
operator|::
name|string
argument_list|()
decl_stmt|;
comment|// add the attribute to the list
if|if
condition|(
name|useNamespaces
condition|)
block|{
comment|// is it a namespace declaration?
name|namespaceSupport
operator|.
name|splitName
argument_list|(
name|name
argument_list|,
name|prefix
argument_list|,
name|lname
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|==
name|QLatin1String
argument_list|(
literal|"xmlns"
argument_list|)
condition|)
block|{
comment|// namespace declaration
name|namespaceSupport
operator|.
name|setPrefix
argument_list|(
name|lname
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|useNamespacePrefixes
condition|)
block|{
comment|// according to http://www.w3.org/2000/xmlns/, the "prefix"
comment|// xmlns maps to the namespace name
comment|// http://www.w3.org/2000/xmlns/
name|attList
operator|.
name|append
argument_list|(
name|name
argument_list|,
name|QLatin1String
argument_list|(
literal|"http://www.w3.org/2000/xmlns/"
argument_list|)
argument_list|,
name|lname
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
comment|// call the handler for prefix mapping
if|if
condition|(
name|contentHnd
condition|)
block|{
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|startPrefixMapping
argument_list|(
name|lname
argument_list|,
name|string
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
comment|// no namespace delcaration
name|namespaceSupport
operator|.
name|processName
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|uri
argument_list|,
name|lname
argument_list|)
expr_stmt|;
name|attList
operator|.
name|append
argument_list|(
name|name
argument_list|,
name|uri
argument_list|,
name|lname
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// no namespace support
name|attList
operator|.
name|append
argument_list|(
name|name
argument_list|,
name|uri
argument_list|,
name|lname
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*   Parse a content [43].    A content is only used between tags. If a end tag is found the< is already   read and the head stand on the '/' of the end tag '</name>'. */
end_comment
begin_function
DECL|function|parseContent
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseContent
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|ChD
init|=
literal|1
decl_stmt|;
comment|// CharData
specifier|const
name|signed
name|char
name|ChD1
init|=
literal|2
decl_stmt|;
comment|// CharData help state
specifier|const
name|signed
name|char
name|ChD2
init|=
literal|3
decl_stmt|;
comment|// CharData help state
specifier|const
name|signed
name|char
name|Ref
init|=
literal|4
decl_stmt|;
comment|// Reference
specifier|const
name|signed
name|char
name|Lt
init|=
literal|5
decl_stmt|;
comment|// '<' read
specifier|const
name|signed
name|char
name|PInstr
init|=
literal|6
decl_stmt|;
comment|// PI
specifier|const
name|signed
name|char
name|PInstrR
init|=
literal|7
decl_stmt|;
comment|// same as PInstr, but already reported
specifier|const
name|signed
name|char
name|Elem
init|=
literal|8
decl_stmt|;
comment|// Element
specifier|const
name|signed
name|char
name|Em
init|=
literal|9
decl_stmt|;
comment|// '!' read
specifier|const
name|signed
name|char
name|Com
init|=
literal|10
decl_stmt|;
comment|// Comment
specifier|const
name|signed
name|char
name|ComR
init|=
literal|11
decl_stmt|;
comment|// same as Com, but already reported
specifier|const
name|signed
name|char
name|CDS
init|=
literal|12
decl_stmt|;
comment|// CDSect
specifier|const
name|signed
name|char
name|CDS1
init|=
literal|13
decl_stmt|;
comment|// read a CDSect
specifier|const
name|signed
name|char
name|CDS2
init|=
literal|14
decl_stmt|;
comment|// read a CDSect (help state)
specifier|const
name|signed
name|char
name|CDS3
init|=
literal|15
decl_stmt|;
comment|// read a CDSect (help state)
specifier|const
name|signed
name|char
name|Done
init|=
literal|16
decl_stmt|;
comment|// finished reading content
specifier|const
name|signed
name|char
name|InpLt
init|=
literal|0
decl_stmt|;
comment|//<
specifier|const
name|signed
name|char
name|InpGt
init|=
literal|1
decl_stmt|;
comment|//>
specifier|const
name|signed
name|char
name|InpSlash
init|=
literal|2
decl_stmt|;
comment|// /
specifier|const
name|signed
name|char
name|InpQMark
init|=
literal|3
decl_stmt|;
comment|// ?
specifier|const
name|signed
name|char
name|InpEMark
init|=
literal|4
decl_stmt|;
comment|// !
specifier|const
name|signed
name|char
name|InpAmp
init|=
literal|5
decl_stmt|;
comment|//&
specifier|const
name|signed
name|char
name|InpDash
init|=
literal|6
decl_stmt|;
comment|// -
specifier|const
name|signed
name|char
name|InpOpenB
init|=
literal|7
decl_stmt|;
comment|// [
specifier|const
name|signed
name|char
name|InpCloseB
init|=
literal|8
decl_stmt|;
comment|//]
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|9
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|mapCLT2FSMChar
index|[]
init|=
block|{
name|InpUnknown
block|,
comment|// white space
name|InpUnknown
block|,
comment|// %
name|InpAmp
block|,
comment|//&
name|InpGt
block|,
comment|//>
name|InpLt
block|,
comment|//<
name|InpSlash
block|,
comment|// /
name|InpQMark
block|,
comment|// ?
name|InpEMark
block|,
comment|// !
name|InpDash
block|,
comment|// -
name|InpCloseB
block|,
comment|//]
name|InpOpenB
block|,
comment|// [
name|InpUnknown
block|,
comment|// =
name|InpUnknown
block|,
comment|// "
name|InpUnknown
block|,
comment|// '
name|InpUnknown
comment|// unknown
block|}
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|16
index|]
index|[
literal|10
index|]
init|=
block|{
comment|/*  InpLt  InpGt  InpSlash  InpQMark  InpEMark  InpAmp  InpDash  InpOpenB  InpCloseB  InpUnknown */
block|{
name|Lt
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|Ref
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD1
block|,
name|ChD
block|}
block|,
comment|// Init
block|{
name|Lt
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|Ref
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD1
block|,
name|ChD
block|}
block|,
comment|// ChD
block|{
name|Lt
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|Ref
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD2
block|,
name|ChD
block|}
block|,
comment|// ChD1
block|{
name|Lt
block|,
operator|-
literal|1
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|Ref
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD2
block|,
name|ChD
block|}
block|,
comment|// ChD2
block|{
name|Lt
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|Ref
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|}
block|,
comment|// Ref (same as Init)
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
name|PInstr
block|,
name|Em
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Elem
block|}
block|,
comment|// Lt
block|{
name|Lt
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|Ref
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|}
block|,
comment|// PInstr (same as Init)
block|{
name|Lt
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|Ref
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|}
block|,
comment|// PInstrR
block|{
name|Lt
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|Ref
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|}
block|,
comment|// Elem (same as Init)
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Com
block|,
name|CDS
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Em
block|{
name|Lt
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|Ref
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|}
block|,
comment|// Com (same as Init)
block|{
name|Lt
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|Ref
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|,
name|ChD
block|}
block|,
comment|// ComR
block|{
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS2
block|,
name|CDS1
block|}
block|,
comment|// CDS
block|{
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS2
block|,
name|CDS1
block|}
block|,
comment|// CDS1
block|{
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS3
block|,
name|CDS1
block|}
block|,
comment|// CDS2
block|{
name|CDS1
block|,
name|Init
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS1
block|,
name|CDS3
block|,
name|CDS1
block|}
comment|// CDS3
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|contentCharDataRead
operator|=
literal|false
expr_stmt|;
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseContent (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseContent
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Ref
case|:
if|if
condition|(
operator|!
name|contentCharDataRead
condition|)
name|contentCharDataRead
operator|=
name|parseReference_charDataRead
expr_stmt|;
break|break;
case|case
name|PInstr
case|:
if|if
condition|(
name|contentHnd
condition|)
block|{
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|processingInstruction
argument_list|(
name|name
argument_list|()
argument_list|,
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|state
operator|=
name|PInstrR
expr_stmt|;
break|break;
case|case
name|Com
case|:
if|if
condition|(
name|lexicalHnd
condition|)
block|{
if|if
condition|(
operator|!
name|lexicalHnd
operator|->
name|comment
argument_list|(
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|lexicalHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|state
operator|=
name|ComR
expr_stmt|;
break|break;
case|case
name|CDS
case|:
name|stringClear
argument_list|()
expr_stmt|;
break|break;
case|case
name|CDS2
case|:
if|if
condition|(
operator|!
name|atEnd
argument_list|()
operator|&&
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
condition|)
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDS3
case|:
comment|// test if this skipping was legal
if|if
condition|(
operator|!
name|atEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
comment|// the end of the CDSect
if|if
condition|(
name|lexicalHnd
condition|)
block|{
if|if
condition|(
operator|!
name|lexicalHnd
operator|->
name|startCDATA
argument_list|()
condition|)
block|{
name|reportParseError
argument_list|(
name|lexicalHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|contentHnd
condition|)
block|{
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|characters
argument_list|(
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|lexicalHnd
condition|)
block|{
if|if
condition|(
operator|!
name|lexicalHnd
operator|->
name|endCDATA
argument_list|()
condition|)
block|{
name|reportParseError
argument_list|(
name|lexicalHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
comment|// three or more ']'
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// after ']]' comes another character
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Done
case|:
comment|// call the handler for CharData
if|if
condition|(
name|contentHnd
condition|)
block|{
if|if
condition|(
name|contentCharDataRead
condition|)
block|{
if|if
condition|(
name|reportWhitespaceCharData
operator|||
operator|!
name|string
argument_list|()
operator|.
name|simplified
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|characters
argument_list|(
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
comment|// Done
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_ERRORPARSINGCONTENT
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// get input (use lookup-table instead of nested ifs for performance
comment|// reasons)
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseContent
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|c
operator|.
name|row
argument_list|()
condition|)
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|mapCLT2FSMChar
index|[
name|charLookupTable
index|[
name|c
operator|.
name|cell
argument_list|()
index|]
index|]
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Init
case|:
comment|// skip the ending '>' of a CDATASection
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|ChD
case|:
comment|// on first call: clear string
if|if
condition|(
operator|!
name|contentCharDataRead
condition|)
block|{
name|contentCharDataRead
operator|=
literal|true
expr_stmt|;
name|stringClear
argument_list|()
expr_stmt|;
block|}
name|stringAddC
argument_list|()
expr_stmt|;
if|if
condition|(
name|reportEntities
condition|)
block|{
if|if
condition|(
operator|!
name|reportEndEntities
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|ChD1
case|:
comment|// on first call: clear string
if|if
condition|(
operator|!
name|contentCharDataRead
condition|)
block|{
name|contentCharDataRead
operator|=
literal|true
expr_stmt|;
name|stringClear
argument_list|()
expr_stmt|;
block|}
name|stringAddC
argument_list|()
expr_stmt|;
if|if
condition|(
name|reportEntities
condition|)
block|{
if|if
condition|(
operator|!
name|reportEndEntities
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|ChD2
case|:
name|stringAddC
argument_list|()
expr_stmt|;
if|if
condition|(
name|reportEntities
condition|)
block|{
if|if
condition|(
operator|!
name|reportEndEntities
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Ref
case|:
if|if
condition|(
operator|!
name|contentCharDataRead
condition|)
block|{
comment|// reference may be CharData; so clear string to be safe
name|stringClear
argument_list|()
expr_stmt|;
name|parseReference_context
operator|=
name|InContent
expr_stmt|;
if|if
condition|(
operator|!
name|parseReference
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseContent
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|reportEntities
condition|)
block|{
comment|// report character data in chunks
if|if
condition|(
name|contentHnd
condition|)
block|{
if|if
condition|(
name|reportWhitespaceCharData
operator|||
operator|!
name|string
argument_list|()
operator|.
name|simplified
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|characters
argument_list|(
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
name|stringClear
argument_list|()
expr_stmt|;
block|}
name|parseReference_context
operator|=
name|InContent
expr_stmt|;
if|if
condition|(
operator|!
name|parseReference
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseContent
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
break|break;
case|case
name|Lt
case|:
comment|// call the handler for CharData
if|if
condition|(
name|contentHnd
condition|)
block|{
if|if
condition|(
name|contentCharDataRead
condition|)
block|{
if|if
condition|(
name|reportWhitespaceCharData
operator|||
operator|!
name|string
argument_list|()
operator|.
name|simplified
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|characters
argument_list|(
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
name|contentCharDataRead
operator|=
literal|false
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|PInstr
case|:
case|case
name|PInstrR
case|:
name|parsePI_xmldecl
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parsePI
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseContent
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Elem
case|:
if|if
condition|(
operator|!
name|parseElement
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseContent
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Em
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Com
case|:
case|case
name|ComR
case|:
if|if
condition|(
operator|!
name|parseComment
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseContent
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|CDS
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"[CDATA["
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseContent
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|CDS1
case|:
name|stringAddC
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|CDS2
case|:
comment|// skip ']'
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|CDS3
case|:
comment|// skip ']'...
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|reportEndEntities
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|reportEndEntities
parameter_list|()
block|{
name|int
name|count
init|=
operator|(
name|int
operator|)
name|xmlRefStack
operator|.
name|count
argument_list|()
decl_stmt|;
while|while
condition|(
name|count
operator|!=
literal|0
operator|&&
name|xmlRefStack
operator|.
name|top
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|contentHnd
condition|)
block|{
if|if
condition|(
name|reportWhitespaceCharData
operator|||
operator|!
name|string
argument_list|()
operator|.
name|simplified
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|characters
argument_list|(
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
name|stringClear
argument_list|()
expr_stmt|;
if|if
condition|(
name|lexicalHnd
condition|)
block|{
if|if
condition|(
operator|!
name|lexicalHnd
operator|->
name|endEntity
argument_list|(
name|xmlRefStack
operator|.
name|top
argument_list|()
operator|.
name|name
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|lexicalHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|xmlRefStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*   Parse Misc [27]. */
end_comment
begin_function
DECL|function|parseMisc
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseMisc
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|Lt
init|=
literal|1
decl_stmt|;
comment|// '<' was read
specifier|const
name|signed
name|char
name|Comment
init|=
literal|2
decl_stmt|;
comment|// read comment
specifier|const
name|signed
name|char
name|eatWS
init|=
literal|3
decl_stmt|;
comment|// eat whitespaces
specifier|const
name|signed
name|char
name|PInstr
init|=
literal|4
decl_stmt|;
comment|// read PI
specifier|const
name|signed
name|char
name|Comment2
init|=
literal|5
decl_stmt|;
comment|// read comment
specifier|const
name|signed
name|char
name|InpWs
init|=
literal|0
decl_stmt|;
comment|// S
specifier|const
name|signed
name|char
name|InpLt
init|=
literal|1
decl_stmt|;
comment|//<
specifier|const
name|signed
name|char
name|InpQm
init|=
literal|2
decl_stmt|;
comment|// ?
specifier|const
name|signed
name|char
name|InpEm
init|=
literal|3
decl_stmt|;
comment|// !
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|4
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|3
index|]
index|[
literal|5
index|]
init|=
block|{
comment|/*  InpWs   InpLt  InpQm  InpEm     InpUnknown */
block|{
name|eatWS
block|,
name|Lt
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|PInstr
block|,
name|Comment
block|,
operator|-
literal|1
block|}
block|,
comment|// Lt
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Comment2
block|}
comment|// Comment
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseMisc (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseMisc
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|eatWS
case|:
return|return
literal|true
return|;
case|case
name|PInstr
case|:
if|if
condition|(
name|contentHnd
condition|)
block|{
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|processingInstruction
argument_list|(
name|name
argument_list|()
argument_list|,
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
case|case
name|Comment2
case|:
if|if
condition|(
name|lexicalHnd
condition|)
block|{
if|if
condition|(
operator|!
name|lexicalHnd
operator|->
name|comment
argument_list|(
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|lexicalHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNEXPECTEDCHARACTER
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseMisc
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|is_S
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpWs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpLt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpQm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'!'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpEm
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|eatWS
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseMisc
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Lt
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|PInstr
case|:
name|parsePI_xmldecl
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parsePI
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseMisc
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Comment
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Comment2
case|:
if|if
condition|(
operator|!
name|parseComment
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseMisc
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a processing instruction [16].    If xmldec is true, it tries to parse a PI or a XML declaration [23].    Precondition: the beginning '<' of the PI is already read and the head stand   on the '?' of '<?'.    If this funktion was successful, the head-position is on the first   character after the PI. */
end_comment
begin_function
DECL|function|parsePI
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parsePI
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|QmI
init|=
literal|1
decl_stmt|;
comment|// ? was read
specifier|const
name|signed
name|char
name|Name
init|=
literal|2
decl_stmt|;
comment|// read Name
specifier|const
name|signed
name|char
name|XMLDecl
init|=
literal|3
decl_stmt|;
comment|// read XMLDecl
specifier|const
name|signed
name|char
name|Ws1
init|=
literal|4
decl_stmt|;
comment|// eat ws after "xml" of XMLDecl
specifier|const
name|signed
name|char
name|PInstr
init|=
literal|5
decl_stmt|;
comment|// read PI
specifier|const
name|signed
name|char
name|Ws2
init|=
literal|6
decl_stmt|;
comment|// eat ws after Name of PI
specifier|const
name|signed
name|char
name|Version
init|=
literal|7
decl_stmt|;
comment|// read versionInfo
specifier|const
name|signed
name|char
name|Ws3
init|=
literal|8
decl_stmt|;
comment|// eat ws after versionInfo
specifier|const
name|signed
name|char
name|EorSD
init|=
literal|9
decl_stmt|;
comment|// read EDecl or SDDecl
specifier|const
name|signed
name|char
name|Ws4
init|=
literal|10
decl_stmt|;
comment|// eat ws after EDecl or SDDecl
specifier|const
name|signed
name|char
name|SD
init|=
literal|11
decl_stmt|;
comment|// read SDDecl
specifier|const
name|signed
name|char
name|Ws5
init|=
literal|12
decl_stmt|;
comment|// eat ws after SDDecl
specifier|const
name|signed
name|char
name|ADone
init|=
literal|13
decl_stmt|;
comment|// almost done
specifier|const
name|signed
name|char
name|Char
init|=
literal|14
decl_stmt|;
comment|// Char was read
specifier|const
name|signed
name|char
name|Qm
init|=
literal|15
decl_stmt|;
comment|// Qm was read
specifier|const
name|signed
name|char
name|Done
init|=
literal|16
decl_stmt|;
comment|// finished reading content
specifier|const
name|signed
name|char
name|InpWs
init|=
literal|0
decl_stmt|;
comment|// whitespace
specifier|const
name|signed
name|char
name|InpNameBe
init|=
literal|1
decl_stmt|;
comment|// NameBeginning
specifier|const
name|signed
name|char
name|InpGt
init|=
literal|2
decl_stmt|;
comment|//>
specifier|const
name|signed
name|char
name|InpQm
init|=
literal|3
decl_stmt|;
comment|// ?
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|4
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|16
index|]
index|[
literal|5
index|]
init|=
block|{
comment|/*  InpWs,  InpNameBe  InpGt  InpQm   InpUnknown  */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|QmI
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
operator|-
literal|1
block|,
name|Name
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// QmI
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Name (this state is left not through input)
block|{
name|Ws1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// XMLDecl
block|{
operator|-
literal|1
block|,
name|Version
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Ws1
block|{
name|Ws2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Qm
block|,
operator|-
literal|1
block|}
block|,
comment|// PInstr
block|{
name|Char
block|,
name|Char
block|,
name|Char
block|,
name|Qm
block|,
name|Char
block|}
block|,
comment|// Ws2
block|{
name|Ws3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ADone
block|,
operator|-
literal|1
block|}
block|,
comment|// Version
block|{
operator|-
literal|1
block|,
name|EorSD
block|,
operator|-
literal|1
block|,
name|ADone
block|,
operator|-
literal|1
block|}
block|,
comment|// Ws3
block|{
name|Ws4
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ADone
block|,
operator|-
literal|1
block|}
block|,
comment|// EorSD
block|{
operator|-
literal|1
block|,
name|SD
block|,
operator|-
literal|1
block|,
name|ADone
block|,
operator|-
literal|1
block|}
block|,
comment|// Ws4
block|{
name|Ws5
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ADone
block|,
operator|-
literal|1
block|}
block|,
comment|// SD
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ADone
block|,
operator|-
literal|1
block|}
block|,
comment|// Ws5
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// ADone
block|{
name|Char
block|,
name|Char
block|,
name|Char
block|,
name|Qm
block|,
name|Char
block|}
block|,
comment|// Char
block|{
name|Char
block|,
name|Char
block|,
name|Done
block|,
name|Qm
block|,
name|Char
block|}
block|,
comment|// Qm
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parsePI (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parsePI
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Name
case|:
comment|// test what name was read and determine the next state
comment|// (not very beautiful, I admit)
if|if
condition|(
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"xml"
argument_list|)
condition|)
block|{
if|if
condition|(
name|parsePI_xmldecl
operator|&&
name|name
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"xml"
argument_list|)
condition|)
block|{
name|state
operator|=
name|XMLDecl
expr_stmt|;
block|}
else|else
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_INVALIDNAMEFORPI
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|state
operator|=
name|PInstr
expr_stmt|;
name|stringClear
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|Version
case|:
comment|// get version (syntax like an attribute)
if|if
condition|(
name|name
argument_list|()
operator|!=
name|QLatin1String
argument_list|(
literal|"version"
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_VERSIONEXPECTED
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|xmlVersion
operator|=
name|string
argument_list|()
expr_stmt|;
break|break;
case|case
name|EorSD
case|:
comment|// get the EDecl or SDDecl (syntax like an attribute)
if|if
condition|(
name|name
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"standalone"
argument_list|)
condition|)
block|{
if|if
condition|(
name|string
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"yes"
argument_list|)
condition|)
block|{
name|standalone
operator|=
name|QXmlSimpleReaderPrivate
operator|::
name|Yes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|string
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"no"
argument_list|)
condition|)
block|{
name|standalone
operator|=
name|QXmlSimpleReaderPrivate
operator|::
name|No
expr_stmt|;
block|}
else|else
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_WRONGVALUEFORSDECL
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|name
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"encoding"
argument_list|)
condition|)
block|{
name|encoding
operator|=
name|string
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_EDECLORSDDECLEXPECTED
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|SD
case|:
if|if
condition|(
name|name
argument_list|()
operator|!=
name|QLatin1String
argument_list|(
literal|"standalone"
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_SDDECLEXPECTED
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|string
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"yes"
argument_list|)
condition|)
block|{
name|standalone
operator|=
name|QXmlSimpleReaderPrivate
operator|::
name|Yes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|string
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"no"
argument_list|)
condition|)
block|{
name|standalone
operator|=
name|QXmlSimpleReaderPrivate
operator|::
name|No
expr_stmt|;
block|}
else|else
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_WRONGVALUEFORSDECL
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Qm
case|:
comment|// test if the skipping was legal
if|if
condition|(
operator|!
name|atEnd
argument_list|()
operator|&&
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNEXPECTEDCHARACTER
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parsePI
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|is_S
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpWs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|determineNameChar
argument_list|(
name|c
argument_list|)
operator|==
name|NameBeginning
condition|)
block|{
name|input
operator|=
name|InpNameBe
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpGt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpQm
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|QmI
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Name
case|:
name|parseName_useRef
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parsePI
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws1
case|:
case|case
name|Ws2
case|:
case|case
name|Ws3
case|:
case|case
name|Ws4
case|:
case|case
name|Ws5
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parsePI
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Version
case|:
if|if
condition|(
operator|!
name|parseAttribute
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parsePI
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EorSD
case|:
if|if
condition|(
operator|!
name|parseAttribute
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parsePI
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|SD
case|:
comment|// get the SDDecl (syntax like an attribute)
if|if
condition|(
name|standalone
operator|!=
name|QXmlSimpleReaderPrivate
operator|::
name|Unknown
condition|)
block|{
comment|// already parsed the standalone declaration
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNEXPECTEDCHARACTER
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|parseAttribute
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parsePI
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|ADone
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Char
case|:
name|stringAddC
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qm
case|:
comment|// skip the '?'
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Done
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a document type definition (doctypedecl [28]).    Precondition: the beginning '<!' of the doctype is already read the head   stands on the 'D' of '<!DOCTYPE'.    If this function was successful, the head-position is on the first   character after the document type definition. */
end_comment
begin_function
DECL|function|parseDoctype
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseDoctype
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|Doctype
init|=
literal|1
decl_stmt|;
comment|// read the doctype
specifier|const
name|signed
name|char
name|Ws1
init|=
literal|2
decl_stmt|;
comment|// eat_ws
specifier|const
name|signed
name|char
name|Doctype2
init|=
literal|3
decl_stmt|;
comment|// read the doctype, part 2
specifier|const
name|signed
name|char
name|Ws2
init|=
literal|4
decl_stmt|;
comment|// eat_ws
specifier|const
name|signed
name|char
name|Sys
init|=
literal|5
decl_stmt|;
comment|// read SYSTEM or PUBLIC
specifier|const
name|signed
name|char
name|Ws3
init|=
literal|6
decl_stmt|;
comment|// eat_ws
specifier|const
name|signed
name|char
name|MP
init|=
literal|7
decl_stmt|;
comment|// markupdecl or PEReference
specifier|const
name|signed
name|char
name|MPR
init|=
literal|8
decl_stmt|;
comment|// same as MP, but already reported
specifier|const
name|signed
name|char
name|PER
init|=
literal|9
decl_stmt|;
comment|// PERReference
specifier|const
name|signed
name|char
name|Mup
init|=
literal|10
decl_stmt|;
comment|// markupdecl
specifier|const
name|signed
name|char
name|Ws4
init|=
literal|11
decl_stmt|;
comment|// eat_ws
specifier|const
name|signed
name|char
name|MPE
init|=
literal|12
decl_stmt|;
comment|// end of markupdecl or PEReference
specifier|const
name|signed
name|char
name|Done
init|=
literal|13
decl_stmt|;
specifier|const
name|signed
name|char
name|InpWs
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|InpD
init|=
literal|1
decl_stmt|;
comment|// 'D'
specifier|const
name|signed
name|char
name|InpS
init|=
literal|2
decl_stmt|;
comment|// 'S' or 'P'
specifier|const
name|signed
name|char
name|InpOB
init|=
literal|3
decl_stmt|;
comment|// [
specifier|const
name|signed
name|char
name|InpCB
init|=
literal|4
decl_stmt|;
comment|//]
specifier|const
name|signed
name|char
name|InpPer
init|=
literal|5
decl_stmt|;
comment|// %
specifier|const
name|signed
name|char
name|InpGt
init|=
literal|6
decl_stmt|;
comment|//>
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|7
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|13
index|]
index|[
literal|8
index|]
init|=
block|{
comment|/*  InpWs,  InpD       InpS       InpOB  InpCB  InpPer InpGt  InpUnknown */
block|{
operator|-
literal|1
block|,
name|Doctype
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
name|Ws1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Doctype
block|{
operator|-
literal|1
block|,
name|Doctype2
block|,
name|Doctype2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Doctype2
block|}
block|,
comment|// Ws1
block|{
name|Ws2
block|,
operator|-
literal|1
block|,
name|Sys
block|,
name|MP
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|}
block|,
comment|// Doctype2
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Sys
block|,
name|MP
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|}
block|,
comment|// Ws2
block|{
name|Ws3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|MP
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|}
block|,
comment|// Sys
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|MP
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|}
block|,
comment|// Ws3
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|MPE
block|,
name|PER
block|,
operator|-
literal|1
block|,
name|Mup
block|}
block|,
comment|// MP
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|MPE
block|,
name|PER
block|,
operator|-
literal|1
block|,
name|Mup
block|}
block|,
comment|// MPR
block|{
name|Ws4
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|MPE
block|,
name|PER
block|,
operator|-
literal|1
block|,
name|Mup
block|}
block|,
comment|// PER
block|{
name|Ws4
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|MPE
block|,
name|PER
block|,
operator|-
literal|1
block|,
name|Mup
block|}
block|,
comment|// Mup
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|MPE
block|,
name|PER
block|,
operator|-
literal|1
block|,
name|Mup
block|}
block|,
comment|// Ws4
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|}
comment|// MPE
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|startDTDwasReported
operator|=
literal|false
expr_stmt|;
name|systemId
operator|.
name|clear
argument_list|()
expr_stmt|;
name|publicId
operator|.
name|clear
argument_list|()
expr_stmt|;
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseDoctype (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseDoctype
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Doctype2
case|:
name|doctype
operator|=
name|name
argument_list|()
expr_stmt|;
break|break;
case|case
name|MP
case|:
if|if
condition|(
operator|!
name|startDTDwasReported
operator|&&
name|lexicalHnd
condition|)
block|{
name|startDTDwasReported
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|lexicalHnd
operator|->
name|startDTD
argument_list|(
name|doctype
argument_list|,
name|publicId
argument_list|,
name|systemId
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|lexicalHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|state
operator|=
name|MPR
expr_stmt|;
break|break;
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_ERRORPARSINGDOCTYPE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseDoctype
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|is_S
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpWs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'D'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'S'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'P'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpOB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpCB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpPer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpGt
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Doctype
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"DOCTYPE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseDoctype
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws1
case|:
case|case
name|Ws2
case|:
case|case
name|Ws3
case|:
case|case
name|Ws4
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseDoctype
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Doctype2
case|:
name|parseName_useRef
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseDoctype
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Sys
case|:
name|parseExternalID_allowPublicID
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseExternalID
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseDoctype
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|thisPublicId
operator|=
name|publicId
expr_stmt|;
name|thisSystemId
operator|=
name|systemId
expr_stmt|;
break|break;
case|case
name|MP
case|:
case|case
name|MPR
case|:
if|if
condition|(
operator|!
name|next_eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseDoctype
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|PER
case|:
name|parsePEReference_context
operator|=
name|InDTD
expr_stmt|;
if|if
condition|(
operator|!
name|parsePEReference
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseDoctype
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Mup
case|:
if|if
condition|(
operator|!
name|parseMarkupdecl
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseDoctype
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|MPE
case|:
if|if
condition|(
operator|!
name|next_eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseDoctype
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Done
case|:
if|if
condition|(
name|lexicalHnd
condition|)
block|{
if|if
condition|(
operator|!
name|startDTDwasReported
condition|)
block|{
name|startDTDwasReported
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|lexicalHnd
operator|->
name|startDTD
argument_list|(
name|doctype
argument_list|,
name|publicId
argument_list|,
name|systemId
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|lexicalHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|lexicalHnd
operator|->
name|endDTD
argument_list|()
condition|)
block|{
name|reportParseError
argument_list|(
name|lexicalHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a ExternalID [75].    If allowPublicID is true parse ExternalID [75] or PublicID [83]. */
end_comment
begin_function
DECL|function|parseExternalID
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseExternalID
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|Sys
init|=
literal|1
decl_stmt|;
comment|// parse 'SYSTEM'
specifier|const
name|signed
name|char
name|SysWS
init|=
literal|2
decl_stmt|;
comment|// parse the whitespace after 'SYSTEM'
specifier|const
name|signed
name|char
name|SysSQ
init|=
literal|3
decl_stmt|;
comment|// parse SystemLiteral with '
specifier|const
name|signed
name|char
name|SysSQ2
init|=
literal|4
decl_stmt|;
comment|// parse SystemLiteral with '
specifier|const
name|signed
name|char
name|SysDQ
init|=
literal|5
decl_stmt|;
comment|// parse SystemLiteral with "
specifier|const
name|signed
name|char
name|SysDQ2
init|=
literal|6
decl_stmt|;
comment|// parse SystemLiteral with "
specifier|const
name|signed
name|char
name|Pub
init|=
literal|7
decl_stmt|;
comment|// parse 'PUBLIC'
specifier|const
name|signed
name|char
name|PubWS
init|=
literal|8
decl_stmt|;
comment|// parse the whitespace after 'PUBLIC'
specifier|const
name|signed
name|char
name|PubSQ
init|=
literal|9
decl_stmt|;
comment|// parse PubidLiteral with '
specifier|const
name|signed
name|char
name|PubSQ2
init|=
literal|10
decl_stmt|;
comment|// parse PubidLiteral with '
specifier|const
name|signed
name|char
name|PubDQ
init|=
literal|11
decl_stmt|;
comment|// parse PubidLiteral with "
specifier|const
name|signed
name|char
name|PubDQ2
init|=
literal|12
decl_stmt|;
comment|// parse PubidLiteral with "
specifier|const
name|signed
name|char
name|PubE
init|=
literal|13
decl_stmt|;
comment|// finished parsing the PubidLiteral
specifier|const
name|signed
name|char
name|PubWS2
init|=
literal|14
decl_stmt|;
comment|// parse the whitespace after the PubidLiteral
specifier|const
name|signed
name|char
name|PDone
init|=
literal|15
decl_stmt|;
comment|// done if allowPublicID is true
specifier|const
name|signed
name|char
name|Done
init|=
literal|16
decl_stmt|;
specifier|const
name|signed
name|char
name|InpSQ
init|=
literal|0
decl_stmt|;
comment|// '
specifier|const
name|signed
name|char
name|InpDQ
init|=
literal|1
decl_stmt|;
comment|// "
specifier|const
name|signed
name|char
name|InpS
init|=
literal|2
decl_stmt|;
comment|// S
specifier|const
name|signed
name|char
name|InpP
init|=
literal|3
decl_stmt|;
comment|// P
specifier|const
name|signed
name|char
name|InpWs
init|=
literal|4
decl_stmt|;
comment|// white space
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|5
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|15
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/*  InpSQ    InpDQ    InpS     InpP     InpWs     InpUnknown */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Sys
block|,
name|Pub
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|SysWS
block|,
operator|-
literal|1
block|}
block|,
comment|// Sys
block|{
name|SysSQ
block|,
name|SysDQ
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// SysWS
block|{
name|Done
block|,
name|SysSQ2
block|,
name|SysSQ2
block|,
name|SysSQ2
block|,
name|SysSQ2
block|,
name|SysSQ2
block|}
block|,
comment|// SysSQ
block|{
name|Done
block|,
name|SysSQ2
block|,
name|SysSQ2
block|,
name|SysSQ2
block|,
name|SysSQ2
block|,
name|SysSQ2
block|}
block|,
comment|// SysSQ2
block|{
name|SysDQ2
block|,
name|Done
block|,
name|SysDQ2
block|,
name|SysDQ2
block|,
name|SysDQ2
block|,
name|SysDQ2
block|}
block|,
comment|// SysDQ
block|{
name|SysDQ2
block|,
name|Done
block|,
name|SysDQ2
block|,
name|SysDQ2
block|,
name|SysDQ2
block|,
name|SysDQ2
block|}
block|,
comment|// SysDQ2
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|PubWS
block|,
operator|-
literal|1
block|}
block|,
comment|// Pub
block|{
name|PubSQ
block|,
name|PubDQ
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// PubWS
block|{
name|PubE
block|,
operator|-
literal|1
block|,
name|PubSQ2
block|,
name|PubSQ2
block|,
name|PubSQ2
block|,
name|PubSQ2
block|}
block|,
comment|// PubSQ
block|{
name|PubE
block|,
operator|-
literal|1
block|,
name|PubSQ2
block|,
name|PubSQ2
block|,
name|PubSQ2
block|,
name|PubSQ2
block|}
block|,
comment|// PubSQ2
block|{
operator|-
literal|1
block|,
name|PubE
block|,
name|PubDQ2
block|,
name|PubDQ2
block|,
name|PubDQ2
block|,
name|PubDQ2
block|}
block|,
comment|// PubDQ
block|{
operator|-
literal|1
block|,
name|PubE
block|,
name|PubDQ2
block|,
name|PubDQ2
block|,
name|PubDQ2
block|,
name|PubDQ2
block|}
block|,
comment|// PubDQ2
block|{
name|PDone
block|,
name|PDone
block|,
name|PDone
block|,
name|PDone
block|,
name|PubWS2
block|,
name|PDone
block|}
block|,
comment|// PubE
block|{
name|SysSQ
block|,
name|SysDQ
block|,
name|PDone
block|,
name|PDone
block|,
name|PDone
block|,
name|PDone
block|}
comment|// PubWS2
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|systemId
operator|.
name|clear
argument_list|()
expr_stmt|;
name|publicId
operator|.
name|clear
argument_list|()
expr_stmt|;
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseExternalID (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseExternalID
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|PDone
case|:
if|if
condition|(
name|parseExternalID_allowPublicID
condition|)
block|{
name|publicId
operator|=
name|string
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNEXPECTEDCHARACTER
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNEXPECTEDCHARACTER
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseExternalID
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|is_S
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpWs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpSQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpDQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'S'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'P'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpP
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Sys
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"SYSTEM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseExternalID
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|SysWS
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseExternalID
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|SysSQ
case|:
case|case
name|SysDQ
case|:
name|stringClear
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|SysSQ2
case|:
case|case
name|SysDQ2
case|:
name|stringAddC
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Pub
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"PUBLIC"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseExternalID
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|PubWS
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseExternalID
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|PubSQ
case|:
case|case
name|PubDQ
case|:
name|stringClear
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|PubSQ2
case|:
case|case
name|PubDQ2
case|:
name|stringAddC
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|PubE
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|PubWS2
case|:
name|publicId
operator|=
name|string
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseExternalID
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Done
case|:
name|systemId
operator|=
name|string
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a markupdecl [29]. */
end_comment
begin_function
DECL|function|parseMarkupdecl
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseMarkupdecl
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|Lt
init|=
literal|1
decl_stmt|;
comment|//< was read
specifier|const
name|signed
name|char
name|Em
init|=
literal|2
decl_stmt|;
comment|// ! was read
specifier|const
name|signed
name|char
name|CE
init|=
literal|3
decl_stmt|;
comment|// E was read
specifier|const
name|signed
name|char
name|Qm
init|=
literal|4
decl_stmt|;
comment|// ? was read
specifier|const
name|signed
name|char
name|Dash
init|=
literal|5
decl_stmt|;
comment|// - was read
specifier|const
name|signed
name|char
name|CA
init|=
literal|6
decl_stmt|;
comment|// A was read
specifier|const
name|signed
name|char
name|CEL
init|=
literal|7
decl_stmt|;
comment|// EL was read
specifier|const
name|signed
name|char
name|CEN
init|=
literal|8
decl_stmt|;
comment|// EN was read
specifier|const
name|signed
name|char
name|CN
init|=
literal|9
decl_stmt|;
comment|// N was read
specifier|const
name|signed
name|char
name|Done
init|=
literal|10
decl_stmt|;
specifier|const
name|signed
name|char
name|InpLt
init|=
literal|0
decl_stmt|;
comment|//<
specifier|const
name|signed
name|char
name|InpQm
init|=
literal|1
decl_stmt|;
comment|// ?
specifier|const
name|signed
name|char
name|InpEm
init|=
literal|2
decl_stmt|;
comment|// !
specifier|const
name|signed
name|char
name|InpDash
init|=
literal|3
decl_stmt|;
comment|// -
specifier|const
name|signed
name|char
name|InpA
init|=
literal|4
decl_stmt|;
comment|// A
specifier|const
name|signed
name|char
name|InpE
init|=
literal|5
decl_stmt|;
comment|// E
specifier|const
name|signed
name|char
name|InpL
init|=
literal|6
decl_stmt|;
comment|// L
specifier|const
name|signed
name|char
name|InpN
init|=
literal|7
decl_stmt|;
comment|// N
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|8
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|4
index|]
index|[
literal|9
index|]
init|=
block|{
comment|/*  InpLt  InpQm  InpEm  InpDash  InpA   InpE   InpL   InpN   InpUnknown */
block|{
name|Lt
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
operator|-
literal|1
block|,
name|Qm
block|,
name|Em
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Lt
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Dash
block|,
name|CA
block|,
name|CE
block|,
operator|-
literal|1
block|,
name|CN
block|,
operator|-
literal|1
block|}
block|,
comment|// Em
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|CEL
block|,
name|CEN
block|,
operator|-
literal|1
block|}
comment|// CE
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseMarkupdecl (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseMarkupdecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Qm
case|:
if|if
condition|(
name|contentHnd
condition|)
block|{
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|processingInstruction
argument_list|(
name|name
argument_list|()
argument_list|,
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
case|case
name|Dash
case|:
if|if
condition|(
name|lexicalHnd
condition|)
block|{
if|if
condition|(
operator|!
name|lexicalHnd
operator|->
name|comment
argument_list|(
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|lexicalHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
case|case
name|CA
case|:
return|return
literal|true
return|;
case|case
name|CEL
case|:
return|return
literal|true
return|;
case|case
name|CEN
case|:
return|return
literal|true
return|;
case|case
name|CN
case|:
return|return
literal|true
return|;
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_LETTEREXPECTED
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseMarkupdecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpLt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpQm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'!'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpEm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpDash
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'E'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'L'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'N'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpN
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Lt
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Em
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|CE
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qm
case|:
name|parsePI_xmldecl
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parsePI
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseMarkupdecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Dash
case|:
if|if
condition|(
operator|!
name|parseComment
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseMarkupdecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|CA
case|:
if|if
condition|(
operator|!
name|parseAttlistDecl
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseMarkupdecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|CEL
case|:
if|if
condition|(
operator|!
name|parseElementDecl
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseMarkupdecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|CEN
case|:
if|if
condition|(
operator|!
name|parseEntityDecl
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseMarkupdecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|CN
case|:
if|if
condition|(
operator|!
name|parseNotationDecl
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseMarkupdecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a PEReference [69] */
end_comment
begin_function
DECL|function|parsePEReference
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parsePEReference
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|Next
init|=
literal|1
decl_stmt|;
specifier|const
name|signed
name|char
name|Name
init|=
literal|2
decl_stmt|;
specifier|const
name|signed
name|char
name|NameR
init|=
literal|3
decl_stmt|;
comment|// same as Name, but already reported
specifier|const
name|signed
name|char
name|Done
init|=
literal|4
decl_stmt|;
specifier|const
name|signed
name|char
name|InpSemi
init|=
literal|0
decl_stmt|;
comment|// ;
specifier|const
name|signed
name|char
name|InpPer
init|=
literal|1
decl_stmt|;
comment|// %
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|2
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|4
index|]
index|[
literal|3
index|]
init|=
block|{
comment|/*  InpSemi  InpPer  InpUnknown */
block|{
operator|-
literal|1
block|,
name|Next
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Name
block|}
block|,
comment|// Next
block|{
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Name
block|{
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
comment|// NameR
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parsePEReference (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parsePEReference
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Name
case|:
block|{
name|bool
name|skipIt
init|=
literal|true
decl_stmt|;
name|QString
name|xmlRefString
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
operator|::
name|Iterator
name|it
decl_stmt|;
name|it
operator|=
name|parameterEntities
operator|.
name|find
argument_list|(
name|ref
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|parameterEntities
operator|.
name|end
argument_list|()
condition|)
block|{
name|skipIt
operator|=
literal|false
expr_stmt|;
name|xmlRefString
operator|=
operator|*
name|it
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entityRes
condition|)
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|QXmlSimpleReaderPrivate
operator|::
name|ExternParameterEntity
argument_list|>
operator|::
name|Iterator
name|it2
decl_stmt|;
name|it2
operator|=
name|externParameterEntities
operator|.
name|find
argument_list|(
name|ref
argument_list|()
argument_list|)
expr_stmt|;
name|QXmlInputSource
modifier|*
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|it2
operator|!=
name|externParameterEntities
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|entityRes
operator|->
name|resolveEntity
argument_list|(
operator|(
operator|*
name|it2
operator|)
operator|.
name|publicId
argument_list|,
operator|(
operator|*
name|it2
operator|)
operator|.
name|systemId
argument_list|,
name|ret
argument_list|)
condition|)
block|{
operator|delete
name|ret
expr_stmt|;
name|reportParseError
argument_list|(
name|entityRes
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
name|xmlRefString
operator|=
name|ret
operator|->
name|data
argument_list|()
expr_stmt|;
operator|delete
name|ret
expr_stmt|;
if|if
condition|(
operator|!
name|stripTextDecl
argument_list|(
name|xmlRefString
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_ERRORINTEXTDECL
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|skipIt
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|skipIt
condition|)
block|{
if|if
condition|(
name|contentHnd
condition|)
block|{
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|skippedEntity
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
operator|+
name|ref
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|parsePEReference_context
operator|==
name|InEntityValue
condition|)
block|{
comment|// Included in literal
if|if
condition|(
operator|!
name|insertXmlRef
argument_list|(
name|xmlRefString
argument_list|,
name|ref
argument_list|()
argument_list|,
literal|true
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|parsePEReference_context
operator|==
name|InDTD
condition|)
block|{
comment|// Included as PE
if|if
condition|(
operator|!
name|insertXmlRef
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|xmlRefString
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|ref
argument_list|()
argument_list|,
literal|false
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
name|state
operator|=
name|NameR
expr_stmt|;
break|break;
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_LETTEREXPECTED
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parsePEReference
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpSemi
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpPer
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Next
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Name
case|:
case|case
name|NameR
case|:
name|parseName_useRef
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parsePEReference
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Done
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a AttlistDecl [52].    Precondition: the beginning '<!' is already read and the head   stands on the 'A' of '<!ATTLIST' */
end_comment
begin_function
DECL|function|parseAttlistDecl
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttlistDecl
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|Attlist
init|=
literal|1
decl_stmt|;
comment|// parse the string "ATTLIST"
specifier|const
name|signed
name|char
name|Ws
init|=
literal|2
decl_stmt|;
comment|// whitespace read
specifier|const
name|signed
name|char
name|Name
init|=
literal|3
decl_stmt|;
comment|// parse name
specifier|const
name|signed
name|char
name|Ws1
init|=
literal|4
decl_stmt|;
comment|// whitespace read
specifier|const
name|signed
name|char
name|Attdef
init|=
literal|5
decl_stmt|;
comment|// parse the AttDef
specifier|const
name|signed
name|char
name|Ws2
init|=
literal|6
decl_stmt|;
comment|// whitespace read
specifier|const
name|signed
name|char
name|Atttype
init|=
literal|7
decl_stmt|;
comment|// parse the AttType
specifier|const
name|signed
name|char
name|Ws3
init|=
literal|8
decl_stmt|;
comment|// whitespace read
specifier|const
name|signed
name|char
name|DDecH
init|=
literal|9
decl_stmt|;
comment|// DefaultDecl with #
specifier|const
name|signed
name|char
name|DefReq
init|=
literal|10
decl_stmt|;
comment|// parse the string "REQUIRED"
specifier|const
name|signed
name|char
name|DefImp
init|=
literal|11
decl_stmt|;
comment|// parse the string "IMPLIED"
specifier|const
name|signed
name|char
name|DefFix
init|=
literal|12
decl_stmt|;
comment|// parse the string "FIXED"
specifier|const
name|signed
name|char
name|Attval
init|=
literal|13
decl_stmt|;
comment|// parse the AttValue
specifier|const
name|signed
name|char
name|Ws4
init|=
literal|14
decl_stmt|;
comment|// whitespace read
specifier|const
name|signed
name|char
name|Done
init|=
literal|15
decl_stmt|;
specifier|const
name|signed
name|char
name|InpWs
init|=
literal|0
decl_stmt|;
comment|// white space
specifier|const
name|signed
name|char
name|InpGt
init|=
literal|1
decl_stmt|;
comment|//>
specifier|const
name|signed
name|char
name|InpHash
init|=
literal|2
decl_stmt|;
comment|// #
specifier|const
name|signed
name|char
name|InpA
init|=
literal|3
decl_stmt|;
comment|// A
specifier|const
name|signed
name|char
name|InpI
init|=
literal|4
decl_stmt|;
comment|// I
specifier|const
name|signed
name|char
name|InpF
init|=
literal|5
decl_stmt|;
comment|// F
specifier|const
name|signed
name|char
name|InpR
init|=
literal|6
decl_stmt|;
comment|// R
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|7
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|15
index|]
index|[
literal|8
index|]
init|=
block|{
comment|/*  InpWs    InpGt    InpHash  InpA      InpI     InpF     InpR     InpUnknown */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Attlist
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
name|Ws
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Attlist
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Name
block|,
name|Name
block|,
name|Name
block|,
name|Name
block|,
name|Name
block|}
block|,
comment|// Ws
block|{
name|Ws1
block|,
name|Done
block|,
name|Attdef
block|,
name|Attdef
block|,
name|Attdef
block|,
name|Attdef
block|,
name|Attdef
block|,
name|Attdef
block|}
block|,
comment|// Name
block|{
operator|-
literal|1
block|,
name|Done
block|,
name|Attdef
block|,
name|Attdef
block|,
name|Attdef
block|,
name|Attdef
block|,
name|Attdef
block|,
name|Attdef
block|}
block|,
comment|// Ws1
block|{
name|Ws2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Attdef
block|{
operator|-
literal|1
block|,
name|Atttype
block|,
name|Atttype
block|,
name|Atttype
block|,
name|Atttype
block|,
name|Atttype
block|,
name|Atttype
block|,
name|Atttype
block|}
block|,
comment|// Ws2
block|{
name|Ws3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Attype
block|{
operator|-
literal|1
block|,
name|Attval
block|,
name|DDecH
block|,
name|Attval
block|,
name|Attval
block|,
name|Attval
block|,
name|Attval
block|,
name|Attval
block|}
block|,
comment|// Ws3
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|DefImp
block|,
name|DefFix
block|,
name|DefReq
block|,
operator|-
literal|1
block|}
block|,
comment|// DDecH
block|{
name|Ws4
block|,
name|Ws4
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// DefReq
block|{
name|Ws4
block|,
name|Ws4
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// DefImp
block|{
name|Ws3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// DefFix
block|{
name|Ws4
block|,
name|Ws4
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Attval
block|{
operator|-
literal|1
block|,
name|Done
block|,
name|Attdef
block|,
name|Attdef
block|,
name|Attdef
block|,
name|Attdef
block|,
name|Attdef
block|,
name|Attdef
block|}
comment|// Ws4
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseAttlistDecl (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttlistDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Name
case|:
name|attDeclEName
operator|=
name|name
argument_list|()
expr_stmt|;
break|break;
case|case
name|Attdef
case|:
name|attDeclAName
operator|=
name|name
argument_list|()
expr_stmt|;
break|break;
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_LETTEREXPECTED
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttlistDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|is_S
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpWs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpGt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpHash
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'I'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpI
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'F'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'R'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpR
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Attlist
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"ATTLIST"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttlistDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws
case|:
case|case
name|Ws1
case|:
case|case
name|Ws2
case|:
case|case
name|Ws3
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttlistDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Name
case|:
name|parseName_useRef
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttlistDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Attdef
case|:
name|parseName_useRef
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttlistDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Atttype
case|:
if|if
condition|(
operator|!
name|parseAttType
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttlistDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|DDecH
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|DefReq
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"REQUIRED"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttlistDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|DefImp
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"IMPLIED"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttlistDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|DefFix
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"FIXED"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttlistDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Attval
case|:
if|if
condition|(
operator|!
name|parseAttValue
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttlistDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws4
case|:
if|if
condition|(
name|declHnd
condition|)
block|{
comment|// ### not all values are computed yet...
if|if
condition|(
operator|!
name|declHnd
operator|->
name|attributeDecl
argument_list|(
name|attDeclEName
argument_list|,
name|attDeclAName
argument_list|,
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|declHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttlistDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Done
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a AttType [54] */
end_comment
begin_function
DECL|function|parseAttType
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|ST
init|=
literal|1
decl_stmt|;
comment|// StringType
specifier|const
name|signed
name|char
name|TTI
init|=
literal|2
decl_stmt|;
comment|// TokenizedType starting with 'I'
specifier|const
name|signed
name|char
name|TTI2
init|=
literal|3
decl_stmt|;
comment|// TokenizedType helpstate
specifier|const
name|signed
name|char
name|TTI3
init|=
literal|4
decl_stmt|;
comment|// TokenizedType helpstate
specifier|const
name|signed
name|char
name|TTE
init|=
literal|5
decl_stmt|;
comment|// TokenizedType starting with 'E'
specifier|const
name|signed
name|char
name|TTEY
init|=
literal|6
decl_stmt|;
comment|// TokenizedType starting with 'ENTITY'
specifier|const
name|signed
name|char
name|TTEI
init|=
literal|7
decl_stmt|;
comment|// TokenizedType starting with 'ENTITI'
specifier|const
name|signed
name|char
name|N
init|=
literal|8
decl_stmt|;
comment|// N read (TokenizedType or Notation)
specifier|const
name|signed
name|char
name|TTNM
init|=
literal|9
decl_stmt|;
comment|// TokenizedType starting with 'NM'
specifier|const
name|signed
name|char
name|TTNM2
init|=
literal|10
decl_stmt|;
comment|// TokenizedType helpstate
specifier|const
name|signed
name|char
name|NO
init|=
literal|11
decl_stmt|;
comment|// Notation
specifier|const
name|signed
name|char
name|NO2
init|=
literal|12
decl_stmt|;
comment|// Notation helpstate
specifier|const
name|signed
name|char
name|NO3
init|=
literal|13
decl_stmt|;
comment|// Notation helpstate
specifier|const
name|signed
name|char
name|NOName
init|=
literal|14
decl_stmt|;
comment|// Notation, read name
specifier|const
name|signed
name|char
name|NO4
init|=
literal|15
decl_stmt|;
comment|// Notation helpstate
specifier|const
name|signed
name|char
name|EN
init|=
literal|16
decl_stmt|;
comment|// Enumeration
specifier|const
name|signed
name|char
name|ENNmt
init|=
literal|17
decl_stmt|;
comment|// Enumeration, read Nmtoken
specifier|const
name|signed
name|char
name|EN2
init|=
literal|18
decl_stmt|;
comment|// Enumeration helpstate
specifier|const
name|signed
name|char
name|ADone
init|=
literal|19
decl_stmt|;
comment|// almost done (make next and accept)
specifier|const
name|signed
name|char
name|Done
init|=
literal|20
decl_stmt|;
specifier|const
name|signed
name|char
name|InpWs
init|=
literal|0
decl_stmt|;
comment|// whitespace
specifier|const
name|signed
name|char
name|InpOp
init|=
literal|1
decl_stmt|;
comment|// (
specifier|const
name|signed
name|char
name|InpCp
init|=
literal|2
decl_stmt|;
comment|//)
specifier|const
name|signed
name|char
name|InpPipe
init|=
literal|3
decl_stmt|;
comment|// |
specifier|const
name|signed
name|char
name|InpC
init|=
literal|4
decl_stmt|;
comment|// C
specifier|const
name|signed
name|char
name|InpE
init|=
literal|5
decl_stmt|;
comment|// E
specifier|const
name|signed
name|char
name|InpI
init|=
literal|6
decl_stmt|;
comment|// I
specifier|const
name|signed
name|char
name|InpM
init|=
literal|7
decl_stmt|;
comment|// M
specifier|const
name|signed
name|char
name|InpN
init|=
literal|8
decl_stmt|;
comment|// N
specifier|const
name|signed
name|char
name|InpO
init|=
literal|9
decl_stmt|;
comment|// O
specifier|const
name|signed
name|char
name|InpR
init|=
literal|10
decl_stmt|;
comment|// R
specifier|const
name|signed
name|char
name|InpS
init|=
literal|11
decl_stmt|;
comment|// S
specifier|const
name|signed
name|char
name|InpY
init|=
literal|12
decl_stmt|;
comment|// Y
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|13
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|19
index|]
index|[
literal|14
index|]
init|=
block|{
comment|/*  InpWs    InpOp    InpCp    InpPipe  InpC     InpE     InpI     InpM     InpN     InpO     InpR     InpS     InpY     InpUnknown */
block|{
operator|-
literal|1
block|,
name|EN
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ST
block|,
name|TTE
block|,
name|TTI
block|,
operator|-
literal|1
block|,
name|N
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|}
block|,
comment|// ST
block|{
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|TTI2
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|}
block|,
comment|// TTI
block|{
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|TTI3
block|,
name|Done
block|,
name|Done
block|}
block|,
comment|// TTI2
block|{
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|}
block|,
comment|// TTI3
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|TTEI
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|TTEY
block|,
operator|-
literal|1
block|}
block|,
comment|// TTE
block|{
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|}
block|,
comment|// TTEY
block|{
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|}
block|,
comment|// TTEI
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|TTNM
block|,
operator|-
literal|1
block|,
name|NO
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// N
block|{
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|TTNM2
block|,
name|Done
block|,
name|Done
block|}
block|,
comment|// TTNM
block|{
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|,
name|Done
block|}
block|,
comment|// TTNM2
block|{
name|NO2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// NO
block|{
operator|-
literal|1
block|,
name|NO3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// NO2
block|{
name|NOName
block|,
name|NOName
block|,
name|NOName
block|,
name|NOName
block|,
name|NOName
block|,
name|NOName
block|,
name|NOName
block|,
name|NOName
block|,
name|NOName
block|,
name|NOName
block|,
name|NOName
block|,
name|NOName
block|,
name|NOName
block|,
name|NOName
block|}
block|,
comment|// NO3
block|{
name|NO4
block|,
operator|-
literal|1
block|,
name|ADone
block|,
name|NO3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// NOName
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ADone
block|,
name|NO3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// NO4
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ENNmt
block|,
operator|-
literal|1
block|,
name|ENNmt
block|,
name|ENNmt
block|,
name|ENNmt
block|,
name|ENNmt
block|,
name|ENNmt
block|,
name|ENNmt
block|,
name|ENNmt
block|,
name|ENNmt
block|,
name|ENNmt
block|,
name|ENNmt
block|}
block|,
comment|// EN
block|{
name|EN2
block|,
operator|-
literal|1
block|,
name|ADone
block|,
name|EN
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// ENNmt
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ADone
block|,
name|EN
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
comment|// EN2
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseAttType (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ADone
case|:
return|return
literal|true
return|;
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_LETTEREXPECTED
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|is_S
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpWs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'('
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpOp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpCp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpPipe
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'C'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'E'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'I'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpI
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'M'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'N'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'O'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'R'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'S'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'Y'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpY
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ST
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"CDATA"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|TTI
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"ID"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|TTI2
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"REF"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|TTI3
case|:
name|next
argument_list|()
expr_stmt|;
comment|// S
break|break;
case|case
name|TTE
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"ENTIT"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|TTEY
case|:
name|next
argument_list|()
expr_stmt|;
comment|// Y
break|break;
case|case
name|TTEI
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"IES"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|N
case|:
name|next
argument_list|()
expr_stmt|;
comment|// N
break|break;
case|case
name|TTNM
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"MTOKEN"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|TTNM2
case|:
name|next
argument_list|()
expr_stmt|;
comment|// S
break|break;
case|case
name|NO
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"OTATION"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|NO2
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|NO3
case|:
if|if
condition|(
operator|!
name|next_eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|NOName
case|:
name|parseName_useRef
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|NO4
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EN
case|:
if|if
condition|(
operator|!
name|next_eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|ENNmt
case|:
if|if
condition|(
operator|!
name|parseNmtoken
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EN2
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttType
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|ADone
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a AttValue [10]    Precondition: the head stands on the beginning " or '    If this function was successful, the head stands on the first   character after the closing " or ' and the value of the attribute   is in string(). */
end_comment
begin_function
DECL|function|parseAttValue
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttValue
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|Dq
init|=
literal|1
decl_stmt|;
comment|// double quotes were read
specifier|const
name|signed
name|char
name|DqRef
init|=
literal|2
decl_stmt|;
comment|// read references in double quotes
specifier|const
name|signed
name|char
name|DqC
init|=
literal|3
decl_stmt|;
comment|// signed character read in double quotes
specifier|const
name|signed
name|char
name|Sq
init|=
literal|4
decl_stmt|;
comment|// single quotes were read
specifier|const
name|signed
name|char
name|SqRef
init|=
literal|5
decl_stmt|;
comment|// read references in single quotes
specifier|const
name|signed
name|char
name|SqC
init|=
literal|6
decl_stmt|;
comment|// signed character read in single quotes
specifier|const
name|signed
name|char
name|Done
init|=
literal|7
decl_stmt|;
specifier|const
name|signed
name|char
name|InpDq
init|=
literal|0
decl_stmt|;
comment|// "
specifier|const
name|signed
name|char
name|InpSq
init|=
literal|1
decl_stmt|;
comment|// '
specifier|const
name|signed
name|char
name|InpAmp
init|=
literal|2
decl_stmt|;
comment|//&
specifier|const
name|signed
name|char
name|InpLt
init|=
literal|3
decl_stmt|;
comment|//<
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|4
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|7
index|]
index|[
literal|5
index|]
init|=
block|{
comment|/*  InpDq  InpSq  InpAmp  InpLt InpUnknown */
block|{
name|Dq
block|,
name|Sq
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
name|Done
block|,
name|DqC
block|,
name|DqRef
block|,
operator|-
literal|1
block|,
name|DqC
block|}
block|,
comment|// Dq
block|{
name|Done
block|,
name|DqC
block|,
name|DqRef
block|,
operator|-
literal|1
block|,
name|DqC
block|}
block|,
comment|// DqRef
block|{
name|Done
block|,
name|DqC
block|,
name|DqRef
block|,
operator|-
literal|1
block|,
name|DqC
block|}
block|,
comment|// DqC
block|{
name|SqC
block|,
name|Done
block|,
name|SqRef
block|,
operator|-
literal|1
block|,
name|SqC
block|}
block|,
comment|// Sq
block|{
name|SqC
block|,
name|Done
block|,
name|SqRef
block|,
operator|-
literal|1
block|,
name|SqC
block|}
block|,
comment|// SqRef
block|{
name|SqC
block|,
name|Done
block|,
name|SqRef
block|,
operator|-
literal|1
block|,
name|SqC
block|}
comment|// SqRef
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseAttValue (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttValue
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNEXPECTEDCHARACTER
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttValue
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpDq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpSq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpAmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpLt
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Dq
case|:
case|case
name|Sq
case|:
name|stringClear
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|DqRef
case|:
case|case
name|SqRef
case|:
name|parseReference_context
operator|=
name|InAttributeValue
expr_stmt|;
if|if
condition|(
operator|!
name|parseReference
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttValue
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|DqC
case|:
case|case
name|SqC
case|:
name|stringAddC
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Done
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a elementdecl [45].    Precondition: the beginning '<!E' is already read and the head   stands on the 'L' of '<!ELEMENT' */
end_comment
begin_function
DECL|function|parseElementDecl
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|Elem
init|=
literal|1
decl_stmt|;
comment|// parse the beginning string
specifier|const
name|signed
name|char
name|Ws1
init|=
literal|2
decl_stmt|;
comment|// whitespace required
specifier|const
name|signed
name|char
name|Nam
init|=
literal|3
decl_stmt|;
comment|// parse Name
specifier|const
name|signed
name|char
name|Ws2
init|=
literal|4
decl_stmt|;
comment|// whitespace required
specifier|const
name|signed
name|char
name|Empty
init|=
literal|5
decl_stmt|;
comment|// read EMPTY
specifier|const
name|signed
name|char
name|Any
init|=
literal|6
decl_stmt|;
comment|// read ANY
specifier|const
name|signed
name|char
name|Cont
init|=
literal|7
decl_stmt|;
comment|// read contentspec (except ANY or EMPTY)
specifier|const
name|signed
name|char
name|Mix
init|=
literal|8
decl_stmt|;
comment|// read Mixed
specifier|const
name|signed
name|char
name|Mix2
init|=
literal|9
decl_stmt|;
comment|//
specifier|const
name|signed
name|char
name|Mix3
init|=
literal|10
decl_stmt|;
comment|//
specifier|const
name|signed
name|char
name|MixN1
init|=
literal|11
decl_stmt|;
comment|//
specifier|const
name|signed
name|char
name|MixN2
init|=
literal|12
decl_stmt|;
comment|//
specifier|const
name|signed
name|char
name|MixN3
init|=
literal|13
decl_stmt|;
comment|//
specifier|const
name|signed
name|char
name|MixN4
init|=
literal|14
decl_stmt|;
comment|//
specifier|const
name|signed
name|char
name|Cp
init|=
literal|15
decl_stmt|;
comment|// parse cp
specifier|const
name|signed
name|char
name|Cp2
init|=
literal|16
decl_stmt|;
comment|//
specifier|const
name|signed
name|char
name|WsD
init|=
literal|17
decl_stmt|;
comment|// eat whitespace before Done
specifier|const
name|signed
name|char
name|Done
init|=
literal|18
decl_stmt|;
specifier|const
name|signed
name|char
name|InpWs
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|InpGt
init|=
literal|1
decl_stmt|;
comment|//>
specifier|const
name|signed
name|char
name|InpPipe
init|=
literal|2
decl_stmt|;
comment|// |
specifier|const
name|signed
name|char
name|InpOp
init|=
literal|3
decl_stmt|;
comment|// (
specifier|const
name|signed
name|char
name|InpCp
init|=
literal|4
decl_stmt|;
comment|//)
specifier|const
name|signed
name|char
name|InpHash
init|=
literal|5
decl_stmt|;
comment|// #
specifier|const
name|signed
name|char
name|InpQm
init|=
literal|6
decl_stmt|;
comment|// ?
specifier|const
name|signed
name|char
name|InpAst
init|=
literal|7
decl_stmt|;
comment|// *
specifier|const
name|signed
name|char
name|InpPlus
init|=
literal|8
decl_stmt|;
comment|// +
specifier|const
name|signed
name|char
name|InpA
init|=
literal|9
decl_stmt|;
comment|// A
specifier|const
name|signed
name|char
name|InpE
init|=
literal|10
decl_stmt|;
comment|// E
specifier|const
name|signed
name|char
name|InpL
init|=
literal|11
decl_stmt|;
comment|// L
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|12
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|18
index|]
index|[
literal|13
index|]
init|=
block|{
comment|/*  InpWs   InpGt  InpPipe  InpOp  InpCp   InpHash  InpQm  InpAst  InpPlus  InpA    InpE    InpL    InpUnknown */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Elem
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
name|Ws1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Elem
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Nam
block|,
name|Nam
block|,
name|Nam
block|,
name|Nam
block|}
block|,
comment|// Ws1
block|{
name|Ws2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Nam
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Cont
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Any
block|,
name|Empty
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Ws2
block|{
name|WsD
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Empty
block|{
name|WsD
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Any
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Cp
block|,
name|Cp
block|,
name|Mix
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Cp
block|,
name|Cp
block|,
name|Cp
block|,
name|Cp
block|}
block|,
comment|// Cont
block|{
name|Mix2
block|,
operator|-
literal|1
block|,
name|MixN1
block|,
operator|-
literal|1
block|,
name|Mix3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Mix
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|MixN1
block|,
operator|-
literal|1
block|,
name|Mix3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Mix2
block|{
name|WsD
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|WsD
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Mix3
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|MixN2
block|,
name|MixN2
block|,
name|MixN2
block|,
name|MixN2
block|}
block|,
comment|// MixN1
block|{
name|MixN3
block|,
operator|-
literal|1
block|,
name|MixN1
block|,
operator|-
literal|1
block|,
name|MixN4
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// MixN2
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|MixN1
block|,
operator|-
literal|1
block|,
name|MixN4
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// MixN3
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|WsD
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// MixN4
block|{
name|WsD
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Cp2
block|,
name|Cp2
block|,
name|Cp2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Cp
block|{
name|WsD
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Cp2
block|{
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
comment|// WsD
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseElementDecl (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNEXPECTEDCHARACTER
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|is_S
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpWs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpGt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpPipe
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'('
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpOp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpCp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpHash
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpQm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpAst
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpPlus
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'E'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'L'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpL
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Elem
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"LEMENT"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws1
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Nam
case|:
name|parseName_useRef
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws2
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Empty
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"EMPTY"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Any
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"ANY"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Cont
case|:
if|if
condition|(
operator|!
name|next_eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Mix
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"#PCDATA"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Mix2
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Mix3
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|MixN1
case|:
if|if
condition|(
operator|!
name|next_eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|MixN2
case|:
name|parseName_useRef
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|MixN3
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|MixN4
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Cp
case|:
if|if
condition|(
operator|!
name|parseChoiceSeq
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Cp2
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|WsD
case|:
if|if
condition|(
operator|!
name|next_eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseElementDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Done
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a NotationDecl [82].    Precondition: the beginning '<!' is already read and the head   stands on the 'N' of '<!NOTATION' */
end_comment
begin_function
DECL|function|parseNotationDecl
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseNotationDecl
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|Not
init|=
literal|1
decl_stmt|;
comment|// read NOTATION
specifier|const
name|signed
name|char
name|Ws1
init|=
literal|2
decl_stmt|;
comment|// eat whitespaces
specifier|const
name|signed
name|char
name|Nam
init|=
literal|3
decl_stmt|;
comment|// read Name
specifier|const
name|signed
name|char
name|Ws2
init|=
literal|4
decl_stmt|;
comment|// eat whitespaces
specifier|const
name|signed
name|char
name|ExtID
init|=
literal|5
decl_stmt|;
comment|// parse ExternalID
specifier|const
name|signed
name|char
name|ExtIDR
init|=
literal|6
decl_stmt|;
comment|// same as ExtID, but already reported
specifier|const
name|signed
name|char
name|Ws3
init|=
literal|7
decl_stmt|;
comment|// eat whitespaces
specifier|const
name|signed
name|char
name|Done
init|=
literal|8
decl_stmt|;
specifier|const
name|signed
name|char
name|InpWs
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|InpGt
init|=
literal|1
decl_stmt|;
comment|//>
specifier|const
name|signed
name|char
name|InpN
init|=
literal|2
decl_stmt|;
comment|// N
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|3
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|8
index|]
index|[
literal|4
index|]
init|=
block|{
comment|/*  InpWs   InpGt  InpN    InpUnknown */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Not
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
name|Ws1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Not
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Nam
block|,
name|Nam
block|}
block|,
comment|// Ws1
block|{
name|Ws2
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Nam
block|{
operator|-
literal|1
block|,
name|Done
block|,
name|ExtID
block|,
name|ExtID
block|}
block|,
comment|// Ws2
block|{
name|Ws3
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// ExtID
block|{
name|Ws3
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// ExtIDR
block|{
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
comment|// Ws3
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseNotationDecl (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseNotationDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ExtID
case|:
comment|// call the handler
if|if
condition|(
name|dtdHnd
condition|)
block|{
if|if
condition|(
operator|!
name|dtdHnd
operator|->
name|notationDecl
argument_list|(
name|name
argument_list|()
argument_list|,
name|publicId
argument_list|,
name|systemId
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|dtdHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|state
operator|=
name|ExtIDR
expr_stmt|;
break|break;
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNEXPECTEDCHARACTER
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseNotationDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|is_S
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpWs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpGt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'N'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpN
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Not
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"NOTATION"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseNotationDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws1
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseNotationDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Nam
case|:
name|parseName_useRef
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseNotationDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws2
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseNotationDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|ExtID
case|:
case|case
name|ExtIDR
case|:
name|parseExternalID_allowPublicID
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|parseExternalID
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseNotationDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws3
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseNotationDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Done
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse choice [49] or seq [50].    Precondition: the beginning '('S? is already read and the head   stands on the first non-whitespace character after it. */
end_comment
begin_function
DECL|function|parseChoiceSeq
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseChoiceSeq
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|Ws1
init|=
literal|1
decl_stmt|;
comment|// eat whitespace
specifier|const
name|signed
name|char
name|CoS
init|=
literal|2
decl_stmt|;
comment|// choice or set
specifier|const
name|signed
name|char
name|Ws2
init|=
literal|3
decl_stmt|;
comment|// eat whitespace
specifier|const
name|signed
name|char
name|More
init|=
literal|4
decl_stmt|;
comment|// more cp to read
specifier|const
name|signed
name|char
name|Name
init|=
literal|5
decl_stmt|;
comment|// read name
specifier|const
name|signed
name|char
name|Done
init|=
literal|6
decl_stmt|;
comment|//
specifier|const
name|signed
name|char
name|InpWs
init|=
literal|0
decl_stmt|;
comment|// S
specifier|const
name|signed
name|char
name|InpOp
init|=
literal|1
decl_stmt|;
comment|// (
specifier|const
name|signed
name|char
name|InpCp
init|=
literal|2
decl_stmt|;
comment|//)
specifier|const
name|signed
name|char
name|InpQm
init|=
literal|3
decl_stmt|;
comment|// ?
specifier|const
name|signed
name|char
name|InpAst
init|=
literal|4
decl_stmt|;
comment|// *
specifier|const
name|signed
name|char
name|InpPlus
init|=
literal|5
decl_stmt|;
comment|// +
specifier|const
name|signed
name|char
name|InpPipe
init|=
literal|6
decl_stmt|;
comment|// |
specifier|const
name|signed
name|char
name|InpComm
init|=
literal|7
decl_stmt|;
comment|// ,
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|8
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|6
index|]
index|[
literal|9
index|]
init|=
block|{
comment|/*  InpWs   InpOp  InpCp  InpQm  InpAst  InpPlus  InpPipe  InpComm  InpUnknown */
block|{
operator|-
literal|1
block|,
name|Ws1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Name
block|}
block|,
comment|// Init
block|{
operator|-
literal|1
block|,
name|CoS
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|CoS
block|}
block|,
comment|// Ws1
block|{
name|Ws2
block|,
operator|-
literal|1
block|,
name|Done
block|,
name|Ws2
block|,
name|Ws2
block|,
name|Ws2
block|,
name|More
block|,
name|More
block|,
operator|-
literal|1
block|}
block|,
comment|// CS
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|More
block|,
name|More
block|,
operator|-
literal|1
block|}
block|,
comment|// Ws2
block|{
operator|-
literal|1
block|,
name|Ws1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Name
block|}
block|,
comment|// More (same as Init)
block|{
name|Ws2
block|,
operator|-
literal|1
block|,
name|Done
block|,
name|Ws2
block|,
name|Ws2
block|,
name|Ws2
block|,
name|More
block|,
name|More
block|,
operator|-
literal|1
block|}
comment|// Name (same as CS)
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseChoiceSeq (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseChoiceSeq
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNEXPECTEDCHARACTER
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseChoiceSeq
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|is_S
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpWs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'('
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpOp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpCp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpQm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpAst
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpPlus
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpPipe
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpComm
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Ws1
case|:
if|if
condition|(
operator|!
name|next_eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseChoiceSeq
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|CoS
case|:
if|if
condition|(
operator|!
name|parseChoiceSeq
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseChoiceSeq
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws2
case|:
if|if
condition|(
operator|!
name|next_eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseChoiceSeq
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|More
case|:
if|if
condition|(
operator|!
name|next_eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseChoiceSeq
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Name
case|:
name|parseName_useRef
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseChoiceSeq
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Done
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a EntityDecl [70].    Precondition: the beginning '<!E' is already read and the head   stand on the 'N' of '<!ENTITY' */
end_comment
begin_function
DECL|function|parseEntityDecl
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|Ent
init|=
literal|1
decl_stmt|;
comment|// parse "ENTITY"
specifier|const
name|signed
name|char
name|Ws1
init|=
literal|2
decl_stmt|;
comment|// white space read
specifier|const
name|signed
name|char
name|Name
init|=
literal|3
decl_stmt|;
comment|// parse name
specifier|const
name|signed
name|char
name|Ws2
init|=
literal|4
decl_stmt|;
comment|// white space read
specifier|const
name|signed
name|char
name|EValue
init|=
literal|5
decl_stmt|;
comment|// parse entity value
specifier|const
name|signed
name|char
name|EValueR
init|=
literal|6
decl_stmt|;
comment|// same as EValue, but already reported
specifier|const
name|signed
name|char
name|ExtID
init|=
literal|7
decl_stmt|;
comment|// parse ExternalID
specifier|const
name|signed
name|char
name|Ws3
init|=
literal|8
decl_stmt|;
comment|// white space read
specifier|const
name|signed
name|char
name|Ndata
init|=
literal|9
decl_stmt|;
comment|// parse "NDATA"
specifier|const
name|signed
name|char
name|Ws4
init|=
literal|10
decl_stmt|;
comment|// white space read
specifier|const
name|signed
name|char
name|NNam
init|=
literal|11
decl_stmt|;
comment|// parse name
specifier|const
name|signed
name|char
name|NNamR
init|=
literal|12
decl_stmt|;
comment|// same as NNam, but already reported
specifier|const
name|signed
name|char
name|PEDec
init|=
literal|13
decl_stmt|;
comment|// parse PEDecl
specifier|const
name|signed
name|char
name|Ws6
init|=
literal|14
decl_stmt|;
comment|// white space read
specifier|const
name|signed
name|char
name|PENam
init|=
literal|15
decl_stmt|;
comment|// parse name
specifier|const
name|signed
name|char
name|Ws7
init|=
literal|16
decl_stmt|;
comment|// white space read
specifier|const
name|signed
name|char
name|PEVal
init|=
literal|17
decl_stmt|;
comment|// parse entity value
specifier|const
name|signed
name|char
name|PEValR
init|=
literal|18
decl_stmt|;
comment|// same as PEVal, but already reported
specifier|const
name|signed
name|char
name|PEEID
init|=
literal|19
decl_stmt|;
comment|// parse ExternalID
specifier|const
name|signed
name|char
name|PEEIDR
init|=
literal|20
decl_stmt|;
comment|// same as PEEID, but already reported
specifier|const
name|signed
name|char
name|WsE
init|=
literal|21
decl_stmt|;
comment|// white space read
specifier|const
name|signed
name|char
name|Done
init|=
literal|22
decl_stmt|;
specifier|const
name|signed
name|char
name|EDDone
init|=
literal|23
decl_stmt|;
comment|// done, but also report an external, unparsed entity decl
specifier|const
name|signed
name|char
name|InpWs
init|=
literal|0
decl_stmt|;
comment|// white space
specifier|const
name|signed
name|char
name|InpPer
init|=
literal|1
decl_stmt|;
comment|// %
specifier|const
name|signed
name|char
name|InpQuot
init|=
literal|2
decl_stmt|;
comment|// " or '
specifier|const
name|signed
name|char
name|InpGt
init|=
literal|3
decl_stmt|;
comment|//>
specifier|const
name|signed
name|char
name|InpN
init|=
literal|4
decl_stmt|;
comment|// N
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|5
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|22
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/*  InpWs  InpPer  InpQuot  InpGt  InpN    InpUnknown */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Ent
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
name|Ws1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Ent
block|{
operator|-
literal|1
block|,
name|PEDec
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Name
block|,
name|Name
block|}
block|,
comment|// Ws1
block|{
name|Ws2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Name
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|EValue
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ExtID
block|}
block|,
comment|// Ws2
block|{
name|WsE
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// EValue
block|{
name|WsE
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// EValueR
block|{
name|Ws3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|EDDone
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// ExtID
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|EDDone
block|,
name|Ndata
block|,
operator|-
literal|1
block|}
block|,
comment|// Ws3
block|{
name|Ws4
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Ndata
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|NNam
block|,
name|NNam
block|}
block|,
comment|// Ws4
block|{
name|WsE
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// NNam
block|{
name|WsE
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// NNamR
block|{
name|Ws6
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// PEDec
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|PENam
block|,
name|PENam
block|}
block|,
comment|// Ws6
block|{
name|Ws7
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// PENam
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|PEVal
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|PEEID
block|}
block|,
comment|// Ws7
block|{
name|WsE
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// PEVal
block|{
name|WsE
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// PEValR
block|{
name|WsE
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// PEEID
block|{
name|WsE
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// PEEIDR
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
comment|// WsE
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseEntityDecl (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|EValue
case|:
if|if
condition|(
operator|!
name|entityExist
argument_list|(
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|entities
operator|.
name|insert
argument_list|(
name|name
argument_list|()
argument_list|,
name|string
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|declHnd
condition|)
block|{
if|if
condition|(
operator|!
name|declHnd
operator|->
name|internalEntityDecl
argument_list|(
name|name
argument_list|()
argument_list|,
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|declHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
name|state
operator|=
name|EValueR
expr_stmt|;
break|break;
case|case
name|NNam
case|:
if|if
condition|(
operator|!
name|entityExist
argument_list|(
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|externEntities
operator|.
name|insert
argument_list|(
name|name
argument_list|()
argument_list|,
name|QXmlSimpleReaderPrivate
operator|::
name|ExternEntity
argument_list|(
name|publicId
argument_list|,
name|systemId
argument_list|,
name|ref
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtdHnd
condition|)
block|{
if|if
condition|(
operator|!
name|dtdHnd
operator|->
name|unparsedEntityDecl
argument_list|(
name|name
argument_list|()
argument_list|,
name|publicId
argument_list|,
name|systemId
argument_list|,
name|ref
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|declHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
name|state
operator|=
name|NNamR
expr_stmt|;
break|break;
case|case
name|PEVal
case|:
if|if
condition|(
operator|!
name|entityExist
argument_list|(
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|parameterEntities
operator|.
name|insert
argument_list|(
name|name
argument_list|()
argument_list|,
name|string
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|declHnd
condition|)
block|{
if|if
condition|(
operator|!
name|declHnd
operator|->
name|internalEntityDecl
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
operator|+
name|name
argument_list|()
argument_list|,
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|declHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
name|state
operator|=
name|PEValR
expr_stmt|;
break|break;
case|case
name|PEEID
case|:
if|if
condition|(
operator|!
name|entityExist
argument_list|(
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|externParameterEntities
operator|.
name|insert
argument_list|(
name|name
argument_list|()
argument_list|,
name|QXmlSimpleReaderPrivate
operator|::
name|ExternParameterEntity
argument_list|(
name|publicId
argument_list|,
name|systemId
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|declHnd
condition|)
block|{
if|if
condition|(
operator|!
name|declHnd
operator|->
name|externalEntityDecl
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
operator|+
name|name
argument_list|()
argument_list|,
name|publicId
argument_list|,
name|systemId
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|declHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
name|state
operator|=
name|PEEIDR
expr_stmt|;
break|break;
case|case
name|EDDone
case|:
if|if
condition|(
operator|!
name|entityExist
argument_list|(
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|externEntities
operator|.
name|insert
argument_list|(
name|name
argument_list|()
argument_list|,
name|QXmlSimpleReaderPrivate
operator|::
name|ExternEntity
argument_list|(
name|publicId
argument_list|,
name|systemId
argument_list|,
name|QString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|declHnd
condition|)
block|{
if|if
condition|(
operator|!
name|declHnd
operator|->
name|externalEntityDecl
argument_list|(
name|name
argument_list|()
argument_list|,
name|publicId
argument_list|,
name|systemId
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|declHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_LETTEREXPECTED
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|is_S
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpWs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpPer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
operator|||
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpQuot
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpGt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'N'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpN
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Ent
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"NTITY"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws1
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Name
case|:
name|parseName_useRef
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws2
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EValue
case|:
case|case
name|EValueR
case|:
if|if
condition|(
operator|!
name|parseEntityValue
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|ExtID
case|:
name|parseExternalID_allowPublicID
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseExternalID
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws3
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ndata
case|:
name|parseString_s
operator|=
name|QLatin1String
argument_list|(
literal|"NDATA"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws4
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|NNam
case|:
case|case
name|NNamR
case|:
name|parseName_useRef
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|PEDec
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Ws6
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|PENam
case|:
name|parseName_useRef
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws7
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|PEVal
case|:
case|case
name|PEValR
case|:
if|if
condition|(
operator|!
name|parseEntityValue
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|PEEID
case|:
case|case
name|PEEIDR
case|:
name|parseExternalID_allowPublicID
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseExternalID
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|WsE
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityDecl
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|EDDone
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Done
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a EntityValue [9] */
end_comment
begin_function
DECL|function|parseEntityValue
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityValue
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|Dq
init|=
literal|1
decl_stmt|;
comment|// EntityValue is double quoted
specifier|const
name|signed
name|char
name|DqC
init|=
literal|2
decl_stmt|;
comment|// signed character
specifier|const
name|signed
name|char
name|DqPER
init|=
literal|3
decl_stmt|;
comment|// PERefence
specifier|const
name|signed
name|char
name|DqRef
init|=
literal|4
decl_stmt|;
comment|// Reference
specifier|const
name|signed
name|char
name|Sq
init|=
literal|5
decl_stmt|;
comment|// EntityValue is double quoted
specifier|const
name|signed
name|char
name|SqC
init|=
literal|6
decl_stmt|;
comment|// signed character
specifier|const
name|signed
name|char
name|SqPER
init|=
literal|7
decl_stmt|;
comment|// PERefence
specifier|const
name|signed
name|char
name|SqRef
init|=
literal|8
decl_stmt|;
comment|// Reference
specifier|const
name|signed
name|char
name|Done
init|=
literal|9
decl_stmt|;
specifier|const
name|signed
name|char
name|InpDq
init|=
literal|0
decl_stmt|;
comment|// "
specifier|const
name|signed
name|char
name|InpSq
init|=
literal|1
decl_stmt|;
comment|// '
specifier|const
name|signed
name|char
name|InpAmp
init|=
literal|2
decl_stmt|;
comment|//&
specifier|const
name|signed
name|char
name|InpPer
init|=
literal|3
decl_stmt|;
comment|// %
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|4
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|9
index|]
index|[
literal|5
index|]
init|=
block|{
comment|/*  InpDq  InpSq  InpAmp  InpPer  InpUnknown */
block|{
name|Dq
block|,
name|Sq
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
name|Done
block|,
name|DqC
block|,
name|DqRef
block|,
name|DqPER
block|,
name|DqC
block|}
block|,
comment|// Dq
block|{
name|Done
block|,
name|DqC
block|,
name|DqRef
block|,
name|DqPER
block|,
name|DqC
block|}
block|,
comment|// DqC
block|{
name|Done
block|,
name|DqC
block|,
name|DqRef
block|,
name|DqPER
block|,
name|DqC
block|}
block|,
comment|// DqPER
block|{
name|Done
block|,
name|DqC
block|,
name|DqRef
block|,
name|DqPER
block|,
name|DqC
block|}
block|,
comment|// DqRef
block|{
name|SqC
block|,
name|Done
block|,
name|SqRef
block|,
name|SqPER
block|,
name|SqC
block|}
block|,
comment|// Sq
block|{
name|SqC
block|,
name|Done
block|,
name|SqRef
block|,
name|SqPER
block|,
name|SqC
block|}
block|,
comment|// SqC
block|{
name|SqC
block|,
name|Done
block|,
name|SqRef
block|,
name|SqPER
block|,
name|SqC
block|}
block|,
comment|// SqPER
block|{
name|SqC
block|,
name|Done
block|,
name|SqRef
block|,
name|SqPER
block|,
name|SqC
block|}
comment|// SqRef
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseEntityValue (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityValue
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_LETTEREXPECTED
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityValue
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpDq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpSq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpAmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpPer
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Dq
case|:
case|case
name|Sq
case|:
name|stringClear
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|DqC
case|:
case|case
name|SqC
case|:
name|stringAddC
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|DqPER
case|:
case|case
name|SqPER
case|:
name|parsePEReference_context
operator|=
name|InEntityValue
expr_stmt|;
if|if
condition|(
operator|!
name|parsePEReference
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityValue
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|DqRef
case|:
case|case
name|SqRef
case|:
name|parseReference_context
operator|=
name|InEntityValue
expr_stmt|;
if|if
condition|(
operator|!
name|parseReference
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseEntityValue
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Done
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a comment [15].    Precondition: the beginning '<!' of the comment is already read and the head   stands on the first '-' of '<!--'.    If this funktion was successful, the head-position is on the first   character after the comment. */
end_comment
begin_function
DECL|function|parseComment
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseComment
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|Dash1
init|=
literal|1
decl_stmt|;
comment|// the first dash was read
specifier|const
name|signed
name|char
name|Dash2
init|=
literal|2
decl_stmt|;
comment|// the second dash was read
specifier|const
name|signed
name|char
name|Com
init|=
literal|3
decl_stmt|;
comment|// read comment
specifier|const
name|signed
name|char
name|Com2
init|=
literal|4
decl_stmt|;
comment|// read comment (help state)
specifier|const
name|signed
name|char
name|ComE
init|=
literal|5
decl_stmt|;
comment|// finished reading comment
specifier|const
name|signed
name|char
name|Done
init|=
literal|6
decl_stmt|;
specifier|const
name|signed
name|char
name|InpDash
init|=
literal|0
decl_stmt|;
comment|// -
specifier|const
name|signed
name|char
name|InpGt
init|=
literal|1
decl_stmt|;
comment|//>
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|2
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|6
index|]
index|[
literal|3
index|]
init|=
block|{
comment|/*  InpDash  InpGt  InpUnknown */
block|{
name|Dash1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
name|Dash2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Dash1
block|{
name|Com2
block|,
name|Com
block|,
name|Com
block|}
block|,
comment|// Dash2
block|{
name|Com2
block|,
name|Com
block|,
name|Com
block|}
block|,
comment|// Com
block|{
name|ComE
block|,
name|Com
block|,
name|Com
block|}
block|,
comment|// Com2
block|{
operator|-
literal|1
block|,
name|Done
block|,
operator|-
literal|1
block|}
comment|// ComE
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseComment (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseComment
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Dash2
case|:
name|stringClear
argument_list|()
expr_stmt|;
break|break;
case|case
name|Com2
case|:
comment|// if next character is not a dash than don't skip it
if|if
condition|(
operator|!
name|atEnd
argument_list|()
operator|&&
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
condition|)
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_ERRORPARSINGCOMMENT
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseComment
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpDash
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpGt
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Dash1
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Dash2
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Com
case|:
name|stringAddC
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Com2
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|ComE
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Done
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*     Parse an Attribute [41].      Precondition: the head stands on the first character of the name     of the attribute (i.e. all whitespaces are already parsed).      The head stand on the next character after the end quotes. The     variable name contains the name of the attribute and the variable     string contains the value of the attribute. */
end_comment
begin_function
DECL|function|parseAttribute
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttribute
parameter_list|()
block|{
specifier|const
name|int
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|PName
init|=
literal|1
decl_stmt|;
comment|// parse name
specifier|const
name|int
name|Ws
init|=
literal|2
decl_stmt|;
comment|// eat ws
specifier|const
name|int
name|Eq
init|=
literal|3
decl_stmt|;
comment|// the '=' was read
specifier|const
name|int
name|Quotes
init|=
literal|4
decl_stmt|;
comment|// " or ' were read
specifier|const
name|int
name|InpNameBe
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|InpEq
init|=
literal|1
decl_stmt|;
comment|// =
specifier|const
name|int
name|InpDq
init|=
literal|2
decl_stmt|;
comment|// "
specifier|const
name|int
name|InpSq
init|=
literal|3
decl_stmt|;
comment|// '
specifier|const
name|int
name|InpUnknown
init|=
literal|4
decl_stmt|;
specifier|static
specifier|const
name|int
name|table
index|[
literal|4
index|]
index|[
literal|5
index|]
init|=
block|{
comment|/*  InpNameBe  InpEq  InpDq    InpSq    InpUnknown */
block|{
name|PName
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
operator|-
literal|1
block|,
name|Eq
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Ws
block|}
block|,
comment|// PName
block|{
operator|-
literal|1
block|,
name|Eq
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Ws
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Quotes
block|,
name|Quotes
block|,
operator|-
literal|1
block|}
comment|// Eq
block|}
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseAttribute (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttribute
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Quotes
case|:
comment|// Done
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNEXPECTEDCHARACTER
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttribute
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|determineNameChar
argument_list|(
name|c
argument_list|)
operator|==
name|NameBeginning
condition|)
block|{
name|input
operator|=
name|InpNameBe
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpEq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpDq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
condition|)
block|{
name|input
operator|=
name|InpSq
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|PName
case|:
name|parseName_useRef
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttribute
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Ws
case|:
if|if
condition|(
operator|!
name|eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttribute
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Eq
case|:
if|if
condition|(
operator|!
name|next_eat_ws
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttribute
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|Quotes
case|:
if|if
condition|(
operator|!
name|parseAttValue
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseAttribute
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a Name [5] and store the name in name or ref (if useRef is true). */
end_comment
begin_function
DECL|function|parseName
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseName
parameter_list|()
block|{
specifier|const
name|int
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|Name1
init|=
literal|1
decl_stmt|;
comment|// parse first character of the name
specifier|const
name|int
name|Name
init|=
literal|2
decl_stmt|;
comment|// parse name
specifier|const
name|int
name|Done
init|=
literal|3
decl_stmt|;
specifier|static
specifier|const
name|int
name|table
index|[
literal|3
index|]
index|[
literal|3
index|]
init|=
block|{
comment|/*  InpNameBe  InpNameCh  InpUnknown */
block|{
name|Name1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
name|Name
block|,
name|Name
block|,
name|Done
block|}
block|,
comment|// Name1
block|{
name|Name
block|,
name|Name
block|,
name|Done
block|}
comment|// Name
block|}
decl_stmt|;
name|int
name|state
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseName (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseName
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_LETTEREXPECTED
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseName
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// we can safely do the (int) cast thanks to the Q_ASSERTs earlier in this function
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
operator|(
name|int
operator|)
name|fastDetermineNameChar
argument_list|(
name|c
argument_list|)
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Name1
case|:
if|if
condition|(
name|parseName_useRef
condition|)
block|{
name|refClear
argument_list|()
expr_stmt|;
name|refAddC
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|nameClear
argument_list|()
expr_stmt|;
name|nameAddC
argument_list|()
expr_stmt|;
block|}
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Name
case|:
if|if
condition|(
name|parseName_useRef
condition|)
block|{
name|refAddC
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|nameAddC
argument_list|()
expr_stmt|;
block|}
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a Nmtoken [7] and store the name in name. */
end_comment
begin_function
DECL|function|parseNmtoken
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseNmtoken
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|NameF
init|=
literal|1
decl_stmt|;
specifier|const
name|signed
name|char
name|Name
init|=
literal|2
decl_stmt|;
specifier|const
name|signed
name|char
name|Done
init|=
literal|3
decl_stmt|;
specifier|const
name|signed
name|char
name|InpNameCh
init|=
literal|0
decl_stmt|;
comment|// NameChar without InpNameBe
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|1
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|3
index|]
index|[
literal|2
index|]
init|=
block|{
comment|/*  InpNameCh  InpUnknown */
block|{
name|NameF
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
name|Name
block|,
name|Done
block|}
block|,
comment|// NameF
block|{
name|Name
block|,
name|Done
block|}
comment|// Name
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseNmtoken (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseNmtoken
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Done
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_LETTEREXPECTED
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseNmtoken
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|determineNameChar
argument_list|(
name|c
argument_list|)
operator|==
name|NotName
condition|)
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpNameCh
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|NameF
case|:
name|nameClear
argument_list|()
expr_stmt|;
name|nameAddC
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Name
case|:
name|nameAddC
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Parse a Reference [67].    parseReference_charDataRead is set to true if the reference must not be   parsed. The character(s) which the reference mapped to are appended to   string. The head stands on the first character after the reference.    parseReference_charDataRead is set to false if the reference must be parsed.   The charachter(s) which the reference mapped to are inserted at the reference   position. The head stands on the first character of the replacement). */
end_comment
begin_function
DECL|function|parseReference
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseReference
parameter_list|()
block|{
comment|// temporary variables (only used in very local context, so they don't
comment|// interfere with incremental parsing)
name|uint
name|tmp
decl_stmt|;
name|bool
name|ok
decl_stmt|;
specifier|const
name|signed
name|char
name|Init
init|=
literal|0
decl_stmt|;
specifier|const
name|signed
name|char
name|SRef
init|=
literal|1
decl_stmt|;
comment|// start of a reference
specifier|const
name|signed
name|char
name|ChRef
init|=
literal|2
decl_stmt|;
comment|// parse CharRef
specifier|const
name|signed
name|char
name|ChDec
init|=
literal|3
decl_stmt|;
comment|// parse CharRef decimal
specifier|const
name|signed
name|char
name|ChHexS
init|=
literal|4
decl_stmt|;
comment|// start CharRef hexadecimal
specifier|const
name|signed
name|char
name|ChHex
init|=
literal|5
decl_stmt|;
comment|// parse CharRef hexadecimal
specifier|const
name|signed
name|char
name|Name
init|=
literal|6
decl_stmt|;
comment|// parse name
specifier|const
name|signed
name|char
name|DoneD
init|=
literal|7
decl_stmt|;
comment|// done CharRef decimal
specifier|const
name|signed
name|char
name|DoneH
init|=
literal|8
decl_stmt|;
comment|// done CharRef hexadecimal
specifier|const
name|signed
name|char
name|DoneN
init|=
literal|9
decl_stmt|;
comment|// done EntityRef
specifier|const
name|signed
name|char
name|InpAmp
init|=
literal|0
decl_stmt|;
comment|//&
specifier|const
name|signed
name|char
name|InpSemi
init|=
literal|1
decl_stmt|;
comment|// ;
specifier|const
name|signed
name|char
name|InpHash
init|=
literal|2
decl_stmt|;
comment|// #
specifier|const
name|signed
name|char
name|InpX
init|=
literal|3
decl_stmt|;
comment|// x
specifier|const
name|signed
name|char
name|InpNum
init|=
literal|4
decl_stmt|;
comment|// 0-9
specifier|const
name|signed
name|char
name|InpHex
init|=
literal|5
decl_stmt|;
comment|// a-f A-F
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|6
decl_stmt|;
specifier|static
specifier|const
name|signed
name|char
name|table
index|[
literal|8
index|]
index|[
literal|7
index|]
init|=
block|{
comment|/*  InpAmp  InpSemi  InpHash  InpX     InpNum  InpHex  InpUnknown */
block|{
name|SRef
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// Init
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ChRef
block|,
name|Name
block|,
name|Name
block|,
name|Name
block|,
name|Name
block|}
block|,
comment|// SRef
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ChHexS
block|,
name|ChDec
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// ChRef
block|{
operator|-
literal|1
block|,
name|DoneD
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ChDec
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|// ChDec
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ChHex
block|,
name|ChHex
block|,
operator|-
literal|1
block|}
block|,
comment|// ChHexS
block|{
operator|-
literal|1
block|,
name|DoneH
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|ChHex
block|,
name|ChHex
block|,
operator|-
literal|1
block|}
block|,
comment|// ChHex
block|{
operator|-
literal|1
block|,
name|DoneN
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
comment|// Name
block|}
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|parseReference_charDataRead
operator|=
literal|false
expr_stmt|;
name|state
operator|=
name|Init
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseReference (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseReference
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|DoneD
case|:
return|return
literal|true
return|;
case|case
name|DoneH
case|:
return|return
literal|true
return|;
case|case
name|DoneN
case|:
return|return
literal|true
return|;
case|case
operator|-
literal|1
case|:
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_ERRORPARSINGREFERENCE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseReference
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|c
operator|.
name|row
argument_list|()
condition|)
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|cell
argument_list|()
operator|==
literal|'&'
condition|)
block|{
name|input
operator|=
name|InpAmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|cell
argument_list|()
operator|==
literal|';'
condition|)
block|{
name|input
operator|=
name|InpSemi
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|cell
argument_list|()
operator|==
literal|'#'
condition|)
block|{
name|input
operator|=
name|InpHash
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|cell
argument_list|()
operator|==
literal|'x'
condition|)
block|{
name|input
operator|=
name|InpX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|'0'
operator|<=
name|c
operator|.
name|cell
argument_list|()
operator|&&
name|c
operator|.
name|cell
argument_list|()
operator|<=
literal|'9'
condition|)
block|{
name|input
operator|=
name|InpNum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|'a'
operator|<=
name|c
operator|.
name|cell
argument_list|()
operator|&&
name|c
operator|.
name|cell
argument_list|()
operator|<=
literal|'f'
condition|)
block|{
name|input
operator|=
name|InpHex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|'A'
operator|<=
name|c
operator|.
name|cell
argument_list|()
operator|&&
name|c
operator|.
name|cell
argument_list|()
operator|<=
literal|'F'
condition|)
block|{
name|input
operator|=
name|InpHex
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
name|state
operator|=
name|table
index|[
name|state
index|]
index|[
name|input
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SRef
case|:
name|refClear
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|ChRef
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|ChDec
case|:
name|refAddC
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|ChHexS
case|:
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|ChHex
case|:
name|refAddC
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|Name
case|:
comment|// read the name into the ref
name|parseName_useRef
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|parseName
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseReference
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|DoneD
case|:
name|tmp
operator|=
name|ref
argument_list|()
operator|.
name|toUInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|stringAddC
argument_list|(
name|QChar
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_ERRORPARSINGREFERENCE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|parseReference_charDataRead
operator|=
literal|true
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|DoneH
case|:
name|tmp
operator|=
name|ref
argument_list|()
operator|.
name|toUInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|stringAddC
argument_list|(
name|QChar
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_ERRORPARSINGREFERENCE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|parseReference_charDataRead
operator|=
literal|true
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
break|break;
case|case
name|DoneN
case|:
if|if
condition|(
operator|!
name|processReference
argument_list|()
condition|)
return|return
literal|false
return|;
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   Helper function for parseReference() */
end_comment
begin_function
DECL|function|processReference
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|processReference
parameter_list|()
block|{
name|QString
name|reference
init|=
name|ref
argument_list|()
decl_stmt|;
if|if
condition|(
name|reference
operator|==
name|QLatin1String
argument_list|(
literal|"amp"
argument_list|)
condition|)
block|{
if|if
condition|(
name|parseReference_context
operator|==
name|InEntityValue
condition|)
block|{
comment|// Bypassed
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'a'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'m'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'p'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Included or Included in literal
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parseReference_charDataRead
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reference
operator|==
name|QLatin1String
argument_list|(
literal|"lt"
argument_list|)
condition|)
block|{
if|if
condition|(
name|parseReference_context
operator|==
name|InEntityValue
condition|)
block|{
comment|// Bypassed
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'l'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'t'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Included or Included in literal
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parseReference_charDataRead
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reference
operator|==
name|QLatin1String
argument_list|(
literal|"gt"
argument_list|)
condition|)
block|{
if|if
condition|(
name|parseReference_context
operator|==
name|InEntityValue
condition|)
block|{
comment|// Bypassed
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'g'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'t'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Included or Included in literal
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parseReference_charDataRead
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reference
operator|==
name|QLatin1String
argument_list|(
literal|"apos"
argument_list|)
condition|)
block|{
if|if
condition|(
name|parseReference_context
operator|==
name|InEntityValue
condition|)
block|{
comment|// Bypassed
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'a'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'p'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'o'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'s'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Included or Included in literal
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parseReference_charDataRead
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reference
operator|==
name|QLatin1String
argument_list|(
literal|"quot"
argument_list|)
condition|)
block|{
if|if
condition|(
name|parseReference_context
operator|==
name|InEntityValue
condition|)
block|{
comment|// Bypassed
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'q'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'u'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'o'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'t'
argument_list|)
argument_list|)
expr_stmt|;
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Included or Included in literal
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parseReference_charDataRead
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
operator|::
name|Iterator
name|it
decl_stmt|;
name|it
operator|=
name|entities
operator|.
name|find
argument_list|(
name|reference
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|entities
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// "Internal General"
switch|switch
condition|(
name|parseReference_context
condition|)
block|{
case|case
name|InContent
case|:
comment|// Included
if|if
condition|(
operator|!
name|insertXmlRef
argument_list|(
operator|*
name|it
argument_list|,
name|reference
argument_list|,
literal|false
argument_list|)
condition|)
return|return
literal|false
return|;
name|parseReference_charDataRead
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|InAttributeValue
case|:
comment|// Included in literal
if|if
condition|(
operator|!
name|insertXmlRef
argument_list|(
operator|*
name|it
argument_list|,
name|reference
argument_list|,
literal|true
argument_list|)
condition|)
return|return
literal|false
return|;
name|parseReference_charDataRead
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|InEntityValue
case|:
block|{
comment|// Bypassed
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|reference
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|stringAddC
argument_list|(
name|reference
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
expr_stmt|;
name|parseReference_charDataRead
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|InDTD
case|:
comment|// Forbidden
name|parseReference_charDataRead
operator|=
literal|false
expr_stmt|;
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_INTERNALGENERALENTITYINDTD
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|QXmlSimpleReaderPrivate
operator|::
name|ExternEntity
argument_list|>
operator|::
name|Iterator
name|itExtern
decl_stmt|;
name|itExtern
operator|=
name|externEntities
operator|.
name|find
argument_list|(
name|reference
argument_list|)
expr_stmt|;
if|if
condition|(
name|itExtern
operator|==
name|externEntities
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// entity not declared
comment|// ### check this case for conformance
if|if
condition|(
name|parseReference_context
operator|==
name|InEntityValue
condition|)
block|{
comment|// Bypassed
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|reference
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|stringAddC
argument_list|(
name|reference
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
expr_stmt|;
name|parseReference_charDataRead
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// if we have some char data read, report it now
if|if
condition|(
name|parseReference_context
operator|==
name|InContent
condition|)
block|{
if|if
condition|(
name|contentCharDataRead
condition|)
block|{
if|if
condition|(
name|reportWhitespaceCharData
operator|||
operator|!
name|string
argument_list|()
operator|.
name|simplified
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|contentHnd
operator|!=
literal|0
operator|&&
operator|!
name|contentHnd
operator|->
name|characters
argument_list|(
name|string
argument_list|()
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|stringClear
argument_list|()
expr_stmt|;
name|contentCharDataRead
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contentHnd
condition|)
block|{
name|qt_xml_skipped_entity_in_content
operator|=
name|parseReference_context
operator|==
name|InContent
expr_stmt|;
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|skippedEntity
argument_list|(
name|reference
argument_list|)
condition|)
block|{
name|qt_xml_skipped_entity_in_content
operator|=
literal|false
expr_stmt|;
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// error
block|}
name|qt_xml_skipped_entity_in_content
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|itExtern
operator|)
operator|.
name|notation
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// "External Parsed General"
switch|switch
condition|(
name|parseReference_context
condition|)
block|{
case|case
name|InContent
case|:
block|{
comment|// Included if validating
name|bool
name|skipIt
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|entityRes
condition|)
block|{
name|QXmlInputSource
modifier|*
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|entityRes
operator|->
name|resolveEntity
argument_list|(
operator|(
operator|*
name|itExtern
operator|)
operator|.
name|publicId
argument_list|,
operator|(
operator|*
name|itExtern
operator|)
operator|.
name|systemId
argument_list|,
name|ret
argument_list|)
condition|)
block|{
operator|delete
name|ret
expr_stmt|;
name|reportParseError
argument_list|(
name|entityRes
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
name|QString
name|xmlRefString
init|=
name|ret
operator|->
name|data
argument_list|()
decl_stmt|;
operator|delete
name|ret
expr_stmt|;
if|if
condition|(
operator|!
name|stripTextDecl
argument_list|(
name|xmlRefString
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_ERRORINTEXTDECL
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|insertXmlRef
argument_list|(
name|xmlRefString
argument_list|,
name|reference
argument_list|,
literal|false
argument_list|)
condition|)
return|return
literal|false
return|;
name|skipIt
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|skipIt
operator|&&
name|contentHnd
condition|)
block|{
name|qt_xml_skipped_entity_in_content
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|contentHnd
operator|->
name|skippedEntity
argument_list|(
name|reference
argument_list|)
condition|)
block|{
name|qt_xml_skipped_entity_in_content
operator|=
literal|false
expr_stmt|;
name|reportParseError
argument_list|(
name|contentHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// error
block|}
name|qt_xml_skipped_entity_in_content
operator|=
literal|false
expr_stmt|;
block|}
name|parseReference_charDataRead
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|InAttributeValue
case|:
comment|// Forbidden
name|parseReference_charDataRead
operator|=
literal|false
expr_stmt|;
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_EXTERNALGENERALENTITYINAV
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
case|case
name|InEntityValue
case|:
block|{
comment|// Bypassed
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|reference
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|stringAddC
argument_list|(
name|reference
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|stringAddC
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
expr_stmt|;
name|parseReference_charDataRead
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|InDTD
case|:
comment|// Forbidden
name|parseReference_charDataRead
operator|=
literal|false
expr_stmt|;
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_EXTERNALGENERALENTITYINDTD
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
comment|// "Unparsed"
comment|// ### notify for "Occurs as Attribute Value" missing (but this is no refence, anyway)
comment|// Forbidden
name|parseReference_charDataRead
operator|=
literal|false
expr_stmt|;
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNPARSEDENTITYREFERENCE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// error
block|}
block|}
block|}
return|return
literal|true
return|;
comment|// no error
block|}
end_function
begin_comment
comment|/*   Parses over a simple string.    After the string was successfully parsed, the head is on the first   character after the string. */
end_comment
begin_function
DECL|function|parseString
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|parseString
parameter_list|()
block|{
specifier|const
name|signed
name|char
name|InpCharExpected
init|=
literal|0
decl_stmt|;
comment|// the character that was expected
specifier|const
name|signed
name|char
name|InpUnknown
init|=
literal|1
decl_stmt|;
name|signed
name|char
name|state
decl_stmt|;
comment|// state in this function is the position in the string s
name|signed
name|char
name|input
decl_stmt|;
if|if
condition|(
name|parseStack
operator|==
literal|0
operator|||
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|Done
operator|=
name|parseString_s
operator|.
name|length
argument_list|()
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|parseStack
operator|->
name|pop
argument_list|()
operator|.
name|state
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: parseString (cont) in state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|parseStack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|ParseFunction
name|function
init|=
name|parseStack
operator|->
name|top
argument_list|()
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
operator|==
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
condition|)
block|{
name|parseStack
operator|->
name|pop
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_QXML_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QXmlSimpleReader: eat_ws (cont)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
call|(
name|this
operator|->*
name|function
call|)
argument_list|()
condition|)
block|{
name|parseFailed
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseString
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|state
operator|==
name|Done
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|parseString
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|c
operator|==
name|parseString_s
index|[
operator|(
name|int
operator|)
name|state
index|]
condition|)
block|{
name|input
operator|=
name|InpCharExpected
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|InpUnknown
expr_stmt|;
block|}
if|if
condition|(
name|input
operator|==
name|InpCharExpected
condition|)
block|{
name|state
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// Error
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNEXPECTEDCHARACTER
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|next
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*   This private function inserts and reports an entity substitution. The   substituted string is \a data and the name of the entity reference is \a   name. If \a inLiteral is true, the entity is IncludedInLiteral (i.e., " and '   must be quoted. Otherwise they are not quoted.    This function returns false on error. */
end_comment
begin_function
DECL|function|insertXmlRef
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|insertXmlRef
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|inLiteral
parameter_list|)
block|{
if|if
condition|(
name|inLiteral
condition|)
block|{
name|QString
name|tmp
init|=
name|data
decl_stmt|;
name|xmlRefStack
operator|.
name|push
argument_list|(
name|XmlRef
argument_list|(
name|name
argument_list|,
name|tmp
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"&quot;"
argument_list|)
argument_list|)
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"&apos;"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xmlRefStack
operator|.
name|push
argument_list|(
name|XmlRef
argument_list|(
name|name
argument_list|,
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|n
init|=
name|qMax
argument_list|(
name|parameterEntities
operator|.
name|count
argument_list|()
argument_list|,
name|entities
operator|.
name|count
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|xmlRefStack
operator|.
name|count
argument_list|()
operator|>
name|n
operator|+
literal|1
condition|)
block|{
comment|// recursive entities
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_RECURSIVEENTITIES
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|reportEntities
operator|&&
name|lexicalHnd
condition|)
block|{
if|if
condition|(
operator|!
name|lexicalHnd
operator|->
name|startEntity
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|reportParseError
argument_list|(
name|lexicalHnd
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*   This private function moves the cursor to the next character. */
end_comment
begin_function
DECL|function|next
name|void
name|QXmlSimpleReaderPrivate
operator|::
name|next
parameter_list|()
block|{
name|int
name|count
init|=
name|xmlRefStack
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|xmlRefStack
operator|.
name|top
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|xmlRefStack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|xmlRefStack
operator|.
name|top
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|// the following could be written nicer, but since it is a time-critical
comment|// function, rather optimize for speed
name|ushort
name|uc
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|c
operator|=
name|inputSource
operator|->
name|next
argument_list|()
expr_stmt|;
comment|// If we are not incremental parsing, we just skip over EndOfData chars to give the
comment|// parser an uninterrupted stream of document chars.
if|if
condition|(
name|c
operator|==
name|QXmlInputSource
operator|::
name|EndOfData
operator|&&
name|parseStack
operator|==
literal|0
condition|)
name|c
operator|=
name|inputSource
operator|->
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|uc
operator|==
literal|'\n'
condition|)
block|{
name|lineNr
operator|++
expr_stmt|;
name|columnNr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uc
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
condition|)
block|{
name|lineNr
operator|++
expr_stmt|;
name|columnNr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
operator|++
name|columnNr
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   This private function moves the cursor to the next non-whitespace character.   This function does not move the cursor if the actual cursor position is a   non-whitespace charcter.    Returns false when you use incremental parsing and this function reaches EOF   with reading only whitespace characters. In this case it also poplulates the   parseStack with useful information. In all other cases, this function returns   true. */
end_comment
begin_function
DECL|function|eat_ws
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
parameter_list|()
block|{
while|while
condition|(
operator|!
name|atEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|is_S
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|parseStack
operator|!=
literal|0
condition|)
block|{
name|unexpectedEof
argument_list|(
operator|&
name|QXmlSimpleReaderPrivate
operator|::
name|eat_ws
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|next_eat_ws
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|next_eat_ws
parameter_list|()
block|{
name|next
argument_list|()
expr_stmt|;
return|return
name|eat_ws
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*   This private function initializes the reader. \a i is the input source to   read the data from. */
end_comment
begin_function
DECL|function|init
name|void
name|QXmlSimpleReaderPrivate
operator|::
name|init
parameter_list|(
specifier|const
name|QXmlInputSource
modifier|*
name|i
parameter_list|)
block|{
name|lineNr
operator|=
literal|0
expr_stmt|;
name|columnNr
operator|=
operator|-
literal|1
expr_stmt|;
name|inputSource
operator|=
cast|const_cast
argument_list|<
name|QXmlInputSource
operator|*
argument_list|>
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|initData
argument_list|()
expr_stmt|;
name|externParameterEntities
operator|.
name|clear
argument_list|()
expr_stmt|;
name|parameterEntities
operator|.
name|clear
argument_list|()
expr_stmt|;
name|externEntities
operator|.
name|clear
argument_list|()
expr_stmt|;
name|entities
operator|.
name|clear
argument_list|()
expr_stmt|;
name|tags
operator|.
name|clear
argument_list|()
expr_stmt|;
name|doctype
operator|.
name|clear
argument_list|()
expr_stmt|;
name|xmlVersion
operator|.
name|clear
argument_list|()
expr_stmt|;
name|encoding
operator|.
name|clear
argument_list|()
expr_stmt|;
name|standalone
operator|=
name|QXmlSimpleReaderPrivate
operator|::
name|Unknown
expr_stmt|;
name|error
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   This private function initializes the XML data related variables. Especially,   it reads the data from the input source. */
end_comment
begin_function
DECL|function|initData
name|void
name|QXmlSimpleReaderPrivate
operator|::
name|initData
parameter_list|()
block|{
name|c
operator|=
name|QXmlInputSource
operator|::
name|EndOfData
expr_stmt|;
name|xmlRefStack
operator|.
name|clear
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   Returns true if a entity with the name \a e exists,   otherwise returns false. */
end_comment
begin_function
DECL|function|entityExist
name|bool
name|QXmlSimpleReaderPrivate
operator|::
name|entityExist
parameter_list|(
specifier|const
name|QString
modifier|&
name|e
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|parameterEntities
operator|.
name|find
argument_list|(
name|e
argument_list|)
operator|==
name|parameterEntities
operator|.
name|end
argument_list|()
operator|&&
name|externParameterEntities
operator|.
name|find
argument_list|(
name|e
argument_list|)
operator|==
name|externParameterEntities
operator|.
name|end
argument_list|()
operator|&&
name|externEntities
operator|.
name|find
argument_list|(
name|e
argument_list|)
operator|==
name|externEntities
operator|.
name|end
argument_list|()
operator|&&
name|entities
operator|.
name|find
argument_list|(
name|e
argument_list|)
operator|==
name|entities
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
end_function
begin_function
DECL|function|reportParseError
name|void
name|QXmlSimpleReaderPrivate
operator|::
name|reportParseError
parameter_list|(
specifier|const
name|QString
modifier|&
name|error
parameter_list|)
block|{
name|this
operator|->
name|error
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|errorHnd
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|error
operator|.
name|isNull
argument_list|()
condition|)
block|{
specifier|const
name|QXmlParseException
name|ex
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_OK
argument_list|)
argument_list|,
name|columnNr
operator|+
literal|1
argument_list|,
name|lineNr
operator|+
literal|1
argument_list|,
name|thisPublicId
argument_list|,
name|thisSystemId
argument_list|)
decl_stmt|;
name|errorHnd
operator|->
name|fatalError
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QXmlParseException
name|ex
argument_list|(
name|this
operator|->
name|error
argument_list|,
name|columnNr
operator|+
literal|1
argument_list|,
name|lineNr
operator|+
literal|1
argument_list|,
name|thisPublicId
argument_list|,
name|thisSystemId
argument_list|)
decl_stmt|;
name|errorHnd
operator|->
name|fatalError
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*   This private function is called when a parsing function encounters an   unexpected EOF. It decides what to do (depending on incremental parsing or   not). \a where is a pointer to the function where the error occurred and \a   state is the parsing state in this function. */
end_comment
begin_function
DECL|function|unexpectedEof
name|void
name|QXmlSimpleReaderPrivate
operator|::
name|unexpectedEof
parameter_list|(
name|ParseFunction
name|where
parameter_list|,
name|int
name|state
parameter_list|)
block|{
if|if
condition|(
name|parseStack
operator|==
literal|0
condition|)
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNEXPECTEDEOF
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
name|QXmlInputSource
operator|::
name|EndOfDocument
condition|)
block|{
name|reportParseError
argument_list|(
name|QLatin1String
argument_list|(
name|XMLERR_UNEXPECTEDEOF
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pushParseState
argument_list|(
name|where
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*   This private function is called when a parse...() function returned false. It   determines if there was an error or if incremental parsing simply went out of   data and does the right thing for the case. \a where is a pointer to the   function where the error occurred and \a state is the parsing state in this   function. */
end_comment
begin_function
DECL|function|parseFailed
name|void
name|QXmlSimpleReaderPrivate
operator|::
name|parseFailed
parameter_list|(
name|ParseFunction
name|where
parameter_list|,
name|int
name|state
parameter_list|)
block|{
if|if
condition|(
name|parseStack
operator|!=
literal|0
operator|&&
name|error
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|pushParseState
argument_list|(
name|where
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*   This private function pushes the function pointer \a function and state \a   state to the parse stack. This is used when you are doing an incremental   parsing and reach the end of file too early.    Only call this function when d->parseStack!=0. */
end_comment
begin_function
DECL|function|pushParseState
name|void
name|QXmlSimpleReaderPrivate
operator|::
name|pushParseState
parameter_list|(
name|ParseFunction
name|function
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|QXmlSimpleReaderPrivate
operator|::
name|ParseState
name|ps
decl_stmt|;
name|ps
operator|.
name|function
operator|=
name|function
expr_stmt|;
name|ps
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|parseStack
operator|->
name|push
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateValue
specifier|inline
specifier|static
name|void
name|updateValue
parameter_list|(
name|QString
modifier|&
name|value
parameter_list|,
specifier|const
name|QChar
modifier|*
name|array
parameter_list|,
name|int
modifier|&
name|arrayPos
parameter_list|,
name|int
modifier|&
name|valueLen
parameter_list|)
block|{
name|value
operator|.
name|resize
argument_list|(
name|valueLen
operator|+
name|arrayPos
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|value
operator|.
name|data
argument_list|()
operator|+
name|valueLen
argument_list|,
name|array
argument_list|,
name|arrayPos
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|valueLen
operator|+=
name|arrayPos
expr_stmt|;
name|arrayPos
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|// use buffers instead of QString::operator+= when single characters are read
end_comment
begin_function
DECL|function|string
specifier|const
name|QString
modifier|&
name|QXmlSimpleReaderPrivate
operator|::
name|string
parameter_list|()
block|{
name|updateValue
argument_list|(
name|stringValue
argument_list|,
name|stringArray
argument_list|,
name|stringArrayPos
argument_list|,
name|stringValueLen
argument_list|)
expr_stmt|;
return|return
name|stringValue
return|;
block|}
end_function
begin_function
DECL|function|name
specifier|const
name|QString
modifier|&
name|QXmlSimpleReaderPrivate
operator|::
name|name
parameter_list|()
block|{
name|updateValue
argument_list|(
name|nameValue
argument_list|,
name|nameArray
argument_list|,
name|nameArrayPos
argument_list|,
name|nameValueLen
argument_list|)
expr_stmt|;
return|return
name|nameValue
return|;
block|}
end_function
begin_function
DECL|function|ref
specifier|const
name|QString
modifier|&
name|QXmlSimpleReaderPrivate
operator|::
name|ref
parameter_list|()
block|{
name|updateValue
argument_list|(
name|refValue
argument_list|,
name|refArray
argument_list|,
name|refArrayPos
argument_list|,
name|refValueLen
argument_list|)
expr_stmt|;
return|return
name|refValue
return|;
block|}
end_function
begin_function
DECL|function|stringAddC
name|void
name|QXmlSimpleReaderPrivate
operator|::
name|stringAddC
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
if|if
condition|(
name|stringArrayPos
operator|==
literal|256
condition|)
name|updateValue
argument_list|(
name|stringValue
argument_list|,
name|stringArray
argument_list|,
name|stringArrayPos
argument_list|,
name|stringValueLen
argument_list|)
expr_stmt|;
name|stringArray
index|[
name|stringArrayPos
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
end_function
begin_function
DECL|function|nameAddC
name|void
name|QXmlSimpleReaderPrivate
operator|::
name|nameAddC
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
if|if
condition|(
name|nameArrayPos
operator|==
literal|256
condition|)
name|updateValue
argument_list|(
name|nameValue
argument_list|,
name|nameArray
argument_list|,
name|nameArrayPos
argument_list|,
name|nameValueLen
argument_list|)
expr_stmt|;
name|nameArray
index|[
name|nameArrayPos
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
end_function
begin_function
DECL|function|refAddC
name|void
name|QXmlSimpleReaderPrivate
operator|::
name|refAddC
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
if|if
condition|(
name|refArrayPos
operator|==
literal|256
condition|)
name|updateValue
argument_list|(
name|refValue
argument_list|,
name|refArray
argument_list|,
name|refArrayPos
argument_list|,
name|refValueLen
argument_list|)
expr_stmt|;
name|refArray
index|[
name|refArrayPos
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
