begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtOpenGL module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qgl.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qglfunctions.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_comment
comment|// malloc
end_comment
begin_include
include|#
directive|include
file|"qpixmap.h"
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qgl_p.h"
end_include
begin_include
include|#
directive|include
file|"gl2paintengineex/qpaintengineex_opengl2_p.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformopenglcontext.h>
end_include
begin_include
include|#
directive|include
file|<qglpixelbuffer.h>
end_include
begin_include
include|#
directive|include
file|<qglframebufferobject.h>
end_include
begin_include
include|#
directive|include
file|<private/qopenglextensions_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qimage_p.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformpixmap.h>
end_include
begin_include
include|#
directive|include
file|<private/qglpixelbuffer_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qimagepixmapcleanuphooks_p.h>
end_include
begin_include
include|#
directive|include
file|"qcolormap.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qlibrary.h"
end_include
begin_include
include|#
directive|include
file|<qmutex.h>
end_include
begin_comment
comment|// #define QT_GL_CONTEXT_RESOURCE_DEBUG
end_comment
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QGLDefaultExtensions
class|class
name|QGLDefaultExtensions
block|{
public|public:
DECL|function|QGLDefaultExtensions
name|QGLDefaultExtensions
parameter_list|()
member_init_list|:
name|extensions
argument_list|(
literal|0
argument_list|)
block|{
name|QGLTemporaryContext
name|tempContext
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
expr_stmt|;
name|QOpenGLExtensions
modifier|*
name|ext
init|=
name|qgl_extensions
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|extensions
operator|=
name|ext
operator|->
name|openGLExtensions
argument_list|()
expr_stmt|;
name|features
operator|=
name|ext
operator|->
name|openGLFeatures
argument_list|()
expr_stmt|;
block|}
DECL|member|features
name|QOpenGLFunctions
operator|::
name|OpenGLFeatures
name|features
decl_stmt|;
DECL|member|extensions
name|QOpenGLExtensions
operator|::
name|OpenGLExtensions
name|extensions
decl_stmt|;
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QGLDefaultExtensions
argument_list|,
argument|qtDefaultExtensions
argument_list|)
end_macro
begin_function
DECL|function|qgl_hasFeature
name|bool
name|qgl_hasFeature
parameter_list|(
name|QOpenGLFunctions
operator|::
name|OpenGLFeature
name|feature
parameter_list|)
block|{
if|if
condition|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
condition|)
return|return
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|functions
argument_list|()
operator|->
name|hasOpenGLFeature
argument_list|(
name|feature
argument_list|)
return|;
return|return
name|qtDefaultExtensions
argument_list|()
operator|->
name|features
operator|&
name|feature
return|;
block|}
end_function
begin_function
DECL|function|qgl_hasExtension
name|bool
name|qgl_hasExtension
parameter_list|(
name|QOpenGLExtensions
operator|::
name|OpenGLExtension
name|extension
parameter_list|)
block|{
if|if
condition|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
condition|)
return|return
name|qgl_extensions
argument_list|()
operator|->
name|hasOpenGLExtension
argument_list|(
name|extension
argument_list|)
return|;
return|return
name|qtDefaultExtensions
argument_list|()
operator|->
name|extensions
operator|&
name|extension
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|extensions
name|QOpenGLExtensions
operator|::
name|OpenGLExtensions
name|extensions
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*     Returns the GL extensions for the current QOpenGLContext. If there is no     current QOpenGLContext, a default context will be created and the extensions     for that context will be returned instead. */
end_comment
begin_function
DECL|function|qgl_extensions
name|QOpenGLExtensions
modifier|*
name|qgl_extensions
parameter_list|()
block|{
if|if
condition|(
name|QOpenGLContext
modifier|*
name|context
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
condition|)
return|return
cast|static_cast
argument_list|<
name|QOpenGLExtensions
operator|*
argument_list|>
argument_list|(
name|context
operator|->
name|functions
argument_list|()
argument_list|)
return|;
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_struct
DECL|struct|QGLThreadContext
struct|struct
name|QGLThreadContext
block|{
DECL|function|~QGLThreadContext
name|~
name|QGLThreadContext
parameter_list|()
block|{
if|if
condition|(
name|context
condition|)
name|context
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
block|}
DECL|member|context
name|QGLContext
modifier|*
name|context
decl_stmt|;
block|}
struct|;
end_struct
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QGLFormat
argument_list|,
argument|qgl_default_format
argument_list|)
end_macro
begin_class
DECL|class|QGLDefaultOverlayFormat
class|class
name|QGLDefaultOverlayFormat
super|:
specifier|public
name|QGLFormat
block|{
public|public:
DECL|function|QGLDefaultOverlayFormat
specifier|inline
name|QGLDefaultOverlayFormat
parameter_list|()
block|{
name|setOption
argument_list|(
name|QGL
operator|::
name|FormatOption
argument_list|(
literal|0xffff
operator|<<
literal|16
argument_list|)
argument_list|)
expr_stmt|;
comment|// turn off all options
name|setOption
argument_list|(
name|QGL
operator|::
name|DirectRendering
argument_list|)
expr_stmt|;
name|setPlane
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QGLDefaultOverlayFormat
argument_list|,
argument|defaultOverlayFormatInstance
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QGLSignalProxy
argument_list|,
argument|theSignalProxy
argument_list|)
end_macro
begin_function
DECL|function|instance
name|QGLSignalProxy
modifier|*
name|QGLSignalProxy
operator|::
name|instance
parameter_list|()
block|{
name|QGLSignalProxy
modifier|*
name|proxy
init|=
name|theSignalProxy
argument_list|()
decl_stmt|;
if|if
condition|(
name|proxy
operator|&&
name|proxy
operator|->
name|thread
argument_list|()
operator|!=
name|qApp
operator|->
name|thread
argument_list|()
condition|)
block|{
if|if
condition|(
name|proxy
operator|->
name|thread
argument_list|()
operator|==
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
name|proxy
operator|->
name|moveToThread
argument_list|(
name|qApp
operator|->
name|thread
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|proxy
return|;
block|}
end_function
begin_comment
comment|/*!     \namespace QGL     \inmodule QtOpenGL      \brief The QGL namespace specifies miscellaneous identifiers used     in the Qt OpenGL module. */
end_comment
begin_comment
comment|/*!     \enum QGL::FormatOption      This enum specifies the format options that can be used to configure an OpenGL     context. These are set using QGLFormat::setOption().      \value DoubleBuffer      Specifies the use of double buffering.     \value DepthBuffer       Enables the use of a depth buffer.     \value Rgba              Specifies that the context should use RGBA as its pixel format.     \value AlphaChannel      Enables the use of an alpha channel.     \value AccumBuffer       Enables the use of an accumulation buffer.     \value StencilBuffer     Enables the use of a stencil buffer.     \value StereoBuffers     Enables the use of a stereo buffers for use with visualization hardware.     \value DirectRendering   Specifies that the context is used for direct rendering to a display.     \value HasOverlay        Enables the use of an overlay.     \value SampleBuffers     Enables the use of sample buffers.     \value DeprecatedFunctions      Enables the use of deprecated functionality for OpenGL 3.x                                     contexts. A context with deprecated functionality enabled is                                     called a full context in the OpenGL specification.     \value SingleBuffer      Specifies the use of a single buffer, as opposed to double buffers.     \value NoDepthBuffer     Disables the use of a depth buffer.     \value ColorIndex        Specifies that the context should use a color index as its pixel format.     \value NoAlphaChannel    Disables the use of an alpha channel.     \value NoAccumBuffer     Disables the use of an accumulation buffer.     \value NoStencilBuffer   Disables the use of a stencil buffer.     \value NoStereoBuffers   Disables the use of stereo buffers.     \value IndirectRendering Specifies that the context is used for indirect rendering to a buffer.     \value NoOverlay         Disables the use of an overlay.     \value NoSampleBuffers   Disables the use of sample buffers.     \value NoDeprecatedFunctions    Disables the use of deprecated functionality for OpenGL 3.x                                     contexts. A context with deprecated functionality disabled is                                     called a forward compatible context in the OpenGL specification.      \sa {Sample Buffers Example} */
end_comment
begin_comment
comment|/*****************************************************************************   QGLFormat implementation  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QGLFormat     \inmodule QtOpenGL      \brief The QGLFormat class specifies the display format of an OpenGL     rendering context.      A display format has several characteristics:     \list     \li \l{setDoubleBuffer()}{Double or single buffering.}     \li \l{setDepth()}{Depth buffer.}     \li \l{setRgba()}{RGBA or color index mode.}     \li \l{setAlpha()}{Alpha channel.}     \li \l{setAccum()}{Accumulation buffer.}     \li \l{setStencil()}{Stencil buffer.}     \li \l{setStereo()}{Stereo buffers.}     \li \l{setDirectRendering()}{Direct rendering.}     \li \l{setOverlay()}{Presence of an overlay.}     \li \l{setPlane()}{Plane of an overlay.}     \li \l{setSampleBuffers()}{Multisample buffers.}     \endlist      You can also specify preferred bit depths for the color buffer,     depth buffer, alpha buffer, accumulation buffer and the stencil     buffer with the functions: setRedBufferSize(), setGreenBufferSize(),     setBlueBufferSize(), setDepthBufferSize(), setAlphaBufferSize(),     setAccumBufferSize() and setStencilBufferSize().      Note that even if you specify that you prefer a 32 bit depth     buffer (e.g. with setDepthBufferSize(32)), the format that is     chosen may not have a 32 bit depth buffer, even if there is a     format available with a 32 bit depth buffer. The main reason for     this is how the system dependant picking algorithms work on the     different platforms, and some format options may have higher     precedence than others.      You create and tell a QGLFormat object what rendering options you     want from an OpenGL rendering context.      OpenGL drivers or accelerated hardware may or may not support     advanced features such as alpha channel or stereographic viewing.     If you request some features that the driver/hardware does not     provide when you create a QGLWidget, you will get a rendering     context with the nearest subset of features.      There are different ways to define the display characteristics of     a rendering context. One is to create a QGLFormat and make it the     default for the entire application:     \snippet code/src_opengl_qgl.cpp 0      Or you can specify the desired format when creating an object of     your QGLWidget subclass:     \snippet code/src_opengl_qgl.cpp 1      After the widget has been created, you can find out which of the     requested features the system was able to provide:     \snippet code/src_opengl_qgl.cpp 2      \legalese         OpenGL is a trademark of Silicon Graphics, Inc. in the         United States and other countries.     \endlegalese      \sa QGLContext, QGLWidget */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_OPENGL_ES
end_ifndef
begin_function
DECL|function|transform_point
specifier|static
specifier|inline
name|void
name|transform_point
parameter_list|(
name|GLdouble
name|out
index|[
literal|4
index|]
parameter_list|,
specifier|const
name|GLdouble
name|m
index|[
literal|16
index|]
parameter_list|,
specifier|const
name|GLdouble
name|in
index|[
literal|4
index|]
parameter_list|)
block|{
DECL|macro|M
define|#
directive|define
name|M
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
value|m[col*4+row]
name|out
index|[
literal|0
index|]
operator|=
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|*
name|in
index|[
literal|0
index|]
operator|+
name|M
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|*
name|in
index|[
literal|1
index|]
operator|+
name|M
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
operator|*
name|in
index|[
literal|2
index|]
operator|+
name|M
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
operator|*
name|in
index|[
literal|3
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|M
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
operator|*
name|in
index|[
literal|0
index|]
operator|+
name|M
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|*
name|in
index|[
literal|1
index|]
operator|+
name|M
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|*
name|in
index|[
literal|2
index|]
operator|+
name|M
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
operator|*
name|in
index|[
literal|3
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|M
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
operator|*
name|in
index|[
literal|0
index|]
operator|+
name|M
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
operator|*
name|in
index|[
literal|1
index|]
operator|+
name|M
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
operator|*
name|in
index|[
literal|2
index|]
operator|+
name|M
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
operator|*
name|in
index|[
literal|3
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|M
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
operator|*
name|in
index|[
literal|0
index|]
operator|+
name|M
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
operator|*
name|in
index|[
literal|1
index|]
operator|+
name|M
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
operator|*
name|in
index|[
literal|2
index|]
operator|+
name|M
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
operator|*
name|in
index|[
literal|3
index|]
expr_stmt|;
DECL|macro|M
undef|#
directive|undef
name|M
block|}
end_function
begin_function
DECL|function|qgluProject
specifier|static
specifier|inline
name|GLint
name|qgluProject
parameter_list|(
name|GLdouble
name|objx
parameter_list|,
name|GLdouble
name|objy
parameter_list|,
name|GLdouble
name|objz
parameter_list|,
specifier|const
name|GLdouble
name|model
index|[
literal|16
index|]
parameter_list|,
specifier|const
name|GLdouble
name|proj
index|[
literal|16
index|]
parameter_list|,
specifier|const
name|GLint
name|viewport
index|[
literal|4
index|]
parameter_list|,
name|GLdouble
modifier|*
name|winx
parameter_list|,
name|GLdouble
modifier|*
name|winy
parameter_list|,
name|GLdouble
modifier|*
name|winz
parameter_list|)
block|{
name|GLdouble
name|in
index|[
literal|4
index|]
decl_stmt|,
name|out
index|[
literal|4
index|]
decl_stmt|;
name|in
index|[
literal|0
index|]
operator|=
name|objx
expr_stmt|;
name|in
index|[
literal|1
index|]
operator|=
name|objy
expr_stmt|;
name|in
index|[
literal|2
index|]
operator|=
name|objz
expr_stmt|;
name|in
index|[
literal|3
index|]
operator|=
literal|1.0
expr_stmt|;
name|transform_point
argument_list|(
name|out
argument_list|,
name|model
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|transform_point
argument_list|(
name|in
argument_list|,
name|proj
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
index|[
literal|3
index|]
operator|==
literal|0.0
condition|)
return|return
name|GL_FALSE
return|;
name|in
index|[
literal|0
index|]
operator|/=
name|in
index|[
literal|3
index|]
expr_stmt|;
name|in
index|[
literal|1
index|]
operator|/=
name|in
index|[
literal|3
index|]
expr_stmt|;
name|in
index|[
literal|2
index|]
operator|/=
name|in
index|[
literal|3
index|]
expr_stmt|;
operator|*
name|winx
operator|=
name|viewport
index|[
literal|0
index|]
operator|+
operator|(
literal|1
operator|+
name|in
index|[
literal|0
index|]
operator|)
operator|*
name|viewport
index|[
literal|2
index|]
operator|/
literal|2
expr_stmt|;
operator|*
name|winy
operator|=
name|viewport
index|[
literal|1
index|]
operator|+
operator|(
literal|1
operator|+
name|in
index|[
literal|1
index|]
operator|)
operator|*
name|viewport
index|[
literal|3
index|]
operator|/
literal|2
expr_stmt|;
operator|*
name|winz
operator|=
operator|(
literal|1
operator|+
name|in
index|[
literal|2
index|]
operator|)
operator|/
literal|2
expr_stmt|;
return|return
name|GL_TRUE
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !QT_OPENGL_ES
end_comment
begin_comment
comment|/*!     Constructs a QGLFormat object with the following default settings:     \list     \li \l{setDoubleBuffer()}{Double buffer:} Enabled.     \li \l{setDepth()}{Depth buffer:} Enabled.     \li \l{setRgba()}{RGBA:} Enabled (i.e., color index disabled).     \li \l{setAlpha()}{Alpha channel:} Disabled.     \li \l{setAccum()}{Accumulator buffer:} Disabled.     \li \l{setStencil()}{Stencil buffer:} Enabled.     \li \l{setStereo()}{Stereo:} Disabled.     \li \l{setDirectRendering()}{Direct rendering:} Enabled.     \li \l{setOverlay()}{Overlay:} Disabled.     \li \l{setPlane()}{Plane:} 0 (i.e., normal plane).     \li \l{setSampleBuffers()}{Multisample buffers:} Disabled.     \endlist */
end_comment
begin_constructor
DECL|function|QGLFormat
name|QGLFormat
operator|::
name|QGLFormat
parameter_list|()
block|{
name|d
operator|=
operator|new
name|QGLFormatPrivate
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Creates a QGLFormat object that is a copy of the current     defaultFormat().      If \a options is not 0, the default format is modified by the     specified format options. The \a options parameter should be     QGL::FormatOption values OR'ed together.      This constructor makes it easy to specify a certain desired format     in classes derived from QGLWidget, for example:     \snippet code/src_opengl_qgl.cpp 3      Note that there are QGL::FormatOption values to turn format settings     both on and off, e.g. QGL::DepthBuffer and QGL::NoDepthBuffer,     QGL::DirectRendering and QGL::IndirectRendering, etc.      The \a plane parameter defaults to 0 and is the plane which this     format should be associated with. Not all OpenGL implementations     supports overlay/underlay rendering planes.      \sa defaultFormat(), setOption(), setPlane() */
end_comment
begin_constructor
DECL|function|QGLFormat
name|QGLFormat
operator|::
name|QGLFormat
parameter_list|(
name|QGL
operator|::
name|FormatOptions
name|options
parameter_list|,
name|int
name|plane
parameter_list|)
block|{
name|d
operator|=
operator|new
name|QGLFormatPrivate
expr_stmt|;
name|QGL
operator|::
name|FormatOptions
name|newOpts
init|=
name|options
decl_stmt|;
name|d
operator|->
name|opts
operator|=
name|defaultFormat
argument_list|()
operator|.
name|d
operator|->
name|opts
expr_stmt|;
name|d
operator|->
name|opts
operator||=
operator|(
name|newOpts
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|d
operator|->
name|opts
operator|&=
operator|~
operator|(
name|newOpts
operator|>>
literal|16
operator|)
expr_stmt|;
name|d
operator|->
name|pln
operator|=
name|plane
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|detach
name|void
name|QGLFormat
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|QGLFormatPrivate
modifier|*
name|newd
init|=
operator|new
name|QGLFormatPrivate
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|newd
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Constructs a copy of \a other. */
end_comment
begin_constructor
DECL|function|QGLFormat
name|QGLFormat
operator|::
name|QGLFormat
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns \a other to this object. */
end_comment
begin_function
DECL|function|operator =
name|QGLFormat
modifier|&
name|QGLFormat
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|d
operator|!=
name|other
operator|.
name|d
condition|)
block|{
name|other
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the QGLFormat. */
end_comment
begin_destructor
DECL|function|~QGLFormat
name|QGLFormat
operator|::
name|~
name|QGLFormat
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn bool QGLFormat::doubleBuffer() const      Returns true if double buffering is enabled; otherwise returns     false. Double buffering is enabled by default.      \sa setDoubleBuffer() */
end_comment
begin_comment
comment|/*!     If \a enable is true sets double buffering; otherwise sets single     buffering.      Double buffering is enabled by default.      Double buffering is a technique where graphics are rendered on an     off-screen buffer and not directly to the screen. When the drawing     has been completed, the program calls a swapBuffers() function to     exchange the screen contents with the buffer. The result is     flicker-free drawing and often better performance.      Note that single buffered contexts are currently not supported     with EGL.      \sa doubleBuffer(), QGLContext::swapBuffers(),     QGLWidget::swapBuffers() */
end_comment
begin_function
DECL|function|setDoubleBuffer
name|void
name|QGLFormat
operator|::
name|setDoubleBuffer
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|setOption
argument_list|(
name|enable
condition|?
name|QGL
operator|::
name|DoubleBuffer
else|:
name|QGL
operator|::
name|SingleBuffer
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFormat::depth() const      Returns true if the depth buffer is enabled; otherwise returns     false. The depth buffer is enabled by default.      \sa setDepth(), setDepthBufferSize() */
end_comment
begin_comment
comment|/*!     If \a enable is true enables the depth buffer; otherwise disables     the depth buffer.      The depth buffer is enabled by default.      The purpose of a depth buffer (or Z-buffering) is to remove hidden     surfaces. Pixels are assigned Z values based on the distance to     the viewer. A pixel with a high Z value is closer to the viewer     than a pixel with a low Z value. This information is used to     decide whether to draw a pixel or not.      \sa depth(), setDepthBufferSize() */
end_comment
begin_function
DECL|function|setDepth
name|void
name|QGLFormat
operator|::
name|setDepth
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|setOption
argument_list|(
name|enable
condition|?
name|QGL
operator|::
name|DepthBuffer
else|:
name|QGL
operator|::
name|NoDepthBuffer
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFormat::rgba() const      Returns true if RGBA color mode is set. Returns false if color     index mode is set. The default color mode is RGBA.      \sa setRgba() */
end_comment
begin_comment
comment|/*!     If \a enable is true sets RGBA mode. If \a enable is false sets     color index mode.      The default color mode is RGBA.      RGBA is the preferred mode for most OpenGL applications. In RGBA     color mode you specify colors as red + green + blue + alpha     quadruplets.      In color index mode you specify an index into a color lookup     table.      \sa rgba() */
end_comment
begin_function
DECL|function|setRgba
name|void
name|QGLFormat
operator|::
name|setRgba
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|setOption
argument_list|(
name|enable
condition|?
name|QGL
operator|::
name|Rgba
else|:
name|QGL
operator|::
name|ColorIndex
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFormat::alpha() const      Returns true if the alpha buffer in the framebuffer is enabled;     otherwise returns false. The alpha buffer is disabled by default.      \sa setAlpha(), setAlphaBufferSize() */
end_comment
begin_comment
comment|/*!     If \a enable is true enables the alpha buffer; otherwise disables     the alpha buffer.      The alpha buffer is disabled by default.      The alpha buffer is typically used for implementing transparency     or translucency. The A in RGBA specifies the transparency of a     pixel.      \sa alpha(), setAlphaBufferSize() */
end_comment
begin_function
DECL|function|setAlpha
name|void
name|QGLFormat
operator|::
name|setAlpha
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|setOption
argument_list|(
name|enable
condition|?
name|QGL
operator|::
name|AlphaChannel
else|:
name|QGL
operator|::
name|NoAlphaChannel
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFormat::accum() const      Returns true if the accumulation buffer is enabled; otherwise     returns false. The accumulation buffer is disabled by default.      \sa setAccum(), setAccumBufferSize() */
end_comment
begin_comment
comment|/*!     If \a enable is true enables the accumulation buffer; otherwise     disables the accumulation buffer.      The accumulation buffer is disabled by default.      The accumulation buffer is used to create blur effects and     multiple exposures.      \sa accum(), setAccumBufferSize() */
end_comment
begin_function
DECL|function|setAccum
name|void
name|QGLFormat
operator|::
name|setAccum
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|setOption
argument_list|(
name|enable
condition|?
name|QGL
operator|::
name|AccumBuffer
else|:
name|QGL
operator|::
name|NoAccumBuffer
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFormat::stencil() const      Returns true if the stencil buffer is enabled; otherwise returns     false. The stencil buffer is enabled by default.      \sa setStencil(), setStencilBufferSize() */
end_comment
begin_comment
comment|/*!     If \a enable is true enables the stencil buffer; otherwise     disables the stencil buffer.      The stencil buffer is enabled by default.      The stencil buffer masks certain parts of the drawing area so that     masked parts are not drawn on.      \sa stencil(), setStencilBufferSize() */
end_comment
begin_function
DECL|function|setStencil
name|void
name|QGLFormat
operator|::
name|setStencil
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|setOption
argument_list|(
name|enable
condition|?
name|QGL
operator|::
name|StencilBuffer
else|:
name|QGL
operator|::
name|NoStencilBuffer
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFormat::stereo() const      Returns true if stereo buffering is enabled; otherwise returns     false. Stereo buffering is disabled by default.      \sa setStereo() */
end_comment
begin_comment
comment|/*!     If \a enable is true enables stereo buffering; otherwise disables     stereo buffering.      Stereo buffering is disabled by default.      Stereo buffering provides extra color buffers to generate left-eye     and right-eye images.      \sa stereo() */
end_comment
begin_function
DECL|function|setStereo
name|void
name|QGLFormat
operator|::
name|setStereo
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|setOption
argument_list|(
name|enable
condition|?
name|QGL
operator|::
name|StereoBuffers
else|:
name|QGL
operator|::
name|NoStereoBuffers
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFormat::directRendering() const      Returns true if direct rendering is enabled; otherwise returns     false.      Direct rendering is enabled by default.      \sa setDirectRendering() */
end_comment
begin_comment
comment|/*!     If \a enable is true enables direct rendering; otherwise disables     direct rendering.      Direct rendering is enabled by default.      Enabling this option will make OpenGL bypass the underlying window     system and render directly from hardware to the screen, if this is     supported by the system.      \sa directRendering() */
end_comment
begin_function
DECL|function|setDirectRendering
name|void
name|QGLFormat
operator|::
name|setDirectRendering
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|setOption
argument_list|(
name|enable
condition|?
name|QGL
operator|::
name|DirectRendering
else|:
name|QGL
operator|::
name|IndirectRendering
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFormat::sampleBuffers() const      Returns true if multisample buffer support is enabled; otherwise     returns false.      The multisample buffer is disabled by default.      \sa setSampleBuffers() */
end_comment
begin_comment
comment|/*!     If \a enable is true, a GL context with multisample buffer support     is picked; otherwise ignored.      \sa sampleBuffers(), setSamples(), samples() */
end_comment
begin_function
DECL|function|setSampleBuffers
name|void
name|QGLFormat
operator|::
name|setSampleBuffers
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|setOption
argument_list|(
name|enable
condition|?
name|QGL
operator|::
name|SampleBuffers
else|:
name|QGL
operator|::
name|NoSampleBuffers
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of samples per pixel when multisampling is     enabled. By default, the highest number of samples that is     available is used.      \sa setSampleBuffers(), sampleBuffers(), setSamples() */
end_comment
begin_function
DECL|function|samples
name|int
name|QGLFormat
operator|::
name|samples
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|numSamples
return|;
block|}
end_function
begin_comment
comment|/*!     Set the preferred number of samples per pixel when multisampling     is enabled to \a numSamples. By default, the highest number of     samples available is used.      \sa setSampleBuffers(), sampleBuffers(), samples() */
end_comment
begin_function
DECL|function|setSamples
name|void
name|QGLFormat
operator|::
name|setSamples
parameter_list|(
name|int
name|numSamples
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|numSamples
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLFormat::setSamples: Cannot have negative number of samples per pixel %d"
argument_list|,
name|numSamples
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|numSamples
operator|=
name|numSamples
expr_stmt|;
name|setSampleBuffers
argument_list|(
name|numSamples
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Set the preferred swap interval. This can be used to sync the GL     drawing into a system window to the vertical refresh of the screen.     Setting an \a interval value of 0 will turn the vertical refresh syncing     off, any value higher than 0 will turn the vertical syncing on.      Under Windows and under X11, where the \c{WGL_EXT_swap_control}     and \c{GLX_SGI_video_sync} extensions are used, the \a interval     parameter can be used to set the minimum number of video frames     that are displayed before a buffer swap will occur. In effect,     setting the \a interval to 10, means there will be 10 vertical     retraces between every buffer swap.      Under Windows the \c{WGL_EXT_swap_control} extension has to be present,     and under X11 the \c{GLX_SGI_video_sync} extension has to be present. */
end_comment
begin_function
DECL|function|setSwapInterval
name|void
name|QGLFormat
operator|::
name|setSwapInterval
parameter_list|(
name|int
name|interval
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|swapInterval
operator|=
name|interval
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the currently set swap interval. -1 is returned if setting     the swap interval isn't supported in the system GL implementation. */
end_comment
begin_function
DECL|function|swapInterval
name|int
name|QGLFormat
operator|::
name|swapInterval
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|swapInterval
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFormat::hasOverlay() const      Returns true if overlay plane is enabled; otherwise returns false.      Overlay is disabled by default.      \sa setOverlay() */
end_comment
begin_comment
comment|/*!     If \a enable is true enables an overlay plane; otherwise disables     the overlay plane.      Enabling the overlay plane will cause QGLWidget to create an     additional context in an overlay plane. See the QGLWidget     documentation for further information.      \sa hasOverlay() */
end_comment
begin_function
DECL|function|setOverlay
name|void
name|QGLFormat
operator|::
name|setOverlay
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|setOption
argument_list|(
name|enable
condition|?
name|QGL
operator|::
name|HasOverlay
else|:
name|QGL
operator|::
name|NoOverlay
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the plane of this format. The default for normal formats     is 0, which means the normal plane. The default for overlay     formats is 1, which is the first overlay plane.      \sa setPlane(), defaultOverlayFormat() */
end_comment
begin_function
DECL|function|plane
name|int
name|QGLFormat
operator|::
name|plane
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|pln
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the requested plane to \a plane. 0 is the normal plane, 1 is     the first overlay plane, 2 is the second overlay plane, etc.; -1,     -2, etc. are underlay planes.      Note that in contrast to other format specifications, the plane     specifications will be matched exactly. This means that if you     specify a plane that the underlying OpenGL system cannot provide,     an \l{QGLWidget::isValid()}{invalid} QGLWidget will be     created.      \sa plane() */
end_comment
begin_function
DECL|function|setPlane
name|void
name|QGLFormat
operator|::
name|setPlane
parameter_list|(
name|int
name|plane
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|pln
operator|=
name|plane
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the format option to \a opt.      \sa testOption() */
end_comment
begin_function
DECL|function|setOption
name|void
name|QGLFormat
operator|::
name|setOption
parameter_list|(
name|QGL
operator|::
name|FormatOptions
name|opt
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|opt
operator|&
literal|0xffff
condition|)
name|d
operator|->
name|opts
operator||=
name|opt
expr_stmt|;
else|else
name|d
operator|->
name|opts
operator|&=
operator|~
operator|(
name|opt
operator|>>
literal|16
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if format option \a opt is set; otherwise returns false.      \sa setOption() */
end_comment
begin_function
DECL|function|testOption
name|bool
name|QGLFormat
operator|::
name|testOption
parameter_list|(
name|QGL
operator|::
name|FormatOptions
name|opt
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|opt
operator|&
literal|0xffff
condition|)
return|return
operator|(
name|d
operator|->
name|opts
operator|&
name|opt
operator|)
operator|!=
literal|0
return|;
else|else
return|return
operator|(
name|d
operator|->
name|opts
operator|&
operator|(
name|opt
operator|>>
literal|16
operator|)
operator|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Set the minimum depth buffer size to \a size.      \sa depthBufferSize(), setDepth(), depth() */
end_comment
begin_function
DECL|function|setDepthBufferSize
name|void
name|QGLFormat
operator|::
name|setDepthBufferSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLFormat::setDepthBufferSize: Cannot set negative depth buffer size %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|depthSize
operator|=
name|size
expr_stmt|;
name|setDepth
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the depth buffer size.      \sa depth(), setDepth(), setDepthBufferSize() */
end_comment
begin_function
DECL|function|depthBufferSize
name|int
name|QGLFormat
operator|::
name|depthBufferSize
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|depthSize
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Set the preferred red buffer size to \a size.      \sa setGreenBufferSize(), setBlueBufferSize(), setAlphaBufferSize() */
end_comment
begin_function
DECL|function|setRedBufferSize
name|void
name|QGLFormat
operator|::
name|setRedBufferSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLFormat::setRedBufferSize: Cannot set negative red buffer size %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|redSize
operator|=
name|size
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the red buffer size.      \sa setRedBufferSize() */
end_comment
begin_function
DECL|function|redBufferSize
name|int
name|QGLFormat
operator|::
name|redBufferSize
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|redSize
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Set the preferred green buffer size to \a size.      \sa setRedBufferSize(), setBlueBufferSize(), setAlphaBufferSize() */
end_comment
begin_function
DECL|function|setGreenBufferSize
name|void
name|QGLFormat
operator|::
name|setGreenBufferSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLFormat::setGreenBufferSize: Cannot set negative green buffer size %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|greenSize
operator|=
name|size
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the green buffer size.      \sa setGreenBufferSize() */
end_comment
begin_function
DECL|function|greenBufferSize
name|int
name|QGLFormat
operator|::
name|greenBufferSize
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|greenSize
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Set the preferred blue buffer size to \a size.      \sa setRedBufferSize(), setGreenBufferSize(), setAlphaBufferSize() */
end_comment
begin_function
DECL|function|setBlueBufferSize
name|void
name|QGLFormat
operator|::
name|setBlueBufferSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLFormat::setBlueBufferSize: Cannot set negative blue buffer size %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|blueSize
operator|=
name|size
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the blue buffer size.      \sa setBlueBufferSize() */
end_comment
begin_function
DECL|function|blueBufferSize
name|int
name|QGLFormat
operator|::
name|blueBufferSize
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|blueSize
return|;
block|}
end_function
begin_comment
comment|/*!     Set the preferred alpha buffer size to \a size.     This function implicitly enables the alpha channel.      \sa setRedBufferSize(), setGreenBufferSize(), alphaBufferSize() */
end_comment
begin_function
DECL|function|setAlphaBufferSize
name|void
name|QGLFormat
operator|::
name|setAlphaBufferSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLFormat::setAlphaBufferSize: Cannot set negative alpha buffer size %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|alphaSize
operator|=
name|size
expr_stmt|;
name|setAlpha
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the alpha buffer size.      \sa alpha(), setAlpha(), setAlphaBufferSize() */
end_comment
begin_function
DECL|function|alphaBufferSize
name|int
name|QGLFormat
operator|::
name|alphaBufferSize
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|alphaSize
return|;
block|}
end_function
begin_comment
comment|/*!     Set the preferred accumulation buffer size, where \a size is the     bit depth for each RGBA component.      \sa accum(), setAccum(), accumBufferSize() */
end_comment
begin_function
DECL|function|setAccumBufferSize
name|void
name|QGLFormat
operator|::
name|setAccumBufferSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLFormat::setAccumBufferSize: Cannot set negative accumulate buffer size %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|accumSize
operator|=
name|size
expr_stmt|;
name|setAccum
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the accumulation buffer size.      \sa setAccumBufferSize(), accum(), setAccum() */
end_comment
begin_function
DECL|function|accumBufferSize
name|int
name|QGLFormat
operator|::
name|accumBufferSize
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|accumSize
return|;
block|}
end_function
begin_comment
comment|/*!     Set the preferred stencil buffer size to \a size.      \sa stencilBufferSize(), setStencil(), stencil() */
end_comment
begin_function
DECL|function|setStencilBufferSize
name|void
name|QGLFormat
operator|::
name|setStencilBufferSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLFormat::setStencilBufferSize: Cannot set negative stencil buffer size %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|stencilSize
operator|=
name|size
expr_stmt|;
name|setStencil
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the stencil buffer size.      \sa stencil(), setStencil(), setStencilBufferSize() */
end_comment
begin_function
DECL|function|stencilBufferSize
name|int
name|QGLFormat
operator|::
name|stencilBufferSize
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|stencilSize
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Set the OpenGL version to the \a major and \a minor numbers. If a     context compatible with the requested OpenGL version cannot be     created, a context compatible with version 1.x is created instead.      \sa majorVersion(), minorVersion() */
end_comment
begin_function
DECL|function|setVersion
name|void
name|QGLFormat
operator|::
name|setVersion
parameter_list|(
name|int
name|major
parameter_list|,
name|int
name|minor
parameter_list|)
block|{
if|if
condition|(
name|major
operator|<
literal|1
operator|||
name|minor
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLFormat::setVersion: Cannot set zero or negative version number %d.%d"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
return|return;
block|}
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|majorVersion
operator|=
name|major
expr_stmt|;
name|d
operator|->
name|minorVersion
operator|=
name|minor
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Returns the OpenGL major version.      \sa setVersion(), minorVersion() */
end_comment
begin_function
DECL|function|majorVersion
name|int
name|QGLFormat
operator|::
name|majorVersion
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|majorVersion
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Returns the OpenGL minor version.      \sa setVersion(), majorVersion() */
end_comment
begin_function
DECL|function|minorVersion
name|int
name|QGLFormat
operator|::
name|minorVersion
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|minorVersion
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QGLFormat::OpenGLContextProfile     \since 4.7      This enum describes the OpenGL context profiles that can be     specified for contexts implementing OpenGL version 3.2 or     higher. These profiles are different from OpenGL ES profiles.      \value NoProfile            OpenGL version is lower than 3.2.     \value CoreProfile          Functionality deprecated in OpenGL version 3.0 is not available.     \value CompatibilityProfile Functionality from earlier OpenGL versions is available. */
end_comment
begin_comment
comment|/*!     \since 4.7      Set the OpenGL context profile to \a profile. The \a profile is     ignored if the requested OpenGL version is less than 3.2.      \sa profile() */
end_comment
begin_function
DECL|function|setProfile
name|void
name|QGLFormat
operator|::
name|setProfile
parameter_list|(
name|OpenGLContextProfile
name|profile
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|profile
operator|=
name|profile
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Returns the OpenGL context profile.      \sa setProfile() */
end_comment
begin_function
DECL|function|profile
name|QGLFormat
operator|::
name|OpenGLContextProfile
name|QGLFormat
operator|::
name|profile
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|profile
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFormat::hasOpenGL()      Returns true if the window system has any OpenGL support;     otherwise returns false.      \warning This function must not be called until the QApplication     object has been created. */
end_comment
begin_comment
comment|/*!     \fn bool QGLFormat::hasOpenGLOverlays()      Returns true if the window system supports OpenGL overlays;     otherwise returns false.      \warning This function must not be called until the QApplication     object has been created. */
end_comment
begin_function
DECL|function|qOpenGLVersionFlagsFromString
name|QGLFormat
operator|::
name|OpenGLVersionFlags
name|Q_AUTOTEST_EXPORT
name|qOpenGLVersionFlagsFromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|versionString
parameter_list|)
block|{
name|QGLFormat
operator|::
name|OpenGLVersionFlags
name|versionFlags
init|=
name|QGLFormat
operator|::
name|OpenGL_Version_None
decl_stmt|;
if|if
condition|(
name|versionString
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"OpenGL ES"
argument_list|)
argument_list|)
condition|)
block|{
name|QStringList
name|parts
init|=
name|versionString
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|size
argument_list|()
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
name|parts
index|[
literal|2
index|]
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"1."
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|parts
index|[
literal|1
index|]
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"-CM"
argument_list|)
argument_list|)
condition|)
block|{
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_ES_Common_Version_1_0
operator||
name|QGLFormat
operator|::
name|OpenGL_ES_CommonLite_Version_1_0
expr_stmt|;
if|if
condition|(
name|parts
index|[
literal|2
index|]
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"1.1"
argument_list|)
argument_list|)
condition|)
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_ES_Common_Version_1_1
operator||
name|QGLFormat
operator|::
name|OpenGL_ES_CommonLite_Version_1_1
expr_stmt|;
block|}
else|else
block|{
comment|// Not -CM, must be CL, CommonLite
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_ES_CommonLite_Version_1_0
expr_stmt|;
if|if
condition|(
name|parts
index|[
literal|2
index|]
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"1.1"
argument_list|)
argument_list|)
condition|)
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_ES_CommonLite_Version_1_1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// OpenGL ES version 2.0 or higher
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_ES_Version_2_0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// if< 3 parts to the name, it is an unrecognised OpenGL ES
name|qWarning
argument_list|(
literal|"Unrecognised OpenGL ES version"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// not ES, regular OpenGL, the version numbers are first in the string
if|if
condition|(
name|versionString
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"1."
argument_list|)
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|versionString
index|[
literal|2
index|]
operator|.
name|toLatin1
argument_list|()
condition|)
block|{
case|case
literal|'5'
case|:
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_1_5
expr_stmt|;
case|case
literal|'4'
case|:
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_1_4
expr_stmt|;
case|case
literal|'3'
case|:
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_1_3
expr_stmt|;
case|case
literal|'2'
case|:
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_1_2
expr_stmt|;
case|case
literal|'1'
case|:
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_1_1
expr_stmt|;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|versionString
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"2."
argument_list|)
argument_list|)
condition|)
block|{
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_1_1
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_2
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_3
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_4
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_5
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_2_0
expr_stmt|;
if|if
condition|(
name|versionString
index|[
literal|2
index|]
operator|.
name|toLatin1
argument_list|()
operator|==
literal|'1'
condition|)
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_2_1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|versionString
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"3."
argument_list|)
argument_list|)
condition|)
block|{
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_1_1
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_2
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_3
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_4
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_5
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_2_0
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_2_1
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_3_0
expr_stmt|;
switch|switch
condition|(
name|versionString
index|[
literal|2
index|]
operator|.
name|toLatin1
argument_list|()
condition|)
block|{
case|case
literal|'3'
case|:
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_3_3
expr_stmt|;
case|case
literal|'2'
case|:
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_3_2
expr_stmt|;
case|case
literal|'1'
case|:
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_3_1
expr_stmt|;
case|case
literal|'0'
case|:
break|break;
default|default:
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_3_1
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_3_2
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_3_3
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|versionString
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"4."
argument_list|)
argument_list|)
condition|)
block|{
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_1_1
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_2
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_3
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_4
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_5
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_2_0
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_2_1
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_3_0
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_3_1
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_3_2
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_3_3
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_4_0
expr_stmt|;
switch|switch
condition|(
name|versionString
index|[
literal|2
index|]
operator|.
name|toLatin1
argument_list|()
condition|)
block|{
case|case
literal|'3'
case|:
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_4_3
expr_stmt|;
case|case
literal|'2'
case|:
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_4_2
expr_stmt|;
case|case
literal|'1'
case|:
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_4_1
expr_stmt|;
case|case
literal|'0'
case|:
break|break;
default|default:
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_4_1
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_4_2
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_4_3
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|versionFlags
operator||=
name|QGLFormat
operator|::
name|OpenGL_Version_1_1
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_2
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_3
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_4
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_1_5
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_2_0
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_2_1
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_3_0
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_3_1
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_3_2
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_3_3
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_4_0
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_4_1
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_4_2
operator||
name|QGLFormat
operator|::
name|OpenGL_Version_4_3
expr_stmt|;
block|}
block|}
return|return
name|versionFlags
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QGLFormat::OpenGLVersionFlag     \since 4.2      This enum describes the various OpenGL versions that are     recognized by Qt. Use the QGLFormat::openGLVersionFlags() function     to identify which versions that are supported at runtime.      \value OpenGL_Version_None  If no OpenGL is present or if no OpenGL context is current.      \value OpenGL_Version_1_1  OpenGL version 1.1 or higher is present.      \value OpenGL_Version_1_2  OpenGL version 1.2 or higher is present.      \value OpenGL_Version_1_3  OpenGL version 1.3 or higher is present.      \value OpenGL_Version_1_4  OpenGL version 1.4 or higher is present.      \value OpenGL_Version_1_5  OpenGL version 1.5 or higher is present.      \value OpenGL_Version_2_0  OpenGL version 2.0 or higher is present.     Note that version 2.0 supports all the functionality of version 1.5.      \value OpenGL_Version_2_1  OpenGL version 2.1 or higher is present.      \value OpenGL_Version_3_0  OpenGL version 3.0 or higher is present.      \value OpenGL_Version_3_1  OpenGL version 3.1 or higher is present.     Note that OpenGL version 3.1 or higher does not necessarily support all the features of     version 3.0 and lower.      \value OpenGL_Version_3_2  OpenGL version 3.2 or higher is present.      \value OpenGL_Version_3_3  OpenGL version 3.3 or higher is present.      \value OpenGL_Version_4_0  OpenGL version 4.0 or higher is present.      \value OpenGL_Version_4_1  OpenGL version 4.1 or higher is present.      \value OpenGL_Version_4_2  OpenGL version 4.2 or higher is present.      \value OpenGL_Version_4_3  OpenGL version 4.3 or higher is present.      \value OpenGL_ES_CommonLite_Version_1_0  OpenGL ES version 1.0 Common Lite or higher is present.      \value OpenGL_ES_Common_Version_1_0  OpenGL ES version 1.0 Common or higher is present.     The Common profile supports all the features of Common Lite.      \value OpenGL_ES_CommonLite_Version_1_1  OpenGL ES version 1.1 Common Lite or higher is present.      \value OpenGL_ES_Common_Version_1_1  OpenGL ES version 1.1 Common or higher is present.     The Common profile supports all the features of Common Lite.      \value OpenGL_ES_Version_2_0  OpenGL ES version 2.0 or higher is present.     Note that OpenGL ES version 2.0 does not support all the features of OpenGL ES 1.x.     So if OpenGL_ES_Version_2_0 is returned, none of the ES 1.x flags are returned.      See also \l{http://www.opengl.org} for more information about the different     revisions of OpenGL.      \sa openGLVersionFlags() */
end_comment
begin_comment
comment|/*!     \since 4.2      Identifies, at runtime, which OpenGL versions that are supported     by the current platform.      Note that if OpenGL version 1.5 is supported, its predecessors     (i.e., version 1.4 and lower) are also supported. To identify the     support of a particular feature, like multi texturing, test for     the version in which the feature was first introduced (i.e.,     version 1.3 in the case of multi texturing) to adapt to the largest     possible group of runtime platforms.      This function needs a valid current OpenGL context to work;     otherwise it will return OpenGL_Version_None.      \sa hasOpenGL(), hasOpenGLOverlays() */
end_comment
begin_function
DECL|function|openGLVersionFlags
name|QGLFormat
operator|::
name|OpenGLVersionFlags
name|QGLFormat
operator|::
name|openGLVersionFlags
parameter_list|()
block|{
specifier|static
name|bool
name|cachedDefault
init|=
literal|false
decl_stmt|;
specifier|static
name|OpenGLVersionFlags
name|defaultVersionFlags
init|=
name|OpenGL_Version_None
decl_stmt|;
name|QGLContext
modifier|*
name|currentCtx
init|=
cast|const_cast
argument_list|<
name|QGLContext
operator|*
argument_list|>
argument_list|(
name|QGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
decl_stmt|;
name|QGLTemporaryContext
modifier|*
name|tmpContext
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|currentCtx
operator|&&
name|currentCtx
operator|->
name|d_func
argument_list|()
operator|->
name|version_flags_cached
condition|)
return|return
name|currentCtx
operator|->
name|d_func
argument_list|()
operator|->
name|version_flags
return|;
if|if
condition|(
operator|!
name|currentCtx
condition|)
block|{
if|if
condition|(
name|cachedDefault
condition|)
block|{
return|return
name|defaultVersionFlags
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|hasOpenGL
argument_list|()
condition|)
return|return
name|defaultVersionFlags
return|;
name|tmpContext
operator|=
operator|new
name|QGLTemporaryContext
expr_stmt|;
name|cachedDefault
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|QString
name|versionString
argument_list|(
name|QLatin1String
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|glGetString
argument_list|(
name|GL_VERSION
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|OpenGLVersionFlags
name|versionFlags
init|=
name|qOpenGLVersionFlagsFromString
argument_list|(
name|versionString
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentCtx
condition|)
block|{
name|currentCtx
operator|->
name|d_func
argument_list|()
operator|->
name|version_flags_cached
operator|=
literal|true
expr_stmt|;
name|currentCtx
operator|->
name|d_func
argument_list|()
operator|->
name|version_flags
operator|=
name|versionFlags
expr_stmt|;
block|}
if|if
condition|(
name|tmpContext
condition|)
block|{
name|defaultVersionFlags
operator|=
name|versionFlags
expr_stmt|;
operator|delete
name|tmpContext
expr_stmt|;
block|}
return|return
name|versionFlags
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the default QGLFormat for the application. All QGLWidget     objects that are created use this format unless another format is     specified, e.g. when they are constructed.      If no special default format has been set using     setDefaultFormat(), the default format is the same as that created     with QGLFormat().      \sa setDefaultFormat() */
end_comment
begin_function
DECL|function|defaultFormat
name|QGLFormat
name|QGLFormat
operator|::
name|defaultFormat
parameter_list|()
block|{
return|return
operator|*
name|qgl_default_format
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets a new default QGLFormat for the application to \a f. For     example, to set single buffering as the default instead of double     buffering, your main() might contain code like this:     \snippet code/src_opengl_qgl.cpp 4      \sa defaultFormat() */
end_comment
begin_function
DECL|function|setDefaultFormat
name|void
name|QGLFormat
operator|::
name|setDefaultFormat
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|f
parameter_list|)
block|{
operator|*
name|qgl_default_format
argument_list|()
operator|=
name|f
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the default QGLFormat for overlay contexts.      The default overlay format is:     \list     \li \l{setDoubleBuffer()}{Double buffer:} Disabled.     \li \l{setDepth()}{Depth buffer:} Disabled.     \li \l{setRgba()}{RGBA:} Disabled (i.e., color index enabled).     \li \l{setAlpha()}{Alpha channel:} Disabled.     \li \l{setAccum()}{Accumulator buffer:} Disabled.     \li \l{setStencil()}{Stencil buffer:} Disabled.     \li \l{setStereo()}{Stereo:} Disabled.     \li \l{setDirectRendering()}{Direct rendering:} Enabled.     \li \l{setOverlay()}{Overlay:} Disabled.     \li \l{setSampleBuffers()}{Multisample buffers:} Disabled.     \li \l{setPlane()}{Plane:} 1 (i.e., first overlay plane).     \endlist      \sa setDefaultFormat() */
end_comment
begin_function
DECL|function|defaultOverlayFormat
name|QGLFormat
name|QGLFormat
operator|::
name|defaultOverlayFormat
parameter_list|()
block|{
return|return
operator|*
name|defaultOverlayFormatInstance
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets a new default QGLFormat for overlay contexts to \a f. This     format is used whenever a QGLWidget is created with a format that     hasOverlay() enabled.      For example, to get a double buffered overlay context (if     available), use code like this:      \snippet code/src_opengl_qgl.cpp 5      As usual, you can find out after widget creation whether the     underlying OpenGL system was able to provide the requested     specification:      \snippet code/src_opengl_qgl.cpp 6      \sa defaultOverlayFormat() */
end_comment
begin_function
DECL|function|setDefaultOverlayFormat
name|void
name|QGLFormat
operator|::
name|setDefaultOverlayFormat
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|f
parameter_list|)
block|{
name|QGLFormat
modifier|*
name|defaultFormat
init|=
name|defaultOverlayFormatInstance
argument_list|()
decl_stmt|;
operator|*
name|defaultFormat
operator|=
name|f
expr_stmt|;
comment|// Make sure the user doesn't request that the overlays themselves
comment|// have overlays, since it is unlikely that the system supports
comment|// infinitely many planes...
name|defaultFormat
operator|->
name|setOverlay
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if all the options of the two QGLFormat objects     \a a and \a b are equal; otherwise returns false.      \relates QGLFormat */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|a
parameter_list|,
specifier|const
name|QGLFormat
modifier|&
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|.
name|d
operator|==
name|b
operator|.
name|d
operator|)
operator|||
operator|(
operator|(
name|int
operator|)
name|a
operator|.
name|d
operator|->
name|opts
operator|==
operator|(
name|int
operator|)
name|b
operator|.
name|d
operator|->
name|opts
operator|&&
name|a
operator|.
name|d
operator|->
name|pln
operator|==
name|b
operator|.
name|d
operator|->
name|pln
operator|&&
name|a
operator|.
name|d
operator|->
name|alphaSize
operator|==
name|b
operator|.
name|d
operator|->
name|alphaSize
operator|&&
name|a
operator|.
name|d
operator|->
name|accumSize
operator|==
name|b
operator|.
name|d
operator|->
name|accumSize
operator|&&
name|a
operator|.
name|d
operator|->
name|stencilSize
operator|==
name|b
operator|.
name|d
operator|->
name|stencilSize
operator|&&
name|a
operator|.
name|d
operator|->
name|depthSize
operator|==
name|b
operator|.
name|d
operator|->
name|depthSize
operator|&&
name|a
operator|.
name|d
operator|->
name|redSize
operator|==
name|b
operator|.
name|d
operator|->
name|redSize
operator|&&
name|a
operator|.
name|d
operator|->
name|greenSize
operator|==
name|b
operator|.
name|d
operator|->
name|greenSize
operator|&&
name|a
operator|.
name|d
operator|->
name|blueSize
operator|==
name|b
operator|.
name|d
operator|->
name|blueSize
operator|&&
name|a
operator|.
name|d
operator|->
name|numSamples
operator|==
name|b
operator|.
name|d
operator|->
name|numSamples
operator|&&
name|a
operator|.
name|d
operator|->
name|swapInterval
operator|==
name|b
operator|.
name|d
operator|->
name|swapInterval
operator|&&
name|a
operator|.
name|d
operator|->
name|majorVersion
operator|==
name|b
operator|.
name|d
operator|->
name|majorVersion
operator|&&
name|a
operator|.
name|d
operator|->
name|minorVersion
operator|==
name|b
operator|.
name|d
operator|->
name|minorVersion
operator|&&
name|a
operator|.
name|d
operator|->
name|profile
operator|==
name|b
operator|.
name|d
operator|->
name|profile
operator|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QGLFormat
modifier|&
name|f
parameter_list|)
block|{
specifier|const
name|QGLFormatPrivate
modifier|*
specifier|const
name|d
init|=
name|f
operator|.
name|d
decl_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QGLFormat("
operator|<<
literal|"options "
operator|<<
name|d
operator|->
name|opts
operator|<<
literal|", plane "
operator|<<
name|d
operator|->
name|pln
operator|<<
literal|", depthBufferSize "
operator|<<
name|d
operator|->
name|depthSize
operator|<<
literal|", accumBufferSize "
operator|<<
name|d
operator|->
name|accumSize
operator|<<
literal|", stencilBufferSize "
operator|<<
name|d
operator|->
name|stencilSize
operator|<<
literal|", redBufferSize "
operator|<<
name|d
operator|->
name|redSize
operator|<<
literal|", greenBufferSize "
operator|<<
name|d
operator|->
name|greenSize
operator|<<
literal|", blueBufferSize "
operator|<<
name|d
operator|->
name|blueSize
operator|<<
literal|", alphaBufferSize "
operator|<<
name|d
operator|->
name|alphaSize
operator|<<
literal|", samples "
operator|<<
name|d
operator|->
name|numSamples
operator|<<
literal|", swapInterval "
operator|<<
name|d
operator|->
name|swapInterval
operator|<<
literal|", majorVersion "
operator|<<
name|d
operator|->
name|majorVersion
operator|<<
literal|", minorVersion "
operator|<<
name|d
operator|->
name|minorVersion
operator|<<
literal|", profile "
operator|<<
name|d
operator|->
name|profile
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Returns false if all the options of the two QGLFormat objects     \a a and \a b are equal; otherwise returns true.      \relates QGLFormat */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|operator
name|!=
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|a
parameter_list|,
specifier|const
name|QGLFormat
modifier|&
name|b
parameter_list|)
block|{
return|return
operator|!
operator|(
name|a
operator|==
name|b
operator|)
return|;
block|}
end_function
begin_struct
DECL|struct|QGLContextGroupList
struct|struct
name|QGLContextGroupList
block|{
DECL|function|QGLContextGroupList
name|QGLContextGroupList
parameter_list|()
member_init_list|:
name|m_mutex
argument_list|(
name|QMutex
operator|::
name|Recursive
argument_list|)
block|{     }
DECL|function|append
name|void
name|append
parameter_list|(
name|QGLContextGroup
modifier|*
name|group
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
name|m_list
operator|.
name|append
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
DECL|function|remove
name|void
name|remove
parameter_list|(
name|QGLContextGroup
modifier|*
name|group
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
name|m_list
operator|.
name|removeOne
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
DECL|member|m_list
name|QList
argument_list|<
name|QGLContextGroup
modifier|*
argument_list|>
name|m_list
decl_stmt|;
DECL|member|m_mutex
name|QMutex
name|m_mutex
decl_stmt|;
block|}
struct|;
end_struct
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QGLContextGroupList
argument_list|,
argument|qt_context_groups
argument_list|)
end_macro
begin_comment
comment|/*****************************************************************************   QGLContext implementation  *****************************************************************************/
end_comment
begin_constructor
DECL|function|QGLContextGroup
name|QGLContextGroup
operator|::
name|QGLContextGroup
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|context
parameter_list|)
member_init_list|:
name|m_context
argument_list|(
name|context
argument_list|)
member_init_list|,
name|m_refs
argument_list|(
literal|1
argument_list|)
block|{
name|qt_context_groups
argument_list|()
operator|->
name|append
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QGLContextGroup
name|QGLContextGroup
operator|::
name|~
name|QGLContextGroup
parameter_list|()
block|{
name|qt_context_groups
argument_list|()
operator|->
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|qt_gl_transfer_context
specifier|const
name|QGLContext
modifier|*
name|qt_gl_transfer_context
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ctx
condition|)
return|return
literal|0
return|;
name|QList
argument_list|<
specifier|const
name|QGLContext
modifier|*
argument_list|>
name|shares
argument_list|(
name|QGLContextPrivate
operator|::
name|contextGroup
argument_list|(
name|ctx
argument_list|)
operator|->
name|shares
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shares
operator|.
name|size
argument_list|()
operator|>=
literal|2
condition|)
return|return
operator|(
name|ctx
operator|==
name|shares
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|)
condition|?
name|shares
operator|.
name|at
argument_list|(
literal|1
argument_list|)
else|:
name|shares
operator|.
name|at
argument_list|(
literal|0
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_constructor
DECL|function|QGLContextPrivate
name|QGLContextPrivate
operator|::
name|QGLContextPrivate
parameter_list|(
name|QGLContext
modifier|*
name|context
parameter_list|)
member_init_list|:
name|internal_context
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|q_ptr
argument_list|(
name|context
argument_list|)
member_init_list|,
name|texture_destroyer
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|functions
argument_list|(
literal|0
argument_list|)
block|{
name|group
operator|=
operator|new
name|QGLContextGroup
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|texture_destroyer
operator|=
operator|new
name|QGLTextureDestroyer
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QGLContextPrivate
name|QGLContextPrivate
operator|::
name|~
name|QGLContextPrivate
parameter_list|()
block|{
operator|delete
name|functions
expr_stmt|;
if|if
condition|(
operator|!
name|group
operator|->
name|m_refs
operator|.
name|deref
argument_list|()
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|group
operator|->
name|context
argument_list|()
operator|==
name|q_ptr
argument_list|)
expr_stmt|;
operator|delete
name|group
expr_stmt|;
block|}
operator|delete
name|texture_destroyer
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|init
name|void
name|QGLContextPrivate
operator|::
name|init
parameter_list|(
name|QPaintDevice
modifier|*
name|dev
parameter_list|,
specifier|const
name|QGLFormat
modifier|&
name|format
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|glFormat
operator|=
name|reqFormat
operator|=
name|format
expr_stmt|;
name|valid
operator|=
literal|false
expr_stmt|;
name|q
operator|->
name|setDevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|guiGlContext
operator|=
literal|0
expr_stmt|;
name|ownContext
operator|=
literal|false
expr_stmt|;
name|fbo
operator|=
literal|0
expr_stmt|;
name|crWin
operator|=
literal|false
expr_stmt|;
name|initDone
operator|=
literal|false
expr_stmt|;
name|sharing
operator|=
literal|false
expr_stmt|;
name|max_texture_size
operator|=
operator|-
literal|1
expr_stmt|;
name|version_flags_cached
operator|=
literal|false
expr_stmt|;
name|version_flags
operator|=
name|QGLFormat
operator|::
name|OpenGL_Version_None
expr_stmt|;
name|current_fbo
operator|=
literal|0
expr_stmt|;
name|default_fbo
operator|=
literal|0
expr_stmt|;
name|active_engine
operator|=
literal|0
expr_stmt|;
name|workaround_needsFullClearOnEveryFrame
operator|=
literal|false
expr_stmt|;
name|workaround_brokenFBOReadBack
operator|=
literal|false
expr_stmt|;
name|workaround_brokenTexSubImage
operator|=
literal|false
expr_stmt|;
name|workaroundsCached
operator|=
literal|false
expr_stmt|;
name|workaround_brokenTextureFromPixmap
operator|=
literal|false
expr_stmt|;
name|workaround_brokenTextureFromPixmap_init
operator|=
literal|false
expr_stmt|;
name|workaround_brokenAlphaTexSubImage
operator|=
literal|false
expr_stmt|;
name|workaround_brokenAlphaTexSubImage_init
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|QT_GL_VERTEX_ARRAY_TRACKED_COUNT
condition|;
operator|++
name|i
control|)
name|vertexAttributeArraysEnabledState
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|member|currentCtx
name|QGLContext
modifier|*
name|QGLContext
operator|::
name|currentCtx
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*    Read back the contents of the currently bound framebuffer, used in    QGLWidget::grabFrameBuffer(), QGLPixelbuffer::toImage() and    QGLFramebufferObject::toImage() */
end_comment
begin_function
DECL|function|convertFromGLImage
specifier|static
name|void
name|convertFromGLImage
parameter_list|(
name|QImage
modifier|&
name|img
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|bool
name|alpha_format
parameter_list|,
name|bool
name|include_alpha
parameter_list|)
block|{
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
block|{
comment|// OpenGL gives RGBA; Qt wants ARGB
name|uint
modifier|*
name|p
init|=
operator|(
name|uint
operator|*
operator|)
name|img
operator|.
name|bits
argument_list|()
decl_stmt|;
name|uint
modifier|*
name|end
init|=
name|p
operator|+
name|w
operator|*
name|h
decl_stmt|;
if|if
condition|(
name|alpha_format
operator|&&
name|include_alpha
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|uint
name|a
init|=
operator|*
name|p
operator|<<
literal|24
decl_stmt|;
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|>>
literal|8
operator|)
operator||
name|a
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// This is an old legacy fix for PowerPC based Macs, which
comment|// we shouldn't remove
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|p
operator|=
literal|0xff000000
operator||
operator|(
operator|*
name|p
operator|>>
literal|8
operator|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// OpenGL gives ABGR (i.e. RGBA backwards); Qt wants ARGB
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
name|y
operator|++
control|)
block|{
name|uint
modifier|*
name|q
init|=
operator|(
name|uint
operator|*
operator|)
name|img
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
specifier|const
name|uint
name|pixel
init|=
operator|*
name|q
decl_stmt|;
if|if
condition|(
name|alpha_format
operator|&&
name|include_alpha
condition|)
block|{
operator|*
name|q
operator|=
operator|(
operator|(
name|pixel
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
name|pixel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|pixel
operator|&
literal|0xff00ff00
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|q
operator|=
literal|0xff000000
operator||
operator|(
operator|(
name|pixel
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
name|pixel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|pixel
operator|&
literal|0x00ff00
operator|)
expr_stmt|;
block|}
name|q
operator|++
expr_stmt|;
block|}
block|}
block|}
name|img
operator|=
name|img
operator|.
name|mirrored
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_gl_read_frame_buffer
name|QImage
name|qt_gl_read_frame_buffer
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|bool
name|alpha_format
parameter_list|,
name|bool
name|include_alpha
parameter_list|)
block|{
name|QImage
name|img
argument_list|(
name|size
argument_list|,
operator|(
name|alpha_format
operator|&&
name|include_alpha
operator|)
condition|?
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
else|:
name|QImage
operator|::
name|Format_RGB32
argument_list|)
decl_stmt|;
name|int
name|w
init|=
name|size
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|size
operator|.
name|height
argument_list|()
decl_stmt|;
name|glReadPixels
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|img
operator|.
name|bits
argument_list|()
argument_list|)
expr_stmt|;
name|convertFromGLImage
argument_list|(
name|img
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|alpha_format
argument_list|,
name|include_alpha
argument_list|)
expr_stmt|;
return|return
name|img
return|;
block|}
end_function
begin_function
DECL|function|qt_gl_read_texture
name|QImage
name|qt_gl_read_texture
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|bool
name|alpha_format
parameter_list|,
name|bool
name|include_alpha
parameter_list|)
block|{
name|QImage
name|img
argument_list|(
name|size
argument_list|,
name|alpha_format
condition|?
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
else|:
name|QImage
operator|::
name|Format_RGB32
argument_list|)
decl_stmt|;
name|int
name|w
init|=
name|size
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|size
operator|.
name|height
argument_list|()
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
comment|//### glGetTexImage not in GL ES 2.0, need to do something else here!
name|glGetTexImage
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|img
operator|.
name|bits
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|convertFromGLImage
argument_list|(
name|img
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|alpha_format
argument_list|,
name|include_alpha
argument_list|)
expr_stmt|;
return|return
name|img
return|;
block|}
end_function
begin_comment
comment|// returns the highest number closest to v, which is a power of 2
end_comment
begin_comment
comment|// NB! assumes 32 bit ints
end_comment
begin_function
DECL|function|qt_next_power_of_two
name|int
name|qt_next_power_of_two
parameter_list|(
name|int
name|v
parameter_list|)
block|{
name|v
operator|--
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|1
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|2
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|4
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|8
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|16
expr_stmt|;
operator|++
name|v
expr_stmt|;
return|return
name|v
return|;
block|}
end_function
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QGLTextureCache
argument_list|,
argument|qt_gl_texture_cache
argument_list|)
end_macro
begin_constructor
DECL|function|QGLTextureCache
name|QGLTextureCache
operator|::
name|QGLTextureCache
parameter_list|()
member_init_list|:
name|m_cache
argument_list|(
literal|64
operator|*
literal|1024
argument_list|)
comment|// cache ~64 MB worth of textures - this is not accurate though
block|{
name|QImagePixmapCleanupHooks
operator|::
name|instance
argument_list|()
operator|->
name|addPlatformPixmapModificationHook
argument_list|(
name|cleanupTexturesForPixampData
argument_list|)
expr_stmt|;
name|QImagePixmapCleanupHooks
operator|::
name|instance
argument_list|()
operator|->
name|addPlatformPixmapDestructionHook
argument_list|(
name|cleanupBeforePixmapDestruction
argument_list|)
expr_stmt|;
name|QImagePixmapCleanupHooks
operator|::
name|instance
argument_list|()
operator|->
name|addImageHook
argument_list|(
name|cleanupTexturesForCacheKey
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QGLTextureCache
name|QGLTextureCache
operator|::
name|~
name|QGLTextureCache
parameter_list|()
block|{
name|QImagePixmapCleanupHooks
operator|::
name|instance
argument_list|()
operator|->
name|removePlatformPixmapModificationHook
argument_list|(
name|cleanupTexturesForPixampData
argument_list|)
expr_stmt|;
name|QImagePixmapCleanupHooks
operator|::
name|instance
argument_list|()
operator|->
name|removePlatformPixmapDestructionHook
argument_list|(
name|cleanupBeforePixmapDestruction
argument_list|)
expr_stmt|;
name|QImagePixmapCleanupHooks
operator|::
name|instance
argument_list|()
operator|->
name|removeImageHook
argument_list|(
name|cleanupTexturesForCacheKey
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|insert
name|void
name|QGLTextureCache
operator|::
name|insert
parameter_list|(
name|QGLContext
modifier|*
name|ctx
parameter_list|,
name|qint64
name|key
parameter_list|,
name|QGLTexture
modifier|*
name|texture
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|QWriteLocker
name|locker
argument_list|(
operator|&
name|m_lock
argument_list|)
decl_stmt|;
specifier|const
name|QGLTextureCacheKey
name|cacheKey
init|=
block|{
name|key
block|,
name|QGLContextPrivate
operator|::
name|contextGroup
operator|(
name|ctx
operator|)
block|}
decl_stmt|;
name|m_cache
operator|.
name|insert
argument_list|(
name|cacheKey
argument_list|,
name|texture
argument_list|,
name|cost
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|remove
name|void
name|QGLTextureCache
operator|::
name|remove
parameter_list|(
name|qint64
name|key
parameter_list|)
block|{
name|QWriteLocker
name|locker
argument_list|(
operator|&
name|m_lock
argument_list|)
decl_stmt|;
name|QMutexLocker
name|groupLocker
argument_list|(
operator|&
name|qt_context_groups
argument_list|()
operator|->
name|m_mutex
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QGLContextGroup
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|qt_context_groups
argument_list|()
operator|->
name|m_list
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|qt_context_groups
argument_list|()
operator|->
name|m_list
operator|.
name|constEnd
argument_list|()
condition|)
block|{
specifier|const
name|QGLTextureCacheKey
name|cacheKey
init|=
block|{
name|key
block|,
operator|*
name|it
block|}
decl_stmt|;
name|m_cache
operator|.
name|remove
argument_list|(
name|cacheKey
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|remove
name|bool
name|QGLTextureCache
operator|::
name|remove
parameter_list|(
name|QGLContext
modifier|*
name|ctx
parameter_list|,
name|GLuint
name|textureId
parameter_list|)
block|{
name|QWriteLocker
name|locker
argument_list|(
operator|&
name|m_lock
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QGLTextureCacheKey
argument_list|>
name|keys
init|=
name|m_cache
operator|.
name|keys
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGLTexture
modifier|*
name|tex
init|=
name|m_cache
operator|.
name|object
argument_list|(
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tex
operator|->
name|id
operator|==
name|textureId
operator|&&
name|tex
operator|->
name|context
operator|==
name|ctx
condition|)
block|{
name|tex
operator|->
name|options
operator||=
name|QGLContext
operator|::
name|MemoryManagedBindOption
expr_stmt|;
comment|// forces a glDeleteTextures() call
name|m_cache
operator|.
name|remove
argument_list|(
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|removeContextTextures
name|void
name|QGLTextureCache
operator|::
name|removeContextTextures
parameter_list|(
name|QGLContext
modifier|*
name|ctx
parameter_list|)
block|{
name|QWriteLocker
name|locker
argument_list|(
operator|&
name|m_lock
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QGLTextureCacheKey
argument_list|>
name|keys
init|=
name|m_cache
operator|.
name|keys
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QGLTextureCacheKey
modifier|&
name|key
init|=
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|m_cache
operator|.
name|object
argument_list|(
name|key
argument_list|)
operator|->
name|context
operator|==
name|ctx
condition|)
name|m_cache
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*   a hook that removes textures from the cache when a pixmap/image   is deref'ed */
end_comment
begin_function
DECL|function|cleanupTexturesForCacheKey
name|void
name|QGLTextureCache
operator|::
name|cleanupTexturesForCacheKey
parameter_list|(
name|qint64
name|cacheKey
parameter_list|)
block|{
name|qt_gl_texture_cache
argument_list|()
operator|->
name|remove
argument_list|(
name|cacheKey
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cleanupTexturesForPixampData
name|void
name|QGLTextureCache
operator|::
name|cleanupTexturesForPixampData
parameter_list|(
name|QPlatformPixmap
modifier|*
name|pmd
parameter_list|)
block|{
name|cleanupTexturesForCacheKey
argument_list|(
name|pmd
operator|->
name|cacheKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cleanupBeforePixmapDestruction
name|void
name|QGLTextureCache
operator|::
name|cleanupBeforePixmapDestruction
parameter_list|(
name|QPlatformPixmap
modifier|*
name|pmd
parameter_list|)
block|{
comment|// Remove any bound textures first:
name|cleanupTexturesForPixampData
argument_list|(
name|pmd
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|instance
name|QGLTextureCache
modifier|*
name|QGLTextureCache
operator|::
name|instance
parameter_list|()
block|{
return|return
name|qt_gl_texture_cache
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// DDS format structure
end_comment
begin_struct
DECL|struct|DDSFormat
struct|struct
name|DDSFormat
block|{
DECL|member|dwSize
name|quint32
name|dwSize
decl_stmt|;
DECL|member|dwFlags
name|quint32
name|dwFlags
decl_stmt|;
DECL|member|dwHeight
name|quint32
name|dwHeight
decl_stmt|;
DECL|member|dwWidth
name|quint32
name|dwWidth
decl_stmt|;
DECL|member|dwLinearSize
name|quint32
name|dwLinearSize
decl_stmt|;
DECL|member|dummy1
name|quint32
name|dummy1
decl_stmt|;
DECL|member|dwMipMapCount
name|quint32
name|dwMipMapCount
decl_stmt|;
DECL|member|dummy2
name|quint32
name|dummy2
index|[
literal|11
index|]
decl_stmt|;
struct|struct
block|{
DECL|member|dummy3
name|quint32
name|dummy3
index|[
literal|2
index|]
decl_stmt|;
DECL|member|dwFourCC
name|quint32
name|dwFourCC
decl_stmt|;
DECL|member|dummy4
name|quint32
name|dummy4
index|[
literal|5
index|]
decl_stmt|;
DECL|member|ddsPixelFormat
block|}
name|ddsPixelFormat
struct|;
block|}
struct|;
end_struct
begin_comment
comment|// compressed texture pixel formats
end_comment
begin_define
DECL|macro|FOURCC_DXT1
define|#
directive|define
name|FOURCC_DXT1
value|0x31545844
end_define
begin_define
DECL|macro|FOURCC_DXT2
define|#
directive|define
name|FOURCC_DXT2
value|0x32545844
end_define
begin_define
DECL|macro|FOURCC_DXT3
define|#
directive|define
name|FOURCC_DXT3
value|0x33545844
end_define
begin_define
DECL|macro|FOURCC_DXT4
define|#
directive|define
name|FOURCC_DXT4
value|0x34545844
end_define
begin_define
DECL|macro|FOURCC_DXT5
define|#
directive|define
name|FOURCC_DXT5
value|0x35545844
end_define
begin_comment
comment|// ####TODO Properly #ifdef this class to use #define symbols actually defined
end_comment
begin_comment
comment|// by system GL includes
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
end_ifndef
begin_define
DECL|macro|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
define|#
directive|define
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
value|0x83F0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
end_ifndef
begin_define
DECL|macro|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
define|#
directive|define
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
value|0x83F1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GL_COMPRESSED_RGBA_S3TC_DXT3_EXT
end_ifndef
begin_define
DECL|macro|GL_COMPRESSED_RGBA_S3TC_DXT3_EXT
define|#
directive|define
name|GL_COMPRESSED_RGBA_S3TC_DXT3_EXT
value|0x83F2
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
end_ifndef
begin_define
DECL|macro|GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
define|#
directive|define
name|GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
value|0x83F3
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GL_GENERATE_MIPMAP_SGIS
end_ifndef
begin_define
DECL|macro|GL_GENERATE_MIPMAP_SGIS
define|#
directive|define
name|GL_GENERATE_MIPMAP_SGIS
value|0x8191
end_define
begin_define
DECL|macro|GL_GENERATE_MIPMAP_HINT_SGIS
define|#
directive|define
name|GL_GENERATE_MIPMAP_HINT_SGIS
value|0x8192
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \class QGLContext     \inmodule QtOpenGL      \brief The QGLContext class encapsulates an OpenGL rendering context.      An OpenGL rendering context is a complete set of OpenGL state     variables. The rendering context's \l {QGL::FormatOption} {format}     is set in the constructor, but it can also be set later with     setFormat(). The format options that are actually set are returned     by format(); the options you asked for are returned by     requestedFormat(). Note that after a QGLContext object has been     constructed, the actual OpenGL context must be created by     explicitly calling the \l{create()}     function. The makeCurrent() function makes this context the     current rendering context. You can make \e no context current     using doneCurrent(). The reset() function will reset the context     and make it invalid.      You can examine properties of the context with, e.g. isValid(),     isSharing(), initialized(), windowCreated() and     overlayTransparentColor().      If you're using double buffering you can swap the screen contents     with the off-screen buffer using swapBuffers().      Please note that QGLContext is not thread safe. */
end_comment
begin_comment
comment|/*!     \enum QGLContext::BindOption     \since 4.6      A set of options to decide how to bind a texture using bindTexture().      \value NoBindOption Don't do anything, pass the texture straight     through.      \value InvertedYBindOption Specifies that the texture should be flipped     over the X axis so that the texture coordinate 0,0 corresponds to     the top left corner. Inverting the texture implies a deep copy     prior to upload.      \value MipmapBindOption Specifies that bindTexture() should try     to generate mipmaps.  If the GL implementation supports the \c     GL_SGIS_generate_mipmap extension, mipmaps will be automatically     generated for the texture. Mipmap generation is only supported for     the \c GL_TEXTURE_2D target.      \value PremultipliedAlphaBindOption Specifies that the image should be     uploaded with premultiplied alpha and does a conversion accordingly.      \value LinearFilteringBindOption Specifies that the texture filtering     should be set to GL_LINEAR. Default is GL_NEAREST. If mipmap is     also enabled, filtering will be set to GL_LINEAR_MIPMAP_LINEAR.      \value DefaultBindOption In Qt 4.5 and earlier, bindTexture()     would mirror the image and automatically generate mipmaps. This     option helps preserve this default behavior.      \omitvalue CanFlipNativePixmapBindOption Used by x11 from pixmap to choose     whether or not it can bind the pixmap upside down or not.      \omitvalue MemoryManagedBindOption Used by paint engines to     indicate that the pixmap should be memory managed along side with     the pixmap/image that it stems from, e.g. installing destruction     hooks in them.      \omitvalue TemporarilyCachedBindOption Used by paint engines on some     platforms to indicate that the pixmap or image texture is possibly     cached only temporarily and must be destroyed immediately after the use.      \omitvalue InternalBindOption */
end_comment
begin_comment
comment|/*!     \obsolete      Constructs an OpenGL context for the given paint \a device, which     can be a widget or a pixmap. The \a format specifies several     display options for the context.      If the underlying OpenGL/Window system cannot satisfy all the     features requested in \a format, the nearest subset of features     will be used. After creation, the format() method will return the     actual format obtained.      Note that after a QGLContext object has been constructed, \l     create() must be called explicitly to create the actual OpenGL     context. The context will be \l {isValid()}{invalid} if it was not     possible to obtain a GL context at all. */
end_comment
begin_constructor
DECL|function|QGLContext
name|QGLContext
operator|::
name|QGLContext
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|format
parameter_list|,
name|QPaintDevice
modifier|*
name|device
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QGLContextPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|device
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an OpenGL context with the given \a format which     specifies several display options for the context.      If the underlying OpenGL/Window system cannot satisfy all the     features requested in \a format, the nearest subset of features     will be used. After creation, the format() method will return the     actual format obtained.      Note that after a QGLContext object has been constructed, \l     create() must be called explicitly to create the actual OpenGL     context. The context will be \l {isValid()}{invalid} if it was not     possible to obtain a GL context at all.      \sa format(), isValid() */
end_comment
begin_constructor
DECL|function|QGLContext
name|QGLContext
operator|::
name|QGLContext
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|format
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QGLContextPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
literal|0
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the OpenGL context and frees its resources. */
end_comment
begin_destructor
DECL|function|~QGLContext
name|QGLContext
operator|::
name|~
name|QGLContext
parameter_list|()
block|{
comment|// remove any textures cached in this context
name|QGLTextureCache
operator|::
name|instance
argument_list|()
operator|->
name|removeContextTextures
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// clean up resources specific to this context
name|d_ptr
operator|->
name|cleanup
argument_list|()
expr_stmt|;
name|QGLSignalProxy
operator|::
name|instance
argument_list|()
operator|->
name|emitAboutToDestroyContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|cleanup
name|void
name|QGLContextPrivate
operator|::
name|cleanup
parameter_list|()
block|{ }
end_function
begin_define
DECL|macro|ctx
define|#
directive|define
name|ctx
value|q_ptr
end_define
begin_function
DECL|function|setVertexAttribArrayEnabled
name|void
name|QGLContextPrivate
operator|::
name|setVertexAttribArrayEnabled
parameter_list|(
name|int
name|arrayIndex
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|arrayIndex
operator|<
name|QT_GL_VERTEX_ARRAY_TRACKED_COUNT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|glEnableVertexAttribArray
name|Q_ASSERT
argument_list|(
name|glEnableVertexAttribArray
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vertexAttributeArraysEnabledState
index|[
name|arrayIndex
index|]
operator|&&
operator|!
name|enabled
condition|)
name|q
operator|->
name|functions
argument_list|()
operator|->
name|glDisableVertexAttribArray
argument_list|(
name|arrayIndex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vertexAttributeArraysEnabledState
index|[
name|arrayIndex
index|]
operator|&&
name|enabled
condition|)
name|q
operator|->
name|functions
argument_list|()
operator|->
name|glEnableVertexAttribArray
argument_list|(
name|arrayIndex
argument_list|)
expr_stmt|;
name|vertexAttributeArraysEnabledState
index|[
name|arrayIndex
index|]
operator|=
name|enabled
expr_stmt|;
block|}
end_function
begin_function
DECL|function|syncGlState
name|void
name|QGLContextPrivate
operator|::
name|syncGlState
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|glEnableVertexAttribArray
name|Q_ASSERT
argument_list|(
name|glEnableVertexAttribArray
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|QT_GL_VERTEX_ARRAY_TRACKED_COUNT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|vertexAttributeArraysEnabledState
index|[
name|i
index|]
condition|)
name|q
operator|->
name|functions
argument_list|()
operator|->
name|glEnableVertexAttribArray
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|q
operator|->
name|functions
argument_list|()
operator|->
name|glDisableVertexAttribArray
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_undef
DECL|macro|ctx
undef|#
directive|undef
name|ctx
end_undef
begin_function
DECL|function|swapRegion
name|void
name|QGLContextPrivate
operator|::
name|swapRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|q
operator|->
name|swapBuffers
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Reads the compressed texture file \a fileName and generates a 2D GL     texture from it.      This function can load DirectDrawSurface (DDS) textures in the     DXT1, DXT3 and DXT5 DDS formats if the \c GL_ARB_texture_compression     and \c GL_EXT_texture_compression_s3tc extensions are supported.      Since 4.6.1, textures in the ETC1 format can be loaded if the     \c GL_OES_compressed_ETC1_RGB8_texture extension is supported     and the ETC1 texture has been encapsulated in the PVR container format.     Also, textures in the PVRTC2 and PVRTC4 formats can be loaded     if the \c GL_IMG_texture_compression_pvrtc extension is supported.      \sa deleteTexture() */
end_comment
begin_function
DECL|function|bindTexture
name|GLuint
name|QGLContext
operator|::
name|bindTexture
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QGLTexture
name|texture
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QSize
name|size
init|=
name|texture
operator|.
name|bindCompressedTexture
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|size
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|texture
operator|.
name|id
return|;
block|}
end_function
begin_function
DECL|function|qt_gl_convertToGLFormatHelper
specifier|static
specifier|inline
name|QRgb
name|qt_gl_convertToGLFormatHelper
parameter_list|(
name|QRgb
name|src_pixel
parameter_list|,
name|GLenum
name|texture_format
parameter_list|)
block|{
if|if
condition|(
name|texture_format
operator|==
name|GL_BGRA
condition|)
block|{
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
block|{
return|return
operator|(
operator|(
name|src_pixel
operator|<<
literal|24
operator|)
operator|&
literal|0xff000000
operator|)
operator||
operator|(
operator|(
name|src_pixel
operator|>>
literal|24
operator|)
operator|&
literal|0x000000ff
operator|)
operator||
operator|(
operator|(
name|src_pixel
operator|<<
literal|8
operator|)
operator|&
literal|0x00ff0000
operator|)
operator||
operator|(
operator|(
name|src_pixel
operator|>>
literal|8
operator|)
operator|&
literal|0x0000ff00
operator|)
return|;
block|}
else|else
block|{
return|return
name|src_pixel
return|;
block|}
block|}
else|else
block|{
comment|// GL_RGBA
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
block|{
return|return
operator|(
name|src_pixel
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|src_pixel
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|src_pixel
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
name|src_pixel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|src_pixel
operator|&
literal|0xff00ff00
operator|)
return|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|convertToGLFormatHelper
specifier|static
name|void
name|convertToGLFormatHelper
parameter_list|(
name|QImage
modifier|&
name|dst
parameter_list|,
specifier|const
name|QImage
modifier|&
name|img
parameter_list|,
name|GLenum
name|texture_format
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|dst
operator|.
name|depth
argument_list|()
operator|==
literal|32
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|img
operator|.
name|depth
argument_list|()
operator|==
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|.
name|size
argument_list|()
operator|!=
name|img
operator|.
name|size
argument_list|()
condition|)
block|{
name|int
name|target_width
init|=
name|dst
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|target_height
init|=
name|dst
operator|.
name|height
argument_list|()
decl_stmt|;
name|qreal
name|sx
init|=
name|target_width
operator|/
name|qreal
argument_list|(
name|img
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
name|qreal
name|sy
init|=
name|target_height
operator|/
name|qreal
argument_list|(
name|img
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|quint32
modifier|*
name|dest
init|=
operator|(
name|quint32
operator|*
operator|)
name|dst
operator|.
name|scanLine
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// NB! avoid detach here
name|uchar
modifier|*
name|srcPixels
init|=
operator|(
name|uchar
operator|*
operator|)
name|img
operator|.
name|scanLine
argument_list|(
name|img
operator|.
name|height
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|sbpl
init|=
name|img
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
name|int
name|dbpl
init|=
name|dst
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
name|int
name|ix
init|=
name|int
argument_list|(
literal|0x00010000
operator|/
name|sx
argument_list|)
decl_stmt|;
name|int
name|iy
init|=
name|int
argument_list|(
literal|0x00010000
operator|/
name|sy
argument_list|)
decl_stmt|;
name|quint32
name|basex
init|=
name|int
argument_list|(
literal|0.5
operator|*
name|ix
argument_list|)
decl_stmt|;
name|quint32
name|srcy
init|=
name|int
argument_list|(
literal|0.5
operator|*
name|iy
argument_list|)
decl_stmt|;
comment|// scale, swizzle and mirror in one loop
while|while
condition|(
name|target_height
operator|--
condition|)
block|{
specifier|const
name|uint
modifier|*
name|src
init|=
operator|(
specifier|const
name|quint32
operator|*
operator|)
operator|(
name|srcPixels
operator|-
operator|(
name|srcy
operator|>>
literal|16
operator|)
operator|*
name|sbpl
operator|)
decl_stmt|;
name|int
name|srcx
init|=
name|basex
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|target_width
condition|;
operator|++
name|x
control|)
block|{
name|dest
index|[
name|x
index|]
operator|=
name|qt_gl_convertToGLFormatHelper
argument_list|(
name|src
index|[
name|srcx
operator|>>
literal|16
index|]
argument_list|,
name|texture_format
argument_list|)
expr_stmt|;
name|srcx
operator|+=
name|ix
expr_stmt|;
block|}
name|dest
operator|=
operator|(
name|quint32
operator|*
operator|)
operator|(
operator|(
operator|(
name|uchar
operator|*
operator|)
name|dest
operator|)
operator|+
name|dbpl
operator|)
expr_stmt|;
name|srcy
operator|+=
name|iy
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|int
name|width
init|=
name|img
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|height
init|=
name|img
operator|.
name|height
argument_list|()
decl_stmt|;
specifier|const
name|uint
modifier|*
name|p
init|=
operator|(
specifier|const
name|uint
operator|*
operator|)
name|img
operator|.
name|scanLine
argument_list|(
name|img
operator|.
name|height
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|uint
modifier|*
name|q
init|=
operator|(
name|uint
operator|*
operator|)
name|dst
operator|.
name|scanLine
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|texture_format
operator|==
name|GL_BGRA
condition|)
block|{
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
block|{
comment|// mirror + swizzle
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|uint
modifier|*
name|end
init|=
name|p
operator|+
name|width
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|q
operator|=
operator|(
operator|(
operator|*
name|p
operator|<<
literal|24
operator|)
operator|&
literal|0xff000000
operator|)
operator||
operator|(
operator|(
operator|*
name|p
operator|>>
literal|24
operator|)
operator|&
literal|0x000000ff
operator|)
operator||
operator|(
operator|(
operator|*
name|p
operator|<<
literal|8
operator|)
operator|&
literal|0x00ff0000
operator|)
operator||
operator|(
operator|(
operator|*
name|p
operator|>>
literal|8
operator|)
operator|&
literal|0x0000ff00
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
name|p
operator|-=
literal|2
operator|*
name|width
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|uint
name|bytesPerLine
init|=
name|img
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
operator|++
name|i
control|)
block|{
name|memcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
name|bytesPerLine
argument_list|)
expr_stmt|;
name|q
operator|+=
name|width
expr_stmt|;
name|p
operator|-=
name|width
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|uint
modifier|*
name|end
init|=
name|p
operator|+
name|width
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|q
operator|=
operator|(
operator|*
name|p
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|*
name|p
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
name|p
operator|-=
literal|2
operator|*
name|width
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|uint
modifier|*
name|end
init|=
name|p
operator|+
name|width
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|q
operator|=
operator|(
operator|(
operator|*
name|p
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
operator|*
name|p
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
name|p
operator|&
literal|0xff00ff00
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
name|p
operator|-=
literal|2
operator|*
name|width
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|bindTexture
name|QGLTexture
modifier|*
name|QGLContextPrivate
operator|::
name|bindTexture
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|format
parameter_list|,
name|QGLContext
operator|::
name|BindOptions
name|options
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
specifier|const
name|qint64
name|key
init|=
name|image
operator|.
name|cacheKey
argument_list|()
decl_stmt|;
name|QGLTexture
modifier|*
name|texture
init|=
name|textureCacheLookup
argument_list|(
name|key
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|texture
condition|)
block|{
if|if
condition|(
name|image
operator|.
name|paintingActive
argument_list|()
condition|)
block|{
comment|// A QPainter is active on the image - take the safe route and replace the texture.
name|q
operator|->
name|deleteTexture
argument_list|(
name|texture
operator|->
name|id
argument_list|)
expr_stmt|;
name|texture
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|glBindTexture
argument_list|(
name|target
argument_list|,
name|texture
operator|->
name|id
argument_list|)
expr_stmt|;
return|return
name|texture
return|;
block|}
block|}
if|if
condition|(
operator|!
name|texture
condition|)
name|texture
operator|=
name|bindTexture
argument_list|(
name|image
argument_list|,
name|target
argument_list|,
name|format
argument_list|,
name|key
argument_list|,
name|options
argument_list|)
expr_stmt|;
comment|// NOTE: bindTexture(const QImage&, GLenum, GLint, const qint64, bool) should never return null
name|Q_ASSERT
argument_list|(
name|texture
argument_list|)
expr_stmt|;
comment|// Enable the cleanup hooks for this image so that the texture cache entry is removed when the
comment|// image gets deleted:
name|QImagePixmapCleanupHooks
operator|::
name|enableCleanupHooks
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|texture
return|;
block|}
end_function
begin_comment
comment|// #define QGL_BIND_TEXTURE_DEBUG
end_comment
begin_comment
comment|// ####TODO Properly #ifdef this file to use #define symbols actually defined
end_comment
begin_comment
comment|// by OpenGL/ES includes
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|GL_UNSIGNED_INT_8_8_8_8_REV
end_ifndef
begin_define
DECL|macro|GL_UNSIGNED_INT_8_8_8_8_REV
define|#
directive|define
name|GL_UNSIGNED_INT_8_8_8_8_REV
value|0x8367
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// map from Qt's ARGB endianness-dependent format to GL's big-endian RGBA layout
end_comment
begin_function
DECL|function|qgl_byteSwapImage
specifier|static
specifier|inline
name|void
name|qgl_byteSwapImage
parameter_list|(
name|QImage
modifier|&
name|img
parameter_list|,
name|GLenum
name|pixel_type
parameter_list|)
block|{
specifier|const
name|int
name|width
init|=
name|img
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|height
init|=
name|img
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|pixel_type
operator|==
name|GL_UNSIGNED_INT_8_8_8_8_REV
operator|||
operator|(
name|pixel_type
operator|==
name|GL_UNSIGNED_BYTE
operator|&&
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|LittleEndian
operator|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
operator|++
name|i
control|)
block|{
name|uint
modifier|*
name|p
init|=
operator|(
name|uint
operator|*
operator|)
name|img
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
name|p
index|[
name|x
index|]
operator|=
operator|(
operator|(
name|p
index|[
name|x
index|]
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
name|p
index|[
name|x
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|p
index|[
name|x
index|]
operator|&
literal|0xff00ff00
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
operator|++
name|i
control|)
block|{
name|uint
modifier|*
name|p
init|=
operator|(
name|uint
operator|*
operator|)
name|img
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
name|p
index|[
name|x
index|]
operator|=
operator|(
name|p
index|[
name|x
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|p
index|[
name|x
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|bindTexture
name|QGLTexture
modifier|*
name|QGLContextPrivate
operator|::
name|bindTexture
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|internalFormat
parameter_list|,
specifier|const
name|qint64
name|key
parameter_list|,
name|QGLContext
operator|::
name|BindOptions
name|options
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QGL_BIND_TEXTURE_DEBUG
name|printf
argument_list|(
literal|"QGLContextPrivate::bindTexture(), imageSize=(%d,%d), internalFormat =0x%x, options=%x, key=%llx\n"
argument_list|,
name|image
operator|.
name|width
argument_list|()
argument_list|,
name|image
operator|.
name|height
argument_list|()
argument_list|,
name|internalFormat
argument_list|,
name|int
argument_list|(
name|options
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|QTime
name|time
decl_stmt|;
name|time
operator|.
name|start
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
comment|// Reset the gl error stack...git
while|while
condition|(
name|glGetError
argument_list|()
operator|!=
name|GL_NO_ERROR
condition|)
empty_stmt|;
endif|#
directive|endif
comment|// Scale the pixmap if needed. GL textures needs to have the
comment|// dimensions 2^n+2(border) x 2^m+2(border), unless we're using GL
comment|// 2.0 or use the GL_TEXTURE_RECTANGLE texture target
name|int
name|tx_w
init|=
name|qt_next_power_of_two
argument_list|(
name|image
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|tx_h
init|=
name|qt_next_power_of_two
argument_list|(
name|image
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|QImage
name|img
init|=
name|image
decl_stmt|;
if|if
condition|(
operator|!
name|qgl_extensions
argument_list|()
operator|->
name|hasOpenGLFeature
argument_list|(
name|QOpenGLFunctions
operator|::
name|NPOTTextures
argument_list|)
operator|&&
operator|!
operator|(
name|QGLFormat
operator|::
name|openGLVersionFlags
argument_list|()
operator|&
name|QGLFormat
operator|::
name|OpenGL_ES_Version_2_0
operator|)
operator|&&
operator|(
name|target
operator|==
name|GL_TEXTURE_2D
operator|&&
operator|(
name|tx_w
operator|!=
name|image
operator|.
name|width
argument_list|()
operator|||
name|tx_h
operator|!=
name|image
operator|.
name|height
argument_list|()
operator|)
operator|)
condition|)
block|{
name|img
operator|=
name|img
operator|.
name|scaled
argument_list|(
name|tx_w
argument_list|,
name|tx_h
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QGL_BIND_TEXTURE_DEBUG
name|printf
argument_list|(
literal|" - upscaled to %dx%d (%d ms)\n"
argument_list|,
name|tx_w
argument_list|,
name|tx_h
argument_list|,
name|time
operator|.
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|GLuint
name|filtering
init|=
name|options
operator|&
name|QGLContext
operator|::
name|LinearFilteringBindOption
condition|?
name|GL_LINEAR
else|:
name|GL_NEAREST
decl_stmt|;
name|GLuint
name|tx_id
decl_stmt|;
name|glGenTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|tx_id
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|target
argument_list|,
name|tx_id
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|filtering
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
name|bool
name|genMipmap
init|=
literal|false
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|glFormat
operator|.
name|directRendering
argument_list|()
operator|&&
operator|(
name|qgl_extensions
argument_list|()
operator|->
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|GenerateMipmap
argument_list|)
operator|)
operator|&&
name|target
operator|==
name|GL_TEXTURE_2D
operator|&&
operator|(
name|options
operator|&
name|QGLContext
operator|::
name|MipmapBindOption
operator|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
name|glHint
argument_list|(
name|GL_GENERATE_MIPMAP_HINT_SGIS
argument_list|,
name|GL_NICEST
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_GENERATE_MIPMAP_SGIS
argument_list|,
name|GL_TRUE
argument_list|)
expr_stmt|;
else|#
directive|else
name|glHint
argument_list|(
name|GL_GENERATE_MIPMAP_HINT
argument_list|,
name|GL_NICEST
argument_list|)
expr_stmt|;
name|genMipmap
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|options
operator|&
name|QGLContext
operator|::
name|LinearFilteringBindOption
condition|?
name|GL_LINEAR_MIPMAP_LINEAR
else|:
name|GL_NEAREST_MIPMAP_NEAREST
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QGL_BIND_TEXTURE_DEBUG
name|printf
argument_list|(
literal|" - generating mipmaps (%d ms)\n"
argument_list|,
name|time
operator|.
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|filtering
argument_list|)
expr_stmt|;
block|}
name|QImage
operator|::
name|Format
name|target_format
init|=
name|img
operator|.
name|format
argument_list|()
decl_stmt|;
name|bool
name|premul
init|=
name|options
operator|&
name|QGLContext
operator|::
name|PremultipliedAlphaBindOption
decl_stmt|;
name|GLenum
name|externalFormat
decl_stmt|;
name|GLuint
name|pixel_type
decl_stmt|;
if|if
condition|(
name|qgl_extensions
argument_list|()
operator|->
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|BGRATextureFormat
argument_list|)
condition|)
block|{
name|externalFormat
operator|=
name|GL_BGRA
expr_stmt|;
if|if
condition|(
name|QGLFormat
operator|::
name|openGLVersionFlags
argument_list|()
operator|&
name|QGLFormat
operator|::
name|OpenGL_Version_1_2
condition|)
name|pixel_type
operator|=
name|GL_UNSIGNED_INT_8_8_8_8_REV
expr_stmt|;
else|else
name|pixel_type
operator|=
name|GL_UNSIGNED_BYTE
expr_stmt|;
block|}
else|else
block|{
name|externalFormat
operator|=
name|GL_RGBA
expr_stmt|;
name|pixel_type
operator|=
name|GL_UNSIGNED_BYTE
expr_stmt|;
block|}
switch|switch
condition|(
name|target_format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
if|if
condition|(
name|premul
condition|)
block|{
name|img
operator|=
name|img
operator|.
name|convertToFormat
argument_list|(
name|target_format
operator|=
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QGL_BIND_TEXTURE_DEBUG
name|printf
argument_list|(
literal|" - converted ARGB32 -> ARGB32_Premultiplied (%d ms) \n"
argument_list|,
name|time
operator|.
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
if|if
condition|(
operator|!
name|premul
condition|)
block|{
name|img
operator|=
name|img
operator|.
name|convertToFormat
argument_list|(
name|target_format
operator|=
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QGL_BIND_TEXTURE_DEBUG
name|printf
argument_list|(
literal|" - converted ARGB32_Premultiplied -> ARGB32 (%d ms)\n"
argument_list|,
name|time
operator|.
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|pixel_type
operator|=
name|GL_UNSIGNED_SHORT_5_6_5
expr_stmt|;
name|externalFormat
operator|=
name|GL_RGB
expr_stmt|;
name|internalFormat
operator|=
name|GL_RGB
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
break|break;
default|default:
if|if
condition|(
name|img
operator|.
name|hasAlphaChannel
argument_list|()
condition|)
block|{
name|img
operator|=
name|img
operator|.
name|convertToFormat
argument_list|(
name|premul
condition|?
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
else|:
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QGL_BIND_TEXTURE_DEBUG
name|printf
argument_list|(
literal|" - converted to 32-bit alpha format (%d ms)\n"
argument_list|,
name|time
operator|.
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|img
operator|=
name|img
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGB32
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QGL_BIND_TEXTURE_DEBUG
name|printf
argument_list|(
literal|" - converted to 32-bit (%d ms)\n"
argument_list|,
name|time
operator|.
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|options
operator|&
name|QGLContext
operator|::
name|InvertedYBindOption
condition|)
block|{
if|if
condition|(
name|img
operator|.
name|isDetached
argument_list|()
condition|)
block|{
name|int
name|ipl
init|=
name|img
operator|.
name|bytesPerLine
argument_list|()
operator|/
literal|4
decl_stmt|;
name|int
name|h
init|=
name|img
operator|.
name|height
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
operator|/
literal|2
condition|;
operator|++
name|y
control|)
block|{
name|int
modifier|*
name|a
init|=
operator|(
name|int
operator|*
operator|)
name|img
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|int
modifier|*
name|b
init|=
operator|(
name|int
operator|*
operator|)
name|img
operator|.
name|scanLine
argument_list|(
name|h
operator|-
name|y
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|ipl
condition|;
operator|++
name|x
control|)
name|qSwap
argument_list|(
name|a
index|[
name|x
index|]
argument_list|,
name|b
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Create a new image and copy across.  If we use the
comment|// above in-place code then a full copy of the image is
comment|// made before the lines are swapped, which processes the
comment|// data twice.  This version should only do it once.
name|img
operator|=
name|img
operator|.
name|mirrored
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QGL_BIND_TEXTURE_DEBUG
name|printf
argument_list|(
literal|" - flipped bits over y (%d ms)\n"
argument_list|,
name|time
operator|.
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|externalFormat
operator|==
name|GL_RGBA
condition|)
block|{
comment|// The only case where we end up with a depth different from
comment|// 32 in the switch above is for the RGB16 case, where we set
comment|// the format to GL_RGB
name|Q_ASSERT
argument_list|(
name|img
operator|.
name|depth
argument_list|()
operator|==
literal|32
argument_list|)
expr_stmt|;
name|qgl_byteSwapImage
argument_list|(
name|img
argument_list|,
name|pixel_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QGL_BIND_TEXTURE_DEBUG
name|printf
argument_list|(
literal|" - did byte swapping (%d ms)\n"
argument_list|,
name|time
operator|.
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
comment|// OpenGL/ES requires that the internal and external formats be
comment|// identical.
name|internalFormat
operator|=
name|externalFormat
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QGL_BIND_TEXTURE_DEBUG
name|printf
argument_list|(
literal|" - uploading, image.format=%d, externalFormat=0x%x, internalFormat=0x%x, pixel_type=0x%x\n"
argument_list|,
name|img
operator|.
name|format
argument_list|()
argument_list|,
name|externalFormat
argument_list|,
name|internalFormat
argument_list|,
name|pixel_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
specifier|const
name|QImage
modifier|&
name|constRef
init|=
name|img
decl_stmt|;
comment|// to avoid detach in bits()...
name|glTexImage2D
argument_list|(
name|target
argument_list|,
literal|0
argument_list|,
name|internalFormat
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|,
literal|0
argument_list|,
name|externalFormat
argument_list|,
name|pixel_type
argument_list|,
name|constRef
operator|.
name|bits
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
name|genMipmap
condition|)
name|glGenerateMipmap
argument_list|(
name|target
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|GLenum
name|error
init|=
name|glGetError
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|!=
name|GL_NO_ERROR
condition|)
block|{
name|qWarning
argument_list|(
literal|" - texture upload failed, error code 0x%x, enum: %d (%x)\n"
argument_list|,
name|error
argument_list|,
name|target
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QGL_BIND_TEXTURE_DEBUG
specifier|static
name|int
name|totalUploadTime
init|=
literal|0
decl_stmt|;
name|totalUploadTime
operator|+=
name|time
operator|.
name|elapsed
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|" - upload done in %d ms, (accumulated: %d ms)\n"
argument_list|,
name|time
operator|.
name|elapsed
argument_list|()
argument_list|,
name|totalUploadTime
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// this assumes the size of a texture is always smaller than the max cache size
name|int
name|cost
init|=
name|img
operator|.
name|width
argument_list|()
operator|*
name|img
operator|.
name|height
argument_list|()
operator|*
literal|4
operator|/
literal|1024
decl_stmt|;
name|QGLTexture
modifier|*
name|texture
init|=
operator|new
name|QGLTexture
argument_list|(
name|q
argument_list|,
name|tx_id
argument_list|,
name|target
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|QGLTextureCache
operator|::
name|instance
argument_list|()
operator|->
name|insert
argument_list|(
name|q
argument_list|,
name|key
argument_list|,
name|texture
argument_list|,
name|cost
argument_list|)
expr_stmt|;
return|return
name|texture
return|;
block|}
end_function
begin_function
DECL|function|textureCacheLookup
name|QGLTexture
modifier|*
name|QGLContextPrivate
operator|::
name|textureCacheLookup
parameter_list|(
specifier|const
name|qint64
name|key
parameter_list|,
name|GLenum
name|target
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|QGLTexture
modifier|*
name|texture
init|=
name|QGLTextureCache
operator|::
name|instance
argument_list|()
operator|->
name|getTexture
argument_list|(
name|q
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|texture
operator|&&
name|texture
operator|->
name|target
operator|==
name|target
operator|&&
operator|(
name|texture
operator|->
name|context
operator|==
name|q
operator|||
name|QGLContext
operator|::
name|areSharing
argument_list|(
name|q
argument_list|,
name|texture
operator|->
name|context
argument_list|)
operator|)
condition|)
block|{
return|return
name|texture
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|bindTexture
name|QGLTexture
modifier|*
name|QGLContextPrivate
operator|::
name|bindTexture
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|format
parameter_list|,
name|QGLContext
operator|::
name|BindOptions
name|options
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|QPlatformPixmap
modifier|*
name|pd
init|=
name|pixmap
operator|.
name|handle
argument_list|()
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|pd
argument_list|)
expr_stmt|;
specifier|const
name|qint64
name|key
init|=
name|pixmap
operator|.
name|cacheKey
argument_list|()
decl_stmt|;
name|QGLTexture
modifier|*
name|texture
init|=
name|textureCacheLookup
argument_list|(
name|key
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|texture
condition|)
block|{
if|if
condition|(
name|pixmap
operator|.
name|paintingActive
argument_list|()
condition|)
block|{
comment|// A QPainter is active on the pixmap - take the safe route and replace the texture.
name|q
operator|->
name|deleteTexture
argument_list|(
name|texture
operator|->
name|id
argument_list|)
expr_stmt|;
name|texture
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|glBindTexture
argument_list|(
name|target
argument_list|,
name|texture
operator|->
name|id
argument_list|)
expr_stmt|;
return|return
name|texture
return|;
block|}
block|}
if|if
condition|(
operator|!
name|texture
condition|)
block|{
name|QImage
name|image
init|=
name|pixmap
operator|.
name|toImage
argument_list|()
decl_stmt|;
comment|// If the system depth is 16 and the pixmap doesn't have an alpha channel
comment|// then we convert it to RGB16 in the hope that it gets uploaded as a 16
comment|// bit texture which is much faster to access than a 32-bit one.
if|if
condition|(
name|pixmap
operator|.
name|depth
argument_list|()
operator|==
literal|16
operator|&&
operator|!
name|image
operator|.
name|hasAlphaChannel
argument_list|()
condition|)
name|image
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGB16
argument_list|)
expr_stmt|;
name|texture
operator|=
name|bindTexture
argument_list|(
name|image
argument_list|,
name|target
argument_list|,
name|format
argument_list|,
name|key
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
comment|// NOTE: bindTexture(const QImage&, GLenum, GLint, const qint64, bool) should never return null
name|Q_ASSERT
argument_list|(
name|texture
argument_list|)
expr_stmt|;
if|if
condition|(
name|texture
operator|->
name|id
operator|>
literal|0
condition|)
name|QImagePixmapCleanupHooks
operator|::
name|enableCleanupHooks
argument_list|(
name|pixmap
argument_list|)
expr_stmt|;
return|return
name|texture
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|maxTextureSize
name|int
name|QGLContextPrivate
operator|::
name|maxTextureSize
parameter_list|()
block|{
if|if
condition|(
name|max_texture_size
operator|!=
operator|-
literal|1
condition|)
return|return
name|max_texture_size
return|;
name|glGetIntegerv
argument_list|(
name|GL_MAX_TEXTURE_SIZE
argument_list|,
operator|&
name|max_texture_size
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_ES
argument_list|)
return|return
name|max_texture_size
return|;
else|#
directive|else
name|GLenum
name|proxy
init|=
name|GL_PROXY_TEXTURE_2D
decl_stmt|;
name|GLint
name|size
decl_stmt|;
name|GLint
name|next
init|=
literal|64
decl_stmt|;
name|glTexImage2D
argument_list|(
name|proxy
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|next
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|glGetTexLevelParameteriv
argument_list|(
name|proxy
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_WIDTH
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|max_texture_size
return|;
block|}
do|do
block|{
name|size
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|size
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|next
operator|>
name|max_texture_size
condition|)
break|break;
name|glTexImage2D
argument_list|(
name|proxy
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|next
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|glGetTexLevelParameteriv
argument_list|(
name|proxy
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_WIDTH
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|>
name|size
condition|)
do|;
name|max_texture_size
operator|=
name|size
expr_stmt|;
return|return
name|max_texture_size
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!   Returns a QGLFunctions object that is initialized for this context.  */
end_comment
begin_function
DECL|function|functions
name|QGLFunctions
modifier|*
name|QGLContext
operator|::
name|functions
parameter_list|()
specifier|const
block|{
name|QGLContextPrivate
modifier|*
name|d
init|=
cast|const_cast
argument_list|<
name|QGLContextPrivate
operator|*
argument_list|>
argument_list|(
name|d_func
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|functions
condition|)
block|{
name|d
operator|->
name|functions
operator|=
operator|new
name|QGLFunctions
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|functions
operator|->
name|initializeGLFunctions
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
return|return
name|d
operator|->
name|functions
return|;
block|}
end_function
begin_comment
comment|/*!   Generates and binds a 2D GL texture to the current context, based   on \a image. The generated texture id is returned and can be used in   later \c glBindTexture() calls.    \overload */
end_comment
begin_function
DECL|function|bindTexture
name|GLuint
name|QGLContext
operator|::
name|bindTexture
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|format
parameter_list|)
block|{
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|QGLTexture
modifier|*
name|texture
init|=
name|d
operator|->
name|bindTexture
argument_list|(
name|image
argument_list|,
name|target
argument_list|,
name|format
argument_list|,
name|DefaultBindOption
argument_list|)
decl_stmt|;
return|return
name|texture
operator|->
name|id
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Generates and binds a 2D GL texture to the current context, based     on \a image. The generated texture id is returned and can be used     in later \c glBindTexture() calls.      The \a target parameter specifies the texture target. The default     target is \c GL_TEXTURE_2D.      The \a format parameter sets the internal format for the     texture. The default format is \c GL_RGBA.      The binding \a options are a set of options used to decide how to     bind the texture to the context.      The texture that is generated is cached, so multiple calls to     bindTexture() with the same QImage will return the same texture     id.      Note that we assume default values for the glPixelStore() and     glPixelTransfer() parameters.      \sa deleteTexture() */
end_comment
begin_function
DECL|function|bindTexture
name|GLuint
name|QGLContext
operator|::
name|bindTexture
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|format
parameter_list|,
name|BindOptions
name|options
parameter_list|)
block|{
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|QGLTexture
modifier|*
name|texture
init|=
name|d
operator|->
name|bindTexture
argument_list|(
name|image
argument_list|,
name|target
argument_list|,
name|format
argument_list|,
name|options
argument_list|)
decl_stmt|;
return|return
name|texture
operator|->
name|id
return|;
block|}
end_function
begin_comment
comment|/*! \overload      Generates and binds a 2D GL texture based on \a pixmap. */
end_comment
begin_function
DECL|function|bindTexture
name|GLuint
name|QGLContext
operator|::
name|bindTexture
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|format
parameter_list|)
block|{
if|if
condition|(
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|QGLTexture
modifier|*
name|texture
init|=
name|d
operator|->
name|bindTexture
argument_list|(
name|pixmap
argument_list|,
name|target
argument_list|,
name|format
argument_list|,
name|DefaultBindOption
argument_list|)
decl_stmt|;
return|return
name|texture
operator|->
name|id
return|;
block|}
end_function
begin_comment
comment|/*!   \overload   \since 4.6    Generates and binds a 2D GL texture to the current context, based   on \a pixmap. */
end_comment
begin_function
DECL|function|bindTexture
name|GLuint
name|QGLContext
operator|::
name|bindTexture
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|format
parameter_list|,
name|BindOptions
name|options
parameter_list|)
block|{
if|if
condition|(
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|QGLTexture
modifier|*
name|texture
init|=
name|d
operator|->
name|bindTexture
argument_list|(
name|pixmap
argument_list|,
name|target
argument_list|,
name|format
argument_list|,
name|options
argument_list|)
decl_stmt|;
return|return
name|texture
operator|->
name|id
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the texture identified by \a id from the texture cache,     and calls glDeleteTextures() to delete the texture from the     context.      \sa bindTexture() */
end_comment
begin_function
DECL|function|deleteTexture
name|void
name|QGLContext
operator|::
name|deleteTexture
parameter_list|(
name|GLuint
name|id
parameter_list|)
block|{
if|if
condition|(
name|QGLTextureCache
operator|::
name|instance
argument_list|()
operator|->
name|remove
argument_list|(
name|this
argument_list|,
name|id
argument_list|)
condition|)
return|return;
name|glDeleteTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_add_rect_to_array
name|void
name|qt_add_rect_to_array
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
name|GLfloat
modifier|*
name|array
parameter_list|)
block|{
name|qreal
name|left
init|=
name|r
operator|.
name|left
argument_list|()
decl_stmt|;
name|qreal
name|right
init|=
name|r
operator|.
name|right
argument_list|()
decl_stmt|;
name|qreal
name|top
init|=
name|r
operator|.
name|top
argument_list|()
decl_stmt|;
name|qreal
name|bottom
init|=
name|r
operator|.
name|bottom
argument_list|()
decl_stmt|;
name|array
index|[
literal|0
index|]
operator|=
name|left
expr_stmt|;
name|array
index|[
literal|1
index|]
operator|=
name|top
expr_stmt|;
name|array
index|[
literal|2
index|]
operator|=
name|right
expr_stmt|;
name|array
index|[
literal|3
index|]
operator|=
name|top
expr_stmt|;
name|array
index|[
literal|4
index|]
operator|=
name|right
expr_stmt|;
name|array
index|[
literal|5
index|]
operator|=
name|bottom
expr_stmt|;
name|array
index|[
literal|6
index|]
operator|=
name|left
expr_stmt|;
name|array
index|[
literal|7
index|]
operator|=
name|bottom
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_add_texcoords_to_array
name|void
name|qt_add_texcoords_to_array
parameter_list|(
name|qreal
name|x1
parameter_list|,
name|qreal
name|y1
parameter_list|,
name|qreal
name|x2
parameter_list|,
name|qreal
name|y2
parameter_list|,
name|GLfloat
modifier|*
name|array
parameter_list|)
block|{
name|array
index|[
literal|0
index|]
operator|=
name|x1
expr_stmt|;
name|array
index|[
literal|1
index|]
operator|=
name|y1
expr_stmt|;
name|array
index|[
literal|2
index|]
operator|=
name|x2
expr_stmt|;
name|array
index|[
literal|3
index|]
operator|=
name|y1
expr_stmt|;
name|array
index|[
literal|4
index|]
operator|=
name|x2
expr_stmt|;
name|array
index|[
literal|5
index|]
operator|=
name|y2
expr_stmt|;
name|array
index|[
literal|6
index|]
operator|=
name|x1
expr_stmt|;
name|array
index|[
literal|7
index|]
operator|=
name|y2
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
end_if
begin_function
DECL|function|qDrawTextureRect
specifier|static
name|void
name|qDrawTextureRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|target
parameter_list|,
name|GLint
name|textureWidth
parameter_list|,
name|GLint
name|textureHeight
parameter_list|,
name|GLenum
name|textureTarget
parameter_list|)
block|{
name|GLfloat
name|tx
init|=
literal|1.0f
decl_stmt|;
name|GLfloat
name|ty
init|=
literal|1.0f
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
name|Q_UNUSED
argument_list|(
name|textureWidth
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|textureHeight
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|textureTarget
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|textureTarget
operator|!=
name|GL_TEXTURE_2D
condition|)
block|{
if|if
condition|(
name|textureWidth
operator|==
operator|-
literal|1
operator|||
name|textureHeight
operator|==
operator|-
literal|1
condition|)
block|{
name|glGetTexLevelParameteriv
argument_list|(
name|textureTarget
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_WIDTH
argument_list|,
operator|&
name|textureWidth
argument_list|)
expr_stmt|;
name|glGetTexLevelParameteriv
argument_list|(
name|textureTarget
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_HEIGHT
argument_list|,
operator|&
name|textureHeight
argument_list|)
expr_stmt|;
block|}
name|tx
operator|=
name|GLfloat
argument_list|(
name|textureWidth
argument_list|)
expr_stmt|;
name|ty
operator|=
name|GLfloat
argument_list|(
name|textureHeight
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|GLfloat
name|texCoordArray
index|[
literal|4
operator|*
literal|2
index|]
init|=
block|{
literal|0
block|,
name|ty
block|,
name|tx
block|,
name|ty
block|,
name|tx
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|GLfloat
name|vertexArray
index|[
literal|4
operator|*
literal|2
index|]
decl_stmt|;
name|qt_add_rect_to_array
argument_list|(
name|target
argument_list|,
name|vertexArray
argument_list|)
expr_stmt|;
name|glVertexPointer
argument_list|(
literal|2
argument_list|,
name|GL_FLOAT
argument_list|,
literal|0
argument_list|,
name|vertexArray
argument_list|)
expr_stmt|;
name|glTexCoordPointer
argument_list|(
literal|2
argument_list|,
name|GL_FLOAT
argument_list|,
literal|0
argument_list|,
name|texCoordArray
argument_list|)
expr_stmt|;
name|glEnableClientState
argument_list|(
name|GL_VERTEX_ARRAY
argument_list|)
expr_stmt|;
name|glEnableClientState
argument_list|(
name|GL_TEXTURE_COORD_ARRAY
argument_list|)
expr_stmt|;
name|glDrawArrays
argument_list|(
name|GL_TRIANGLE_FAN
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|glDisableClientState
argument_list|(
name|GL_VERTEX_ARRAY
argument_list|)
expr_stmt|;
name|glDisableClientState
argument_list|(
name|GL_TEXTURE_COORD_ARRAY
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !QT_OPENGL_ES_2
end_comment
begin_comment
comment|/*!     \since 4.4      This function supports the following use cases:      \list     \li On OpenGL and OpenGL ES 1.x it draws the given texture, \a textureId,     to the given target rectangle, \a target, in OpenGL model space. The     \a textureTarget should be a 2D texture target.     \li On OpenGL and OpenGL ES 2.x, if a painter is active, not inside a     beginNativePainting / endNativePainting block, and uses the     engine with type QPaintEngine::OpenGL2, the function will draw the given     texture, \a textureId, to the given target rectangle, \a target,     respecting the current painter state. This will let you draw a texture     with the clip, transform, render hints, and composition mode set by the     painter. Note that the texture target needs to be GL_TEXTURE_2D for this     use case, and that this is the only supported use case under OpenGL ES 2.x.     \endlist  */
end_comment
begin_function
DECL|function|drawTexture
name|void
name|QGLContext
operator|::
name|drawTexture
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|target
parameter_list|,
name|GLuint
name|textureId
parameter_list|,
name|GLenum
name|textureTarget
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
name|d_ptr
operator|->
name|active_engine
operator|&&
name|d_ptr
operator|->
name|active_engine
operator|->
name|type
argument_list|()
operator|==
name|QPaintEngine
operator|::
name|OpenGL2
condition|)
block|{
name|QGL2PaintEngineEx
modifier|*
name|eng
init|=
cast|static_cast
argument_list|<
name|QGL2PaintEngineEx
operator|*
argument_list|>
argument_list|(
name|d_ptr
operator|->
name|active_engine
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|eng
operator|->
name|isNativePaintingActive
argument_list|()
condition|)
block|{
name|QRectF
name|src
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|target
operator|.
name|width
argument_list|()
argument_list|,
name|target
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|QSize
name|size
argument_list|(
name|target
operator|.
name|width
argument_list|()
argument_list|,
name|target
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|eng
operator|->
name|drawTexture
argument_list|(
name|target
argument_list|,
name|textureId
argument_list|,
name|size
argument_list|,
name|src
argument_list|)
condition|)
return|return;
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
if|if
condition|(
name|textureTarget
operator|!=
name|GL_TEXTURE_2D
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLContext::drawTexture(): texture target must be GL_TEXTURE_2D on OpenGL ES"
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
specifier|const
name|bool
name|wasEnabled
init|=
name|glIsEnabled
argument_list|(
name|GL_TEXTURE_2D
argument_list|)
decl_stmt|;
name|GLint
name|oldTexture
decl_stmt|;
name|glGetIntegerv
argument_list|(
name|GL_TEXTURE_BINDING_2D
argument_list|,
operator|&
name|oldTexture
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|glEnable
argument_list|(
name|textureTarget
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|textureTarget
argument_list|,
name|textureId
argument_list|)
expr_stmt|;
name|qDrawTextureRect
argument_list|(
name|target
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|textureTarget
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
name|glDisable
argument_list|(
name|textureTarget
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|wasEnabled
condition|)
name|glDisable
argument_list|(
name|textureTarget
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|textureTarget
argument_list|,
name|oldTexture
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|textureId
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|textureTarget
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"drawTexture() with OpenGL ES 2.0 requires an active OpenGL2 paint engine"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \since 4.4      This function supports the following use cases:      \list     \li By default it draws the given texture, \a textureId,     at the given \a point in OpenGL model space. The     \a textureTarget should be a 2D texture target.     \li If a painter is active, not inside a     beginNativePainting / endNativePainting block, and uses the     engine with type QPaintEngine::OpenGL2, the function will draw the given     texture, \a textureId, at the given \a point,     respecting the current painter state. This will let you draw a texture     with the clip, transform, render hints, and composition mode set by the     painter. Note that the texture target needs to be GL_TEXTURE_2D for this     use case.     \endlist      \note This function is not supported under any version of OpenGL ES. */
end_comment
begin_function
DECL|function|drawTexture
name|void
name|QGLContext
operator|::
name|drawTexture
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|,
name|GLuint
name|textureId
parameter_list|,
name|GLenum
name|textureTarget
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
name|Q_UNUSED
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|textureId
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|textureTarget
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"drawTexture(const QPointF&point, GLuint textureId, GLenum textureTarget) not supported with OpenGL ES, use rect version instead"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|const
name|bool
name|wasEnabled
init|=
name|glIsEnabled
argument_list|(
name|GL_TEXTURE_2D
argument_list|)
decl_stmt|;
name|GLint
name|oldTexture
decl_stmt|;
name|glGetIntegerv
argument_list|(
name|GL_TEXTURE_BINDING_2D
argument_list|,
operator|&
name|oldTexture
argument_list|)
expr_stmt|;
name|glEnable
argument_list|(
name|textureTarget
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|textureTarget
argument_list|,
name|textureId
argument_list|)
expr_stmt|;
name|GLint
name|textureWidth
decl_stmt|;
name|GLint
name|textureHeight
decl_stmt|;
name|glGetTexLevelParameteriv
argument_list|(
name|textureTarget
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_WIDTH
argument_list|,
operator|&
name|textureWidth
argument_list|)
expr_stmt|;
name|glGetTexLevelParameteriv
argument_list|(
name|textureTarget
argument_list|,
literal|0
argument_list|,
name|GL_TEXTURE_HEIGHT
argument_list|,
operator|&
name|textureHeight
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|active_engine
operator|&&
name|d_ptr
operator|->
name|active_engine
operator|->
name|type
argument_list|()
operator|==
name|QPaintEngine
operator|::
name|OpenGL2
condition|)
block|{
name|QGL2PaintEngineEx
modifier|*
name|eng
init|=
cast|static_cast
argument_list|<
name|QGL2PaintEngineEx
operator|*
argument_list|>
argument_list|(
name|d_ptr
operator|->
name|active_engine
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|eng
operator|->
name|isNativePaintingActive
argument_list|()
condition|)
block|{
name|QRectF
name|dest
argument_list|(
name|point
argument_list|,
name|QSizeF
argument_list|(
name|textureWidth
argument_list|,
name|textureHeight
argument_list|)
argument_list|)
decl_stmt|;
name|QRectF
name|src
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|textureWidth
argument_list|,
name|textureHeight
argument_list|)
decl_stmt|;
name|QSize
name|size
argument_list|(
name|textureWidth
argument_list|,
name|textureHeight
argument_list|)
decl_stmt|;
if|if
condition|(
name|eng
operator|->
name|drawTexture
argument_list|(
name|dest
argument_list|,
name|textureId
argument_list|,
name|size
argument_list|,
name|src
argument_list|)
condition|)
return|return;
block|}
block|}
name|qDrawTextureRect
argument_list|(
name|QRectF
argument_list|(
name|point
argument_list|,
name|QSizeF
argument_list|(
name|textureWidth
argument_list|,
name|textureHeight
argument_list|)
argument_list|)
argument_list|,
name|textureWidth
argument_list|,
name|textureHeight
argument_list|,
name|textureTarget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wasEnabled
condition|)
name|glDisable
argument_list|(
name|textureTarget
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|textureTarget
argument_list|,
name|oldTexture
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     This function sets the limit for the texture cache to \a size,     expressed in kilobytes.      By default, the cache limit is approximately 64 MB.      \sa textureCacheLimit() */
end_comment
begin_function
DECL|function|setTextureCacheLimit
name|void
name|QGLContext
operator|::
name|setTextureCacheLimit
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|QGLTextureCache
operator|::
name|instance
argument_list|()
operator|->
name|setMaxCost
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current texture cache limit in kilobytes.      \sa setTextureCacheLimit() */
end_comment
begin_function
DECL|function|textureCacheLimit
name|int
name|QGLContext
operator|::
name|textureCacheLimit
parameter_list|()
block|{
return|return
name|QGLTextureCache
operator|::
name|instance
argument_list|()
operator|->
name|maxCost
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGLFormat QGLContext::format() const      Returns the frame buffer format that was obtained (this may be a     subset of what was requested).      \sa requestedFormat() */
end_comment
begin_comment
comment|/*!     \fn QGLFormat QGLContext::requestedFormat() const      Returns the frame buffer format that was originally requested in     the constructor or setFormat().      \sa format() */
end_comment
begin_comment
comment|/*!     Sets a \a format for this context. The context is \l{reset()}{reset}.      Call create() to create a new GL context that tries to match the     new format.      \snippet code/src_opengl_qgl.cpp 7      \sa format(), reset(), create() */
end_comment
begin_function
DECL|function|setFormat
name|void
name|QGLContext
operator|::
name|setFormat
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|format
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
name|d
operator|->
name|glFormat
operator|=
name|d
operator|->
name|reqFormat
operator|=
name|format
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setDevice
name|void
name|QGLContext
operator|::
name|setDevice
parameter_list|(
name|QPaintDevice
modifier|*
name|pDev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|isValid
argument_list|()
condition|)
name|reset
argument_list|()
expr_stmt|;
name|d
operator|->
name|paintDevice
operator|=
name|pDev
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|paintDevice
operator|&&
operator|(
name|d
operator|->
name|paintDevice
operator|->
name|devType
argument_list|()
operator|!=
name|QInternal
operator|::
name|Widget
operator|&&
name|d
operator|->
name|paintDevice
operator|->
name|devType
argument_list|()
operator|!=
name|QInternal
operator|::
name|Pixmap
operator|&&
name|d
operator|->
name|paintDevice
operator|->
name|devType
argument_list|()
operator|!=
name|QInternal
operator|::
name|Pbuffer
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLContext: Unsupported paint device type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLContext::isValid() const      Returns true if a GL rendering context has been successfully     created; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn void QGLContext::setValid(bool valid)     \internal      Forces the GL rendering context to be valid. */
end_comment
begin_comment
comment|/*!     \fn bool QGLContext::isSharing() const      Returns true if this context is sharing its GL context with     another QGLContext, otherwise false is returned. Note that context     sharing might not be supported between contexts with different     formats. */
end_comment
begin_comment
comment|/*!     Returns true if \a context1 and \a context2 are sharing their     GL resources such as textures, shader programs, etc;     otherwise returns false.      \since 4.6 */
end_comment
begin_function
DECL|function|areSharing
name|bool
name|QGLContext
operator|::
name|areSharing
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|context1
parameter_list|,
specifier|const
name|QGLContext
modifier|*
name|context2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context1
operator|||
operator|!
name|context2
condition|)
return|return
literal|false
return|;
return|return
name|context1
operator|->
name|d_ptr
operator|->
name|group
operator|==
name|context2
operator|->
name|d_ptr
operator|->
name|group
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLContext::deviceIsPixmap() const      Returns true if the paint device of this context is a pixmap;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QGLContext::windowCreated() const      Returns true if a window has been created for this context;     otherwise returns false.      \sa setWindowCreated() */
end_comment
begin_comment
comment|/*!     \fn void QGLContext::setWindowCreated(bool on)      If \a on is true the context has had a window created for it. If     \a on is false no window has been created for the context.      \sa windowCreated() */
end_comment
begin_comment
comment|/*!     \fn uint QGLContext::colorIndex(const QColor& c) const      \internal      Returns a colormap index for the color c, in ColorIndex mode. Used     by qglColor() and qglClearColor(). */
end_comment
begin_comment
comment|/*!     \fn bool QGLContext::initialized() const      Returns true if this context has been initialized, i.e. if     QGLWidget::initializeGL() has been performed on it; otherwise     returns false.      \sa setInitialized() */
end_comment
begin_comment
comment|/*!     \fn void QGLContext::setInitialized(bool on)      If \a on is true the context has been initialized, i.e.     QGLContext::setInitialized() has been called on it. If \a on is     false the context has not been initialized.      \sa initialized() */
end_comment
begin_comment
comment|/*!     \fn const QGLContext* QGLContext::currentContext()      Returns the current context, i.e. the context to which any OpenGL     commands will currently be directed. Returns 0 if no context is     current.      \sa makeCurrent() */
end_comment
begin_comment
comment|/*!     \fn QColor QGLContext::overlayTransparentColor() const      If this context is a valid context in an overlay plane, returns     the plane's transparent color. Otherwise returns an \l{QColor::isValid()}{invalid} color.      The returned color's \l{QColor::pixel()}{pixel} value is     the index of the transparent color in the colormap of the overlay     plane. (Naturally, the color's RGB values are meaningless.)      The returned QColor object will generally work as expected only     when passed as the argument to QGLWidget::qglColor() or     QGLWidget::qglClearColor(). Under certain circumstances it can     also be used to draw transparent graphics with a QPainter. See the     examples/opengl/overlay_x11 example for details. */
end_comment
begin_comment
comment|/*!     Creates the GL context. Returns true if it was successful in     creating a valid GL rendering context on the paint device     specified in the constructor; otherwise returns false (i.e. the     context is invalid).      If the OpenGL implementation on your system does not support the requested     version of OpenGL context, then QGLContext will try to create the closest     matching version. The actual created context properties can be queried     using the QGLFormat returned by the format() function. For example, if     you request a context that supports OpenGL 4.3 Core profile but the driver     and/or hardware only supports version 3.2 Core profile contexts then you will     get a 3.2 Core profile context.      After successful creation, format() returns the set of features of     the created GL rendering context.      If \a shareContext points to a valid QGLContext, this method will     try to establish OpenGL display list and texture object sharing     between this context and the \a shareContext. Note that this may     fail if the two contexts have different \l {format()} {formats}.     Use isSharing() to see if sharing is in effect.      \warning Implementation note: initialization of C++ class     members usually takes place in the class constructor. QGLContext     is an exception because it must be simple to customize. The     virtual functions chooseContext() (and chooseVisual() for X11) can     be reimplemented in a subclass to select a particular context. The     problem is that virtual functions are not properly called during     construction (even though this is correct C++) because C++     constructs class hierarchies from the bottom up. For this reason     we need a create() function.      \sa chooseContext(), format(), isValid() */
end_comment
begin_function
DECL|function|create
name|bool
name|QGLContext
operator|::
name|create
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|shareContext
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|paintDevice
operator|&&
operator|!
name|d
operator|->
name|guiGlContext
condition|)
return|return
literal|false
return|;
name|reset
argument_list|()
expr_stmt|;
name|d
operator|->
name|valid
operator|=
name|chooseContext
argument_list|(
name|shareContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|valid
operator|&&
name|d
operator|->
name|paintDevice
operator|&&
name|d
operator|->
name|paintDevice
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Widget
condition|)
block|{
name|QWidgetPrivate
modifier|*
name|wd
init|=
name|qt_widget_private
argument_list|(
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|paintDevice
argument_list|)
argument_list|)
decl_stmt|;
name|wd
operator|->
name|usesDoubleBufferedGLContext
operator|=
name|d
operator|->
name|glFormat
operator|.
name|doubleBuffer
argument_list|()
expr_stmt|;
block|}
return|return
name|d
operator|->
name|valid
return|;
block|}
end_function
begin_function
DECL|function|isValid
name|bool
name|QGLContext
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|valid
return|;
block|}
end_function
begin_function
DECL|function|setValid
name|void
name|QGLContext
operator|::
name|setValid
parameter_list|(
name|bool
name|valid
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|valid
operator|=
name|valid
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isSharing
name|bool
name|QGLContext
operator|::
name|isSharing
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|group
operator|->
name|isSharing
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|format
name|QGLFormat
name|QGLContext
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|glFormat
return|;
block|}
end_function
begin_function
DECL|function|requestedFormat
name|QGLFormat
name|QGLContext
operator|::
name|requestedFormat
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|reqFormat
return|;
block|}
end_function
begin_function
DECL|function|device
name|QPaintDevice
modifier|*
name|QGLContext
operator|::
name|device
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|paintDevice
return|;
block|}
end_function
begin_function
DECL|function|deviceIsPixmap
name|bool
name|QGLContext
operator|::
name|deviceIsPixmap
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|paintDevice
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Pixmap
return|;
block|}
end_function
begin_function
DECL|function|windowCreated
name|bool
name|QGLContext
operator|::
name|windowCreated
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|crWin
return|;
block|}
end_function
begin_function
DECL|function|setWindowCreated
name|void
name|QGLContext
operator|::
name|setWindowCreated
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|crWin
operator|=
name|on
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initialized
name|bool
name|QGLContext
operator|::
name|initialized
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLContext
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|initDone
return|;
block|}
end_function
begin_function
DECL|function|setInitialized
name|void
name|QGLContext
operator|::
name|setInitialized
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|d
operator|->
name|initDone
operator|=
name|on
expr_stmt|;
block|}
end_function
begin_function
DECL|function|currentContext
specifier|const
name|QGLContext
modifier|*
name|QGLContext
operator|::
name|currentContext
parameter_list|()
block|{
if|if
condition|(
specifier|const
name|QOpenGLContext
modifier|*
name|threadContext
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
condition|)
block|{
return|return
name|QGLContext
operator|::
name|fromOpenGLContext
argument_list|(
cast|const_cast
argument_list|<
name|QOpenGLContext
operator|*
argument_list|>
argument_list|(
name|threadContext
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|setCurrentContext
name|void
name|QGLContextPrivate
operator|::
name|setCurrentContext
parameter_list|(
name|QGLContext
modifier|*
name|context
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Moves the QGLContext to the given \a thread.      Enables calling swapBuffers() and makeCurrent() on the context in     the given thread. */
end_comment
begin_function
DECL|function|moveToThread
name|void
name|QGLContext
operator|::
name|moveToThread
parameter_list|(
name|QThread
modifier|*
name|thread
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|guiGlContext
condition|)
name|d
operator|->
name|guiGlContext
operator|->
name|moveToThread
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLContext::chooseContext(const QGLContext* shareContext = 0)      This semi-internal function is called by create(). It creates a     system-dependent OpenGL handle that matches the format() of \a     shareContext as closely as possible, returning true if successful     or false if a suitable handle could not be found.      On Windows, it calls the virtual function choosePixelFormat(),     which finds a matching pixel format identifier. On X11, it calls     the virtual function chooseVisual() which finds an appropriate X     visual. On other platforms it may work differently. */
end_comment
begin_comment
comment|/*! \fn int QGLContext::choosePixelFormat(void* dummyPfd, HDC pdc)      \b{Win32 only:} This virtual function chooses a pixel format     that matches the OpenGL \l{setFormat()}{format}.     Reimplement this function in a subclass if you need a custom     context.      \warning The \a dummyPfd pointer and \a pdc are used as a \c     PIXELFORMATDESCRIPTOR*. We use \c void to avoid using     Windows-specific types in our header files.      \sa chooseContext() */
end_comment
begin_comment
comment|/*! \fn void *QGLContext::chooseVisual()    \b{X11 only:} This virtual function tries to find a visual that   matches the format, reducing the demands if the original request   cannot be met.    The algorithm for reducing the demands of the format is quite   simple-minded, so override this method in your subclass if your   application has spcific requirements on visual selection.    \sa chooseContext() */
end_comment
begin_comment
comment|/*! \fn void *QGLContext::tryVisual(const QGLFormat& f, int bufDepth)   \internal    \b{X11 only:} This virtual function chooses a visual that matches   the OpenGL \l{format()}{format}. Reimplement this function   in a subclass if you need a custom visual.    \sa chooseContext() */
end_comment
begin_comment
comment|/*!     \fn void QGLContext::reset()      Resets the context and makes it invalid.      \sa create(), isValid() */
end_comment
begin_comment
comment|/*!     \fn void QGLContext::makeCurrent()      Makes this context the current OpenGL rendering context. All GL     functions you call operate on this context until another context     is made current.      In some very rare cases the underlying call may fail. If this     occurs an error message is output to stderr.      If you call this from a thread other than the main UI thread,     make sure you've first pushed the context to the relevant thread     from the UI thread using moveToThread(). */
end_comment
begin_comment
comment|/*!     \fn void QGLContext::swapBuffers() const      Call this to finish a frame of OpenGL rendering, and make sure to     call makeCurrent() again before you begin a new frame. */
end_comment
begin_comment
comment|/*!     \fn void QGLContext::doneCurrent()      Makes no GL context the current context. Normally, you do not need     to call this function; QGLContext calls it as necessary. */
end_comment
begin_comment
comment|/*!     \fn QPaintDevice* QGLContext::device() const      Returns the paint device set for this context.      \sa QGLContext::QGLContext() */
end_comment
begin_comment
comment|/*****************************************************************************   QGLWidget implementation  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QGLWidget     \inmodule QtOpenGL      \brief The QGLWidget class is a widget for rendering OpenGL graphics.      QGLWidget provides functionality for displaying OpenGL graphics     integrated into a Qt application. It is very simple to use. You     inherit from it and use the subclass like any other QWidget,     except that you have the choice between using QPainter and     standard OpenGL rendering commands.      QGLWidget provides three convenient virtual functions that you can     reimplement in your subclass to perform the typical OpenGL tasks:      \list     \li paintGL() - Renders the OpenGL scene. Gets called whenever the widget     needs to be updated.     \li resizeGL() - Sets up the OpenGL viewport, projection, etc. Gets     called whenever the widget has been resized (and also when it     is shown for the first time because all newly created widgets get a     resize event automatically).     \li initializeGL() - Sets up the OpenGL rendering context, defines display     lists, etc. Gets called once before the first time resizeGL() or     paintGL() is called.     \endlist      Here is a rough outline of how a QGLWidget subclass might look:      \snippet code/src_opengl_qgl.cpp 8      If you need to trigger a repaint from places other than paintGL()     (a typical example is when using \l{QTimer}{timers} to     animate scenes), you should call the widget's updateGL() function.      Your widget's OpenGL rendering context is made current when     paintGL(), resizeGL(), or initializeGL() is called. If you need to     call the standard OpenGL API functions from other places (e.g. in     your widget's constructor or in your own paint functions), you     must call makeCurrent() first.      QGLWidget provides functions for requesting a new display     \l{QGLFormat}{format} and you can also create widgets with     customized rendering \l{QGLContext}{contexts}.      You can also share OpenGL display lists between QGLWidget objects (see     the documentation of the QGLWidget constructors for details).      Note that under Windows, the QGLContext belonging to a QGLWidget     has to be recreated when the QGLWidget is reparented. This is     necessary due to limitations on the Windows platform. This will     most likely cause problems for users that have subclassed and     installed their own QGLContext on a QGLWidget. It is possible to     work around this issue by putting the QGLWidget inside a dummy     widget and then reparenting the dummy widget, instead of the     QGLWidget. This will side-step the issue altogether, and is what     we recommend for users that need this kind of functionality.      On Mac OS X, when Qt is built with Cocoa support, a QGLWidget     can't have any sibling widgets placed ontop of itself. This is due     to limitations in the Cocoa API and is not supported by Apple.      \section1 Overlays      The QGLWidget creates a GL overlay context in addition to the     normal context if overlays are supported by the underlying system.      If you want to use overlays, you specify it in the     \l{QGLFormat}{format}. (Note: Overlay must be requested in the format     passed to the QGLWidget constructor.) Your GL widget should also     implement some or all of these virtual methods:      \list     \li paintOverlayGL()     \li resizeOverlayGL()     \li initializeOverlayGL()     \endlist      These methods work in the same way as the normal paintGL() etc.     functions, except that they will be called when the overlay     context is made current. You can explicitly make the overlay     context current by using makeOverlayCurrent(), and you can access     the overlay context directly (e.g. to ask for its transparent     color) by calling overlayContext().      On X servers in which the default visual is in an overlay plane,     non-GL Qt windows can also be used for overlays.      \section1 Painting Techniques      As described above, subclass QGLWidget to render pure 3D content in the     following way:      \list     \li Reimplement the QGLWidget::initializeGL() and QGLWidget::resizeGL() to        set up the OpenGL state and provide a perspective transformation.     \li Reimplement QGLWidget::paintGL() to paint the 3D scene, calling only        OpenGL functions to draw on the widget.     \endlist      It is also possible to draw 2D graphics onto a QGLWidget subclass, it is necessary     to reimplement QGLWidget::paintEvent() and do the following:      \list     \li Construct a QPainter object.     \li Initialize it for use on the widget with the QPainter::begin() function.     \li Draw primitives using QPainter's member functions.     \li Call QPainter::end() to finish painting.     \endlist      Overpainting 2D content on top of 3D content takes a little more effort.     One approach to doing this is shown in the     \l{Overpainting Example}{Overpainting} example.      \section1 Threading      As of Qt version 4.8, support for doing threaded GL rendering has     been improved. There are three scenarios that we currently support:     \list     \li 1. Buffer swapping in a thread.      Swapping buffers in a double buffered context may be a     synchronous, locking call that may be a costly operation in some     GL implementations. Especially so on embedded devices. It's not     optimal to have the CPU idling while the GPU is doing a buffer     swap. In those cases it is possible to do the rendering in the     main thread and do the actual buffer swap in a separate     thread. This can be done with the following steps:      1. Call doneCurrent() in the main thread when the rendering is     finished.      2. Call QGLContext::moveToThread(swapThread) to transfer ownership     of the context to the swapping thread.      3. Notify the swapping thread that it can grab the context.      4. Make the rendering context current in the swapping thread with     makeCurrent() and then call swapBuffers().      5. Call doneCurrent() in the swapping thread.      6. Call QGLContext::moveToThread(qApp->thread()) and notify the     main thread that swapping is done.      Doing this will free up the main thread so that it can continue     with, for example, handling UI events or network requests. Even if     there is a context swap involved, it may be preferable compared to     having the main thread wait while the GPU finishes the swap     operation. Note that this is highly implementation dependent.      \li 2. Texture uploading in a thread.      Doing texture uploads in a thread may be very useful for     applications handling large amounts of images that needs to be     displayed, like for instance a photo gallery application. This is     supported in Qt through the existing bindTexture() API. A simple     way of doing this is to create two sharing QGLWidgets. One is made     current in the main GUI thread, while the other is made current in     the texture upload thread. The widget in the uploading thread is     never shown, it is only used for sharing textures with the main     thread. For each texture that is bound via bindTexture(), notify     the main thread so that it can start using the texture.      \li 3. Using QPainter to draw into a QGLWidget in a thread.      In Qt 4.8, it is possible to draw into a QGLWidget using a     QPainter in a separate thread. Note that this is also possible for     QGLPixelBuffers and QGLFramebufferObjects. Since this is only     supported in the GL 2 paint engine, OpenGL 2.0 or OpenGL ES 2.0 is     required.      QGLWidgets can only be created in the main GUI thread. This means     a call to doneCurrent() is necessary to release the GL context     from the main thread, before the widget can be drawn into by     another thread. You then need to call QGLContext::moveToThread()     to transfer ownership of the context to the thread in which you     want to make it current.     Also, the main GUI thread will dispatch resize and     paint events to a QGLWidget when the widget is resized, or parts     of it becomes exposed or needs redrawing. It is therefore     necessary to handle those events because the default     implementations inside QGLWidget will try to make the QGLWidget's     context current, which again will interfere with any threads     rendering into the widget. Reimplement QGLWidget::paintEvent() and     QGLWidget::resizeEvent() to notify the rendering thread that a     resize or update is necessary, and be careful not to call the base     class implementation. If you are rendering an animation, it might     not be necessary to handle the paint event at all since the     rendering thread is doing regular updates. Then it would be enough     to reimplement QGLWidget::paintEvent() to do nothing.      \endlist      As a general rule when doing threaded rendering: be aware that     binding and releasing contexts in different threads have to be     synchronized by the user. A GL rendering context can only be     current in one thread at any time. If you try to open a QPainter     on a QGLWidget and the widget's rendering context is current in     another thread, it will fail.      In addition to this, rendering using raw GL calls in a separate     thread is supported.      \e{OpenGL is a trademark of Silicon Graphics, Inc. in the United States and other     countries.}      \sa QGLPixelBuffer, {Hello GL Example}, {2D Painting Example}, {Overpainting Example},         {Grabber Example} */
end_comment
begin_comment
comment|/*!     Constructs an OpenGL widget with a \a parent widget.      The \l{QGLFormat::defaultFormat()}{default format} is     used. The widget will be \l{isValid()}{invalid} if the     system has no \l{QGLFormat::hasOpenGL()}{OpenGL support}.      The \a parent and widget flag, \a f, arguments are passed     to the QWidget constructor.      If \a shareWidget is a valid QGLWidget, this widget will share     OpenGL display lists and texture objects with \a shareWidget. But     if \a shareWidget and this widget have different \l {format()}     {formats}, sharing might not be possible. You can check whether     sharing is in effect by calling isSharing().      The initialization of OpenGL rendering state, etc. should be done     by overriding the initializeGL() function, rather than in the     constructor of your QGLWidget subclass.      \sa QGLFormat::defaultFormat(), {Textures Example} */
end_comment
begin_constructor
DECL|function|QGLWidget
name|QGLWidget
operator|::
name|QGLWidget
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|,
specifier|const
name|QGLWidget
modifier|*
name|shareWidget
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|f
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|(
operator|new
name|QGLWidgetPrivate
operator|)
argument_list|,
name|parent
argument_list|,
name|f
operator||
name|Qt
operator|::
name|MSWindowsOwnDC
argument_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_PaintOnScreen
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoSystemBackground
argument_list|)
expr_stmt|;
name|setAutoFillBackground
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// for compatibility
name|d
operator|->
name|init
argument_list|(
operator|new
name|QGLContext
argument_list|(
name|QGLFormat
operator|::
name|defaultFormat
argument_list|()
argument_list|,
name|this
argument_list|)
argument_list|,
name|shareWidget
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   \internal  */
end_comment
begin_constructor
DECL|function|QGLWidget
name|QGLWidget
operator|::
name|QGLWidget
parameter_list|(
name|QGLWidgetPrivate
modifier|&
name|dd
parameter_list|,
specifier|const
name|QGLFormat
modifier|&
name|format
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|,
specifier|const
name|QGLWidget
modifier|*
name|shareWidget
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|f
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|,
name|f
operator||
name|Qt
operator|::
name|MSWindowsOwnDC
argument_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_PaintOnScreen
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoSystemBackground
argument_list|)
expr_stmt|;
name|setAutoFillBackground
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// for compatibility
name|d
operator|->
name|init
argument_list|(
operator|new
name|QGLContext
argument_list|(
name|format
argument_list|,
name|this
argument_list|)
argument_list|,
name|shareWidget
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an OpenGL widget with parent \a parent.      The \a format argument specifies the desired     \l{QGLFormat}{rendering options}.     If the underlying OpenGL/Window system     cannot satisfy all the features requested in \a format, the     nearest subset of features will be used. After creation, the     format() method will return the actual format obtained.      The widget will be \l{isValid()}{invalid} if the system     has no \l{QGLFormat::hasOpenGL()}{OpenGL support}.      The \a parent and widget flag, \a f, arguments are passed     to the QWidget constructor.      If \a shareWidget is a valid QGLWidget, this widget will share     OpenGL display lists and texture objects with \a shareWidget. But     if \a shareWidget and this widget have different \l {format()}     {formats}, sharing might not be possible. You can check whether     sharing is in effect by calling isSharing().      The initialization of OpenGL rendering state, etc. should be done     by overriding the initializeGL() function, rather than in the     constructor of your QGLWidget subclass.      \sa QGLFormat::defaultFormat(), isValid() */
end_comment
begin_constructor
DECL|function|QGLWidget
name|QGLWidget
operator|::
name|QGLWidget
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|format
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|,
specifier|const
name|QGLWidget
modifier|*
name|shareWidget
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|f
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|(
operator|new
name|QGLWidgetPrivate
operator|)
argument_list|,
name|parent
argument_list|,
name|f
operator||
name|Qt
operator|::
name|MSWindowsOwnDC
argument_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_PaintOnScreen
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoSystemBackground
argument_list|)
expr_stmt|;
name|setAutoFillBackground
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// for compatibility
name|d
operator|->
name|init
argument_list|(
operator|new
name|QGLContext
argument_list|(
name|format
argument_list|,
name|this
argument_list|)
argument_list|,
name|shareWidget
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an OpenGL widget with parent \a parent.      The \a context argument is a pointer to the QGLContext that     you wish to be bound to this widget. This allows you to pass in     your own QGLContext sub-classes.      The widget will be \l{isValid()}{invalid} if the system     has no \l{QGLFormat::hasOpenGL()}{OpenGL support}.      The \a parent and widget flag, \a f, arguments are passed     to the QWidget constructor.      If \a shareWidget is a valid QGLWidget, this widget will share     OpenGL display lists and texture objects with \a shareWidget. But     if \a shareWidget and this widget have different \l {format()}     {formats}, sharing might not be possible. You can check whether     sharing is in effect by calling isSharing().      The initialization of OpenGL rendering state, etc. should be done     by overriding the initializeGL() function, rather than in the     constructor of your QGLWidget subclass.      \sa QGLFormat::defaultFormat(), isValid() */
end_comment
begin_constructor
DECL|function|QGLWidget
name|QGLWidget
operator|::
name|QGLWidget
parameter_list|(
name|QGLContext
modifier|*
name|context
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|,
specifier|const
name|QGLWidget
modifier|*
name|shareWidget
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|f
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|(
operator|new
name|QGLWidgetPrivate
operator|)
argument_list|,
name|parent
argument_list|,
name|f
operator||
name|Qt
operator|::
name|MSWindowsOwnDC
argument_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_PaintOnScreen
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoSystemBackground
argument_list|)
expr_stmt|;
name|setAutoFillBackground
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// for compatibility
name|d
operator|->
name|init
argument_list|(
name|context
argument_list|,
name|shareWidget
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the widget. */
end_comment
begin_destructor
DECL|function|~QGLWidget
name|QGLWidget
operator|::
name|~
name|QGLWidget
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|glcx
expr_stmt|;
name|d
operator|->
name|glcx
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|cleanupColormaps
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn QGLFormat QGLWidget::format() const      Returns the format of the contained GL rendering context. */
end_comment
begin_comment
comment|/*!     \fn bool QGLWidget::doubleBuffer() const      Returns true if the contained GL rendering context has double     buffering; otherwise returns false.      \sa QGLFormat::doubleBuffer() */
end_comment
begin_comment
comment|/*!     \fn void QGLWidget::setAutoBufferSwap(bool on)      If \a on is true automatic GL buffer swapping is switched on;     otherwise it is switched off.      If \a on is true and the widget is using a double-buffered format,     the background and foreground GL buffers will automatically be     swapped after each paintGL() call.      The buffer auto-swapping is on by default.      \sa autoBufferSwap(), doubleBuffer(), swapBuffers() */
end_comment
begin_comment
comment|/*!     \fn bool QGLWidget::autoBufferSwap() const      Returns true if the widget is doing automatic GL buffer swapping;     otherwise returns false.      \sa setAutoBufferSwap() */
end_comment
begin_comment
comment|/*!     \fn QFunctionPointer QGLContext::getProcAddress() const      Returns a function pointer to the GL extension function passed in     \a proc. 0 is returned if a pointer to the function could not be     obtained. */
end_comment
begin_comment
comment|/*!     \fn bool QGLWidget::isValid() const      Returns true if the widget has a valid GL rendering context;     otherwise returns false. A widget will be invalid if the system     has no \l{QGLFormat::hasOpenGL()}{OpenGL support}. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QGLWidget
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|glcx
operator|&&
name|d
operator|->
name|glcx
operator|->
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLWidget::isSharing() const      Returns true if this widget's GL context is shared with another GL     context, otherwise false is returned. Context sharing might not be     possible if the widgets use different formats.      \sa format() */
end_comment
begin_function
DECL|function|isSharing
name|bool
name|QGLWidget
operator|::
name|isSharing
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|glcx
operator|->
name|isSharing
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGLWidget::makeCurrent()      Makes this widget the current widget for OpenGL operations, i.e.     makes the widget's rendering context the current OpenGL rendering     context. */
end_comment
begin_function
DECL|function|makeCurrent
name|void
name|QGLWidget
operator|::
name|makeCurrent
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|glcx
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGLWidget::doneCurrent()      Makes no GL context the current context. Normally, you do not need     to call this function; QGLContext calls it as necessary. However,     it may be useful in multithreaded environments. */
end_comment
begin_function
DECL|function|doneCurrent
name|void
name|QGLWidget
operator|::
name|doneCurrent
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|glcx
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGLWidget::swapBuffers()      Swaps the screen contents with an off-screen buffer. This only     works if the widget's format specifies double buffer mode.      Normally, there is no need to explicitly call this function     because it is done automatically after each widget repaint, i.e.     each time after paintGL() has been executed.      \sa doubleBuffer(), setAutoBufferSwap(), QGLFormat::setDoubleBuffer() */
end_comment
begin_function
DECL|function|swapBuffers
name|void
name|QGLWidget
operator|::
name|swapBuffers
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|glcx
operator|->
name|swapBuffers
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn const QGLContext* QGLWidget::overlayContext() const      Returns the overlay context of this widget, or 0 if this widget     has no overlay.      \sa context() */
end_comment
begin_comment
comment|/*!     \fn void QGLWidget::makeOverlayCurrent()      Makes the overlay context of this widget current. Use this if you     need to issue OpenGL commands to the overlay context outside of     initializeOverlayGL(), resizeOverlayGL(), and paintOverlayGL().      Does nothing if this widget has no overlay.      \sa makeCurrent() */
end_comment
begin_comment
comment|/*!   \obsolete    Sets a new format for this widget.    If the underlying OpenGL/Window system cannot satisfy all the   features requested in \a format, the nearest subset of features will   be used. After creation, the format() method will return the actual   rendering context format obtained.    The widget will be assigned a new QGLContext, and the initializeGL()   function will be executed for this new context before the first   resizeGL() or paintGL().    This method will try to keep display list and texture object sharing   in effect with other QGLWidget objects, but changing the format might make   sharing impossible. Use isSharing() to see if sharing is still in   effect.    \sa format(), isSharing(), isValid() */
end_comment
begin_function
DECL|function|setFormat
name|void
name|QGLWidget
operator|::
name|setFormat
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|format
parameter_list|)
block|{
name|setContext
argument_list|(
operator|new
name|QGLContext
argument_list|(
name|format
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QGLContext *QGLWidget::context() const      Returns the context of this widget.      It is possible that the context is not valid (see isValid()), for     example, if the underlying hardware does not support the format     attributes that were requested. */
end_comment
begin_comment
comment|/*!   \fn void QGLWidget::setContext(QGLContext *context,                                  const QGLContext* shareContext,                                  bool deleteOldContext)   \obsolete    Sets a new context for this widget. The QGLContext \a context must   be created using \e new. QGLWidget will delete \a context when   another context is set or when the widget is destroyed.    If \a context is invalid, QGLContext::create() is performed on   it. The initializeGL() function will then be executed for the new   context before the first resizeGL() or paintGL().    If \a context is invalid, this method will try to keep display list   and texture object sharing in effect, or (if \a shareContext points   to a valid context) start display list and texture object sharing   with that context, but sharing might be impossible if the two   contexts have different \l {format()} {formats}. Use isSharing() to   see whether sharing is in effect.    If \a deleteOldContext is true (the default), the existing context   will be deleted. You may use false here if you have kept a pointer   to the old context (as returned by context()), and want to restore   that context later.    \note This function is obsolete and should no longer be used. If you were   using it to recreate the context for a QGLWidget, you should instead create a   new QGLWidget or use the QOpenGLContext API in conjunction with QWindow.   There is currently no officially supported way to substitute QGLWidget's   context with your own implementation of QGLContext.    \sa context(), isSharing() */
end_comment
begin_comment
comment|/*!     \fn void QGLWidget::updateGL()      Updates the widget by calling glDraw(). */
end_comment
begin_function
DECL|function|updateGL
name|void
name|QGLWidget
operator|::
name|updateGL
parameter_list|()
block|{
if|if
condition|(
name|updatesEnabled
argument_list|()
operator|&&
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Mapped
argument_list|)
condition|)
name|glDraw
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGLWidget::updateOverlayGL()      Updates the widget's overlay (if any). Will cause the virtual     function paintOverlayGL() to be executed.      The widget's rendering context will become the current context and     initializeGL() will be called if it hasn't already been called. */
end_comment
begin_comment
comment|/*!     This virtual function is called once before the first call to     paintGL() or resizeGL(), and then once whenever the widget has     been assigned a new QGLContext. Reimplement it in a subclass.      This function should set up any required OpenGL context rendering     flags, defining display lists, etc.      There is no need to call makeCurrent() because this has already     been done when this function is called. */
end_comment
begin_function
DECL|function|initializeGL
name|void
name|QGLWidget
operator|::
name|initializeGL
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!     This virtual function is called whenever the widget needs to be     painted. Reimplement it in a subclass.      There is no need to call makeCurrent() because this has already     been done when this function is called. */
end_comment
begin_function
DECL|function|paintGL
name|void
name|QGLWidget
operator|::
name|paintGL
parameter_list|()
block|{
name|glClear
argument_list|(
name|GL_COLOR_BUFFER_BIT
operator||
name|GL_DEPTH_BUFFER_BIT
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGLWidget::resizeGL(int width , int height)      This virtual function is called whenever the widget has been     resized. The new size is passed in \a width and \a height.     Reimplement it in a subclass.      There is no need to call makeCurrent() because this has already     been done when this function is called. */
end_comment
begin_function
DECL|function|resizeGL
name|void
name|QGLWidget
operator|::
name|resizeGL
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     This virtual function is used in the same manner as initializeGL()     except that it operates on the widget's overlay context instead of     the widget's main context. This means that initializeOverlayGL()     is called once before the first call to paintOverlayGL() or     resizeOverlayGL(). Reimplement it in a subclass.      This function should set up any required OpenGL context rendering     flags, defining display lists, etc. for the overlay context.      There is no need to call makeOverlayCurrent() because this has     already been done when this function is called. */
end_comment
begin_function
DECL|function|initializeOverlayGL
name|void
name|QGLWidget
operator|::
name|initializeOverlayGL
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!     This virtual function is used in the same manner as paintGL()     except that it operates on the widget's overlay context instead of     the widget's main context. This means that paintOverlayGL() is     called whenever the widget's overlay needs to be painted.     Reimplement it in a subclass.      There is no need to call makeOverlayCurrent() because this has     already been done when this function is called. */
end_comment
begin_function
DECL|function|paintOverlayGL
name|void
name|QGLWidget
operator|::
name|paintOverlayGL
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!     \fn void QGLWidget::resizeOverlayGL(int width , int height)      This virtual function is used in the same manner as paintGL()     except that it operates on the widget's overlay context instead of     the widget's main context. This means that resizeOverlayGL() is     called whenever the widget has been resized. The new size is     passed in \a width and \a height. Reimplement it in a subclass.      There is no need to call makeOverlayCurrent() because this has     already been done when this function is called. */
end_comment
begin_function
DECL|function|resizeOverlayGL
name|void
name|QGLWidget
operator|::
name|resizeOverlayGL
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     \fn void QGLWidget::paintEvent(QPaintEvent *event)      Handles paint events passed in the \a event parameter. Will cause     the virtual paintGL() function to be called.      The widget's rendering context will become the current context and     initializeGL() will be called if it hasn't already been called. */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QGLWidget
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
block|{
if|if
condition|(
name|updatesEnabled
argument_list|()
condition|)
block|{
name|glDraw
argument_list|()
expr_stmt|;
name|updateOverlayGL
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QGLWidget::resizeEvent(QResizeEvent *event)      Handles resize events that are passed in the \a event parameter.     Calls the virtual function resizeGL(). */
end_comment
begin_comment
comment|/*!     \fn void QGLWidget::setMouseTracking(bool enable)      If \a enable is true then mouse tracking is enabled; otherwise it     is disabled. */
end_comment
begin_comment
comment|/*!     Renders the current scene on a pixmap and returns the pixmap.      You can use this method on both visible and invisible QGLWidget objects.      This method will create a pixmap and a temporary QGLContext to     render on the pixmap. It will then call initializeGL(),     resizeGL(), and paintGL() on this context. Finally, the widget's     original GL context is restored.      The size of the pixmap will be \a w pixels wide and \a h pixels     high unless one of these parameters is 0 (the default), in which     case the pixmap will have the same size as the widget.      If \a useContext is true, this method will try to be more     efficient by using the existing GL context to render the pixmap.     The default is false. Only use true if you understand the risks.     Note that under Windows a temporary context has to be created     and usage of the \e useContext parameter is not supported.      Overlays are not rendered onto the pixmap.      If the GL rendering context and the desktop have different bit     depths, the result will most likely look surprising.      Note that the creation of display lists, modifications of the view     frustum etc. should be done from within initializeGL(). If this is     not done, the temporary QGLContext will not be initialized     properly, and the rendered pixmap may be incomplete/corrupted. */
end_comment
begin_function
DECL|function|renderPixmap
name|QPixmap
name|QGLWidget
operator|::
name|renderPixmap
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|bool
name|useContext
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|QSize
name|sz
init|=
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|w
operator|>
literal|0
operator|)
operator|&&
operator|(
name|h
operator|>
literal|0
operator|)
condition|)
name|sz
operator|=
name|QSize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|QPixmap
name|pm
argument_list|(
name|sz
argument_list|)
decl_stmt|;
name|d
operator|->
name|glcx
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
name|bool
name|success
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|useContext
operator|&&
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|renderCxPm
argument_list|(
operator|&
name|pm
argument_list|)
condition|)
return|return
name|pm
return|;
name|QGLFormat
name|fmt
init|=
name|d
operator|->
name|glcx
operator|->
name|requestedFormat
argument_list|()
decl_stmt|;
name|fmt
operator|.
name|setDirectRendering
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Direct is unlikely to work
name|fmt
operator|.
name|setDoubleBuffer
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// We don't need dbl buf
name|QGLContext
modifier|*
name|ocx
init|=
name|d
operator|->
name|glcx
decl_stmt|;
name|ocx
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
name|d
operator|->
name|glcx
operator|=
operator|new
name|QGLContext
argument_list|(
name|fmt
argument_list|,
operator|&
name|pm
argument_list|)
expr_stmt|;
name|d
operator|->
name|glcx
operator|->
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|glcx
operator|->
name|isValid
argument_list|()
condition|)
name|updateGL
argument_list|()
expr_stmt|;
else|else
name|success
operator|=
literal|false
expr_stmt|;
operator|delete
name|d
operator|->
name|glcx
expr_stmt|;
name|d
operator|->
name|glcx
operator|=
name|ocx
expr_stmt|;
name|ocx
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
return|return
name|pm
return|;
block|}
return|return
name|QPixmap
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an image of the frame buffer. If \a withAlpha is true the     alpha channel is included.      Depending on your hardware, you can explicitly select which color     buffer to grab with a glReadBuffer() call before calling this     function. */
end_comment
begin_function
DECL|function|grabFrameBuffer
name|QImage
name|QGLWidget
operator|::
name|grabFrameBuffer
parameter_list|(
name|bool
name|withAlpha
parameter_list|)
block|{
name|makeCurrent
argument_list|()
expr_stmt|;
name|QImage
name|res
decl_stmt|;
name|qreal
name|pixelRatio
init|=
name|devicePixelRatio
argument_list|()
decl_stmt|;
name|int
name|w
init|=
name|pixelRatio
operator|*
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|pixelRatio
operator|*
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|format
argument_list|()
operator|.
name|rgba
argument_list|()
condition|)
name|res
operator|=
name|qt_gl_read_frame_buffer
argument_list|(
name|QSize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
argument_list|,
name|format
argument_list|()
operator|.
name|alpha
argument_list|()
argument_list|,
name|withAlpha
argument_list|)
expr_stmt|;
name|res
operator|.
name|setDevicePixelRatio
argument_list|(
name|pixelRatio
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*!     Initializes OpenGL for this widget's context. Calls the virtual     function initializeGL(). */
end_comment
begin_function
DECL|function|glInit
name|void
name|QGLWidget
operator|::
name|glInit
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return;
name|makeCurrent
argument_list|()
expr_stmt|;
name|initializeGL
argument_list|()
expr_stmt|;
name|d
operator|->
name|glcx
operator|->
name|setInitialized
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Executes the virtual function paintGL().      The widget's rendering context will become the current context and     initializeGL() will be called if it hasn't already been called. */
end_comment
begin_function
DECL|function|glDraw
name|void
name|QGLWidget
operator|::
name|glDraw
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return;
name|makeCurrent
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_OPENGL_ES
if|if
condition|(
name|d
operator|->
name|glcx
operator|->
name|deviceIsPixmap
argument_list|()
condition|)
name|glDrawBuffer
argument_list|(
name|GL_FRONT
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|glcx
operator|->
name|initialized
argument_list|()
condition|)
block|{
name|glInit
argument_list|()
expr_stmt|;
specifier|const
name|qreal
name|scaleFactor
init|=
operator|(
name|window
argument_list|()
operator|&&
name|window
argument_list|()
operator|->
name|windowHandle
argument_list|()
operator|)
condition|?
name|window
argument_list|()
operator|->
name|windowHandle
argument_list|()
operator|->
name|devicePixelRatio
argument_list|()
else|:
literal|1.0
decl_stmt|;
name|resizeGL
argument_list|(
name|d
operator|->
name|glcx
operator|->
name|device
argument_list|()
operator|->
name|width
argument_list|()
operator|*
name|scaleFactor
argument_list|,
name|d
operator|->
name|glcx
operator|->
name|device
argument_list|()
operator|->
name|height
argument_list|()
operator|*
name|scaleFactor
argument_list|)
expr_stmt|;
comment|// New context needs this "resize"
block|}
name|paintGL
argument_list|()
expr_stmt|;
if|if
condition|(
name|doubleBuffer
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|autoSwap
condition|)
name|swapBuffers
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|glFlush
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Convenience function for specifying a drawing color to OpenGL.     Calls glColor4 (in RGBA mode) or glIndex (in color-index mode)     with the color \a c. Applies to this widgets GL context.      \note This function is not supported on OpenGL/ES 2.0 systems.      \sa qglClearColor(), QGLContext::currentContext(), QColor */
end_comment
begin_function
DECL|function|qglColor
name|void
name|QGLWidget
operator|::
name|qglColor
parameter_list|(
specifier|const
name|QColor
modifier|&
name|c
parameter_list|)
specifier|const
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
name|glColor4f
argument_list|(
name|c
operator|.
name|redF
argument_list|()
argument_list|,
name|c
operator|.
name|greenF
argument_list|()
argument_list|,
name|c
operator|.
name|blueF
argument_list|()
argument_list|,
name|c
operator|.
name|alphaF
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_D
argument_list|(
specifier|const
name|QGLWidget
argument_list|)
expr_stmt|;
specifier|const
name|QGLContext
modifier|*
name|ctx
init|=
name|QGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|format
argument_list|()
operator|.
name|rgba
argument_list|()
condition|)
name|glColor4f
argument_list|(
name|c
operator|.
name|redF
argument_list|()
argument_list|,
name|c
operator|.
name|greenF
argument_list|()
argument_list|,
name|c
operator|.
name|blueF
argument_list|()
argument_list|,
name|c
operator|.
name|alphaF
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|cmap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// QGLColormap in use?
name|int
name|i
init|=
name|d
operator|->
name|cmap
operator|.
name|find
argument_list|(
name|c
operator|.
name|rgb
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
name|d
operator|->
name|cmap
operator|.
name|findNearest
argument_list|(
name|c
operator|.
name|rgb
argument_list|()
argument_list|)
expr_stmt|;
name|glIndexi
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|glIndexi
argument_list|(
name|ctx
operator|->
name|colorIndex
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_OPENGL_ES
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//QT_OPENGL_ES_2
block|}
end_function
begin_comment
comment|/*!     Convenience function for specifying the clearing color to OpenGL.     Calls glClearColor (in RGBA mode) or glClearIndex (in color-index     mode) with the color \a c. Applies to this widgets GL context.      \sa qglColor(), QGLContext::currentContext(), QColor */
end_comment
begin_function
DECL|function|qglClearColor
name|void
name|QGLWidget
operator|::
name|qglClearColor
parameter_list|(
specifier|const
name|QColor
modifier|&
name|c
parameter_list|)
specifier|const
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
name|glClearColor
argument_list|(
name|c
operator|.
name|redF
argument_list|()
argument_list|,
name|c
operator|.
name|greenF
argument_list|()
argument_list|,
name|c
operator|.
name|blueF
argument_list|()
argument_list|,
name|c
operator|.
name|alphaF
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_D
argument_list|(
specifier|const
name|QGLWidget
argument_list|)
expr_stmt|;
specifier|const
name|QGLContext
modifier|*
name|ctx
init|=
name|QGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|format
argument_list|()
operator|.
name|rgba
argument_list|()
condition|)
name|glClearColor
argument_list|(
name|c
operator|.
name|redF
argument_list|()
argument_list|,
name|c
operator|.
name|greenF
argument_list|()
argument_list|,
name|c
operator|.
name|blueF
argument_list|()
argument_list|,
name|c
operator|.
name|alphaF
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|cmap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// QGLColormap in use?
name|int
name|i
init|=
name|d
operator|->
name|cmap
operator|.
name|find
argument_list|(
name|c
operator|.
name|rgb
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
name|d
operator|->
name|cmap
operator|.
name|findNearest
argument_list|(
name|c
operator|.
name|rgb
argument_list|()
argument_list|)
expr_stmt|;
name|glClearIndex
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|glClearIndex
argument_list|(
name|ctx
operator|->
name|colorIndex
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Converts the image \a img into the unnamed format expected by     OpenGL functions such as glTexImage2D(). The returned image is not     usable as a QImage, but QImage::width(), QImage::height() and     QImage::bits() may be used with OpenGL. The GL format used is     \c GL_RGBA.      \omit ###      \l opengl/texture example     The following few lines are from the texture example. Most of the     code is irrelevant, so we just quote the relevant bits:      \quotefromfile opengl/texture/gltexobj.cpp     \skipto tex1     \printline tex1     \printline gllogo.bmp      We create \e tex1 (and another variable) for OpenGL, and load a real     image into \e buf.      \skipto convertToGLFormat     \printline convertToGLFormat      A few lines later, we convert \e buf into OpenGL format and store it     in \e tex1.      \skipto glTexImage2D     \printline glTexImage2D     \printline tex1.bits      Note the dimension restrictions for texture images as described in     the glTexImage2D() documentation. The width must be 2^m + 2*border     and the height 2^n + 2*border where m and n are integers and     border is either 0 or 1.      Another function in the same example uses \e tex1 with OpenGL.      \endomit */
end_comment
begin_function
DECL|function|convertToGLFormat
name|QImage
name|QGLWidget
operator|::
name|convertToGLFormat
parameter_list|(
specifier|const
name|QImage
modifier|&
name|img
parameter_list|)
block|{
name|QImage
name|res
argument_list|(
name|img
operator|.
name|size
argument_list|()
argument_list|,
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
decl_stmt|;
name|convertToGLFormatHelper
argument_list|(
name|res
argument_list|,
name|img
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
argument_list|,
name|GL_RGBA
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGLColormap& QGLWidget::colormap() const      Returns the colormap for this widget.      Usually it is only top-level widgets that can have different     colormaps installed. Asking for the colormap of a child widget     will return the colormap for the child's top-level widget.      If no colormap has been set for this widget, the QGLColormap     returned will be empty.      \sa setColormap(), QGLColormap::isEmpty() */
end_comment
begin_comment
comment|/*!     \fn void QGLWidget::setColormap(const QGLColormap& cmap)      Set the colormap for this widget to \a cmap. Usually it is only     top-level widgets that can have colormaps installed.      \sa colormap() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_OPENGL_ES
end_ifndef
begin_function
DECL|function|qt_save_gl_state
specifier|static
name|void
name|qt_save_gl_state
parameter_list|()
block|{
name|glPushClientAttrib
argument_list|(
name|GL_CLIENT_ALL_ATTRIB_BITS
argument_list|)
expr_stmt|;
name|glPushAttrib
argument_list|(
name|GL_ALL_ATTRIB_BITS
argument_list|)
expr_stmt|;
name|glMatrixMode
argument_list|(
name|GL_TEXTURE
argument_list|)
expr_stmt|;
name|glPushMatrix
argument_list|()
expr_stmt|;
name|glLoadIdentity
argument_list|()
expr_stmt|;
name|glMatrixMode
argument_list|(
name|GL_PROJECTION
argument_list|)
expr_stmt|;
name|glPushMatrix
argument_list|()
expr_stmt|;
name|glMatrixMode
argument_list|(
name|GL_MODELVIEW
argument_list|)
expr_stmt|;
name|glPushMatrix
argument_list|()
expr_stmt|;
name|glShadeModel
argument_list|(
name|GL_FLAT
argument_list|)
expr_stmt|;
name|glDisable
argument_list|(
name|GL_CULL_FACE
argument_list|)
expr_stmt|;
name|glDisable
argument_list|(
name|GL_LIGHTING
argument_list|)
expr_stmt|;
name|glDisable
argument_list|(
name|GL_STENCIL_TEST
argument_list|)
expr_stmt|;
name|glDisable
argument_list|(
name|GL_DEPTH_TEST
argument_list|)
expr_stmt|;
name|glEnable
argument_list|(
name|GL_BLEND
argument_list|)
expr_stmt|;
name|glBlendFunc
argument_list|(
name|GL_ONE
argument_list|,
name|GL_ONE_MINUS_SRC_ALPHA
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_restore_gl_state
specifier|static
name|void
name|qt_restore_gl_state
parameter_list|()
block|{
name|glMatrixMode
argument_list|(
name|GL_TEXTURE
argument_list|)
expr_stmt|;
name|glPopMatrix
argument_list|()
expr_stmt|;
name|glMatrixMode
argument_list|(
name|GL_PROJECTION
argument_list|)
expr_stmt|;
name|glPopMatrix
argument_list|()
expr_stmt|;
name|glMatrixMode
argument_list|(
name|GL_MODELVIEW
argument_list|)
expr_stmt|;
name|glPopMatrix
argument_list|()
expr_stmt|;
name|glPopAttrib
argument_list|()
expr_stmt|;
name|glPopClientAttrib
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_gl_draw_text
specifier|static
name|void
name|qt_gl_draw_text
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|GLfloat
name|color
index|[
literal|4
index|]
decl_stmt|;
name|glGetFloatv
argument_list|(
name|GL_CURRENT_COLOR
argument_list|,
operator|&
name|color
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|QColor
name|col
decl_stmt|;
name|col
operator|.
name|setRgbF
argument_list|(
name|color
index|[
literal|0
index|]
argument_list|,
name|color
index|[
literal|1
index|]
argument_list|,
name|color
index|[
literal|2
index|]
argument_list|,
name|color
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|QPen
name|old_pen
init|=
name|p
operator|->
name|pen
argument_list|()
decl_stmt|;
name|QFont
name|old_font
init|=
name|p
operator|->
name|font
argument_list|()
decl_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|p
operator|->
name|setFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawText
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|old_pen
argument_list|)
expr_stmt|;
name|p
operator|->
name|setFont
argument_list|(
name|old_font
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !QT_OPENGL_ES
end_comment
begin_comment
comment|/*!    Renders the string \a str into the GL context of this widget.     \a x and \a y are specified in window coordinates, with the origin    in the upper left-hand corner of the window. If \a font is not    specified, the currently set application font will be used to    render the string. To change the color of the rendered text you can    use the glColor() call (or the qglColor() convenience function),    just before the renderText() call.     \note This function clears the stencil buffer.     \note This function is not supported on OpenGL/ES systems.     \note This function temporarily disables depth-testing when the    text is drawn.     \note This function can only be used inside a    QPainter::beginNativePainting()/QPainter::endNativePainting() block    if a painter is active on the QGLWidget.     \l{Overpainting Example}{Overpaint} with QPainter::drawText() instead. */
end_comment
begin_function
DECL|function|renderText
name|void
name|QGLWidget
operator|::
name|renderText
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_OPENGL_ES
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|isValid
argument_list|()
condition|)
return|return;
name|GLint
name|view
index|[
literal|4
index|]
decl_stmt|;
name|bool
name|use_scissor_testing
init|=
name|glIsEnabled
argument_list|(
name|GL_SCISSOR_TEST
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|use_scissor_testing
condition|)
name|glGetIntegerv
argument_list|(
name|GL_VIEWPORT
argument_list|,
operator|&
name|view
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|int
name|width
init|=
name|d
operator|->
name|glcx
operator|->
name|device
argument_list|()
operator|->
name|width
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|d
operator|->
name|glcx
operator|->
name|device
argument_list|()
operator|->
name|height
argument_list|()
decl_stmt|;
name|bool
name|auto_swap
init|=
name|autoBufferSwap
argument_list|()
decl_stmt|;
name|QPaintEngine
modifier|*
name|engine
init|=
name|paintEngine
argument_list|()
decl_stmt|;
name|qt_save_gl_state
argument_list|()
expr_stmt|;
name|QPainter
modifier|*
name|p
decl_stmt|;
name|bool
name|reuse_painter
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|engine
operator|->
name|isActive
argument_list|()
condition|)
block|{
name|reuse_painter
operator|=
literal|true
expr_stmt|;
name|p
operator|=
name|engine
operator|->
name|painter
argument_list|()
expr_stmt|;
name|glDisable
argument_list|(
name|GL_DEPTH_TEST
argument_list|)
expr_stmt|;
name|glViewport
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|glMatrixMode
argument_list|(
name|GL_PROJECTION
argument_list|)
expr_stmt|;
name|glLoadIdentity
argument_list|()
expr_stmt|;
name|glOrtho
argument_list|(
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|glMatrixMode
argument_list|(
name|GL_MODELVIEW
argument_list|)
expr_stmt|;
name|glLoadIdentity
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|setAutoBufferSwap
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// disable glClear() as a result of QPainter::begin()
name|d
operator|->
name|disable_clear_on_painter_begin
operator|=
literal|true
expr_stmt|;
name|p
operator|=
operator|new
name|QPainter
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|QRect
name|viewport
argument_list|(
name|view
index|[
literal|0
index|]
argument_list|,
name|view
index|[
literal|1
index|]
argument_list|,
name|view
index|[
literal|2
index|]
argument_list|,
name|view
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|use_scissor_testing
operator|&&
name|viewport
operator|!=
name|rect
argument_list|()
condition|)
block|{
comment|// if the user hasn't set a scissor box, we set one that
comment|// covers the current viewport
name|glScissor
argument_list|(
name|view
index|[
literal|0
index|]
argument_list|,
name|view
index|[
literal|1
index|]
argument_list|,
name|view
index|[
literal|2
index|]
argument_list|,
name|view
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|glEnable
argument_list|(
name|GL_SCISSOR_TEST
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_scissor_testing
condition|)
block|{
comment|// use the scissor box set by the user
name|glEnable
argument_list|(
name|GL_SCISSOR_TEST
argument_list|)
expr_stmt|;
block|}
name|qt_gl_draw_text
argument_list|(
name|p
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|str
argument_list|,
name|font
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reuse_painter
condition|)
block|{
name|p
operator|->
name|end
argument_list|()
expr_stmt|;
operator|delete
name|p
expr_stmt|;
name|setAutoBufferSwap
argument_list|(
name|auto_swap
argument_list|)
expr_stmt|;
name|d
operator|->
name|disable_clear_on_painter_begin
operator|=
literal|false
expr_stmt|;
block|}
name|qt_restore_gl_state
argument_list|()
expr_stmt|;
else|#
directive|else
comment|// QT_OPENGL_ES
name|Q_UNUSED
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|font
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"QGLWidget::renderText is not supported under OpenGL/ES"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*! \overload      \a x, \a y and \a z are specified in scene or object coordinates     relative to the currently set projection and model matrices. This     can be useful if you want to annotate models with text labels and     have the labels move with the model as it is rotated etc.      \note This function is not supported on OpenGL/ES systems.      \note If depth testing is enabled before this function is called,     then the drawn text will be depth-tested against the models that     have already been drawn in the scene.  Use \c{glDisable(GL_DEPTH_TEST)}     before calling this function to annotate the models without     depth-testing the text.      \note This function can only be used inside a     QPainter::beginNativePainting()/QPainter::endNativePainting() block     if a painter is active on the QGLWidget.      \l{Overpainting Example}{Overpaint} with QPainter::drawText() instead. */
end_comment
begin_function
DECL|function|renderText
name|void
name|QGLWidget
operator|::
name|renderText
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|double
name|z
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_OPENGL_ES
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|isValid
argument_list|()
condition|)
return|return;
name|bool
name|auto_swap
init|=
name|autoBufferSwap
argument_list|()
decl_stmt|;
name|int
name|width
init|=
name|d
operator|->
name|glcx
operator|->
name|device
argument_list|()
operator|->
name|width
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|d
operator|->
name|glcx
operator|->
name|device
argument_list|()
operator|->
name|height
argument_list|()
decl_stmt|;
name|GLdouble
name|model
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|,
name|proj
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
name|GLint
name|view
index|[
literal|4
index|]
decl_stmt|;
name|glGetDoublev
argument_list|(
name|GL_MODELVIEW_MATRIX
argument_list|,
operator|&
name|model
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|glGetDoublev
argument_list|(
name|GL_PROJECTION_MATRIX
argument_list|,
operator|&
name|proj
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|glGetIntegerv
argument_list|(
name|GL_VIEWPORT
argument_list|,
operator|&
name|view
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|GLdouble
name|win_x
init|=
literal|0
decl_stmt|,
name|win_y
init|=
literal|0
decl_stmt|,
name|win_z
init|=
literal|0
decl_stmt|;
name|qgluProject
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
operator|&
name|model
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|proj
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|view
index|[
literal|0
index|]
argument_list|,
operator|&
name|win_x
argument_list|,
operator|&
name|win_y
argument_list|,
operator|&
name|win_z
argument_list|)
expr_stmt|;
name|win_y
operator|=
name|height
operator|-
name|win_y
expr_stmt|;
comment|// y is inverted
name|QPaintEngine
modifier|*
name|engine
init|=
name|paintEngine
argument_list|()
decl_stmt|;
name|QPainter
modifier|*
name|p
decl_stmt|;
name|bool
name|reuse_painter
init|=
literal|false
decl_stmt|;
name|bool
name|use_depth_testing
init|=
name|glIsEnabled
argument_list|(
name|GL_DEPTH_TEST
argument_list|)
decl_stmt|;
name|bool
name|use_scissor_testing
init|=
name|glIsEnabled
argument_list|(
name|GL_SCISSOR_TEST
argument_list|)
decl_stmt|;
name|qt_save_gl_state
argument_list|()
expr_stmt|;
if|if
condition|(
name|engine
operator|->
name|isActive
argument_list|()
condition|)
block|{
name|reuse_painter
operator|=
literal|true
expr_stmt|;
name|p
operator|=
name|engine
operator|->
name|painter
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|setAutoBufferSwap
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// disable glClear() as a result of QPainter::begin()
name|d
operator|->
name|disable_clear_on_painter_begin
operator|=
literal|true
expr_stmt|;
name|p
operator|=
operator|new
name|QPainter
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|QRect
name|viewport
argument_list|(
name|view
index|[
literal|0
index|]
argument_list|,
name|view
index|[
literal|1
index|]
argument_list|,
name|view
index|[
literal|2
index|]
argument_list|,
name|view
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|use_scissor_testing
operator|&&
name|viewport
operator|!=
name|rect
argument_list|()
condition|)
block|{
name|glScissor
argument_list|(
name|view
index|[
literal|0
index|]
argument_list|,
name|view
index|[
literal|1
index|]
argument_list|,
name|view
index|[
literal|2
index|]
argument_list|,
name|view
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|glEnable
argument_list|(
name|GL_SCISSOR_TEST
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_scissor_testing
condition|)
block|{
name|glEnable
argument_list|(
name|GL_SCISSOR_TEST
argument_list|)
expr_stmt|;
block|}
name|glMatrixMode
argument_list|(
name|GL_PROJECTION
argument_list|)
expr_stmt|;
name|glLoadIdentity
argument_list|()
expr_stmt|;
name|glViewport
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|glOrtho
argument_list|(
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|glMatrixMode
argument_list|(
name|GL_MODELVIEW
argument_list|)
expr_stmt|;
name|glLoadIdentity
argument_list|()
expr_stmt|;
name|glAlphaFunc
argument_list|(
name|GL_GREATER
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|glEnable
argument_list|(
name|GL_ALPHA_TEST
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_depth_testing
condition|)
name|glEnable
argument_list|(
name|GL_DEPTH_TEST
argument_list|)
expr_stmt|;
name|glTranslated
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
name|win_z
argument_list|)
expr_stmt|;
name|qt_gl_draw_text
argument_list|(
name|p
argument_list|,
name|qRound
argument_list|(
name|win_x
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|win_y
argument_list|)
argument_list|,
name|str
argument_list|,
name|font
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reuse_painter
condition|)
block|{
name|p
operator|->
name|end
argument_list|()
expr_stmt|;
operator|delete
name|p
expr_stmt|;
name|setAutoBufferSwap
argument_list|(
name|auto_swap
argument_list|)
expr_stmt|;
name|d
operator|->
name|disable_clear_on_painter_begin
operator|=
literal|false
expr_stmt|;
block|}
name|qt_restore_gl_state
argument_list|()
expr_stmt|;
else|#
directive|else
comment|// QT_OPENGL_ES
name|Q_UNUSED
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|font
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"QGLWidget::renderText is not supported under OpenGL/ES"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|format
name|QGLFormat
name|QGLWidget
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|glcx
operator|->
name|format
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|context
name|QGLContext
modifier|*
name|QGLWidget
operator|::
name|context
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|glcx
return|;
block|}
end_function
begin_function
DECL|function|doubleBuffer
name|bool
name|QGLWidget
operator|::
name|doubleBuffer
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|glcx
operator|->
name|d_ptr
operator|->
name|glFormat
operator|.
name|testOption
argument_list|(
name|QGL
operator|::
name|DoubleBuffer
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setAutoBufferSwap
name|void
name|QGLWidget
operator|::
name|setAutoBufferSwap
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoSwap
operator|=
name|on
expr_stmt|;
block|}
end_function
begin_function
DECL|function|autoBufferSwap
name|bool
name|QGLWidget
operator|::
name|autoBufferSwap
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autoSwap
return|;
block|}
end_function
begin_comment
comment|/*!     Calls QGLContext:::bindTexture(\a image, \a target, \a format) on the currently     set context.      \sa deleteTexture() */
end_comment
begin_function
DECL|function|bindTexture
name|GLuint
name|QGLWidget
operator|::
name|bindTexture
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|format
parameter_list|)
block|{
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|glcx
operator|->
name|bindTexture
argument_list|(
name|image
argument_list|,
name|target
argument_list|,
name|format
argument_list|,
name|QGLContext
operator|::
name|DefaultBindOption
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload   \since 4.6    The binding \a options are a set of options used to decide how to   bind the texture to the context.  */
end_comment
begin_function
DECL|function|bindTexture
name|GLuint
name|QGLWidget
operator|::
name|bindTexture
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|format
parameter_list|,
name|QGLContext
operator|::
name|BindOptions
name|options
parameter_list|)
block|{
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|glcx
operator|->
name|bindTexture
argument_list|(
name|image
argument_list|,
name|target
argument_list|,
name|format
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Calls QGLContext:::bindTexture(\a pixmap, \a target, \a format) on the currently     set context.      \sa deleteTexture() */
end_comment
begin_function
DECL|function|bindTexture
name|GLuint
name|QGLWidget
operator|::
name|bindTexture
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|format
parameter_list|)
block|{
if|if
condition|(
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|glcx
operator|->
name|bindTexture
argument_list|(
name|pixmap
argument_list|,
name|target
argument_list|,
name|format
argument_list|,
name|QGLContext
operator|::
name|DefaultBindOption
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload   \since 4.6    Generates and binds a 2D GL texture to the current context, based   on \a pixmap. The generated texture id is returned and can be used in    The binding \a options are a set of options used to decide how to   bind the texture to the context.  */
end_comment
begin_function
DECL|function|bindTexture
name|GLuint
name|QGLWidget
operator|::
name|bindTexture
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|format
parameter_list|,
name|QGLContext
operator|::
name|BindOptions
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|glcx
operator|->
name|bindTexture
argument_list|(
name|pixmap
argument_list|,
name|target
argument_list|,
name|format
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \overload      Calls QGLContext::bindTexture(\a fileName) on the currently set context.      \sa deleteTexture() */
end_comment
begin_function
DECL|function|bindTexture
name|GLuint
name|QGLWidget
operator|::
name|bindTexture
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|glcx
operator|->
name|bindTexture
argument_list|(
name|fileName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Calls QGLContext::deleteTexture(\a id) on the currently set     context.      \sa bindTexture() */
end_comment
begin_function
DECL|function|deleteTexture
name|void
name|QGLWidget
operator|::
name|deleteTexture
parameter_list|(
name|GLuint
name|id
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|glcx
operator|->
name|deleteTexture
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Calls the corresponding QGLContext::drawTexture() with     \a target, \a textureId, and \a textureTarget for this     widget's context. */
end_comment
begin_function
DECL|function|drawTexture
name|void
name|QGLWidget
operator|::
name|drawTexture
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|target
parameter_list|,
name|GLuint
name|textureId
parameter_list|,
name|GLenum
name|textureTarget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|glcx
operator|->
name|drawTexture
argument_list|(
name|target
argument_list|,
name|textureId
argument_list|,
name|textureTarget
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Calls the corresponding QGLContext::drawTexture() with     \a point, \a textureId, and \a textureTarget for this     widget's context. */
end_comment
begin_function
DECL|function|drawTexture
name|void
name|QGLWidget
operator|::
name|drawTexture
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|,
name|GLuint
name|textureId
parameter_list|,
name|GLenum
name|textureTarget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|glcx
operator|->
name|drawTexture
argument_list|(
name|point
argument_list|,
name|textureId
argument_list|,
name|textureTarget
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QGLEngineThreadStorage<QGL2PaintEngineEx>
argument_list|,
argument|qt_gl_2_engine
argument_list|)
end_macro
begin_function
DECL|function|qt_qgl_paint_engine
name|Q_OPENGL_EXPORT
name|QPaintEngine
modifier|*
name|qt_qgl_paint_engine
parameter_list|()
block|{
return|return
name|qt_gl_2_engine
argument_list|()
operator|->
name|engine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the GL widget's paint engine. */
end_comment
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QGLWidget
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
return|return
name|qt_qgl_paint_engine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*   This is the shared initialization for all platforms. Called from QGLWidgetPrivate::init() */
end_comment
begin_function
DECL|function|initContext
name|void
name|QGLWidgetPrivate
operator|::
name|initContext
parameter_list|(
name|QGLContext
modifier|*
name|context
parameter_list|,
specifier|const
name|QGLWidget
modifier|*
name|shareWidget
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|glDevice
operator|.
name|setWidget
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|glcx
operator|=
literal|0
expr_stmt|;
name|autoSwap
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|context
operator|&&
operator|!
name|context
operator|->
name|device
argument_list|()
condition|)
name|context
operator|->
name|setDevice
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|setContext
argument_list|(
name|context
argument_list|,
name|shareWidget
condition|?
name|shareWidget
operator|->
name|context
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glcx
condition|)
name|glcx
operator|=
operator|new
name|QGLContext
argument_list|(
name|QGLFormat
operator|::
name|defaultFormat
argument_list|()
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QString
argument_list|,
argument|qt_gl_lib_name
argument_list|)
end_macro
begin_function
DECL|function|qt_set_gl_library_name
name|void
name|qt_set_gl_library_name
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|qt_gl_lib_name
argument_list|()
operator|->
name|operator
name|=
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_gl_library_name
specifier|const
name|QString
name|qt_gl_library_name
parameter_list|()
block|{
if|if
condition|(
name|qt_gl_lib_name
argument_list|()
operator|->
name|isNull
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
return|return
name|QLatin1String
argument_list|(
literal|"GLESv2"
argument_list|)
return|;
else|#
directive|else
return|return
name|QLatin1String
argument_list|(
literal|"GL"
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
operator|*
name|qt_gl_lib_name
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|addShare
name|void
name|QGLContextGroup
operator|::
name|addShare
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|context
parameter_list|,
specifier|const
name|QGLContext
modifier|*
name|share
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|context
operator|&&
name|share
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|d_ptr
operator|->
name|group
operator|==
name|share
operator|->
name|d_ptr
operator|->
name|group
condition|)
return|return;
comment|// Make sure 'context' is not already shared with another group of contexts.
name|Q_ASSERT
argument_list|(
name|context
operator|->
name|d_ptr
operator|->
name|group
operator|->
name|m_refs
operator|.
name|load
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|// Free 'context' group resources and make it use the same resources as 'share'.
name|QGLContextGroup
modifier|*
name|group
init|=
name|share
operator|->
name|d_ptr
operator|->
name|group
decl_stmt|;
operator|delete
name|context
operator|->
name|d_ptr
operator|->
name|group
expr_stmt|;
name|context
operator|->
name|d_ptr
operator|->
name|group
operator|=
name|group
expr_stmt|;
name|group
operator|->
name|m_refs
operator|.
name|ref
argument_list|()
expr_stmt|;
comment|// Maintain a list of all the contexts in each group of sharing contexts.
comment|// The list is empty if the "share" context wasn't sharing already.
if|if
condition|(
name|group
operator|->
name|m_shares
operator|.
name|isEmpty
argument_list|()
condition|)
name|group
operator|->
name|m_shares
operator|.
name|append
argument_list|(
name|share
argument_list|)
expr_stmt|;
name|group
operator|->
name|m_shares
operator|.
name|append
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|removeShare
name|void
name|QGLContextGroup
operator|::
name|removeShare
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|context
parameter_list|)
block|{
comment|// Remove the context from the group.
name|QGLContextGroup
modifier|*
name|group
init|=
name|context
operator|->
name|d_ptr
operator|->
name|group
decl_stmt|;
if|if
condition|(
name|group
operator|->
name|m_shares
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|group
operator|->
name|m_shares
operator|.
name|removeAll
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|// Update context group representative.
name|Q_ASSERT
argument_list|(
name|group
operator|->
name|m_shares
operator|.
name|size
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|->
name|m_context
operator|==
name|context
condition|)
name|group
operator|->
name|m_context
operator|=
name|group
operator|->
name|m_shares
index|[
literal|0
index|]
expr_stmt|;
comment|// If there is only one context left, then make the list empty.
if|if
condition|(
name|group
operator|->
name|m_shares
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
name|group
operator|->
name|m_shares
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|bindCompressedTexture
name|QSize
name|QGLTexture
operator|::
name|bindCompressedTexture
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
return|return
name|QSize
argument_list|()
return|;
name|QByteArray
name|contents
init|=
name|file
operator|.
name|readAll
argument_list|()
decl_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|bindCompressedTexture
argument_list|(
name|contents
operator|.
name|constData
argument_list|()
argument_list|,
name|contents
operator|.
name|size
argument_list|()
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// PVR header format for container files that store textures compressed
end_comment
begin_comment
comment|// with the ETC1, PVRTC2, and PVRTC4 encodings.  Format information from the
end_comment
begin_comment
comment|// PowerVR SDK at http://www.imgtec.com/powervr/insider/powervr-sdk.asp
end_comment
begin_comment
comment|// "PVRTexTool Reference Manual, version 1.11f".
end_comment
begin_struct
DECL|struct|PvrHeader
struct|struct
name|PvrHeader
block|{
DECL|member|headerSize
name|quint32
name|headerSize
decl_stmt|;
DECL|member|height
name|quint32
name|height
decl_stmt|;
DECL|member|width
name|quint32
name|width
decl_stmt|;
DECL|member|mipMapCount
name|quint32
name|mipMapCount
decl_stmt|;
DECL|member|flags
name|quint32
name|flags
decl_stmt|;
DECL|member|dataSize
name|quint32
name|dataSize
decl_stmt|;
DECL|member|bitsPerPixel
name|quint32
name|bitsPerPixel
decl_stmt|;
DECL|member|redMask
name|quint32
name|redMask
decl_stmt|;
DECL|member|greenMask
name|quint32
name|greenMask
decl_stmt|;
DECL|member|blueMask
name|quint32
name|blueMask
decl_stmt|;
DECL|member|alphaMask
name|quint32
name|alphaMask
decl_stmt|;
DECL|member|magic
name|quint32
name|magic
decl_stmt|;
DECL|member|surfaceCount
name|quint32
name|surfaceCount
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|PVR_MAGIC
define|#
directive|define
name|PVR_MAGIC
value|0x21525650
end_define
begin_comment
DECL|macro|PVR_MAGIC
comment|// "PVR!" in little-endian
end_comment
begin_define
DECL|macro|PVR_FORMAT_MASK
define|#
directive|define
name|PVR_FORMAT_MASK
value|0x000000FF
end_define
begin_define
DECL|macro|PVR_FORMAT_PVRTC2
define|#
directive|define
name|PVR_FORMAT_PVRTC2
value|0x00000018
end_define
begin_define
DECL|macro|PVR_FORMAT_PVRTC4
define|#
directive|define
name|PVR_FORMAT_PVRTC4
value|0x00000019
end_define
begin_define
DECL|macro|PVR_FORMAT_ETC1
define|#
directive|define
name|PVR_FORMAT_ETC1
value|0x00000036
end_define
begin_define
DECL|macro|PVR_HAS_MIPMAPS
define|#
directive|define
name|PVR_HAS_MIPMAPS
value|0x00000100
end_define
begin_define
DECL|macro|PVR_TWIDDLED
define|#
directive|define
name|PVR_TWIDDLED
value|0x00000200
end_define
begin_define
DECL|macro|PVR_NORMAL_MAP
define|#
directive|define
name|PVR_NORMAL_MAP
value|0x00000400
end_define
begin_define
DECL|macro|PVR_BORDER_ADDED
define|#
directive|define
name|PVR_BORDER_ADDED
value|0x00000800
end_define
begin_define
DECL|macro|PVR_CUBE_MAP
define|#
directive|define
name|PVR_CUBE_MAP
value|0x00001000
end_define
begin_define
DECL|macro|PVR_FALSE_COLOR_MIPMAPS
define|#
directive|define
name|PVR_FALSE_COLOR_MIPMAPS
value|0x00002000
end_define
begin_define
DECL|macro|PVR_VOLUME_TEXTURE
define|#
directive|define
name|PVR_VOLUME_TEXTURE
value|0x00004000
end_define
begin_define
DECL|macro|PVR_ALPHA_IN_TEXTURE
define|#
directive|define
name|PVR_ALPHA_IN_TEXTURE
value|0x00008000
end_define
begin_define
DECL|macro|PVR_VERTICAL_FLIP
define|#
directive|define
name|PVR_VERTICAL_FLIP
value|0x00010000
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG
end_ifndef
begin_define
DECL|macro|GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG
define|#
directive|define
name|GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG
value|0x8C00
end_define
begin_define
DECL|macro|GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG
define|#
directive|define
name|GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG
value|0x8C01
end_define
begin_define
DECL|macro|GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
define|#
directive|define
name|GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
value|0x8C02
end_define
begin_define
DECL|macro|GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
define|#
directive|define
name|GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
value|0x8C03
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GL_ETC1_RGB8_OES
end_ifndef
begin_define
DECL|macro|GL_ETC1_RGB8_OES
define|#
directive|define
name|GL_ETC1_RGB8_OES
value|0x8D64
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|canBindCompressedTexture
name|bool
name|QGLTexture
operator|::
name|canBindCompressedTexture
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|bool
modifier|*
name|hasAlpha
parameter_list|)
block|{
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|!=
name|QSysInfo
operator|::
name|LittleEndian
condition|)
block|{
comment|// Compressed texture loading only supported on little-endian
comment|// systems such as x86 and ARM at the moment.
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|format
condition|)
block|{
comment|// Auto-detect the format from the header.
if|if
condition|(
name|len
operator|>=
literal|4
operator|&&
operator|!
name|qstrncmp
argument_list|(
name|buf
argument_list|,
literal|"DDS "
argument_list|,
literal|4
argument_list|)
condition|)
block|{
operator|*
name|hasAlpha
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>=
literal|52
operator|&&
operator|!
name|qstrncmp
argument_list|(
name|buf
operator|+
literal|44
argument_list|,
literal|"PVR!"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
specifier|const
name|PvrHeader
modifier|*
name|pvrHeader
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|PvrHeader
operator|*
argument_list|>
argument_list|(
name|buf
argument_list|)
decl_stmt|;
operator|*
name|hasAlpha
operator|=
operator|(
name|pvrHeader
operator|->
name|alphaMask
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
else|else
block|{
comment|// Validate the format against the header.
if|if
condition|(
operator|!
name|qstricmp
argument_list|(
name|format
argument_list|,
literal|"DDS"
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|>=
literal|4
operator|&&
operator|!
name|qstrncmp
argument_list|(
name|buf
argument_list|,
literal|"DDS "
argument_list|,
literal|4
argument_list|)
condition|)
block|{
operator|*
name|hasAlpha
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|qstricmp
argument_list|(
name|format
argument_list|,
literal|"PVR"
argument_list|)
operator|||
operator|!
name|qstricmp
argument_list|(
name|format
argument_list|,
literal|"ETC1"
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|>=
literal|52
operator|&&
operator|!
name|qstrncmp
argument_list|(
name|buf
operator|+
literal|44
argument_list|,
literal|"PVR!"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
specifier|const
name|PvrHeader
modifier|*
name|pvrHeader
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|PvrHeader
operator|*
argument_list|>
argument_list|(
name|buf
argument_list|)
decl_stmt|;
operator|*
name|hasAlpha
operator|=
operator|(
name|pvrHeader
operator|->
name|alphaMask
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_define
DECL|macro|ctx
define|#
directive|define
name|ctx
value|QGLContext::currentContext()
end_define
begin_function
DECL|function|bindCompressedTexture
name|QSize
name|QGLTexture
operator|::
name|bindCompressedTexture
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|!=
name|QSysInfo
operator|::
name|LittleEndian
condition|)
block|{
comment|// Compressed texture loading only supported on little-endian
comment|// systems such as x86 and ARM at the moment.
return|return
name|QSize
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|format
condition|)
block|{
comment|// Auto-detect the format from the header.
if|if
condition|(
name|len
operator|>=
literal|4
operator|&&
operator|!
name|qstrncmp
argument_list|(
name|buf
argument_list|,
literal|"DDS "
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|bindCompressedTextureDDS
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
return|;
elseif|else
if|if
condition|(
name|len
operator|>=
literal|52
operator|&&
operator|!
name|qstrncmp
argument_list|(
name|buf
operator|+
literal|44
argument_list|,
literal|"PVR!"
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|bindCompressedTexturePVR
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
else|else
block|{
comment|// Validate the format against the header.
if|if
condition|(
operator|!
name|qstricmp
argument_list|(
name|format
argument_list|,
literal|"DDS"
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|>=
literal|4
operator|&&
operator|!
name|qstrncmp
argument_list|(
name|buf
argument_list|,
literal|"DDS "
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|bindCompressedTextureDDS
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|qstricmp
argument_list|(
name|format
argument_list|,
literal|"PVR"
argument_list|)
operator|||
operator|!
name|qstricmp
argument_list|(
name|format
argument_list|,
literal|"ETC1"
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|>=
literal|52
operator|&&
operator|!
name|qstrncmp
argument_list|(
name|buf
operator|+
literal|44
argument_list|,
literal|"PVR!"
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|bindCompressedTexturePVR
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
return|return
name|QSize
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|bindCompressedTextureDDS
name|QSize
name|QGLTexture
operator|::
name|bindCompressedTextureDDS
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// We only support 2D texture loading at present.
if|if
condition|(
name|target
operator|!=
name|GL_TEXTURE_2D
condition|)
return|return
name|QSize
argument_list|()
return|;
comment|// Bail out if the necessary extension is not present.
if|if
condition|(
operator|!
name|qgl_extensions
argument_list|()
operator|->
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|DDSTextureCompression
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLContext::bindTexture(): DDS texture compression is not supported."
argument_list|)
expr_stmt|;
return|return
name|QSize
argument_list|()
return|;
block|}
specifier|const
name|DDSFormat
modifier|*
name|ddsHeader
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|DDSFormat
operator|*
argument_list|>
argument_list|(
name|buf
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ddsHeader
operator|->
name|dwLinearSize
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLContext::bindTexture(): DDS image size is not valid."
argument_list|)
expr_stmt|;
return|return
name|QSize
argument_list|()
return|;
block|}
name|int
name|blockSize
init|=
literal|16
decl_stmt|;
name|GLenum
name|format
decl_stmt|;
switch|switch
condition|(
name|ddsHeader
operator|->
name|ddsPixelFormat
operator|.
name|dwFourCC
condition|)
block|{
case|case
name|FOURCC_DXT1
case|:
name|format
operator|=
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
expr_stmt|;
name|blockSize
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|FOURCC_DXT3
case|:
name|format
operator|=
name|GL_COMPRESSED_RGBA_S3TC_DXT3_EXT
expr_stmt|;
break|break;
case|case
name|FOURCC_DXT5
case|:
name|format
operator|=
name|GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QGLContext::bindTexture(): DDS image format not supported."
argument_list|)
expr_stmt|;
return|return
name|QSize
argument_list|()
return|;
block|}
specifier|const
name|GLubyte
modifier|*
name|pixels
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|buf
operator|+
name|ddsHeader
operator|->
name|dwSize
operator|+
literal|4
argument_list|)
decl_stmt|;
name|glGenTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|GL_LINEAR
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|GL_LINEAR
argument_list|)
expr_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|available
init|=
name|len
operator|-
name|int
argument_list|(
name|ddsHeader
operator|->
name|dwSize
operator|+
literal|4
argument_list|)
decl_stmt|;
name|int
name|w
init|=
name|ddsHeader
operator|->
name|dwWidth
decl_stmt|;
name|int
name|h
init|=
name|ddsHeader
operator|->
name|dwHeight
decl_stmt|;
comment|// load mip-maps
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ddsHeader
operator|->
name|dwMipMapCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|w
operator|==
literal|0
condition|)
name|w
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
name|h
operator|=
literal|1
expr_stmt|;
name|size
operator|=
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|*
operator|(
operator|(
name|h
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|*
name|blockSize
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|available
condition|)
break|break;
name|qgl_extensions
argument_list|()
operator|->
name|glCompressedTexImage2D
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|i
argument_list|,
name|format
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|pixels
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|size
expr_stmt|;
name|available
operator|-=
name|size
expr_stmt|;
comment|// half size for each mip-map level
name|w
operator|=
name|w
operator|/
literal|2
expr_stmt|;
name|h
operator|=
name|h
operator|/
literal|2
expr_stmt|;
block|}
comment|// DDS images are not inverted.
name|options
operator|&=
operator|~
name|QGLContext
operator|::
name|InvertedYBindOption
expr_stmt|;
return|return
name|QSize
argument_list|(
name|ddsHeader
operator|->
name|dwWidth
argument_list|,
name|ddsHeader
operator|->
name|dwHeight
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|bindCompressedTexturePVR
name|QSize
name|QGLTexture
operator|::
name|bindCompressedTexturePVR
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// We only support 2D texture loading at present.  Cube maps later.
if|if
condition|(
name|target
operator|!=
name|GL_TEXTURE_2D
condition|)
return|return
name|QSize
argument_list|()
return|;
comment|// Determine which texture format we will be loading.
specifier|const
name|PvrHeader
modifier|*
name|pvrHeader
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|PvrHeader
operator|*
argument_list|>
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|GLenum
name|textureFormat
decl_stmt|;
name|quint32
name|minWidth
decl_stmt|,
name|minHeight
decl_stmt|;
switch|switch
condition|(
name|pvrHeader
operator|->
name|flags
operator|&
name|PVR_FORMAT_MASK
condition|)
block|{
case|case
name|PVR_FORMAT_PVRTC2
case|:
if|if
condition|(
name|pvrHeader
operator|->
name|alphaMask
condition|)
name|textureFormat
operator|=
name|GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
expr_stmt|;
else|else
name|textureFormat
operator|=
name|GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG
expr_stmt|;
name|minWidth
operator|=
literal|16
expr_stmt|;
name|minHeight
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|PVR_FORMAT_PVRTC4
case|:
if|if
condition|(
name|pvrHeader
operator|->
name|alphaMask
condition|)
name|textureFormat
operator|=
name|GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
expr_stmt|;
else|else
name|textureFormat
operator|=
name|GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG
expr_stmt|;
name|minWidth
operator|=
literal|8
expr_stmt|;
name|minHeight
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|PVR_FORMAT_ETC1
case|:
name|textureFormat
operator|=
name|GL_ETC1_RGB8_OES
expr_stmt|;
name|minWidth
operator|=
literal|4
expr_stmt|;
name|minHeight
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QGLContext::bindTexture(): PVR image format 0x%x not supported."
argument_list|,
name|int
argument_list|(
name|pvrHeader
operator|->
name|flags
operator|&
name|PVR_FORMAT_MASK
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QSize
argument_list|()
return|;
block|}
comment|// Bail out if the necessary extension is not present.
if|if
condition|(
name|textureFormat
operator|==
name|GL_ETC1_RGB8_OES
condition|)
block|{
if|if
condition|(
operator|!
name|qgl_extensions
argument_list|()
operator|->
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|ETC1TextureCompression
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLContext::bindTexture(): ETC1 texture compression is not supported."
argument_list|)
expr_stmt|;
return|return
name|QSize
argument_list|()
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|qgl_extensions
argument_list|()
operator|->
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|PVRTCTextureCompression
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLContext::bindTexture(): PVRTC texture compression is not supported."
argument_list|)
expr_stmt|;
return|return
name|QSize
argument_list|()
return|;
block|}
block|}
comment|// Boundary check on the buffer size.
name|quint32
name|bufferSize
init|=
name|pvrHeader
operator|->
name|headerSize
operator|+
name|pvrHeader
operator|->
name|dataSize
decl_stmt|;
if|if
condition|(
name|bufferSize
operator|>
name|quint32
argument_list|(
name|len
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLContext::bindTexture(): PVR image size is not valid."
argument_list|)
expr_stmt|;
return|return
name|QSize
argument_list|()
return|;
block|}
comment|// Create the texture.
name|glPixelStorei
argument_list|(
name|GL_UNPACK_ALIGNMENT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|glGenTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvrHeader
operator|->
name|mipMapCount
condition|)
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|QGLContext
operator|::
name|LinearFilteringBindOption
operator|)
operator|!=
literal|0
condition|)
block|{
name|glTexParameteri
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|GL_LINEAR
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|GL_LINEAR_MIPMAP_LINEAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glTexParameteri
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|GL_NEAREST_MIPMAP_NEAREST
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|options
operator|&
name|QGLContext
operator|::
name|LinearFilteringBindOption
operator|)
operator|!=
literal|0
condition|)
block|{
name|glTexParameteri
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|GL_LINEAR
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|GL_LINEAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glTexParameteri
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
block|}
comment|// Load the compressed mipmap levels.
specifier|const
name|GLubyte
modifier|*
name|buffer
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|buf
operator|+
name|pvrHeader
operator|->
name|headerSize
argument_list|)
decl_stmt|;
name|bufferSize
operator|=
name|pvrHeader
operator|->
name|dataSize
expr_stmt|;
name|quint32
name|level
init|=
literal|0
decl_stmt|;
name|quint32
name|width
init|=
name|pvrHeader
operator|->
name|width
decl_stmt|;
name|quint32
name|height
init|=
name|pvrHeader
operator|->
name|height
decl_stmt|;
while|while
condition|(
name|bufferSize
operator|>
literal|0
operator|&&
name|level
operator|<=
name|pvrHeader
operator|->
name|mipMapCount
condition|)
block|{
name|quint32
name|size
init|=
operator|(
name|qMax
argument_list|(
name|width
argument_list|,
name|minWidth
argument_list|)
operator|*
name|qMax
argument_list|(
name|height
argument_list|,
name|minHeight
argument_list|)
operator|*
name|pvrHeader
operator|->
name|bitsPerPixel
operator|)
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|bufferSize
condition|)
break|break;
name|qgl_extensions
argument_list|()
operator|->
name|glCompressedTexImage2D
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GLint
argument_list|(
name|level
argument_list|)
argument_list|,
name|textureFormat
argument_list|,
name|GLsizei
argument_list|(
name|width
argument_list|)
argument_list|,
name|GLsizei
argument_list|(
name|height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GLsizei
argument_list|(
name|size
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|width
operator|/=
literal|2
expr_stmt|;
name|height
operator|/=
literal|2
expr_stmt|;
name|buffer
operator|+=
name|size
expr_stmt|;
operator|++
name|level
expr_stmt|;
block|}
comment|// Restore the default pixel alignment for later texture uploads.
name|glPixelStorei
argument_list|(
name|GL_UNPACK_ALIGNMENT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// Set the invert flag for the texture.  The "vertical flip"
comment|// flag in PVR is the opposite sense to our sense of inversion.
if|if
condition|(
operator|(
name|pvrHeader
operator|->
name|flags
operator|&
name|PVR_VERTICAL_FLIP
operator|)
operator|!=
literal|0
condition|)
name|options
operator|&=
operator|~
name|QGLContext
operator|::
name|InvertedYBindOption
expr_stmt|;
else|else
name|options
operator||=
name|QGLContext
operator|::
name|InvertedYBindOption
expr_stmt|;
return|return
name|QSize
argument_list|(
name|pvrHeader
operator|->
name|width
argument_list|,
name|pvrHeader
operator|->
name|height
argument_list|)
return|;
block|}
end_function
begin_undef
DECL|macro|ctx
undef|#
directive|undef
name|ctx
end_undef
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
