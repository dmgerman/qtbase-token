begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtOpenGL module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qgl.h"
end_include
begin_include
include|#
directive|include
file|"qgl_p.h"
end_include
begin_include
include|#
directive|include
file|"qmap.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qcolormap.h"
end_include
begin_include
include|#
directive|include
file|"qdesktopwidget.h"
end_include
begin_include
include|#
directive|include
file|"qpixmap.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|"qlibrary.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|<private/qfontengine_ft_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qt_x11_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpixmap_x11_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qimagepixmapcleanuphooks_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qunicodetables_p.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_HPUX
end_ifdef
begin_comment
comment|// for GLXPBuffer
end_comment
begin_include
include|#
directive|include
file|<private/qglpixelbuffer_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// We always define GLX_EXT_texture_from_pixmap ourselves because
end_comment
begin_comment
comment|// we can't trust system headers to do it properly
end_comment
begin_define
DECL|macro|GLX_EXT_texture_from_pixmap
define|#
directive|define
name|GLX_EXT_texture_from_pixmap
value|1
end_define
begin_define
DECL|macro|INT8
define|#
directive|define
name|INT8
value|dummy_INT8
end_define
begin_define
DECL|macro|INT32
define|#
directive|define
name|INT32
value|dummy_INT32
end_define
begin_include
include|#
directive|include
file|<GL/glx.h>
end_include
begin_undef
DECL|macro|INT8
undef|#
directive|undef
name|INT8
end_undef
begin_undef
DECL|macro|INT32
undef|#
directive|undef
name|INT32
end_undef
begin_include
include|#
directive|include
file|<X11/Xlib.h>
end_include
begin_include
include|#
directive|include
file|<X11/Xutil.h>
end_include
begin_include
include|#
directive|include
file|<X11/Xos.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_VXWORS
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|open
end_ifdef
begin_undef
DECL|macro|open
undef|#
directive|undef
name|open
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|getpid
end_ifdef
begin_undef
DECL|macro|getpid
undef|#
directive|undef
name|getpid
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_OS_VXWORKS
end_comment
begin_include
include|#
directive|include
file|<X11/Xatom.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_BSD4
argument_list|)
end_if
begin_include
include|#
directive|include
file|<dlfcn.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|QT_BEGIN_NAMESPACE
specifier|extern
name|Drawable
name|qt_x11Handle
parameter_list|(
specifier|const
name|QPaintDevice
modifier|*
name|pd
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
specifier|const
name|QX11Info
modifier|*
name|qt_x11Info
parameter_list|(
specifier|const
name|QPaintDevice
modifier|*
name|pd
parameter_list|)
function_decl|;
end_function_decl
begin_ifndef
ifndef|#
directive|ifndef
name|GLX_ARB_multisample
end_ifndef
begin_define
DECL|macro|GLX_SAMPLE_BUFFERS_ARB
define|#
directive|define
name|GLX_SAMPLE_BUFFERS_ARB
value|100000
end_define
begin_define
DECL|macro|GLX_SAMPLES_ARB
define|#
directive|define
name|GLX_SAMPLES_ARB
value|100001
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GLX_TEXTURE_2D_BIT_EXT
end_ifndef
begin_define
DECL|macro|GLX_TEXTURE_2D_BIT_EXT
define|#
directive|define
name|GLX_TEXTURE_2D_BIT_EXT
value|0x00000002
end_define
begin_define
DECL|macro|GLX_TEXTURE_RECTANGLE_BIT_EXT
define|#
directive|define
name|GLX_TEXTURE_RECTANGLE_BIT_EXT
value|0x00000004
end_define
begin_define
DECL|macro|GLX_BIND_TO_TEXTURE_RGB_EXT
define|#
directive|define
name|GLX_BIND_TO_TEXTURE_RGB_EXT
value|0x20D0
end_define
begin_define
DECL|macro|GLX_BIND_TO_TEXTURE_RGBA_EXT
define|#
directive|define
name|GLX_BIND_TO_TEXTURE_RGBA_EXT
value|0x20D1
end_define
begin_define
DECL|macro|GLX_BIND_TO_MIPMAP_TEXTURE_EXT
define|#
directive|define
name|GLX_BIND_TO_MIPMAP_TEXTURE_EXT
value|0x20D2
end_define
begin_define
DECL|macro|GLX_BIND_TO_TEXTURE_TARGETS_EXT
define|#
directive|define
name|GLX_BIND_TO_TEXTURE_TARGETS_EXT
value|0x20D3
end_define
begin_define
DECL|macro|GLX_Y_INVERTED_EXT
define|#
directive|define
name|GLX_Y_INVERTED_EXT
value|0x20D4
end_define
begin_define
DECL|macro|GLX_TEXTURE_FORMAT_EXT
define|#
directive|define
name|GLX_TEXTURE_FORMAT_EXT
value|0x20D5
end_define
begin_define
DECL|macro|GLX_TEXTURE_TARGET_EXT
define|#
directive|define
name|GLX_TEXTURE_TARGET_EXT
value|0x20D6
end_define
begin_define
DECL|macro|GLX_MIPMAP_TEXTURE_EXT
define|#
directive|define
name|GLX_MIPMAP_TEXTURE_EXT
value|0x20D7
end_define
begin_define
DECL|macro|GLX_TEXTURE_FORMAT_NONE_EXT
define|#
directive|define
name|GLX_TEXTURE_FORMAT_NONE_EXT
value|0x20D8
end_define
begin_define
DECL|macro|GLX_TEXTURE_FORMAT_RGB_EXT
define|#
directive|define
name|GLX_TEXTURE_FORMAT_RGB_EXT
value|0x20D9
end_define
begin_define
DECL|macro|GLX_TEXTURE_FORMAT_RGBA_EXT
define|#
directive|define
name|GLX_TEXTURE_FORMAT_RGBA_EXT
value|0x20DA
end_define
begin_define
DECL|macro|GLX_TEXTURE_2D_EXT
define|#
directive|define
name|GLX_TEXTURE_2D_EXT
value|0x20DC
end_define
begin_define
DECL|macro|GLX_TEXTURE_RECTANGLE_EXT
define|#
directive|define
name|GLX_TEXTURE_RECTANGLE_EXT
value|0x20DD
end_define
begin_define
DECL|macro|GLX_FRONT_LEFT_EXT
define|#
directive|define
name|GLX_FRONT_LEFT_EXT
value|0x20DE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GLX_ARB_create_context
end_ifndef
begin_define
DECL|macro|GLX_CONTEXT_DEBUG_BIT_ARB
define|#
directive|define
name|GLX_CONTEXT_DEBUG_BIT_ARB
value|0x00000001
end_define
begin_define
DECL|macro|GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB
define|#
directive|define
name|GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB
value|0x00000002
end_define
begin_define
DECL|macro|GLX_CONTEXT_MAJOR_VERSION_ARB
define|#
directive|define
name|GLX_CONTEXT_MAJOR_VERSION_ARB
value|0x2091
end_define
begin_define
DECL|macro|GLX_CONTEXT_MINOR_VERSION_ARB
define|#
directive|define
name|GLX_CONTEXT_MINOR_VERSION_ARB
value|0x2092
end_define
begin_define
DECL|macro|GLX_CONTEXT_FLAGS_ARB
define|#
directive|define
name|GLX_CONTEXT_FLAGS_ARB
value|0x2094
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GLX_ARB_create_context_profile
end_ifndef
begin_define
DECL|macro|GLX_CONTEXT_CORE_PROFILE_BIT_ARB
define|#
directive|define
name|GLX_CONTEXT_CORE_PROFILE_BIT_ARB
value|0x00000001
end_define
begin_define
DECL|macro|GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB
define|#
directive|define
name|GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB
value|0x00000002
end_define
begin_define
DECL|macro|GLX_CONTEXT_PROFILE_MASK_ARB
define|#
directive|define
name|GLX_CONTEXT_PROFILE_MASK_ARB
value|0x9126
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*   The qt_gl_choose_cmap function is internal and used by QGLWidget::setContext()   and GLX (not Windows).  If the application can't find any sharable   colormaps, it must at least create as few colormaps as possible.  The   dictionary solution below ensures only one colormap is created per visual.   Colormaps are also deleted when the application terminates. */
end_comment
begin_struct
DECL|struct|QCMapEntry
struct|struct
name|QCMapEntry
block|{
name|QCMapEntry
parameter_list|()
constructor_decl|;
name|~
name|QCMapEntry
parameter_list|()
destructor_decl|;
DECL|member|cmap
name|Colormap
name|cmap
decl_stmt|;
DECL|member|alloc
name|bool
name|alloc
decl_stmt|;
DECL|member|scmap
name|XStandardColormap
name|scmap
decl_stmt|;
block|}
struct|;
end_struct
begin_constructor
DECL|function|QCMapEntry
name|QCMapEntry
operator|::
name|QCMapEntry
parameter_list|()
block|{
name|cmap
operator|=
literal|0
expr_stmt|;
name|alloc
operator|=
literal|false
expr_stmt|;
name|scmap
operator|.
name|colormap
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QCMapEntry
name|QCMapEntry
operator|::
name|~
name|QCMapEntry
parameter_list|()
block|{
if|if
condition|(
name|alloc
condition|)
name|XFreeColormap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_typedef
DECL|typedef|CMapEntryHash
typedef|typedef
name|QHash
argument_list|<
name|int
argument_list|,
name|QCMapEntry
modifier|*
argument_list|>
name|CMapEntryHash
typedef|;
end_typedef
begin_typedef
DECL|typedef|GLCMapHash
typedef|typedef
name|QHash
argument_list|<
name|int
argument_list|,
name|QMap
argument_list|<
name|int
argument_list|,
name|QRgb
argument_list|>
argument_list|>
name|GLCMapHash
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|mesa_gl
specifier|static
name|bool
name|mesa_gl
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|first_time
specifier|static
name|bool
name|first_time
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
name|void
name|cleanup_cmaps
parameter_list|()
function_decl|;
end_function_decl
begin_struct
DECL|struct|QGLCMapCleanupHandler
struct|struct
name|QGLCMapCleanupHandler
block|{
DECL|function|QGLCMapCleanupHandler
name|QGLCMapCleanupHandler
parameter_list|()
block|{
name|cmap_hash
operator|=
operator|new
name|CMapEntryHash
expr_stmt|;
name|qglcmap_hash
operator|=
operator|new
name|GLCMapHash
expr_stmt|;
block|}
DECL|function|~QGLCMapCleanupHandler
name|~
name|QGLCMapCleanupHandler
parameter_list|()
block|{
operator|delete
name|cmap_hash
expr_stmt|;
operator|delete
name|qglcmap_hash
expr_stmt|;
block|}
DECL|member|cmap_hash
name|CMapEntryHash
modifier|*
name|cmap_hash
decl_stmt|;
DECL|member|qglcmap_hash
name|GLCMapHash
modifier|*
name|qglcmap_hash
decl_stmt|;
block|}
struct|;
end_struct
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QGLCMapCleanupHandler
argument_list|,
argument|cmap_handler
argument_list|)
end_macro
begin_function
DECL|function|cleanup_cmaps
specifier|static
name|void
name|cleanup_cmaps
parameter_list|()
block|{
name|CMapEntryHash
modifier|*
name|hash
init|=
name|cmap_handler
argument_list|()
operator|->
name|cmap_hash
decl_stmt|;
name|QHash
argument_list|<
name|int
argument_list|,
name|QCMapEntry
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|hash
operator|->
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|)
block|{
operator|delete
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
name|hash
operator|->
name|clear
argument_list|()
expr_stmt|;
name|cmap_handler
argument_list|()
operator|->
name|qglcmap_hash
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_gl_choose_cmap
name|Colormap
name|qt_gl_choose_cmap
parameter_list|(
name|Display
modifier|*
name|dpy
parameter_list|,
name|XVisualInfo
modifier|*
name|vi
parameter_list|)
block|{
if|if
condition|(
name|first_time
condition|)
block|{
specifier|const
name|char
modifier|*
name|v
init|=
name|glXQueryServerString
argument_list|(
name|dpy
argument_list|,
name|vi
operator|->
name|screen
argument_list|,
name|GLX_VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
condition|)
name|mesa_gl
operator|=
operator|(
name|strstr
argument_list|(
name|v
argument_list|,
literal|"Mesa"
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|first_time
operator|=
literal|false
expr_stmt|;
block|}
name|CMapEntryHash
modifier|*
name|hash
init|=
name|cmap_handler
argument_list|()
operator|->
name|cmap_hash
decl_stmt|;
name|CMapEntryHash
operator|::
name|ConstIterator
name|it
init|=
name|hash
operator|->
name|constFind
argument_list|(
operator|(
name|long
operator|)
name|vi
operator|->
name|visualid
operator|+
operator|(
name|vi
operator|->
name|screen
operator|*
literal|256
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|)
return|return
name|it
operator|.
name|value
argument_list|()
operator|->
name|cmap
return|;
comment|// found colormap for visual
if|if
condition|(
name|vi
operator|->
name|visualid
operator|==
name|XVisualIDFromVisual
argument_list|(
operator|(
name|Visual
operator|*
operator|)
name|QX11Info
operator|::
name|appVisual
argument_list|(
name|vi
operator|->
name|screen
argument_list|)
argument_list|)
condition|)
block|{
comment|// qDebug("Using x11AppColormap");
return|return
name|QX11Info
operator|::
name|appColormap
argument_list|(
name|vi
operator|->
name|screen
argument_list|)
return|;
block|}
name|QCMapEntry
modifier|*
name|x
init|=
operator|new
name|QCMapEntry
argument_list|()
decl_stmt|;
name|XStandardColormap
modifier|*
name|c
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
comment|// qDebug("Choosing cmap for vID %0x", vi->visualid);
if|if
condition|(
name|mesa_gl
condition|)
block|{
comment|// we're using MesaGL
name|Atom
name|hp_cmaps
init|=
name|XInternAtom
argument_list|(
name|dpy
argument_list|,
literal|"_HP_RGB_SMOOTH_MAP_LIST"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|hp_cmaps
operator|&&
name|vi
operator|->
name|visual
operator|->
name|c_class
operator|==
name|TrueColor
operator|&&
name|vi
operator|->
name|depth
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|XGetRGBColormaps
argument_list|(
name|dpy
argument_list|,
name|RootWindow
argument_list|(
name|dpy
argument_list|,
name|vi
operator|->
name|screen
argument_list|)
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|n
argument_list|,
name|hp_cmaps
argument_list|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
operator|&&
name|x
operator|->
name|cmap
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
index|[
name|i
index|]
operator|.
name|visualid
operator|==
name|vi
operator|->
name|visual
operator|->
name|visualid
condition|)
block|{
name|x
operator|->
name|cmap
operator|=
name|c
index|[
name|i
index|]
operator|.
name|colormap
expr_stmt|;
name|x
operator|->
name|scmap
operator|=
name|c
index|[
name|i
index|]
expr_stmt|;
comment|//qDebug("Using HP_RGB scmap");
block|}
name|i
operator|++
expr_stmt|;
block|}
name|XFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|x
operator|->
name|cmap
condition|)
block|{
if|if
condition|(
name|XGetRGBColormaps
argument_list|(
name|dpy
argument_list|,
name|RootWindow
argument_list|(
name|dpy
argument_list|,
name|vi
operator|->
name|screen
argument_list|)
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|n
argument_list|,
name|XA_RGB_DEFAULT_MAP
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
operator|&&
name|x
operator|->
name|cmap
operator|==
literal|0
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|c
index|[
name|i
index|]
operator|.
name|red_max
operator|||
operator|!
name|c
index|[
name|i
index|]
operator|.
name|green_max
operator|||
operator|!
name|c
index|[
name|i
index|]
operator|.
name|blue_max
operator|||
operator|!
name|c
index|[
name|i
index|]
operator|.
name|red_mult
operator|||
operator|!
name|c
index|[
name|i
index|]
operator|.
name|green_mult
operator|||
operator|!
name|c
index|[
name|i
index|]
operator|.
name|blue_mult
condition|)
continue|continue;
comment|// invalid stdcmap
if|if
condition|(
name|c
index|[
name|i
index|]
operator|.
name|visualid
operator|==
name|vi
operator|->
name|visualid
condition|)
block|{
name|x
operator|->
name|cmap
operator|=
name|c
index|[
name|i
index|]
operator|.
name|colormap
expr_stmt|;
name|x
operator|->
name|scmap
operator|=
name|c
index|[
name|i
index|]
expr_stmt|;
comment|//qDebug("Using RGB_DEFAULT scmap");
block|}
block|}
name|XFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|x
operator|->
name|cmap
condition|)
block|{
comment|// no shared cmap found
name|x
operator|->
name|cmap
operator|=
name|XCreateColormap
argument_list|(
name|dpy
argument_list|,
name|RootWindow
argument_list|(
name|dpy
argument_list|,
name|vi
operator|->
name|screen
argument_list|)
argument_list|,
name|vi
operator|->
name|visual
argument_list|,
name|AllocNone
argument_list|)
expr_stmt|;
name|x
operator|->
name|alloc
operator|=
literal|true
expr_stmt|;
comment|// qDebug("Allocating cmap");
block|}
comment|// colormap hash should be cleanup only when the QApplication dtor is called
if|if
condition|(
name|hash
operator|->
name|isEmpty
argument_list|()
condition|)
name|qAddPostRoutine
argument_list|(
name|cleanup_cmaps
argument_list|)
expr_stmt|;
comment|// associate cmap with visualid
name|hash
operator|->
name|insert
argument_list|(
operator|(
name|long
operator|)
name|vi
operator|->
name|visualid
operator|+
operator|(
name|vi
operator|->
name|screen
operator|*
literal|256
operator|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|x
operator|->
name|cmap
return|;
block|}
end_function
begin_struct
DECL|struct|QTransColor
struct|struct
name|QTransColor
block|{
DECL|member|vis
name|VisualID
name|vis
decl_stmt|;
DECL|member|screen
name|int
name|screen
decl_stmt|;
DECL|member|color
name|long
name|color
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|trans_colors
specifier|static
name|QVector
argument_list|<
name|QTransColor
argument_list|>
name|trans_colors
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|trans_colors_init
specifier|static
name|int
name|trans_colors_init
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|find_trans_colors
specifier|static
name|void
name|find_trans_colors
parameter_list|()
block|{
struct|struct
name|OverlayProp
block|{
name|long
name|visual
decl_stmt|;
name|long
name|type
decl_stmt|;
name|long
name|value
decl_stmt|;
name|long
name|layer
decl_stmt|;
block|}
struct|;
name|trans_colors_init
operator|=
literal|true
expr_stmt|;
name|Display
modifier|*
name|appDisplay
init|=
name|X11
operator|->
name|display
decl_stmt|;
name|int
name|scr
decl_stmt|;
name|int
name|lastsize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|scr
operator|=
literal|0
init|;
name|scr
operator|<
name|ScreenCount
argument_list|(
name|appDisplay
argument_list|)
condition|;
name|scr
operator|++
control|)
block|{
name|QWidget
modifier|*
name|rootWin
init|=
name|QApplication
operator|::
name|desktop
argument_list|()
operator|->
name|screen
argument_list|(
name|scr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rootWin
condition|)
return|return;
comment|// Should not happen
name|Atom
name|overlayVisualsAtom
init|=
name|XInternAtom
argument_list|(
name|appDisplay
argument_list|,
literal|"SERVER_OVERLAY_VISUALS"
argument_list|,
name|True
argument_list|)
decl_stmt|;
if|if
condition|(
name|overlayVisualsAtom
operator|==
name|XNone
condition|)
return|return;
comment|// Server has no overlays
name|Atom
name|actualType
decl_stmt|;
name|int
name|actualFormat
decl_stmt|;
name|ulong
name|nItems
decl_stmt|;
name|ulong
name|bytesAfter
decl_stmt|;
name|unsigned
name|char
modifier|*
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|res
init|=
name|XGetWindowProperty
argument_list|(
name|appDisplay
argument_list|,
name|rootWin
operator|->
name|winId
argument_list|()
argument_list|,
name|overlayVisualsAtom
argument_list|,
literal|0
argument_list|,
literal|10000
argument_list|,
name|False
argument_list|,
name|overlayVisualsAtom
argument_list|,
operator|&
name|actualType
argument_list|,
operator|&
name|actualFormat
argument_list|,
operator|&
name|nItems
argument_list|,
operator|&
name|bytesAfter
argument_list|,
operator|&
name|retval
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
name|Success
operator|||
name|actualType
operator|!=
name|overlayVisualsAtom
operator|||
name|actualFormat
operator|!=
literal|32
operator|||
name|nItems
operator|<
literal|4
operator|||
operator|!
name|retval
condition|)
return|return;
comment|// Error reading property
name|OverlayProp
modifier|*
name|overlayProps
init|=
operator|(
name|OverlayProp
operator|*
operator|)
name|retval
decl_stmt|;
name|int
name|numProps
init|=
name|nItems
operator|/
literal|4
decl_stmt|;
name|trans_colors
operator|.
name|resize
argument_list|(
name|lastsize
operator|+
name|numProps
argument_list|)
expr_stmt|;
name|int
name|j
init|=
name|lastsize
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numProps
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|overlayProps
index|[
name|i
index|]
operator|.
name|type
operator|==
literal|1
condition|)
block|{
name|trans_colors
index|[
name|j
index|]
operator|.
name|vis
operator|=
operator|(
name|VisualID
operator|)
name|overlayProps
index|[
name|i
index|]
operator|.
name|visual
expr_stmt|;
name|trans_colors
index|[
name|j
index|]
operator|.
name|screen
operator|=
name|scr
expr_stmt|;
name|trans_colors
index|[
name|j
index|]
operator|.
name|color
operator|=
operator|(
name|int
operator|)
name|overlayProps
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|XFree
argument_list|(
name|overlayProps
argument_list|)
expr_stmt|;
name|lastsize
operator|=
name|j
expr_stmt|;
name|trans_colors
operator|.
name|resize
argument_list|(
name|lastsize
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*****************************************************************************   QGLFormat UNIX/GLX-specific code  *****************************************************************************/
end_comment
begin_function
DECL|function|qglx_getProcAddress
name|void
modifier|*
name|qglx_getProcAddress
parameter_list|(
specifier|const
name|char
modifier|*
name|procName
parameter_list|)
block|{
comment|// On systems where the GL driver is pluggable (like Mesa), we have to use
comment|// the glXGetProcAddressARB extension to resolve other function pointers as
comment|// the symbols wont be in the GL library, but rather in a plugin loaded by
comment|// the GL library.
typedef|typedef
name|void
modifier|*
function_decl|(
modifier|*
name|qt_glXGetProcAddressARB
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|static
name|qt_glXGetProcAddressARB
name|glXGetProcAddressARB
init|=
literal|0
decl_stmt|;
specifier|static
name|bool
name|triedResolvingGlxGetProcAddress
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|triedResolvingGlxGetProcAddress
condition|)
block|{
name|triedResolvingGlxGetProcAddress
operator|=
literal|true
expr_stmt|;
name|QGLExtensionMatcher
name|extensions
argument_list|(
name|glXGetClientString
argument_list|(
name|QX11Info
operator|::
name|display
argument_list|()
argument_list|,
name|GLX_EXTENSIONS
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|extensions
operator|.
name|match
argument_list|(
literal|"GLX_ARB_get_proc_address"
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_BSD4
argument_list|)
name|void
modifier|*
name|handle
init|=
name|dlopen
argument_list|(
name|NULL
argument_list|,
name|RTLD_LAZY
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
condition|)
block|{
name|glXGetProcAddressARB
operator|=
operator|(
name|qt_glXGetProcAddressARB
operator|)
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"glXGetProcAddressARB"
argument_list|)
expr_stmt|;
name|dlclose
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|glXGetProcAddressARB
condition|)
endif|#
directive|endif
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_LIBRARY
argument_list|)
specifier|extern
specifier|const
name|QString
name|qt_gl_library_name
argument_list|()
decl_stmt|;
name|QLibrary
name|lib
argument_list|(
name|qt_gl_library_name
argument_list|()
argument_list|)
decl_stmt|;
name|glXGetProcAddressARB
operator|=
operator|(
name|qt_glXGetProcAddressARB
operator|)
name|lib
operator|.
name|resolve
argument_list|(
literal|"glXGetProcAddressARB"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
name|void
modifier|*
name|procAddress
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|glXGetProcAddressARB
condition|)
name|procAddress
operator|=
name|glXGetProcAddressARB
argument_list|(
name|procName
argument_list|)
expr_stmt|;
comment|// If glXGetProcAddress didn't work, try looking the symbol up in the GL library
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_BSD4
argument_list|)
if|if
condition|(
operator|!
name|procAddress
condition|)
block|{
name|void
modifier|*
name|handle
init|=
name|dlopen
argument_list|(
name|NULL
argument_list|,
name|RTLD_LAZY
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
condition|)
block|{
name|procAddress
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
name|procName
argument_list|)
expr_stmt|;
name|dlclose
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_LIBRARY
argument_list|)
if|if
condition|(
operator|!
name|procAddress
condition|)
block|{
specifier|extern
specifier|const
name|QString
name|qt_gl_library_name
argument_list|()
decl_stmt|;
name|QLibrary
name|lib
argument_list|(
name|qt_gl_library_name
argument_list|()
argument_list|)
decl_stmt|;
name|procAddress
operator|=
name|lib
operator|.
name|resolve
argument_list|(
name|procName
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|procAddress
return|;
block|}
end_function
begin_function
DECL|function|hasOpenGL
name|bool
name|QGLFormat
operator|::
name|hasOpenGL
parameter_list|()
block|{
return|return
name|glXQueryExtension
argument_list|(
name|X11
operator|->
name|display
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function
begin_function
DECL|function|hasOpenGLOverlays
name|bool
name|QGLFormat
operator|::
name|hasOpenGLOverlays
parameter_list|()
block|{
if|if
condition|(
operator|!
name|trans_colors_init
condition|)
name|find_trans_colors
argument_list|()
expr_stmt|;
return|return
name|trans_colors
operator|.
name|size
argument_list|()
operator|>
literal|0
return|;
block|}
end_function
begin_function
DECL|function|buildSpec
specifier|static
name|bool
name|buildSpec
parameter_list|(
name|int
modifier|*
name|spec
parameter_list|,
specifier|const
name|QGLFormat
modifier|&
name|f
parameter_list|,
name|QPaintDevice
modifier|*
name|paintDevice
parameter_list|,
name|int
name|bufDepth
parameter_list|,
name|bool
name|onlyFBConfig
init|=
literal|false
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_LEVEL
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|f
operator|.
name|plane
argument_list|()
expr_stmt|;
specifier|const
name|QX11Info
modifier|*
name|xinfo
init|=
name|qt_x11Info
argument_list|(
name|paintDevice
argument_list|)
decl_stmt|;
name|bool
name|useFBConfig
init|=
name|onlyFBConfig
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|GLX_VERSION_1_3
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_XRENDER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
comment|/*       HPUX defines GLX_VERSION_1_3 but does not implement the corresponding functions.       Specifically glXChooseFBConfig and glXGetVisualFromFBConfig are not implemented.      */
name|QWidget
modifier|*
name|widget
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|paintDevice
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Widget
condition|)
name|widget
operator|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|paintDevice
argument_list|)
expr_stmt|;
comment|// Only use glXChooseFBConfig for widgets if we're trying to get an ARGB visual
if|if
condition|(
name|widget
operator|&&
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TranslucentBackground
argument_list|)
operator|&&
name|X11
operator|->
name|use_xrender
condition|)
name|useFBConfig
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|GLX_VERSION_1_1
argument_list|)
operator|&&
name|defined
argument_list|(
name|GLX_EXT_visual_info
argument_list|)
specifier|static
name|bool
name|useTranspExt
init|=
literal|false
decl_stmt|;
specifier|static
name|bool
name|useTranspExtChecked
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|plane
argument_list|()
operator|&&
operator|!
name|useTranspExtChecked
operator|&&
name|paintDevice
condition|)
block|{
name|QGLExtensionMatcher
name|extensions
argument_list|(
name|glXQueryExtensionsString
argument_list|(
name|xinfo
operator|->
name|display
argument_list|()
argument_list|,
name|xinfo
operator|->
name|screen
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|useTranspExt
operator|=
name|extensions
operator|.
name|match
argument_list|(
literal|"GLX_EXT_visual_info"
argument_list|)
expr_stmt|;
comment|//# (A bit simplistic; that could theoretically be a substring)
if|if
condition|(
name|useTranspExt
condition|)
block|{
name|QByteArray
name|cstr
argument_list|(
name|glXGetClientString
argument_list|(
name|xinfo
operator|->
name|display
argument_list|()
argument_list|,
name|GLX_VENDOR
argument_list|)
argument_list|)
decl_stmt|;
name|useTranspExt
operator|=
operator|!
name|cstr
operator|.
name|contains
argument_list|(
literal|"Xi Graphics"
argument_list|)
expr_stmt|;
comment|// bug workaround
if|if
condition|(
name|useTranspExt
condition|)
block|{
comment|// bug workaround - some systems (eg. FireGL) refuses to return an overlay
comment|// visual if the GLX_TRANSPARENT_TYPE_EXT attribute is specified, even if
comment|// the implementation supports transparent overlays
name|int
name|tmpSpec
index|[]
init|=
block|{
name|GLX_LEVEL
block|,
name|f
operator|.
name|plane
argument_list|()
block|,
name|GLX_TRANSPARENT_TYPE_EXT
block|,
name|f
operator|.
name|rgba
argument_list|()
operator|?
name|GLX_TRANSPARENT_RGB_EXT
operator|:
name|GLX_TRANSPARENT_INDEX_EXT
block|,
name|XNone
block|}
decl_stmt|;
name|XVisualInfo
modifier|*
name|vinf
init|=
name|glXChooseVisual
argument_list|(
name|xinfo
operator|->
name|display
argument_list|()
argument_list|,
name|xinfo
operator|->
name|screen
argument_list|()
argument_list|,
name|tmpSpec
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vinf
condition|)
block|{
name|useTranspExt
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
name|useTranspExtChecked
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|plane
argument_list|()
operator|&&
name|useTranspExt
operator|&&
operator|!
name|useFBConfig
condition|)
block|{
comment|// Required to avoid non-transparent overlay visual(!) on some systems
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_TRANSPARENT_TYPE_EXT
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|f
operator|.
name|rgba
argument_list|()
condition|?
name|GLX_TRANSPARENT_RGB_EXT
else|:
name|GLX_TRANSPARENT_INDEX_EXT
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|GLX_VERSION_1_3
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
comment|// GLX_RENDER_TYPE is only in glx>=1.3
if|if
condition|(
name|useFBConfig
condition|)
block|{
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_RENDER_TYPE
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|f
operator|.
name|rgba
argument_list|()
condition|?
name|GLX_RGBA_BIT
else|:
name|GLX_COLOR_INDEX_BIT
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|f
operator|.
name|doubleBuffer
argument_list|()
condition|)
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_DOUBLEBUFFER
expr_stmt|;
if|if
condition|(
name|useFBConfig
condition|)
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|True
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|depth
argument_list|()
condition|)
block|{
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_DEPTH_SIZE
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|f
operator|.
name|depthBufferSize
argument_list|()
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
name|f
operator|.
name|depthBufferSize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|stereo
argument_list|()
condition|)
block|{
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_STEREO
expr_stmt|;
if|if
condition|(
name|useFBConfig
condition|)
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|True
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|stencil
argument_list|()
condition|)
block|{
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_STENCIL_SIZE
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|f
operator|.
name|stencilBufferSize
argument_list|()
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
name|f
operator|.
name|stencilBufferSize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|rgba
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|useFBConfig
condition|)
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_RGBA
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_RED_SIZE
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|f
operator|.
name|redBufferSize
argument_list|()
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
name|f
operator|.
name|redBufferSize
argument_list|()
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_GREEN_SIZE
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|f
operator|.
name|greenBufferSize
argument_list|()
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
name|f
operator|.
name|greenBufferSize
argument_list|()
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_BLUE_SIZE
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|f
operator|.
name|blueBufferSize
argument_list|()
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
name|f
operator|.
name|blueBufferSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|alpha
argument_list|()
condition|)
block|{
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_ALPHA_SIZE
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|f
operator|.
name|alphaBufferSize
argument_list|()
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
name|f
operator|.
name|alphaBufferSize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|accum
argument_list|()
condition|)
block|{
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_ACCUM_RED_SIZE
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|f
operator|.
name|accumBufferSize
argument_list|()
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
name|f
operator|.
name|accumBufferSize
argument_list|()
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_ACCUM_GREEN_SIZE
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|f
operator|.
name|accumBufferSize
argument_list|()
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
name|f
operator|.
name|accumBufferSize
argument_list|()
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_ACCUM_BLUE_SIZE
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|f
operator|.
name|accumBufferSize
argument_list|()
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
name|f
operator|.
name|accumBufferSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|alpha
argument_list|()
condition|)
block|{
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_ACCUM_ALPHA_SIZE
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|f
operator|.
name|accumBufferSize
argument_list|()
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
name|f
operator|.
name|accumBufferSize
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_BUFFER_SIZE
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|bufDepth
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|sampleBuffers
argument_list|()
condition|)
block|{
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_SAMPLE_BUFFERS_ARB
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
literal|1
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_SAMPLES_ARB
expr_stmt|;
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|f
operator|.
name|samples
argument_list|()
operator|==
operator|-
literal|1
condition|?
literal|4
else|:
name|f
operator|.
name|samples
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|GLX_VERSION_1_3
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
if|if
condition|(
name|useFBConfig
condition|)
block|{
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_DRAWABLE_TYPE
expr_stmt|;
switch|switch
condition|(
name|paintDevice
operator|->
name|devType
argument_list|()
condition|)
block|{
case|case
name|QInternal
operator|::
name|Pixmap
case|:
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_PIXMAP_BIT
expr_stmt|;
break|break;
case|case
name|QInternal
operator|::
name|Pbuffer
case|:
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_PBUFFER_BIT
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QGLContext: Unknown paint device type %d"
argument_list|,
name|paintDevice
operator|->
name|devType
argument_list|()
argument_list|)
expr_stmt|;
comment|// Fall-through& assume it's a window
case|case
name|QInternal
operator|::
name|Widget
case|:
name|spec
index|[
name|i
operator|++
index|]
operator|=
name|GLX_WINDOW_BIT
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
endif|#
directive|endif
name|spec
index|[
name|i
index|]
operator|=
name|XNone
expr_stmt|;
return|return
name|useFBConfig
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QGLContext UNIX/GLX-specific code  *****************************************************************************/
end_comment
begin_function
DECL|function|chooseContext
name|bool
name|QGLContext
operator|::
name|chooseContext
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|shareContext
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
specifier|const
name|QX11Info
modifier|*
name|xinfo
init|=
name|qt_x11Info
argument_list|(
name|d
operator|->
name|paintDevice
argument_list|)
decl_stmt|;
name|Display
modifier|*
name|disp
init|=
name|xinfo
operator|->
name|display
argument_list|()
decl_stmt|;
name|d
operator|->
name|vi
operator|=
name|chooseVisual
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|vi
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|deviceIsPixmap
argument_list|()
operator|&&
operator|(
operator|(
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
operator|)
operator|->
name|depth
operator|!=
name|xinfo
operator|->
name|depth
argument_list|()
operator|||
operator|(
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
operator|)
operator|->
name|screen
operator|!=
name|xinfo
operator|->
name|screen
argument_list|()
operator|)
condition|)
block|{
name|XFree
argument_list|(
name|d
operator|->
name|vi
argument_list|)
expr_stmt|;
name|XVisualInfo
name|appVisInfo
decl_stmt|;
name|memset
argument_list|(
operator|&
name|appVisInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|XVisualInfo
argument_list|)
argument_list|)
expr_stmt|;
name|appVisInfo
operator|.
name|visualid
operator|=
name|XVisualIDFromVisual
argument_list|(
operator|(
name|Visual
operator|*
operator|)
name|xinfo
operator|->
name|visual
argument_list|()
argument_list|)
expr_stmt|;
name|appVisInfo
operator|.
name|screen
operator|=
name|xinfo
operator|->
name|screen
argument_list|()
expr_stmt|;
name|int
name|nvis
decl_stmt|;
name|d
operator|->
name|vi
operator|=
name|XGetVisualInfo
argument_list|(
name|disp
argument_list|,
name|VisualIDMask
operator||
name|VisualScreenMask
argument_list|,
operator|&
name|appVisInfo
argument_list|,
operator|&
name|nvis
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|vi
condition|)
return|return
literal|false
return|;
name|int
name|useGL
decl_stmt|;
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_USE_GL
argument_list|,
operator|&
name|useGL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|useGL
condition|)
return|return
literal|false
return|;
comment|//# Chickening out already...
block|}
name|int
name|res
decl_stmt|;
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_LEVEL
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|d
operator|->
name|glFormat
operator|.
name|setPlane
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_DOUBLEBUFFER
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|d
operator|->
name|glFormat
operator|.
name|setDoubleBuffer
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_DEPTH_SIZE
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|d
operator|->
name|glFormat
operator|.
name|setDepth
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|glFormat
operator|.
name|depth
argument_list|()
condition|)
name|d
operator|->
name|glFormat
operator|.
name|setDepthBufferSize
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_RGBA
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|d
operator|->
name|glFormat
operator|.
name|setRgba
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_RED_SIZE
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|d
operator|->
name|glFormat
operator|.
name|setRedBufferSize
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_GREEN_SIZE
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|d
operator|->
name|glFormat
operator|.
name|setGreenBufferSize
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_BLUE_SIZE
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|d
operator|->
name|glFormat
operator|.
name|setBlueBufferSize
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_ALPHA_SIZE
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|d
operator|->
name|glFormat
operator|.
name|setAlpha
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|glFormat
operator|.
name|alpha
argument_list|()
condition|)
name|d
operator|->
name|glFormat
operator|.
name|setAlphaBufferSize
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_ACCUM_RED_SIZE
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|d
operator|->
name|glFormat
operator|.
name|setAccum
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|glFormat
operator|.
name|accum
argument_list|()
condition|)
name|d
operator|->
name|glFormat
operator|.
name|setAccumBufferSize
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_STENCIL_SIZE
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|d
operator|->
name|glFormat
operator|.
name|setStencil
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|glFormat
operator|.
name|stencil
argument_list|()
condition|)
name|d
operator|->
name|glFormat
operator|.
name|setStencilBufferSize
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_STEREO
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|d
operator|->
name|glFormat
operator|.
name|setStereo
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_SAMPLE_BUFFERS_ARB
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|d
operator|->
name|glFormat
operator|.
name|setSampleBuffers
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|glFormat
operator|.
name|sampleBuffers
argument_list|()
condition|)
block|{
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_SAMPLES_ARB
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|d
operator|->
name|glFormat
operator|.
name|setSamples
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
name|Bool
name|direct
init|=
name|format
argument_list|()
operator|.
name|directRendering
argument_list|()
condition|?
name|True
else|:
name|False
decl_stmt|;
if|if
condition|(
name|shareContext
operator|&&
operator|(
operator|!
name|shareContext
operator|->
name|isValid
argument_list|()
operator|||
operator|!
name|shareContext
operator|->
name|d_func
argument_list|()
operator|->
name|cx
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLContext::chooseContext(): Cannot share with invalid context"
argument_list|)
expr_stmt|;
name|shareContext
operator|=
literal|0
expr_stmt|;
block|}
comment|// 1. Sharing between rgba and color-index will give wrong colors.
comment|// 2. Contexts cannot be shared btw. direct/non-direct renderers.
comment|// 3. Pixmaps cannot share contexts that are set up for direct rendering.
comment|// 4. If the contexts are not created on the same screen, they can't be shared
if|if
condition|(
name|shareContext
operator|&&
operator|(
name|format
argument_list|()
operator|.
name|rgba
argument_list|()
operator|!=
name|shareContext
operator|->
name|format
argument_list|()
operator|.
name|rgba
argument_list|()
operator|||
operator|(
name|deviceIsPixmap
argument_list|()
operator|&&
name|glXIsDirect
argument_list|(
name|disp
argument_list|,
operator|(
name|GLXContext
operator|)
name|shareContext
operator|->
name|d_func
argument_list|()
operator|->
name|cx
argument_list|)
operator|)
operator|||
operator|(
name|shareContext
operator|->
name|d_func
argument_list|()
operator|->
name|screen
operator|!=
name|xinfo
operator|->
name|screen
argument_list|()
operator|)
operator|)
condition|)
block|{
name|shareContext
operator|=
literal|0
expr_stmt|;
block|}
specifier|const
name|int
name|major
init|=
name|d
operator|->
name|reqFormat
operator|.
name|majorVersion
argument_list|()
decl_stmt|;
specifier|const
name|int
name|minor
init|=
name|d
operator|->
name|reqFormat
operator|.
name|minorVersion
argument_list|()
decl_stmt|;
specifier|const
name|int
name|profile
init|=
name|d
operator|->
name|reqFormat
operator|.
name|profile
argument_list|()
operator|==
name|QGLFormat
operator|::
name|CompatibilityProfile
condition|?
name|GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB
else|:
name|GLX_CONTEXT_CORE_PROFILE_BIT_ARB
decl_stmt|;
name|d
operator|->
name|cx
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|GLX_VERSION_1_3
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
comment|/*       HPUX defines GLX_VERSION_1_3 but does not implement the corresponding functions.       Specifically glXChooseFBConfig and glXGetVisualFromFBConfig are not implemented.      */
if|if
condition|(
operator|(
name|major
operator|==
literal|3
operator|&&
name|minor
operator|>=
literal|2
operator|)
operator|||
name|major
operator|>
literal|3
condition|)
block|{
name|QGLTemporaryContext
modifier|*
name|tmpContext
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|QGLContext
operator|::
name|currentContext
argument_list|()
condition|)
name|tmpContext
operator|=
operator|new
name|QGLTemporaryContext
expr_stmt|;
name|int
name|attributes
index|[]
init|=
block|{
name|GLX_CONTEXT_MAJOR_VERSION_ARB
block|,
name|major
block|,
name|GLX_CONTEXT_MINOR_VERSION_ARB
block|,
name|minor
block|,
name|GLX_CONTEXT_PROFILE_MASK_ARB
block|,
name|profile
block|,
literal|0
block|}
decl_stmt|;
typedef|typedef
name|GLXContext
function_decl|(
modifier|*
name|Q_PFNGLXCREATECONTEXTATTRIBSARBPROC
function_decl|)
parameter_list|(
name|Display
modifier|*
name|dpy
parameter_list|,
name|GLXFBConfig
name|config
parameter_list|,
name|GLXContext
name|share_context
parameter_list|,
name|Bool
name|direct
parameter_list|,
specifier|const
name|int
modifier|*
name|attrib_list
parameter_list|)
function_decl|;
name|Q_PFNGLXCREATECONTEXTATTRIBSARBPROC
name|glXCreateContextAttribs
init|=
operator|(
name|Q_PFNGLXCREATECONTEXTATTRIBSARBPROC
operator|)
name|qglx_getProcAddress
argument_list|(
literal|"glXCreateContextAttribsARB"
argument_list|)
decl_stmt|;
if|if
condition|(
name|glXCreateContextAttribs
condition|)
block|{
name|int
name|spec
index|[
literal|45
index|]
decl_stmt|;
name|glXGetConfig
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|GLX_BUFFER_SIZE
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|buildSpec
argument_list|(
name|spec
argument_list|,
name|format
argument_list|()
argument_list|,
name|d
operator|->
name|paintDevice
argument_list|,
name|res
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|GLXFBConfig
modifier|*
name|configs
decl_stmt|;
name|int
name|configCount
init|=
literal|0
decl_stmt|;
name|configs
operator|=
name|glXChooseFBConfig
argument_list|(
name|disp
argument_list|,
name|xinfo
operator|->
name|screen
argument_list|()
argument_list|,
name|spec
argument_list|,
operator|&
name|configCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|configs
operator|&&
name|configCount
operator|>
literal|0
condition|)
block|{
name|d
operator|->
name|cx
operator|=
name|glXCreateContextAttribs
argument_list|(
name|disp
argument_list|,
name|configs
index|[
literal|0
index|]
argument_list|,
name|shareContext
condition|?
operator|(
name|GLXContext
operator|)
name|shareContext
operator|->
name|d_func
argument_list|()
operator|->
name|cx
else|:
literal|0
argument_list|,
name|direct
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|cx
operator|&&
name|shareContext
condition|)
block|{
name|shareContext
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|cx
operator|=
name|glXCreateContextAttribs
argument_list|(
name|disp
argument_list|,
name|configs
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|direct
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|screen
operator|=
operator|(
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
operator|)
operator|->
name|screen
expr_stmt|;
block|}
name|XFree
argument_list|(
name|configs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QGLContext::chooseContext(): OpenGL %d.%d is not supported"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpContext
condition|)
operator|delete
name|tmpContext
expr_stmt|;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|major
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|minor
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|profile
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|cx
operator|&&
name|shareContext
condition|)
block|{
name|d
operator|->
name|cx
operator|=
name|glXCreateContext
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
operator|(
name|GLXContext
operator|)
name|shareContext
operator|->
name|d_func
argument_list|()
operator|->
name|cx
argument_list|,
name|direct
argument_list|)
expr_stmt|;
name|d
operator|->
name|screen
operator|=
operator|(
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
operator|)
operator|->
name|screen
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|cx
condition|)
block|{
name|d
operator|->
name|cx
operator|=
name|glXCreateContext
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|NULL
argument_list|,
name|direct
argument_list|)
expr_stmt|;
name|d
operator|->
name|screen
operator|=
operator|(
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
operator|)
operator|->
name|screen
expr_stmt|;
name|shareContext
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|shareContext
operator|&&
name|d
operator|->
name|cx
condition|)
block|{
name|QGLContext
modifier|*
name|share
init|=
cast|const_cast
argument_list|<
name|QGLContext
operator|*
argument_list|>
argument_list|(
name|shareContext
argument_list|)
decl_stmt|;
name|d
operator|->
name|sharing
operator|=
literal|true
expr_stmt|;
name|share
operator|->
name|d_func
argument_list|()
operator|->
name|sharing
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|cx
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|glFormat
operator|.
name|setDirectRendering
argument_list|(
name|glXIsDirect
argument_list|(
name|disp
argument_list|,
operator|(
name|GLXContext
operator|)
name|d
operator|->
name|cx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deviceIsPixmap
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|GLX_MESA_pixmap_colormap
argument_list|)
operator|&&
name|defined
argument_list|(
name|QGL_USE_MESA_EXT
argument_list|)
name|d
operator|->
name|gpm
operator|=
name|glXCreateGLXPixmapMESA
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|qt_x11Handle
argument_list|(
name|d
operator|->
name|paintDevice
argument_list|)
argument_list|,
name|qt_gl_choose_cmap
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|gpm
operator|=
operator|(
name|quint32
operator|)
name|glXCreateGLXPixmap
argument_list|(
name|disp
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
argument_list|,
name|qt_x11Handle
argument_list|(
name|d
operator|->
name|paintDevice
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|gpm
condition|)
return|return
literal|false
return|;
block|}
name|QGLExtensionMatcher
name|extensions
argument_list|(
name|glXQueryExtensionsString
argument_list|(
name|xinfo
operator|->
name|display
argument_list|()
argument_list|,
name|xinfo
operator|->
name|screen
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|extensions
operator|.
name|match
argument_list|(
literal|"GLX_SGI_video_sync"
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|glFormat
operator|.
name|swapInterval
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|d
operator|->
name|glFormat
operator|.
name|setSwapInterval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|glFormat
operator|.
name|setSwapInterval
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*   See qgl.cpp for qdoc comment.  */
end_comment
begin_function
DECL|function|chooseVisual
name|void
modifier|*
name|QGLContext
operator|::
name|chooseVisual
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|int
name|bufDepths
index|[]
init|=
block|{
literal|8
block|,
literal|4
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
comment|// Try 16, 12 also?
comment|//todo: if pixmap, also make sure that vi->depth == pixmap->depth
name|void
modifier|*
name|vis
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|bool
name|fail
init|=
literal|false
decl_stmt|;
name|QGLFormat
name|fmt
init|=
name|format
argument_list|()
decl_stmt|;
name|bool
name|tryDouble
init|=
operator|!
name|fmt
operator|.
name|doubleBuffer
argument_list|()
decl_stmt|;
comment|// Some GL impl's only have double
name|bool
name|triedDouble
init|=
literal|false
decl_stmt|;
name|bool
name|triedSample
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|fmt
operator|.
name|sampleBuffers
argument_list|()
condition|)
name|fmt
operator|.
name|setSampleBuffers
argument_list|(
name|QGLExtensions
operator|::
name|glExtensions
argument_list|()
operator|&
name|QGLExtensions
operator|::
name|SampleBuffers
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|fail
operator|&&
operator|!
operator|(
name|vis
operator|=
name|tryVisual
argument_list|(
name|fmt
argument_list|,
name|bufDepths
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|fmt
operator|.
name|rgba
argument_list|()
operator|&&
name|bufDepths
index|[
name|i
index|]
operator|>
literal|1
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tryDouble
condition|)
block|{
name|fmt
operator|.
name|setDoubleBuffer
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|tryDouble
operator|=
literal|false
expr_stmt|;
name|triedDouble
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|triedDouble
condition|)
block|{
name|fmt
operator|.
name|setDoubleBuffer
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|triedDouble
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|triedSample
operator|&&
name|fmt
operator|.
name|sampleBuffers
argument_list|()
condition|)
block|{
name|fmt
operator|.
name|setSampleBuffers
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|triedSample
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fmt
operator|.
name|stereo
argument_list|()
condition|)
block|{
name|fmt
operator|.
name|setStereo
argument_list|(
literal|false
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fmt
operator|.
name|accum
argument_list|()
condition|)
block|{
name|fmt
operator|.
name|setAccum
argument_list|(
literal|false
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fmt
operator|.
name|stencil
argument_list|()
condition|)
block|{
name|fmt
operator|.
name|setStencil
argument_list|(
literal|false
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fmt
operator|.
name|alpha
argument_list|()
condition|)
block|{
name|fmt
operator|.
name|setAlpha
argument_list|(
literal|false
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fmt
operator|.
name|depth
argument_list|()
condition|)
block|{
name|fmt
operator|.
name|setDepth
argument_list|(
literal|false
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fmt
operator|.
name|doubleBuffer
argument_list|()
condition|)
block|{
name|fmt
operator|.
name|setDoubleBuffer
argument_list|(
literal|false
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fail
operator|=
literal|true
expr_stmt|;
block|}
name|d
operator|->
name|glFormat
operator|=
name|fmt
expr_stmt|;
return|return
name|vis
return|;
block|}
end_function
begin_comment
comment|/*   See qgl.cpp for qdoc comment.  */
end_comment
begin_function
DECL|function|tryVisual
name|void
modifier|*
name|QGLContext
operator|::
name|tryVisual
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|f
parameter_list|,
name|int
name|bufDepth
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|int
name|spec
index|[
literal|45
index|]
decl_stmt|;
specifier|const
name|QX11Info
modifier|*
name|xinfo
init|=
name|qt_x11Info
argument_list|(
name|d
operator|->
name|paintDevice
argument_list|)
decl_stmt|;
name|bool
name|useFBConfig
init|=
name|buildSpec
argument_list|(
name|spec
argument_list|,
name|f
argument_list|,
name|d
operator|->
name|paintDevice
argument_list|,
name|bufDepth
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|XVisualInfo
modifier|*
name|chosenVisualInfo
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|GLX_VERSION_1_3
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
while|while
condition|(
name|useFBConfig
condition|)
block|{
name|GLXFBConfig
modifier|*
name|configs
decl_stmt|;
name|int
name|configCount
init|=
literal|0
decl_stmt|;
name|configs
operator|=
name|glXChooseFBConfig
argument_list|(
name|xinfo
operator|->
name|display
argument_list|()
argument_list|,
name|xinfo
operator|->
name|screen
argument_list|()
argument_list|,
name|spec
argument_list|,
operator|&
name|configCount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|configs
condition|)
break|break;
comment|// fallback to trying glXChooseVisual
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|configCount
condition|;
operator|++
name|i
control|)
block|{
name|XVisualInfo
modifier|*
name|vi
decl_stmt|;
name|vi
operator|=
name|glXGetVisualFromFBConfig
argument_list|(
name|xinfo
operator|->
name|display
argument_list|()
argument_list|,
name|configs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vi
condition|)
continue|continue;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_XRENDER
argument_list|)
name|QWidget
modifier|*
name|w
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|paintDevice
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Widget
condition|)
name|w
operator|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|paintDevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|&&
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TranslucentBackground
argument_list|)
operator|&&
name|f
operator|.
name|alpha
argument_list|()
condition|)
block|{
comment|// Attempt to find a config who's visual has a proper alpha channel
name|XRenderPictFormat
modifier|*
name|pictFormat
decl_stmt|;
name|pictFormat
operator|=
name|XRenderFindVisualFormat
argument_list|(
name|xinfo
operator|->
name|display
argument_list|()
argument_list|,
name|vi
operator|->
name|visual
argument_list|)
expr_stmt|;
if|if
condition|(
name|pictFormat
operator|&&
operator|(
name|pictFormat
operator|->
name|type
operator|==
name|PictTypeDirect
operator|)
operator|&&
name|pictFormat
operator|->
name|direct
operator|.
name|alphaMask
condition|)
block|{
comment|// The pict format for the visual matching the FBConfig indicates ARGB
if|if
condition|(
name|chosenVisualInfo
condition|)
name|XFree
argument_list|(
name|chosenVisualInfo
argument_list|)
expr_stmt|;
name|chosenVisualInfo
operator|=
name|vi
expr_stmt|;
break|break;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|//QT_NO_XRENDER
if|if
condition|(
name|chosenVisualInfo
condition|)
block|{
comment|// If we've got a visual we can use and we're not trying to find one with a
comment|// real alpha channel, we might as well just use the one we've got
break|break;
block|}
if|if
condition|(
operator|!
name|chosenVisualInfo
condition|)
name|chosenVisualInfo
operator|=
name|vi
expr_stmt|;
comment|// Have something to fall back to
else|else
name|XFree
argument_list|(
name|vi
argument_list|)
expr_stmt|;
block|}
name|XFree
argument_list|(
name|configs
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|// defined(GLX_VERSION_1_3)
if|if
condition|(
operator|!
name|chosenVisualInfo
condition|)
name|chosenVisualInfo
operator|=
name|glXChooseVisual
argument_list|(
name|xinfo
operator|->
name|display
argument_list|()
argument_list|,
name|xinfo
operator|->
name|screen
argument_list|()
argument_list|,
name|spec
argument_list|)
expr_stmt|;
return|return
name|chosenVisualInfo
return|;
block|}
end_function
begin_function
DECL|function|reset
name|void
name|QGLContext
operator|::
name|reset
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|valid
condition|)
return|return;
name|d
operator|->
name|cleanup
argument_list|()
expr_stmt|;
specifier|const
name|QX11Info
modifier|*
name|xinfo
init|=
name|qt_x11Info
argument_list|(
name|d
operator|->
name|paintDevice
argument_list|)
decl_stmt|;
name|doneCurrent
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|gpm
condition|)
name|glXDestroyGLXPixmap
argument_list|(
name|xinfo
operator|->
name|display
argument_list|()
argument_list|,
operator|(
name|GLXPixmap
operator|)
name|d
operator|->
name|gpm
argument_list|)
expr_stmt|;
name|d
operator|->
name|gpm
operator|=
literal|0
expr_stmt|;
name|glXDestroyContext
argument_list|(
name|xinfo
operator|->
name|display
argument_list|()
argument_list|,
operator|(
name|GLXContext
operator|)
name|d
operator|->
name|cx
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|vi
condition|)
name|XFree
argument_list|(
name|d
operator|->
name|vi
argument_list|)
expr_stmt|;
name|d
operator|->
name|vi
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|cx
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|crWin
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|sharing
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|valid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|transpColor
operator|=
name|QColor
argument_list|()
expr_stmt|;
name|d
operator|->
name|initDone
operator|=
literal|false
expr_stmt|;
name|QGLContextGroup
operator|::
name|removeShare
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|makeCurrent
name|void
name|QGLContext
operator|::
name|makeCurrent
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|valid
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLContext::makeCurrent(): Cannot make invalid context current."
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|QX11Info
modifier|*
name|xinfo
init|=
name|qt_x11Info
argument_list|(
name|d
operator|->
name|paintDevice
argument_list|)
decl_stmt|;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|paintDevice
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Pixmap
condition|)
block|{
name|ok
operator|=
name|glXMakeCurrent
argument_list|(
name|xinfo
operator|->
name|display
argument_list|()
argument_list|,
operator|(
name|GLXPixmap
operator|)
name|d
operator|->
name|gpm
argument_list|,
operator|(
name|GLXContext
operator|)
name|d
operator|->
name|cx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|paintDevice
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Pbuffer
condition|)
block|{
name|ok
operator|=
name|glXMakeCurrent
argument_list|(
name|xinfo
operator|->
name|display
argument_list|()
argument_list|,
operator|(
name|GLXPbuffer
operator|)
name|d
operator|->
name|pbuf
argument_list|,
operator|(
name|GLXContext
operator|)
name|d
operator|->
name|cx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|paintDevice
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Widget
condition|)
block|{
name|ok
operator|=
name|glXMakeCurrent
argument_list|(
name|xinfo
operator|->
name|display
argument_list|()
argument_list|,
operator|(
operator|(
name|QWidget
operator|*
operator|)
name|d
operator|->
name|paintDevice
operator|)
operator|->
name|internalWinId
argument_list|()
argument_list|,
operator|(
name|GLXContext
operator|)
name|d
operator|->
name|cx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
name|qWarning
argument_list|(
literal|"QGLContext::makeCurrent(): Failed."
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
name|QGLContextPrivate
operator|::
name|setCurrentContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|doneCurrent
name|void
name|QGLContext
operator|::
name|doneCurrent
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|glXMakeCurrent
argument_list|(
name|qt_x11Info
argument_list|(
name|d
operator|->
name|paintDevice
argument_list|)
operator|->
name|display
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QGLContextPrivate
operator|::
name|setCurrentContext
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|swapBuffers
name|void
name|QGLContext
operator|::
name|swapBuffers
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|valid
condition|)
return|return;
if|if
condition|(
operator|!
name|deviceIsPixmap
argument_list|()
condition|)
block|{
name|int
name|interval
init|=
name|d
operator|->
name|glFormat
operator|.
name|swapInterval
argument_list|()
decl_stmt|;
if|if
condition|(
name|interval
operator|>
literal|0
condition|)
block|{
typedef|typedef
name|int
function_decl|(
modifier|*
name|qt_glXGetVideoSyncSGI
function_decl|)
parameter_list|(
name|uint
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|qt_glXWaitVideoSyncSGI
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|uint
modifier|*
parameter_list|)
function_decl|;
specifier|static
name|qt_glXGetVideoSyncSGI
name|glXGetVideoSyncSGI
init|=
literal|0
decl_stmt|;
specifier|static
name|qt_glXWaitVideoSyncSGI
name|glXWaitVideoSyncSGI
init|=
literal|0
decl_stmt|;
specifier|static
name|bool
name|resolved
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|resolved
condition|)
block|{
specifier|const
name|QX11Info
modifier|*
name|xinfo
init|=
name|qt_x11Info
argument_list|(
name|d
operator|->
name|paintDevice
argument_list|)
decl_stmt|;
name|QGLExtensionMatcher
name|extensions
argument_list|(
name|glXQueryExtensionsString
argument_list|(
name|xinfo
operator|->
name|display
argument_list|()
argument_list|,
name|xinfo
operator|->
name|screen
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|extensions
operator|.
name|match
argument_list|(
literal|"GLX_SGI_video_sync"
argument_list|)
condition|)
block|{
name|glXGetVideoSyncSGI
operator|=
operator|(
name|qt_glXGetVideoSyncSGI
operator|)
name|qglx_getProcAddress
argument_list|(
literal|"glXGetVideoSyncSGI"
argument_list|)
expr_stmt|;
name|glXWaitVideoSyncSGI
operator|=
operator|(
name|qt_glXWaitVideoSyncSGI
operator|)
name|qglx_getProcAddress
argument_list|(
literal|"glXWaitVideoSyncSGI"
argument_list|)
expr_stmt|;
block|}
name|resolved
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|glXGetVideoSyncSGI
operator|&&
name|glXWaitVideoSyncSGI
condition|)
block|{
name|uint
name|counter
decl_stmt|;
if|if
condition|(
operator|!
name|glXGetVideoSyncSGI
argument_list|(
operator|&
name|counter
argument_list|)
condition|)
name|glXWaitVideoSyncSGI
argument_list|(
name|interval
operator|+
literal|1
argument_list|,
operator|(
name|counter
operator|+
name|interval
operator|)
operator|%
operator|(
name|interval
operator|+
literal|1
operator|)
argument_list|,
operator|&
name|counter
argument_list|)
expr_stmt|;
block|}
block|}
name|glXSwapBuffers
argument_list|(
name|qt_x11Info
argument_list|(
name|d
operator|->
name|paintDevice
argument_list|)
operator|->
name|display
argument_list|()
argument_list|,
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|paintDevice
argument_list|)
operator|->
name|winId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|overlayTransparentColor
name|QColor
name|QGLContext
operator|::
name|overlayTransparentColor
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isValid
argument_list|()
condition|)
return|return
name|Qt
operator|::
name|transparent
return|;
return|return
name|QColor
argument_list|()
return|;
comment|// Invalid color
block|}
end_function
begin_function
DECL|function|qt_transparent_pixel
specifier|static
name|uint
name|qt_transparent_pixel
parameter_list|(
name|VisualID
name|id
parameter_list|,
name|int
name|screen
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trans_colors
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|trans_colors
index|[
name|i
index|]
operator|.
name|vis
operator|==
name|id
operator|&&
name|trans_colors
index|[
name|i
index|]
operator|.
name|screen
operator|==
name|screen
condition|)
return|return
name|trans_colors
index|[
name|i
index|]
operator|.
name|color
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|colorIndex
name|uint
name|QGLContext
operator|::
name|colorIndex
parameter_list|(
specifier|const
name|QColor
modifier|&
name|c
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLContext
argument_list|)
expr_stmt|;
name|int
name|screen
init|=
operator|(
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
operator|)
operator|->
name|screen
decl_stmt|;
name|QColormap
name|colmap
init|=
name|QColormap
operator|::
name|instance
argument_list|(
name|screen
argument_list|)
decl_stmt|;
if|if
condition|(
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|format
argument_list|()
operator|.
name|plane
argument_list|()
operator|&&
name|c
operator|==
name|Qt
operator|::
name|transparent
condition|)
block|{
return|return
name|qt_transparent_pixel
argument_list|(
operator|(
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
operator|)
operator|->
name|visualid
argument_list|,
operator|(
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
operator|)
operator|->
name|screen
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
operator|)
operator|->
name|visualid
operator|==
name|XVisualIDFromVisual
argument_list|(
operator|(
name|Visual
operator|*
operator|)
name|QX11Info
operator|::
name|appVisual
argument_list|(
name|screen
argument_list|)
argument_list|)
condition|)
return|return
name|colmap
operator|.
name|pixel
argument_list|(
name|c
argument_list|)
return|;
comment|// We're using QColor's cmap
name|XVisualInfo
modifier|*
name|info
init|=
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|vi
decl_stmt|;
name|CMapEntryHash
modifier|*
name|hash
init|=
name|cmap_handler
argument_list|()
operator|->
name|cmap_hash
decl_stmt|;
name|CMapEntryHash
operator|::
name|ConstIterator
name|it
init|=
name|hash
operator|->
name|constFind
argument_list|(
name|long
argument_list|(
name|info
operator|->
name|visualid
argument_list|)
operator|+
operator|(
name|info
operator|->
name|screen
operator|*
literal|256
operator|)
argument_list|)
decl_stmt|;
name|QCMapEntry
modifier|*
name|x
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|)
name|x
operator|=
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|&&
operator|!
name|x
operator|->
name|alloc
condition|)
block|{
comment|// It's a standard colormap
name|int
name|rf
init|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|float
operator|)
name|c
operator|.
name|red
argument_list|()
operator|*
operator|(
name|x
operator|->
name|scmap
operator|.
name|red_max
operator|+
literal|1
operator|)
operator|)
operator|/
literal|256.0
argument_list|)
decl_stmt|;
name|int
name|gf
init|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|float
operator|)
name|c
operator|.
name|green
argument_list|()
operator|*
operator|(
name|x
operator|->
name|scmap
operator|.
name|green_max
operator|+
literal|1
operator|)
operator|)
operator|/
literal|256.0
argument_list|)
decl_stmt|;
name|int
name|bf
init|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|float
operator|)
name|c
operator|.
name|blue
argument_list|()
operator|*
operator|(
name|x
operator|->
name|scmap
operator|.
name|blue_max
operator|+
literal|1
operator|)
operator|)
operator|/
literal|256.0
argument_list|)
decl_stmt|;
name|uint
name|p
init|=
name|x
operator|->
name|scmap
operator|.
name|base_pixel
operator|+
operator|(
name|rf
operator|*
name|x
operator|->
name|scmap
operator|.
name|red_mult
operator|)
operator|+
operator|(
name|gf
operator|*
name|x
operator|->
name|scmap
operator|.
name|green_mult
operator|)
operator|+
operator|(
name|bf
operator|*
name|x
operator|->
name|scmap
operator|.
name|blue_mult
operator|)
decl_stmt|;
return|return
name|p
return|;
block|}
else|else
block|{
name|QMap
argument_list|<
name|int
argument_list|,
name|QRgb
argument_list|>
modifier|&
name|cmap
init|=
operator|(
operator|*
name|cmap_handler
argument_list|()
operator|->
name|qglcmap_hash
operator|)
index|[
operator|(
name|long
operator|)
name|info
operator|->
name|visualid
index|]
decl_stmt|;
comment|// already in the map?
name|QRgb
name|target
init|=
name|c
operator|.
name|rgb
argument_list|()
decl_stmt|;
name|QMap
argument_list|<
name|int
argument_list|,
name|QRgb
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|cmap
operator|.
name|begin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|cmap
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|==
name|target
condition|)
return|return
name|it
operator|.
name|key
argument_list|()
return|;
block|}
comment|// need to alloc color
name|unsigned
name|long
name|plane_mask
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|long
name|color_map_entry
decl_stmt|;
if|if
condition|(
operator|!
name|XAllocColorCells
argument_list|(
name|QX11Info
operator|::
name|display
argument_list|()
argument_list|,
name|x
operator|->
name|cmap
argument_list|,
literal|true
argument_list|,
name|plane_mask
argument_list|,
literal|0
argument_list|,
operator|&
name|color_map_entry
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|colmap
operator|.
name|pixel
argument_list|(
name|c
argument_list|)
return|;
name|XColor
name|col
decl_stmt|;
name|col
operator|.
name|flags
operator|=
name|DoRed
operator||
name|DoGreen
operator||
name|DoBlue
expr_stmt|;
name|col
operator|.
name|pixel
operator|=
name|color_map_entry
expr_stmt|;
name|col
operator|.
name|red
operator|=
call|(
name|ushort
call|)
argument_list|(
operator|(
name|qRed
argument_list|(
name|c
operator|.
name|rgb
argument_list|()
argument_list|)
operator|/
literal|255.0
operator|)
operator|*
literal|65535.0
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|col
operator|.
name|green
operator|=
call|(
name|ushort
call|)
argument_list|(
operator|(
name|qGreen
argument_list|(
name|c
operator|.
name|rgb
argument_list|()
argument_list|)
operator|/
literal|255.0
operator|)
operator|*
literal|65535.0
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|col
operator|.
name|blue
operator|=
call|(
name|ushort
call|)
argument_list|(
operator|(
name|qBlue
argument_list|(
name|c
operator|.
name|rgb
argument_list|()
argument_list|)
operator|/
literal|255.0
operator|)
operator|*
literal|65535.0
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|XStoreColor
argument_list|(
name|QX11Info
operator|::
name|display
argument_list|()
argument_list|,
name|x
operator|->
name|cmap
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|insert
argument_list|(
name|color_map_entry
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|color_map_entry
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_FONTCONFIG
end_ifndef
begin_comment
comment|/*! \internal     This is basically a substitute for glxUseXFont() which can only     handle XLFD fonts. This version relies on freetype to render the     glyphs, but it works with all fonts that fontconfig provides - both     antialiased and aliased bitmap and outline fonts. */
end_comment
begin_function
DECL|function|qgl_use_font
specifier|static
name|void
name|qgl_use_font
parameter_list|(
name|QFontEngineFT
modifier|*
name|engine
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|listBase
parameter_list|)
block|{
name|GLfloat
name|color
index|[
literal|4
index|]
decl_stmt|;
name|glGetFloatv
argument_list|(
name|GL_CURRENT_COLOR
argument_list|,
name|color
argument_list|)
expr_stmt|;
comment|// save the pixel unpack state
name|GLint
name|gl_swapbytes
decl_stmt|,
name|gl_lsbfirst
decl_stmt|,
name|gl_rowlength
decl_stmt|,
name|gl_skiprows
decl_stmt|,
name|gl_skippixels
decl_stmt|,
name|gl_alignment
decl_stmt|;
name|glGetIntegerv
argument_list|(
name|GL_UNPACK_SWAP_BYTES
argument_list|,
operator|&
name|gl_swapbytes
argument_list|)
expr_stmt|;
name|glGetIntegerv
argument_list|(
name|GL_UNPACK_LSB_FIRST
argument_list|,
operator|&
name|gl_lsbfirst
argument_list|)
expr_stmt|;
name|glGetIntegerv
argument_list|(
name|GL_UNPACK_ROW_LENGTH
argument_list|,
operator|&
name|gl_rowlength
argument_list|)
expr_stmt|;
name|glGetIntegerv
argument_list|(
name|GL_UNPACK_SKIP_ROWS
argument_list|,
operator|&
name|gl_skiprows
argument_list|)
expr_stmt|;
name|glGetIntegerv
argument_list|(
name|GL_UNPACK_SKIP_PIXELS
argument_list|,
operator|&
name|gl_skippixels
argument_list|)
expr_stmt|;
name|glGetIntegerv
argument_list|(
name|GL_UNPACK_ALIGNMENT
argument_list|,
operator|&
name|gl_alignment
argument_list|)
expr_stmt|;
name|glPixelStorei
argument_list|(
name|GL_UNPACK_SWAP_BYTES
argument_list|,
name|GL_FALSE
argument_list|)
expr_stmt|;
name|glPixelStorei
argument_list|(
name|GL_UNPACK_LSB_FIRST
argument_list|,
name|GL_FALSE
argument_list|)
expr_stmt|;
name|glPixelStorei
argument_list|(
name|GL_UNPACK_ROW_LENGTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|glPixelStorei
argument_list|(
name|GL_UNPACK_SKIP_ROWS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|glPixelStorei
argument_list|(
name|GL_UNPACK_SKIP_PIXELS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|glPixelStorei
argument_list|(
name|GL_UNPACK_ALIGNMENT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|antialiased
init|=
name|engine
operator|->
name|drawAntialiased
argument_list|()
decl_stmt|;
name|FT_Face
name|face
init|=
name|engine
operator|->
name|lockFace
argument_list|()
decl_stmt|;
comment|// start generating font glyphs
for|for
control|(
name|int
name|i
init|=
name|first
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|int
name|list
init|=
name|listBase
operator|+
name|i
decl_stmt|;
name|GLfloat
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|FT_Error
name|err
decl_stmt|;
name|err
operator|=
name|FT_Load_Glyph
argument_list|(
name|face
argument_list|,
name|FT_Get_Char_Index
argument_list|(
name|face
argument_list|,
name|i
argument_list|)
argument_list|,
name|FT_LOAD_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|qDebug
argument_list|(
literal|"failed loading glyph %d from font"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|err
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|FT_Render_Glyph
argument_list|(
name|face
operator|->
name|glyph
argument_list|,
operator|(
name|antialiased
condition|?
name|FT_RENDER_MODE_NORMAL
else|:
name|FT_RENDER_MODE_MONO
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|qDebug
argument_list|(
literal|"failed rendering glyph %d from font"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|err
argument_list|)
expr_stmt|;
block|}
name|FT_Bitmap
name|bm
init|=
name|face
operator|->
name|glyph
operator|->
name|bitmap
decl_stmt|;
name|x0
operator|=
name|face
operator|->
name|glyph
operator|->
name|metrics
operator|.
name|horiBearingX
operator|>>
literal|6
expr_stmt|;
name|y0
operator|=
operator|(
name|face
operator|->
name|glyph
operator|->
name|metrics
operator|.
name|height
operator|-
name|face
operator|->
name|glyph
operator|->
name|metrics
operator|.
name|horiBearingY
operator|)
operator|>>
literal|6
expr_stmt|;
name|dx
operator|=
name|face
operator|->
name|glyph
operator|->
name|metrics
operator|.
name|horiAdvance
operator|>>
literal|6
expr_stmt|;
name|dy
operator|=
literal|0
expr_stmt|;
name|int
name|sz
init|=
name|bm
operator|.
name|pitch
operator|*
name|bm
operator|.
name|rows
decl_stmt|;
name|uint
modifier|*
name|aa_glyph
init|=
literal|0
decl_stmt|;
name|uchar
modifier|*
name|ua_glyph
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|antialiased
condition|)
name|aa_glyph
operator|=
operator|new
name|uint
index|[
name|sz
index|]
expr_stmt|;
else|else
name|ua_glyph
operator|=
operator|new
name|uchar
index|[
name|sz
index|]
expr_stmt|;
comment|// convert to GL format
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|bm
operator|.
name|rows
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|bm
operator|.
name|pitch
condition|;
operator|++
name|x
control|)
block|{
name|int
name|c1
init|=
name|y
operator|*
name|bm
operator|.
name|pitch
operator|+
name|x
decl_stmt|;
name|int
name|c2
init|=
operator|(
name|bm
operator|.
name|rows
operator|-
name|y
operator|-
literal|1
operator|)
operator|>
literal|0
condition|?
operator|(
name|bm
operator|.
name|rows
operator|-
name|y
operator|-
literal|1
operator|)
operator|*
name|bm
operator|.
name|pitch
operator|+
name|x
else|:
name|x
decl_stmt|;
if|if
condition|(
name|antialiased
condition|)
block|{
name|aa_glyph
index|[
name|c1
index|]
operator|=
operator|(
name|int
argument_list|(
name|color
index|[
literal|0
index|]
operator|*
literal|255
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|int
argument_list|(
name|color
index|[
literal|1
index|]
operator|*
literal|255
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|int
argument_list|(
name|color
index|[
literal|2
index|]
operator|*
literal|255
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|bm
operator|.
name|buffer
index|[
name|c2
index|]
expr_stmt|;
block|}
else|else
block|{
name|ua_glyph
index|[
name|c1
index|]
operator|=
name|bm
operator|.
name|buffer
index|[
name|c2
index|]
expr_stmt|;
block|}
block|}
block|}
name|glNewList
argument_list|(
name|list
argument_list|,
name|GL_COMPILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|antialiased
condition|)
block|{
comment|// calling glBitmap() is just a trick to move the current
comment|// raster pos, since glGet*() won't work in display lists
name|glBitmap
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|x0
argument_list|,
operator|-
name|y0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|glDrawPixels
argument_list|(
name|bm
operator|.
name|pitch
argument_list|,
name|bm
operator|.
name|rows
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_INT_8_8_8_8
argument_list|,
name|aa_glyph
argument_list|)
expr_stmt|;
name|glBitmap
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dx
operator|-
name|x0
argument_list|,
name|y0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glBitmap
argument_list|(
name|bm
operator|.
name|pitch
operator|*
literal|8
argument_list|,
name|bm
operator|.
name|rows
argument_list|,
operator|-
name|x0
argument_list|,
name|y0
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|ua_glyph
argument_list|)
expr_stmt|;
block|}
name|glEndList
argument_list|()
expr_stmt|;
name|antialiased
condition|?
operator|delete
index|[]
name|aa_glyph
else|:
operator|delete
index|[]
name|ua_glyph
expr_stmt|;
block|}
name|engine
operator|->
name|unlockFace
argument_list|()
expr_stmt|;
comment|// restore pixel unpack settings
name|glPixelStorei
argument_list|(
name|GL_UNPACK_SWAP_BYTES
argument_list|,
name|gl_swapbytes
argument_list|)
expr_stmt|;
name|glPixelStorei
argument_list|(
name|GL_UNPACK_LSB_FIRST
argument_list|,
name|gl_lsbfirst
argument_list|)
expr_stmt|;
name|glPixelStorei
argument_list|(
name|GL_UNPACK_ROW_LENGTH
argument_list|,
name|gl_rowlength
argument_list|)
expr_stmt|;
name|glPixelStorei
argument_list|(
name|GL_UNPACK_SKIP_ROWS
argument_list|,
name|gl_skiprows
argument_list|)
expr_stmt|;
name|glPixelStorei
argument_list|(
name|GL_UNPACK_SKIP_PIXELS
argument_list|,
name|gl_skippixels
argument_list|)
expr_stmt|;
name|glPixelStorei
argument_list|(
name|GL_UNPACK_ALIGNMENT
argument_list|,
name|gl_alignment
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|d
undef|#
directive|undef
name|d
end_undef
begin_function
DECL|function|generateFontDisplayLists
name|void
name|QGLContext
operator|::
name|generateFontDisplayLists
parameter_list|(
specifier|const
name|QFont
modifier|&
name|fnt
parameter_list|,
name|int
name|listBase
parameter_list|)
block|{
name|QFont
name|f
argument_list|(
name|fnt
argument_list|)
decl_stmt|;
name|QFontEngine
modifier|*
name|engine
init|=
name|f
operator|.
name|d
operator|->
name|engineForScript
argument_list|(
name|QUnicodeTables
operator|::
name|Common
argument_list|)
decl_stmt|;
if|if
condition|(
name|engine
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|Multi
condition|)
name|engine
operator|=
cast|static_cast
argument_list|<
name|QFontEngineMulti
operator|*
argument_list|>
argument_list|(
name|engine
argument_list|)
operator|->
name|engine
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_FONTCONFIG
if|if
condition|(
name|engine
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|Freetype
condition|)
block|{
name|qgl_use_font
argument_list|(
cast|static_cast
argument_list|<
name|QFontEngineFT
operator|*
argument_list|>
argument_list|(
name|engine
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|,
name|listBase
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|// glXUseXFont() only works with XLFD font structures and a few GL
comment|// drivers crash if 0 is passed as the font handle
name|f
operator|.
name|setStyleStrategy
argument_list|(
name|QFont
operator|::
name|OpenGLCompatible
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|handle
argument_list|()
operator|&&
name|engine
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|XLFD
condition|)
name|glXUseXFont
argument_list|(
cast|static_cast
argument_list|<
name|Font
argument_list|>
argument_list|(
name|f
operator|.
name|handle
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|,
name|listBase
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getProcAddress
name|void
modifier|*
name|QGLContext
operator|::
name|getProcAddress
parameter_list|(
specifier|const
name|QString
modifier|&
name|proc
parameter_list|)
specifier|const
block|{
typedef|typedef
name|void
modifier|*
function_decl|(
modifier|*
name|qt_glXGetProcAddressARB
function_decl|)
parameter_list|(
specifier|const
name|GLubyte
modifier|*
parameter_list|)
function_decl|;
specifier|static
name|qt_glXGetProcAddressARB
name|glXGetProcAddressARB
init|=
literal|0
decl_stmt|;
specifier|static
name|bool
name|resolved
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|resolved
operator|&&
operator|!
name|glXGetProcAddressARB
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|glXGetProcAddressARB
condition|)
block|{
name|QGLExtensionMatcher
name|extensions
argument_list|(
name|glXGetClientString
argument_list|(
name|QX11Info
operator|::
name|display
argument_list|()
argument_list|,
name|GLX_EXTENSIONS
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|extensions
operator|.
name|match
argument_list|(
literal|"GLX_ARB_get_proc_address"
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_BSD4
argument_list|)
name|void
modifier|*
name|handle
init|=
name|dlopen
argument_list|(
name|NULL
argument_list|,
name|RTLD_LAZY
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
condition|)
block|{
name|glXGetProcAddressARB
operator|=
operator|(
name|qt_glXGetProcAddressARB
operator|)
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"glXGetProcAddressARB"
argument_list|)
expr_stmt|;
name|dlclose
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|glXGetProcAddressARB
condition|)
endif|#
directive|endif
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_LIBRARY
argument_list|)
specifier|extern
specifier|const
name|QString
name|qt_gl_library_name
argument_list|()
decl_stmt|;
name|QLibrary
name|lib
argument_list|(
name|qt_gl_library_name
argument_list|()
argument_list|)
decl_stmt|;
name|glXGetProcAddressARB
operator|=
operator|(
name|qt_glXGetProcAddressARB
operator|)
name|lib
operator|.
name|resolve
argument_list|(
literal|"glXGetProcAddressARB"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|resolved
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|glXGetProcAddressARB
condition|)
return|return
literal|0
return|;
return|return
name|glXGetProcAddressARB
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|proc
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*     QGLTemporaryContext implementation */
end_comment
begin_class
DECL|class|QGLTemporaryContextPrivate
class|class
name|QGLTemporaryContextPrivate
block|{
public|public:
DECL|member|initialized
name|bool
name|initialized
decl_stmt|;
DECL|member|drawable
name|Window
name|drawable
decl_stmt|;
DECL|member|context
name|GLXContext
name|context
decl_stmt|;
DECL|member|oldDrawable
name|GLXDrawable
name|oldDrawable
decl_stmt|;
DECL|member|oldContext
name|GLXContext
name|oldContext
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|QGLTemporaryContext
name|QGLTemporaryContext
operator|::
name|QGLTemporaryContext
parameter_list|(
name|bool
parameter_list|,
name|QWidget
modifier|*
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QGLTemporaryContextPrivate
argument_list|)
block|{
name|d
operator|->
name|initialized
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|oldDrawable
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|oldContext
operator|=
literal|0
expr_stmt|;
name|int
name|screen
init|=
literal|0
decl_stmt|;
name|int
name|attribs
index|[]
init|=
block|{
name|GLX_RGBA
block|,
name|XNone
block|}
decl_stmt|;
name|XVisualInfo
modifier|*
name|vi
init|=
name|glXChooseVisual
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|screen
argument_list|,
name|attribs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vi
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLTempContext: No GL capable X visuals available."
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|useGL
decl_stmt|;
name|glXGetConfig
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|vi
argument_list|,
name|GLX_USE_GL
argument_list|,
operator|&
name|useGL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|useGL
condition|)
block|{
name|XFree
argument_list|(
name|vi
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|oldDrawable
operator|=
name|glXGetCurrentDrawable
argument_list|()
expr_stmt|;
name|d
operator|->
name|oldContext
operator|=
name|glXGetCurrentContext
argument_list|()
expr_stmt|;
name|XSetWindowAttributes
name|a
decl_stmt|;
name|a
operator|.
name|colormap
operator|=
name|qt_gl_choose_cmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|vi
argument_list|)
expr_stmt|;
name|d
operator|->
name|drawable
operator|=
name|XCreateWindow
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|RootWindow
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|screen
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|vi
operator|->
name|depth
argument_list|,
name|InputOutput
argument_list|,
name|vi
operator|->
name|visual
argument_list|,
name|CWColormap
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|d
operator|->
name|context
operator|=
name|glXCreateContext
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|vi
argument_list|,
literal|0
argument_list|,
name|True
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|context
operator|&&
name|glXMakeCurrent
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|d
operator|->
name|drawable
argument_list|,
name|d
operator|->
name|context
argument_list|)
condition|)
block|{
name|d
operator|->
name|initialized
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QGLTempContext: Unable to create GL context."
argument_list|)
expr_stmt|;
name|XDestroyWindow
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|d
operator|->
name|drawable
argument_list|)
expr_stmt|;
block|}
name|XFree
argument_list|(
name|vi
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QGLTemporaryContext
name|QGLTemporaryContext
operator|::
name|~
name|QGLTemporaryContext
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|initialized
condition|)
block|{
name|glXMakeCurrent
argument_list|(
name|X11
operator|->
name|display
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|glXDestroyContext
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|d
operator|->
name|context
argument_list|)
expr_stmt|;
name|XDestroyWindow
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|d
operator|->
name|drawable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|oldDrawable
operator|&&
name|d
operator|->
name|oldContext
condition|)
name|glXMakeCurrent
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|d
operator|->
name|oldDrawable
argument_list|,
name|d
operator|->
name|oldContext
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*****************************************************************************   QGLOverlayWidget (Internal overlay class for X11)  *****************************************************************************/
end_comment
begin_class
DECL|class|QGLOverlayWidget
class|class
name|QGLOverlayWidget
super|:
specifier|public
name|QGLWidget
block|{
name|Q_OBJECT
public|public:
name|QGLOverlayWidget
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|format
parameter_list|,
name|QGLWidget
modifier|*
name|parent
parameter_list|,
specifier|const
name|QGLWidget
modifier|*
name|shareWidget
init|=
literal|0
parameter_list|)
constructor_decl|;
protected|protected:
name|void
name|initializeGL
parameter_list|()
function_decl|;
name|void
name|paintGL
parameter_list|()
function_decl|;
name|void
name|resizeGL
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
function_decl|;
DECL|function|x11Event
name|bool
name|x11Event
parameter_list|(
name|XEvent
modifier|*
name|e
parameter_list|)
block|{
return|return
name|realWidget
operator|->
name|x11Event
argument_list|(
name|e
argument_list|)
return|;
block|}
private|private:
DECL|member|realWidget
name|QGLWidget
modifier|*
name|realWidget
decl_stmt|;
private|private:
name|Q_DISABLE_COPY
argument_list|(
argument|QGLOverlayWidget
argument_list|)
block|}
class|;
end_class
begin_constructor
DECL|function|QGLOverlayWidget
name|QGLOverlayWidget
operator|::
name|QGLOverlayWidget
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|format
parameter_list|,
name|QGLWidget
modifier|*
name|parent
parameter_list|,
specifier|const
name|QGLWidget
modifier|*
name|shareWidget
parameter_list|)
member_init_list|:
name|QGLWidget
argument_list|(
name|format
argument_list|,
name|parent
argument_list|,
name|shareWidget
condition|?
name|shareWidget
operator|->
name|d_func
argument_list|()
operator|->
name|olw
else|:
literal|0
argument_list|)
block|{
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_X11OpenGLOverlay
argument_list|)
expr_stmt|;
name|realWidget
operator|=
name|parent
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|initializeGL
name|void
name|QGLOverlayWidget
operator|::
name|initializeGL
parameter_list|()
block|{
name|QColor
name|transparentColor
init|=
name|context
argument_list|()
operator|->
name|overlayTransparentColor
argument_list|()
decl_stmt|;
if|if
condition|(
name|transparentColor
operator|.
name|isValid
argument_list|()
condition|)
name|qglClearColor
argument_list|(
name|transparentColor
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QGLOverlayWidget::initializeGL(): Could not get transparent color"
argument_list|)
expr_stmt|;
name|realWidget
operator|->
name|initializeOverlayGL
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resizeGL
name|void
name|QGLOverlayWidget
operator|::
name|resizeGL
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|glViewport
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|realWidget
operator|->
name|resizeOverlayGL
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|paintGL
name|void
name|QGLOverlayWidget
operator|::
name|paintGL
parameter_list|()
block|{
name|realWidget
operator|->
name|paintOverlayGL
argument_list|()
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|Bool
undef|#
directive|undef
name|Bool
end_undef
begin_function
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|"qgl_x11.moc"
name|QT_END_INCLUDE_NAMESPACE
comment|/*****************************************************************************   QGLWidget UNIX/GLX-specific code  *****************************************************************************/
DECL|function|init
name|void
name|QGLWidgetPrivate
operator|::
name|init
parameter_list|(
name|QGLContext
modifier|*
name|context
parameter_list|,
specifier|const
name|QGLWidget
modifier|*
name|shareWidget
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|initContext
argument_list|(
name|context
argument_list|,
name|shareWidget
argument_list|)
expr_stmt|;
name|olw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|isValid
argument_list|()
operator|&&
name|context
operator|->
name|format
argument_list|()
operator|.
name|hasOverlay
argument_list|()
condition|)
block|{
name|QString
name|olwName
init|=
name|q
operator|->
name|objectName
argument_list|()
decl_stmt|;
name|olwName
operator|+=
name|QLatin1String
argument_list|(
literal|"-QGL_internal_overlay_widget"
argument_list|)
expr_stmt|;
name|olw
operator|=
operator|new
name|QGLOverlayWidget
argument_list|(
name|QGLFormat
operator|::
name|defaultOverlayFormat
argument_list|()
argument_list|,
name|q
argument_list|,
name|shareWidget
argument_list|)
expr_stmt|;
name|olw
operator|->
name|setObjectName
argument_list|(
name|olwName
argument_list|)
expr_stmt|;
if|if
condition|(
name|olw
operator|->
name|isValid
argument_list|()
condition|)
block|{
name|olw
operator|->
name|setAutoBufferSwap
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|olw
operator|->
name|setFocusProxy
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|delete
name|olw
expr_stmt|;
name|olw
operator|=
literal|0
expr_stmt|;
name|glcx
operator|->
name|d_func
argument_list|()
operator|->
name|glFormat
operator|.
name|setOverlay
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|renderCxPm
name|bool
name|QGLWidgetPrivate
operator|::
name|renderCxPm
parameter_list|(
name|QPixmap
modifier|*
name|pm
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|XVisualInfo
operator|*
operator|)
name|glcx
operator|->
name|d_func
argument_list|()
operator|->
name|vi
operator|)
operator|->
name|depth
operator|!=
name|pm
operator|->
name|depth
argument_list|()
condition|)
return|return
literal|false
return|;
name|GLXPixmap
name|glPm
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|GLX_MESA_pixmap_colormap
argument_list|)
operator|&&
name|defined
argument_list|(
name|QGL_USE_MESA_EXT
argument_list|)
name|glPm
operator|=
name|glXCreateGLXPixmapMESA
argument_list|(
name|X11
operator|->
name|display
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|glcx
operator|->
name|vi
argument_list|,
operator|(
name|Pixmap
operator|)
name|pm
operator|->
name|handle
argument_list|()
argument_list|,
name|qt_gl_choose_cmap
argument_list|(
name|pm
operator|->
name|X11
operator|->
name|display
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|glcx
operator|->
name|vi
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|glPm
operator|=
operator|(
name|quint32
operator|)
name|glXCreateGLXPixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
operator|(
name|XVisualInfo
operator|*
operator|)
name|glcx
operator|->
name|d_func
argument_list|()
operator|->
name|vi
argument_list|,
operator|(
name|Pixmap
operator|)
name|pm
operator|->
name|handle
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|glXMakeCurrent
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|glPm
argument_list|,
operator|(
name|GLXContext
operator|)
name|glcx
operator|->
name|d_func
argument_list|()
operator|->
name|cx
argument_list|)
condition|)
block|{
name|glXDestroyGLXPixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|glPm
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|glDrawBuffer
argument_list|(
name|GL_FRONT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glcx
operator|->
name|initialized
argument_list|()
condition|)
name|q
operator|->
name|glInit
argument_list|()
expr_stmt|;
name|q
operator|->
name|resizeGL
argument_list|(
name|pm
operator|->
name|width
argument_list|()
argument_list|,
name|pm
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|paintGL
argument_list|()
expr_stmt|;
name|glFlush
argument_list|()
expr_stmt|;
name|q
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
name|glXDestroyGLXPixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|glPm
argument_list|)
expr_stmt|;
name|q
operator|->
name|resizeGL
argument_list|(
name|q
operator|->
name|width
argument_list|()
argument_list|,
name|q
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal   Free up any allocated colormaps. This fn is only called for   top-level widgets. */
end_comment
begin_function
DECL|function|cleanupColormaps
name|void
name|QGLWidgetPrivate
operator|::
name|cleanupColormaps
parameter_list|()
block|{
if|if
condition|(
operator|!
name|cmap
operator|.
name|handle
argument_list|()
condition|)
block|{
return|return;
block|}
else|else
block|{
name|XFreeColormap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
operator|(
name|Colormap
operator|)
name|cmap
operator|.
name|handle
argument_list|()
argument_list|)
expr_stmt|;
name|cmap
operator|.
name|setHandle
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setMouseTracking
name|void
name|QGLWidget
operator|::
name|setMouseTracking
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|olw
condition|)
name|d
operator|->
name|olw
operator|->
name|setMouseTracking
argument_list|(
name|enable
argument_list|)
expr_stmt|;
name|QWidget
operator|::
name|setMouseTracking
argument_list|(
name|enable
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resizeEvent
name|void
name|QGLWidget
operator|::
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return;
name|makeCurrent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|glcx
operator|->
name|initialized
argument_list|()
condition|)
name|glInit
argument_list|()
expr_stmt|;
name|glXWaitX
argument_list|()
expr_stmt|;
name|resizeGL
argument_list|(
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|olw
condition|)
name|d
operator|->
name|olw
operator|->
name|setGeometry
argument_list|(
name|rect
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|overlayContext
specifier|const
name|QGLContext
modifier|*
name|QGLWidget
operator|::
name|overlayContext
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|olw
condition|)
return|return
name|d
operator|->
name|olw
operator|->
name|context
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|makeOverlayCurrent
name|void
name|QGLWidget
operator|::
name|makeOverlayCurrent
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|olw
condition|)
name|d
operator|->
name|olw
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateOverlayGL
name|void
name|QGLWidget
operator|::
name|updateOverlayGL
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|olw
condition|)
name|d
operator|->
name|olw
operator|->
name|updateGL
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Sets a new QGLContext, \a context, for this QGLWidget, using the     shared context, \a shareContext. If \a deleteOldContext is true,     the original context is deleted; otherwise it is overridden. */
end_comment
begin_function
DECL|function|setContext
name|void
name|QGLWidget
operator|::
name|setContext
parameter_list|(
name|QGLContext
modifier|*
name|context
parameter_list|,
specifier|const
name|QGLContext
modifier|*
name|shareContext
parameter_list|,
name|bool
name|deleteOldContext
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLWidget::setContext: Cannot set null context"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|context
operator|->
name|deviceIsPixmap
argument_list|()
operator|&&
name|context
operator|->
name|device
argument_list|()
operator|!=
name|this
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLWidget::setContext: Context must refer to this widget"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|glcx
condition|)
name|d
operator|->
name|glcx
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
name|QGLContext
modifier|*
name|oldcx
init|=
name|d
operator|->
name|glcx
decl_stmt|;
name|d
operator|->
name|glcx
operator|=
name|context
expr_stmt|;
if|if
condition|(
name|parentWidget
argument_list|()
condition|)
block|{
comment|// force creation of delay-created widgets
name|parentWidget
argument_list|()
operator|->
name|winId
argument_list|()
expr_stmt|;
if|if
condition|(
name|parentWidget
argument_list|()
operator|->
name|x11Info
argument_list|()
operator|.
name|screen
argument_list|()
operator|!=
name|x11Info
argument_list|()
operator|.
name|screen
argument_list|()
condition|)
name|d_func
argument_list|()
operator|->
name|xinfo
operator|=
name|parentWidget
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|xinfo
expr_stmt|;
block|}
comment|// If the application has set WA_TranslucentBackground and not explicitly set
comment|// the alpha buffer size to zero, modify the format so it have an alpha channel
name|QGLFormat
modifier|&
name|fmt
init|=
name|d
operator|->
name|glcx
operator|->
name|d_func
argument_list|()
operator|->
name|glFormat
decl_stmt|;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TranslucentBackground
argument_list|)
operator|&&
name|fmt
operator|.
name|alphaBufferSize
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|fmt
operator|.
name|setAlphaBufferSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bool
name|createFailed
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|glcx
operator|->
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|glcx
operator|->
name|create
argument_list|(
name|shareContext
condition|?
name|shareContext
else|:
name|oldcx
argument_list|)
condition|)
name|createFailed
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|createFailed
condition|)
block|{
if|if
condition|(
name|deleteOldContext
condition|)
operator|delete
name|oldcx
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|glcx
operator|->
name|windowCreated
argument_list|()
operator|||
name|d
operator|->
name|glcx
operator|->
name|deviceIsPixmap
argument_list|()
condition|)
block|{
if|if
condition|(
name|deleteOldContext
condition|)
operator|delete
name|oldcx
expr_stmt|;
return|return;
block|}
name|bool
name|visible
init|=
name|isVisible
argument_list|()
decl_stmt|;
if|if
condition|(
name|visible
condition|)
name|hide
argument_list|()
expr_stmt|;
name|XVisualInfo
modifier|*
name|vi
init|=
operator|(
name|XVisualInfo
operator|*
operator|)
name|d
operator|->
name|glcx
operator|->
name|d_func
argument_list|()
operator|->
name|vi
decl_stmt|;
name|XSetWindowAttributes
name|a
decl_stmt|;
name|QColormap
name|colmap
init|=
name|QColormap
operator|::
name|instance
argument_list|(
name|vi
operator|->
name|screen
argument_list|)
decl_stmt|;
name|a
operator|.
name|colormap
operator|=
name|qt_gl_choose_cmap
argument_list|(
name|QX11Info
operator|::
name|display
argument_list|()
argument_list|,
name|vi
argument_list|)
expr_stmt|;
comment|// find best colormap
name|a
operator|.
name|background_pixel
operator|=
name|colmap
operator|.
name|pixel
argument_list|(
name|palette
argument_list|()
operator|.
name|color
argument_list|(
name|backgroundRole
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|.
name|border_pixel
operator|=
name|colmap
operator|.
name|pixel
argument_list|(
name|Qt
operator|::
name|black
argument_list|)
expr_stmt|;
name|Window
name|p
init|=
name|RootWindow
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|vi
operator|->
name|screen
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentWidget
argument_list|()
condition|)
name|p
operator|=
name|parentWidget
argument_list|()
operator|->
name|winId
argument_list|()
expr_stmt|;
name|Window
name|w
init|=
name|XCreateWindow
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|p
argument_list|,
name|x
argument_list|()
argument_list|,
name|y
argument_list|()
argument_list|,
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|,
literal|0
argument_list|,
name|vi
operator|->
name|depth
argument_list|,
name|InputOutput
argument_list|,
name|vi
operator|->
name|visual
argument_list|,
name|CWBackPixel
operator||
name|CWBorderPixel
operator||
name|CWColormap
argument_list|,
operator|&
name|a
argument_list|)
decl_stmt|;
name|Window
modifier|*
name|cmw
decl_stmt|;
name|Window
modifier|*
name|cmwret
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|XGetWMColormapWindows
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|window
argument_list|()
operator|->
name|winId
argument_list|()
argument_list|,
operator|&
name|cmwret
argument_list|,
operator|&
name|count
argument_list|)
condition|)
block|{
name|cmw
operator|=
operator|new
name|Window
index|[
name|count
operator|+
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmw
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cmwret
argument_list|,
sizeof|sizeof
argument_list|(
name|Window
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|XFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmwret
argument_list|)
expr_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmw
index|[
name|i
index|]
operator|==
name|winId
argument_list|()
condition|)
block|{
comment|// replace old window
name|cmw
index|[
name|i
index|]
operator|=
name|w
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|count
condition|)
comment|// append new window
name|cmw
index|[
name|count
operator|++
index|]
operator|=
name|w
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|cmw
operator|=
operator|new
name|Window
index|[
name|count
index|]
expr_stmt|;
name|cmw
index|[
literal|0
index|]
operator|=
name|w
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|GLX_MESA_release_buffers
argument_list|)
operator|&&
name|defined
argument_list|(
name|QGL_USE_MESA_EXT
argument_list|)
if|if
condition|(
name|oldcx
operator|&&
name|oldcx
operator|->
name|windowCreated
argument_list|()
condition|)
name|glXReleaseBuffersMESA
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|winId
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|deleteOldContext
condition|)
operator|delete
name|oldcx
expr_stmt|;
name|oldcx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|create
argument_list|(
name|w
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|createWinId
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|XSetWMColormapWindows
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|window
argument_list|()
operator|->
name|winId
argument_list|()
argument_list|,
name|cmw
argument_list|,
name|count
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|cmw
expr_stmt|;
comment|// calling QWidget::create() will always result in a new paint
comment|// engine being created - get rid of it and replace it with our
comment|// own
if|if
condition|(
name|visible
condition|)
name|show
argument_list|()
expr_stmt|;
name|XFlush
argument_list|(
name|X11
operator|->
name|display
argument_list|)
expr_stmt|;
name|d
operator|->
name|glcx
operator|->
name|setWindowCreated
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|colormap
specifier|const
name|QGLColormap
modifier|&
name|QGLWidget
operator|::
name|colormap
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|cmap
return|;
block|}
end_function
begin_comment
comment|/*\internal   Store color values in the given colormap. */
end_comment
begin_function
DECL|function|qStoreColors
specifier|static
name|void
name|qStoreColors
parameter_list|(
name|QWidget
modifier|*
name|tlw
parameter_list|,
name|Colormap
name|cmap
parameter_list|,
specifier|const
name|QGLColormap
modifier|&
name|cols
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|tlw
argument_list|)
expr_stmt|;
name|XColor
name|c
decl_stmt|;
name|QRgb
name|color
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|color
operator|=
name|cols
operator|.
name|entryRgb
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|c
operator|.
name|pixel
operator|=
name|i
expr_stmt|;
name|c
operator|.
name|red
operator|=
call|(
name|ushort
call|)
argument_list|(
operator|(
name|qRed
argument_list|(
name|color
argument_list|)
operator|/
literal|255.0
operator|)
operator|*
literal|65535.0
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|c
operator|.
name|green
operator|=
call|(
name|ushort
call|)
argument_list|(
operator|(
name|qGreen
argument_list|(
name|color
argument_list|)
operator|/
literal|255.0
operator|)
operator|*
literal|65535.0
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|c
operator|.
name|blue
operator|=
call|(
name|ushort
call|)
argument_list|(
operator|(
name|qBlue
argument_list|(
name|color
argument_list|)
operator|/
literal|255.0
operator|)
operator|*
literal|65535.0
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|c
operator|.
name|flags
operator|=
name|DoRed
operator||
name|DoGreen
operator||
name|DoBlue
expr_stmt|;
name|XStoreColor
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|cmap
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*\internal   Check whether the given visual supports dynamic colormaps or not. */
end_comment
begin_function
DECL|function|qCanAllocColors
specifier|static
name|bool
name|qCanAllocColors
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
name|bool
name|validVisual
init|=
literal|false
decl_stmt|;
name|int
name|numVisuals
decl_stmt|;
name|long
name|mask
decl_stmt|;
name|XVisualInfo
name|templ
decl_stmt|;
name|XVisualInfo
modifier|*
name|visuals
decl_stmt|;
name|VisualID
name|id
init|=
name|XVisualIDFromVisual
argument_list|(
operator|(
name|Visual
operator|*
operator|)
name|w
operator|->
name|window
argument_list|()
operator|->
name|x11Info
argument_list|()
operator|.
name|visual
argument_list|()
argument_list|)
decl_stmt|;
name|mask
operator|=
name|VisualScreenMask
expr_stmt|;
name|templ
operator|.
name|screen
operator|=
name|w
operator|->
name|x11Info
argument_list|()
operator|.
name|screen
argument_list|()
expr_stmt|;
name|visuals
operator|=
name|XGetVisualInfo
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|mask
argument_list|,
operator|&
name|templ
argument_list|,
operator|&
name|numVisuals
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numVisuals
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|visuals
index|[
name|i
index|]
operator|.
name|visualid
operator|==
name|id
condition|)
block|{
switch|switch
condition|(
name|visuals
index|[
name|i
index|]
operator|.
name|c_class
condition|)
block|{
case|case
name|TrueColor
case|:
case|case
name|StaticColor
case|:
case|case
name|StaticGray
case|:
case|case
name|XGrayScale
case|:
name|validVisual
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|DirectColor
case|:
case|case
name|PseudoColor
case|:
name|validVisual
operator|=
literal|true
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
name|XFree
argument_list|(
name|visuals
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validVisual
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setColormap
name|void
name|QGLWidget
operator|::
name|setColormap
parameter_list|(
specifier|const
name|QGLColormap
modifier|&
name|c
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGLWidget
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|tlw
init|=
name|window
argument_list|()
decl_stmt|;
comment|// must return a valid widget
name|d
operator|->
name|cmap
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|cmap
operator|.
name|handle
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|qCanAllocColors
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLWidget::setColormap: Cannot create a read/write "
literal|"colormap for this visual"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// If the child GL widget is not of the same visual class as the
comment|// toplevel widget we will get in trouble..
name|Window
name|wid
init|=
name|tlw
operator|->
name|winId
argument_list|()
decl_stmt|;
name|Visual
modifier|*
name|vis
init|=
operator|(
name|Visual
operator|*
operator|)
name|tlw
operator|->
name|x11Info
argument_list|()
operator|.
name|visual
argument_list|()
decl_stmt|;
empty_stmt|;
name|VisualID
name|cvId
init|=
name|XVisualIDFromVisual
argument_list|(
operator|(
name|Visual
operator|*
operator|)
name|x11Info
argument_list|()
operator|.
name|visual
argument_list|()
argument_list|)
decl_stmt|;
name|VisualID
name|tvId
init|=
name|XVisualIDFromVisual
argument_list|(
operator|(
name|Visual
operator|*
operator|)
name|tlw
operator|->
name|x11Info
argument_list|()
operator|.
name|visual
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cvId
operator|!=
name|tvId
condition|)
block|{
name|wid
operator|=
name|winId
argument_list|()
expr_stmt|;
name|vis
operator|=
operator|(
name|Visual
operator|*
operator|)
name|x11Info
argument_list|()
operator|.
name|visual
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|cmap
operator|.
name|handle
argument_list|()
condition|)
comment|// allocate a cmap if necessary
name|d
operator|->
name|cmap
operator|.
name|setHandle
argument_list|(
name|XCreateColormap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|wid
argument_list|,
name|vis
argument_list|,
name|AllocAll
argument_list|)
argument_list|)
expr_stmt|;
name|qStoreColors
argument_list|(
name|this
argument_list|,
operator|(
name|Colormap
operator|)
name|d
operator|->
name|cmap
operator|.
name|handle
argument_list|()
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|XSetWindowColormap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|wid
argument_list|,
operator|(
name|Colormap
operator|)
name|d
operator|->
name|cmap
operator|.
name|handle
argument_list|()
argument_list|)
expr_stmt|;
comment|// tell the wm that this window has a special colormap
name|Window
modifier|*
name|cmw
decl_stmt|;
name|Window
modifier|*
name|cmwret
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|XGetWMColormapWindows
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|tlw
operator|->
name|winId
argument_list|()
argument_list|,
operator|&
name|cmwret
argument_list|,
operator|&
name|count
argument_list|)
condition|)
block|{
name|cmw
operator|=
operator|new
name|Window
index|[
name|count
operator|+
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmw
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cmwret
argument_list|,
sizeof|sizeof
argument_list|(
name|Window
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|XFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmwret
argument_list|)
expr_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmw
index|[
name|i
index|]
operator|==
name|winId
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|count
condition|)
comment|// append new window only if not in the list
name|cmw
index|[
name|count
operator|++
index|]
operator|=
name|winId
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|cmw
operator|=
operator|new
name|Window
index|[
name|count
index|]
expr_stmt|;
name|cmw
index|[
literal|0
index|]
operator|=
name|winId
argument_list|()
expr_stmt|;
block|}
name|XSetWMColormapWindows
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|tlw
operator|->
name|winId
argument_list|()
argument_list|,
name|cmw
argument_list|,
name|count
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|cmw
expr_stmt|;
block|}
end_function
begin_comment
comment|// Solaris defines glXBindTexImageEXT as part of the GL library
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|GLX_VERSION_1_3
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
end_if
begin_typedef
DECL|typedef|qt_glXBindTexImageEXT
typedef|typedef
name|void
function_decl|(
modifier|*
name|qt_glXBindTexImageEXT
function_decl|)
parameter_list|(
name|Display
modifier|*
parameter_list|,
name|GLXDrawable
parameter_list|,
name|int
parameter_list|,
specifier|const
name|int
modifier|*
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|qt_glXReleaseTexImageEXT
typedef|typedef
name|void
function_decl|(
modifier|*
name|qt_glXReleaseTexImageEXT
function_decl|)
parameter_list|(
name|Display
modifier|*
parameter_list|,
name|GLXDrawable
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef
begin_decl_stmt
DECL|variable|glXBindTexImageEXT
specifier|static
name|qt_glXBindTexImageEXT
name|glXBindTexImageEXT
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|glXReleaseTexImageEXT
specifier|static
name|qt_glXReleaseTexImageEXT
name|glXReleaseTexImageEXT
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_resolveTextureFromPixmap
specifier|static
name|bool
name|qt_resolveTextureFromPixmap
parameter_list|(
name|QPaintDevice
modifier|*
name|paintDevice
parameter_list|)
block|{
specifier|static
name|bool
name|resolvedTextureFromPixmap
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|resolvedTextureFromPixmap
condition|)
block|{
name|resolvedTextureFromPixmap
operator|=
literal|true
expr_stmt|;
comment|// Check to see if we have NPOT texture support
if|if
condition|(
operator|!
operator|(
name|QGLExtensions
operator|::
name|glExtensions
argument_list|()
operator|&
name|QGLExtensions
operator|::
name|NPOTTextures
operator|)
operator|&&
operator|!
operator|(
name|QGLFormat
operator|::
name|openGLVersionFlags
argument_list|()
operator|&
name|QGLFormat
operator|::
name|OpenGL_Version_2_0
operator|)
condition|)
block|{
return|return
literal|false
return|;
comment|// Can't use TFP without NPOT
block|}
specifier|const
name|QX11Info
modifier|*
name|xinfo
init|=
name|qt_x11Info
argument_list|(
name|paintDevice
argument_list|)
decl_stmt|;
name|Display
modifier|*
name|display
init|=
name|xinfo
condition|?
name|xinfo
operator|->
name|display
argument_list|()
else|:
name|X11
operator|->
name|display
decl_stmt|;
name|int
name|screen
init|=
name|xinfo
condition|?
name|xinfo
operator|->
name|screen
argument_list|()
else|:
name|X11
operator|->
name|defaultScreen
decl_stmt|;
name|QGLExtensionMatcher
name|serverExtensions
argument_list|(
name|glXQueryExtensionsString
argument_list|(
name|display
argument_list|,
name|screen
argument_list|)
argument_list|)
decl_stmt|;
name|QGLExtensionMatcher
name|clientExtensions
argument_list|(
name|glXGetClientString
argument_list|(
name|display
argument_list|,
name|GLX_EXTENSIONS
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverExtensions
operator|.
name|match
argument_list|(
literal|"GLX_EXT_texture_from_pixmap"
argument_list|)
operator|&&
name|clientExtensions
operator|.
name|match
argument_list|(
literal|"GLX_EXT_texture_from_pixmap"
argument_list|)
condition|)
block|{
name|glXBindTexImageEXT
operator|=
operator|(
name|qt_glXBindTexImageEXT
operator|)
name|qglx_getProcAddress
argument_list|(
literal|"glXBindTexImageEXT"
argument_list|)
expr_stmt|;
name|glXReleaseTexImageEXT
operator|=
operator|(
name|qt_glXReleaseTexImageEXT
operator|)
name|qglx_getProcAddress
argument_list|(
literal|"glXReleaseTexImageEXT"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|glXBindTexImageEXT
operator|&&
name|glXReleaseTexImageEXT
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//defined(GLX_VERSION_1_3)&& !defined(Q_OS_HPUX)
end_comment
begin_function
DECL|function|bindTextureFromNativePixmap
name|QGLTexture
modifier|*
name|QGLContextPrivate
operator|::
name|bindTextureFromNativePixmap
parameter_list|(
name|QPixmap
modifier|*
name|pixmap
parameter_list|,
specifier|const
name|qint64
name|key
parameter_list|,
name|QGLContext
operator|::
name|BindOptions
name|options
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|GLX_VERSION_1_3
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
return|return
literal|0
return|;
else|#
directive|else
comment|// Check we have GLX 1.3, as it is needed for glXCreatePixmap& glXDestroyPixmap
name|int
name|majorVersion
init|=
literal|0
decl_stmt|;
name|int
name|minorVersion
init|=
literal|0
decl_stmt|;
name|glXQueryVersion
argument_list|(
name|X11
operator|->
name|display
argument_list|,
operator|&
name|majorVersion
argument_list|,
operator|&
name|minorVersion
argument_list|)
expr_stmt|;
if|if
condition|(
name|majorVersion
operator|<
literal|1
operator|||
operator|(
name|majorVersion
operator|==
literal|1
operator|&&
name|minorVersion
operator|<
literal|3
operator|)
condition|)
return|return
literal|0
return|;
name|Q_Q
argument_list|(
name|QGLContext
argument_list|)
expr_stmt|;
name|QX11PixmapData
modifier|*
name|pixmapData
init|=
cast|static_cast
argument_list|<
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|pixmap
operator|->
name|data_ptr
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|pixmapData
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|X11Class
argument_list|)
expr_stmt|;
comment|// We can't use TFP if the pixmap has a separate X11 mask
if|if
condition|(
name|pixmapData
operator|->
name|x11_mask
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|qt_resolveTextureFromPixmap
argument_list|(
name|paintDevice
argument_list|)
condition|)
return|return
literal|0
return|;
specifier|const
name|QX11Info
modifier|&
name|x11Info
init|=
name|pixmapData
operator|->
name|xinfo
decl_stmt|;
comment|// Store the configs (Can be static because configs aren't dependent on current context)
specifier|static
name|GLXFBConfig
name|glxRGBPixmapConfig
init|=
literal|0
decl_stmt|;
specifier|static
name|bool
name|RGBConfigInverted
init|=
literal|false
decl_stmt|;
specifier|static
name|GLXFBConfig
name|glxRGBAPixmapConfig
init|=
literal|0
decl_stmt|;
specifier|static
name|bool
name|RGBAConfigInverted
init|=
literal|false
decl_stmt|;
name|bool
name|hasAlpha
init|=
name|pixmapData
operator|->
name|hasAlphaChannel
argument_list|()
decl_stmt|;
comment|// Check to see if we need a config
if|if
condition|(
operator|(
name|hasAlpha
operator|&&
operator|!
name|glxRGBAPixmapConfig
operator|)
operator|||
operator|(
operator|!
name|hasAlpha
operator|&&
operator|!
name|glxRGBPixmapConfig
operator|)
condition|)
block|{
name|GLXFBConfig
modifier|*
name|configList
init|=
literal|0
decl_stmt|;
name|int
name|configCount
init|=
literal|0
decl_stmt|;
name|int
name|configAttribs
index|[]
init|=
block|{
name|hasAlpha
operator|?
name|GLX_BIND_TO_TEXTURE_RGBA_EXT
operator|:
name|GLX_BIND_TO_TEXTURE_RGB_EXT
block|,
name|True
block|,
name|GLX_DRAWABLE_TYPE
block|,
name|GLX_PIXMAP_BIT
block|,
name|GLX_BIND_TO_TEXTURE_TARGETS_EXT
block|,
name|GLX_TEXTURE_2D_BIT_EXT
block|,
comment|// QGLContext::bindTexture() can't return an inverted texture, but QPainter::drawPixmap() can:
name|GLX_Y_INVERTED_EXT
block|,
name|options
operator|&
name|QGLContext
operator|::
name|CanFlipNativePixmapBindOption
operator|?
name|GLX_DONT_CARE
operator|:
name|False
block|,
name|XNone
block|}
decl_stmt|;
name|configList
operator|=
name|glXChooseFBConfig
argument_list|(
name|x11Info
operator|.
name|display
argument_list|()
argument_list|,
name|x11Info
operator|.
name|screen
argument_list|()
argument_list|,
name|configAttribs
argument_list|,
operator|&
name|configCount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|configList
condition|)
return|return
literal|0
return|;
name|int
name|yInv
decl_stmt|;
name|glXGetFBConfigAttrib
argument_list|(
name|x11Info
operator|.
name|display
argument_list|()
argument_list|,
name|configList
index|[
literal|0
index|]
argument_list|,
name|GLX_Y_INVERTED_EXT
argument_list|,
operator|&
name|yInv
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasAlpha
condition|)
block|{
name|glxRGBAPixmapConfig
operator|=
name|configList
index|[
literal|0
index|]
expr_stmt|;
name|RGBAConfigInverted
operator|=
name|yInv
expr_stmt|;
block|}
else|else
block|{
name|glxRGBPixmapConfig
operator|=
name|configList
index|[
literal|0
index|]
expr_stmt|;
name|RGBConfigInverted
operator|=
name|yInv
expr_stmt|;
block|}
name|XFree
argument_list|(
name|configList
argument_list|)
expr_stmt|;
block|}
comment|// Check to see if the surface is still valid
if|if
condition|(
name|pixmapData
operator|->
name|gl_surface
operator|&&
name|hasAlpha
operator|!=
operator|(
name|pixmapData
operator|->
name|flags
operator|&
name|QX11PixmapData
operator|::
name|GlSurfaceCreatedWithAlpha
operator|)
condition|)
block|{
comment|// Surface is invalid!
name|destroyGlSurfaceForPixmap
argument_list|(
name|pixmapData
argument_list|)
expr_stmt|;
block|}
comment|// Check to see if we need a surface
if|if
condition|(
operator|!
name|pixmapData
operator|->
name|gl_surface
condition|)
block|{
name|GLXPixmap
name|glxPixmap
decl_stmt|;
name|int
name|pixmapAttribs
index|[]
init|=
block|{
name|GLX_TEXTURE_FORMAT_EXT
block|,
name|hasAlpha
operator|?
name|GLX_TEXTURE_FORMAT_RGBA_EXT
operator|:
name|GLX_TEXTURE_FORMAT_RGB_EXT
block|,
name|GLX_TEXTURE_TARGET_EXT
block|,
name|GLX_TEXTURE_2D_EXT
block|,
name|GLX_MIPMAP_TEXTURE_EXT
block|,
name|False
block|,
comment|// Maybe needs to be don't care
name|XNone
block|}
decl_stmt|;
comment|// Wrap the X Pixmap into a GLXPixmap:
name|glxPixmap
operator|=
name|glXCreatePixmap
argument_list|(
name|x11Info
operator|.
name|display
argument_list|()
argument_list|,
name|hasAlpha
condition|?
name|glxRGBAPixmapConfig
else|:
name|glxRGBPixmapConfig
argument_list|,
name|pixmapData
operator|->
name|handle
argument_list|()
argument_list|,
name|pixmapAttribs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glxPixmap
condition|)
return|return
literal|0
return|;
name|pixmapData
operator|->
name|gl_surface
operator|=
operator|(
name|void
operator|*
operator|)
name|glxPixmap
expr_stmt|;
comment|// Make sure the cleanup hook gets called so we can delete the glx pixmap
name|QImagePixmapCleanupHooks
operator|::
name|enableCleanupHooks
argument_list|(
name|pixmapData
argument_list|)
expr_stmt|;
block|}
name|GLuint
name|textureId
decl_stmt|;
name|glGenTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|textureId
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|textureId
argument_list|)
expr_stmt|;
name|glXBindTexImageEXT
argument_list|(
name|x11Info
operator|.
name|display
argument_list|()
argument_list|,
operator|(
name|GLXPixmap
operator|)
name|pixmapData
operator|->
name|gl_surface
argument_list|,
name|GLX_FRONT_LEFT_EXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|textureId
argument_list|)
expr_stmt|;
name|GLuint
name|filtering
init|=
operator|(
name|options
operator|&
name|QGLContext
operator|::
name|LinearFilteringBindOption
operator|)
condition|?
name|GL_LINEAR
else|:
name|GL_NEAREST
decl_stmt|;
name|glTexParameterf
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|filtering
argument_list|)
expr_stmt|;
name|glTexParameterf
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|filtering
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|hasAlpha
operator|&&
name|RGBAConfigInverted
operator|)
operator|||
operator|(
operator|!
name|hasAlpha
operator|&&
name|RGBConfigInverted
operator|)
operator|)
condition|)
name|options
operator|&=
operator|~
name|QGLContext
operator|::
name|InvertedYBindOption
expr_stmt|;
name|QGLTexture
modifier|*
name|texture
init|=
operator|new
name|QGLTexture
argument_list|(
name|q
argument_list|,
name|textureId
argument_list|,
name|GL_TEXTURE_2D
argument_list|,
name|options
argument_list|)
decl_stmt|;
if|if
condition|(
name|texture
operator|->
name|options
operator|&
name|QGLContext
operator|::
name|InvertedYBindOption
condition|)
name|pixmapData
operator|->
name|flags
operator||=
name|QX11PixmapData
operator|::
name|InvertedWhenBoundToTexture
expr_stmt|;
comment|// We assume the cost of bound pixmaps is zero
name|QGLTextureCache
operator|::
name|instance
argument_list|()
operator|->
name|insert
argument_list|(
name|q
argument_list|,
name|key
argument_list|,
name|texture
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|texture
return|;
endif|#
directive|endif
comment|//!defined(GLX_VERSION_1_3) || defined(Q_OS_HPUX)
block|}
end_function
begin_function
DECL|function|destroyGlSurfaceForPixmap
name|void
name|QGLContextPrivate
operator|::
name|destroyGlSurfaceForPixmap
parameter_list|(
name|QPixmapData
modifier|*
name|pmd
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|GLX_VERSION_1_3
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
name|Q_ASSERT
argument_list|(
name|pmd
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|X11Class
argument_list|)
expr_stmt|;
name|QX11PixmapData
modifier|*
name|pixmapData
init|=
cast|static_cast
argument_list|<
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|pmd
argument_list|)
decl_stmt|;
if|if
condition|(
name|pixmapData
operator|->
name|gl_surface
condition|)
block|{
name|glXDestroyPixmap
argument_list|(
name|QX11Info
operator|::
name|display
argument_list|()
argument_list|,
operator|(
name|GLXPixmap
operator|)
name|pixmapData
operator|->
name|gl_surface
argument_list|)
expr_stmt|;
name|pixmapData
operator|->
name|gl_surface
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|unbindPixmapFromTexture
name|void
name|QGLContextPrivate
operator|::
name|unbindPixmapFromTexture
parameter_list|(
name|QPixmapData
modifier|*
name|pmd
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|GLX_VERSION_1_3
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
name|Q_ASSERT
argument_list|(
name|pmd
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|X11Class
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
expr_stmt|;
name|QX11PixmapData
modifier|*
name|pixmapData
init|=
cast|static_cast
argument_list|<
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|pmd
argument_list|)
decl_stmt|;
if|if
condition|(
name|pixmapData
operator|->
name|gl_surface
condition|)
name|glXReleaseTexImageEXT
argument_list|(
name|QX11Info
operator|::
name|display
argument_list|()
argument_list|,
operator|(
name|GLXPixmap
operator|)
name|pixmapData
operator|->
name|gl_surface
argument_list|,
name|GLX_FRONT_LEFT_EXT
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
