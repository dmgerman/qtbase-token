begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtOpenGL module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qglframebufferobject.h"
end_include
begin_include
include|#
directive|include
file|"qglframebufferobject_p.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<private/qgl_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfont_p.h>
end_include
begin_include
include|#
directive|include
file|"gl2paintengineex/qpaintengineex_opengl2_p.h"
end_include
begin_include
include|#
directive|include
file|<qlibrary.h>
end_include
begin_include
include|#
directive|include
file|<qimage.h>
end_include
begin_include
include|#
directive|include
file|<qwindow.h>
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
specifier|extern
name|QImage
name|qt_gl_read_framebuffer
parameter_list|(
specifier|const
name|QSize
modifier|&
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|QGL_FUNC_CONTEXT
define|#
directive|define
name|QGL_FUNC_CONTEXT
value|const QGLContext *ctx = QGLContext::currentContext();
end_define
begin_define
DECL|macro|QGL_FUNCP_CONTEXT
define|#
directive|define
name|QGL_FUNCP_CONTEXT
value|const QGLContext *ctx = QGLContext::currentContext();
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
end_ifndef
begin_define
DECL|macro|QT_RESET_GLERROR
define|#
directive|define
name|QT_RESET_GLERROR
parameter_list|()
define|\
value|{                                                         \     while (glGetError() != GL_NO_ERROR) {}                \ }
end_define
begin_define
DECL|macro|QT_CHECK_GLERROR
define|#
directive|define
name|QT_CHECK_GLERROR
parameter_list|()
define|\
value|{                                                         \     GLenum err = glGetError();                            \     if (err != GL_NO_ERROR) {                             \         qDebug("[%s line %d] GL Error: %d",               \                __FILE__, __LINE__, (int)err);             \     }                                                     \ }
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_RESET_GLERROR
define|#
directive|define
name|QT_RESET_GLERROR
parameter_list|()
value|{}
end_define
begin_define
DECL|macro|QT_CHECK_GLERROR
define|#
directive|define
name|QT_CHECK_GLERROR
parameter_list|()
value|{}
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// ####TODO Properly #ifdef this class to use #define symbols actually defined
end_comment
begin_comment
comment|// by OpenGL/ES includes
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|GL_MAX_SAMPLES
end_ifndef
begin_define
DECL|macro|GL_MAX_SAMPLES
define|#
directive|define
name|GL_MAX_SAMPLES
value|0x8D57
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GL_RENDERBUFFER_SAMPLES
end_ifndef
begin_define
DECL|macro|GL_RENDERBUFFER_SAMPLES
define|#
directive|define
name|GL_RENDERBUFFER_SAMPLES
value|0x8CAB
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GL_DEPTH24_STENCIL8
end_ifndef
begin_define
DECL|macro|GL_DEPTH24_STENCIL8
define|#
directive|define
name|GL_DEPTH24_STENCIL8
value|0x88F0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GL_DEPTH_COMPONENT24
end_ifndef
begin_define
DECL|macro|GL_DEPTH_COMPONENT24
define|#
directive|define
name|GL_DEPTH_COMPONENT24
value|0x81A6
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GL_READ_FRAMEBUFFER
end_ifndef
begin_define
DECL|macro|GL_READ_FRAMEBUFFER
define|#
directive|define
name|GL_READ_FRAMEBUFFER
value|0x8CA8
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GL_DRAW_FRAMEBUFFER
end_ifndef
begin_define
DECL|macro|GL_DRAW_FRAMEBUFFER
define|#
directive|define
name|GL_DRAW_FRAMEBUFFER
value|0x8CA9
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \class QGLFramebufferObjectFormat     \brief The QGLFramebufferObjectFormat class specifies the format of an OpenGL     framebuffer object.      \since 4.6     \obsolete      \ingroup painting-3D      A framebuffer object has several characteristics:     \list     \li \l{setSamples()}{Number of samples per pixels.}     \li \l{setAttachment()}{Depth and/or stencil attachments.}     \li \l{setTextureTarget()}{Texture target.}     \li \l{setInternalTextureFormat()}{Internal texture format.}     \endlist      Note that the desired attachments or number of samples per pixels might not     be supported by the hardware driver. Call QGLFramebufferObject::format()     after creating a QGLFramebufferObject to find the exact format that was     used to create the frame buffer object.      \note This class has been deprecated in favor of QOpenGLFramebufferObject.      \sa QGLFramebufferObject */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|detach
name|void
name|QGLFramebufferObjectFormat
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|QGLFramebufferObjectFormatPrivate
modifier|*
name|newd
init|=
operator|new
name|QGLFramebufferObjectFormatPrivate
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|newd
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Creates a QGLFramebufferObjectFormat object for specifying     the format of an OpenGL framebuffer object.      By default the format specifies a non-multisample framebuffer object with no     attachments, texture target \c GL_TEXTURE_2D, and internal format \c GL_RGBA8.     On OpenGL/ES systems, the default internal format is \c GL_RGBA.      \sa samples(), attachment(), internalTextureFormat() */
end_comment
begin_constructor
DECL|function|QGLFramebufferObjectFormat
name|QGLFramebufferObjectFormat
operator|::
name|QGLFramebufferObjectFormat
parameter_list|()
block|{
name|d
operator|=
operator|new
name|QGLFramebufferObjectFormatPrivate
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a other. */
end_comment
begin_constructor
DECL|function|QGLFramebufferObjectFormat
name|QGLFramebufferObjectFormat
operator|::
name|QGLFramebufferObjectFormat
parameter_list|(
specifier|const
name|QGLFramebufferObjectFormat
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns \a other to this object. */
end_comment
begin_function
DECL|function|operator =
name|QGLFramebufferObjectFormat
modifier|&
name|QGLFramebufferObjectFormat
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QGLFramebufferObjectFormat
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|d
operator|!=
name|other
operator|.
name|d
condition|)
block|{
name|other
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the QGLFramebufferObjectFormat. */
end_comment
begin_destructor
DECL|function|~QGLFramebufferObjectFormat
name|QGLFramebufferObjectFormat
operator|::
name|~
name|QGLFramebufferObjectFormat
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Sets the number of samples per pixel for a multisample framebuffer object     to \a samples.  The default sample count of 0 represents a regular     non-multisample framebuffer object.      If the desired amount of samples per pixel is not supported by the hardware     then the maximum number of samples per pixel will be used. Note that     multisample framebuffer objects can not be bound as textures. Also, the     \c{GL_EXT_framebuffer_multisample} extension is required to create a     framebuffer with more than one sample per pixel.      \sa samples() */
end_comment
begin_function
DECL|function|setSamples
name|void
name|QGLFramebufferObjectFormat
operator|::
name|setSamples
parameter_list|(
name|int
name|samples
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|samples
operator|=
name|samples
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of samples per pixel if a framebuffer object     is a multisample framebuffer object. Otherwise, returns 0.     The default value is 0.      \sa setSamples() */
end_comment
begin_function
DECL|function|samples
name|int
name|QGLFramebufferObjectFormat
operator|::
name|samples
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|samples
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Enables mipmapping if \a enabled is true; otherwise disables it.      Mipmapping is disabled by default.      If mipmapping is enabled, additional memory will be allocated for     the mipmap levels. The mipmap levels can be updated by binding the     texture and calling glGenerateMipmap(). Mipmapping cannot be enabled     for multisampled framebuffer objects.      \sa mipmap(), QGLFramebufferObject::texture() */
end_comment
begin_function
DECL|function|setMipmap
name|void
name|QGLFramebufferObjectFormat
operator|::
name|setMipmap
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|mipmap
operator|=
name|enabled
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns true if mipmapping is enabled.      \sa setMipmap() */
end_comment
begin_function
DECL|function|mipmap
name|bool
name|QGLFramebufferObjectFormat
operator|::
name|mipmap
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|mipmap
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the attachment configuration of a framebuffer object to \a attachment.      \sa attachment() */
end_comment
begin_function
DECL|function|setAttachment
name|void
name|QGLFramebufferObjectFormat
operator|::
name|setAttachment
parameter_list|(
name|QGLFramebufferObject
operator|::
name|Attachment
name|attachment
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|attachment
operator|=
name|attachment
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the configuration of the depth and stencil buffers attached to     a framebuffer object.  The default is QGLFramebufferObject::NoAttachment.      \sa setAttachment() */
end_comment
begin_function
DECL|function|attachment
name|QGLFramebufferObject
operator|::
name|Attachment
name|QGLFramebufferObjectFormat
operator|::
name|attachment
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|attachment
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the texture target of the texture attached to a framebuffer object to     \a target. Ignored for multisample framebuffer objects.      \sa textureTarget(), samples() */
end_comment
begin_function
DECL|function|setTextureTarget
name|void
name|QGLFramebufferObjectFormat
operator|::
name|setTextureTarget
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|target
operator|=
name|target
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the texture target of the texture attached to a framebuffer object.     Ignored for multisample framebuffer objects.  The default is     \c GL_TEXTURE_2D.      \sa setTextureTarget(), samples() */
end_comment
begin_function
DECL|function|textureTarget
name|GLenum
name|QGLFramebufferObjectFormat
operator|::
name|textureTarget
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|target
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the internal format of a framebuffer object's texture or     multisample framebuffer object's color buffer to     \a internalTextureFormat.      \sa internalTextureFormat() */
end_comment
begin_function
DECL|function|setInternalTextureFormat
name|void
name|QGLFramebufferObjectFormat
operator|::
name|setInternalTextureFormat
parameter_list|(
name|GLenum
name|internalTextureFormat
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|internal_format
operator|=
name|internalTextureFormat
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the internal format of a framebuffer object's texture or     multisample framebuffer object's color buffer.  The default is     \c GL_RGBA8 on desktop OpenGL systems, and \c GL_RGBA on     OpenGL/ES systems.      \sa setInternalTextureFormat() */
end_comment
begin_function
DECL|function|internalTextureFormat
name|GLenum
name|QGLFramebufferObjectFormat
operator|::
name|internalTextureFormat
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|internal_format
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if all the options of this framebuffer object format     are the same as \a other; otherwise returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QGLFramebufferObjectFormat
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QGLFramebufferObjectFormat
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|==
name|other
operator|.
name|d
condition|)
return|return
literal|true
return|;
else|else
return|return
name|d
operator|->
name|equals
argument_list|(
name|other
operator|.
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns false if all the options of this framebuffer object format     are the same as \a other; otherwise returns true. */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QGLFramebufferObjectFormat
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QGLFramebufferObjectFormat
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|other
operator|)
return|;
block|}
end_function
begin_function
DECL|function|setFBO
name|void
name|QGLFBOGLPaintDevice
operator|::
name|setFBO
parameter_list|(
name|QGLFramebufferObject
modifier|*
name|f
parameter_list|,
name|QGLFramebufferObject
operator|::
name|Attachment
name|attachment
parameter_list|)
block|{
name|fbo
operator|=
name|f
expr_stmt|;
name|m_thisFBO
operator|=
name|fbo
operator|->
name|d_func
argument_list|()
operator|->
name|fbo
argument_list|()
expr_stmt|;
comment|// This shouldn't be needed
comment|// The context that the fbo was created in may not have depth
comment|// and stencil buffers, but the fbo itself might.
name|fboFormat
operator|=
name|QGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|format
argument_list|()
expr_stmt|;
if|if
condition|(
name|attachment
operator|==
name|QGLFramebufferObject
operator|::
name|CombinedDepthStencil
condition|)
block|{
name|fboFormat
operator|.
name|setDepth
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|fboFormat
operator|.
name|setStencil
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attachment
operator|==
name|QGLFramebufferObject
operator|::
name|Depth
condition|)
block|{
name|fboFormat
operator|.
name|setDepth
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|fboFormat
operator|.
name|setStencil
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fboFormat
operator|.
name|setDepth
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|fboFormat
operator|.
name|setStencil
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|GLenum
name|format
init|=
name|f
operator|->
name|format
argument_list|()
operator|.
name|internalTextureFormat
argument_list|()
decl_stmt|;
name|reqAlpha
operator|=
operator|(
name|format
operator|!=
name|GL_RGB
ifndef|#
directive|ifndef
name|QT_OPENGL_ES
operator|&&
name|format
operator|!=
name|GL_RGB5
operator|&&
name|format
operator|!=
name|GL_RGB8
endif|#
directive|endif
operator|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|context
name|QGLContext
modifier|*
name|QGLFBOGLPaintDevice
operator|::
name|context
parameter_list|()
specifier|const
block|{
return|return
cast|const_cast
argument_list|<
name|QGLContext
operator|*
argument_list|>
argument_list|(
name|QGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|checkFramebufferStatus
name|bool
name|QGLFramebufferObjectPrivate
operator|::
name|checkFramebufferStatus
parameter_list|()
specifier|const
block|{
name|QGL_FUNCP_CONTEXT
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return
literal|false
return|;
comment|// Context no longer exists.
name|GLenum
name|status
init|=
name|glCheckFramebufferStatus
argument_list|(
name|GL_FRAMEBUFFER
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|GL_NO_ERROR
case|:
case|case
name|GL_FRAMEBUFFER_COMPLETE
case|:
return|return
literal|true
return|;
break|break;
case|case
name|GL_FRAMEBUFFER_UNSUPPORTED
case|:
name|qDebug
argument_list|(
literal|"QGLFramebufferObject: Unsupported framebuffer format."
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
case|:
name|qDebug
argument_list|(
literal|"QGLFramebufferObject: Framebuffer incomplete attachment."
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
case|:
name|qDebug
argument_list|(
literal|"QGLFramebufferObject: Framebuffer incomplete, missing attachment."
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT
case|:
name|qDebug
argument_list|(
literal|"QGLFramebufferObject: Framebuffer incomplete, duplicate attachment."
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS
case|:
name|qDebug
argument_list|(
literal|"QGLFramebufferObject: Framebuffer incomplete, attached images must have same dimensions."
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GL_FRAMEBUFFER_INCOMPLETE_FORMATS
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_FORMATS
case|:
name|qDebug
argument_list|(
literal|"QGLFramebufferObject: Framebuffer incomplete, attached images must have same format."
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER
case|:
name|qDebug
argument_list|(
literal|"QGLFramebufferObject: Framebuffer incomplete, missing draw buffer."
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER
case|:
name|qDebug
argument_list|(
literal|"QGLFramebufferObject: Framebuffer incomplete, missing read buffer."
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE
case|case
name|GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE
case|:
name|qDebug
argument_list|(
literal|"QGLFramebufferObject: Framebuffer incomplete, attachments must have same number of samples per pixel."
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|qDebug
argument_list|()
operator|<<
literal|"QGLFramebufferObject: An undefined error has occurred: "
operator|<<
name|status
expr_stmt|;
break|break;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|function|freeFramebufferFunc
name|void
name|freeFramebufferFunc
parameter_list|(
name|QGLContext
modifier|*
name|ctx
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|glDeleteFramebuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
block|}
DECL|function|freeRenderbufferFunc
name|void
name|freeRenderbufferFunc
parameter_list|(
name|QGLContext
modifier|*
name|ctx
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
block|}
DECL|function|freeTextureFunc
name|void
name|freeTextureFunc
parameter_list|(
name|QGLContext
modifier|*
name|ctx
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|glDeleteTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_namespace
begin_function
DECL|function|init
name|void
name|QGLFramebufferObjectPrivate
operator|::
name|init
parameter_list|(
name|QGLFramebufferObject
modifier|*
name|q
parameter_list|,
specifier|const
name|QSize
modifier|&
name|sz
parameter_list|,
name|QGLFramebufferObject
operator|::
name|Attachment
name|attachment
parameter_list|,
name|GLenum
name|texture_target
parameter_list|,
name|GLenum
name|internal_format
parameter_list|,
name|GLint
name|samples
parameter_list|,
name|bool
name|mipmap
parameter_list|)
block|{
name|QGLContext
modifier|*
name|ctx
init|=
cast|const_cast
argument_list|<
name|QGLContext
operator|*
argument_list|>
argument_list|(
name|QGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|ext_detected
init|=
operator|(
name|QGLExtensions
operator|::
name|glExtensions
argument_list|()
operator|&
name|QGLExtensions
operator|::
name|FramebufferObject
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|ext_detected
operator|||
operator|(
name|ext_detected
operator|&&
operator|!
name|qt_resolve_framebufferobject_extensions
argument_list|(
name|ctx
argument_list|)
operator|)
condition|)
return|return;
name|size
operator|=
name|sz
expr_stmt|;
name|target
operator|=
name|texture_target
expr_stmt|;
comment|// texture dimensions
name|QT_RESET_GLERROR
argument_list|()
expr_stmt|;
comment|// reset error state
name|GLuint
name|fbo
init|=
literal|0
decl_stmt|;
name|glGenFramebuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|fbo
argument_list|)
expr_stmt|;
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|fbo
argument_list|)
expr_stmt|;
name|GLuint
name|texture
init|=
literal|0
decl_stmt|;
name|GLuint
name|color_buffer
init|=
literal|0
decl_stmt|;
name|GLuint
name|depth_buffer
init|=
literal|0
decl_stmt|;
name|GLuint
name|stencil_buffer
init|=
literal|0
decl_stmt|;
name|QT_CHECK_GLERROR
argument_list|()
expr_stmt|;
comment|// init texture
if|if
condition|(
name|samples
operator|==
literal|0
condition|)
block|{
name|glGenTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|texture
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|target
argument_list|,
name|texture
argument_list|)
expr_stmt|;
name|glTexImage2D
argument_list|(
name|target
argument_list|,
literal|0
argument_list|,
name|internal_format
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mipmap
condition|)
block|{
name|int
name|width
init|=
name|size
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|size
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|level
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|width
operator|>
literal|1
operator|||
name|height
operator|>
literal|1
condition|)
block|{
name|width
operator|=
name|qMax
argument_list|(
literal|1
argument_list|,
name|width
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|height
operator|=
name|qMax
argument_list|(
literal|1
argument_list|,
name|height
operator|>>
literal|1
argument_list|)
expr_stmt|;
operator|++
name|level
expr_stmt|;
name|glTexImage2D
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|internal_format
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_WRAP_S
argument_list|,
name|GL_CLAMP_TO_EDGE
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_WRAP_T
argument_list|,
name|GL_CLAMP_TO_EDGE
argument_list|)
expr_stmt|;
name|glFramebufferTexture2D
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_COLOR_ATTACHMENT0
argument_list|,
name|target
argument_list|,
name|texture
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QT_CHECK_GLERROR
argument_list|()
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|()
expr_stmt|;
name|glBindTexture
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|color_buffer
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mipmap
operator|=
literal|false
expr_stmt|;
name|GLint
name|maxSamples
decl_stmt|;
name|glGetIntegerv
argument_list|(
name|GL_MAX_SAMPLES
argument_list|,
operator|&
name|maxSamples
argument_list|)
expr_stmt|;
name|samples
operator|=
name|qBound
argument_list|(
literal|0
argument_list|,
name|int
argument_list|(
name|samples
argument_list|)
argument_list|,
name|int
argument_list|(
name|maxSamples
argument_list|)
argument_list|)
expr_stmt|;
name|glGenRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|color_buffer
argument_list|)
expr_stmt|;
name|glBindRenderbuffer
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|color_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|glRenderbufferStorageMultisampleEXT
operator|&&
name|samples
operator|>
literal|0
condition|)
block|{
name|glRenderbufferStorageMultisampleEXT
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|internal_format
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|samples
operator|=
literal|0
expr_stmt|;
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|internal_format
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_COLOR_ATTACHMENT0
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|color_buffer
argument_list|)
expr_stmt|;
name|QT_CHECK_GLERROR
argument_list|()
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|()
expr_stmt|;
if|if
condition|(
name|valid
condition|)
name|glGetRenderbufferParameteriv
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_RENDERBUFFER_SAMPLES
argument_list|,
operator|&
name|samples
argument_list|)
expr_stmt|;
block|}
comment|// In practice, a combined depth-stencil buffer is supported by all desktop platforms, while a
comment|// separate stencil buffer is not. On embedded devices however, a combined depth-stencil buffer
comment|// might not be supported while separate buffers are, according to QTBUG-12861.
if|if
condition|(
name|attachment
operator|==
name|QGLFramebufferObject
operator|::
name|CombinedDepthStencil
operator|&&
operator|(
name|QGLExtensions
operator|::
name|glExtensions
argument_list|()
operator|&
name|QGLExtensions
operator|::
name|PackedDepthStencil
operator|)
condition|)
block|{
comment|// depth and stencil buffer needs another extension
name|glGenRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|glIsRenderbuffer
argument_list|(
name|depth_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|glBindRenderbuffer
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|depth_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|glIsRenderbuffer
argument_list|(
name|depth_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|!=
literal|0
operator|&&
name|glRenderbufferStorageMultisampleEXT
condition|)
name|glRenderbufferStorageMultisampleEXT
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_DEPTH24_STENCIL8
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_DEPTH24_STENCIL8
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|stencil_buffer
operator|=
name|depth_buffer
expr_stmt|;
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_DEPTH_ATTACHMENT
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|depth_buffer
argument_list|)
expr_stmt|;
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_STENCIL_ATTACHMENT
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|stencil_buffer
argument_list|)
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
name|stencil_buffer
operator|=
name|depth_buffer
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|depth_buffer
operator|==
literal|0
operator|&&
operator|(
name|attachment
operator|==
name|QGLFramebufferObject
operator|::
name|CombinedDepthStencil
operator|||
operator|(
name|attachment
operator|==
name|QGLFramebufferObject
operator|::
name|Depth
operator|)
operator|)
condition|)
block|{
name|glGenRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|glIsRenderbuffer
argument_list|(
name|depth_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|glBindRenderbuffer
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|depth_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|glIsRenderbuffer
argument_list|(
name|depth_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|!=
literal|0
operator|&&
name|glRenderbufferStorageMultisampleEXT
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
if|if
condition|(
name|QGLExtensions
operator|::
name|glExtensions
argument_list|()
operator|&
name|QGLExtensions
operator|::
name|Depth24
condition|)
block|{
name|glRenderbufferStorageMultisampleEXT
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_DEPTH_COMPONENT24_OES
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glRenderbufferStorageMultisampleEXT
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_DEPTH_COMPONENT16
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|glRenderbufferStorageMultisampleEXT
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_DEPTH_COMPONENT
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
if|if
condition|(
name|QGLExtensions
operator|::
name|glExtensions
argument_list|()
operator|&
name|QGLExtensions
operator|::
name|Depth24
condition|)
block|{
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_DEPTH_COMPONENT24_OES
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_DEPTH_COMPONENT16
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_DEPTH_COMPONENT
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_DEPTH_ATTACHMENT
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|depth_buffer
argument_list|)
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
name|depth_buffer
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stencil_buffer
operator|==
literal|0
operator|&&
operator|(
name|attachment
operator|==
name|QGLFramebufferObject
operator|::
name|CombinedDepthStencil
operator|)
condition|)
block|{
name|glGenRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|stencil_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|glIsRenderbuffer
argument_list|(
name|stencil_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|glBindRenderbuffer
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|stencil_buffer
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|glIsRenderbuffer
argument_list|(
name|stencil_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|!=
literal|0
operator|&&
name|glRenderbufferStorageMultisampleEXT
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
name|glRenderbufferStorageMultisampleEXT
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_STENCIL_INDEX8
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|glRenderbufferStorageMultisampleEXT
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|samples
argument_list|,
name|GL_STENCIL_INDEX
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_ES
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_STENCIL_INDEX8
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|glRenderbufferStorage
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|GL_STENCIL_INDEX
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|glFramebufferRenderbuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|GL_STENCIL_ATTACHMENT
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|stencil_buffer
argument_list|)
expr_stmt|;
name|valid
operator|=
name|checkFramebufferStatus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|stencil_buffer
argument_list|)
expr_stmt|;
name|stencil_buffer
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// The FBO might have become valid after removing the depth or stencil buffer.
name|valid
operator|=
name|checkFramebufferStatus
argument_list|()
expr_stmt|;
if|if
condition|(
name|depth_buffer
operator|&&
name|stencil_buffer
condition|)
block|{
name|fbo_attachment
operator|=
name|QGLFramebufferObject
operator|::
name|CombinedDepthStencil
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|depth_buffer
condition|)
block|{
name|fbo_attachment
operator|=
name|QGLFramebufferObject
operator|::
name|Depth
expr_stmt|;
block|}
else|else
block|{
name|fbo_attachment
operator|=
name|QGLFramebufferObject
operator|::
name|NoAttachment
expr_stmt|;
block|}
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|ctx
operator|->
name|d_ptr
operator|->
name|current_fbo
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
condition|)
block|{
name|fbo_guard
operator|=
name|createSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|fbo
argument_list|,
name|freeFramebufferFunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|color_buffer
condition|)
name|color_buffer_guard
operator|=
name|createSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|color_buffer
argument_list|,
name|freeRenderbufferFunc
argument_list|)
expr_stmt|;
else|else
name|texture_guard
operator|=
name|createSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|texture
argument_list|,
name|freeTextureFunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth_buffer
condition|)
name|depth_buffer_guard
operator|=
name|createSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|depth_buffer
argument_list|,
name|freeRenderbufferFunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stencil_buffer
condition|)
block|{
if|if
condition|(
name|stencil_buffer
operator|==
name|depth_buffer
condition|)
name|stencil_buffer_guard
operator|=
name|depth_buffer_guard
expr_stmt|;
else|else
name|stencil_buffer_guard
operator|=
name|createSharedResourceGuard
argument_list|(
name|ctx
argument_list|,
name|stencil_buffer
argument_list|,
name|freeRenderbufferFunc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|color_buffer
condition|)
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|color_buffer
argument_list|)
expr_stmt|;
else|else
name|glDeleteTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|texture
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth_buffer
condition|)
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|depth_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|stencil_buffer
operator|&&
name|depth_buffer
operator|!=
name|stencil_buffer
condition|)
name|glDeleteRenderbuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|stencil_buffer
argument_list|)
expr_stmt|;
name|glDeleteFramebuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|fbo
argument_list|)
expr_stmt|;
block|}
name|QT_CHECK_GLERROR
argument_list|()
expr_stmt|;
name|format
operator|.
name|setTextureTarget
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|format
operator|.
name|setSamples
argument_list|(
name|int
argument_list|(
name|samples
argument_list|)
argument_list|)
expr_stmt|;
name|format
operator|.
name|setAttachment
argument_list|(
name|fbo_attachment
argument_list|)
expr_stmt|;
name|format
operator|.
name|setInternalTextureFormat
argument_list|(
name|internal_format
argument_list|)
expr_stmt|;
name|format
operator|.
name|setMipmap
argument_list|(
name|mipmap
argument_list|)
expr_stmt|;
name|glDevice
operator|.
name|setFBO
argument_list|(
name|q
argument_list|,
name|attachment
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QGLFramebufferObject     \brief The QGLFramebufferObject class encapsulates an OpenGL framebuffer object.     \since 4.2      \ingroup painting-3D      The QGLFramebufferObject class encapsulates an OpenGL framebuffer     object, defined by the \c{GL_EXT_framebuffer_object} extension. In     addition it provides a rendering surface that can be painted on     with a QPainter, rendered to using native GL calls, or both. This     surface can be bound and used as a regular texture in your own GL     drawing code.  By default, the QGLFramebufferObject class     generates a 2D GL texture (using the \c{GL_TEXTURE_2D} target),     which is used as the internal rendering target.      \b{It is important to have a current GL context when creating a     QGLFramebufferObject, otherwise initialization will fail.}      OpenGL framebuffer objects and pbuffers (see     \l{QGLPixelBuffer}{QGLPixelBuffer}) can both be used to render to     offscreen surfaces, but there are a number of advantages with     using framebuffer objects instead of pbuffers:      \list 1     \li A framebuffer object does not require a separate rendering     context, so no context switching will occur when switching     rendering targets. There is an overhead involved in switching     targets, but in general it is cheaper than a context switch to a     pbuffer.      \li Rendering to dynamic textures (i.e. render-to-texture     functionality) works on all platforms. No need to do explicit copy     calls from a render buffer into a texture, as was necessary on     systems that did not support the \c{render_texture} extension.      \li It is possible to attach several rendering buffers (or texture     objects) to the same framebuffer object, and render to all of them     without doing a context switch.      \li The OpenGL framebuffer extension is a pure GL extension with no     system dependant WGL, CGL, or GLX parts. This makes using     framebuffer objects more portable.     \endlist      When using a QPainter to paint to a QGLFramebufferObject you should take     care that the QGLFramebufferObject is created with the CombinedDepthStencil     attachment for QPainter to be able to render correctly.     Note that you need to create a QGLFramebufferObject with more than one     sample per pixel for primitives to be antialiased when drawing using a     QPainter. To create a multisample framebuffer object you should use one of     the constructors that take a QGLFramebufferObject parameter, and set the     QGLFramebufferObject::samples() property to a non-zero value.      When painting to a QGLFramebufferObject using QPainter, the state of     the current GL context will be altered by the paint engine to reflect     its needs.  Applications should not rely upon the GL state being reset     to its original conditions, particularly the current shader program,     GL viewport, texture units, and drawing modes.      For multisample framebuffer objects a color render buffer is created,     otherwise a texture with the specified texture target is created.     The color render buffer or texture will have the specified internal     format, and will be bound to the \c GL_COLOR_ATTACHMENT0     attachment in the framebuffer object.      If you want to use a framebuffer object with multisampling enabled     as a texture, you first need to copy from it to a regular framebuffer     object using QGLContext::blitFramebuffer().      \section1 Threading      As of Qt 4.8, it's possible to draw into a QGLFramebufferObject     using a QPainter in a separate thread. Note that OpenGL 2.0 or     OpenGL ES 2.0 is required for this to work.      \sa {Framebuffer Object Example} */
end_comment
begin_comment
comment|/*!     \enum QGLFramebufferObject::Attachment     \since 4.3      This enum type is used to configure the depth and stencil buffers     attached to the framebuffer object when it is created.      \value NoAttachment         No attachment is added to the framebuffer object. Note that the                                 OpenGL depth and stencil tests won't work when rendering to a                                 framebuffer object without any depth or stencil buffers.                                 This is the default value.      \value CombinedDepthStencil If the \c GL_EXT_packed_depth_stencil extension is present,                                 a combined depth and stencil buffer is attached.                                 If the extension is not present, only a depth buffer is attached.      \value Depth                A depth buffer is attached to the framebuffer object.      \sa attachment() */
end_comment
begin_comment
comment|/*! \fn QGLFramebufferObject::QGLFramebufferObject(const QSize&size, GLenum target)      Constructs an OpenGL framebuffer object and binds a 2D GL texture     to the buffer of the size \a size. The texture is bound to the     \c GL_COLOR_ATTACHMENT0 target in the framebuffer object.      The \a target parameter is used to specify the GL texture     target. The default target is \c GL_TEXTURE_2D. Keep in mind that     \c GL_TEXTURE_2D textures must have a power of 2 width and height     (e.g. 256x512), unless you are using OpenGL 2.0 or higher.      By default, no depth and stencil buffers are attached. This behavior     can be toggled using one of the overloaded constructors.      The default internal texture format is \c GL_RGBA8 for desktop     OpenGL, and \c GL_RGBA for OpenGL/ES.      It is important that you have a current GL context set when     creating the QGLFramebufferObject, otherwise the initialization     will fail.      \sa size(), texture(), attachment() */
end_comment
begin_constructor
DECL|function|QGLFramebufferObject
name|QGLFramebufferObject
operator|::
name|QGLFramebufferObject
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|GLenum
name|target
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|size
argument_list|,
name|NoAttachment
argument_list|,
name|target
argument_list|,
name|DEFAULT_FORMAT
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object and binds a 2D GL texture     to the buffer of the given \a width and \a height.      \sa size(), texture() */
end_comment
begin_constructor
DECL|function|QGLFramebufferObject
name|QGLFramebufferObject
operator|::
name|QGLFramebufferObject
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|GLenum
name|target
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
name|NoAttachment
argument_list|,
name|target
argument_list|,
name|DEFAULT_FORMAT
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object of the given \a size based on the     supplied \a format. */
end_comment
begin_constructor
DECL|function|QGLFramebufferObject
name|QGLFramebufferObject
operator|::
name|QGLFramebufferObject
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
specifier|const
name|QGLFramebufferObjectFormat
modifier|&
name|format
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|size
argument_list|,
name|format
operator|.
name|attachment
argument_list|()
argument_list|,
name|format
operator|.
name|textureTarget
argument_list|()
argument_list|,
name|format
operator|.
name|internalTextureFormat
argument_list|()
argument_list|,
name|format
operator|.
name|samples
argument_list|()
argument_list|,
name|format
operator|.
name|mipmap
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object of the given \a width and \a height     based on the supplied \a format. */
end_comment
begin_constructor
DECL|function|QGLFramebufferObject
name|QGLFramebufferObject
operator|::
name|QGLFramebufferObject
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
specifier|const
name|QGLFramebufferObjectFormat
modifier|&
name|format
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
name|format
operator|.
name|attachment
argument_list|()
argument_list|,
name|format
operator|.
name|textureTarget
argument_list|()
argument_list|,
name|format
operator|.
name|internalTextureFormat
argument_list|()
argument_list|,
name|format
operator|.
name|samples
argument_list|()
argument_list|,
name|format
operator|.
name|mipmap
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object and binds a texture to the     buffer of the given \a width and \a height.      The \a attachment parameter describes the depth/stencil buffer     configuration, \a target the texture target and \a internal_format     the internal texture format. The default texture target is \c     GL_TEXTURE_2D, while the default internal format is \c GL_RGBA8     for desktop OpenGL and \c GL_RGBA for OpenGL/ES.      \sa size(), texture(), attachment() */
end_comment
begin_constructor
DECL|function|QGLFramebufferObject
name|QGLFramebufferObject
operator|::
name|QGLFramebufferObject
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|Attachment
name|attachment
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|internal_format
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
name|attachment
argument_list|,
name|target
argument_list|,
name|internal_format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \overload      Constructs an OpenGL framebuffer object and binds a texture to the     buffer of the given \a size.      The \a attachment parameter describes the depth/stencil buffer     configuration, \a target the texture target and \a internal_format     the internal texture format. The default texture target is \c     GL_TEXTURE_2D, while the default internal format is \c GL_RGBA8     for desktop OpenGL and \c GL_RGBA for OpenGL/ES.      \sa size(), texture(), attachment() */
end_comment
begin_constructor
DECL|function|QGLFramebufferObject
name|QGLFramebufferObject
operator|::
name|QGLFramebufferObject
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|Attachment
name|attachment
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLenum
name|internal_format
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QGLFramebufferObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|this
argument_list|,
name|size
argument_list|,
name|attachment
argument_list|,
name|target
argument_list|,
name|internal_format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QGLFramebufferObject::~QGLFramebufferObject()      Destroys the framebuffer object and frees any allocated resources. */
end_comment
begin_destructor
DECL|function|~QGLFramebufferObject
name|QGLFramebufferObject
operator|::
name|~
name|QGLFramebufferObject
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|engine
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|texture_guard
condition|)
name|d
operator|->
name|texture_guard
operator|->
name|free
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|color_buffer_guard
condition|)
name|d
operator|->
name|color_buffer_guard
operator|->
name|free
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|depth_buffer_guard
condition|)
name|d
operator|->
name|depth_buffer_guard
operator|->
name|free
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|stencil_buffer_guard
operator|&&
name|d
operator|->
name|stencil_buffer_guard
operator|!=
name|d
operator|->
name|depth_buffer_guard
condition|)
name|d
operator|->
name|stencil_buffer_guard
operator|->
name|free
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fbo_guard
condition|)
name|d
operator|->
name|fbo_guard
operator|->
name|free
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn bool QGLFramebufferObject::isValid() const      Returns true if the framebuffer object is valid.      The framebuffer can become invalid if the initialization process     fails, the user attaches an invalid buffer to the framebuffer     object, or a non-power of two width/height is specified as the     texture size if the texture target is \c{GL_TEXTURE_2D}.     The non-power of two limitation does not apply if the OpenGL version     is 2.0 or higher, or if the GL_ARB_texture_non_power_of_two extension     is present.      The framebuffer can also become invalid if the QGLContext that     the framebuffer was created within is destroyed and there are     no other shared contexts that can take over ownership of the     framebuffer. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QGLFramebufferObject
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|valid
operator|&&
name|d
operator|->
name|fbo_guard
operator|&&
name|d
operator|->
name|fbo_guard
operator|->
name|id
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFramebufferObject::bind()      Switches rendering from the default, windowing system provided     framebuffer to this framebuffer object.     Returns true upon success, false otherwise.      \sa release() */
end_comment
begin_function
DECL|function|bind
name|bool
name|QGLFramebufferObject
operator|::
name|bind
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|Q_D
argument_list|(
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
name|QGL_FUNC_CONTEXT
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return
literal|false
return|;
comment|// Context no longer exists.
specifier|const
name|QGLContext
modifier|*
name|current
init|=
name|QGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG
if|if
condition|(
operator|!
name|current
operator|||
name|QGLContextPrivate
operator|::
name|contextGroup
argument_list|(
name|current
argument_list|)
operator|!=
name|QGLContextPrivate
operator|::
name|contextGroup
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLFramebufferObject::bind() called from incompatible context"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|d
operator|->
name|fbo
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|valid
operator|=
name|d
operator|->
name|checkFramebufferStatus
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|valid
operator|&&
name|current
condition|)
name|current
operator|->
name|d_ptr
operator|->
name|current_fbo
operator|=
name|d
operator|->
name|fbo
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|valid
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFramebufferObject::release()      Switches rendering back to the default, windowing system provided     framebuffer.     Returns true upon success, false otherwise.      \sa bind() */
end_comment
begin_function
DECL|function|release
name|bool
name|QGLFramebufferObject
operator|::
name|release
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|QGL_FUNC_CONTEXT
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return
literal|false
return|;
comment|// Context no longer exists.
specifier|const
name|QGLContext
modifier|*
name|current
init|=
name|QGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG
if|if
condition|(
operator|!
name|current
operator|||
name|QGLContextPrivate
operator|::
name|contextGroup
argument_list|(
name|current
argument_list|)
operator|!=
name|QGLContextPrivate
operator|::
name|contextGroup
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGLFramebufferObject::release() called from incompatible context"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|current
condition|)
block|{
name|current
operator|->
name|d_ptr
operator|->
name|current_fbo
operator|=
name|current
operator|->
name|d_ptr
operator|->
name|default_fbo
expr_stmt|;
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|current
operator|->
name|d_ptr
operator|->
name|default_fbo
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \fn GLuint QGLFramebufferObject::texture() const      Returns the texture id for the texture attached as the default     rendering target in this framebuffer object. This texture id can     be bound as a normal texture in your own GL code.      If a multisample framebuffer object is used then the value returned     from this function will be invalid. */
end_comment
begin_function
DECL|function|texture
name|GLuint
name|QGLFramebufferObject
operator|::
name|texture
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|texture_guard
condition|?
name|d
operator|->
name|texture_guard
operator|->
name|id
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QSize QGLFramebufferObject::size() const      Returns the size of the texture attached to this framebuffer     object. */
end_comment
begin_function
DECL|function|size
name|QSize
name|QGLFramebufferObject
operator|::
name|size
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|size
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the format of this framebuffer object. */
end_comment
begin_function
DECL|function|format
name|QGLFramebufferObjectFormat
name|QGLFramebufferObject
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|format
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QGLFramebufferObject::toImage() const      Returns the contents of this framebuffer object as a QImage. */
end_comment
begin_function
DECL|function|toImage
name|QImage
name|QGLFramebufferObject
operator|::
name|toImage
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|valid
condition|)
return|return
name|QImage
argument_list|()
return|;
comment|// qt_gl_read_framebuffer doesn't work on a multisample FBO
if|if
condition|(
name|format
argument_list|()
operator|.
name|samples
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|QGLFramebufferObject
name|temp
argument_list|(
name|size
argument_list|()
argument_list|,
name|QGLFramebufferObjectFormat
argument_list|()
argument_list|)
decl_stmt|;
name|QRect
name|rect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|blitFramebuffer
argument_list|(
operator|&
name|temp
argument_list|,
name|rect
argument_list|,
cast|const_cast
argument_list|<
name|QGLFramebufferObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|,
name|rect
argument_list|)
expr_stmt|;
return|return
name|temp
operator|.
name|toImage
argument_list|()
return|;
block|}
name|bool
name|wasBound
init|=
name|isBound
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|wasBound
condition|)
cast|const_cast
argument_list|<
name|QGLFramebufferObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|bind
argument_list|()
expr_stmt|;
name|QImage
name|image
init|=
name|qt_gl_read_framebuffer
argument_list|(
name|d
operator|->
name|size
argument_list|,
name|format
argument_list|()
operator|.
name|internalTextureFormat
argument_list|()
operator|!=
name|GL_RGB
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|wasBound
condition|)
cast|const_cast
argument_list|<
name|QGLFramebufferObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|release
argument_list|()
expr_stmt|;
return|return
name|image
return|;
block|}
end_function
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QGLEngineThreadStorage<QGL2PaintEngineEx>
argument_list|,
argument|qt_buffer_2_engine
argument_list|)
end_macro
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QGLFramebufferObject
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|engine
condition|)
return|return
name|d
operator|->
name|engine
return|;
name|QPaintEngine
modifier|*
name|engine
init|=
name|qt_buffer_2_engine
argument_list|()
operator|->
name|engine
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|->
name|isActive
argument_list|()
operator|&&
name|engine
operator|->
name|paintDevice
argument_list|()
operator|!=
name|this
condition|)
block|{
name|d
operator|->
name|engine
operator|=
operator|new
name|QGL2PaintEngineEx
expr_stmt|;
return|return
name|d
operator|->
name|engine
return|;
block|}
return|return
name|engine
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFramebufferObject::bindDefault()     \internal      Switches rendering back to the default, windowing system provided     framebuffer.     Returns true upon success, false otherwise.      \sa bind(), release() */
end_comment
begin_function
DECL|function|bindDefault
name|bool
name|QGLFramebufferObject
operator|::
name|bindDefault
parameter_list|()
block|{
name|QGLContext
modifier|*
name|ctx
init|=
cast|const_cast
argument_list|<
name|QGLContext
operator|*
argument_list|>
argument_list|(
name|QGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
name|bool
name|ext_detected
init|=
operator|(
name|QGLExtensions
operator|::
name|glExtensions
argument_list|()
operator|&
name|QGLExtensions
operator|::
name|FramebufferObject
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|ext_detected
operator|||
operator|(
name|ext_detected
operator|&&
operator|!
name|qt_resolve_framebufferobject_extensions
argument_list|(
name|ctx
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
name|ctx
operator|->
name|d_ptr
operator|->
name|current_fbo
operator|=
name|ctx
operator|->
name|d_ptr
operator|->
name|default_fbo
expr_stmt|;
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|ctx
operator|->
name|d_ptr
operator|->
name|default_fbo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QGLFramebufferObject::bindDefault() called without current context."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|ctx
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFramebufferObject::hasOpenGLFramebufferObjects()      Returns true if the OpenGL \c{GL_EXT_framebuffer_object} extension     is present on this system; otherwise returns false. */
end_comment
begin_function
DECL|function|hasOpenGLFramebufferObjects
name|bool
name|QGLFramebufferObject
operator|::
name|hasOpenGLFramebufferObjects
parameter_list|()
block|{
return|return
operator|(
name|QGLExtensions
operator|::
name|glExtensions
argument_list|()
operator|&
name|QGLExtensions
operator|::
name|FramebufferObject
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Draws the given texture, \a textureId, to the given target rectangle,     \a target, in OpenGL model space. The \a textureTarget should be a 2D     texture target.      The framebuffer object should be bound when calling this function.      Equivalent to the corresponding QGLContext::drawTexture(). */
end_comment
begin_function
DECL|function|drawTexture
name|void
name|QGLFramebufferObject
operator|::
name|drawTexture
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|target
parameter_list|,
name|GLuint
name|textureId
parameter_list|,
name|GLenum
name|textureTarget
parameter_list|)
block|{
cast|const_cast
argument_list|<
name|QGLContext
operator|*
argument_list|>
argument_list|(
name|QGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
operator|->
name|drawTexture
argument_list|(
name|target
argument_list|,
name|textureId
argument_list|,
name|textureTarget
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Draws the given texture, \a textureId, at the given \a point in OpenGL     model space. The \a textureTarget should be a 2D texture target.      The framebuffer object should be bound when calling this function.      Equivalent to the corresponding QGLContext::drawTexture(). */
end_comment
begin_function
DECL|function|drawTexture
name|void
name|QGLFramebufferObject
operator|::
name|drawTexture
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|,
name|GLuint
name|textureId
parameter_list|,
name|GLenum
name|textureTarget
parameter_list|)
block|{
cast|const_cast
argument_list|<
name|QGLContext
operator|*
argument_list|>
argument_list|(
name|QGLContext
operator|::
name|currentContext
argument_list|()
argument_list|)
operator|->
name|drawTexture
argument_list|(
name|point
argument_list|,
name|textureId
argument_list|,
name|textureTarget
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|metric
name|int
name|QGLFramebufferObject
operator|::
name|metric
parameter_list|(
name|PaintDeviceMetric
name|metric
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
name|float
name|dpmx
init|=
name|qt_defaultDpiX
argument_list|()
operator|*
literal|100.
operator|/
literal|2.54
decl_stmt|;
name|float
name|dpmy
init|=
name|qt_defaultDpiY
argument_list|()
operator|*
literal|100.
operator|/
literal|2.54
decl_stmt|;
name|int
name|w
init|=
name|d
operator|->
name|size
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|d
operator|->
name|size
operator|.
name|height
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|metric
condition|)
block|{
case|case
name|PdmWidth
case|:
return|return
name|w
return|;
case|case
name|PdmHeight
case|:
return|return
name|h
return|;
case|case
name|PdmWidthMM
case|:
return|return
name|qRound
argument_list|(
name|w
operator|*
literal|1000
operator|/
name|dpmx
argument_list|)
return|;
case|case
name|PdmHeightMM
case|:
return|return
name|qRound
argument_list|(
name|h
operator|*
literal|1000
operator|/
name|dpmy
argument_list|)
return|;
case|case
name|PdmNumColors
case|:
return|return
literal|0
return|;
case|case
name|PdmDepth
case|:
return|return
literal|32
return|;
comment|//d->depth;
case|case
name|PdmDpiX
case|:
return|return
name|qRound
argument_list|(
name|dpmx
operator|*
literal|0.0254
argument_list|)
return|;
case|case
name|PdmDpiY
case|:
return|return
name|qRound
argument_list|(
name|dpmy
operator|*
literal|0.0254
argument_list|)
return|;
case|case
name|PdmPhysicalDpiX
case|:
return|return
name|qRound
argument_list|(
name|dpmx
operator|*
literal|0.0254
argument_list|)
return|;
case|case
name|PdmPhysicalDpiY
case|:
return|return
name|qRound
argument_list|(
name|dpmy
operator|*
literal|0.0254
argument_list|)
return|;
default|default:
name|qWarning
argument_list|(
literal|"QGLFramebufferObject::metric(), Unhandled metric type: %d.\n"
argument_list|,
name|metric
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn GLuint QGLFramebufferObject::handle() const      Returns the GL framebuffer object handle for this framebuffer     object (returned by the \c{glGenFrameBuffersEXT()} function). This     handle can be used to attach new images or buffers to the     framebuffer. The user is responsible for cleaning up and     destroying these objects. */
end_comment
begin_function
DECL|function|handle
name|GLuint
name|QGLFramebufferObject
operator|::
name|handle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fbo
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \fn int QGLFramebufferObject::devType() const     \internal */
end_comment
begin_comment
comment|/*!     Returns the status of the depth and stencil buffers attached to     this framebuffer object. */
end_comment
begin_function
DECL|function|attachment
name|QGLFramebufferObject
operator|::
name|Attachment
name|QGLFramebufferObject
operator|::
name|attachment
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|valid
condition|)
return|return
name|d
operator|->
name|fbo_attachment
return|;
return|return
name|NoAttachment
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns true if the framebuffer object is currently bound to a context,     otherwise false is returned. */
end_comment
begin_function
DECL|function|isBound
name|bool
name|QGLFramebufferObject
operator|::
name|isBound
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGLFramebufferObject
argument_list|)
expr_stmt|;
specifier|const
name|QGLContext
modifier|*
name|current
init|=
name|QGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
return|return
name|current
condition|?
name|current
operator|->
name|d_ptr
operator|->
name|current_fbo
operator|==
name|d
operator|->
name|fbo
argument_list|()
else|:
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGLFramebufferObject::hasOpenGLFramebufferBlit()      \since 4.6      Returns true if the OpenGL \c{GL_EXT_framebuffer_blit} extension     is present on this system; otherwise returns false.      \sa blitFramebuffer() */
end_comment
begin_function
DECL|function|hasOpenGLFramebufferBlit
name|bool
name|QGLFramebufferObject
operator|::
name|hasOpenGLFramebufferBlit
parameter_list|()
block|{
return|return
operator|(
name|QGLExtensions
operator|::
name|glExtensions
argument_list|()
operator|&
name|QGLExtensions
operator|::
name|FramebufferBlit
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Blits from the \a sourceRect rectangle in the \a source framebuffer     object to the \a targetRect rectangle in the \a target framebuffer object.      If \a source or \a target is 0, the default framebuffer will be used     instead of a framebuffer object as source or target respectively.      The \a buffers parameter should be a mask consisting of any combination of     \c GL_COLOR_BUFFER_BIT, \c GL_DEPTH_BUFFER_BIT, and     \c GL_STENCIL_BUFFER_BIT.  Any buffer type that is not present both     in the source and target buffers is ignored.      The \a sourceRect and \a targetRect rectangles may have different sizes;     in this case \a buffers should not contain \c GL_DEPTH_BUFFER_BIT or     \c GL_STENCIL_BUFFER_BIT. The \a filter parameter should be set to     \c GL_LINEAR or \c GL_NEAREST, and specifies whether linear or nearest     interpolation should be used when scaling is performed.      If \a source equals \a target a copy is performed within the same buffer.     Results are undefined if the source and target rectangles overlap and     have different sizes. The sizes must also be the same if any of the     framebuffer objects are multisample framebuffers.      Note that the scissor test will restrict the blit area if enabled.      This function will have no effect unless hasOpenGLFramebufferBlit() returns     true.      \sa hasOpenGLFramebufferBlit() */
end_comment
begin_function
DECL|function|blitFramebuffer
name|void
name|QGLFramebufferObject
operator|::
name|blitFramebuffer
parameter_list|(
name|QGLFramebufferObject
modifier|*
name|target
parameter_list|,
specifier|const
name|QRect
modifier|&
name|targetRect
parameter_list|,
name|QGLFramebufferObject
modifier|*
name|source
parameter_list|,
specifier|const
name|QRect
modifier|&
name|sourceRect
parameter_list|,
name|GLbitfield
name|buffers
parameter_list|,
name|GLenum
name|filter
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|QGLExtensions
operator|::
name|glExtensions
argument_list|()
operator|&
name|QGLExtensions
operator|::
name|FramebufferBlit
operator|)
condition|)
return|return;
specifier|const
name|QGLContext
modifier|*
name|ctx
init|=
name|QGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|||
operator|!
name|ctx
operator|->
name|contextHandle
argument_list|()
condition|)
return|return;
name|QSurface
modifier|*
name|surface
init|=
name|ctx
operator|->
name|contextHandle
argument_list|()
operator|->
name|surface
argument_list|()
decl_stmt|;
specifier|const
name|int
name|height
init|=
cast|static_cast
argument_list|<
name|QWindow
operator|*
argument_list|>
argument_list|(
name|surface
argument_list|)
operator|->
name|height
argument_list|()
decl_stmt|;
specifier|const
name|int
name|sh
init|=
name|source
condition|?
name|source
operator|->
name|height
argument_list|()
else|:
name|height
decl_stmt|;
specifier|const
name|int
name|th
init|=
name|target
condition|?
name|target
operator|->
name|height
argument_list|()
else|:
name|height
decl_stmt|;
specifier|const
name|int
name|sx0
init|=
name|sourceRect
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|int
name|sx1
init|=
name|sourceRect
operator|.
name|left
argument_list|()
operator|+
name|sourceRect
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|sy0
init|=
name|sh
operator|-
operator|(
name|sourceRect
operator|.
name|top
argument_list|()
operator|+
name|sourceRect
operator|.
name|height
argument_list|()
operator|)
decl_stmt|;
specifier|const
name|int
name|sy1
init|=
name|sh
operator|-
name|sourceRect
operator|.
name|top
argument_list|()
decl_stmt|;
specifier|const
name|int
name|tx0
init|=
name|targetRect
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|int
name|tx1
init|=
name|targetRect
operator|.
name|left
argument_list|()
operator|+
name|targetRect
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|ty0
init|=
name|th
operator|-
operator|(
name|targetRect
operator|.
name|top
argument_list|()
operator|+
name|targetRect
operator|.
name|height
argument_list|()
operator|)
decl_stmt|;
specifier|const
name|int
name|ty1
init|=
name|th
operator|-
name|targetRect
operator|.
name|top
argument_list|()
decl_stmt|;
name|glBindFramebuffer
argument_list|(
name|GL_READ_FRAMEBUFFER
argument_list|,
name|source
condition|?
name|source
operator|->
name|handle
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
name|glBindFramebuffer
argument_list|(
name|GL_DRAW_FRAMEBUFFER
argument_list|,
name|target
condition|?
name|target
operator|->
name|handle
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
name|glBlitFramebufferEXT
argument_list|(
name|sx0
argument_list|,
name|sy0
argument_list|,
name|sx1
argument_list|,
name|sy1
argument_list|,
name|tx0
argument_list|,
name|ty0
argument_list|,
name|tx1
argument_list|,
name|ty1
argument_list|,
name|buffers
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|glBindFramebuffer
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
name|ctx
operator|->
name|d_ptr
operator|->
name|current_fbo
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
