begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtOpenGL module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QGL_P_H
end_ifndef
begin_define
DECL|macro|QGL_P_H
define|#
directive|define
name|QGL_P_H
end_define
begin_comment
comment|//
end_comment
begin_comment
comment|//  W A R N I N G
end_comment
begin_comment
comment|//  -------------
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// This file is not part of the Qt API.  It exists for the convenience
end_comment
begin_comment
comment|// of the QGLWidget class.  This header file may change from
end_comment
begin_comment
comment|// version to version without notice, or even be removed.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// We mean it.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"QtOpenGL/qgl.h"
end_include
begin_include
include|#
directive|include
file|"QtOpenGL/qglcolormap.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qmap.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qthread.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qthreadstorage.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qhash.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qatomic.h"
end_include
begin_include
include|#
directive|include
file|"QtWidgets/private/qwidget_p.h"
end_include
begin_include
include|#
directive|include
file|"qcache.h"
end_include
begin_include
include|#
directive|include
file|"qglpaintdevice_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_EGL
end_ifndef
begin_include
include|#
directive|include
file|<QtGui/private/qegl_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
end_if
begin_include
include|#
directive|include
file|<QtGui/QGuiGLContext>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|QGLContext
name|class
name|QGLContext
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QGLOverlayWidget
name|class
name|QGLOverlayWidget
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QPixmap
name|class
name|QPixmap
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QPixmapFilter
name|class
name|QPixmapFilter
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_MAC
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|qDebug
end_ifdef
begin_define
DECL|macro|old_qDebug
define|#
directive|define
name|old_qDebug
value|qDebug
end_define
begin_undef
DECL|macro|qDebug
undef|#
directive|undef
name|qDebug
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_INCLUDE_NAMESPACE
ifndef|#
directive|ifndef
name|QT_MAC_USE_COCOA
include|#
directive|include
file|<AGL/agl.h>
endif|#
directive|endif
name|QT_END_INCLUDE_NAMESPACE
ifdef|#
directive|ifdef
name|old_qDebug
DECL|macro|qDebug
undef|#
directive|undef
name|qDebug
DECL|macro|qDebug
define|#
directive|define
name|qDebug
value|QT_NO_QDEBUG_MACRO
DECL|macro|old_qDebug
undef|#
directive|undef
name|old_qDebug
endif|#
directive|endif
DECL|variable|QMacWindowChangeEvent
name|class
name|QMacWindowChangeEvent
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_EGL
end_ifndef
begin_decl_stmt
DECL|variable|QEglContext
name|class
name|QEglContext
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|<QtOpenGL/private/qglextensions_p.h>
name|QT_END_INCLUDE_NAMESPACE
name|class
name|QGLFormatPrivate
block|{
name|public
label|:
name|QGLFormatPrivate
argument_list|()
operator|:
name|ref
argument_list|(
literal|1
argument_list|)
block|{
name|opts
operator|=
name|QGL
operator|::
name|DoubleBuffer
operator||
name|QGL
operator|::
name|DepthBuffer
operator||
name|QGL
operator|::
name|Rgba
operator||
name|QGL
operator|::
name|DirectRendering
operator||
name|QGL
operator|::
name|StencilBuffer
operator||
name|QGL
operator|::
name|DeprecatedFunctions
block|;
name|pln
operator|=
literal|0
block|;
name|depthSize
operator|=
name|accumSize
operator|=
name|stencilSize
operator|=
name|redSize
operator|=
name|greenSize
operator|=
name|blueSize
operator|=
name|alphaSize
operator|=
operator|-
literal|1
block|;
name|numSamples
operator|=
operator|-
literal|1
block|;
name|swapInterval
operator|=
operator|-
literal|1
block|;
name|majorVersion
operator|=
literal|1
block|;
name|minorVersion
operator|=
literal|0
block|;
name|profile
operator|=
name|QGLFormat
operator|::
name|NoProfile
block|;     }
name|QGLFormatPrivate
argument_list|(
specifier|const
name|QGLFormatPrivate
operator|*
name|other
argument_list|)
operator|:
name|ref
argument_list|(
literal|1
argument_list|)
operator|,
name|opts
argument_list|(
name|other
operator|->
name|opts
argument_list|)
operator|,
name|pln
argument_list|(
name|other
operator|->
name|pln
argument_list|)
operator|,
name|depthSize
argument_list|(
name|other
operator|->
name|depthSize
argument_list|)
operator|,
name|accumSize
argument_list|(
name|other
operator|->
name|accumSize
argument_list|)
operator|,
name|stencilSize
argument_list|(
name|other
operator|->
name|stencilSize
argument_list|)
operator|,
name|redSize
argument_list|(
name|other
operator|->
name|redSize
argument_list|)
operator|,
name|greenSize
argument_list|(
name|other
operator|->
name|greenSize
argument_list|)
operator|,
name|blueSize
argument_list|(
name|other
operator|->
name|blueSize
argument_list|)
operator|,
name|alphaSize
argument_list|(
name|other
operator|->
name|alphaSize
argument_list|)
operator|,
name|numSamples
argument_list|(
name|other
operator|->
name|numSamples
argument_list|)
operator|,
name|swapInterval
argument_list|(
name|other
operator|->
name|swapInterval
argument_list|)
operator|,
name|majorVersion
argument_list|(
name|other
operator|->
name|majorVersion
argument_list|)
operator|,
name|minorVersion
argument_list|(
name|other
operator|->
name|minorVersion
argument_list|)
operator|,
name|profile
argument_list|(
argument|other->profile
argument_list|)
block|{     }
name|QAtomicInt
name|ref
expr_stmt|;
name|QGL
operator|::
name|FormatOptions
name|opts
expr_stmt|;
name|int
name|pln
decl_stmt|;
name|int
name|depthSize
decl_stmt|;
name|int
name|accumSize
decl_stmt|;
name|int
name|stencilSize
decl_stmt|;
name|int
name|redSize
decl_stmt|;
name|int
name|greenSize
decl_stmt|;
name|int
name|blueSize
decl_stmt|;
name|int
name|alphaSize
decl_stmt|;
name|int
name|numSamples
decl_stmt|;
name|int
name|swapInterval
decl_stmt|;
name|int
name|majorVersion
decl_stmt|;
name|int
name|minorVersion
decl_stmt|;
name|QGLFormat
operator|::
name|OpenGLContextProfile
name|profile
expr_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_decl_stmt
name|class
name|Q_OPENGL_EXPORT
name|QGLWidgetPrivate
range|:
name|public
name|QWidgetPrivate
block|{
name|Q_DECLARE_PUBLIC
argument_list|(
argument|QGLWidget
argument_list|)
name|public
operator|:
name|QGLWidgetPrivate
argument_list|()
operator|:
name|QWidgetPrivate
argument_list|()
block|,
name|disable_clear_on_painter_begin
argument_list|(
name|false
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_QWS
argument_list|)
block|,
name|wsurf
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_EGL
argument_list|)
block|,
name|eglSurfaceWindowId
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
block|,
name|eglSurfaceWindowId
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
block|{
name|isGLWidget
operator|=
literal|1
block|;     }
operator|~
name|QGLWidgetPrivate
argument_list|()
block|{}
name|void
name|init
argument_list|(
name|QGLContext
operator|*
name|context
argument_list|,
specifier|const
name|QGLWidget
operator|*
name|shareWidget
argument_list|)
block|;
name|void
name|initContext
argument_list|(
name|QGLContext
operator|*
name|context
argument_list|,
specifier|const
name|QGLWidget
operator|*
name|shareWidget
argument_list|)
block|;
name|bool
name|renderCxPm
argument_list|(
name|QPixmap
operator|*
name|pixmap
argument_list|)
block|;
name|void
name|cleanupColormaps
argument_list|()
block|;
name|void
name|aboutToDestroy
argument_list|()
block|{
if|if
condition|(
name|glcx
condition|)
name|glcx
operator|->
name|reset
argument_list|()
expr_stmt|;
block|}
name|QGLContext
operator|*
name|glcx
block|;
name|QGLWidgetGLPaintDevice
name|glDevice
block|;
name|bool
name|autoSwap
block|;
name|QGLColormap
name|cmap
block|;
ifndef|#
directive|ifndef
name|QT_OPENGL_ES
name|QMap
operator|<
name|QString
block|,
name|int
operator|>
name|displayListCache
block|;
endif|#
directive|endif
name|bool
name|disable_clear_on_painter_begin
block|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
name|void
name|updateColormap
argument_list|()
block|;
name|QGLContext
operator|*
name|olcx
block|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|QGLOverlayWidget
operator|*
name|olw
block|;
ifndef|#
directive|ifndef
name|QT_NO_EGL
name|void
name|recreateEglSurface
argument_list|()
block|;
name|WId
name|eglSurfaceWindowId
block|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|QGLContext
operator|*
name|olcx
block|;
name|void
name|updatePaintDevice
argument_list|()
block|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
name|void
name|recreateEglSurface
argument_list|()
block|;
name|WId
name|eglSurfaceWindowId
block|;
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QGLContextGroupResourceBase
name|class
name|QGLContextGroupResourceBase
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QGLSharedResourceGuard
name|class
name|QGLSharedResourceGuard
decl_stmt|;
end_decl_stmt
begin_comment
comment|// QGLContextPrivate has the responsibility of creating context groups.
end_comment
begin_comment
comment|// QGLContextPrivate maintains the reference counter and destroys
end_comment
begin_comment
comment|// context groups when needed.
end_comment
begin_decl_stmt
name|class
name|QGLContextGroup
block|{
name|public
label|:
operator|~
name|QGLContextGroup
argument_list|()
expr_stmt|;
name|QGLExtensionFuncs
modifier|&
name|extensionFuncs
parameter_list|()
block|{
return|return
name|m_extensionFuncs
return|;
block|}
specifier|const
name|QGLContext
operator|*
name|context
argument_list|()
specifier|const
block|{
return|return
name|m_context
return|;
block|}
name|bool
name|isSharing
argument_list|()
specifier|const
block|{
return|return
name|m_shares
operator|.
name|size
argument_list|()
operator|>=
literal|2
return|;
block|}
name|QList
operator|<
specifier|const
name|QGLContext
operator|*
operator|>
name|shares
argument_list|()
specifier|const
block|{
return|return
name|m_shares
return|;
block|}
name|void
name|addGuard
parameter_list|(
name|QGLSharedResourceGuard
modifier|*
name|guard
parameter_list|)
function_decl|;
name|void
name|removeGuard
parameter_list|(
name|QGLSharedResourceGuard
modifier|*
name|guard
parameter_list|)
function_decl|;
specifier|static
name|void
name|addShare
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|context
parameter_list|,
specifier|const
name|QGLContext
modifier|*
name|share
parameter_list|)
function_decl|;
specifier|static
name|void
name|removeShare
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|context
parameter_list|)
function_decl|;
name|private
label|:
name|QGLContextGroup
argument_list|(
specifier|const
name|QGLContext
operator|*
name|context
argument_list|)
expr_stmt|;
name|QGLExtensionFuncs
name|m_extensionFuncs
decl_stmt|;
specifier|const
name|QGLContext
modifier|*
name|m_context
decl_stmt|;
comment|// context group's representative
name|QList
operator|<
specifier|const
name|QGLContext
operator|*
operator|>
name|m_shares
expr_stmt|;
name|QHash
operator|<
name|QGLContextGroupResourceBase
operator|*
operator|,
name|void
operator|*
operator|>
name|m_resources
expr_stmt|;
name|QGLSharedResourceGuard
modifier|*
name|m_guards
decl_stmt|;
comment|// double-linked list of active guards.
name|QAtomicInt
name|m_refs
decl_stmt|;
name|void
name|cleanupResources
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|friend
name|class
name|QGLContext
decl_stmt|;
name|friend
name|class
name|QGLContextPrivate
decl_stmt|;
name|friend
name|class
name|QGLContextGroupResourceBase
decl_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|// Get the context that resources for "ctx" will transfer to once
end_comment
begin_comment
comment|// "ctx" is destroyed.  Returns null if nothing is sharing with ctx.
end_comment
begin_function_decl
name|Q_OPENGL_EXPORT
specifier|const
name|QGLContext
modifier|*
name|qt_gl_transfer_context
parameter_list|(
specifier|const
name|QGLContext
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|// GL extension definitions
end_comment
begin_decl_stmt
name|class
name|QGLExtensions
block|{
name|public
label|:
enum|enum
name|Extension
block|{
name|TextureRectangle
init|=
literal|0x00000001
block|,
name|SampleBuffers
init|=
literal|0x00000002
block|,
name|GenerateMipmap
init|=
literal|0x00000004
block|,
name|TextureCompression
init|=
literal|0x00000008
block|,
name|FragmentProgram
init|=
literal|0x00000010
block|,
name|MirroredRepeat
init|=
literal|0x00000020
block|,
name|FramebufferObject
init|=
literal|0x00000040
block|,
name|StencilTwoSide
init|=
literal|0x00000080
block|,
name|StencilWrap
init|=
literal|0x00000100
block|,
name|PackedDepthStencil
init|=
literal|0x00000200
block|,
name|NVFloatBuffer
init|=
literal|0x00000400
block|,
name|PixelBufferObject
init|=
literal|0x00000800
block|,
name|FramebufferBlit
init|=
literal|0x00001000
block|,
name|NPOTTextures
init|=
literal|0x00002000
block|,
name|BGRATextureFormat
init|=
literal|0x00004000
block|,
name|DDSTextureCompression
init|=
literal|0x00008000
block|,
name|ETC1TextureCompression
init|=
literal|0x00010000
block|,
name|PVRTCTextureCompression
init|=
literal|0x00020000
block|,
name|FragmentShader
init|=
literal|0x00040000
block|,
name|ElementIndexUint
init|=
literal|0x00080000
block|,
name|Depth24
init|=
literal|0x00100000
block|,
name|SRGBFrameBuffer
init|=
literal|0x00200000
block|}
enum|;
name|Q_DECLARE_FLAGS
argument_list|(
argument|Extensions
argument_list|,
argument|Extension
argument_list|)
specifier|static
name|Extensions
name|glExtensions
parameter_list|()
function_decl|;
specifier|static
name|Extensions
name|currentContextExtensions
parameter_list|()
function_decl|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|/*     QGLTemporaryContext - the main objective of this class is to have a way of     creating a GL context and making it current, without going via QGLWidget     and friends. At certain points during GL initialization we need a current     context in order decide what GL features are available, and to resolve GL     extensions. Having a light-weight way of creating such a context saves     initial application startup time, and it doesn't wind up creating recursive     conflicts.     The class currently uses a private d pointer to hide the platform specific     types. This could possibly been done inline with #ifdef'ery, but it causes     major headaches on e.g. X11 due to namespace pollution. */
end_comment
begin_decl_stmt
DECL|variable|QGLTemporaryContextPrivate
name|class
name|QGLTemporaryContextPrivate
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|class
name|QGLTemporaryContext
block|{
name|public
label|:
name|QGLTemporaryContext
argument_list|(
argument|bool directRendering = true
argument_list|,
argument|QWidget *parent =
literal|0
argument_list|)
empty_stmt|;
operator|~
name|QGLTemporaryContext
argument_list|()
expr_stmt|;
name|private
label|:
name|QScopedPointer
operator|<
name|QGLTemporaryContextPrivate
operator|>
name|d
expr_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_decl_stmt
DECL|variable|QGLTexture
name|class
name|QGLTexture
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QGLTextureDestroyer
name|class
name|QGLTextureDestroyer
decl_stmt|;
end_decl_stmt
begin_comment
comment|// This probably needs to grow to GL_MAX_VERTEX_ATTRIBS, but 3 is ok for now as that's
end_comment
begin_comment
comment|// all the GL2 engine uses:
end_comment
begin_define
DECL|macro|QT_GL_VERTEX_ARRAY_TRACKED_COUNT
define|#
directive|define
name|QT_GL_VERTEX_ARRAY_TRACKED_COUNT
value|3
end_define
begin_decl_stmt
DECL|variable|QGLContextResourceBase
name|class
name|QGLContextResourceBase
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|class
name|QGLContextPrivate
block|{
name|Q_DECLARE_PUBLIC
argument_list|(
argument|QGLContext
argument_list|)
name|public
label|:
name|explicit
name|QGLContextPrivate
parameter_list|(
name|QGLContext
modifier|*
name|context
parameter_list|)
function_decl|;
operator|~
name|QGLContextPrivate
argument_list|()
expr_stmt|;
name|QGLTexture
modifier|*
name|bindTexture
argument_list|(
specifier|const
name|QImage
operator|&
name|image
argument_list|,
name|GLenum
name|target
argument_list|,
name|GLint
name|format
argument_list|,
name|QGLContext
operator|::
name|BindOptions
name|options
argument_list|)
decl_stmt|;
name|QGLTexture
modifier|*
name|bindTexture
argument_list|(
specifier|const
name|QImage
operator|&
name|image
argument_list|,
name|GLenum
name|target
argument_list|,
name|GLint
name|format
argument_list|,
specifier|const
name|qint64
name|key
argument_list|,
name|QGLContext
operator|::
name|BindOptions
name|options
argument_list|)
decl_stmt|;
name|QGLTexture
modifier|*
name|bindTexture
argument_list|(
specifier|const
name|QPixmap
operator|&
name|pixmap
argument_list|,
name|GLenum
name|target
argument_list|,
name|GLint
name|format
argument_list|,
name|QGLContext
operator|::
name|BindOptions
name|options
argument_list|)
decl_stmt|;
name|QGLTexture
modifier|*
name|textureCacheLookup
parameter_list|(
specifier|const
name|qint64
name|key
parameter_list|,
name|GLenum
name|target
parameter_list|)
function_decl|;
name|void
name|init
parameter_list|(
name|QPaintDevice
modifier|*
name|dev
parameter_list|,
specifier|const
name|QGLFormat
modifier|&
name|format
parameter_list|)
function_decl|;
name|QImage
name|convertToGLFormat
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|bool
name|force_premul
parameter_list|,
name|GLenum
name|texture_format
parameter_list|)
function_decl|;
name|int
name|maxTextureSize
parameter_list|()
function_decl|;
name|void
name|cleanup
parameter_list|()
function_decl|;
name|void
name|setVertexAttribArrayEnabled
parameter_list|(
name|int
name|arrayIndex
parameter_list|,
name|bool
name|enabled
init|=
name|true
parameter_list|)
function_decl|;
name|void
name|syncGlState
parameter_list|()
function_decl|;
comment|// Makes sure the GL context's state is what we think it is
name|void
name|swapRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
name|void
name|updateFormatVersion
parameter_list|()
function_decl|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
name|HGLRC
name|rc
decl_stmt|;
name|HDC
name|dc
decl_stmt|;
name|WId
name|win
decl_stmt|;
name|int
name|pixelFormatId
decl_stmt|;
name|QGLCmap
modifier|*
name|cmap
decl_stmt|;
name|HBITMAP
name|hbitmap
decl_stmt|;
name|HDC
name|hbitmap_hdc
decl_stmt|;
name|Qt
operator|::
name|HANDLE
name|threadId
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_EGL
name|QEglContext
modifier|*
name|eglContext
decl_stmt|;
name|EGLSurface
name|eglSurface
decl_stmt|;
name|void
name|destroyEglSurfaceForDevice
parameter_list|()
function_decl|;
name|EGLSurface
name|eglSurfaceForDevice
argument_list|()
specifier|const
expr_stmt|;
specifier|static
name|QEglProperties
modifier|*
name|extraWindowSurfaceCreationProps
decl_stmt|;
specifier|static
name|void
name|setExtraWindowSurfaceCreationProps
parameter_list|(
name|QEglProperties
modifier|*
name|props
parameter_list|)
function_decl|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
name|QGuiGLContext
modifier|*
name|guiGlContext
decl_stmt|;
name|void
name|setupSharing
parameter_list|()
function_decl|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|void
modifier|*
name|cx
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|void
modifier|*
name|vi
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|void
modifier|*
name|pbuf
decl_stmt|;
name|quint32
name|gpm
decl_stmt|;
name|int
name|screen
decl_stmt|;
name|QHash
operator|<
name|QPlatformPixmap
operator|*
operator|,
name|QPixmap
operator|>
name|boundPixmaps
expr_stmt|;
name|QGLTexture
modifier|*
name|bindTextureFromNativePixmap
argument_list|(
name|QPixmap
operator|*
argument_list|,
specifier|const
name|qint64
name|key
argument_list|,
name|QGLContext
operator|::
name|BindOptions
name|options
argument_list|)
decl_stmt|;
specifier|static
name|void
name|destroyGlSurfaceForPixmap
parameter_list|(
name|QPlatformPixmap
modifier|*
parameter_list|)
function_decl|;
specifier|static
name|void
name|unbindPixmapFromTexture
parameter_list|(
name|QPlatformPixmap
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|bool
name|update
decl_stmt|;
name|void
modifier|*
name|tryFormat
parameter_list|(
specifier|const
name|QGLFormat
modifier|&
name|format
parameter_list|)
function_decl|;
name|void
name|clearDrawable
parameter_list|()
function_decl|;
endif|#
directive|endif
name|QGLFormat
name|glFormat
decl_stmt|;
name|QGLFormat
name|reqFormat
decl_stmt|;
name|GLuint
name|fbo
decl_stmt|;
name|uint
name|valid
range|:
literal|1
decl_stmt|;
name|uint
name|sharing
range|:
literal|1
decl_stmt|;
name|uint
name|initDone
range|:
literal|1
decl_stmt|;
name|uint
name|crWin
range|:
literal|1
decl_stmt|;
name|uint
name|internal_context
range|:
literal|1
decl_stmt|;
name|uint
name|version_flags_cached
range|:
literal|1
decl_stmt|;
name|uint
name|extension_flags_cached
range|:
literal|1
decl_stmt|;
comment|// workarounds for driver/hw bugs on different platforms
name|uint
name|workaround_needsFullClearOnEveryFrame
range|:
literal|1
decl_stmt|;
name|uint
name|workaround_brokenFBOReadBack
range|:
literal|1
decl_stmt|;
name|uint
name|workaround_brokenTexSubImage
range|:
literal|1
decl_stmt|;
name|uint
name|workaroundsCached
range|:
literal|1
decl_stmt|;
name|uint
name|workaround_brokenTextureFromPixmap
range|:
literal|1
decl_stmt|;
name|uint
name|workaround_brokenTextureFromPixmap_init
range|:
literal|1
decl_stmt|;
name|uint
name|workaround_brokenAlphaTexSubImage
range|:
literal|1
decl_stmt|;
name|uint
name|workaround_brokenAlphaTexSubImage_init
range|:
literal|1
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_EGL
name|uint
name|ownsEglContext
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
name|QPaintDevice
modifier|*
name|paintDevice
decl_stmt|;
name|QColor
name|transpColor
decl_stmt|;
name|QGLContext
modifier|*
name|q_ptr
decl_stmt|;
name|QGLFormat
operator|::
name|OpenGLVersionFlags
name|version_flags
expr_stmt|;
name|QGLExtensions
operator|::
name|Extensions
name|extension_flags
expr_stmt|;
name|QGLContextGroup
modifier|*
name|group
decl_stmt|;
name|GLint
name|max_texture_size
decl_stmt|;
name|GLuint
name|current_fbo
decl_stmt|;
name|GLuint
name|default_fbo
decl_stmt|;
name|QPaintEngine
modifier|*
name|active_engine
decl_stmt|;
name|QGLTextureDestroyer
modifier|*
name|texture_destroyer
decl_stmt|;
name|QGLFunctions
modifier|*
name|functions
decl_stmt|;
name|bool
name|vertexAttributeArraysEnabledState
index|[
name|QT_GL_VERTEX_ARRAY_TRACKED_COUNT
index|]
decl_stmt|;
specifier|static
specifier|inline
name|QGLContextGroup
modifier|*
name|contextGroup
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|ctx
operator|->
name|d_ptr
operator|->
name|group
return|;
block|}
ifdef|#
directive|ifdef
name|Q_WS_WIN
specifier|static
specifier|inline
name|QGLExtensionFuncs
modifier|&
name|extensionFuncs
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|ctx
operator|->
name|d_ptr
operator|->
name|group
operator|->
name|extensionFuncs
argument_list|()
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_QWS
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
specifier|static
name|Q_OPENGL_EXPORT
name|QGLExtensionFuncs
name|qt_extensionFuncs
decl_stmt|;
specifier|static
name|Q_OPENGL_EXPORT
name|QGLExtensionFuncs
modifier|&
name|extensionFuncs
parameter_list|(
specifier|const
name|QGLContext
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
specifier|static
name|void
name|setCurrentContext
parameter_list|(
name|QGLContext
modifier|*
name|context
parameter_list|)
function_decl|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_macro
name|Q_DECLARE_OPERATORS_FOR_FLAGS
argument_list|(
argument|QGLExtensions::Extensions
argument_list|)
end_macro
begin_comment
comment|// Temporarily make a context current if not already current or
end_comment
begin_comment
comment|// shared with the current contex.  The previous context is made
end_comment
begin_comment
comment|// current when the object goes out of scope.
end_comment
begin_decl_stmt
name|class
name|Q_OPENGL_EXPORT
name|QGLShareContextScope
block|{
name|public
label|:
name|QGLShareContextScope
argument_list|(
specifier|const
name|QGLContext
operator|*
name|ctx
argument_list|)
operator|:
name|m_oldContext
argument_list|(
literal|0
argument_list|)
block|{
name|QGLContext
operator|*
name|currentContext
operator|=
name|const_cast
operator|<
name|QGLContext
operator|*
operator|>
operator|(
name|QGLContext
operator|::
name|currentContext
argument_list|()
operator|)
block|;
if|if
condition|(
name|currentContext
operator|!=
name|ctx
operator|&&
operator|!
name|QGLContext
operator|::
name|areSharing
argument_list|(
name|ctx
argument_list|,
name|currentContext
argument_list|)
condition|)
block|{
name|m_oldContext
operator|=
name|currentContext
expr_stmt|;
name|m_ctx
operator|=
name|const_cast
operator|<
name|QGLContext
operator|*
operator|>
operator|(
name|ctx
operator|)
expr_stmt|;
name|m_ctx
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|m_ctx
operator|=
name|currentContext
expr_stmt|;
block|}
block|}
name|operator
name|QGLContext
operator|*
operator|(
operator|)
block|{
return|return
name|m_ctx
return|;
block|}
name|QGLContext
operator|*
name|operator
operator|->
expr|(
block|)
block|{
return|return
name|m_ctx
return|;
block|}
end_decl_stmt
begin_expr_stmt
operator|~
name|QGLShareContextScope
argument_list|()
block|{
if|if
condition|(
name|m_oldContext
condition|)
name|m_oldContext
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
block|}
end_expr_stmt
begin_label
name|private
label|:
end_label
begin_decl_stmt
name|QGLContext
modifier|*
name|m_oldContext
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|QGLContext
modifier|*
name|m_ctx
decl_stmt|;
end_decl_stmt
begin_decl_stmt
unit|};
name|class
name|Q_OPENGL_EXPORT
name|QGLTextureDestroyer
range|:
name|public
name|QObject
block|{
name|Q_OBJECT
name|public
operator|:
name|QGLTextureDestroyer
argument_list|()
operator|:
name|QObject
argument_list|()
block|{
name|qRegisterMetaType
operator|<
name|GLuint
operator|>
operator|(
literal|"GLuint"
operator|)
block|;
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|freeTexture
argument_list|(
name|QGLContext
operator|*
argument_list|,
name|QPlatformPixmap
operator|*
argument_list|,
name|GLuint
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|freeTexture_slot
argument_list|(
name|QGLContext
operator|*
argument_list|,
name|QPlatformPixmap
operator|*
argument_list|,
name|GLuint
argument_list|)
argument_list|)
argument_list|)
block|;     }
name|void
name|emitFreeTexture
argument_list|(
argument|QGLContext *context
argument_list|,
argument|QPlatformPixmap *boundPixmap
argument_list|,
argument|GLuint id
argument_list|)
block|{
name|emit
name|freeTexture
argument_list|(
name|context
argument_list|,
name|boundPixmap
argument_list|,
name|id
argument_list|)
block|;     }
name|Q_SIGNALS
operator|:
name|void
name|freeTexture
argument_list|(
argument|QGLContext *context
argument_list|,
argument|QPlatformPixmap *boundPixmap
argument_list|,
argument|GLuint id
argument_list|)
block|;
name|private
name|slots
operator|:
name|void
name|freeTexture_slot
argument_list|(
argument|QGLContext *context
argument_list|,
argument|QPlatformPixmap *boundPixmap
argument_list|,
argument|GLuint id
argument_list|)
block|{
name|Q_UNUSED
argument_list|(
name|boundPixmap
argument_list|)
block|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
if|if
condition|(
name|boundPixmap
condition|)
block|{
name|QGLContext
modifier|*
name|oldContext
init|=
name|const_cast
operator|<
name|QGLContext
operator|*
operator|>
operator|(
name|QGLContext
operator|::
name|currentContext
argument_list|()
operator|)
decl_stmt|;
name|context
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
comment|// Although glXReleaseTexImage is a glX call, it must be called while there
comment|// is a current context - the context the pixmap was bound to a texture in.
comment|// Otherwise the release doesn't do anything and you get BadDrawable errors
comment|// when you come to delete the context.
name|QGLContextPrivate
operator|::
name|unbindPixmapFromTexture
argument_list|(
name|boundPixmap
argument_list|)
expr_stmt|;
name|glDeleteTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldContext
condition|)
name|oldContext
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|QGLShareContextScope
name|scope
parameter_list|(
name|context
parameter_list|)
function_decl|;
name|glDeleteTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|id
argument_list|)
block|;     }
end_decl_stmt
begin_comment
unit|};
comment|// ### make QGLContext a QObject in 5.0 and remove the proxy stuff
end_comment
begin_decl_stmt
name|class
name|Q_OPENGL_EXPORT
name|QGLSignalProxy
range|:
name|public
name|QObject
block|{
name|Q_OBJECT
name|public
operator|:
name|void
name|emitAboutToDestroyContext
argument_list|(
argument|const QGLContext *context
argument_list|)
block|{
name|emit
name|aboutToDestroyContext
argument_list|(
name|context
argument_list|)
block|;     }
specifier|static
name|QGLSignalProxy
operator|*
name|instance
argument_list|()
block|;
name|Q_SIGNALS
operator|:
name|void
name|aboutToDestroyContext
argument_list|(
specifier|const
name|QGLContext
operator|*
name|context
argument_list|)
block|; }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|class
name|QGLTexture
block|{
name|public
label|:
name|QGLTexture
argument_list|(
argument|QGLContext *ctx =
literal|0
argument_list|,
argument|GLuint tx_id =
literal|0
argument_list|,
argument|GLenum tx_target = GL_TEXTURE_2D
argument_list|,
argument|QGLContext::BindOptions opt = QGLContext::DefaultBindOption
argument_list|)
block|:
name|context
argument_list|(
name|ctx
argument_list|)
operator|,
name|id
argument_list|(
name|tx_id
argument_list|)
operator|,
name|target
argument_list|(
name|tx_target
argument_list|)
operator|,
name|options
argument_list|(
name|opt
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|,
name|boundPixmap
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
block|{}
operator|~
name|QGLTexture
argument_list|()
block|{
if|if
condition|(
name|options
operator|&
name|QGLContext
operator|::
name|MemoryManagedBindOption
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|QPlatformPixmap
modifier|*
name|boundPixmap
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|context
operator|->
name|d_ptr
operator|->
name|texture_destroyer
operator|->
name|emitFreeTexture
argument_list|(
name|context
argument_list|,
name|boundPixmap
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
name|QGLContext
operator|*
name|context
expr_stmt|;
name|GLuint
name|id
decl_stmt|;
name|GLenum
name|target
decl_stmt|;
name|QGLContext
operator|::
name|BindOptions
name|options
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|QPlatformPixmap
modifier|*
name|boundPixmap
decl_stmt|;
endif|#
directive|endif
name|bool
name|canBindCompressedTexture
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|bool
modifier|*
name|hasAlpha
parameter_list|)
function_decl|;
name|QSize
name|bindCompressedTexture
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
init|=
literal|0
parameter_list|)
function_decl|;
name|QSize
name|bindCompressedTexture
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|format
init|=
literal|0
parameter_list|)
function_decl|;
name|QSize
name|bindCompressedTextureDDS
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|QSize
name|bindCompressedTexturePVR
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_struct
DECL|struct|QGLTextureCacheKey
struct|struct
name|QGLTextureCacheKey
block|{
DECL|member|key
name|qint64
name|key
decl_stmt|;
DECL|member|group
name|QGLContextGroup
modifier|*
name|group
decl_stmt|;
block|}
struct|;
end_struct
begin_expr_stmt
DECL|function|operator
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|QGLTextureCacheKey
operator|&
name|a
operator|,
specifier|const
name|QGLTextureCacheKey
operator|&
name|b
operator|)
block|{
return|return
name|a
operator|.
name|key
operator|==
name|b
operator|.
name|key
operator|&&
name|a
operator|.
name|group
operator|==
name|b
operator|.
name|group
return|;
block|}
end_expr_stmt
begin_function
DECL|function|qHash
specifier|inline
name|uint
name|qHash
parameter_list|(
specifier|const
name|QGLTextureCacheKey
modifier|&
name|key
parameter_list|)
block|{
return|return
name|qHash
argument_list|(
name|key
operator|.
name|key
argument_list|)
operator|^
name|qHash
argument_list|(
name|key
operator|.
name|group
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
name|class
name|Q_AUTOTEST_EXPORT
name|QGLTextureCache
block|{
name|public
label|:
name|QGLTextureCache
argument_list|()
expr_stmt|;
operator|~
name|QGLTextureCache
argument_list|()
expr_stmt|;
name|void
name|insert
parameter_list|(
name|QGLContext
modifier|*
name|ctx
parameter_list|,
name|qint64
name|key
parameter_list|,
name|QGLTexture
modifier|*
name|texture
parameter_list|,
name|int
name|cost
parameter_list|)
function_decl|;
name|void
name|remove
parameter_list|(
name|qint64
name|key
parameter_list|)
function_decl|;
specifier|inline
name|int
name|size
parameter_list|()
function_decl|;
specifier|inline
name|void
name|setMaxCost
parameter_list|(
name|int
name|newMax
parameter_list|)
function_decl|;
specifier|inline
name|int
name|maxCost
parameter_list|()
function_decl|;
specifier|inline
name|QGLTexture
modifier|*
name|getTexture
parameter_list|(
name|QGLContext
modifier|*
name|ctx
parameter_list|,
name|qint64
name|key
parameter_list|)
function_decl|;
name|bool
name|remove
parameter_list|(
name|QGLContext
modifier|*
name|ctx
parameter_list|,
name|GLuint
name|textureId
parameter_list|)
function_decl|;
name|void
name|removeContextTextures
parameter_list|(
name|QGLContext
modifier|*
name|ctx
parameter_list|)
function_decl|;
specifier|static
name|QGLTextureCache
modifier|*
name|instance
parameter_list|()
function_decl|;
specifier|static
name|void
name|cleanupTexturesForCacheKey
parameter_list|(
name|qint64
name|cacheKey
parameter_list|)
function_decl|;
specifier|static
name|void
name|cleanupTexturesForPixampData
parameter_list|(
name|QPlatformPixmap
modifier|*
name|pixmap
parameter_list|)
function_decl|;
specifier|static
name|void
name|cleanupBeforePixmapDestruction
parameter_list|(
name|QPlatformPixmap
modifier|*
name|pixmap
parameter_list|)
function_decl|;
name|private
label|:
name|QCache
operator|<
name|QGLTextureCacheKey
operator|,
name|QGLTexture
operator|>
name|m_cache
expr_stmt|;
name|QReadWriteLock
name|m_lock
decl_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
DECL|function|size
name|int
name|QGLTextureCache
operator|::
name|size
argument_list|()
block|{
name|QReadLocker
name|locker
argument_list|(
operator|&
name|m_lock
argument_list|)
block|;
return|return
name|m_cache
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|setMaxCost
name|void
name|QGLTextureCache
operator|::
name|setMaxCost
argument_list|(
argument|int newMax
argument_list|)
block|{
name|QWriteLocker
name|locker
argument_list|(
operator|&
name|m_lock
argument_list|)
block|;
name|m_cache
operator|.
name|setMaxCost
argument_list|(
name|newMax
argument_list|)
block|; }
DECL|function|maxCost
name|int
name|QGLTextureCache
operator|::
name|maxCost
argument_list|()
block|{
name|QReadLocker
name|locker
argument_list|(
operator|&
name|m_lock
argument_list|)
block|;
return|return
name|m_cache
operator|.
name|maxCost
argument_list|()
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|getTexture
name|QGLTexture
operator|*
name|QGLTextureCache
operator|::
name|getTexture
argument_list|(
argument|QGLContext *ctx
argument_list|,
argument|qint64 key
argument_list|)
block|{
name|QReadLocker
name|locker
argument_list|(
operator|&
name|m_lock
argument_list|)
block|;
specifier|const
name|QGLTextureCacheKey
name|cacheKey
operator|=
block|{
name|key
block|,
name|QGLContextPrivate
operator|::
name|contextGroup
argument_list|(
argument|ctx
argument_list|)
block|}
block|;
return|return
name|m_cache
operator|.
name|object
argument_list|(
name|cacheKey
argument_list|)
return|;
block|}
end_expr_stmt
begin_function_decl
specifier|extern
name|Q_OPENGL_EXPORT
name|QPaintEngine
modifier|*
name|qt_qgl_paint_engine
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
name|bool
name|qt_gl_preferGL2Engine
parameter_list|()
function_decl|;
end_function_decl
begin_function
DECL|function|qt_gl_preferredTextureFormat
specifier|inline
name|GLenum
name|qt_gl_preferredTextureFormat
parameter_list|()
block|{
return|return
operator|(
name|QGLExtensions
operator|::
name|glExtensions
argument_list|()
operator|&
name|QGLExtensions
operator|::
name|BGRATextureFormat
operator|)
operator|&&
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|LittleEndian
condition|?
name|GL_BGRA
else|:
name|GL_RGBA
return|;
block|}
end_function
begin_function
DECL|function|qt_gl_preferredTextureTarget
specifier|inline
name|GLenum
name|qt_gl_preferredTextureTarget
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
return|return
name|GL_TEXTURE_2D
return|;
else|#
directive|else
return|return
operator|(
name|QGLExtensions
operator|::
name|glExtensions
argument_list|()
operator|&
name|QGLExtensions
operator|::
name|TextureRectangle
operator|)
operator|&&
operator|!
name|qt_gl_preferGL2Engine
argument_list|()
condition|?
name|GL_TEXTURE_RECTANGLE_NV
else|:
name|GL_TEXTURE_2D
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*    Base for resources that are shared in a context group. */
end_comment
begin_decl_stmt
name|class
name|Q_OPENGL_EXPORT
name|QGLContextGroupResourceBase
block|{
name|public
label|:
name|QGLContextGroupResourceBase
argument_list|()
expr_stmt|;
name|virtual
operator|~
name|QGLContextGroupResourceBase
argument_list|()
expr_stmt|;
name|void
name|insert
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|context
parameter_list|,
name|void
modifier|*
name|value
parameter_list|)
function_decl|;
name|void
modifier|*
name|value
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|context
parameter_list|)
function_decl|;
name|void
name|cleanup
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|context
parameter_list|)
function_decl|;
name|void
name|cleanup
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|context
parameter_list|,
name|void
modifier|*
name|value
parameter_list|)
function_decl|;
name|virtual
name|void
name|freeResource
parameter_list|(
name|void
modifier|*
name|value
parameter_list|)
init|=
literal|0
function_decl|;
name|protected
label|:
name|QList
operator|<
name|QGLContextGroup
operator|*
operator|>
name|m_groups
expr_stmt|;
name|private
label|:
name|QAtomicInt
name|active
decl_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|/*    The QGLContextGroupResource template is used to manage a resource    for a group of sharing GL contexts. When the last context in the    group is destroyed, or when the QGLContextGroupResource object    itself is destroyed (implies potential context switches), the    resource will be freed.     The class used as the template class type needs to have a    constructor with the following signature:      T(const QGLContext *); */
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|class
name|QGLContextGroupResource
operator|:
name|public
name|QGLContextGroupResourceBase
block|{
name|public
operator|:
operator|~
name|QGLContextGroupResource
argument_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_groups
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QGLContext
modifier|*
name|context
init|=
name|m_groups
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|context
argument_list|()
decl_stmt|;
name|T
modifier|*
name|resource
init|=
name|reinterpret_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|QGLContextGroupResourceBase
operator|::
name|value
argument_list|(
name|context
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|resource
condition|)
block|{
name|QGLShareContextScope
name|scope
parameter_list|(
name|context
parameter_list|)
function_decl|;
name|delete
name|resource
decl_stmt|;
block|}
block|}
end_expr_stmt
begin_expr_stmt
unit|}      T
operator|*
name|value
argument_list|(
argument|const QGLContext *context
argument_list|)
block|{
name|T
operator|*
name|resource
operator|=
name|reinterpret_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|QGLContextGroupResourceBase
operator|::
name|value
argument_list|(
name|context
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|resource
condition|)
block|{
name|resource
operator|=
name|new
name|T
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|context
argument_list|,
name|resource
argument_list|)
expr_stmt|;
block|}
end_expr_stmt
begin_return
return|return
name|resource
return|;
end_return
begin_function
unit|}  protected:
name|void
name|freeResource
parameter_list|(
name|void
modifier|*
name|resource
parameter_list|)
block|{
name|delete
name|reinterpret_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|resource
operator|)
expr_stmt|;
block|}
end_function
begin_comment
unit|};
comment|// Put a guard around a GL object identifier and its context.
end_comment
begin_comment
comment|// When the context goes away, a shared context will be used
end_comment
begin_comment
comment|// in its place.  If there are no more shared contexts, then
end_comment
begin_comment
comment|// the identifier is returned as zero - it is assumed that the
end_comment
begin_comment
comment|// context destruction cleaned up the identifier in this case.
end_comment
begin_decl_stmt
name|class
name|Q_OPENGL_EXPORT
name|QGLSharedResourceGuard
block|{
name|public
label|:
name|QGLSharedResourceGuard
argument_list|(
specifier|const
name|QGLContext
operator|*
name|context
argument_list|)
operator|:
name|m_group
argument_list|(
literal|0
argument_list|)
operator|,
name|m_id
argument_list|(
literal|0
argument_list|)
operator|,
name|m_next
argument_list|(
literal|0
argument_list|)
operator|,
name|m_prev
argument_list|(
literal|0
argument_list|)
block|{
name|setContext
argument_list|(
name|context
argument_list|)
block|;     }
name|QGLSharedResourceGuard
argument_list|(
argument|const QGLContext *context
argument_list|,
argument|GLuint id
argument_list|)
operator|:
name|m_group
argument_list|(
literal|0
argument_list|)
operator|,
name|m_id
argument_list|(
name|id
argument_list|)
operator|,
name|m_next
argument_list|(
literal|0
argument_list|)
operator|,
name|m_prev
argument_list|(
literal|0
argument_list|)
block|{
name|setContext
argument_list|(
name|context
argument_list|)
block|;     }
operator|~
name|QGLSharedResourceGuard
argument_list|()
expr_stmt|;
specifier|const
name|QGLContext
operator|*
name|context
argument_list|()
specifier|const
block|{
return|return
name|m_group
operator|?
name|m_group
operator|->
name|context
argument_list|()
operator|:
literal|0
return|;
block|}
name|void
name|setContext
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|context
parameter_list|)
function_decl|;
name|GLuint
name|id
argument_list|()
specifier|const
block|{
return|return
name|m_id
return|;
block|}
name|void
name|setId
parameter_list|(
name|GLuint
name|id
parameter_list|)
block|{
name|m_id
operator|=
name|id
expr_stmt|;
block|}
name|private
label|:
name|QGLContextGroup
modifier|*
name|m_group
decl_stmt|;
name|GLuint
name|m_id
decl_stmt|;
name|QGLSharedResourceGuard
modifier|*
name|m_next
decl_stmt|;
name|QGLSharedResourceGuard
modifier|*
name|m_prev
decl_stmt|;
name|friend
name|class
name|QGLContextGroup
decl_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_decl_stmt
name|class
name|QGLExtensionMatcher
block|{
name|public
label|:
name|QGLExtensionMatcher
argument_list|(
specifier|const
name|char
operator|*
name|str
argument_list|)
expr_stmt|;
name|QGLExtensionMatcher
argument_list|()
expr_stmt|;
name|bool
name|match
argument_list|(
specifier|const
name|char
operator|*
name|str
argument_list|)
decl|const
block|{
name|int
name|str_length
init|=
name|qstrlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|str_length
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|str
index|[
name|str_length
operator|-
literal|1
index|]
operator|!=
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_offsets
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|extension
init|=
name|m_extensions
operator|.
name|constData
argument_list|()
operator|+
name|m_offsets
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|qstrncmp
argument_list|(
name|extension
argument_list|,
name|str
argument_list|,
name|str_length
argument_list|)
operator|==
literal|0
operator|&&
name|extension
index|[
name|str_length
index|]
operator|==
literal|' '
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|private
label|:
name|void
name|init
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
name|QByteArray
name|m_extensions
decl_stmt|;
name|QVector
operator|<
name|int
operator|>
name|m_offsets
expr_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|// this is a class that wraps a QThreadStorage object for storing
end_comment
begin_comment
comment|// thread local instances of the GL 1 and GL 2 paint engines
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|class
name|QGLEngineThreadStorage
block|{
name|public
operator|:
name|QPaintEngine
operator|*
name|engine
argument_list|()
block|{
name|QPaintEngine
operator|*
operator|&
name|localEngine
operator|=
name|storage
operator|.
name|localData
argument_list|()
block|;
if|if
condition|(
operator|!
name|localEngine
condition|)
name|localEngine
operator|=
name|new
name|T
expr_stmt|;
return|return
name|localEngine
return|;
block|}
end_expr_stmt
begin_label
name|private
label|:
end_label
begin_expr_stmt
name|QThreadStorage
operator|<
name|QPaintEngine
operator|*
operator|>
name|storage
expr_stmt|;
end_expr_stmt
begin_macro
unit|};
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QGL_P_H
end_comment
end_unit
