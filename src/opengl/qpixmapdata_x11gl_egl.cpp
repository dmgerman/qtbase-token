begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtOpenGL module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qt_x11_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qegl_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qeglproperties_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qeglcontext_p.h>
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_1
argument_list|)
end_if
begin_include
include|#
directive|include
file|<QtOpenGL/private/qpaintengineex_opengl2_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
end_ifndef
begin_include
include|#
directive|include
file|<QtOpenGL/private/qpaintengine_opengl_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<QtOpenGL/private/qgl_p.h>
end_include
begin_include
include|#
directive|include
file|<QtOpenGL/private/qgl_egl_p.h>
end_include
begin_include
include|#
directive|include
file|"qpixmapdata_x11gl_p.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QX11GLSharedContexts
class|class
name|QX11GLSharedContexts
block|{
public|public:
DECL|function|QX11GLSharedContexts
name|QX11GLSharedContexts
parameter_list|()
member_init_list|:
name|rgbContext
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|argbContext
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|sharedQGLContext
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|sharePixmap
argument_list|(
literal|0
argument_list|)
block|{
name|EGLint
name|rgbConfigId
decl_stmt|;
name|EGLint
name|argbConfigId
decl_stmt|;
do|do
block|{
name|EGLConfig
name|rgbConfig
init|=
name|QEgl
operator|::
name|defaultConfig
argument_list|(
name|QInternal
operator|::
name|Pixmap
argument_list|,
name|QEgl
operator|::
name|OpenGL
argument_list|,
name|QEgl
operator|::
name|Renderable
argument_list|)
decl_stmt|;
name|EGLConfig
name|argbConfig
init|=
name|QEgl
operator|::
name|defaultConfig
argument_list|(
name|QInternal
operator|::
name|Pixmap
argument_list|,
name|QEgl
operator|::
name|OpenGL
argument_list|,
name|QEgl
operator|::
name|Renderable
operator||
name|QEgl
operator|::
name|Translucent
argument_list|)
decl_stmt|;
name|eglGetConfigAttrib
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|rgbConfig
argument_list|,
name|EGL_CONFIG_ID
argument_list|,
operator|&
name|rgbConfigId
argument_list|)
expr_stmt|;
name|eglGetConfigAttrib
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|argbConfig
argument_list|,
name|EGL_CONFIG_ID
argument_list|,
operator|&
name|argbConfigId
argument_list|)
expr_stmt|;
name|rgbContext
operator|=
operator|new
name|QEglContext
expr_stmt|;
name|rgbContext
operator|->
name|setConfig
argument_list|(
name|rgbConfig
argument_list|)
expr_stmt|;
name|rgbContext
operator|->
name|createContext
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rgbContext
operator|->
name|isValid
argument_list|()
condition|)
break|break;
comment|// If the RGB& ARGB configs are the same, use the same egl context for both:
if|if
condition|(
name|rgbConfig
operator|==
name|argbConfig
condition|)
name|argbContext
operator|=
name|rgbContext
expr_stmt|;
comment|// Otherwise, create a separate context to be used for ARGB pixmaps:
if|if
condition|(
operator|!
name|argbContext
condition|)
block|{
name|argbContext
operator|=
operator|new
name|QEglContext
expr_stmt|;
name|argbContext
operator|->
name|setConfig
argument_list|(
name|argbConfig
argument_list|)
expr_stmt|;
name|bool
name|success
init|=
name|argbContext
operator|->
name|createContext
argument_list|(
name|rgbContext
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|qWarning
argument_list|(
literal|"QX11GLPixmapData - RGB& ARGB contexts aren't shared"
argument_list|)
expr_stmt|;
name|success
operator|=
name|argbContext
operator|->
name|createContext
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
name|argbContext
operator|=
name|rgbContext
expr_stmt|;
comment|// Might work, worth a shot at least.
block|}
block|}
if|if
condition|(
operator|!
name|argbContext
operator|->
name|isValid
argument_list|()
condition|)
break|break;
comment|// Create the pixmap which will be used to create the egl surface for the share QGLContext
name|QX11PixmapData
modifier|*
name|rgbPixmapData
init|=
operator|new
name|QX11PixmapData
argument_list|(
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
decl_stmt|;
name|rgbPixmapData
operator|->
name|resize
argument_list|(
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|rgbPixmapData
operator|->
name|fill
argument_list|(
name|Qt
operator|::
name|red
argument_list|)
expr_stmt|;
name|sharePixmap
operator|=
operator|new
name|QPixmap
argument_list|(
name|rgbPixmapData
argument_list|)
expr_stmt|;
name|EGLSurface
name|sharePixmapSurface
init|=
name|QEgl
operator|::
name|createSurface
argument_list|(
name|sharePixmap
argument_list|,
name|rgbConfig
argument_list|)
decl_stmt|;
name|rgbPixmapData
operator|->
name|gl_surface
operator|=
operator|(
name|void
operator|*
operator|)
name|sharePixmapSurface
expr_stmt|;
comment|// Create the actual QGLContext which will be used for sharing
name|sharedQGLContext
operator|=
operator|new
name|QGLContext
argument_list|(
name|QX11GLPixmapData
operator|::
name|glFormat
argument_list|()
argument_list|)
expr_stmt|;
name|sharedQGLContext
operator|->
name|d_func
argument_list|()
operator|->
name|eglContext
operator|=
name|rgbContext
expr_stmt|;
name|sharedQGLContext
operator|->
name|d_func
argument_list|()
operator|->
name|eglSurface
operator|=
name|sharePixmapSurface
expr_stmt|;
name|sharedQGLContext
operator|->
name|d_func
argument_list|()
operator|->
name|valid
operator|=
literal|true
expr_stmt|;
name|qt_glformat_from_eglconfig
argument_list|(
name|sharedQGLContext
operator|->
name|d_func
argument_list|()
operator|->
name|glFormat
argument_list|,
name|rgbConfig
argument_list|)
expr_stmt|;
name|valid
operator|=
name|rgbContext
operator|->
name|makeCurrent
argument_list|(
name|sharePixmapSurface
argument_list|)
expr_stmt|;
comment|// If the ARGB& RGB configs are different, check ARGB works too:
if|if
condition|(
name|argbConfig
operator|!=
name|rgbConfig
condition|)
block|{
name|QX11PixmapData
modifier|*
name|argbPixmapData
init|=
operator|new
name|QX11PixmapData
argument_list|(
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
decl_stmt|;
name|argbPixmapData
operator|->
name|resize
argument_list|(
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|argbPixmapData
operator|->
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
comment|// Force ARGB
name|QPixmap
name|argbPixmap
argument_list|(
name|argbPixmapData
argument_list|)
decl_stmt|;
comment|// destroys pixmap data when goes out of scope
name|EGLSurface
name|argbPixmapSurface
init|=
name|QEgl
operator|::
name|createSurface
argument_list|(
operator|&
name|argbPixmap
argument_list|,
name|argbConfig
argument_list|)
decl_stmt|;
name|valid
operator|=
name|argbContext
operator|->
name|makeCurrent
argument_list|(
name|argbPixmapSurface
argument_list|)
expr_stmt|;
name|argbContext
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
name|eglDestroySurface
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|argbPixmapSurface
argument_list|)
expr_stmt|;
name|argbPixmapData
operator|->
name|gl_surface
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Unable to make pixmap surface current:"
operator|<<
name|QEgl
operator|::
name|errorString
argument_list|()
expr_stmt|;
break|break;
block|}
comment|// The pixmap surface destruction hooks are installed by QGLTextureCache, so we
comment|// must make sure this is instanciated:
name|QGLTextureCache
operator|::
name|instance
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
operator|!
name|valid
condition|)
name|cleanup
argument_list|()
expr_stmt|;
else|else
name|qDebug
argument_list|(
literal|"Using QX11GLPixmapData with EGL config %d for ARGB and config %d for RGB"
argument_list|,
name|argbConfigId
argument_list|,
name|rgbConfigId
argument_list|)
expr_stmt|;
block|}
DECL|function|~QX11GLSharedContexts
name|~
name|QX11GLSharedContexts
parameter_list|()
block|{
name|cleanup
argument_list|()
expr_stmt|;
block|}
DECL|function|cleanup
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|sharedQGLContext
condition|)
block|{
operator|delete
name|sharedQGLContext
expr_stmt|;
name|sharedQGLContext
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|argbContext
operator|&&
name|argbContext
operator|!=
name|rgbContext
condition|)
operator|delete
name|argbContext
expr_stmt|;
name|argbContext
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rgbContext
condition|)
block|{
operator|delete
name|rgbContext
expr_stmt|;
name|rgbContext
operator|=
literal|0
expr_stmt|;
block|}
comment|// Deleting the QPixmap will fire the pixmap destruction cleanup hooks which in turn
comment|// will destroy the egl surface:
if|if
condition|(
name|sharePixmap
condition|)
block|{
operator|delete
name|sharePixmap
expr_stmt|;
name|sharePixmap
operator|=
literal|0
expr_stmt|;
block|}
block|}
DECL|function|isValid
name|bool
name|isValid
parameter_list|()
block|{
return|return
name|valid
return|;
block|}
comment|// On 16bpp systems, RGB& ARGB pixmaps are different bit-depths and therefore need
comment|// different contexts:
DECL|member|rgbContext
name|QEglContext
modifier|*
name|rgbContext
decl_stmt|;
DECL|member|argbContext
name|QEglContext
modifier|*
name|argbContext
decl_stmt|;
comment|// The share context wraps the rgbContext and is used as the master of the context share
comment|// group. As all other contexts will have the same egl context (or a shared one if rgb != argb)
comment|// all QGLContexts will actually be sharing and can be in the same context group.
DECL|member|sharedQGLContext
name|QGLContext
modifier|*
name|sharedQGLContext
decl_stmt|;
private|private:
DECL|member|sharePixmap
name|QPixmap
modifier|*
name|sharePixmap
decl_stmt|;
DECL|member|valid
name|bool
name|valid
decl_stmt|;
block|}
class|;
end_class
begin_function_decl
specifier|static
name|void
name|qt_cleanup_x11gl_share_contexts
parameter_list|()
function_decl|;
end_function_decl
begin_macro
name|Q_GLOBAL_STATIC_WITH_INITIALIZER
argument_list|(
argument|QX11GLSharedContexts
argument_list|,
argument|qt_x11gl_share_contexts
argument_list|,
argument|{                                      qAddPostRoutine(qt_cleanup_x11gl_share_contexts);                                  }
argument_list|)
end_macro
begin_function
DECL|function|qt_cleanup_x11gl_share_contexts
specifier|static
name|void
name|qt_cleanup_x11gl_share_contexts
parameter_list|()
block|{
name|qt_x11gl_share_contexts
argument_list|()
operator|->
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sharedContexts
name|QX11GLSharedContexts
modifier|*
name|QX11GLPixmapData
operator|::
name|sharedContexts
parameter_list|()
block|{
return|return
name|qt_x11gl_share_contexts
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|hasX11GLPixmaps
name|bool
name|QX11GLPixmapData
operator|::
name|hasX11GLPixmaps
parameter_list|()
block|{
specifier|static
name|bool
name|checkedForX11GLPixmaps
init|=
literal|false
decl_stmt|;
specifier|static
name|bool
name|haveX11GLPixmaps
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|checkedForX11GLPixmaps
condition|)
return|return
name|haveX11GLPixmaps
return|;
name|haveX11GLPixmaps
operator|=
name|qt_x11gl_share_contexts
argument_list|()
operator|->
name|isValid
argument_list|()
expr_stmt|;
name|checkedForX11GLPixmaps
operator|=
literal|true
expr_stmt|;
return|return
name|haveX11GLPixmaps
return|;
block|}
end_function
begin_constructor
DECL|function|QX11GLPixmapData
name|QX11GLPixmapData
operator|::
name|QX11GLPixmapData
parameter_list|()
member_init_list|:
name|QX11PixmapData
argument_list|(
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
member_init_list|,
name|ctx
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QX11GLPixmapData
name|QX11GLPixmapData
operator|::
name|~
name|QX11GLPixmapData
parameter_list|()
block|{
if|if
condition|(
name|ctx
condition|)
operator|delete
name|ctx
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|fill
name|void
name|QX11GLPixmapData
operator|::
name|fill
parameter_list|(
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
if|if
condition|(
name|ctx
condition|)
block|{
name|ctx
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
name|glFinish
argument_list|()
expr_stmt|;
name|eglWaitClient
argument_list|()
expr_stmt|;
block|}
name|QX11PixmapData
operator|::
name|fill
argument_list|(
name|color
argument_list|)
expr_stmt|;
name|XSync
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|False
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
name|ctx
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
name|eglWaitNative
argument_list|(
name|EGL_CORE_NATIVE_ENGINE
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|copy
name|void
name|QX11GLPixmapData
operator|::
name|copy
parameter_list|(
specifier|const
name|QPixmapData
modifier|*
name|data
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
if|if
condition|(
name|ctx
condition|)
block|{
name|ctx
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
name|glFinish
argument_list|()
expr_stmt|;
name|eglWaitClient
argument_list|()
expr_stmt|;
block|}
name|QX11PixmapData
operator|::
name|copy
argument_list|(
name|data
argument_list|,
name|rect
argument_list|)
expr_stmt|;
name|XSync
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|False
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
name|ctx
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
name|eglWaitNative
argument_list|(
name|EGL_CORE_NATIVE_ENGINE
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|scroll
name|bool
name|QX11GLPixmapData
operator|::
name|scroll
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
if|if
condition|(
name|ctx
condition|)
block|{
name|ctx
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
name|glFinish
argument_list|()
expr_stmt|;
name|eglWaitClient
argument_list|()
expr_stmt|;
block|}
name|bool
name|success
init|=
name|QX11PixmapData
operator|::
name|scroll
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|rect
argument_list|)
decl_stmt|;
name|XSync
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|False
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
name|ctx
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
name|eglWaitNative
argument_list|(
name|EGL_CORE_NATIVE_ENGINE
argument_list|)
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_1
argument_list|)
end_if
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QGL2PaintEngineEx
argument_list|,
argument|qt_gl_pixmap_2_engine
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
end_ifndef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QOpenGLPaintEngine
argument_list|,
argument|qt_gl_pixmap_engine
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QX11GLPixmapData
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
comment|// We need to create the context before beginPaint - do it here:
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|ctx
operator|=
operator|new
name|QGLContext
argument_list|(
name|glFormat
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|eglContext
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|eglContext
operator|=
name|hasAlphaChannel
argument_list|()
condition|?
name|sharedContexts
argument_list|()
operator|->
name|argbContext
else|:
name|sharedContexts
argument_list|()
operator|->
name|rgbContext
expr_stmt|;
comment|// While we use a separate QGLContext for each pixmap, the underlying QEglContext is
comment|// the same. So we must use a "fake" QGLContext and fool the texture cache into thinking
comment|// each pixmap's QGLContext is sharing with this central one. The only place this is
comment|// going to fail is where we the underlying EGL RGB and ARGB contexts aren't sharing.
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|sharing
operator|=
literal|true
expr_stmt|;
name|QGLContextGroup
operator|::
name|addShare
argument_list|(
name|ctx
argument_list|,
name|sharedContexts
argument_list|()
operator|->
name|sharedQGLContext
argument_list|)
expr_stmt|;
comment|// Update the glFormat for the QGLContext:
name|qt_glformat_from_eglconfig
argument_list|(
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|glFormat
argument_list|,
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|eglContext
operator|->
name|config
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QPaintEngine
modifier|*
name|engine
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_ES_1
argument_list|)
name|engine
operator|=
name|qt_gl_pixmap_engine
argument_list|()
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
name|engine
operator|=
name|qt_gl_pixmap_2_engine
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|qt_gl_preferGL2Engine
argument_list|()
condition|)
name|engine
operator|=
name|qt_gl_pixmap_2_engine
argument_list|()
expr_stmt|;
else|else
name|engine
operator|=
name|qt_gl_pixmap_engine
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Support multiple painters on multiple pixmaps simultaniously
if|if
condition|(
name|engine
operator|->
name|isActive
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Pixmap paint engine already active"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_ES_1
argument_list|)
name|engine
operator|=
operator|new
name|QOpenGLPaintEngine
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
name|engine
operator|=
operator|new
name|QGL2PaintEngineEx
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|qt_gl_preferGL2Engine
argument_list|()
condition|)
name|engine
operator|=
operator|new
name|QGL2PaintEngineEx
expr_stmt|;
else|else
name|engine
operator|=
operator|new
name|QOpenGLPaintEngine
expr_stmt|;
endif|#
directive|endif
name|engine
operator|->
name|setAutoDestruct
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|engine
return|;
block|}
return|return
name|engine
return|;
block|}
end_function
begin_function
DECL|function|beginPaint
name|void
name|QX11GLPixmapData
operator|::
name|beginPaint
parameter_list|()
block|{
comment|//    qDebug("QX11GLPixmapData::beginPaint()");
comment|// TODO: Check to see if the surface is renderable
if|if
condition|(
operator|(
name|EGLSurface
operator|)
name|gl_surface
operator|==
name|EGL_NO_SURFACE
condition|)
block|{
name|QPixmap
name|tmpPixmap
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|EGLConfig
name|cfg
init|=
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|eglContext
operator|->
name|config
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|cfg
operator|!=
name|QEGL_NO_CONFIG
argument_list|)
expr_stmt|;
comment|//        qDebug("QX11GLPixmapData - using EGL Config ID %d", ctx->d_func()->eglContext->configAttrib(EGL_CONFIG_ID));
name|EGLSurface
name|surface
init|=
name|QEgl
operator|::
name|createSurface
argument_list|(
operator|&
name|tmpPixmap
argument_list|,
name|cfg
argument_list|)
decl_stmt|;
if|if
condition|(
name|surface
operator|==
name|EGL_NO_SURFACE
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Error creating EGL surface for pixmap:"
operator|<<
name|QEgl
operator|::
name|errorString
argument_list|()
expr_stmt|;
return|return;
block|}
name|gl_surface
operator|=
operator|(
name|void
operator|*
operator|)
name|surface
expr_stmt|;
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|eglSurface
operator|=
name|surface
expr_stmt|;
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|valid
operator|=
literal|true
expr_stmt|;
block|}
name|QGLPaintDevice
operator|::
name|beginPaint
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|context
name|QGLContext
modifier|*
name|QX11GLPixmapData
operator|::
name|context
parameter_list|()
specifier|const
block|{
return|return
name|ctx
return|;
block|}
end_function
begin_function
DECL|function|size
name|QSize
name|QX11GLPixmapData
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
name|QSize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|glFormat
name|QGLFormat
name|QX11GLPixmapData
operator|::
name|glFormat
parameter_list|()
block|{
return|return
name|QGLFormat
operator|::
name|defaultFormat
argument_list|()
return|;
comment|//###
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
