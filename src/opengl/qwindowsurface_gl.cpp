begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtOpenGL module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtWidgets/QApplication>
end_include
begin_include
include|#
directive|include
file|<QtGui/QColormap>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/QDesktopWidget>
end_include
begin_include
include|#
directive|include
file|<QtGui/QPaintDevice>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/QWidget>
end_include
begin_include
include|#
directive|include
file|<qglframebufferobject.h>
end_include
begin_include
include|#
directive|include
file|<qglpixelbuffer.h>
end_include
begin_include
include|#
directive|include
file|<qcolormap.h>
end_include
begin_include
include|#
directive|include
file|<qdesktopwidget.h>
end_include
begin_include
include|#
directive|include
file|<private/qwidget_p.h>
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_X11
end_ifdef
begin_include
include|#
directive|include
file|<private/qt_x11_p.h>
end_include
begin_include
include|#
directive|include
file|<qx11info_x11.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_OPENGL_ES
end_ifndef
begin_include
include|#
directive|include
file|<GL/glx.h>
end_include
begin_include
include|#
directive|include
file|<X11/Xlib.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//Q_WS_X11
end_comment
begin_include
include|#
directive|include
file|<private/qglextensions_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qwindowsurface_gl_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qgl_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qglpixelbuffer_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpaintengineex_opengl2_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpixmapdata_gl_p.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
end_ifndef
begin_include
include|#
directive|include
file|<private/qpaintengine_opengl_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|GLX_ARB_multisample
end_ifndef
begin_define
DECL|macro|GLX_SAMPLE_BUFFERS_ARB
define|#
directive|define
name|GLX_SAMPLE_BUFFERS_ARB
value|100000
end_define
begin_define
DECL|macro|GLX_SAMPLES_ARB
define|#
directive|define
name|GLX_SAMPLES_ARB
value|100001
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_EGL
end_ifndef
begin_include
include|#
directive|include
file|<private/qeglcontext_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_QPA
end_ifdef
begin_include
include|#
directive|include
file|<qplatformscreen_qpa.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|//
end_comment
begin_comment
comment|// QGLWindowSurface
end_comment
begin_comment
comment|//
end_comment
begin_class
DECL|class|QGLGlobalShareWidget
class|class
name|QGLGlobalShareWidget
block|{
public|public:
DECL|function|QGLGlobalShareWidget
name|QGLGlobalShareWidget
parameter_list|()
member_init_list|:
name|firstPixmap
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|widgetRefCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|widget
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|initializing
argument_list|(
literal|false
argument_list|)
block|{
name|created
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|shareWidget
name|QGLWidget
modifier|*
name|shareWidget
parameter_list|()
block|{
if|if
condition|(
operator|!
name|initializing
operator|&&
operator|!
name|widget
operator|&&
operator|!
name|cleanedUp
condition|)
block|{
name|initializing
operator|=
literal|true
expr_stmt|;
name|widget
operator|=
operator|new
name|QGLWidget
argument_list|(
name|QGLFormat
argument_list|(
name|QGL
operator|::
name|SingleBuffer
operator||
name|QGL
operator|::
name|NoDepthBuffer
operator||
name|QGL
operator|::
name|NoStencilBuffer
argument_list|)
argument_list|)
expr_stmt|;
name|widget
operator|->
name|resize
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// We don't need this internal widget to appear in QApplication::topLevelWidgets()
if|if
condition|(
name|QWidgetPrivate
operator|::
name|allWidgets
condition|)
name|QWidgetPrivate
operator|::
name|allWidgets
operator|->
name|remove
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|initializing
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|widget
return|;
block|}
comment|// destroys the share widget and prevents recreation
DECL|function|cleanup
name|void
name|cleanup
parameter_list|()
block|{
name|QGLWidget
modifier|*
name|w
init|=
name|widget
decl_stmt|;
name|cleanedUp
operator|=
literal|true
expr_stmt|;
name|widget
operator|=
literal|0
expr_stmt|;
operator|delete
name|w
expr_stmt|;
block|}
comment|// destroys the share widget, but allows it to be recreated later on
DECL|function|destroy
name|void
name|destroy
parameter_list|()
block|{
if|if
condition|(
name|cleanedUp
condition|)
return|return;
name|QGLWidget
modifier|*
name|w
init|=
name|widget
decl_stmt|;
comment|// prevent potential recursions
name|cleanedUp
operator|=
literal|true
expr_stmt|;
name|widget
operator|=
literal|0
expr_stmt|;
operator|delete
name|w
expr_stmt|;
name|cleanedUp
operator|=
literal|false
expr_stmt|;
block|}
DECL|member|cleanedUp
specifier|static
name|bool
name|cleanedUp
decl_stmt|;
DECL|member|created
specifier|static
name|bool
name|created
decl_stmt|;
DECL|member|firstPixmap
name|QGLPixmapData
modifier|*
name|firstPixmap
decl_stmt|;
DECL|member|widgetRefCount
name|int
name|widgetRefCount
decl_stmt|;
private|private:
DECL|member|widget
name|QGLWidget
modifier|*
name|widget
decl_stmt|;
DECL|member|initializing
name|bool
name|initializing
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|member|cleanedUp
name|bool
name|QGLGlobalShareWidget
operator|::
name|cleanedUp
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|created
name|bool
name|QGLGlobalShareWidget
operator|::
name|created
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
name|void
name|qt_cleanup_gl_share_widget
parameter_list|()
function_decl|;
end_function_decl
begin_macro
name|Q_GLOBAL_STATIC_WITH_INITIALIZER
argument_list|(
argument|QGLGlobalShareWidget
argument_list|,
argument|_qt_gl_share_widget
argument_list|,
argument|{                                      qAddPostRoutine(qt_cleanup_gl_share_widget);                                  }
argument_list|)
end_macro
begin_function
DECL|function|qt_cleanup_gl_share_widget
specifier|static
name|void
name|qt_cleanup_gl_share_widget
parameter_list|()
block|{
if|if
condition|(
name|QGLGlobalShareWidget
operator|::
name|created
condition|)
name|_qt_gl_share_widget
argument_list|()
operator|->
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_gl_share_widget
name|QGLWidget
modifier|*
name|qt_gl_share_widget
parameter_list|()
block|{
if|if
condition|(
name|QGLGlobalShareWidget
operator|::
name|cleanedUp
condition|)
return|return
literal|0
return|;
return|return
name|_qt_gl_share_widget
argument_list|()
operator|->
name|shareWidget
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|qt_destroy_gl_share_widget
name|void
name|qt_destroy_gl_share_widget
parameter_list|()
block|{
if|if
condition|(
name|QGLGlobalShareWidget
operator|::
name|created
condition|)
name|_qt_gl_share_widget
argument_list|()
operator|->
name|destroy
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_gl_share_context
specifier|const
name|QGLContext
modifier|*
name|qt_gl_share_context
parameter_list|()
block|{
name|QGLWidget
modifier|*
name|widget
init|=
name|qt_gl_share_widget
argument_list|()
decl_stmt|;
if|if
condition|(
name|widget
condition|)
return|return
name|widget
operator|->
name|context
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QGL_USE_TEXTURE_POOL
end_ifdef
begin_function
DECL|function|qt_gl_register_pixmap
name|void
name|qt_gl_register_pixmap
parameter_list|(
name|QGLPixmapData
modifier|*
name|pd
parameter_list|)
block|{
name|QGLGlobalShareWidget
modifier|*
name|shared
init|=
name|_qt_gl_share_widget
argument_list|()
decl_stmt|;
name|pd
operator|->
name|next
operator|=
name|shared
operator|->
name|firstPixmap
expr_stmt|;
name|pd
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|shared
operator|->
name|firstPixmap
condition|)
name|shared
operator|->
name|firstPixmap
operator|->
name|prev
operator|=
name|pd
expr_stmt|;
name|shared
operator|->
name|firstPixmap
operator|=
name|pd
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_gl_unregister_pixmap
name|void
name|qt_gl_unregister_pixmap
parameter_list|(
name|QGLPixmapData
modifier|*
name|pd
parameter_list|)
block|{
if|if
condition|(
name|pd
operator|->
name|next
condition|)
name|pd
operator|->
name|next
operator|->
name|prev
operator|=
name|pd
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|prev
condition|)
block|{
name|pd
operator|->
name|prev
operator|->
name|next
operator|=
name|pd
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|QGLGlobalShareWidget
modifier|*
name|shared
init|=
name|_qt_gl_share_widget
argument_list|()
decl_stmt|;
if|if
condition|(
name|shared
condition|)
name|shared
operator|->
name|firstPixmap
operator|=
name|pd
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|qt_gl_hibernate_pixmaps
name|void
name|qt_gl_hibernate_pixmaps
parameter_list|()
block|{
name|QGLGlobalShareWidget
modifier|*
name|shared
init|=
name|_qt_gl_share_widget
argument_list|()
decl_stmt|;
comment|// Scan all QGLPixmapData objects in the system and hibernate them.
name|QGLPixmapData
modifier|*
name|pd
init|=
name|shared
operator|->
name|firstPixmap
decl_stmt|;
while|while
condition|(
name|pd
operator|!=
literal|0
condition|)
block|{
name|pd
operator|->
name|hibernate
argument_list|()
expr_stmt|;
name|pd
operator|=
name|pd
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_struct
DECL|struct|QGLWindowSurfacePrivate
struct|struct
name|QGLWindowSurfacePrivate
block|{
DECL|member|fbo
name|QGLFramebufferObject
modifier|*
name|fbo
decl_stmt|;
DECL|member|pb
name|QGLPixelBuffer
modifier|*
name|pb
decl_stmt|;
DECL|member|tex_id
name|GLuint
name|tex_id
decl_stmt|;
DECL|member|pb_tex_id
name|GLuint
name|pb_tex_id
decl_stmt|;
DECL|member|tried_fbo
name|int
name|tried_fbo
range|:
literal|1
decl_stmt|;
DECL|member|tried_pb
name|int
name|tried_pb
range|:
literal|1
decl_stmt|;
DECL|member|destructive_swap_buffers
name|int
name|destructive_swap_buffers
range|:
literal|1
decl_stmt|;
DECL|member|geometry_updated
name|int
name|geometry_updated
range|:
literal|1
decl_stmt|;
DECL|member|did_paint
name|int
name|did_paint
range|:
literal|1
decl_stmt|;
DECL|member|ctx
name|QGLContext
modifier|*
name|ctx
decl_stmt|;
DECL|member|contexts
name|QList
argument_list|<
name|QGLContext
modifier|*
modifier|*
argument_list|>
name|contexts
decl_stmt|;
DECL|member|paintedRegion
name|QRegion
name|paintedRegion
decl_stmt|;
DECL|member|size
name|QSize
name|size
decl_stmt|;
DECL|member|textureSize
name|QSize
name|textureSize
decl_stmt|;
DECL|member|buffers
name|QList
argument_list|<
name|QImage
argument_list|>
name|buffers
decl_stmt|;
DECL|member|glDevice
name|QGLWindowSurfaceGLPaintDevice
name|glDevice
decl_stmt|;
DECL|member|q_ptr
name|QGLWindowSurface
modifier|*
name|q_ptr
decl_stmt|;
DECL|member|swap_region_support
name|bool
name|swap_region_support
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|member|surfaceFormat
name|QGLFormat
name|QGLWindowSurface
operator|::
name|surfaceFormat
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|swapBehavior
name|QGLWindowSurface
operator|::
name|SwapMode
name|QGLWindowSurface
operator|::
name|swapBehavior
init|=
name|QGLWindowSurface
operator|::
name|AutomaticSwap
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|endPaint
name|void
name|QGLWindowSurfaceGLPaintDevice
operator|::
name|endPaint
parameter_list|()
block|{
name|glFlush
argument_list|()
expr_stmt|;
name|QGLPaintDevice
operator|::
name|endPaint
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|size
name|QSize
name|QGLWindowSurfaceGLPaintDevice
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|size
return|;
block|}
end_function
begin_function
DECL|function|context
name|QGLContext
modifier|*
name|QGLWindowSurfaceGLPaintDevice
operator|::
name|context
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|ctx
return|;
block|}
end_function
begin_function
DECL|function|metric
name|int
name|QGLWindowSurfaceGLPaintDevice
operator|::
name|metric
parameter_list|(
name|PaintDeviceMetric
name|m
parameter_list|)
specifier|const
block|{
name|QWindow
modifier|*
name|window
init|=
name|d
operator|->
name|q_ptr
operator|->
name|window
argument_list|()
decl_stmt|;
name|QPlatformScreen
modifier|*
name|screen
init|=
name|QPlatformScreen
operator|::
name|platformScreenForWindow
argument_list|(
name|window
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|screen
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|PdmDpiX
operator|||
name|m
operator|==
name|PdmDpiY
condition|)
return|return
literal|72
return|;
block|}
name|int
name|val
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|PdmWidth
condition|)
block|{
name|val
operator|=
name|window
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|PdmWidthMM
condition|)
block|{
name|val
operator|=
name|window
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
operator|*
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|width
argument_list|()
operator|/
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|PdmHeight
condition|)
block|{
name|val
operator|=
name|window
operator|->
name|geometry
argument_list|()
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|PdmHeightMM
condition|)
block|{
name|val
operator|=
name|window
operator|->
name|geometry
argument_list|()
operator|.
name|height
argument_list|()
operator|*
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|height
argument_list|()
operator|/
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|PdmDepth
condition|)
block|{
name|val
operator|=
name|screen
operator|->
name|depth
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|PdmDpiX
operator|||
name|m
operator|==
name|PdmPhysicalDpiX
condition|)
block|{
name|val
operator|=
name|qRound
argument_list|(
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
operator|/
name|double
argument_list|(
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|width
argument_list|()
operator|/
literal|25.4
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|PdmDpiY
operator|||
name|m
operator|==
name|PdmPhysicalDpiY
condition|)
block|{
name|val
operator|=
name|qRound
argument_list|(
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|height
argument_list|()
operator|/
name|double
argument_list|(
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|height
argument_list|()
operator|/
literal|25.4
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
literal|1
operator|<<
name|qMax
argument_list|(
literal|24
argument_list|,
name|screen
operator|->
name|depth
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QGLWindowSurfaceGLPaintDevice
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
return|return
name|qt_qgl_paint_engine
argument_list|()
return|;
block|}
end_function
begin_constructor
DECL|function|QGLWindowSurface
name|QGLWindowSurface
operator|::
name|QGLWindowSurface
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|)
member_init_list|:
name|QWindowSurface
argument_list|(
name|window
argument_list|)
member_init_list|,
name|d_ptr
argument_list|(
operator|new
name|QGLWindowSurfacePrivate
argument_list|)
block|{
comment|//    Q_ASSERT(window->isTopLevel());
name|d_ptr
operator|->
name|pb
operator|=
literal|0
expr_stmt|;
name|d_ptr
operator|->
name|fbo
operator|=
literal|0
expr_stmt|;
name|d_ptr
operator|->
name|ctx
operator|=
literal|0
expr_stmt|;
name|d_ptr
operator|->
name|tex_id
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
name|d_ptr
operator|->
name|tried_fbo
operator|=
literal|true
expr_stmt|;
name|d_ptr
operator|->
name|tried_pb
operator|=
literal|true
expr_stmt|;
else|#
directive|else
name|d_ptr
operator|->
name|tried_fbo
operator|=
literal|false
expr_stmt|;
name|d_ptr
operator|->
name|tried_pb
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
name|d_ptr
operator|->
name|destructive_swap_buffers
operator|=
name|qgetenv
argument_list|(
literal|"QT_GL_SWAPBUFFER_PRESERVE"
argument_list|)
operator|.
name|isNull
argument_list|()
expr_stmt|;
name|d_ptr
operator|->
name|glDevice
operator|.
name|d
operator|=
name|d_ptr
expr_stmt|;
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
name|d_ptr
operator|->
name|geometry_updated
operator|=
literal|false
expr_stmt|;
name|d_ptr
operator|->
name|did_paint
operator|=
literal|false
expr_stmt|;
name|d_ptr
operator|->
name|swap_region_support
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QGLWindowSurface
name|QGLWindowSurface
operator|::
name|~
name|QGLWindowSurface
parameter_list|()
block|{
if|if
condition|(
name|d_ptr
operator|->
name|ctx
condition|)
name|glDeleteTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|d_ptr
operator|->
name|tex_id
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_WS_QPA
comment|// Dont delete the contexts. Destroying the window does that for us
foreach|foreach
control|(
name|QGLContext
modifier|*
modifier|*
name|ctx
decl|,
name|d_ptr
operator|->
name|contexts
control|)
block|{
operator|delete
operator|*
name|ctx
expr_stmt|;
operator|*
name|ctx
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
operator|delete
name|d_ptr
operator|->
name|pb
expr_stmt|;
operator|delete
name|d_ptr
operator|->
name|fbo
expr_stmt|;
operator|delete
name|d_ptr
expr_stmt|;
if|if
condition|(
name|QGLGlobalShareWidget
operator|::
name|cleanedUp
condition|)
return|return;
operator|--
operator|(
name|_qt_gl_share_widget
argument_list|()
operator|->
name|widgetRefCount
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QGL_USE_TEXTURE_POOL
if|if
condition|(
name|_qt_gl_share_widget
argument_list|()
operator|->
name|widgetRefCount
operator|<=
literal|0
condition|)
block|{
comment|// All of the widget window surfaces have been destroyed
comment|// but we still have GL pixmaps active.  Ask them to hibernate
comment|// to free up GPU resources until a widget is shown again.
comment|// This may eventually cause the EGLContext to be destroyed
comment|// because nothing in the system needs a context, which will
comment|// free up even more GPU resources.
name|qt_gl_hibernate_pixmaps
argument_list|()
expr_stmt|;
comment|// Destroy the context if necessary.
if|if
condition|(
operator|!
name|qt_gl_share_widget
argument_list|()
operator|->
name|context
argument_list|()
operator|->
name|isSharing
argument_list|()
condition|)
name|qt_destroy_gl_share_widget
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QGL_USE_TEXTURE_POOL
block|}
end_destructor
begin_function
DECL|function|deleted
name|void
name|QGLWindowSurface
operator|::
name|deleted
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|)
block|{
if|#
directive|if
literal|0
block|QWidget *widget = qobject_cast<QWidget *>(object);     if (widget) {         if (widget == window()) {
comment|// Make sure that the fbo is destroyed before destroying its context.
block|delete d_ptr->fbo;             d_ptr->fbo = 0;         }
ifndef|#
directive|ifndef
name|Q_WS_QPA
comment|//no need to specifically delete the QGLContext as it will be deleted by QWidget
block|QWidgetPrivate *widgetPrivate = widget->d_func();         if (widgetPrivate->extraData()) {             union { QGLContext **ctxPtrPtr; void **voidPtrPtr; };             voidPtrPtr =&widgetPrivate->extraData()->glContext;             int index = d_ptr->contexts.indexOf(ctxPtrPtr);             if (index != -1) {                 delete *ctxPtrPtr;                 *ctxPtrPtr = 0;                 d_ptr->contexts.removeAt(index);             }         }
endif|#
directive|endif
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|hijackWindow
name|void
name|QGLWindowSurface
operator|::
name|hijackWindow
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|)
block|{
if|#
directive|if
literal|0
block|QWidgetPrivate *widgetPrivate = widget->d_func();     widgetPrivate->createExtra();     if (widgetPrivate->extraData()->glContext)         return;      QGLContext *ctx = NULL;
comment|// For translucent top-level widgets we need alpha in the format.
block|if (widget->testAttribute(Qt::WA_TranslucentBackground)) {         QGLFormat modFormat(surfaceFormat);         modFormat.setSampleBuffers(false);         modFormat.setSamples(0);         modFormat.setAlpha(true);         ctx = new QGLContext(modFormat, widget);     } else         ctx = new QGLContext(surfaceFormat, widget);      ctx->create(qt_gl_share_context());      if (widget != qt_gl_share_widget())         ++(_qt_gl_share_widget()->widgetRefCount);
ifndef|#
directive|ifndef
name|QT_NO_EGL
block|static bool checkedForNOKSwapRegion = false;     static bool haveNOKSwapRegion = false;      if (!checkedForNOKSwapRegion) {         haveNOKSwapRegion = QEgl::hasExtension("EGL_NOK_swap_region2");         checkedForNOKSwapRegion = true;          if (haveNOKSwapRegion)             qDebug()<< "Found EGL_NOK_swap_region2 extension. Using partial updates.";     }      d_ptr->destructive_swap_buffers = true;     if (ctx->d_func()->eglContext->configAttrib(EGL_SURFACE_TYPE)&EGL_SWAP_BEHAVIOR_PRESERVED_BIT) {         EGLint swapBehavior;         if (eglQuerySurface(ctx->d_func()->eglContext->display(), ctx->d_func()->eglSurface                             , EGL_SWAP_BEHAVIOR,&swapBehavior)) {             d_ptr->destructive_swap_buffers = (swapBehavior != EGL_BUFFER_PRESERVED);         }     }      d_ptr->swap_region_support = haveNOKSwapRegion;
endif|#
directive|endif
block|widgetPrivate->extraData()->glContext = ctx;      union { QGLContext **ctxPtrPtr; void **voidPtrPtr; };      connect(widget, SIGNAL(destroyed(QObject*)), this, SLOT(deleted(QObject*)));      voidPtrPtr =&widgetPrivate->extraData()->glContext;     d_ptr->contexts<< ctxPtrPtr;
ifndef|#
directive|ifndef
name|Q_OS_SYMBIAN
block|qDebug()<< "hijackWindow() context created for"<< widget<< d_ptr->contexts.size();
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|context
name|QGLContext
modifier|*
name|QGLWindowSurface
operator|::
name|context
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|ctx
return|;
block|}
end_function
begin_function
DECL|function|paintDevice
name|QPaintDevice
modifier|*
name|QGLWindowSurface
operator|::
name|paintDevice
parameter_list|()
block|{
name|updateGeometry
argument_list|()
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|pb
condition|)
return|return
name|d_ptr
operator|->
name|pb
return|;
if|if
condition|(
name|d_ptr
operator|->
name|ctx
condition|)
return|return
operator|&
name|d_ptr
operator|->
name|glDevice
return|;
if|#
directive|if
literal|0
block|QGLContext *ctx = reinterpret_cast<QGLContext *>(window()->d_func()->extraData()->glContext);     ctx->makeCurrent();
endif|#
directive|endif
name|Q_ASSERT
argument_list|(
name|d_ptr
operator|->
name|fbo
argument_list|)
expr_stmt|;
return|return
name|d_ptr
operator|->
name|fbo
return|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|drawTexture
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|GLuint
name|tex_id
parameter_list|,
specifier|const
name|QSize
modifier|&
name|texSize
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|src
init|=
name|QRectF
argument_list|()
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|beginPaint
name|void
name|QGLWindowSurface
operator|::
name|beginPaint
parameter_list|(
specifier|const
name|QRegion
modifier|&
parameter_list|)
block|{
name|d_ptr
operator|->
name|did_paint
operator|=
literal|true
expr_stmt|;
name|updateGeometry
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|context
argument_list|()
condition|)
return|return;
name|int
name|clearFlags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|context
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|workaround_needsFullClearOnEveryFrame
condition|)
name|clearFlags
operator|=
name|GL_COLOR_BUFFER_BIT
operator||
name|GL_DEPTH_BUFFER_BIT
operator||
name|GL_STENCIL_BUFFER_BIT
expr_stmt|;
elseif|else
if|if
condition|(
name|context
argument_list|()
operator|->
name|format
argument_list|()
operator|.
name|alpha
argument_list|()
condition|)
name|clearFlags
operator|=
name|GL_COLOR_BUFFER_BIT
expr_stmt|;
if|if
condition|(
name|clearFlags
condition|)
block|{
name|glClearColor
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|glClear
argument_list|(
name|clearFlags
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|endPaint
name|void
name|QGLWindowSurface
operator|::
name|endPaint
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|rgn
parameter_list|)
block|{
if|if
condition|(
name|context
argument_list|()
condition|)
name|d_ptr
operator|->
name|paintedRegion
operator||=
name|rgn
expr_stmt|;
name|d_ptr
operator|->
name|buffers
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|blitTexture
specifier|static
name|void
name|blitTexture
parameter_list|(
name|QGLContext
modifier|*
name|ctx
parameter_list|,
name|GLuint
name|texture
parameter_list|,
specifier|const
name|QSize
modifier|&
name|viewport
parameter_list|,
specifier|const
name|QSize
modifier|&
name|texSize
parameter_list|,
specifier|const
name|QRect
modifier|&
name|targetRect
parameter_list|,
specifier|const
name|QRect
modifier|&
name|sourceRect
parameter_list|)
block|{
name|glDisable
argument_list|(
name|GL_DEPTH_TEST
argument_list|)
expr_stmt|;
name|glDisable
argument_list|(
name|GL_SCISSOR_TEST
argument_list|)
expr_stmt|;
name|glDisable
argument_list|(
name|GL_BLEND
argument_list|)
expr_stmt|;
name|glViewport
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|viewport
operator|.
name|width
argument_list|()
argument_list|,
name|viewport
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|QGLShaderProgram
modifier|*
name|blitProgram
init|=
name|QGLEngineSharedShaders
operator|::
name|shadersForContext
argument_list|(
name|ctx
argument_list|)
operator|->
name|blitProgram
argument_list|()
decl_stmt|;
name|blitProgram
operator|->
name|bind
argument_list|()
expr_stmt|;
name|blitProgram
operator|->
name|setUniformValue
argument_list|(
literal|"imageTexture"
argument_list|,
literal|0
comment|/*QT_IMAGE_TEXTURE_UNIT*/
argument_list|)
expr_stmt|;
comment|// The shader manager's blit program does not multiply the
comment|// vertices by the pmv matrix, so we need to do the effect
comment|// of the orthographic projection here ourselves.
name|QRectF
name|r
decl_stmt|;
name|qreal
name|w
init|=
name|viewport
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|h
init|=
name|viewport
operator|.
name|height
argument_list|()
decl_stmt|;
name|r
operator|.
name|setLeft
argument_list|(
operator|(
name|targetRect
operator|.
name|left
argument_list|()
operator|/
name|w
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetRect
operator|.
name|right
argument_list|()
operator|==
operator|(
name|viewport
operator|.
name|width
argument_list|()
operator|-
literal|1
operator|)
condition|)
name|r
operator|.
name|setRight
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
else|else
name|r
operator|.
name|setRight
argument_list|(
operator|(
name|targetRect
operator|.
name|right
argument_list|()
operator|/
name|w
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
argument_list|)
expr_stmt|;
name|r
operator|.
name|setBottom
argument_list|(
operator|(
name|targetRect
operator|.
name|top
argument_list|()
operator|/
name|h
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetRect
operator|.
name|bottom
argument_list|()
operator|==
operator|(
name|viewport
operator|.
name|height
argument_list|()
operator|-
literal|1
operator|)
condition|)
name|r
operator|.
name|setTop
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
else|else
name|r
operator|.
name|setTop
argument_list|(
operator|(
name|targetRect
operator|.
name|bottom
argument_list|()
operator|/
name|w
operator|)
operator|*
literal|2.0f
operator|-
literal|1.0f
argument_list|)
expr_stmt|;
name|drawTexture
argument_list|(
name|r
argument_list|,
name|texture
argument_list|,
name|texSize
argument_list|,
name|sourceRect
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|flush
name|void
name|QGLWindowSurface
operator|::
name|flush
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|rgn
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|//### Find out why d_ptr->geometry_updated isn't always false.
comment|// flush() should not be called when d_ptr->geometry_updated is true. It assumes that either
comment|// d_ptr->fbo or d_ptr->pb is allocated and has the correct size.
block|if (d_ptr->geometry_updated)         return;
comment|// did_paint is set to true in ::beginPaint. ::beginPaint means that we
comment|// at least cleared the background (= painted something). In EGL API it's a
comment|// mistake to call swapBuffers if nothing was painted unless
comment|// EGL_BUFFER_PRESERVED is set. This check protects the flush func from
comment|// being executed if it's for nothing.
block|if (!d_ptr->destructive_swap_buffers&& !d_ptr->did_paint)         return;
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
block|if (window() != widget) {
comment|// For performance reasons we don't support
comment|// flushing native child widgets on Symbian.
comment|// It breaks overlapping native child widget
comment|// rendering in some cases but we prefer performance.
block|return;     }
endif|#
directive|endif
block|QWidget *parent = widget->internalWinId() ? widget : widget->nativeParentWidget();     Q_ASSERT(parent);
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
block|if (!geometry().isValid())         return;
else|#
directive|else
block|if (!size().isValid())         return;
endif|#
directive|endif
comment|// Needed to support native child-widgets...
block|hijackWindow(parent);      QRect br = rgn.boundingRect().translated(offset);     br = br.intersected(window()->rect());     QPoint wOffset = qt_qwidget_data(parent)->wrect.topLeft();     QRect rect = br.translated(-offset - wOffset);      const GLenum target = GL_TEXTURE_2D;     Q_UNUSED(target);      if (QGLWindowSurface::swapBehavior == QGLWindowSurface::KillSwap)         return;      if (context()) {         context()->makeCurrent();          if (context()->format().doubleBuffer()) {
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
block|if (d_ptr->destructive_swap_buffers) {                 glBindTexture(target, d_ptr->tex_id);                  QVector<QRect> rects = d_ptr->paintedRegion.rects();                 for (int i = 0; i< rects.size(); ++i) {                     QRect br = rects.at(i);                     if (br.isEmpty())                         continue;                      const uint bottom = window()->height() - (br.y() + br.height());                     glCopyTexSubImage2D(target, 0, br.x(), bottom, br.x(), bottom, br.width(), br.height());                 }                  glBindTexture(target, 0);                  QRegion dirtyRegion = QRegion(window()->rect()) - d_ptr->paintedRegion;                  if (!dirtyRegion.isEmpty()) {                     glMatrixMode(GL_MODELVIEW);                     glLoadIdentity();                      glMatrixMode(GL_PROJECTION);                     glLoadIdentity();
ifndef|#
directive|ifndef
name|QT_OPENGL_ES
block|glOrtho(0, window()->width(), window()->height(), 0, -999999, 999999);
else|#
directive|else
block|glOrthof(0, window()->width(), window()->height(), 0, -999999, 999999);
endif|#
directive|endif
block|glViewport(0, 0, window()->width(), window()->height());                      QVector<QRect> rects = dirtyRegion.rects();                     glColor4f(1, 1, 1, 1);                     for (int i = 0; i< rects.size(); ++i) {                         QRect rect = rects.at(i);                         if (rect.isEmpty())                             continue;                          drawTexture(rect, d_ptr->tex_id, window()->size(), rect);                     }                 }             }
endif|#
directive|endif
block|bool doingPartialUpdate = false;             if (d_ptr->swap_region_support) {                 if (QGLWindowSurface::swapBehavior == QGLWindowSurface::AutomaticSwap)                     doingPartialUpdate = br.width() * br.height()< parent->geometry().width() * parent->geometry().height() * 0.2;                 else if (QGLWindowSurface::swapBehavior == QGLWindowSurface::AlwaysPartialSwap)                     doingPartialUpdate = true;             }              QGLContext *ctx = reinterpret_cast<QGLContext *>(parent->d_func()->extraData()->glContext);             if (widget != window()) {                 if (initializeOffscreenTexture(window()->size()))                     qWarning()<< "QGLWindowSurface: Flushing to native child widget, may lead to significant performance loss";                 glBindTexture(target, d_ptr->tex_id);                  const uint bottom = window()->height() - (br.y() + br.height());                 glCopyTexSubImage2D(target, 0, br.x(), bottom, br.x(), bottom, br.width(), br.height());                  glBindTexture(target, 0);                  ctx->makeCurrent();                 if (doingPartialUpdate)                     blitTexture(ctx, d_ptr->tex_id, parent->size(), window()->size(), rect, br);                 else                     blitTexture(ctx, d_ptr->tex_id, parent->size(), window()->size(), parent->rect(), parent->rect().translated(offset + wOffset));             }              if (doingPartialUpdate)                 ctx->d_func()->swapRegion(br);             else                 ctx->swapBuffers();              d_ptr->paintedRegion = QRegion();         } else {             glFlush();         }         return;     }      QGLContext *previous_ctx = const_cast<QGLContext *>(QGLContext::currentContext());     QGLContext *ctx = reinterpret_cast<QGLContext *>(parent->d_func()->extraData()->glContext);
comment|// QPainter::end() should have unbound the fbo, otherwise something is very wrong...
block|Q_ASSERT(!d_ptr->fbo || !d_ptr->fbo->isBound());      if (ctx != previous_ctx) {         ctx->makeCurrent();     }      QSize size = widget->rect().size();     if (d_ptr->destructive_swap_buffers&& ctx->format().doubleBuffer()) {         rect = parent->rect();         br = rect.translated(wOffset + offset);         size = parent->size();     }      glDisable(GL_SCISSOR_TEST);      if (d_ptr->fbo&& (QGLExtensions::glExtensions()& QGLExtensions::FramebufferBlit)) {         const int h = d_ptr->fbo->height();          const int sx0 = br.left();         const int sx1 = br.left() + br.width();         const int sy0 = h - (br.top() + br.height());         const int sy1 = h - br.top();          const int tx0 = rect.left();         const int tx1 = rect.left() + rect.width();         const int ty0 = parent->height() - (rect.top() + rect.height());         const int ty1 = parent->height() - rect.top();          if (window() == parent || d_ptr->fbo->format().samples()<= 1) {             if (ctx->d_ptr->current_fbo != 0)                 glBindFramebuffer(GL_DRAW_FRAMEBUFFER_EXT, 0);              glBindFramebuffer(GL_READ_FRAMEBUFFER_EXT, d_ptr->fbo->handle());              glBlitFramebufferEXT(sx0, sy0, sx1, sy1,                     tx0, ty0, tx1, ty1,                     GL_COLOR_BUFFER_BIT,                     GL_NEAREST);              glBindFramebuffer(GL_READ_FRAMEBUFFER_EXT, 0);         } else {
comment|// can't do sub-region blits with multisample FBOs
block|QGLFramebufferObject *temp = qgl_fbo_pool()->acquire(d_ptr->fbo->size(), QGLFramebufferObjectFormat());              glBindFramebuffer(GL_DRAW_FRAMEBUFFER_EXT, temp->handle());             glBindFramebuffer(GL_READ_FRAMEBUFFER_EXT, d_ptr->fbo->handle());              glBlitFramebufferEXT(0, 0, d_ptr->fbo->width(), d_ptr->fbo->height(),                     0, 0, d_ptr->fbo->width(), d_ptr->fbo->height(),                     GL_COLOR_BUFFER_BIT,                     GL_NEAREST);              glBindFramebuffer(GL_READ_FRAMEBUFFER_EXT, temp->handle());             glBindFramebuffer(GL_DRAW_FRAMEBUFFER_EXT, 0);              glBlitFramebufferEXT(sx0, sy0, sx1, sy1,                     tx0, ty0, tx1, ty1,                     GL_COLOR_BUFFER_BIT,                     GL_NEAREST);              glBindFramebuffer(GL_READ_FRAMEBUFFER_EXT, 0);              qgl_fbo_pool()->release(temp);         }          ctx->d_ptr->current_fbo = 0;     }
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
block|else {         GLuint texture;     if (d_ptr->fbo) {         texture = d_ptr->fbo->texture();     } else {         d_ptr->pb->makeCurrent();         glBindTexture(target, d_ptr->pb_tex_id);         const uint bottom = window()->height() - (br.y() + br.height());         glCopyTexSubImage2D(target, 0, br.x(), bottom, br.x(), bottom, br.width(), br.height());         texture = d_ptr->pb_tex_id;         glBindTexture(target, 0);     }          glDisable(GL_DEPTH_TEST);          if (d_ptr->fbo) {             d_ptr->fbo->release();         } else {             ctx->makeCurrent();         }          glMatrixMode(GL_MODELVIEW);         glLoadIdentity();          glMatrixMode(GL_PROJECTION);         glLoadIdentity();
ifndef|#
directive|ifndef
name|QT_OPENGL_ES
block|glOrtho(0, size.width(), size.height(), 0, -999999, 999999);
else|#
directive|else
block|glOrthof(0, size.width(), size.height(), 0, -999999, 999999);
endif|#
directive|endif
block|glViewport(0, 0, size.width(), size.height());          glColor4f(1, 1, 1, 1);         drawTexture(rect, texture, window()->size(), br);          if (d_ptr->fbo)             d_ptr->fbo->bind();     }
else|#
directive|else
comment|// OpenGL/ES 2.0 version of the fbo blit.
block|else if (d_ptr->fbo) {         Q_UNUSED(target);          if (d_ptr->fbo->isBound())             d_ptr->fbo->release();          blitTexture(ctx, d_ptr->fbo->texture(), size, window()->size(), rect, br);     }
endif|#
directive|endif
block|if (ctx->format().doubleBuffer())         ctx->swapBuffers();     else         glFlush();
endif|#
directive|endif
name|d_ptr
operator|->
name|did_paint
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
end_if
begin_function
DECL|function|setGeometry
name|void
name|QGLWindowSurface
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|QWindowSurface
operator|::
name|setGeometry
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|geometry_updated
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|resize
name|void
name|QGLWindowSurface
operator|::
name|resize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|QWindowSurface
operator|::
name|resize
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|geometry_updated
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|updateGeometry
name|void
name|QGLWindowSurface
operator|::
name|updateGeometry
parameter_list|()
block|{
if|#
directive|if
literal|0
block|if (!d_ptr->geometry_updated)         return;     d_ptr->geometry_updated = false;      bool hijack(true);     QWidgetPrivate *wd = window()->d_func();     if (wd->extraData()&& wd->extraData()->glContext) {
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
comment|// Symbian needs to recreate the context when native window size changes
block|if (d_ptr->size != geometry().size()) {             if (window() != qt_gl_share_widget())                 --(_qt_gl_share_widget()->widgetRefCount);              delete wd->extraData()->glContext;             wd->extraData()->glContext = 0;             d_ptr->ctx = 0;         }         else
endif|#
directive|endif
block|{             hijack = false;
comment|// we already have gl context for widget
block|}     }      if (hijack)         hijackWindow(window());      QGLContext *ctx = reinterpret_cast<QGLContext *>(wd->extraData()->glContext);
ifdef|#
directive|ifdef
name|Q_WS_MAC
block|ctx->updatePaintDevice();
endif|#
directive|endif
block|QSize surfSize = geometry().size();      if (surfSize.width()<= 0 || surfSize.height()<= 0)         return;      if (d_ptr->size == surfSize)         return;      d_ptr->size = surfSize;      if (d_ptr->ctx) {
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
block|if (d_ptr->destructive_swap_buffers)             initializeOffscreenTexture(surfSize);
endif|#
directive|endif
block|return;     }      const GLenum target = GL_TEXTURE_2D;     if (d_ptr->destructive_swap_buffers&& (QGLExtensions::glExtensions()& QGLExtensions::FramebufferObject)&& (d_ptr->fbo || !d_ptr->tried_fbo)&& qt_gl_preferGL2Engine())     {         d_ptr->tried_fbo = true;         ctx->d_ptr->internal_context = true;         ctx->makeCurrent();         delete d_ptr->fbo;          QGLFramebufferObjectFormat format;         format.setAttachment(QGLFramebufferObject::CombinedDepthStencil);         format.setInternalTextureFormat(GLenum(GL_RGBA));         format.setTextureTarget(target);          if (QGLExtensions::glExtensions()& QGLExtensions::FramebufferBlit)             format.setSamples(8);          d_ptr->fbo = new QGLFramebufferObject(surfSize, format);          if (d_ptr->fbo->isValid()) {             qDebug()<< "Created Window Surface FBO"<< surfSize<< "with samples"<< d_ptr->fbo->format().samples();             return;         } else {             qDebug()<< "QGLWindowSurface: Failed to create valid FBO, falling back";             delete d_ptr->fbo;             d_ptr->fbo = 0;         }     }
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
comment|//QPA doesn't support pixelbuffers
block|if (d_ptr->destructive_swap_buffers&& (d_ptr->pb || !d_ptr->tried_pb)) {         d_ptr->tried_pb = true;          if (d_ptr->pb) {             d_ptr->pb->makeCurrent();             glDeleteTextures(1,&d_ptr->pb_tex_id);         }          delete d_ptr->pb;          d_ptr->pb = new QGLPixelBuffer(surfSize.width(), surfSize.height(),                                         QGLFormat(QGL::SampleBuffers | QGL::StencilBuffer | QGL::DepthBuffer),                                         qt_gl_share_widget());          if (d_ptr->pb->isValid()) {             qDebug()<< "Created Window Surface Pixelbuffer, Sample buffers:"<< d_ptr->pb->format().sampleBuffers();             d_ptr->pb->makeCurrent();              glGenTextures(1,&d_ptr->pb_tex_id);             glBindTexture(target, d_ptr->pb_tex_id);             glTexImage2D(target, 0, GL_RGBA, surfSize.width(), surfSize.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);              glTexParameterf(target, GL_TEXTURE_MAG_FILTER, GL_NEAREST);             glTexParameterf(target, GL_TEXTURE_MIN_FILTER, GL_NEAREST);             glBindTexture(target, 0);              glMatrixMode(GL_PROJECTION);             glLoadIdentity();             glOrtho(0, d_ptr->pb->width(), d_ptr->pb->height(), 0, -999999, 999999);              d_ptr->pb->d_ptr->qctx->d_func()->internal_context = true;             return;         } else {             qDebug()<< "QGLWindowSurface: Failed to create valid pixelbuffer, falling back";             delete d_ptr->pb;             d_ptr->pb = 0;         }     }
endif|#
directive|endif
comment|// !defined(QT_OPENGL_ES_2) !defined(Q_WS_QPA)
block|ctx->makeCurrent();
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
block|if (d_ptr->destructive_swap_buffers)         initializeOffscreenTexture(surfSize);
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_OS_SYMBIAN
block|qDebug()<< "QGLWindowSurface: Using plain widget as window surface"<< this;
endif|#
directive|endif
block|d_ptr->ctx = ctx;     d_ptr->ctx->d_ptr->internal_context = true;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|initializeOffscreenTexture
name|bool
name|QGLWindowSurface
operator|::
name|initializeOffscreenTexture
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
name|d_ptr
operator|->
name|textureSize
condition|)
return|return
literal|false
return|;
name|glGenTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|d_ptr
operator|->
name|tex_id
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|d_ptr
operator|->
name|tex_id
argument_list|)
expr_stmt|;
name|glTexImage2D
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
literal|0
argument_list|,
name|GL_RGB
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|,
literal|0
argument_list|,
name|GL_RGB
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|glTexParameterf
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
name|glTexParameterf
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|textureSize
operator|=
name|size
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|scroll
name|bool
name|QGLWindowSurface
operator|::
name|scroll
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|area
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|// this code randomly fails currently for unknown reasons
block|return false;      if (!d_ptr->pb)         return false;      d_ptr->pb->makeCurrent();      QRect br = area.boundingRect();
if|#
directive|if
literal|0
comment|// ## workaround driver issue (scrolling by these deltas is unbearably slow for some reason)
comment|// ## maybe we should use glCopyTexSubImage insteadk
block|if (dx == 1 || dx == -1 || dy == 1 || dy == -1 || dy == 2)         return false;      glRasterPos2i(br.x() + dx, br.y() + br.height() + dy);     glCopyPixels(br.x(), d_ptr->pb->height() - (br.y() + br.height()), br.width(), br.height(), GL_COLOR);     return true;
endif|#
directive|endif
block|const GLenum target = GL_TEXTURE_2D;      glBindTexture(target, d_ptr->tex_id);     glCopyTexImage2D(target, 0, GL_RGBA, br.x(), d_ptr->pb->height() - (br.y() + br.height()), br.width(), br.height(), 0);     glBindTexture(target, 0);      drawTexture(br.translated(dx, dy), d_ptr->tex_id, window()->size());
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|drawTexture
specifier|static
name|void
name|drawTexture
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|GLuint
name|tex_id
parameter_list|,
specifier|const
name|QSize
modifier|&
name|texSize
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|br
parameter_list|)
block|{
specifier|const
name|GLenum
name|target
init|=
name|GL_TEXTURE_2D
decl_stmt|;
name|QRectF
name|src
init|=
name|br
operator|.
name|isEmpty
argument_list|()
condition|?
name|QRectF
argument_list|(
name|QPointF
argument_list|()
argument_list|,
name|texSize
argument_list|)
else|:
name|QRectF
argument_list|(
name|QPointF
argument_list|(
name|br
operator|.
name|x
argument_list|()
argument_list|,
name|texSize
operator|.
name|height
argument_list|()
operator|-
name|br
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|,
name|br
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|GL_TEXTURE_2D
condition|)
block|{
name|qreal
name|width
init|=
name|texSize
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|height
init|=
name|texSize
operator|.
name|height
argument_list|()
decl_stmt|;
name|src
operator|.
name|setLeft
argument_list|(
name|src
operator|.
name|left
argument_list|()
operator|/
name|width
argument_list|)
expr_stmt|;
name|src
operator|.
name|setRight
argument_list|(
name|src
operator|.
name|right
argument_list|()
operator|/
name|width
argument_list|)
expr_stmt|;
name|src
operator|.
name|setTop
argument_list|(
name|src
operator|.
name|top
argument_list|()
operator|/
name|height
argument_list|)
expr_stmt|;
name|src
operator|.
name|setBottom
argument_list|(
name|src
operator|.
name|bottom
argument_list|()
operator|/
name|height
argument_list|)
expr_stmt|;
block|}
specifier|const
name|GLfloat
name|tx1
init|=
name|src
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|GLfloat
name|tx2
init|=
name|src
operator|.
name|right
argument_list|()
decl_stmt|;
specifier|const
name|GLfloat
name|ty1
init|=
name|src
operator|.
name|top
argument_list|()
decl_stmt|;
specifier|const
name|GLfloat
name|ty2
init|=
name|src
operator|.
name|bottom
argument_list|()
decl_stmt|;
name|GLfloat
name|texCoordArray
index|[
literal|4
operator|*
literal|2
index|]
init|=
block|{
name|tx1
block|,
name|ty2
block|,
name|tx2
block|,
name|ty2
block|,
name|tx2
block|,
name|ty1
block|,
name|tx1
block|,
name|ty1
block|}
decl_stmt|;
name|GLfloat
name|vertexArray
index|[
literal|4
operator|*
literal|2
index|]
decl_stmt|;
specifier|extern
name|void
name|qt_add_rect_to_array
argument_list|(
specifier|const
name|QRectF
operator|&
name|r
argument_list|,
name|GLfloat
operator|*
name|array
argument_list|)
decl_stmt|;
comment|// qpaintengine_opengl.cpp
name|qt_add_rect_to_array
argument_list|(
name|rect
argument_list|,
name|vertexArray
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
name|glVertexPointer
argument_list|(
literal|2
argument_list|,
name|GL_FLOAT
argument_list|,
literal|0
argument_list|,
name|vertexArray
argument_list|)
expr_stmt|;
name|glTexCoordPointer
argument_list|(
literal|2
argument_list|,
name|GL_FLOAT
argument_list|,
literal|0
argument_list|,
name|texCoordArray
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|target
argument_list|,
name|tex_id
argument_list|)
expr_stmt|;
name|glEnable
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|glEnableClientState
argument_list|(
name|GL_VERTEX_ARRAY
argument_list|)
expr_stmt|;
name|glEnableClientState
argument_list|(
name|GL_TEXTURE_COORD_ARRAY
argument_list|)
expr_stmt|;
name|glDrawArrays
argument_list|(
name|GL_TRIANGLE_FAN
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|glDisableClientState
argument_list|(
name|GL_VERTEX_ARRAY
argument_list|)
expr_stmt|;
name|glDisableClientState
argument_list|(
name|GL_TEXTURE_COORD_ARRAY
argument_list|)
expr_stmt|;
name|glDisable
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|glVertexAttribPointer
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|,
literal|2
argument_list|,
name|GL_FLOAT
argument_list|,
name|GL_FALSE
argument_list|,
literal|0
argument_list|,
name|vertexArray
argument_list|)
expr_stmt|;
name|glVertexAttribPointer
argument_list|(
name|QT_TEXTURE_COORDS_ATTR
argument_list|,
literal|2
argument_list|,
name|GL_FLOAT
argument_list|,
name|GL_FALSE
argument_list|,
literal|0
argument_list|,
name|texCoordArray
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|target
argument_list|,
name|tex_id
argument_list|)
expr_stmt|;
name|glEnableVertexAttribArray
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|)
expr_stmt|;
name|glEnableVertexAttribArray
argument_list|(
name|QT_TEXTURE_COORDS_ATTR
argument_list|)
expr_stmt|;
name|glDrawArrays
argument_list|(
name|GL_TRIANGLE_FAN
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|glDisableVertexAttribArray
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|)
expr_stmt|;
name|glDisableVertexAttribArray
argument_list|(
name|QT_TEXTURE_COORDS_ATTR
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|features
name|QWindowSurface
operator|::
name|WindowSurfaceFeatures
name|QGLWindowSurface
operator|::
name|features
parameter_list|()
specifier|const
block|{
name|WindowSurfaceFeatures
name|features
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|destructive_swap_buffers
operator|||
name|d_ptr
operator|->
name|swap_region_support
condition|)
name|features
operator||=
name|PartialUpdates
expr_stmt|;
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|destructive_swap_buffers
condition|)
name|features
operator||=
name|PreservedContents
expr_stmt|;
return|return
name|features
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
