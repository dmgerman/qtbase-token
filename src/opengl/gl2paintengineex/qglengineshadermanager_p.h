begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtOpenGL module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//  W A R N I N G
end_comment
begin_comment
comment|//  -------------
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// This file is not part of the Qt API.  It exists purely as an
end_comment
begin_comment
comment|// implementation detail.  This header file may change from version to
end_comment
begin_comment
comment|// version without notice, or even be removed.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// We mean it.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|/*     VERTEX SHADERS     ==============      Vertex shaders are specified as multiple (partial) shaders. On desktop,     this works fine. On ES, QGLShader& QGLShaderProgram will make partial     shaders work by concatenating the source in each QGLShader and compiling     it as a single shader. This is abstracted nicely by QGLShaderProgram and     the GL2 engine doesn't need to worry about it.      Generally, there's two vertex shader objects. The position shaders are     the ones which set gl_Position. There's also two "main" vertex shaders,     one which just calls the position shader and another which also passes     through some texture coordinates from a vertex attribute array to a     varying. These texture coordinates are used for mask position in text     rendering and for the source coordinates in drawImage/drawPixmap. There's     also a "Simple" vertex shader for rendering a solid colour (used to render     into the stencil buffer where the actual colour value is discarded).      The position shaders for brushes look scary. This is because many of the     calculations which logically belong in the fragment shader have been moved     into the vertex shader to improve performance. This is why the position     calculation is in a separate shader. Not only does it calculate the     position, but it also calculates some data to be passed to the fragment     shader as a varying. It is optimal to move as much of the calculation as     possible into the vertex shader as this is executed less often.      The varyings passed to the fragment shaders are interpolated (which is     cheap). Unfortunately, GL will apply perspective correction to the     interpolation calusing errors. To get around this, the vertex shader must     apply perspective correction itself and set the w-value of gl_Position to     zero. That way, GL will be tricked into thinking it doesn't need to apply a     perspective correction and use linear interpolation instead (which is what     we want). Of course, if the brush transform is affeine, no perspective     correction is needed and a simpler vertex shader can be used instead.      So there are the following "main" vertex shaders:         qglslMainVertexShader         qglslMainWithTexCoordsVertexShader      And the the following position vertex shaders:         qglslPositionOnlyVertexShader         qglslPositionWithTextureBrushVertexShader         qglslPositionWithPatternBrushVertexShader         qglslPositionWithLinearGradientBrushVertexShader         qglslPositionWithRadialGradientBrushVertexShader         qglslPositionWithConicalGradientBrushVertexShader         qglslAffinePositionWithTextureBrushVertexShader         qglslAffinePositionWithPatternBrushVertexShader         qglslAffinePositionWithLinearGradientBrushVertexShader         qglslAffinePositionWithRadialGradientBrushVertexShader         qglslAffinePositionWithConicalGradientBrushVertexShader      Leading to 23 possible vertex shaders       FRAGMENT SHADERS     ================      Fragment shaders are also specified as multiple (partial) shaders. The     different fragment shaders represent the different stages in Qt's fragment     pipeline. There are 1-3 stages in this pipeline: First stage is to get the     fragment's colour value. The next stage is to get the fragment's mask value     (coverage value for anti-aliasing) and the final stage is to blend the     incoming fragment with the background (for composition modes not supported     by GL).      Of these, the first stage will always be present. If Qt doesn't need to     apply anti-aliasing (because it's off or handled by multisampling) then     the coverage value doesn't need to be applied. (Note: There are two types     of mask, one for regular anti-aliasing and one for sub-pixel anti-     aliasing.) If the composition mode is one which GL supports natively then     the blending stage doesn't need to be applied.      As eash stage can have multiple implementations, they are abstracted as     GLSL function calls with the following signatures:      Brushes& image drawing are implementations of "qcolorp vec4 srcPixel()":         qglslImageSrcFragShader         qglslImageSrcWithPatternFragShader         qglslNonPremultipliedImageSrcFragShader         qglslSolidBrushSrcFragShader         qglslTextureBrushSrcFragShader         qglslTextureBrushWithPatternFragShader         qglslPatternBrushSrcFragShader         qglslLinearGradientBrushSrcFragShader         qglslRadialGradientBrushSrcFragShader         qglslConicalGradientBrushSrcFragShader     NOTE: It is assumed the colour returned by srcPixel() is pre-multiplied      Masks are implementations of "qcolorp vec4 applyMask(qcolorp vec4 src)":         qglslMaskFragmentShader         qglslRgbMaskFragmentShaderPass1         qglslRgbMaskFragmentShaderPass2         qglslRgbMaskWithGammaFragmentShader      Composition modes are "qcolorp vec4 compose(qcolorp vec4 src)":         qglslColorBurnCompositionModeFragmentShader         qglslColorDodgeCompositionModeFragmentShader         qglslDarkenCompositionModeFragmentShader         qglslDifferenceCompositionModeFragmentShader         qglslExclusionCompositionModeFragmentShader         qglslHardLightCompositionModeFragmentShader         qglslLightenCompositionModeFragmentShader         qglslMultiplyCompositionModeFragmentShader         qglslOverlayCompositionModeFragmentShader         qglslScreenCompositionModeFragmentShader         qglslSoftLightCompositionModeFragmentShader       Note: In the future, some GLSL compilers will support an extension allowing           a new 'color' precision specifier. To support this, qcolorp is used for           all color components so it can be defined to colorp or lowp depending upon           the implementation.      So there are differnt frament shader main functions, depending on the     number& type of pipelines the fragment needs to go through.      The choice of which main() fragment shader string to use depends on:         - Use of global opacity         - Brush style (some brushes apply opacity themselves)         - Use& type of mask (TODO: Need to support high quality anti-aliasing& text)         - Use of non-GL Composition mode      Leading to the following fragment shader main functions:         gl_FragColor = compose(applyMask(srcPixel()*globalOpacity));         gl_FragColor = compose(applyMask(srcPixel()));         gl_FragColor = applyMask(srcPixel()*globalOpacity);         gl_FragColor = applyMask(srcPixel());         gl_FragColor = compose(srcPixel()*globalOpacity);         gl_FragColor = compose(srcPixel());         gl_FragColor = srcPixel()*globalOpacity;         gl_FragColor = srcPixel();      Called:         qglslMainFragmentShader_CMO         qglslMainFragmentShader_CM         qglslMainFragmentShader_MO         qglslMainFragmentShader_M         qglslMainFragmentShader_CO         qglslMainFragmentShader_C         qglslMainFragmentShader_O         qglslMainFragmentShader      Where:         M = Mask         C = Composition         O = Global Opacity       CUSTOM SHADER CODE     ==================      The use of custom shader code is supported by the engine for drawImage and     drawPixmap calls. This is implemented via hooks in the fragment pipeline.      The custom shader is passed to the engine as a partial fragment shader     (QGLCustomShaderStage). The shader will implement a pre-defined method name     which Qt's fragment pipeline will call:          lowp vec4 customShader(lowp sampler2d imageTexture, highp vec2 textureCoords)      The provided src and srcCoords parameters can be used to sample from the     source image.      Transformations, clipping, opacity, and composition modes set using QPainter     will be respected when using the custom shader hook. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QGLENGINE_SHADER_MANAGER_H
end_ifndef
begin_define
DECL|macro|QGLENGINE_SHADER_MANAGER_H
define|#
directive|define
name|QGLENGINE_SHADER_MANAGER_H
end_define
begin_include
include|#
directive|include
file|<QGLShader>
end_include
begin_include
include|#
directive|include
file|<QGLShaderProgram>
end_include
begin_include
include|#
directive|include
file|<QPainter>
end_include
begin_include
include|#
directive|include
file|<private/qgl_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qglcustomshaderstage_p.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|/* struct QGLEngineCachedShaderProg {     QGLEngineCachedShaderProg(QGLEngineShaderManager::ShaderName vertexMain,                               QGLEngineShaderManager::ShaderName vertexPosition,                               QGLEngineShaderManager::ShaderName fragMain,                               QGLEngineShaderManager::ShaderName pixelSrc,                               QGLEngineShaderManager::ShaderName mask,                               QGLEngineShaderManager::ShaderName composition);      int cacheKey;     QGLShaderProgram* program; } */
DECL|variable|QT_VERTEX_COORDS_ATTR
specifier|static
specifier|const
name|GLuint
name|QT_VERTEX_COORDS_ATTR
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QT_TEXTURE_COORDS_ATTR
specifier|static
specifier|const
name|GLuint
name|QT_TEXTURE_COORDS_ATTR
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QT_OPACITY_ATTR
specifier|static
specifier|const
name|GLuint
name|QT_OPACITY_ATTR
init|=
literal|2
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QT_PMV_MATRIX_1_ATTR
specifier|static
specifier|const
name|GLuint
name|QT_PMV_MATRIX_1_ATTR
init|=
literal|3
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QT_PMV_MATRIX_2_ATTR
specifier|static
specifier|const
name|GLuint
name|QT_PMV_MATRIX_2_ATTR
init|=
literal|4
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QT_PMV_MATRIX_3_ATTR
specifier|static
specifier|const
name|GLuint
name|QT_PMV_MATRIX_3_ATTR
init|=
literal|5
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QGLEngineShaderProg
name|class
name|QGLEngineShaderProg
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|class
name|Q_OPENGL_EXPORT
name|QGLEngineSharedShaders
block|{
name|Q_GADGET
name|public
range|:      enum
name|SnippetName
block|{
name|MainVertexShader
block|,
name|MainWithTexCoordsVertexShader
block|,
name|MainWithTexCoordsAndOpacityVertexShader
block|,
comment|// UntransformedPositionVertexShader must be first in the list:
name|UntransformedPositionVertexShader
block|,
name|PositionOnlyVertexShader
block|,
name|ComplexGeometryPositionOnlyVertexShader
block|,
name|PositionWithPatternBrushVertexShader
block|,
name|PositionWithLinearGradientBrushVertexShader
block|,
name|PositionWithConicalGradientBrushVertexShader
block|,
name|PositionWithRadialGradientBrushVertexShader
block|,
name|PositionWithTextureBrushVertexShader
block|,
name|AffinePositionWithPatternBrushVertexShader
block|,
name|AffinePositionWithLinearGradientBrushVertexShader
block|,
name|AffinePositionWithConicalGradientBrushVertexShader
block|,
name|AffinePositionWithRadialGradientBrushVertexShader
block|,
name|AffinePositionWithTextureBrushVertexShader
block|,
comment|// MainFragmentShader_CMO must be first in the list:
name|MainFragmentShader_CMO
block|,
name|MainFragmentShader_CM
block|,
name|MainFragmentShader_MO
block|,
name|MainFragmentShader_M
block|,
name|MainFragmentShader_CO
block|,
name|MainFragmentShader_C
block|,
name|MainFragmentShader_O
block|,
name|MainFragmentShader
block|,
name|MainFragmentShader_ImageArrays
block|,
comment|// ImageSrcFragmentShader must be first in the list::
name|ImageSrcFragmentShader
block|,
name|ImageSrcWithPatternFragmentShader
block|,
name|NonPremultipliedImageSrcFragmentShader
block|,
name|CustomImageSrcFragmentShader
block|,
name|SolidBrushSrcFragmentShader
block|,
name|TextureBrushSrcFragmentShader
block|,
name|TextureBrushSrcWithPatternFragmentShader
block|,
name|PatternBrushSrcFragmentShader
block|,
name|LinearGradientBrushSrcFragmentShader
block|,
name|RadialGradientBrushSrcFragmentShader
block|,
name|ConicalGradientBrushSrcFragmentShader
block|,
name|ShockingPinkSrcFragmentShader
block|,
comment|// NoMaskFragmentShader must be first in the list:
name|NoMaskFragmentShader
block|,
name|MaskFragmentShader
block|,
name|RgbMaskFragmentShaderPass1
block|,
name|RgbMaskFragmentShaderPass2
block|,
name|RgbMaskWithGammaFragmentShader
block|,
comment|// NoCompositionModeFragmentShader must be first in the list:
name|NoCompositionModeFragmentShader
block|,
name|MultiplyCompositionModeFragmentShader
block|,
name|ScreenCompositionModeFragmentShader
block|,
name|OverlayCompositionModeFragmentShader
block|,
name|DarkenCompositionModeFragmentShader
block|,
name|LightenCompositionModeFragmentShader
block|,
name|ColorDodgeCompositionModeFragmentShader
block|,
name|ColorBurnCompositionModeFragmentShader
block|,
name|HardLightCompositionModeFragmentShader
block|,
name|SoftLightCompositionModeFragmentShader
block|,
name|DifferenceCompositionModeFragmentShader
block|,
name|ExclusionCompositionModeFragmentShader
block|,
name|TotalSnippetCount
block|,
name|InvalidSnippetName
block|}
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
name|Q_ENUMS
argument_list|(
argument|SnippetName
argument_list|)
specifier|static
name|QByteArray
name|snippetNameStr
parameter_list|(
name|SnippetName
name|snippetName
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/*     // These allow the ShaderName enum to be used as a cache key     const int mainVertexOffset = 0;     const int positionVertexOffset = (1<<2) - PositionOnlyVertexShader;     const int mainFragOffset = (1<<6) - MainFragmentShader_CMO;     const int srcPixelOffset = (1<<10) - ImageSrcFragmentShader;     const int maskOffset = (1<<14) - NoMaskShader;     const int compositionOffset = (1<< 16) - MultiplyCompositionModeFragmentShader; */
name|QGLEngineSharedShaders
argument_list|(
specifier|const
name|QGLContext
operator|*
name|context
argument_list|)
expr_stmt|;
operator|~
name|QGLEngineSharedShaders
argument_list|()
expr_stmt|;
name|QGLShaderProgram
modifier|*
name|simpleProgram
parameter_list|()
block|{
return|return
name|simpleShaderProg
return|;
block|}
name|QGLShaderProgram
modifier|*
name|blitProgram
parameter_list|()
block|{
return|return
name|blitShaderProg
return|;
block|}
comment|// Compile the program if it's not already in the cache, return the item in the cache.
name|QGLEngineShaderProg
modifier|*
name|findProgramInCache
parameter_list|(
specifier|const
name|QGLEngineShaderProg
modifier|&
name|prog
parameter_list|)
function_decl|;
comment|// Compile the custom shader if it's not already in the cache, return the item in the cache.
specifier|static
name|QGLEngineSharedShaders
modifier|*
name|shadersForContext
parameter_list|(
specifier|const
name|QGLContext
modifier|*
name|context
parameter_list|)
function_decl|;
comment|// Ideally, this would be static and cleanup all programs in all contexts which
comment|// contain the custom code. Currently it is just a hint and we rely on deleted
comment|// custom shaders being cleaned up by being kicked out of the cache when it's
comment|// full.
name|void
name|cleanupCustomStage
parameter_list|(
name|QGLCustomShaderStage
modifier|*
name|stage
parameter_list|)
function_decl|;
name|private
label|:
name|QGLShaderProgram
modifier|*
name|blitShaderProg
decl_stmt|;
name|QGLShaderProgram
modifier|*
name|simpleShaderProg
decl_stmt|;
name|QList
operator|<
name|QGLEngineShaderProg
operator|*
operator|>
name|cachedPrograms
expr_stmt|;
name|QList
operator|<
name|QGLShader
operator|*
operator|>
name|shaders
expr_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|qShaderSnippets
index|[
name|TotalSnippetCount
index|]
decl_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_decl_stmt
name|class
name|QGLEngineShaderProg
block|{
name|public
label|:
name|QGLEngineShaderProg
argument_list|()
operator|:
name|program
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|QGLEngineShaderProg
argument_list|()
block|{
if|if
condition|(
name|program
condition|)
name|delete
name|program
decl_stmt|;
block|}
name|QGLEngineSharedShaders
operator|::
name|SnippetName
name|mainVertexShader
expr_stmt|;
name|QGLEngineSharedShaders
operator|::
name|SnippetName
name|positionVertexShader
expr_stmt|;
name|QGLEngineSharedShaders
operator|::
name|SnippetName
name|mainFragShader
expr_stmt|;
name|QGLEngineSharedShaders
operator|::
name|SnippetName
name|srcPixelFragShader
expr_stmt|;
name|QGLEngineSharedShaders
operator|::
name|SnippetName
name|maskFragShader
expr_stmt|;
name|QGLEngineSharedShaders
operator|::
name|SnippetName
name|compositionFragShader
expr_stmt|;
name|QByteArray
name|customStageSource
decl_stmt|;
comment|//TODO: Decent cache key for custom stages
name|QGLShaderProgram
modifier|*
name|program
decl_stmt|;
name|QVector
operator|<
name|uint
operator|>
name|uniformLocations
expr_stmt|;
name|bool
name|useTextureCoords
decl_stmt|;
name|bool
name|useOpacityAttribute
decl_stmt|;
name|bool
name|usePmvMatrixAttribute
decl_stmt|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|QGLEngineShaderProg
operator|&
name|other
operator|)
specifier|const
block|{
comment|// We don't care about the program
return|return
operator|(
name|mainVertexShader
operator|==
name|other
operator|.
name|mainVertexShader
operator|&&
name|positionVertexShader
operator|==
name|other
operator|.
name|positionVertexShader
operator|&&
name|mainFragShader
operator|==
name|other
operator|.
name|mainFragShader
operator|&&
name|srcPixelFragShader
operator|==
name|other
operator|.
name|srcPixelFragShader
operator|&&
name|maskFragShader
operator|==
name|other
operator|.
name|maskFragShader
operator|&&
name|compositionFragShader
operator|==
name|other
operator|.
name|compositionFragShader
operator|&&
name|customStageSource
operator|==
name|other
operator|.
name|customStageSource
operator|)
return|;
block|}
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_decl_stmt
name|class
name|Q_OPENGL_EXPORT
name|QGLEngineShaderManager
range|:
name|public
name|QObject
block|{
name|Q_OBJECT
name|public
operator|:
name|QGLEngineShaderManager
argument_list|(
name|QGLContext
operator|*
name|context
argument_list|)
block|;
operator|~
name|QGLEngineShaderManager
argument_list|()
block|;      enum
name|MaskType
block|{
name|NoMask
block|,
name|PixelMask
block|,
name|SubPixelMaskPass1
block|,
name|SubPixelMaskPass2
block|,
name|SubPixelWithGammaMask
block|}
block|;     enum
name|PixelSrcType
block|{
name|ImageSrc
operator|=
name|Qt
operator|::
name|TexturePattern
operator|+
literal|1
block|,
name|NonPremultipliedImageSrc
operator|=
name|Qt
operator|::
name|TexturePattern
operator|+
literal|2
block|,
name|PatternSrc
operator|=
name|Qt
operator|::
name|TexturePattern
operator|+
literal|3
block|,
name|TextureSrcWithPattern
operator|=
name|Qt
operator|::
name|TexturePattern
operator|+
literal|4
block|}
block|;      enum
name|Uniform
block|{
name|ImageTexture
block|,
name|PatternColor
block|,
name|GlobalOpacity
block|,
name|Depth
block|,
name|MaskTexture
block|,
name|FragmentColor
block|,
name|LinearData
block|,
name|Angle
block|,
name|HalfViewportSize
block|,
name|Fmp
block|,
name|Fmp2MRadius2
block|,
name|Inverse2Fmp2MRadius2
block|,
name|SqrFr
block|,
name|BRadius
block|,
name|InvertedTextureSize
block|,
name|BrushTransform
block|,
name|BrushTexture
block|,
name|Matrix
block|,
name|NumUniforms
block|}
block|;      enum
name|OpacityMode
block|{
name|NoOpacity
block|,
name|UniformOpacity
block|,
name|AttributeOpacity
block|}
block|;
comment|// There are optimizations we can do, depending on the brush transform:
comment|//    1) May not have to apply perspective-correction
comment|//    2) Can use lower precision for matrix
name|void
name|optimiseForBrushTransform
argument_list|(
argument|QTransform::TransformationType transformType
argument_list|)
block|;
name|void
name|setSrcPixelType
argument_list|(
name|Qt
operator|::
name|BrushStyle
argument_list|)
block|;
name|void
name|setSrcPixelType
argument_list|(
name|PixelSrcType
argument_list|)
block|;
comment|// For non-brush sources, like pixmaps& images
name|void
name|setOpacityMode
argument_list|(
name|OpacityMode
argument_list|)
block|;
name|void
name|setMaskType
argument_list|(
name|MaskType
argument_list|)
block|;
name|void
name|setCompositionMode
argument_list|(
name|QPainter
operator|::
name|CompositionMode
argument_list|)
block|;
name|void
name|setCustomStage
argument_list|(
name|QGLCustomShaderStage
operator|*
name|stage
argument_list|)
block|;
name|void
name|removeCustomStage
argument_list|()
block|;
name|GLuint
name|getUniformLocation
argument_list|(
argument|Uniform id
argument_list|)
block|;
name|void
name|setDirty
argument_list|()
block|;
comment|// someone has manually changed the current shader program
name|bool
name|useCorrectShaderProg
argument_list|()
block|;
comment|// returns true if the shader program needed to be changed
name|void
name|useSimpleProgram
argument_list|()
block|;
name|void
name|useBlitProgram
argument_list|()
block|;
name|void
name|setHasComplexGeometry
argument_list|(
argument|bool hasComplexGeometry
argument_list|)
block|{
name|complexGeometry
operator|=
name|hasComplexGeometry
block|;
name|shaderProgNeedsChanging
operator|=
name|true
block|;     }
name|bool
name|hasComplexGeometry
argument_list|()
specifier|const
block|{
return|return
name|complexGeometry
return|;
block|}
name|QGLShaderProgram
operator|*
name|currentProgram
argument_list|()
block|;
comment|// Returns pointer to the shader the manager has chosen
name|QGLShaderProgram
operator|*
name|simpleProgram
argument_list|()
block|;
comment|// Used to draw into e.g. stencil buffers
name|QGLShaderProgram
operator|*
name|blitProgram
argument_list|()
block|;
comment|// Used to blit a texture into the framebuffer
name|QGLEngineSharedShaders
operator|*
name|sharedShaders
block|;
name|private
operator|:
name|QGLContext
operator|*
name|ctx
block|;
name|bool
name|shaderProgNeedsChanging
block|;
name|bool
name|complexGeometry
block|;
comment|// Current state variables which influence the choice of shader:
name|QTransform
name|brushTransform
block|;
name|int
name|srcPixelType
block|;
name|OpacityMode
name|opacityMode
block|;
name|MaskType
name|maskType
block|;
name|QPainter
operator|::
name|CompositionMode
name|compositionMode
block|;
name|QGLCustomShaderStage
operator|*
name|customSrcStage
block|;
name|QGLEngineShaderProg
operator|*
name|currentShaderProg
block|; }
decl_stmt|;
end_decl_stmt
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QGLENGINE_SHADER_MANAGER_H
end_comment
end_unit
