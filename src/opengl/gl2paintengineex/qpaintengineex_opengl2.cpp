begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtOpenGL module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia. For licensing terms and ** conditions see http://qt.digia.com/licensing. For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights. These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*     When the active program changes, we need to update it's uniforms.     We could track state for each program and only update stale uniforms         - Could lead to lots of overhead if there's a lot of programs     We could update all the uniforms when the program changes         - Could end up updating lots of uniforms which don't need updating      Updating uniforms should be cheap, so the overhead of updating up-to-date     uniforms should be minimal. It's also less complex.      Things which _may_ cause a different program to be used:         - Change in brush/pen style         - Change in painter opacity         - Change in composition mode      Whenever we set a mode on the shader manager - it needs to tell us if it had     to switch to a different program.      The shader manager should only switch when we tell it to. E.g. if we set a new     brush style and then switch to transparent painter, we only want it to compile     and use the correct program when we really need it. */
end_comment
begin_comment
comment|// #define QT_OPENGL_CACHE_AS_VBOS
end_comment
begin_include
include|#
directive|include
file|"qglgradientcache_p.h"
end_include
begin_include
include|#
directive|include
file|"qpaintengineex_opengl2_p.h"
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_comment
comment|//for memcpy
end_comment
begin_include
include|#
directive|include
file|<qmath.h>
end_include
begin_include
include|#
directive|include
file|<private/qgl_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qmath_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpaintengineex_p.h>
end_include
begin_include
include|#
directive|include
file|<QPaintEngine>
end_include
begin_include
include|#
directive|include
file|<private/qpainter_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfontengine_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qdatabuffer_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qstatictext_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qtriangulator_p.h>
end_include
begin_include
include|#
directive|include
file|"qglengineshadermanager_p.h"
end_include
begin_include
include|#
directive|include
file|"qgl2pexvertexarray_p.h"
end_include
begin_include
include|#
directive|include
file|"qtextureglyphcache_gl_p.h"
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
end_ifndef
begin_include
include|#
directive|include
file|<qopenglfunctions_1_1.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|QT_BEGIN_NAMESPACE
name|Q_GUI_EXPORT
name|QImage
name|qt_imageForBrush
parameter_list|(
name|int
name|brushStyle
parameter_list|,
name|bool
name|invert
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|////////////////////////////////// Private Methods //////////////////////////////////////////
end_comment
begin_destructor
DECL|function|~QGL2PaintEngineExPrivate
name|QGL2PaintEngineExPrivate
operator|::
name|~
name|QGL2PaintEngineExPrivate
parameter_list|()
block|{
operator|delete
name|shaderManager
expr_stmt|;
while|while
condition|(
name|pathCaches
operator|.
name|size
argument_list|()
condition|)
block|{
name|QVectorPath
operator|::
name|CacheEntry
modifier|*
name|e
init|=
operator|*
operator|(
name|pathCaches
operator|.
name|constBegin
argument_list|()
operator|)
decl_stmt|;
name|e
operator|->
name|cleanup
argument_list|(
name|e
operator|->
name|engine
argument_list|,
name|e
operator|->
name|data
argument_list|)
expr_stmt|;
name|e
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|engine
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|elementIndicesVBOId
operator|!=
literal|0
condition|)
block|{
name|glDeleteBuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|elementIndicesVBOId
argument_list|)
expr_stmt|;
name|elementIndicesVBOId
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_destructor
begin_function
DECL|function|updateTextureFilter
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|updateTextureFilter
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|wrapMode
parameter_list|,
name|bool
name|smoothPixmapTransform
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
comment|//    glActiveTexture(GL_TEXTURE0 + QT_BRUSH_TEXTURE_UNIT); //### Is it always this texture unit?
if|if
condition|(
name|id
operator|!=
name|GLuint
argument_list|(
operator|-
literal|1
argument_list|)
operator|&&
name|id
operator|==
name|lastTextureUsed
condition|)
return|return;
name|lastTextureUsed
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|smoothPixmapTransform
condition|)
block|{
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|GL_LINEAR
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|GL_LINEAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
block|}
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_WRAP_S
argument_list|,
name|wrapMode
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|GL_TEXTURE_WRAP_T
argument_list|,
name|wrapMode
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_premultiplyColor
specifier|inline
name|QColor
name|qt_premultiplyColor
parameter_list|(
name|QColor
name|c
parameter_list|,
name|GLfloat
name|opacity
parameter_list|)
block|{
name|qreal
name|alpha
init|=
name|c
operator|.
name|alphaF
argument_list|()
operator|*
name|opacity
decl_stmt|;
name|c
operator|.
name|setAlphaF
argument_list|(
name|alpha
argument_list|)
expr_stmt|;
name|c
operator|.
name|setRedF
argument_list|(
name|c
operator|.
name|redF
argument_list|()
operator|*
name|alpha
argument_list|)
expr_stmt|;
name|c
operator|.
name|setGreenF
argument_list|(
name|c
operator|.
name|greenF
argument_list|()
operator|*
name|alpha
argument_list|)
expr_stmt|;
name|c
operator|.
name|setBlueF
argument_list|(
name|c
operator|.
name|blueF
argument_list|()
operator|*
name|alpha
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|setBrush
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|setBrush
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
if|if
condition|(
name|qbrush_fast_equals
argument_list|(
name|currentBrush
argument_list|,
name|brush
argument_list|)
condition|)
return|return;
specifier|const
name|Qt
operator|::
name|BrushStyle
name|newStyle
init|=
name|qbrush_style
argument_list|(
name|brush
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|newStyle
operator|!=
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
name|currentBrush
operator|=
name|brush
expr_stmt|;
if|if
condition|(
operator|!
name|currentBrushPixmap
operator|.
name|isNull
argument_list|()
condition|)
name|currentBrushPixmap
operator|=
name|QPixmap
argument_list|()
expr_stmt|;
name|brushUniformsDirty
operator|=
literal|true
expr_stmt|;
comment|// All brushes have at least one uniform
if|if
condition|(
name|newStyle
operator|>
name|Qt
operator|::
name|SolidPattern
condition|)
name|brushTextureDirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|currentBrush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|TexturePattern
operator|&&
name|qHasPixmapTexture
argument_list|(
name|brush
argument_list|)
operator|&&
name|brush
operator|.
name|texture
argument_list|()
operator|.
name|isQBitmap
argument_list|()
condition|)
block|{
name|shaderManager
operator|->
name|setSrcPixelType
argument_list|(
name|QGLEngineShaderManager
operator|::
name|TextureSrcWithPattern
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shaderManager
operator|->
name|setSrcPixelType
argument_list|(
name|newStyle
argument_list|)
expr_stmt|;
block|}
name|shaderManager
operator|->
name|optimiseForBrushTransform
argument_list|(
name|currentBrush
operator|.
name|transform
argument_list|()
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|useSimpleShader
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|useSimpleShader
parameter_list|()
block|{
name|shaderManager
operator|->
name|useSimpleProgram
argument_list|()
expr_stmt|;
if|if
condition|(
name|matrixDirty
condition|)
name|updateMatrix
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// ####TODO Properly #ifdef this class to use #define symbols actually defined
end_comment
begin_comment
comment|// by OpenGL/ES includes
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|GL_MIRRORED_REPEAT_IBM
end_ifndef
begin_define
DECL|macro|GL_MIRRORED_REPEAT_IBM
define|#
directive|define
name|GL_MIRRORED_REPEAT_IBM
value|0x8370
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|updateBrushTexture
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|updateBrushTexture
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
comment|//     qDebug("QGL2PaintEngineExPrivate::updateBrushTexture()");
name|Qt
operator|::
name|BrushStyle
name|style
init|=
name|currentBrush
operator|.
name|style
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|style
operator|>=
name|Qt
operator|::
name|Dense1Pattern
operator|)
operator|&&
operator|(
name|style
operator|<=
name|Qt
operator|::
name|DiagCrossPattern
operator|)
condition|)
block|{
comment|// Get the image data for the pattern
name|QImage
name|texImage
init|=
name|qt_imageForBrush
argument_list|(
name|style
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|QT_BRUSH_TEXTURE_UNIT
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|bindTexture
argument_list|(
name|texImage
argument_list|,
name|GL_TEXTURE_2D
argument_list|,
name|GL_RGBA
argument_list|,
name|QGLContext
operator|::
name|InternalBindOption
argument_list|)
expr_stmt|;
name|updateTextureFilter
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_REPEAT
argument_list|,
name|q
operator|->
name|state
argument_list|()
operator|->
name|renderHints
operator|&
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|>=
name|Qt
operator|::
name|LinearGradientPattern
operator|&&
name|style
operator|<=
name|Qt
operator|::
name|ConicalGradientPattern
condition|)
block|{
comment|// Gradiant brush: All the gradiants use the same texture
specifier|const
name|QGradient
modifier|*
name|g
init|=
name|currentBrush
operator|.
name|gradient
argument_list|()
decl_stmt|;
comment|// We apply global opacity in the fragment shaders, so we always pass 1.0
comment|// for opacity to the cache.
name|GLuint
name|texId
init|=
name|QGL2GradientCache
operator|::
name|cacheForContext
argument_list|(
name|ctx
argument_list|)
operator|->
name|getBuffer
argument_list|(
operator|*
name|g
argument_list|,
literal|1.0
argument_list|)
decl_stmt|;
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|QT_BRUSH_TEXTURE_UNIT
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|texId
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|spread
argument_list|()
operator|==
name|QGradient
operator|::
name|RepeatSpread
operator|||
name|g
operator|->
name|type
argument_list|()
operator|==
name|QGradient
operator|::
name|ConicalGradient
condition|)
name|updateTextureFilter
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_REPEAT
argument_list|,
name|q
operator|->
name|state
argument_list|()
operator|->
name|renderHints
operator|&
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|g
operator|->
name|spread
argument_list|()
operator|==
name|QGradient
operator|::
name|ReflectSpread
condition|)
name|updateTextureFilter
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_MIRRORED_REPEAT_IBM
argument_list|,
name|q
operator|->
name|state
argument_list|()
operator|->
name|renderHints
operator|&
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|)
expr_stmt|;
else|else
name|updateTextureFilter
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_CLAMP_TO_EDGE
argument_list|,
name|q
operator|->
name|state
argument_list|()
operator|->
name|renderHints
operator|&
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|TexturePattern
condition|)
block|{
name|currentBrushPixmap
operator|=
name|currentBrush
operator|.
name|texture
argument_list|()
expr_stmt|;
name|int
name|max_texture_size
init|=
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|maxTextureSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentBrushPixmap
operator|.
name|width
argument_list|()
operator|>
name|max_texture_size
operator|||
name|currentBrushPixmap
operator|.
name|height
argument_list|()
operator|>
name|max_texture_size
condition|)
name|currentBrushPixmap
operator|=
name|currentBrushPixmap
operator|.
name|scaled
argument_list|(
name|max_texture_size
argument_list|,
name|max_texture_size
argument_list|,
name|Qt
operator|::
name|KeepAspectRatio
argument_list|)
expr_stmt|;
name|GLuint
name|wrapMode
init|=
name|GL_REPEAT
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|contextHandle
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
comment|// OpenGL ES does not support GL_REPEAT wrap modes for NPOT textures. So instead,
comment|// we emulate GL_REPEAT by only taking the fractional part of the texture coords
comment|// in the qopenglslTextureBrushSrcFragmentShader program.
name|wrapMode
operator|=
name|GL_CLAMP_TO_EDGE
expr_stmt|;
block|}
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|QT_BRUSH_TEXTURE_UNIT
argument_list|)
expr_stmt|;
name|QGLTexture
modifier|*
name|tex
init|=
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|bindTexture
argument_list|(
name|currentBrushPixmap
argument_list|,
name|GL_TEXTURE_2D
argument_list|,
name|GL_RGBA
argument_list|,
name|QGLContext
operator|::
name|InternalBindOption
operator||
name|QGLContext
operator|::
name|CanFlipNativePixmapBindOption
argument_list|)
decl_stmt|;
name|updateTextureFilter
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|wrapMode
argument_list|,
name|q
operator|->
name|state
argument_list|()
operator|->
name|renderHints
operator|&
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|)
expr_stmt|;
name|textureInvertedY
operator|=
name|tex
operator|->
name|options
operator|&
name|QGLContext
operator|::
name|InvertedYBindOption
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
name|brushTextureDirty
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateBrushUniforms
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|updateBrushUniforms
parameter_list|()
block|{
comment|//     qDebug("QGL2PaintEngineExPrivate::updateBrushUniforms()");
name|Qt
operator|::
name|BrushStyle
name|style
init|=
name|currentBrush
operator|.
name|style
argument_list|()
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|NoBrush
condition|)
return|return;
name|QTransform
name|brushQTransform
init|=
name|currentBrush
operator|.
name|transform
argument_list|()
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|SolidPattern
condition|)
block|{
name|QColor
name|col
init|=
name|qt_premultiplyColor
argument_list|(
name|currentBrush
operator|.
name|color
argument_list|()
argument_list|,
operator|(
name|GLfloat
operator|)
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
argument_list|)
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|FragmentColor
argument_list|)
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// All other brushes have a transform and thus need the translation point:
name|QPointF
name|translationPoint
decl_stmt|;
if|if
condition|(
name|style
operator|<=
name|Qt
operator|::
name|DiagCrossPattern
condition|)
block|{
name|QColor
name|col
init|=
name|qt_premultiplyColor
argument_list|(
name|currentBrush
operator|.
name|color
argument_list|()
argument_list|,
operator|(
name|GLfloat
operator|)
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
argument_list|)
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|PatternColor
argument_list|)
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|QVector2D
name|halfViewportSize
argument_list|(
name|width
operator|*
literal|0.5
argument_list|,
name|height
operator|*
literal|0.5
argument_list|)
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|HalfViewportSize
argument_list|)
argument_list|,
name|halfViewportSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|LinearGradientPattern
condition|)
block|{
specifier|const
name|QLinearGradient
modifier|*
name|g
init|=
cast|static_cast
argument_list|<
specifier|const
name|QLinearGradient
operator|*
argument_list|>
argument_list|(
name|currentBrush
operator|.
name|gradient
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|realStart
init|=
name|g
operator|->
name|start
argument_list|()
decl_stmt|;
name|QPointF
name|realFinal
init|=
name|g
operator|->
name|finalStop
argument_list|()
decl_stmt|;
name|translationPoint
operator|=
name|realStart
expr_stmt|;
name|QPointF
name|l
init|=
name|realFinal
operator|-
name|realStart
decl_stmt|;
name|QVector3D
name|linearData
argument_list|(
name|l
operator|.
name|x
argument_list|()
argument_list|,
name|l
operator|.
name|y
argument_list|()
argument_list|,
literal|1.0f
operator|/
operator|(
name|l
operator|.
name|x
argument_list|()
operator|*
name|l
operator|.
name|x
argument_list|()
operator|+
name|l
operator|.
name|y
argument_list|()
operator|*
name|l
operator|.
name|y
argument_list|()
operator|)
argument_list|)
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|LinearData
argument_list|)
argument_list|,
name|linearData
argument_list|)
expr_stmt|;
name|QVector2D
name|halfViewportSize
argument_list|(
name|width
operator|*
literal|0.5
argument_list|,
name|height
operator|*
literal|0.5
argument_list|)
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|HalfViewportSize
argument_list|)
argument_list|,
name|halfViewportSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|ConicalGradientPattern
condition|)
block|{
specifier|const
name|QConicalGradient
modifier|*
name|g
init|=
cast|static_cast
argument_list|<
specifier|const
name|QConicalGradient
operator|*
argument_list|>
argument_list|(
name|currentBrush
operator|.
name|gradient
argument_list|()
argument_list|)
decl_stmt|;
name|translationPoint
operator|=
name|g
operator|->
name|center
argument_list|()
expr_stmt|;
name|GLfloat
name|angle
init|=
operator|-
operator|(
name|g
operator|->
name|angle
argument_list|()
operator|*
literal|2
operator|*
name|Q_PI
operator|)
operator|/
literal|360.0
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|Angle
argument_list|)
argument_list|,
name|angle
argument_list|)
expr_stmt|;
name|QVector2D
name|halfViewportSize
argument_list|(
name|width
operator|*
literal|0.5
argument_list|,
name|height
operator|*
literal|0.5
argument_list|)
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|HalfViewportSize
argument_list|)
argument_list|,
name|halfViewportSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|RadialGradientPattern
condition|)
block|{
specifier|const
name|QRadialGradient
modifier|*
name|g
init|=
cast|static_cast
argument_list|<
specifier|const
name|QRadialGradient
operator|*
argument_list|>
argument_list|(
name|currentBrush
operator|.
name|gradient
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|realCenter
init|=
name|g
operator|->
name|center
argument_list|()
decl_stmt|;
name|QPointF
name|realFocal
init|=
name|g
operator|->
name|focalPoint
argument_list|()
decl_stmt|;
name|qreal
name|realRadius
init|=
name|g
operator|->
name|centerRadius
argument_list|()
operator|-
name|g
operator|->
name|focalRadius
argument_list|()
decl_stmt|;
name|translationPoint
operator|=
name|realFocal
expr_stmt|;
name|QPointF
name|fmp
init|=
name|realCenter
operator|-
name|realFocal
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|Fmp
argument_list|)
argument_list|,
name|fmp
argument_list|)
expr_stmt|;
name|GLfloat
name|fmp2_m_radius2
init|=
operator|-
name|fmp
operator|.
name|x
argument_list|()
operator|*
name|fmp
operator|.
name|x
argument_list|()
operator|-
name|fmp
operator|.
name|y
argument_list|()
operator|*
name|fmp
operator|.
name|y
argument_list|()
operator|+
name|realRadius
operator|*
name|realRadius
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|Fmp2MRadius2
argument_list|)
argument_list|,
name|fmp2_m_radius2
argument_list|)
expr_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|Inverse2Fmp2MRadius2
argument_list|)
argument_list|,
name|GLfloat
argument_list|(
literal|1.0
operator|/
operator|(
literal|2.0
operator|*
name|fmp2_m_radius2
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|SqrFr
argument_list|)
argument_list|,
name|GLfloat
argument_list|(
name|g
operator|->
name|focalRadius
argument_list|()
operator|*
name|g
operator|->
name|focalRadius
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|BRadius
argument_list|)
argument_list|,
name|GLfloat
argument_list|(
literal|2
operator|*
operator|(
name|g
operator|->
name|centerRadius
argument_list|()
operator|-
name|g
operator|->
name|focalRadius
argument_list|()
operator|)
operator|*
name|g
operator|->
name|focalRadius
argument_list|()
argument_list|)
argument_list|,
name|g
operator|->
name|focalRadius
argument_list|()
argument_list|,
name|g
operator|->
name|centerRadius
argument_list|()
operator|-
name|g
operator|->
name|focalRadius
argument_list|()
argument_list|)
expr_stmt|;
name|QVector2D
name|halfViewportSize
argument_list|(
name|width
operator|*
literal|0.5
argument_list|,
name|height
operator|*
literal|0.5
argument_list|)
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|HalfViewportSize
argument_list|)
argument_list|,
name|halfViewportSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|TexturePattern
condition|)
block|{
specifier|const
name|QPixmap
modifier|&
name|texPixmap
init|=
name|currentBrush
operator|.
name|texture
argument_list|()
decl_stmt|;
if|if
condition|(
name|qHasPixmapTexture
argument_list|(
name|currentBrush
argument_list|)
operator|&&
name|currentBrush
operator|.
name|texture
argument_list|()
operator|.
name|isQBitmap
argument_list|()
condition|)
block|{
name|QColor
name|col
init|=
name|qt_premultiplyColor
argument_list|(
name|currentBrush
operator|.
name|color
argument_list|()
argument_list|,
operator|(
name|GLfloat
operator|)
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
argument_list|)
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|PatternColor
argument_list|)
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
name|QSizeF
name|invertedTextureSize
argument_list|(
literal|1.0
operator|/
name|texPixmap
operator|.
name|width
argument_list|()
argument_list|,
literal|1.0
operator|/
name|texPixmap
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|InvertedTextureSize
argument_list|)
argument_list|,
name|invertedTextureSize
argument_list|)
expr_stmt|;
name|QVector2D
name|halfViewportSize
argument_list|(
name|width
operator|*
literal|0.5
argument_list|,
name|height
operator|*
literal|0.5
argument_list|)
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|HalfViewportSize
argument_list|)
argument_list|,
name|halfViewportSize
argument_list|)
expr_stmt|;
block|}
else|else
name|qWarning
argument_list|(
literal|"QGL2PaintEngineEx: Unimplemented fill style"
argument_list|)
expr_stmt|;
specifier|const
name|QPointF
modifier|&
name|brushOrigin
init|=
name|q
operator|->
name|state
argument_list|()
operator|->
name|brushOrigin
decl_stmt|;
name|QTransform
name|matrix
init|=
name|q
operator|->
name|state
argument_list|()
operator|->
name|matrix
decl_stmt|;
name|matrix
operator|.
name|translate
argument_list|(
name|brushOrigin
operator|.
name|x
argument_list|()
argument_list|,
name|brushOrigin
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|QTransform
name|translate
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|-
name|translationPoint
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|translationPoint
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|qreal
name|m22
init|=
operator|-
literal|1
decl_stmt|;
name|qreal
name|dy
init|=
name|height
decl_stmt|;
if|if
condition|(
name|device
operator|->
name|isFlipped
argument_list|()
condition|)
block|{
name|m22
operator|=
literal|1
expr_stmt|;
name|dy
operator|=
literal|0
expr_stmt|;
block|}
name|QTransform
name|gl_to_qt
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m22
argument_list|,
literal|0
argument_list|,
name|dy
argument_list|)
decl_stmt|;
name|QTransform
name|inv_matrix
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|Qt
operator|::
name|TexturePattern
operator|&&
name|textureInvertedY
operator|==
operator|-
literal|1
condition|)
name|inv_matrix
operator|=
name|gl_to_qt
operator|*
operator|(
name|QTransform
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|currentBrush
operator|.
name|texture
argument_list|()
operator|.
name|height
argument_list|()
argument_list|)
operator|*
name|brushQTransform
operator|*
name|matrix
operator|)
operator|.
name|inverted
argument_list|()
operator|*
name|translate
expr_stmt|;
else|else
name|inv_matrix
operator|=
name|gl_to_qt
operator|*
operator|(
name|brushQTransform
operator|*
name|matrix
operator|)
operator|.
name|inverted
argument_list|()
operator|*
name|translate
expr_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|BrushTransform
argument_list|)
argument_list|,
name|inv_matrix
argument_list|)
expr_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|BrushTexture
argument_list|)
argument_list|,
name|QT_BRUSH_TEXTURE_UNIT
argument_list|)
expr_stmt|;
block|}
name|brushUniformsDirty
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|// This assumes the shader manager has already setup the correct shader program
end_comment
begin_function
DECL|function|updateMatrix
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|updateMatrix
parameter_list|()
block|{
comment|//     qDebug("QGL2PaintEngineExPrivate::updateMatrix()");
specifier|const
name|QTransform
modifier|&
name|transform
init|=
name|q
operator|->
name|state
argument_list|()
operator|->
name|matrix
decl_stmt|;
comment|// The projection matrix converts from Qt's coordinate system to GL's coordinate system
comment|//    * GL's viewport is 2x2, Qt's is width x height
comment|//    * GL has +y -> -y going from bottom -> top, Qt is the other way round
comment|//    * GL has [0,0] in the center, Qt has it in the top-left
comment|//
comment|// This results in the Projection matrix below, which is multiplied by the painter's
comment|// transformation matrix, as shown below:
comment|//
comment|//                Projection Matrix                      Painter Transform
comment|// ------------------------------------------------   ------------------------
comment|// | 2.0 / width  |      0.0      |     -1.0      |   |  m11  |  m21  |  dx  |
comment|// |     0.0      | -2.0 / height |      1.0      | * |  m12  |  m22  |  dy  |
comment|// |     0.0      |      0.0      |      1.0      |   |  m13  |  m23  |  m33 |
comment|// ------------------------------------------------   ------------------------
comment|//
comment|// NOTE: The resultant matrix is also transposed, as GL expects column-major matracies
specifier|const
name|GLfloat
name|wfactor
init|=
literal|2.0f
operator|/
name|width
decl_stmt|;
name|GLfloat
name|hfactor
init|=
operator|-
literal|2.0f
operator|/
name|height
decl_stmt|;
name|GLfloat
name|dx
init|=
name|transform
operator|.
name|dx
argument_list|()
decl_stmt|;
name|GLfloat
name|dy
init|=
name|transform
operator|.
name|dy
argument_list|()
decl_stmt|;
if|if
condition|(
name|device
operator|->
name|isFlipped
argument_list|()
condition|)
block|{
name|hfactor
operator|*=
operator|-
literal|1
expr_stmt|;
name|dy
operator|-=
name|height
expr_stmt|;
block|}
comment|// Non-integer translates can have strange effects for some rendering operations such as
comment|// anti-aliased text rendering. In such cases, we snap the translate to the pixel grid.
if|if
condition|(
name|snapToPixelGrid
operator|&&
name|transform
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxTranslate
condition|)
block|{
comment|// 0.50 needs to rounded down to 0.0 for consistency with raster engine:
name|dx
operator|=
name|ceilf
argument_list|(
name|dx
operator|-
literal|0.5f
argument_list|)
expr_stmt|;
name|dy
operator|=
name|ceilf
argument_list|(
name|dy
operator|-
literal|0.5f
argument_list|)
expr_stmt|;
block|}
name|pmvMatrix
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|wfactor
operator|*
name|transform
operator|.
name|m11
argument_list|()
operator|)
operator|-
name|transform
operator|.
name|m13
argument_list|()
expr_stmt|;
name|pmvMatrix
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|wfactor
operator|*
name|transform
operator|.
name|m21
argument_list|()
operator|)
operator|-
name|transform
operator|.
name|m23
argument_list|()
expr_stmt|;
name|pmvMatrix
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|wfactor
operator|*
name|dx
operator|)
operator|-
name|transform
operator|.
name|m33
argument_list|()
expr_stmt|;
name|pmvMatrix
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|hfactor
operator|*
name|transform
operator|.
name|m12
argument_list|()
operator|)
operator|+
name|transform
operator|.
name|m13
argument_list|()
expr_stmt|;
name|pmvMatrix
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|hfactor
operator|*
name|transform
operator|.
name|m22
argument_list|()
operator|)
operator|+
name|transform
operator|.
name|m23
argument_list|()
expr_stmt|;
name|pmvMatrix
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|hfactor
operator|*
name|dy
operator|)
operator|+
name|transform
operator|.
name|m33
argument_list|()
expr_stmt|;
name|pmvMatrix
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|transform
operator|.
name|m13
argument_list|()
expr_stmt|;
name|pmvMatrix
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|transform
operator|.
name|m23
argument_list|()
expr_stmt|;
name|pmvMatrix
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
name|transform
operator|.
name|m33
argument_list|()
expr_stmt|;
comment|// 1/10000 == 0.0001, so we have good enough res to cover curves
comment|// that span the entire widget...
name|inverseScale
operator|=
name|qMax
argument_list|(
literal|1
operator|/
name|qMax
argument_list|(
name|qMax
argument_list|(
name|qAbs
argument_list|(
name|transform
operator|.
name|m11
argument_list|()
argument_list|)
argument_list|,
name|qAbs
argument_list|(
name|transform
operator|.
name|m22
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|qAbs
argument_list|(
name|transform
operator|.
name|m12
argument_list|()
argument_list|)
argument_list|,
name|qAbs
argument_list|(
name|transform
operator|.
name|m21
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|0.0001
argument_list|)
argument_list|)
expr_stmt|;
name|matrixDirty
operator|=
literal|false
expr_stmt|;
name|matrixUniformDirty
operator|=
literal|true
expr_stmt|;
comment|// Set the PMV matrix attribute. As we use an attributes rather than uniforms, we only
comment|// need to do this once for every matrix change and persists across all shader programs.
name|glVertexAttrib3fv
argument_list|(
name|QT_PMV_MATRIX_1_ATTR
argument_list|,
name|pmvMatrix
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|glVertexAttrib3fv
argument_list|(
name|QT_PMV_MATRIX_2_ATTR
argument_list|,
name|pmvMatrix
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|glVertexAttrib3fv
argument_list|(
name|QT_PMV_MATRIX_3_ATTR
argument_list|,
name|pmvMatrix
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|dasher
operator|.
name|setInvScale
argument_list|(
name|inverseScale
argument_list|)
expr_stmt|;
name|stroker
operator|.
name|setInvScale
argument_list|(
name|inverseScale
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateCompositionMode
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|updateCompositionMode
parameter_list|()
block|{
comment|// NOTE: The entire paint engine works on pre-multiplied data - which is why some of these
comment|//       composition modes look odd.
comment|//     qDebug()<< "QGL2PaintEngineExPrivate::updateCompositionMode() - Setting GL composition mode for "<< q->state()->composition_mode;
switch|switch
condition|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|composition_mode
condition|)
block|{
case|case
name|QPainter
operator|::
name|CompositionMode_SourceOver
case|:
name|glBlendFunc
argument_list|(
name|GL_ONE
argument_list|,
name|GL_ONE_MINUS_SRC_ALPHA
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_DestinationOver
case|:
name|glBlendFunc
argument_list|(
name|GL_ONE_MINUS_DST_ALPHA
argument_list|,
name|GL_ONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_Clear
case|:
name|glBlendFunc
argument_list|(
name|GL_ZERO
argument_list|,
name|GL_ZERO
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_Source
case|:
name|glBlendFunc
argument_list|(
name|GL_ONE
argument_list|,
name|GL_ZERO
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_Destination
case|:
name|glBlendFunc
argument_list|(
name|GL_ZERO
argument_list|,
name|GL_ONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_SourceIn
case|:
name|glBlendFunc
argument_list|(
name|GL_DST_ALPHA
argument_list|,
name|GL_ZERO
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_DestinationIn
case|:
name|glBlendFunc
argument_list|(
name|GL_ZERO
argument_list|,
name|GL_SRC_ALPHA
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_SourceOut
case|:
name|glBlendFunc
argument_list|(
name|GL_ONE_MINUS_DST_ALPHA
argument_list|,
name|GL_ZERO
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_DestinationOut
case|:
name|glBlendFunc
argument_list|(
name|GL_ZERO
argument_list|,
name|GL_ONE_MINUS_SRC_ALPHA
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_SourceAtop
case|:
name|glBlendFunc
argument_list|(
name|GL_DST_ALPHA
argument_list|,
name|GL_ONE_MINUS_SRC_ALPHA
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_DestinationAtop
case|:
name|glBlendFunc
argument_list|(
name|GL_ONE_MINUS_DST_ALPHA
argument_list|,
name|GL_SRC_ALPHA
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_Xor
case|:
name|glBlendFunc
argument_list|(
name|GL_ONE_MINUS_DST_ALPHA
argument_list|,
name|GL_ONE_MINUS_SRC_ALPHA
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_Plus
case|:
name|glBlendFunc
argument_list|(
name|GL_ONE
argument_list|,
name|GL_ONE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"Unsupported composition mode"
argument_list|)
expr_stmt|;
break|break;
block|}
name|compositionModeDirty
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setCoords
specifier|static
specifier|inline
name|void
name|setCoords
parameter_list|(
name|GLfloat
modifier|*
name|coords
parameter_list|,
specifier|const
name|QGLRect
modifier|&
name|rect
parameter_list|)
block|{
name|coords
index|[
literal|0
index|]
operator|=
name|rect
operator|.
name|left
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|rect
operator|.
name|top
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|rect
operator|.
name|right
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|rect
operator|.
name|top
expr_stmt|;
name|coords
index|[
literal|4
index|]
operator|=
name|rect
operator|.
name|right
expr_stmt|;
name|coords
index|[
literal|5
index|]
operator|=
name|rect
operator|.
name|bottom
expr_stmt|;
name|coords
index|[
literal|6
index|]
operator|=
name|rect
operator|.
name|left
expr_stmt|;
name|coords
index|[
literal|7
index|]
operator|=
name|rect
operator|.
name|bottom
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawTexture
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|drawTexture
parameter_list|(
specifier|const
name|QGLRect
modifier|&
name|dest
parameter_list|,
specifier|const
name|QGLRect
modifier|&
name|src
parameter_list|,
specifier|const
name|QSize
modifier|&
name|textureSize
parameter_list|,
name|bool
name|opaque
parameter_list|,
name|bool
name|pattern
parameter_list|)
block|{
comment|// Setup for texture drawing
name|currentBrush
operator|=
name|noBrush
expr_stmt|;
name|shaderManager
operator|->
name|setSrcPixelType
argument_list|(
name|pattern
condition|?
name|QGLEngineShaderManager
operator|::
name|PatternSrc
else|:
name|QGLEngineShaderManager
operator|::
name|ImageSrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapToPixelGrid
condition|)
block|{
name|snapToPixelGrid
operator|=
literal|false
expr_stmt|;
name|matrixDirty
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|prepareForDraw
argument_list|(
name|opaque
argument_list|)
condition|)
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|ImageTexture
argument_list|)
argument_list|,
name|QT_IMAGE_TEXTURE_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern
condition|)
block|{
name|QColor
name|col
init|=
name|qt_premultiplyColor
argument_list|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|pen
operator|.
name|color
argument_list|()
argument_list|,
operator|(
name|GLfloat
operator|)
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
argument_list|)
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|PatternColor
argument_list|)
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
name|GLfloat
name|dx
init|=
literal|1.0
operator|/
name|textureSize
operator|.
name|width
argument_list|()
decl_stmt|;
name|GLfloat
name|dy
init|=
literal|1.0
operator|/
name|textureSize
operator|.
name|height
argument_list|()
decl_stmt|;
name|QGLRect
name|srcTextureRect
argument_list|(
name|src
operator|.
name|left
operator|*
name|dx
argument_list|,
name|src
operator|.
name|top
operator|*
name|dy
argument_list|,
name|src
operator|.
name|right
operator|*
name|dx
argument_list|,
name|src
operator|.
name|bottom
operator|*
name|dy
argument_list|)
decl_stmt|;
name|setCoords
argument_list|(
name|staticVertexCoordinateArray
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|setCoords
argument_list|(
name|staticTextureCoordinateArray
argument_list|,
name|srcTextureRect
argument_list|)
expr_stmt|;
name|glDrawArrays
argument_list|(
name|GL_TRIANGLE_FAN
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|beginNativePainting
name|void
name|QGL2PaintEngineEx
operator|::
name|beginNativePainting
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|ensureActive
argument_list|()
expr_stmt|;
name|d
operator|->
name|transferMode
argument_list|(
name|BrushDrawingMode
argument_list|)
expr_stmt|;
name|d
operator|->
name|nativePaintingActive
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|glUseProgram
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Disable all the vertex attribute arrays:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|QT_GL_VERTEX_ARRAY_TRACKED_COUNT
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|glDisableVertexAttribArray
argument_list|(
name|i
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
if|if
condition|(
operator|!
name|d
operator|->
name|ctx
operator|->
name|contextHandle
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
specifier|const
name|QGLContext
modifier|*
name|ctx
init|=
name|d
operator|->
name|ctx
decl_stmt|;
specifier|const
name|QGLFormat
modifier|&
name|fmt
init|=
name|d
operator|->
name|device
operator|->
name|format
argument_list|()
decl_stmt|;
if|if
condition|(
name|fmt
operator|.
name|majorVersion
argument_list|()
operator|<
literal|3
operator|||
operator|(
name|fmt
operator|.
name|majorVersion
argument_list|()
operator|==
literal|3
operator|&&
name|fmt
operator|.
name|minorVersion
argument_list|()
operator|<
literal|1
operator|)
operator|||
operator|(
name|fmt
operator|.
name|majorVersion
argument_list|()
operator|==
literal|3
operator|&&
name|fmt
operator|.
name|minorVersion
argument_list|()
operator|==
literal|1
operator|&&
name|ctx
operator|->
name|contextHandle
argument_list|()
operator|->
name|hasExtension
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"GL_ARB_compatibility"
argument_list|)
argument_list|)
operator|)
operator|||
name|fmt
operator|.
name|profile
argument_list|()
operator|==
name|QGLFormat
operator|::
name|CompatibilityProfile
condition|)
block|{
comment|// be nice to people who mix OpenGL 1.x code with QPainter commands
comment|// by setting modelview and projection matrices to mirror the GL 1
comment|// paint engine
specifier|const
name|QTransform
modifier|&
name|mtx
init|=
name|state
argument_list|()
operator|->
name|matrix
decl_stmt|;
name|float
name|mv_matrix
index|[
literal|4
index|]
index|[
literal|4
index|]
init|=
block|{
block|{
name|float
argument_list|(
name|mtx
operator|.
name|m11
argument_list|()
argument_list|)
block|,
name|float
argument_list|(
name|mtx
operator|.
name|m12
argument_list|()
argument_list|)
block|,
literal|0
block|,
name|float
argument_list|(
argument|mtx.m13()
argument_list|)
block|}
block|,
block|{
name|float
argument_list|(
name|mtx
operator|.
name|m21
argument_list|()
argument_list|)
block|,
name|float
argument_list|(
name|mtx
operator|.
name|m22
argument_list|()
argument_list|)
block|,
literal|0
block|,
name|float
argument_list|(
argument|mtx.m23()
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|float
argument_list|(
name|mtx
operator|.
name|dx
argument_list|()
argument_list|)
block|,
name|float
argument_list|(
name|mtx
operator|.
name|dy
argument_list|()
argument_list|)
block|,
literal|0
block|,
name|float
argument_list|(
argument|mtx.m33()
argument_list|)
block|}
block|}
decl_stmt|;
specifier|const
name|QSize
name|sz
init|=
name|d
operator|->
name|device
operator|->
name|size
argument_list|()
decl_stmt|;
name|QOpenGLFunctions_1_1
modifier|*
name|gl1funcs
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|versionFunctions
argument_list|<
name|QOpenGLFunctions_1_1
argument_list|>
argument_list|()
decl_stmt|;
name|gl1funcs
operator|->
name|initializeOpenGLFunctions
argument_list|()
expr_stmt|;
name|gl1funcs
operator|->
name|glMatrixMode
argument_list|(
name|GL_PROJECTION
argument_list|)
expr_stmt|;
name|gl1funcs
operator|->
name|glLoadIdentity
argument_list|()
expr_stmt|;
name|gl1funcs
operator|->
name|glOrtho
argument_list|(
literal|0
argument_list|,
name|sz
operator|.
name|width
argument_list|()
argument_list|,
name|sz
operator|.
name|height
argument_list|()
argument_list|,
literal|0
argument_list|,
operator|-
literal|999999
argument_list|,
literal|999999
argument_list|)
expr_stmt|;
name|gl1funcs
operator|->
name|glMatrixMode
argument_list|(
name|GL_MODELVIEW
argument_list|)
expr_stmt|;
name|gl1funcs
operator|->
name|glLoadMatrixf
argument_list|(
operator|&
name|mv_matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|d
operator|->
name|lastTextureUsed
operator|=
name|GLuint
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirtyStencilRegion
operator|=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|)
expr_stmt|;
name|d
operator|->
name|resetGLState
argument_list|()
expr_stmt|;
name|d
operator|->
name|shaderManager
operator|->
name|setDirty
argument_list|()
expr_stmt|;
name|d
operator|->
name|needsSync
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resetGLState
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|resetGLState
parameter_list|()
block|{
name|glDisable
argument_list|(
name|GL_BLEND
argument_list|)
expr_stmt|;
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
argument_list|)
expr_stmt|;
name|glDisable
argument_list|(
name|GL_STENCIL_TEST
argument_list|)
expr_stmt|;
name|glDisable
argument_list|(
name|GL_DEPTH_TEST
argument_list|)
expr_stmt|;
name|glDisable
argument_list|(
name|GL_SCISSOR_TEST
argument_list|)
expr_stmt|;
name|glDepthMask
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|glDepthFunc
argument_list|(
name|GL_LESS
argument_list|)
expr_stmt|;
name|glClearDepthf
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|glStencilMask
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
name|glStencilOp
argument_list|(
name|GL_KEEP
argument_list|,
name|GL_KEEP
argument_list|,
name|GL_KEEP
argument_list|)
expr_stmt|;
name|glStencilFunc
argument_list|(
name|GL_ALWAYS
argument_list|,
literal|0
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|setVertexAttribArrayEnabled
argument_list|(
name|QT_TEXTURE_COORDS_ATTR
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|setVertexAttribArrayEnabled
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|setVertexAttribArrayEnabled
argument_list|(
name|QT_OPACITY_ATTR
argument_list|,
literal|false
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_OPENGL_ES_2
if|if
condition|(
operator|!
name|ctx
operator|->
name|contextHandle
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
comment|// gl_Color, corresponding to vertex attribute 3, may have been changed
name|float
name|color
index|[]
init|=
block|{
literal|1.0f
block|,
literal|1.0f
block|,
literal|1.0f
block|,
literal|1.0f
block|}
decl_stmt|;
name|glVertexAttrib4fv
argument_list|(
literal|3
argument_list|,
name|color
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|endNativePainting
name|void
name|QGL2PaintEngineEx
operator|::
name|endNativePainting
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|d
operator|->
name|needsSync
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|nativePaintingActive
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|invalidateState
name|void
name|QGL2PaintEngineEx
operator|::
name|invalidateState
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|d
operator|->
name|needsSync
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isNativePaintingActive
name|bool
name|QGL2PaintEngineEx
operator|::
name|isNativePaintingActive
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativePaintingActive
return|;
block|}
end_function
begin_function
DECL|function|shouldDrawCachedGlyphs
name|bool
name|QGL2PaintEngineEx
operator|::
name|shouldDrawCachedGlyphs
parameter_list|(
name|QFontEngine
modifier|*
name|fontEngine
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|t
parameter_list|)
specifier|const
block|{
comment|// The paint engine does not support projected cached glyph drawing
if|if
condition|(
name|t
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxProject
condition|)
return|return
literal|false
return|;
comment|// The font engine might not support filling the glyph cache
comment|// with the given transform applied, in which case we need to
comment|// fall back to the QPainterPath code-path.
if|if
condition|(
operator|!
name|fontEngine
operator|->
name|supportsTransformation
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|// Except that drawing paths is slow, so for scales between
comment|// 0.5 and 2.0 we leave the glyph cache untransformed and deal
comment|// with the transform ourselves when painting, resulting in
comment|// drawing 1x cached glyphs with a smooth-scale.
name|float
name|det
init|=
name|t
operator|.
name|determinant
argument_list|()
decl_stmt|;
if|if
condition|(
name|det
operator|>=
literal|0.25f
operator|&&
name|det
operator|<=
literal|4.f
condition|)
block|{
comment|// Assuming the baseclass still agrees
return|return
name|QPaintEngineEx
operator|::
name|shouldDrawCachedGlyphs
argument_list|(
name|fontEngine
argument_list|,
name|t
argument_list|)
return|;
block|}
return|return
literal|false
return|;
comment|// Fall back to path-drawing
block|}
return|return
name|QPaintEngineEx
operator|::
name|shouldDrawCachedGlyphs
argument_list|(
name|fontEngine
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|transferMode
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|transferMode
parameter_list|(
name|EngineMode
name|newMode
parameter_list|)
block|{
if|if
condition|(
name|newMode
operator|==
name|mode
condition|)
return|return;
if|if
condition|(
name|mode
operator|==
name|TextDrawingMode
operator|||
name|mode
operator|==
name|ImageDrawingMode
operator|||
name|mode
operator|==
name|ImageArrayDrawingMode
condition|)
block|{
name|lastTextureUsed
operator|=
name|GLuint
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newMode
operator|==
name|TextDrawingMode
condition|)
block|{
name|shaderManager
operator|->
name|setHasComplexGeometry
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shaderManager
operator|->
name|setHasComplexGeometry
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newMode
operator|==
name|ImageDrawingMode
condition|)
block|{
name|setVertexAttributePointer
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|,
name|staticVertexCoordinateArray
argument_list|)
expr_stmt|;
name|setVertexAttributePointer
argument_list|(
name|QT_TEXTURE_COORDS_ATTR
argument_list|,
name|staticTextureCoordinateArray
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newMode
operator|==
name|ImageArrayDrawingMode
condition|)
block|{
name|setVertexAttributePointer
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|vertexCoordinateArray
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|setVertexAttributePointer
argument_list|(
name|QT_TEXTURE_COORDS_ATTR
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|textureCoordinateArray
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|setVertexAttributePointer
argument_list|(
name|QT_OPACITY_ATTR
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|opacityArray
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// This needs to change when we implement high-quality anti-aliasing...
if|if
condition|(
name|newMode
operator|!=
name|TextDrawingMode
condition|)
name|shaderManager
operator|->
name|setMaskType
argument_list|(
name|QGLEngineShaderManager
operator|::
name|NoMask
argument_list|)
expr_stmt|;
name|mode
operator|=
name|newMode
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|QGL2PEVectorPathCache
struct|struct
name|QGL2PEVectorPathCache
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_CACHE_AS_VBOS
DECL|member|vbo
name|GLuint
name|vbo
decl_stmt|;
DECL|member|ibo
name|GLuint
name|ibo
decl_stmt|;
else|#
directive|else
name|float
modifier|*
name|vertices
decl_stmt|;
name|void
modifier|*
name|indices
decl_stmt|;
endif|#
directive|endif
DECL|member|vertexCount
name|int
name|vertexCount
decl_stmt|;
DECL|member|indexCount
name|int
name|indexCount
decl_stmt|;
DECL|member|primitiveType
name|GLenum
name|primitiveType
decl_stmt|;
DECL|member|iscale
name|qreal
name|iscale
decl_stmt|;
DECL|member|indexType
name|QVertexIndexVector
operator|::
name|Type
name|indexType
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|cleanupVectorPath
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|cleanupVectorPath
parameter_list|(
name|QPaintEngineEx
modifier|*
name|engine
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|QGL2PEVectorPathCache
modifier|*
name|c
init|=
operator|(
name|QGL2PEVectorPathCache
operator|*
operator|)
name|data
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_OPENGL_CACHE_AS_VBOS
name|Q_ASSERT
argument_list|(
name|engine
operator|->
name|type
argument_list|()
operator|==
name|QPaintEngine
operator|::
name|OpenGL2
argument_list|)
expr_stmt|;
cast|static_cast
argument_list|<
name|QGL2PaintEngineEx
operator|*
argument_list|>
argument_list|(
name|engine
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|unusedVBOSToClean
operator|<<
name|c
operator|->
name|vbo
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ibo
condition|)
name|d
operator|->
name|unusedIBOSToClean
operator|<<
name|c
operator|->
name|ibo
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|vertices
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|indices
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|delete
name|c
expr_stmt|;
block|}
end_function
begin_comment
comment|// Assumes everything is configured for the brush you want to use
end_comment
begin_function
DECL|function|fill
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|fill
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|)
block|{
name|transferMode
argument_list|(
name|BrushDrawingMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapToPixelGrid
condition|)
block|{
name|snapToPixelGrid
operator|=
literal|false
expr_stmt|;
name|matrixDirty
operator|=
literal|true
expr_stmt|;
block|}
comment|// Might need to call updateMatrix to re-calculate inverseScale
if|if
condition|(
name|matrixDirty
condition|)
name|updateMatrix
argument_list|()
expr_stmt|;
specifier|const
name|QPointF
modifier|*
specifier|const
name|points
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|QPointF
operator|*
argument_list|>
argument_list|(
name|path
operator|.
name|points
argument_list|()
argument_list|)
decl_stmt|;
comment|// Check to see if there's any hints
if|if
condition|(
name|path
operator|.
name|shape
argument_list|()
operator|==
name|QVectorPath
operator|::
name|RectangleHint
condition|)
block|{
name|QGLRect
name|rect
argument_list|(
name|points
index|[
literal|0
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|points
index|[
literal|0
index|]
operator|.
name|y
argument_list|()
argument_list|,
name|points
index|[
literal|2
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|points
index|[
literal|2
index|]
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|prepareForDraw
argument_list|(
name|currentBrush
operator|.
name|isOpaque
argument_list|()
argument_list|)
expr_stmt|;
name|composite
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|path
operator|.
name|isConvex
argument_list|()
condition|)
block|{
if|if
condition|(
name|path
operator|.
name|isCacheable
argument_list|()
condition|)
block|{
name|QVectorPath
operator|::
name|CacheEntry
modifier|*
name|data
init|=
name|path
operator|.
name|lookupCacheData
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|QGL2PEVectorPathCache
modifier|*
name|cache
decl_stmt|;
name|bool
name|updateCache
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|data
condition|)
block|{
name|cache
operator|=
operator|(
name|QGL2PEVectorPathCache
operator|*
operator|)
name|data
operator|->
name|data
expr_stmt|;
comment|// Check if scale factor is exceeded for curved paths and generate curves if so...
if|if
condition|(
name|path
operator|.
name|isCurved
argument_list|()
condition|)
block|{
name|qreal
name|scaleFactor
init|=
name|cache
operator|->
name|iscale
operator|/
name|inverseScale
decl_stmt|;
if|if
condition|(
name|scaleFactor
argument_list|<
literal|0.5
operator|||
name|scaleFactor
argument_list|>
literal|2.0
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_CACHE_AS_VBOS
name|glDeleteBuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|cache
operator|->
name|vbo
argument_list|)
expr_stmt|;
name|cache
operator|->
name|vbo
operator|=
literal|0
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|cache
operator|->
name|ibo
operator|==
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|cache
operator|->
name|vertices
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|cache
operator|->
name|indices
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|updateCache
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|cache
operator|=
operator|new
name|QGL2PEVectorPathCache
expr_stmt|;
name|data
operator|=
cast|const_cast
argument_list|<
name|QVectorPath
operator|&
argument_list|>
argument_list|(
name|path
argument_list|)
operator|.
name|addCacheData
argument_list|(
name|q
argument_list|,
name|cache
argument_list|,
name|cleanupVectorPath
argument_list|)
expr_stmt|;
name|updateCache
operator|=
literal|true
expr_stmt|;
block|}
comment|// Flatten the path at the current scale factor and fill it into the cache struct.
if|if
condition|(
name|updateCache
condition|)
block|{
name|vertexCoordinateArray
operator|.
name|clear
argument_list|()
expr_stmt|;
name|vertexCoordinateArray
operator|.
name|addPath
argument_list|(
name|path
argument_list|,
name|inverseScale
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|vertexCount
init|=
name|vertexCoordinateArray
operator|.
name|vertexCount
argument_list|()
decl_stmt|;
name|int
name|floatSizeInBytes
init|=
name|vertexCount
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
decl_stmt|;
name|cache
operator|->
name|vertexCount
operator|=
name|vertexCount
expr_stmt|;
name|cache
operator|->
name|indexCount
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|primitiveType
operator|=
name|GL_TRIANGLE_FAN
expr_stmt|;
name|cache
operator|->
name|iscale
operator|=
name|inverseScale
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_OPENGL_CACHE_AS_VBOS
name|glGenBuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|cache
operator|->
name|vbo
argument_list|)
expr_stmt|;
name|glBindBuffer
argument_list|(
name|GL_ARRAY_BUFFER
argument_list|,
name|cache
operator|->
name|vbo
argument_list|)
expr_stmt|;
name|glBufferData
argument_list|(
name|GL_ARRAY_BUFFER
argument_list|,
name|floatSizeInBytes
argument_list|,
name|vertexCoordinateArray
operator|.
name|data
argument_list|()
argument_list|,
name|GL_STATIC_DRAW
argument_list|)
expr_stmt|;
name|cache
operator|->
name|ibo
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|cache
operator|->
name|vertices
operator|=
operator|(
name|float
operator|*
operator|)
name|malloc
argument_list|(
name|floatSizeInBytes
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cache
operator|->
name|vertices
argument_list|,
name|vertexCoordinateArray
operator|.
name|data
argument_list|()
argument_list|,
name|floatSizeInBytes
argument_list|)
expr_stmt|;
name|cache
operator|->
name|indices
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|prepareForDraw
argument_list|(
name|currentBrush
operator|.
name|isOpaque
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_OPENGL_CACHE_AS_VBOS
name|glBindBuffer
argument_list|(
name|GL_ARRAY_BUFFER
argument_list|,
name|cache
operator|->
name|vbo
argument_list|)
expr_stmt|;
name|setVertexAttributePointer
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|setVertexAttributePointer
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|,
name|cache
operator|->
name|vertices
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|glDrawArrays
argument_list|(
name|cache
operator|->
name|primitiveType
argument_list|,
literal|0
argument_list|,
name|cache
operator|->
name|vertexCount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//        printf(" - Marking path as cachable...\n");
comment|// Tag it for later so that if the same path is drawn twice, it is assumed to be static and thus cachable
name|path
operator|.
name|makeCacheable
argument_list|()
expr_stmt|;
name|vertexCoordinateArray
operator|.
name|clear
argument_list|()
expr_stmt|;
name|vertexCoordinateArray
operator|.
name|addPath
argument_list|(
name|path
argument_list|,
name|inverseScale
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|prepareForDraw
argument_list|(
name|currentBrush
operator|.
name|isOpaque
argument_list|()
argument_list|)
expr_stmt|;
name|drawVertexArrays
argument_list|(
name|vertexCoordinateArray
argument_list|,
name|GL_TRIANGLE_FAN
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bool
name|useCache
init|=
name|path
operator|.
name|isCacheable
argument_list|()
decl_stmt|;
if|if
condition|(
name|useCache
condition|)
block|{
name|QRectF
name|bbox
init|=
name|path
operator|.
name|controlPointRect
argument_list|()
decl_stmt|;
comment|// If the path doesn't fit within these limits, it is possible that the triangulation will fail.
name|useCache
operator|&=
operator|(
name|bbox
operator|.
name|left
argument_list|()
operator|>
operator|-
literal|0x8000
operator|*
name|inverseScale
operator|)
operator|&&
operator|(
name|bbox
operator|.
name|right
argument_list|()
operator|<
literal|0x8000
operator|*
name|inverseScale
operator|)
operator|&&
operator|(
name|bbox
operator|.
name|top
argument_list|()
operator|>
operator|-
literal|0x8000
operator|*
name|inverseScale
operator|)
operator|&&
operator|(
name|bbox
operator|.
name|bottom
argument_list|()
operator|<
literal|0x8000
operator|*
name|inverseScale
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|useCache
condition|)
block|{
name|QVectorPath
operator|::
name|CacheEntry
modifier|*
name|data
init|=
name|path
operator|.
name|lookupCacheData
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|QGL2PEVectorPathCache
modifier|*
name|cache
decl_stmt|;
name|bool
name|updateCache
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|data
condition|)
block|{
name|cache
operator|=
operator|(
name|QGL2PEVectorPathCache
operator|*
operator|)
name|data
operator|->
name|data
expr_stmt|;
comment|// Check if scale factor is exceeded for curved paths and generate curves if so...
if|if
condition|(
name|path
operator|.
name|isCurved
argument_list|()
condition|)
block|{
name|qreal
name|scaleFactor
init|=
name|cache
operator|->
name|iscale
operator|/
name|inverseScale
decl_stmt|;
if|if
condition|(
name|scaleFactor
argument_list|<
literal|0.5
operator|||
name|scaleFactor
argument_list|>
literal|2.0
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_OPENGL_CACHE_AS_VBOS
name|glDeleteBuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|cache
operator|->
name|vbo
argument_list|)
expr_stmt|;
name|glDeleteBuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|cache
operator|->
name|ibo
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|cache
operator|->
name|vertices
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cache
operator|->
name|indices
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|updateCache
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|cache
operator|=
operator|new
name|QGL2PEVectorPathCache
expr_stmt|;
name|data
operator|=
cast|const_cast
argument_list|<
name|QVectorPath
operator|&
argument_list|>
argument_list|(
name|path
argument_list|)
operator|.
name|addCacheData
argument_list|(
name|q
argument_list|,
name|cache
argument_list|,
name|cleanupVectorPath
argument_list|)
expr_stmt|;
name|updateCache
operator|=
literal|true
expr_stmt|;
block|}
comment|// Flatten the path at the current scale factor and fill it into the cache struct.
if|if
condition|(
name|updateCache
condition|)
block|{
name|QTriangleSet
name|polys
init|=
name|qTriangulate
argument_list|(
name|path
argument_list|,
name|QTransform
argument_list|()
operator|.
name|scale
argument_list|(
literal|1
operator|/
name|inverseScale
argument_list|,
literal|1
operator|/
name|inverseScale
argument_list|)
argument_list|)
decl_stmt|;
name|cache
operator|->
name|vertexCount
operator|=
name|polys
operator|.
name|vertices
operator|.
name|size
argument_list|()
operator|/
literal|2
expr_stmt|;
name|cache
operator|->
name|indexCount
operator|=
name|polys
operator|.
name|indices
operator|.
name|size
argument_list|()
expr_stmt|;
name|cache
operator|->
name|primitiveType
operator|=
name|GL_TRIANGLES
expr_stmt|;
name|cache
operator|->
name|iscale
operator|=
name|inverseScale
expr_stmt|;
name|cache
operator|->
name|indexType
operator|=
name|polys
operator|.
name|indices
operator|.
name|type
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_OPENGL_CACHE_AS_VBOS
name|glGenBuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|cache
operator|->
name|vbo
argument_list|)
expr_stmt|;
name|glGenBuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|cache
operator|->
name|ibo
argument_list|)
expr_stmt|;
name|glBindBuffer
argument_list|(
name|GL_ARRAY_BUFFER
argument_list|,
name|cache
operator|->
name|vbo
argument_list|)
expr_stmt|;
name|glBindBuffer
argument_list|(
name|GL_ELEMENT_ARRAY_BUFFER
argument_list|,
name|cache
operator|->
name|ibo
argument_list|)
expr_stmt|;
if|if
condition|(
name|polys
operator|.
name|indices
operator|.
name|type
argument_list|()
operator|==
name|QVertexIndexVector
operator|::
name|UnsignedInt
condition|)
name|glBufferData
argument_list|(
name|GL_ELEMENT_ARRAY_BUFFER
argument_list|,
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
operator|*
name|polys
operator|.
name|indices
operator|.
name|size
argument_list|()
argument_list|,
name|polys
operator|.
name|indices
operator|.
name|data
argument_list|()
argument_list|,
name|GL_STATIC_DRAW
argument_list|)
expr_stmt|;
else|else
name|glBufferData
argument_list|(
name|GL_ELEMENT_ARRAY_BUFFER
argument_list|,
sizeof|sizeof
argument_list|(
name|quint16
argument_list|)
operator|*
name|polys
operator|.
name|indices
operator|.
name|size
argument_list|()
argument_list|,
name|polys
operator|.
name|indices
operator|.
name|data
argument_list|()
argument_list|,
name|GL_STATIC_DRAW
argument_list|)
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|float
argument_list|>
name|vertices
argument_list|(
name|polys
operator|.
name|vertices
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|polys
operator|.
name|vertices
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|vertices
index|[
name|i
index|]
operator|=
name|float
argument_list|(
name|inverseScale
operator|*
name|polys
operator|.
name|vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|glBufferData
argument_list|(
name|GL_ARRAY_BUFFER
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
name|vertices
operator|.
name|size
argument_list|()
argument_list|,
name|vertices
operator|.
name|data
argument_list|()
argument_list|,
name|GL_STATIC_DRAW
argument_list|)
expr_stmt|;
else|#
directive|else
name|cache
operator|->
name|vertices
operator|=
operator|(
name|float
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
name|polys
operator|.
name|vertices
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|polys
operator|.
name|indices
operator|.
name|type
argument_list|()
operator|==
name|QVertexIndexVector
operator|::
name|UnsignedInt
condition|)
block|{
name|cache
operator|->
name|indices
operator|=
operator|(
name|quint32
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
operator|*
name|polys
operator|.
name|indices
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cache
operator|->
name|indices
argument_list|,
name|polys
operator|.
name|indices
operator|.
name|data
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
operator|*
name|polys
operator|.
name|indices
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cache
operator|->
name|indices
operator|=
operator|(
name|quint16
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|quint16
argument_list|)
operator|*
name|polys
operator|.
name|indices
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cache
operator|->
name|indices
argument_list|,
name|polys
operator|.
name|indices
operator|.
name|data
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|quint16
argument_list|)
operator|*
name|polys
operator|.
name|indices
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|polys
operator|.
name|vertices
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|cache
operator|->
name|vertices
index|[
name|i
index|]
operator|=
name|float
argument_list|(
name|inverseScale
operator|*
name|polys
operator|.
name|vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|prepareForDraw
argument_list|(
name|currentBrush
operator|.
name|isOpaque
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_OPENGL_CACHE_AS_VBOS
name|glBindBuffer
argument_list|(
name|GL_ARRAY_BUFFER
argument_list|,
name|cache
operator|->
name|vbo
argument_list|)
expr_stmt|;
name|glBindBuffer
argument_list|(
name|GL_ELEMENT_ARRAY_BUFFER
argument_list|,
name|cache
operator|->
name|ibo
argument_list|)
expr_stmt|;
name|setVertexAttributePointer
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|indexType
operator|==
name|QVertexIndexVector
operator|::
name|UnsignedInt
condition|)
name|glDrawElements
argument_list|(
name|cache
operator|->
name|primitiveType
argument_list|,
name|cache
operator|->
name|indexCount
argument_list|,
name|GL_UNSIGNED_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|glDrawElements
argument_list|(
name|cache
operator|->
name|primitiveType
argument_list|,
name|cache
operator|->
name|indexCount
argument_list|,
name|GL_UNSIGNED_SHORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|glBindBuffer
argument_list|(
name|GL_ELEMENT_ARRAY_BUFFER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|glBindBuffer
argument_list|(
name|GL_ARRAY_BUFFER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|setVertexAttributePointer
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|,
name|cache
operator|->
name|vertices
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|indexType
operator|==
name|QVertexIndexVector
operator|::
name|UnsignedInt
condition|)
name|glDrawElements
argument_list|(
name|cache
operator|->
name|primitiveType
argument_list|,
name|cache
operator|->
name|indexCount
argument_list|,
name|GL_UNSIGNED_INT
argument_list|,
operator|(
name|qint32
operator|*
operator|)
name|cache
operator|->
name|indices
argument_list|)
expr_stmt|;
else|else
name|glDrawElements
argument_list|(
name|cache
operator|->
name|primitiveType
argument_list|,
name|cache
operator|->
name|indexCount
argument_list|,
name|GL_UNSIGNED_SHORT
argument_list|,
operator|(
name|qint16
operator|*
operator|)
name|cache
operator|->
name|indices
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|//        printf(" - Marking path as cachable...\n");
comment|// Tag it for later so that if the same path is drawn twice, it is assumed to be static and thus cachable
name|path
operator|.
name|makeCacheable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|device
operator|->
name|format
argument_list|()
operator|.
name|stencil
argument_list|()
condition|)
block|{
comment|// If there is no stencil buffer, triangulate the path instead.
name|QRectF
name|bbox
init|=
name|path
operator|.
name|controlPointRect
argument_list|()
decl_stmt|;
comment|// If the path doesn't fit within these limits, it is possible that the triangulation will fail.
name|bool
name|withinLimits
init|=
operator|(
name|bbox
operator|.
name|left
argument_list|()
operator|>
operator|-
literal|0x8000
operator|*
name|inverseScale
operator|)
operator|&&
operator|(
name|bbox
operator|.
name|right
argument_list|()
operator|<
literal|0x8000
operator|*
name|inverseScale
operator|)
operator|&&
operator|(
name|bbox
operator|.
name|top
argument_list|()
operator|>
operator|-
literal|0x8000
operator|*
name|inverseScale
operator|)
operator|&&
operator|(
name|bbox
operator|.
name|bottom
argument_list|()
operator|<
literal|0x8000
operator|*
name|inverseScale
operator|)
decl_stmt|;
if|if
condition|(
name|withinLimits
condition|)
block|{
name|QTriangleSet
name|polys
init|=
name|qTriangulate
argument_list|(
name|path
argument_list|,
name|QTransform
argument_list|()
operator|.
name|scale
argument_list|(
literal|1
operator|/
name|inverseScale
argument_list|,
literal|1
operator|/
name|inverseScale
argument_list|)
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|float
argument_list|>
name|vertices
argument_list|(
name|polys
operator|.
name|vertices
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|polys
operator|.
name|vertices
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|vertices
index|[
name|i
index|]
operator|=
name|float
argument_list|(
name|inverseScale
operator|*
name|polys
operator|.
name|vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|prepareForDraw
argument_list|(
name|currentBrush
operator|.
name|isOpaque
argument_list|()
argument_list|)
expr_stmt|;
name|setVertexAttributePointer
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|,
name|vertices
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|polys
operator|.
name|indices
operator|.
name|type
argument_list|()
operator|==
name|QVertexIndexVector
operator|::
name|UnsignedInt
condition|)
name|glDrawElements
argument_list|(
name|GL_TRIANGLES
argument_list|,
name|polys
operator|.
name|indices
operator|.
name|size
argument_list|()
argument_list|,
name|GL_UNSIGNED_INT
argument_list|,
name|polys
operator|.
name|indices
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|glDrawElements
argument_list|(
name|GL_TRIANGLES
argument_list|,
name|polys
operator|.
name|indices
operator|.
name|size
argument_list|()
argument_list|,
name|GL_UNSIGNED_SHORT
argument_list|,
name|polys
operator|.
name|indices
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We can't handle big, concave painter paths with OpenGL without stencil buffer.
name|qWarning
argument_list|(
literal|"Painter path exceeds +/-32767 pixels."
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// The path is too complicated& needs the stencil technique
name|vertexCoordinateArray
operator|.
name|clear
argument_list|()
expr_stmt|;
name|vertexCoordinateArray
operator|.
name|addPath
argument_list|(
name|path
argument_list|,
name|inverseScale
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fillStencilWithVertexArray
argument_list|(
name|vertexCoordinateArray
argument_list|,
name|path
operator|.
name|hasWindingFill
argument_list|()
argument_list|)
expr_stmt|;
name|glStencilMask
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
name|glStencilOp
argument_list|(
name|GL_KEEP
argument_list|,
name|GL_REPLACE
argument_list|,
name|GL_REPLACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|clipTestEnabled
condition|)
block|{
comment|// Pass when high bit is set, replace stencil value with current clip
name|glStencilFunc
argument_list|(
name|GL_NOTEQUAL
argument_list|,
name|q
operator|->
name|state
argument_list|()
operator|->
name|currentClip
argument_list|,
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|path
operator|.
name|hasWindingFill
argument_list|()
condition|)
block|{
comment|// Pass when any bit is set, replace stencil value with 0
name|glStencilFunc
argument_list|(
name|GL_NOTEQUAL
argument_list|,
literal|0
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Pass when high bit is set, replace stencil value with 0
name|glStencilFunc
argument_list|(
name|GL_NOTEQUAL
argument_list|,
literal|0
argument_list|,
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
block|}
name|prepareForDraw
argument_list|(
name|currentBrush
operator|.
name|isOpaque
argument_list|()
argument_list|)
expr_stmt|;
comment|// Stencil the brush onto the dest buffer
name|composite
argument_list|(
name|vertexCoordinateArray
operator|.
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
name|glStencilMask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|updateClipScissorTest
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|fillStencilWithVertexArray
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|fillStencilWithVertexArray
parameter_list|(
specifier|const
name|float
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|stops
parameter_list|,
name|int
name|stopCount
parameter_list|,
specifier|const
name|QGLRect
modifier|&
name|bounds
parameter_list|,
name|StencilFillMode
name|mode
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|count
operator|||
name|stops
argument_list|)
expr_stmt|;
comment|//     qDebug("QGL2PaintEngineExPrivate::fillStencilWithVertexArray()");
name|glStencilMask
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
comment|// Enable stencil writes
if|if
condition|(
name|dirtyStencilRegion
operator|.
name|intersects
argument_list|(
name|currentScissorBounds
argument_list|)
condition|)
block|{
name|QVector
argument_list|<
name|QRect
argument_list|>
name|clearRegion
init|=
name|dirtyStencilRegion
operator|.
name|intersected
argument_list|(
name|currentScissorBounds
argument_list|)
operator|.
name|rects
argument_list|()
decl_stmt|;
name|glClearStencil
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Clear to zero
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clearRegion
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
ifndef|#
directive|ifndef
name|QT_GL_NO_SCISSOR_TEST
name|setScissor
argument_list|(
name|clearRegion
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|glClear
argument_list|(
name|GL_STENCIL_BUFFER_BIT
argument_list|)
expr_stmt|;
block|}
name|dirtyStencilRegion
operator|-=
name|currentScissorBounds
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_GL_NO_SCISSOR_TEST
name|updateClipScissorTest
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|glColorMask
argument_list|(
name|GL_FALSE
argument_list|,
name|GL_FALSE
argument_list|,
name|GL_FALSE
argument_list|,
name|GL_FALSE
argument_list|)
expr_stmt|;
comment|// Disable color writes
name|useSimpleShader
argument_list|()
expr_stmt|;
name|glEnable
argument_list|(
name|GL_STENCIL_TEST
argument_list|)
expr_stmt|;
comment|// For some reason, this has to happen _after_ the simple shader is use()'d
if|if
condition|(
name|mode
operator|==
name|WindingFillMode
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|stops
operator|&&
operator|!
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|clipTestEnabled
condition|)
block|{
comment|// Flatten clip values higher than current clip, and set high bit to match current clip
name|glStencilFunc
argument_list|(
name|GL_LEQUAL
argument_list|,
name|GL_STENCIL_HIGH_BIT
operator||
name|q
operator|->
name|state
argument_list|()
operator|->
name|currentClip
argument_list|,
operator|~
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
name|glStencilOp
argument_list|(
name|GL_KEEP
argument_list|,
name|GL_REPLACE
argument_list|,
name|GL_REPLACE
argument_list|)
expr_stmt|;
name|composite
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
name|glStencilFunc
argument_list|(
name|GL_EQUAL
argument_list|,
name|GL_STENCIL_HIGH_BIT
argument_list|,
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|stencilClean
condition|)
block|{
comment|// Clear stencil buffer within bounding rect
name|glStencilFunc
argument_list|(
name|GL_ALWAYS
argument_list|,
literal|0
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|glStencilOp
argument_list|(
name|GL_ZERO
argument_list|,
name|GL_ZERO
argument_list|,
name|GL_ZERO
argument_list|)
expr_stmt|;
name|composite
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
block|}
comment|// Inc. for front-facing triangle
name|glStencilOpSeparate
argument_list|(
name|GL_FRONT
argument_list|,
name|GL_KEEP
argument_list|,
name|GL_INCR_WRAP
argument_list|,
name|GL_INCR_WRAP
argument_list|)
expr_stmt|;
comment|// Dec. for back-facing "holes"
name|glStencilOpSeparate
argument_list|(
name|GL_BACK
argument_list|,
name|GL_KEEP
argument_list|,
name|GL_DECR_WRAP
argument_list|,
name|GL_DECR_WRAP
argument_list|)
expr_stmt|;
name|glStencilMask
argument_list|(
operator|~
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
name|drawVertexArrays
argument_list|(
name|data
argument_list|,
name|stops
argument_list|,
name|stopCount
argument_list|,
name|GL_TRIANGLE_FAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|clipTestEnabled
condition|)
block|{
comment|// Clear high bit of stencil outside of path
name|glStencilFunc
argument_list|(
name|GL_EQUAL
argument_list|,
name|q
operator|->
name|state
argument_list|()
operator|->
name|currentClip
argument_list|,
operator|~
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
name|glStencilOp
argument_list|(
name|GL_KEEP
argument_list|,
name|GL_REPLACE
argument_list|,
name|GL_REPLACE
argument_list|)
expr_stmt|;
name|glStencilMask
argument_list|(
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
name|composite
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|OddEvenFillMode
condition|)
block|{
name|glStencilMask
argument_list|(
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
name|glStencilOp
argument_list|(
name|GL_KEEP
argument_list|,
name|GL_KEEP
argument_list|,
name|GL_INVERT
argument_list|)
expr_stmt|;
comment|// Simply invert the stencil bit
name|drawVertexArrays
argument_list|(
name|data
argument_list|,
name|stops
argument_list|,
name|stopCount
argument_list|,
name|GL_TRIANGLE_FAN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TriStripStrokeFillMode
name|Q_ASSERT
argument_list|(
name|count
operator|&&
operator|!
name|stops
argument_list|)
expr_stmt|;
comment|// tristrips generated directly, so no vertexArray or stops
name|glStencilMask
argument_list|(
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|glStencilOp(GL_KEEP, GL_KEEP, GL_INVERT);
comment|// Simply invert the stencil bit
block|setVertexAttributePointer(QT_VERTEX_COORDS_ATTR, data);         glDrawArrays(GL_TRIANGLE_STRIP, 0, count);
else|#
directive|else
name|glStencilOp
argument_list|(
name|GL_KEEP
argument_list|,
name|GL_KEEP
argument_list|,
name|GL_REPLACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|clipTestEnabled
condition|)
block|{
name|glStencilFunc
argument_list|(
name|GL_LEQUAL
argument_list|,
name|q
operator|->
name|state
argument_list|()
operator|->
name|currentClip
operator||
name|GL_STENCIL_HIGH_BIT
argument_list|,
operator|~
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glStencilFunc
argument_list|(
name|GL_ALWAYS
argument_list|,
name|GL_STENCIL_HIGH_BIT
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|setVertexAttributePointer
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|glDrawArrays
argument_list|(
name|GL_TRIANGLE_STRIP
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|// Enable color writes& disable stencil writes
name|glColorMask
argument_list|(
name|GL_TRUE
argument_list|,
name|GL_TRUE
argument_list|,
name|GL_TRUE
argument_list|,
name|GL_TRUE
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     If the maximum value in the stencil buffer is GL_STENCIL_HIGH_BIT - 1,     restore the stencil buffer to a pristine state.  The current clip region     is set to 1, and the rest to 0. */
end_comment
begin_function
DECL|function|resetClipIfNeeded
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|resetClipIfNeeded
parameter_list|()
block|{
if|if
condition|(
name|maxClip
operator|!=
operator|(
name|GL_STENCIL_HIGH_BIT
operator|-
literal|1
operator|)
condition|)
return|return;
name|Q_Q
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|useSimpleShader
argument_list|()
expr_stmt|;
name|glEnable
argument_list|(
name|GL_STENCIL_TEST
argument_list|)
expr_stmt|;
name|glColorMask
argument_list|(
name|GL_FALSE
argument_list|,
name|GL_FALSE
argument_list|,
name|GL_FALSE
argument_list|,
name|GL_FALSE
argument_list|)
expr_stmt|;
name|QRectF
name|bounds
init|=
name|q
operator|->
name|state
argument_list|()
operator|->
name|matrix
operator|.
name|inverted
argument_list|()
operator|.
name|mapRect
argument_list|(
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
decl_stmt|;
name|QGLRect
name|rect
argument_list|(
name|bounds
operator|.
name|left
argument_list|()
argument_list|,
name|bounds
operator|.
name|top
argument_list|()
argument_list|,
name|bounds
operator|.
name|right
argument_list|()
argument_list|,
name|bounds
operator|.
name|bottom
argument_list|()
argument_list|)
decl_stmt|;
comment|// Set high bit on clip region
name|glStencilFunc
argument_list|(
name|GL_LEQUAL
argument_list|,
name|q
operator|->
name|state
argument_list|()
operator|->
name|currentClip
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|glStencilOp
argument_list|(
name|GL_KEEP
argument_list|,
name|GL_INVERT
argument_list|,
name|GL_INVERT
argument_list|)
expr_stmt|;
name|glStencilMask
argument_list|(
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
name|composite
argument_list|(
name|rect
argument_list|)
expr_stmt|;
comment|// Reset clipping to 1 and everything else to zero
name|glStencilFunc
argument_list|(
name|GL_NOTEQUAL
argument_list|,
literal|0x01
argument_list|,
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
name|glStencilOp
argument_list|(
name|GL_ZERO
argument_list|,
name|GL_REPLACE
argument_list|,
name|GL_REPLACE
argument_list|)
expr_stmt|;
name|glStencilMask
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
name|composite
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|q
operator|->
name|state
argument_list|()
operator|->
name|currentClip
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|state
argument_list|()
operator|->
name|canRestoreClip
operator|=
literal|false
expr_stmt|;
name|maxClip
operator|=
literal|1
expr_stmt|;
name|glStencilMask
argument_list|(
literal|0x0
argument_list|)
expr_stmt|;
name|glColorMask
argument_list|(
name|GL_TRUE
argument_list|,
name|GL_TRUE
argument_list|,
name|GL_TRUE
argument_list|,
name|GL_TRUE
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepareForCachedGlyphDraw
name|bool
name|QGL2PaintEngineExPrivate
operator|::
name|prepareForCachedGlyphDraw
parameter_list|(
specifier|const
name|QFontEngineGlyphCache
modifier|&
name|cache
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|cache
operator|.
name|transform
argument_list|()
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
argument_list|)
expr_stmt|;
name|QTransform
modifier|&
name|transform
init|=
name|q
operator|->
name|state
argument_list|()
operator|->
name|matrix
decl_stmt|;
name|transform
operator|.
name|scale
argument_list|(
literal|1.0
operator|/
name|cache
operator|.
name|transform
argument_list|()
operator|.
name|m11
argument_list|()
argument_list|,
literal|1.0
operator|/
name|cache
operator|.
name|transform
argument_list|()
operator|.
name|m22
argument_list|()
argument_list|)
expr_stmt|;
name|bool
name|ret
init|=
name|prepareForDraw
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|transform
operator|.
name|scale
argument_list|(
name|cache
operator|.
name|transform
argument_list|()
operator|.
name|m11
argument_list|()
argument_list|,
name|cache
operator|.
name|transform
argument_list|()
operator|.
name|m22
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|prepareForDraw
name|bool
name|QGL2PaintEngineExPrivate
operator|::
name|prepareForDraw
parameter_list|(
name|bool
name|srcPixelsAreOpaque
parameter_list|)
block|{
if|if
condition|(
name|brushTextureDirty
operator|&&
name|mode
operator|!=
name|ImageDrawingMode
operator|&&
name|mode
operator|!=
name|ImageArrayDrawingMode
condition|)
name|updateBrushTexture
argument_list|()
expr_stmt|;
if|if
condition|(
name|compositionModeDirty
condition|)
name|updateCompositionMode
argument_list|()
expr_stmt|;
if|if
condition|(
name|matrixDirty
condition|)
name|updateMatrix
argument_list|()
expr_stmt|;
specifier|const
name|bool
name|stateHasOpacity
init|=
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
operator|<
literal|0.99f
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|composition_mode
operator|==
name|QPainter
operator|::
name|CompositionMode_Source
operator|||
operator|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|composition_mode
operator|==
name|QPainter
operator|::
name|CompositionMode_SourceOver
operator|&&
name|srcPixelsAreOpaque
operator|&&
operator|!
name|stateHasOpacity
operator|)
condition|)
block|{
name|glDisable
argument_list|(
name|GL_BLEND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glEnable
argument_list|(
name|GL_BLEND
argument_list|)
expr_stmt|;
block|}
name|QGLEngineShaderManager
operator|::
name|OpacityMode
name|opacityMode
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|ImageArrayDrawingMode
condition|)
block|{
name|opacityMode
operator|=
name|QGLEngineShaderManager
operator|::
name|AttributeOpacity
expr_stmt|;
block|}
else|else
block|{
name|opacityMode
operator|=
name|stateHasOpacity
condition|?
name|QGLEngineShaderManager
operator|::
name|UniformOpacity
else|:
name|QGLEngineShaderManager
operator|::
name|NoOpacity
expr_stmt|;
if|if
condition|(
name|stateHasOpacity
operator|&&
operator|(
name|mode
operator|!=
name|ImageDrawingMode
operator|)
condition|)
block|{
comment|// Using a brush
name|bool
name|brushIsPattern
init|=
operator|(
name|currentBrush
operator|.
name|style
argument_list|()
operator|>=
name|Qt
operator|::
name|Dense1Pattern
operator|)
operator|&&
operator|(
name|currentBrush
operator|.
name|style
argument_list|()
operator|<=
name|Qt
operator|::
name|DiagCrossPattern
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|currentBrush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|SolidPattern
operator|)
operator|||
name|brushIsPattern
condition|)
name|opacityMode
operator|=
name|QGLEngineShaderManager
operator|::
name|NoOpacity
expr_stmt|;
comment|// Global opacity handled by srcPixel shader
block|}
block|}
name|shaderManager
operator|->
name|setOpacityMode
argument_list|(
name|opacityMode
argument_list|)
expr_stmt|;
name|bool
name|changed
init|=
name|shaderManager
operator|->
name|useCorrectShaderProg
argument_list|()
decl_stmt|;
comment|// If the shader program needs changing, we change it and mark all uniforms as dirty
if|if
condition|(
name|changed
condition|)
block|{
comment|// The shader program has changed so mark all uniforms as dirty:
name|brushUniformsDirty
operator|=
literal|true
expr_stmt|;
name|opacityUniformDirty
operator|=
literal|true
expr_stmt|;
name|matrixUniformDirty
operator|=
literal|true
expr_stmt|;
name|translateZUniformDirty
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|brushUniformsDirty
operator|&&
name|mode
operator|!=
name|ImageDrawingMode
operator|&&
name|mode
operator|!=
name|ImageArrayDrawingMode
condition|)
name|updateBrushUniforms
argument_list|()
expr_stmt|;
if|if
condition|(
name|opacityMode
operator|==
name|QGLEngineShaderManager
operator|::
name|UniformOpacity
operator|&&
name|opacityUniformDirty
condition|)
block|{
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|GlobalOpacity
argument_list|)
argument_list|,
operator|(
name|GLfloat
operator|)
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
argument_list|)
expr_stmt|;
name|opacityUniformDirty
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|matrixUniformDirty
operator|&&
name|shaderManager
operator|->
name|hasComplexGeometry
argument_list|()
condition|)
block|{
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|Matrix
argument_list|)
argument_list|,
name|pmvMatrix
argument_list|)
expr_stmt|;
name|matrixUniformDirty
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|translateZUniformDirty
operator|&&
name|shaderManager
operator|->
name|hasComplexGeometry
argument_list|()
condition|)
block|{
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|TranslateZ
argument_list|)
argument_list|,
name|translateZ
argument_list|)
expr_stmt|;
name|translateZUniformDirty
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function
begin_function
DECL|function|composite
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|composite
parameter_list|(
specifier|const
name|QGLRect
modifier|&
name|boundingRect
parameter_list|)
block|{
name|setCoords
argument_list|(
name|staticVertexCoordinateArray
argument_list|,
name|boundingRect
argument_list|)
expr_stmt|;
name|setVertexAttributePointer
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|,
name|staticVertexCoordinateArray
argument_list|)
expr_stmt|;
name|glDrawArrays
argument_list|(
name|GL_TRIANGLE_FAN
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Draws the vertex array as a set of<vertexArrayStops.size()> triangle fans.
end_comment
begin_function
DECL|function|drawVertexArrays
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|drawVertexArrays
parameter_list|(
specifier|const
name|float
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|stops
parameter_list|,
name|int
name|stopCount
parameter_list|,
name|GLenum
name|primitive
parameter_list|)
block|{
comment|// Now setup the pointer to the vertex array:
name|setVertexAttributePointer
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|int
name|previousStop
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stopCount
condition|;
operator|++
name|i
control|)
block|{
name|int
name|stop
init|=
name|stops
index|[
name|i
index|]
decl_stmt|;
comment|/*         qDebug("Drawing triangle fan for vertecies %d -> %d:", previousStop, stop-1);         for (int i=previousStop; i<stop; ++i)             qDebug("   %02d: [%.2f, %.2f]", i, vertexArray.data()[i].x, vertexArray.data()[i].y); */
name|glDrawArrays
argument_list|(
name|primitive
argument_list|,
name|previousStop
argument_list|,
name|stop
operator|-
name|previousStop
argument_list|)
expr_stmt|;
name|previousStop
operator|=
name|stop
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/////////////////////////////////// Public Methods //////////////////////////////////////////
end_comment
begin_constructor
DECL|function|QGL2PaintEngineEx
name|QGL2PaintEngineEx
operator|::
name|QGL2PaintEngineEx
parameter_list|()
member_init_list|:
name|QPaintEngineEx
argument_list|(
operator|*
operator|(
operator|new
name|QGL2PaintEngineExPrivate
argument_list|(
name|this
argument_list|)
operator|)
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QGL2PaintEngineEx
name|QGL2PaintEngineEx
operator|::
name|~
name|QGL2PaintEngineEx
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|fill
name|void
name|QGL2PaintEngineEx
operator|::
name|fill
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbrush_style
argument_list|(
name|brush
argument_list|)
operator|==
name|Qt
operator|::
name|NoBrush
condition|)
return|return;
name|ensureActive
argument_list|()
expr_stmt|;
name|d
operator|->
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|d
operator|->
name|fill
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function
begin_function_decl
name|Q_GUI_EXPORT
name|bool
name|qt_scaleForTransform
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|,
name|qreal
modifier|*
name|scale
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|// qtransform.cpp
end_comment
begin_function
DECL|function|stroke
name|void
name|QGL2PaintEngineEx
operator|::
name|stroke
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
specifier|const
name|QBrush
modifier|&
name|penBrush
init|=
name|qpen_brush
argument_list|(
name|pen
argument_list|)
decl_stmt|;
if|if
condition|(
name|qpen_style
argument_list|(
name|pen
argument_list|)
operator|==
name|Qt
operator|::
name|NoPen
operator|||
name|qbrush_style
argument_list|(
name|penBrush
argument_list|)
operator|==
name|Qt
operator|::
name|NoBrush
condition|)
return|return;
name|QGL2PaintEngineState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
if|if
condition|(
name|qt_pen_is_cosmetic
argument_list|(
name|pen
argument_list|,
name|s
operator|->
name|renderHints
argument_list|)
operator|&&
operator|!
name|qt_scaleForTransform
argument_list|(
name|s
operator|->
name|transform
argument_list|()
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|// QTriangulatingStroker class is not meant to support cosmetically sheared strokes.
name|QPaintEngineEx
operator|::
name|stroke
argument_list|(
name|path
argument_list|,
name|pen
argument_list|)
expr_stmt|;
return|return;
block|}
name|ensureActive
argument_list|()
expr_stmt|;
name|d
operator|->
name|setBrush
argument_list|(
name|penBrush
argument_list|)
expr_stmt|;
name|d
operator|->
name|stroke
argument_list|(
name|path
argument_list|,
name|pen
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stroke
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|stroke
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
block|{
specifier|const
name|QGL2PaintEngineState
modifier|*
name|s
init|=
name|q
operator|->
name|state
argument_list|()
decl_stmt|;
if|if
condition|(
name|snapToPixelGrid
condition|)
block|{
name|snapToPixelGrid
operator|=
literal|false
expr_stmt|;
name|matrixDirty
operator|=
literal|true
expr_stmt|;
block|}
specifier|const
name|Qt
operator|::
name|PenStyle
name|penStyle
init|=
name|qpen_style
argument_list|(
name|pen
argument_list|)
decl_stmt|;
specifier|const
name|QBrush
modifier|&
name|penBrush
init|=
name|qpen_brush
argument_list|(
name|pen
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|opaque
init|=
name|penBrush
operator|.
name|isOpaque
argument_list|()
operator|&&
name|s
operator|->
name|opacity
operator|>
literal|0.99
decl_stmt|;
name|transferMode
argument_list|(
name|BrushDrawingMode
argument_list|)
expr_stmt|;
comment|// updateMatrix() is responsible for setting the inverse scale on
comment|// the strokers, so we need to call it here and not wait for
comment|// prepareForDraw() down below.
name|updateMatrix
argument_list|()
expr_stmt|;
name|QRectF
name|clip
init|=
name|q
operator|->
name|state
argument_list|()
operator|->
name|matrix
operator|.
name|inverted
argument_list|()
operator|.
name|mapRect
argument_list|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|clipEnabled
condition|?
name|q
operator|->
name|state
argument_list|()
operator|->
name|rectangleClip
else|:
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|penStyle
operator|==
name|Qt
operator|::
name|SolidLine
condition|)
block|{
name|stroker
operator|.
name|process
argument_list|(
name|path
argument_list|,
name|pen
argument_list|,
name|clip
argument_list|,
name|s
operator|->
name|renderHints
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Some sort of dash
name|dasher
operator|.
name|process
argument_list|(
name|path
argument_list|,
name|pen
argument_list|,
name|clip
argument_list|,
name|s
operator|->
name|renderHints
argument_list|)
expr_stmt|;
name|QVectorPath
name|dashStroke
argument_list|(
name|dasher
operator|.
name|points
argument_list|()
argument_list|,
name|dasher
operator|.
name|elementCount
argument_list|()
argument_list|,
name|dasher
operator|.
name|elementTypes
argument_list|()
argument_list|)
decl_stmt|;
name|stroker
operator|.
name|process
argument_list|(
name|dashStroke
argument_list|,
name|pen
argument_list|,
name|clip
argument_list|,
name|s
operator|->
name|renderHints
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stroker
operator|.
name|vertexCount
argument_list|()
condition|)
return|return;
if|if
condition|(
name|opaque
condition|)
block|{
name|prepareForDraw
argument_list|(
name|opaque
argument_list|)
expr_stmt|;
name|setVertexAttributePointer
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|,
name|stroker
operator|.
name|vertices
argument_list|()
argument_list|)
expr_stmt|;
name|glDrawArrays
argument_list|(
name|GL_TRIANGLE_STRIP
argument_list|,
literal|0
argument_list|,
name|stroker
operator|.
name|vertexCount
argument_list|()
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|//         QBrush b(Qt::green);
comment|//         d->setBrush(&b);
comment|//         d->prepareForDraw(true);
comment|//         glDrawArrays(GL_LINE_STRIP, 0, d->stroker.vertexCount() / 2);
block|}
else|else
block|{
name|qreal
name|width
init|=
name|qpen_widthf
argument_list|(
name|pen
argument_list|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
name|width
operator|=
literal|0.5
expr_stmt|;
name|qreal
name|extra
init|=
name|pen
operator|.
name|joinStyle
argument_list|()
operator|==
name|Qt
operator|::
name|MiterJoin
condition|?
name|qMax
argument_list|(
name|pen
operator|.
name|miterLimit
argument_list|()
operator|*
name|width
argument_list|,
name|width
argument_list|)
else|:
name|width
decl_stmt|;
if|if
condition|(
name|qt_pen_is_cosmetic
argument_list|(
name|pen
argument_list|,
name|s
operator|->
name|renderHints
argument_list|)
condition|)
name|extra
operator|=
name|extra
operator|*
name|inverseScale
expr_stmt|;
name|QRectF
name|bounds
init|=
name|path
operator|.
name|controlPointRect
argument_list|()
operator|.
name|adjusted
argument_list|(
operator|-
name|extra
argument_list|,
operator|-
name|extra
argument_list|,
name|extra
argument_list|,
name|extra
argument_list|)
decl_stmt|;
name|fillStencilWithVertexArray
argument_list|(
name|stroker
operator|.
name|vertices
argument_list|()
argument_list|,
name|stroker
operator|.
name|vertexCount
argument_list|()
operator|/
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|bounds
argument_list|,
name|QGL2PaintEngineExPrivate
operator|::
name|TriStripStrokeFillMode
argument_list|)
expr_stmt|;
name|glStencilOp
argument_list|(
name|GL_KEEP
argument_list|,
name|GL_REPLACE
argument_list|,
name|GL_REPLACE
argument_list|)
expr_stmt|;
comment|// Pass when any bit is set, replace stencil value with 0
name|glStencilFunc
argument_list|(
name|GL_NOTEQUAL
argument_list|,
literal|0
argument_list|,
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
name|prepareForDraw
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Stencil the brush onto the dest buffer
name|composite
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
name|glStencilMask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|updateClipScissorTest
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|penChanged
name|void
name|QGL2PaintEngineEx
operator|::
name|penChanged
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|brushChanged
name|void
name|QGL2PaintEngineEx
operator|::
name|brushChanged
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|brushOriginChanged
name|void
name|QGL2PaintEngineEx
operator|::
name|brushOriginChanged
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|opacityChanged
name|void
name|QGL2PaintEngineEx
operator|::
name|opacityChanged
parameter_list|()
block|{
comment|//    qDebug("QGL2PaintEngineEx::opacityChanged()");
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|state
argument_list|()
operator|->
name|opacityChanged
operator|=
literal|true
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|shaderManager
argument_list|)
expr_stmt|;
name|d
operator|->
name|brushUniformsDirty
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|opacityUniformDirty
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|compositionModeChanged
name|void
name|QGL2PaintEngineEx
operator|::
name|compositionModeChanged
parameter_list|()
block|{
comment|//     qDebug("QGL2PaintEngineEx::compositionModeChanged()");
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|state
argument_list|()
operator|->
name|compositionModeChanged
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|compositionModeDirty
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|renderHintsChanged
name|void
name|QGL2PaintEngineEx
operator|::
name|renderHintsChanged
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|state
argument_list|()
operator|->
name|renderHintsChanged
operator|=
literal|true
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|d
operator|->
name|ctx
operator|->
name|contextHandle
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|state
argument_list|()
operator|->
name|renderHints
operator|&
name|QPainter
operator|::
name|Antialiasing
operator|)
operator|||
operator|(
name|state
argument_list|()
operator|->
name|renderHints
operator|&
name|QPainter
operator|::
name|HighQualityAntialiasing
operator|)
condition|)
name|d
operator|->
name|glEnable
argument_list|(
name|GL_MULTISAMPLE
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|glDisable
argument_list|(
name|GL_MULTISAMPLE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|d
operator|->
name|lastTextureUsed
operator|=
name|GLuint
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|brushTextureDirty
operator|=
literal|true
expr_stmt|;
comment|//    qDebug("QGL2PaintEngineEx::renderHintsChanged() not implemented!");
block|}
end_function
begin_function
DECL|function|transformChanged
name|void
name|QGL2PaintEngineEx
operator|::
name|transformChanged
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|d
operator|->
name|matrixDirty
operator|=
literal|true
expr_stmt|;
name|state
argument_list|()
operator|->
name|matrixChanged
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|scaleRect
specifier|static
specifier|const
name|QRectF
name|scaleRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
name|qreal
name|sx
parameter_list|,
name|qreal
name|sy
parameter_list|)
block|{
return|return
name|QRectF
argument_list|(
name|r
operator|.
name|x
argument_list|()
operator|*
name|sx
argument_list|,
name|r
operator|.
name|y
argument_list|()
operator|*
name|sy
argument_list|,
name|r
operator|.
name|width
argument_list|()
operator|*
name|sx
argument_list|,
name|r
operator|.
name|height
argument_list|()
operator|*
name|sy
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|drawPixmap
name|void
name|QGL2PaintEngineEx
operator|::
name|drawPixmap
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|dest
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|src
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|QGLContext
modifier|*
name|ctx
init|=
name|d
operator|->
name|ctx
decl_stmt|;
name|int
name|max_texture_size
init|=
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|maxTextureSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|pixmap
operator|.
name|width
argument_list|()
operator|>
name|max_texture_size
operator|||
name|pixmap
operator|.
name|height
argument_list|()
operator|>
name|max_texture_size
condition|)
block|{
name|QPixmap
name|scaled
init|=
name|pixmap
operator|.
name|scaled
argument_list|(
name|max_texture_size
argument_list|,
name|max_texture_size
argument_list|,
name|Qt
operator|::
name|KeepAspectRatio
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|sx
init|=
name|scaled
operator|.
name|width
argument_list|()
operator|/
name|qreal
argument_list|(
name|pixmap
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|sy
init|=
name|scaled
operator|.
name|height
argument_list|()
operator|/
name|qreal
argument_list|(
name|pixmap
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|drawPixmap
argument_list|(
name|dest
argument_list|,
name|scaled
argument_list|,
name|scaleRect
argument_list|(
name|src
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ensureActive
argument_list|()
expr_stmt|;
name|d
operator|->
name|transferMode
argument_list|(
name|ImageDrawingMode
argument_list|)
expr_stmt|;
name|QGLContext
operator|::
name|BindOptions
name|bindOptions
init|=
name|QGLContext
operator|::
name|InternalBindOption
operator||
name|QGLContext
operator|::
name|CanFlipNativePixmapBindOption
decl_stmt|;
ifdef|#
directive|ifdef
name|QGL_USE_TEXTURE_POOL
name|bindOptions
operator||=
name|QGLContext
operator|::
name|TemporarilyCachedBindOption
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|QT_IMAGE_TEXTURE_UNIT
argument_list|)
expr_stmt|;
name|QGLTexture
modifier|*
name|texture
init|=
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|bindTexture
argument_list|(
name|pixmap
argument_list|,
name|GL_TEXTURE_2D
argument_list|,
name|GL_RGBA
argument_list|,
name|bindOptions
argument_list|)
decl_stmt|;
name|GLfloat
name|top
init|=
name|texture
operator|->
name|options
operator|&
name|QGLContext
operator|::
name|InvertedYBindOption
condition|?
operator|(
name|pixmap
operator|.
name|height
argument_list|()
operator|-
name|src
operator|.
name|top
argument_list|()
operator|)
else|:
name|src
operator|.
name|top
argument_list|()
decl_stmt|;
name|GLfloat
name|bottom
init|=
name|texture
operator|->
name|options
operator|&
name|QGLContext
operator|::
name|InvertedYBindOption
condition|?
operator|(
name|pixmap
operator|.
name|height
argument_list|()
operator|-
name|src
operator|.
name|bottom
argument_list|()
operator|)
else|:
name|src
operator|.
name|bottom
argument_list|()
decl_stmt|;
name|QGLRect
name|srcRect
argument_list|(
name|src
operator|.
name|left
argument_list|()
argument_list|,
name|top
argument_list|,
name|src
operator|.
name|right
argument_list|()
argument_list|,
name|bottom
argument_list|)
decl_stmt|;
name|bool
name|isBitmap
init|=
name|pixmap
operator|.
name|isQBitmap
argument_list|()
decl_stmt|;
name|bool
name|isOpaque
init|=
operator|!
name|isBitmap
operator|&&
operator|!
name|pixmap
operator|.
name|hasAlpha
argument_list|()
decl_stmt|;
name|d
operator|->
name|updateTextureFilter
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_CLAMP_TO_EDGE
argument_list|,
name|state
argument_list|()
operator|->
name|renderHints
operator|&
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|,
name|texture
operator|->
name|id
argument_list|)
expr_stmt|;
name|d
operator|->
name|drawTexture
argument_list|(
name|dest
argument_list|,
name|srcRect
argument_list|,
name|pixmap
operator|.
name|size
argument_list|()
argument_list|,
name|isOpaque
argument_list|,
name|isBitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|texture
operator|->
name|options
operator|&
name|QGLContext
operator|::
name|TemporarilyCachedBindOption
condition|)
block|{
comment|// pixmap was temporarily cached as a QImage texture by pooling system
comment|// and should be destroyed immediately
name|QGLTextureCache
operator|::
name|instance
argument_list|()
operator|->
name|remove
argument_list|(
name|ctx
argument_list|,
name|texture
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|drawImage
name|void
name|QGL2PaintEngineEx
operator|::
name|drawImage
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|dest
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|QGLContext
modifier|*
name|ctx
init|=
name|d
operator|->
name|ctx
decl_stmt|;
name|int
name|max_texture_size
init|=
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|maxTextureSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|image
operator|.
name|width
argument_list|()
operator|>
name|max_texture_size
operator|||
name|image
operator|.
name|height
argument_list|()
operator|>
name|max_texture_size
condition|)
block|{
name|QImage
name|scaled
init|=
name|image
operator|.
name|scaled
argument_list|(
name|max_texture_size
argument_list|,
name|max_texture_size
argument_list|,
name|Qt
operator|::
name|KeepAspectRatio
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|sx
init|=
name|scaled
operator|.
name|width
argument_list|()
operator|/
name|qreal
argument_list|(
name|image
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|sy
init|=
name|scaled
operator|.
name|height
argument_list|()
operator|/
name|qreal
argument_list|(
name|image
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|drawImage
argument_list|(
name|dest
argument_list|,
name|scaled
argument_list|,
name|scaleRect
argument_list|(
name|src
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ensureActive
argument_list|()
expr_stmt|;
name|d
operator|->
name|transferMode
argument_list|(
name|ImageDrawingMode
argument_list|)
expr_stmt|;
name|d
operator|->
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|QT_IMAGE_TEXTURE_UNIT
argument_list|)
expr_stmt|;
name|QGLContext
operator|::
name|BindOptions
name|bindOptions
init|=
name|QGLContext
operator|::
name|InternalBindOption
decl_stmt|;
ifdef|#
directive|ifdef
name|QGL_USE_TEXTURE_POOL
name|bindOptions
operator||=
name|QGLContext
operator|::
name|TemporarilyCachedBindOption
expr_stmt|;
endif|#
directive|endif
name|QGLTexture
modifier|*
name|texture
init|=
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|bindTexture
argument_list|(
name|image
argument_list|,
name|GL_TEXTURE_2D
argument_list|,
name|GL_RGBA
argument_list|,
name|bindOptions
argument_list|)
decl_stmt|;
name|GLuint
name|id
init|=
name|texture
operator|->
name|id
decl_stmt|;
name|d
operator|->
name|updateTextureFilter
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_CLAMP_TO_EDGE
argument_list|,
name|state
argument_list|()
operator|->
name|renderHints
operator|&
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|d
operator|->
name|drawTexture
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|image
operator|.
name|size
argument_list|()
argument_list|,
operator|!
name|image
operator|.
name|hasAlphaChannel
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|texture
operator|->
name|options
operator|&
name|QGLContext
operator|::
name|TemporarilyCachedBindOption
condition|)
block|{
comment|// image was temporarily cached by texture pooling system
comment|// and should be destroyed immediately
name|QGLTextureCache
operator|::
name|instance
argument_list|()
operator|->
name|remove
argument_list|(
name|ctx
argument_list|,
name|texture
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|drawStaticTextItem
name|void
name|QGL2PaintEngineEx
operator|::
name|drawStaticTextItem
parameter_list|(
name|QStaticTextItem
modifier|*
name|textItem
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|ensureActive
argument_list|()
expr_stmt|;
name|QPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
comment|// don't try to cache huge fonts or vastly transformed fonts
name|QFontEngine
modifier|*
name|fontEngine
init|=
name|textItem
operator|->
name|fontEngine
argument_list|()
decl_stmt|;
if|if
condition|(
name|shouldDrawCachedGlyphs
argument_list|(
name|fontEngine
argument_list|,
name|s
operator|->
name|matrix
argument_list|)
condition|)
block|{
name|QFontEngine
operator|::
name|GlyphFormat
name|glyphFormat
init|=
name|fontEngine
operator|->
name|glyphFormat
operator|!=
name|QFontEngine
operator|::
name|Format_None
condition|?
name|fontEngine
operator|->
name|glyphFormat
else|:
name|d
operator|->
name|glyphCacheFormat
decl_stmt|;
if|if
condition|(
name|glyphFormat
operator|==
name|QFontEngine
operator|::
name|Format_A32
condition|)
block|{
if|if
condition|(
operator|!
name|QGLFramebufferObject
operator|::
name|hasOpenGLFramebufferObjects
argument_list|()
operator|||
name|d
operator|->
name|device
operator|->
name|alphaRequested
argument_list|()
operator|||
name|s
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|>
name|QTransform
operator|::
name|TxTranslate
operator|||
operator|(
name|s
operator|->
name|composition_mode
operator|!=
name|QPainter
operator|::
name|CompositionMode_Source
operator|&&
name|s
operator|->
name|composition_mode
operator|!=
name|QPainter
operator|::
name|CompositionMode_SourceOver
operator|)
condition|)
block|{
name|glyphFormat
operator|=
name|QFontEngine
operator|::
name|Format_A8
expr_stmt|;
block|}
block|}
name|d
operator|->
name|drawCachedGlyphs
argument_list|(
name|glyphFormat
argument_list|,
name|textItem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QPaintEngineEx
operator|::
name|drawStaticTextItem
argument_list|(
name|textItem
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|drawTexture
name|bool
name|QGL2PaintEngineEx
operator|::
name|drawTexture
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|dest
parameter_list|,
name|GLuint
name|textureId
parameter_list|,
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|src
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|shaderManager
condition|)
return|return
literal|false
return|;
name|ensureActive
argument_list|()
expr_stmt|;
name|d
operator|->
name|transferMode
argument_list|(
name|ImageDrawingMode
argument_list|)
expr_stmt|;
name|d
operator|->
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|QT_IMAGE_TEXTURE_UNIT
argument_list|)
expr_stmt|;
name|d
operator|->
name|glBindTexture
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|textureId
argument_list|)
expr_stmt|;
name|QGLRect
name|srcRect
argument_list|(
name|src
operator|.
name|left
argument_list|()
argument_list|,
name|src
operator|.
name|bottom
argument_list|()
argument_list|,
name|src
operator|.
name|right
argument_list|()
argument_list|,
name|src
operator|.
name|top
argument_list|()
argument_list|)
decl_stmt|;
name|d
operator|->
name|updateTextureFilter
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_CLAMP_TO_EDGE
argument_list|,
name|state
argument_list|()
operator|->
name|renderHints
operator|&
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|,
name|textureId
argument_list|)
expr_stmt|;
name|d
operator|->
name|drawTexture
argument_list|(
name|dest
argument_list|,
name|srcRect
argument_list|,
name|size
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|drawTextItem
name|void
name|QGL2PaintEngineEx
operator|::
name|drawTextItem
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QTextItem
modifier|&
name|textItem
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|ensureActive
argument_list|()
expr_stmt|;
name|QGL2PaintEngineState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
specifier|const
name|QTextItemInt
modifier|&
name|ti
init|=
cast|static_cast
argument_list|<
specifier|const
name|QTextItemInt
operator|&
argument_list|>
argument_list|(
name|textItem
argument_list|)
decl_stmt|;
name|QTransform
operator|::
name|TransformationType
name|txtype
init|=
name|s
operator|->
name|matrix
operator|.
name|type
argument_list|()
decl_stmt|;
name|QFontEngine
operator|::
name|GlyphFormat
name|glyphFormat
init|=
name|ti
operator|.
name|fontEngine
operator|->
name|glyphFormat
operator|!=
name|QFontEngine
operator|::
name|Format_None
condition|?
name|ti
operator|.
name|fontEngine
operator|->
name|glyphFormat
else|:
name|d
operator|->
name|glyphCacheFormat
decl_stmt|;
if|if
condition|(
name|glyphFormat
operator|==
name|QFontEngine
operator|::
name|Format_A32
condition|)
block|{
if|if
condition|(
operator|!
name|QGLFramebufferObject
operator|::
name|hasOpenGLFramebufferObjects
argument_list|()
operator|||
name|d
operator|->
name|device
operator|->
name|alphaRequested
argument_list|()
operator|||
name|txtype
operator|>
name|QTransform
operator|::
name|TxTranslate
operator|||
operator|(
name|state
argument_list|()
operator|->
name|composition_mode
operator|!=
name|QPainter
operator|::
name|CompositionMode_Source
operator|&&
name|state
argument_list|()
operator|->
name|composition_mode
operator|!=
name|QPainter
operator|::
name|CompositionMode_SourceOver
operator|)
condition|)
block|{
name|glyphFormat
operator|=
name|QFontEngine
operator|::
name|Format_A8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shouldDrawCachedGlyphs
argument_list|(
name|ti
operator|.
name|fontEngine
argument_list|,
name|s
operator|->
name|matrix
argument_list|)
condition|)
block|{
name|QVarLengthArray
argument_list|<
name|QFixedPoint
argument_list|>
name|positions
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|glyph_t
argument_list|>
name|glyphs
decl_stmt|;
name|QTransform
name|matrix
init|=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|ti
operator|.
name|fontEngine
operator|->
name|getGlyphPositions
argument_list|(
name|ti
operator|.
name|glyphs
argument_list|,
name|matrix
argument_list|,
name|ti
operator|.
name|flags
argument_list|,
name|glyphs
argument_list|,
name|positions
argument_list|)
expr_stmt|;
block|{
name|QStaticTextItem
name|staticTextItem
decl_stmt|;
name|staticTextItem
operator|.
name|chars
operator|=
cast|const_cast
argument_list|<
name|QChar
operator|*
argument_list|>
argument_list|(
name|ti
operator|.
name|chars
argument_list|)
expr_stmt|;
name|staticTextItem
operator|.
name|setFontEngine
argument_list|(
name|ti
operator|.
name|fontEngine
argument_list|)
expr_stmt|;
name|staticTextItem
operator|.
name|glyphs
operator|=
name|glyphs
operator|.
name|data
argument_list|()
expr_stmt|;
name|staticTextItem
operator|.
name|numChars
operator|=
name|ti
operator|.
name|num_chars
expr_stmt|;
name|staticTextItem
operator|.
name|numGlyphs
operator|=
name|glyphs
operator|.
name|size
argument_list|()
expr_stmt|;
name|staticTextItem
operator|.
name|glyphPositions
operator|=
name|positions
operator|.
name|data
argument_list|()
expr_stmt|;
name|d
operator|->
name|drawCachedGlyphs
argument_list|(
name|glyphFormat
argument_list|,
operator|&
name|staticTextItem
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|QPaintEngineEx
operator|::
name|drawTextItem
argument_list|(
name|p
argument_list|,
name|ti
argument_list|)
expr_stmt|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|class|QOpenGLStaticTextUserData
class|class
name|QOpenGLStaticTextUserData
super|:
specifier|public
name|QStaticTextUserData
block|{
public|public:
DECL|function|QOpenGLStaticTextUserData
name|QOpenGLStaticTextUserData
parameter_list|()
member_init_list|:
name|QStaticTextUserData
argument_list|(
name|OpenGLUserData
argument_list|)
member_init_list|,
name|cacheSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|cacheSerialNumber
argument_list|(
literal|0
argument_list|)
block|{         }
DECL|function|~QOpenGLStaticTextUserData
name|~
name|QOpenGLStaticTextUserData
parameter_list|()
block|{         }
DECL|member|cacheSize
name|QSize
name|cacheSize
decl_stmt|;
DECL|member|vertexCoordinateArray
name|QGL2PEXVertexArray
name|vertexCoordinateArray
decl_stmt|;
DECL|member|textureCoordinateArray
name|QGL2PEXVertexArray
name|textureCoordinateArray
decl_stmt|;
DECL|member|glyphFormat
name|QFontEngine
operator|::
name|GlyphFormat
name|glyphFormat
decl_stmt|;
DECL|member|cacheSerialNumber
name|int
name|cacheSerialNumber
decl_stmt|;
block|}
class|;
block|}
end_namespace
begin_comment
comment|// #define QT_OPENGL_DRAWCACHEDGLYPHS_INDEX_ARRAY_VBO
end_comment
begin_function
DECL|function|drawCachedGlyphs
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|drawCachedGlyphs
parameter_list|(
name|QFontEngine
operator|::
name|GlyphFormat
name|glyphFormat
parameter_list|,
name|QStaticTextItem
modifier|*
name|staticTextItem
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|QGL2PaintEngineState
modifier|*
name|s
init|=
name|q
operator|->
name|state
argument_list|()
decl_stmt|;
name|void
modifier|*
name|cacheKey
init|=
cast|const_cast
argument_list|<
name|QGLContext
operator|*
argument_list|>
argument_list|(
name|QGLContextPrivate
operator|::
name|contextGroup
argument_list|(
name|ctx
argument_list|)
operator|->
name|context
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|recreateVertexArrays
init|=
literal|false
decl_stmt|;
name|QTransform
name|glyphCacheTransform
decl_stmt|;
name|QFontEngine
modifier|*
name|fe
init|=
name|staticTextItem
operator|->
name|fontEngine
argument_list|()
decl_stmt|;
if|if
condition|(
name|fe
operator|->
name|supportsTransformation
argument_list|(
name|s
operator|->
name|matrix
argument_list|)
condition|)
block|{
comment|// The font-engine supports rendering glyphs with the current transform, so we
comment|// build a glyph-cache with the scale pre-applied, so that the cache contains
comment|// glyphs with the appropriate resolution in the case of retina displays.
name|glyphCacheTransform
operator|=
name|s
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|<
name|QTransform
operator|::
name|TxRotate
condition|?
name|QTransform
operator|::
name|fromScale
argument_list|(
name|qAbs
argument_list|(
name|s
operator|->
name|matrix
operator|.
name|m11
argument_list|()
argument_list|)
argument_list|,
name|qAbs
argument_list|(
name|s
operator|->
name|matrix
operator|.
name|m22
argument_list|()
argument_list|)
argument_list|)
else|:
name|QTransform
operator|::
name|fromScale
argument_list|(
name|QVector2D
argument_list|(
name|s
operator|->
name|matrix
operator|.
name|m11
argument_list|()
argument_list|,
name|s
operator|->
name|matrix
operator|.
name|m12
argument_list|()
argument_list|)
operator|.
name|length
argument_list|()
argument_list|,
name|QVector2D
argument_list|(
name|s
operator|->
name|matrix
operator|.
name|m21
argument_list|()
argument_list|,
name|s
operator|->
name|matrix
operator|.
name|m22
argument_list|()
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QGLTextureGlyphCache
modifier|*
name|cache
init|=
operator|(
name|QGLTextureGlyphCache
operator|*
operator|)
name|fe
operator|->
name|glyphCache
argument_list|(
name|cacheKey
argument_list|,
name|glyphFormat
argument_list|,
name|glyphCacheTransform
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cache
operator|||
name|cache
operator|->
name|glyphFormat
argument_list|()
operator|!=
name|glyphFormat
operator|||
name|cache
operator|->
name|contextGroup
argument_list|()
operator|==
literal|0
condition|)
block|{
name|cache
operator|=
operator|new
name|QGLTextureGlyphCache
argument_list|(
name|glyphFormat
argument_list|,
name|glyphCacheTransform
argument_list|)
expr_stmt|;
name|fe
operator|->
name|setGlyphCache
argument_list|(
name|cacheKey
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|recreateVertexArrays
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|staticTextItem
operator|->
name|userDataNeedsUpdate
condition|)
block|{
name|recreateVertexArrays
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|staticTextItem
operator|->
name|userData
argument_list|()
operator|==
literal|0
condition|)
block|{
name|recreateVertexArrays
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|staticTextItem
operator|->
name|userData
argument_list|()
operator|->
name|type
operator|!=
name|QStaticTextUserData
operator|::
name|OpenGLUserData
condition|)
block|{
name|recreateVertexArrays
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|QOpenGLStaticTextUserData
modifier|*
name|userData
init|=
cast|static_cast
argument_list|<
name|QOpenGLStaticTextUserData
operator|*
argument_list|>
argument_list|(
name|staticTextItem
operator|->
name|userData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|userData
operator|->
name|glyphFormat
operator|!=
name|glyphFormat
condition|)
block|{
name|recreateVertexArrays
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|userData
operator|->
name|cacheSerialNumber
operator|!=
name|cache
operator|->
name|serialNumber
argument_list|()
condition|)
block|{
name|recreateVertexArrays
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// We only need to update the cache with new glyphs if we are actually going to recreate the vertex arrays.
comment|// If the cache size has changed, we do need to regenerate the vertices, but we don't need to repopulate the
comment|// cache so this text is performed before we test if the cache size has changed.
if|if
condition|(
name|recreateVertexArrays
condition|)
block|{
name|cache
operator|->
name|setPaintEnginePrivate
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cache
operator|->
name|populate
argument_list|(
name|fe
argument_list|,
name|staticTextItem
operator|->
name|numGlyphs
argument_list|,
name|staticTextItem
operator|->
name|glyphs
argument_list|,
name|staticTextItem
operator|->
name|glyphPositions
argument_list|)
condition|)
block|{
comment|// No space for glyphs in cache. We need to reset it and try again.
name|cache
operator|->
name|clear
argument_list|()
expr_stmt|;
name|cache
operator|->
name|populate
argument_list|(
name|fe
argument_list|,
name|staticTextItem
operator|->
name|numGlyphs
argument_list|,
name|staticTextItem
operator|->
name|glyphs
argument_list|,
name|staticTextItem
operator|->
name|glyphPositions
argument_list|)
expr_stmt|;
block|}
name|cache
operator|->
name|fillInPendingGlyphs
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cache
operator|->
name|width
argument_list|()
operator|==
literal|0
operator|||
name|cache
operator|->
name|height
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|transferMode
argument_list|(
name|TextDrawingMode
argument_list|)
expr_stmt|;
name|int
name|margin
init|=
name|fe
operator|->
name|glyphMargin
argument_list|(
name|glyphFormat
argument_list|)
decl_stmt|;
name|GLfloat
name|dx
init|=
literal|1.0
operator|/
name|cache
operator|->
name|width
argument_list|()
decl_stmt|;
name|GLfloat
name|dy
init|=
literal|1.0
operator|/
name|cache
operator|->
name|height
argument_list|()
decl_stmt|;
comment|// Use global arrays by default
name|QGL2PEXVertexArray
modifier|*
name|vertexCoordinates
init|=
operator|&
name|vertexCoordinateArray
decl_stmt|;
name|QGL2PEXVertexArray
modifier|*
name|textureCoordinates
init|=
operator|&
name|textureCoordinateArray
decl_stmt|;
if|if
condition|(
name|staticTextItem
operator|->
name|useBackendOptimizations
condition|)
block|{
name|QOpenGLStaticTextUserData
modifier|*
name|userData
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|staticTextItem
operator|->
name|userData
argument_list|()
operator|==
literal|0
operator|||
name|staticTextItem
operator|->
name|userData
argument_list|()
operator|->
name|type
operator|!=
name|QStaticTextUserData
operator|::
name|OpenGLUserData
condition|)
block|{
name|userData
operator|=
operator|new
name|QOpenGLStaticTextUserData
argument_list|()
expr_stmt|;
name|staticTextItem
operator|->
name|setUserData
argument_list|(
name|userData
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|userData
operator|=
cast|static_cast
argument_list|<
name|QOpenGLStaticTextUserData
operator|*
argument_list|>
argument_list|(
name|staticTextItem
operator|->
name|userData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|userData
operator|->
name|glyphFormat
operator|=
name|glyphFormat
expr_stmt|;
name|userData
operator|->
name|cacheSerialNumber
operator|=
name|cache
operator|->
name|serialNumber
argument_list|()
expr_stmt|;
comment|// Use cache if backend optimizations is turned on
name|vertexCoordinates
operator|=
operator|&
name|userData
operator|->
name|vertexCoordinateArray
expr_stmt|;
name|textureCoordinates
operator|=
operator|&
name|userData
operator|->
name|textureCoordinateArray
expr_stmt|;
name|QSize
name|size
argument_list|(
name|cache
operator|->
name|width
argument_list|()
argument_list|,
name|cache
operator|->
name|height
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|userData
operator|->
name|cacheSize
operator|!=
name|size
condition|)
block|{
name|recreateVertexArrays
operator|=
literal|true
expr_stmt|;
name|userData
operator|->
name|cacheSize
operator|=
name|size
expr_stmt|;
block|}
block|}
if|if
condition|(
name|recreateVertexArrays
condition|)
block|{
name|vertexCoordinates
operator|->
name|clear
argument_list|()
expr_stmt|;
name|textureCoordinates
operator|->
name|clear
argument_list|()
expr_stmt|;
name|bool
name|supportsSubPixelPositions
init|=
name|fe
operator|->
name|supportsSubPixelPositions
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|staticTextItem
operator|->
name|numGlyphs
condition|;
operator|++
name|i
control|)
block|{
name|QFixed
name|subPixelPosition
decl_stmt|;
if|if
condition|(
name|supportsSubPixelPositions
condition|)
name|subPixelPosition
operator|=
name|fe
operator|->
name|subPixelPositionForX
argument_list|(
name|staticTextItem
operator|->
name|glyphPositions
index|[
name|i
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|QTextureGlyphCache
operator|::
name|GlyphAndSubPixelPosition
name|glyph
argument_list|(
name|staticTextItem
operator|->
name|glyphs
index|[
name|i
index|]
argument_list|,
name|subPixelPosition
argument_list|)
decl_stmt|;
specifier|const
name|QTextureGlyphCache
operator|::
name|Coord
modifier|&
name|c
init|=
name|cache
operator|->
name|coords
index|[
name|glyph
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|isNull
argument_list|()
condition|)
continue|continue;
name|int
name|x
init|=
name|qFloor
argument_list|(
name|staticTextItem
operator|->
name|glyphPositions
index|[
name|i
index|]
operator|.
name|x
operator|.
name|toReal
argument_list|()
operator|*
name|cache
operator|->
name|transform
argument_list|()
operator|.
name|m11
argument_list|()
argument_list|)
operator|+
name|c
operator|.
name|baseLineX
operator|-
name|margin
decl_stmt|;
name|int
name|y
init|=
name|qRound
argument_list|(
name|staticTextItem
operator|->
name|glyphPositions
index|[
name|i
index|]
operator|.
name|y
operator|.
name|toReal
argument_list|()
operator|*
name|cache
operator|->
name|transform
argument_list|()
operator|.
name|m22
argument_list|()
argument_list|)
operator|-
name|c
operator|.
name|baseLineY
operator|-
name|margin
decl_stmt|;
name|vertexCoordinates
operator|->
name|addQuad
argument_list|(
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|c
operator|.
name|w
argument_list|,
name|c
operator|.
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|textureCoordinates
operator|->
name|addQuad
argument_list|(
name|QRectF
argument_list|(
name|c
operator|.
name|x
operator|*
name|dx
argument_list|,
name|c
operator|.
name|y
operator|*
name|dy
argument_list|,
name|c
operator|.
name|w
operator|*
name|dx
argument_list|,
name|c
operator|.
name|h
operator|*
name|dy
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|staticTextItem
operator|->
name|userDataNeedsUpdate
operator|=
literal|false
expr_stmt|;
block|}
name|int
name|numGlyphs
init|=
name|vertexCoordinates
operator|->
name|vertexCount
argument_list|()
operator|/
literal|4
decl_stmt|;
if|if
condition|(
name|numGlyphs
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|elementIndices
operator|.
name|size
argument_list|()
operator|<
name|numGlyphs
operator|*
literal|6
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|elementIndices
operator|.
name|size
argument_list|()
operator|%
literal|6
operator|==
literal|0
argument_list|)
expr_stmt|;
name|int
name|j
init|=
name|elementIndices
operator|.
name|size
argument_list|()
operator|/
literal|6
operator|*
literal|4
decl_stmt|;
while|while
condition|(
name|j
operator|<
name|numGlyphs
operator|*
literal|4
condition|)
block|{
name|elementIndices
operator|.
name|append
argument_list|(
name|j
operator|+
literal|0
argument_list|)
expr_stmt|;
name|elementIndices
operator|.
name|append
argument_list|(
name|j
operator|+
literal|0
argument_list|)
expr_stmt|;
name|elementIndices
operator|.
name|append
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|elementIndices
operator|.
name|append
argument_list|(
name|j
operator|+
literal|2
argument_list|)
expr_stmt|;
name|elementIndices
operator|.
name|append
argument_list|(
name|j
operator|+
literal|3
argument_list|)
expr_stmt|;
name|elementIndices
operator|.
name|append
argument_list|(
name|j
operator|+
literal|3
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|4
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_DRAWCACHEDGLYPHS_INDEX_ARRAY_VBO
argument_list|)
if|if
condition|(
name|elementIndicesVBOId
operator|==
literal|0
condition|)
name|glGenBuffers
argument_list|(
literal|1
argument_list|,
operator|&
name|elementIndicesVBOId
argument_list|)
expr_stmt|;
name|glBindBuffer
argument_list|(
name|GL_ELEMENT_ARRAY_BUFFER
argument_list|,
name|elementIndicesVBOId
argument_list|)
expr_stmt|;
name|glBufferData
argument_list|(
name|GL_ELEMENT_ARRAY_BUFFER
argument_list|,
name|elementIndices
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|GLushort
argument_list|)
argument_list|,
name|elementIndices
operator|.
name|constData
argument_list|()
argument_list|,
name|GL_STATIC_DRAW
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_DRAWCACHEDGLYPHS_INDEX_ARRAY_VBO
argument_list|)
name|glBindBuffer
argument_list|(
name|GL_ELEMENT_ARRAY_BUFFER
argument_list|,
name|elementIndicesVBOId
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|setVertexAttributePointer
argument_list|(
name|QT_VERTEX_COORDS_ATTR
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|vertexCoordinates
operator|->
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|setVertexAttributePointer
argument_list|(
name|QT_TEXTURE_COORDS_ATTR
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
name|textureCoordinates
operator|->
name|data
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|snapToPixelGrid
condition|)
block|{
name|snapToPixelGrid
operator|=
literal|true
expr_stmt|;
name|matrixDirty
operator|=
literal|true
expr_stmt|;
block|}
name|QBrush
name|pensBrush
init|=
name|q
operator|->
name|state
argument_list|()
operator|->
name|pen
operator|.
name|brush
argument_list|()
decl_stmt|;
name|setBrush
argument_list|(
name|pensBrush
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyphFormat
operator|==
name|QFontEngine
operator|::
name|Format_A32
condition|)
block|{
comment|// Subpixel antialiasing without gamma correction
name|QPainter
operator|::
name|CompositionMode
name|compMode
init|=
name|q
operator|->
name|state
argument_list|()
operator|->
name|composition_mode
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|compMode
operator|==
name|QPainter
operator|::
name|CompositionMode_Source
operator|||
name|compMode
operator|==
name|QPainter
operator|::
name|CompositionMode_SourceOver
argument_list|)
expr_stmt|;
name|shaderManager
operator|->
name|setMaskType
argument_list|(
name|QGLEngineShaderManager
operator|::
name|SubPixelMaskPass1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pensBrush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|SolidPattern
condition|)
block|{
comment|// Solid patterns can get away with only one pass.
name|QColor
name|c
init|=
name|pensBrush
operator|.
name|color
argument_list|()
decl_stmt|;
name|qreal
name|oldOpacity
init|=
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
decl_stmt|;
if|if
condition|(
name|compMode
operator|==
name|QPainter
operator|::
name|CompositionMode_Source
condition|)
block|{
name|c
operator|=
name|qt_premultiplyColor
argument_list|(
name|c
argument_list|,
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
argument_list|)
expr_stmt|;
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
operator|=
literal|1
expr_stmt|;
name|opacityUniformDirty
operator|=
literal|true
expr_stmt|;
block|}
name|compositionModeDirty
operator|=
literal|false
expr_stmt|;
comment|// I can handle this myself, thank you very much
name|prepareForCachedGlyphDraw
argument_list|(
operator|*
name|cache
argument_list|)
expr_stmt|;
comment|// prepareForCachedGlyphDraw() have set the opacity on the current shader, so the opacity state can now be reset.
if|if
condition|(
name|compMode
operator|==
name|QPainter
operator|::
name|CompositionMode_Source
condition|)
block|{
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
operator|=
name|oldOpacity
expr_stmt|;
name|opacityUniformDirty
operator|=
literal|true
expr_stmt|;
block|}
name|glEnable
argument_list|(
name|GL_BLEND
argument_list|)
expr_stmt|;
name|glBlendFunc
argument_list|(
name|GL_CONSTANT_COLOR
argument_list|,
name|GL_ONE_MINUS_SRC_COLOR
argument_list|)
expr_stmt|;
name|glBlendColor
argument_list|(
name|c
operator|.
name|redF
argument_list|()
argument_list|,
name|c
operator|.
name|greenF
argument_list|()
argument_list|,
name|c
operator|.
name|blueF
argument_list|()
argument_list|,
name|c
operator|.
name|alphaF
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Other brush styles need two passes.
name|qreal
name|oldOpacity
init|=
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
decl_stmt|;
if|if
condition|(
name|compMode
operator|==
name|QPainter
operator|::
name|CompositionMode_Source
condition|)
block|{
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
operator|=
literal|1
expr_stmt|;
name|opacityUniformDirty
operator|=
literal|true
expr_stmt|;
name|pensBrush
operator|=
name|Qt
operator|::
name|white
expr_stmt|;
name|setBrush
argument_list|(
name|pensBrush
argument_list|)
expr_stmt|;
block|}
name|compositionModeDirty
operator|=
literal|false
expr_stmt|;
comment|// I can handle this myself, thank you very much
name|prepareForCachedGlyphDraw
argument_list|(
operator|*
name|cache
argument_list|)
expr_stmt|;
name|glEnable
argument_list|(
name|GL_BLEND
argument_list|)
expr_stmt|;
name|glBlendFunc
argument_list|(
name|GL_ZERO
argument_list|,
name|GL_ONE_MINUS_SRC_COLOR
argument_list|)
expr_stmt|;
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|QT_MASK_TEXTURE_UNIT
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|cache
operator|->
name|texture
argument_list|()
argument_list|)
expr_stmt|;
name|updateTextureFilter
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_REPEAT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_DRAWCACHEDGLYPHS_INDEX_ARRAY_VBO
argument_list|)
name|glDrawElements
argument_list|(
name|GL_TRIANGLE_STRIP
argument_list|,
literal|6
operator|*
name|numGlyphs
argument_list|,
name|GL_UNSIGNED_SHORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|glDrawElements
argument_list|(
name|GL_TRIANGLE_STRIP
argument_list|,
literal|6
operator|*
name|numGlyphs
argument_list|,
name|GL_UNSIGNED_SHORT
argument_list|,
name|elementIndices
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|shaderManager
operator|->
name|setMaskType
argument_list|(
name|QGLEngineShaderManager
operator|::
name|SubPixelMaskPass2
argument_list|)
expr_stmt|;
if|if
condition|(
name|compMode
operator|==
name|QPainter
operator|::
name|CompositionMode_Source
condition|)
block|{
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
operator|=
name|oldOpacity
expr_stmt|;
name|opacityUniformDirty
operator|=
literal|true
expr_stmt|;
name|pensBrush
operator|=
name|q
operator|->
name|state
argument_list|()
operator|->
name|pen
operator|.
name|brush
argument_list|()
expr_stmt|;
name|setBrush
argument_list|(
name|pensBrush
argument_list|)
expr_stmt|;
block|}
name|compositionModeDirty
operator|=
literal|false
expr_stmt|;
name|prepareForCachedGlyphDraw
argument_list|(
operator|*
name|cache
argument_list|)
expr_stmt|;
name|glEnable
argument_list|(
name|GL_BLEND
argument_list|)
expr_stmt|;
name|glBlendFunc
argument_list|(
name|GL_ONE
argument_list|,
name|GL_ONE
argument_list|)
expr_stmt|;
block|}
name|compositionModeDirty
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// Grayscale/mono glyphs
name|shaderManager
operator|->
name|setMaskType
argument_list|(
name|QGLEngineShaderManager
operator|::
name|PixelMask
argument_list|)
expr_stmt|;
name|prepareForCachedGlyphDraw
argument_list|(
operator|*
name|cache
argument_list|)
expr_stmt|;
block|}
name|QGLTextureGlyphCache
operator|::
name|FilterMode
name|filterMode
init|=
operator|(
name|s
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|>
name|QTransform
operator|::
name|TxTranslate
operator|)
condition|?
name|QGLTextureGlyphCache
operator|::
name|Linear
else|:
name|QGLTextureGlyphCache
operator|::
name|Nearest
decl_stmt|;
if|if
condition|(
name|lastMaskTextureUsed
operator|!=
name|cache
operator|->
name|texture
argument_list|()
operator|||
name|cache
operator|->
name|filterMode
argument_list|()
operator|!=
name|filterMode
condition|)
block|{
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|QT_MASK_TEXTURE_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastMaskTextureUsed
operator|!=
name|cache
operator|->
name|texture
argument_list|()
condition|)
block|{
name|glBindTexture
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|cache
operator|->
name|texture
argument_list|()
argument_list|)
expr_stmt|;
name|lastMaskTextureUsed
operator|=
name|cache
operator|->
name|texture
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cache
operator|->
name|filterMode
argument_list|()
operator|!=
name|filterMode
condition|)
block|{
if|if
condition|(
name|filterMode
operator|==
name|QGLTextureGlyphCache
operator|::
name|Linear
condition|)
block|{
name|glTexParameteri
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|GL_LINEAR
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|GL_LINEAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glTexParameteri
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MAG_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
name|glTexParameteri
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_TEXTURE_MIN_FILTER
argument_list|,
name|GL_NEAREST
argument_list|)
expr_stmt|;
block|}
name|cache
operator|->
name|setFilterMode
argument_list|(
name|filterMode
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_DRAWCACHEDGLYPHS_INDEX_ARRAY_VBO
argument_list|)
name|glDrawElements
argument_list|(
name|GL_TRIANGLE_STRIP
argument_list|,
literal|6
operator|*
name|numGlyphs
argument_list|,
name|GL_UNSIGNED_SHORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|glBindBuffer
argument_list|(
name|GL_ELEMENT_ARRAY_BUFFER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|glDrawElements
argument_list|(
name|GL_TRIANGLE_STRIP
argument_list|,
literal|6
operator|*
name|numGlyphs
argument_list|,
name|GL_UNSIGNED_SHORT
argument_list|,
name|elementIndices
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|drawPixmapFragments
name|void
name|QGL2PaintEngineEx
operator|::
name|drawPixmapFragments
parameter_list|(
specifier|const
name|QPainter
operator|::
name|PixmapFragment
modifier|*
name|fragments
parameter_list|,
name|int
name|fragmentCount
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|QPainter
operator|::
name|PixmapFragmentHints
name|hints
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
comment|// Use fallback for extended composition modes.
if|if
condition|(
name|state
argument_list|()
operator|->
name|composition_mode
operator|>
name|QPainter
operator|::
name|CompositionMode_Plus
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawPixmapFragments
argument_list|(
name|fragments
argument_list|,
name|fragmentCount
argument_list|,
name|pixmap
argument_list|,
name|hints
argument_list|)
expr_stmt|;
return|return;
block|}
name|ensureActive
argument_list|()
expr_stmt|;
name|int
name|max_texture_size
init|=
name|d
operator|->
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|maxTextureSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|pixmap
operator|.
name|width
argument_list|()
operator|>
name|max_texture_size
operator|||
name|pixmap
operator|.
name|height
argument_list|()
operator|>
name|max_texture_size
condition|)
block|{
name|QPixmap
name|scaled
init|=
name|pixmap
operator|.
name|scaled
argument_list|(
name|max_texture_size
argument_list|,
name|max_texture_size
argument_list|,
name|Qt
operator|::
name|KeepAspectRatio
argument_list|)
decl_stmt|;
name|d
operator|->
name|drawPixmapFragments
argument_list|(
name|fragments
argument_list|,
name|fragmentCount
argument_list|,
name|scaled
argument_list|,
name|hints
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|drawPixmapFragments
argument_list|(
name|fragments
argument_list|,
name|fragmentCount
argument_list|,
name|pixmap
argument_list|,
name|hints
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|drawPixmapFragments
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|drawPixmapFragments
parameter_list|(
specifier|const
name|QPainter
operator|::
name|PixmapFragment
modifier|*
name|fragments
parameter_list|,
name|int
name|fragmentCount
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|QPainter
operator|::
name|PixmapFragmentHints
name|hints
parameter_list|)
block|{
name|GLfloat
name|dx
init|=
literal|1.0f
operator|/
name|pixmap
operator|.
name|size
argument_list|()
operator|.
name|width
argument_list|()
decl_stmt|;
name|GLfloat
name|dy
init|=
literal|1.0f
operator|/
name|pixmap
operator|.
name|size
argument_list|()
operator|.
name|height
argument_list|()
decl_stmt|;
name|vertexCoordinateArray
operator|.
name|clear
argument_list|()
expr_stmt|;
name|textureCoordinateArray
operator|.
name|clear
argument_list|()
expr_stmt|;
name|opacityArray
operator|.
name|reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|snapToPixelGrid
condition|)
block|{
name|snapToPixelGrid
operator|=
literal|false
expr_stmt|;
name|matrixDirty
operator|=
literal|true
expr_stmt|;
block|}
name|bool
name|allOpaque
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fragmentCount
condition|;
operator|++
name|i
control|)
block|{
name|qreal
name|s
init|=
literal|0
decl_stmt|;
name|qreal
name|c
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|fragments
index|[
name|i
index|]
operator|.
name|rotation
operator|!=
literal|0
condition|)
block|{
name|s
operator|=
name|qFastSin
argument_list|(
name|fragments
index|[
name|i
index|]
operator|.
name|rotation
operator|*
name|Q_PI
operator|/
literal|180
argument_list|)
expr_stmt|;
name|c
operator|=
name|qFastCos
argument_list|(
name|fragments
index|[
name|i
index|]
operator|.
name|rotation
operator|*
name|Q_PI
operator|/
literal|180
argument_list|)
expr_stmt|;
block|}
name|qreal
name|right
init|=
literal|0.5
operator|*
name|fragments
index|[
name|i
index|]
operator|.
name|scaleX
operator|*
name|fragments
index|[
name|i
index|]
operator|.
name|width
decl_stmt|;
name|qreal
name|bottom
init|=
literal|0.5
operator|*
name|fragments
index|[
name|i
index|]
operator|.
name|scaleY
operator|*
name|fragments
index|[
name|i
index|]
operator|.
name|height
decl_stmt|;
name|QGLPoint
name|bottomRight
argument_list|(
name|right
operator|*
name|c
operator|-
name|bottom
operator|*
name|s
argument_list|,
name|right
operator|*
name|s
operator|+
name|bottom
operator|*
name|c
argument_list|)
decl_stmt|;
name|QGLPoint
name|bottomLeft
argument_list|(
operator|-
name|right
operator|*
name|c
operator|-
name|bottom
operator|*
name|s
argument_list|,
operator|-
name|right
operator|*
name|s
operator|+
name|bottom
operator|*
name|c
argument_list|)
decl_stmt|;
name|vertexCoordinateArray
operator|.
name|addVertex
argument_list|(
name|bottomRight
operator|.
name|x
operator|+
name|fragments
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|bottomRight
operator|.
name|y
operator|+
name|fragments
index|[
name|i
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|vertexCoordinateArray
operator|.
name|addVertex
argument_list|(
operator|-
name|bottomLeft
operator|.
name|x
operator|+
name|fragments
index|[
name|i
index|]
operator|.
name|x
argument_list|,
operator|-
name|bottomLeft
operator|.
name|y
operator|+
name|fragments
index|[
name|i
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|vertexCoordinateArray
operator|.
name|addVertex
argument_list|(
operator|-
name|bottomRight
operator|.
name|x
operator|+
name|fragments
index|[
name|i
index|]
operator|.
name|x
argument_list|,
operator|-
name|bottomRight
operator|.
name|y
operator|+
name|fragments
index|[
name|i
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|vertexCoordinateArray
operator|.
name|addVertex
argument_list|(
operator|-
name|bottomRight
operator|.
name|x
operator|+
name|fragments
index|[
name|i
index|]
operator|.
name|x
argument_list|,
operator|-
name|bottomRight
operator|.
name|y
operator|+
name|fragments
index|[
name|i
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|vertexCoordinateArray
operator|.
name|addVertex
argument_list|(
name|bottomLeft
operator|.
name|x
operator|+
name|fragments
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|bottomLeft
operator|.
name|y
operator|+
name|fragments
index|[
name|i
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|vertexCoordinateArray
operator|.
name|addVertex
argument_list|(
name|bottomRight
operator|.
name|x
operator|+
name|fragments
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|bottomRight
operator|.
name|y
operator|+
name|fragments
index|[
name|i
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|QGLRect
name|src
argument_list|(
name|fragments
index|[
name|i
index|]
operator|.
name|sourceLeft
operator|*
name|dx
argument_list|,
name|fragments
index|[
name|i
index|]
operator|.
name|sourceTop
operator|*
name|dy
argument_list|,
operator|(
name|fragments
index|[
name|i
index|]
operator|.
name|sourceLeft
operator|+
name|fragments
index|[
name|i
index|]
operator|.
name|width
operator|)
operator|*
name|dx
argument_list|,
operator|(
name|fragments
index|[
name|i
index|]
operator|.
name|sourceTop
operator|+
name|fragments
index|[
name|i
index|]
operator|.
name|height
operator|)
operator|*
name|dy
argument_list|)
decl_stmt|;
name|textureCoordinateArray
operator|.
name|addVertex
argument_list|(
name|src
operator|.
name|right
argument_list|,
name|src
operator|.
name|bottom
argument_list|)
expr_stmt|;
name|textureCoordinateArray
operator|.
name|addVertex
argument_list|(
name|src
operator|.
name|right
argument_list|,
name|src
operator|.
name|top
argument_list|)
expr_stmt|;
name|textureCoordinateArray
operator|.
name|addVertex
argument_list|(
name|src
operator|.
name|left
argument_list|,
name|src
operator|.
name|top
argument_list|)
expr_stmt|;
name|textureCoordinateArray
operator|.
name|addVertex
argument_list|(
name|src
operator|.
name|left
argument_list|,
name|src
operator|.
name|top
argument_list|)
expr_stmt|;
name|textureCoordinateArray
operator|.
name|addVertex
argument_list|(
name|src
operator|.
name|left
argument_list|,
name|src
operator|.
name|bottom
argument_list|)
expr_stmt|;
name|textureCoordinateArray
operator|.
name|addVertex
argument_list|(
name|src
operator|.
name|right
argument_list|,
name|src
operator|.
name|bottom
argument_list|)
expr_stmt|;
name|qreal
name|opacity
init|=
name|fragments
index|[
name|i
index|]
operator|.
name|opacity
operator|*
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
decl_stmt|;
name|opacityArray
operator|<<
name|opacity
operator|<<
name|opacity
operator|<<
name|opacity
operator|<<
name|opacity
operator|<<
name|opacity
operator|<<
name|opacity
expr_stmt|;
name|allOpaque
operator|&=
operator|(
name|opacity
operator|>=
literal|0.99f
operator|)
expr_stmt|;
block|}
name|glActiveTexture
argument_list|(
name|GL_TEXTURE0
operator|+
name|QT_IMAGE_TEXTURE_UNIT
argument_list|)
expr_stmt|;
name|QGLTexture
modifier|*
name|texture
init|=
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|bindTexture
argument_list|(
name|pixmap
argument_list|,
name|GL_TEXTURE_2D
argument_list|,
name|GL_RGBA
argument_list|,
name|QGLContext
operator|::
name|InternalBindOption
operator||
name|QGLContext
operator|::
name|CanFlipNativePixmapBindOption
argument_list|)
decl_stmt|;
if|if
condition|(
name|texture
operator|->
name|options
operator|&
name|QGLContext
operator|::
name|InvertedYBindOption
condition|)
block|{
comment|// Flip texture y-coordinate.
name|QGLPoint
modifier|*
name|data
init|=
name|textureCoordinateArray
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
operator|*
name|fragmentCount
condition|;
operator|++
name|i
control|)
name|data
index|[
name|i
index|]
operator|.
name|y
operator|=
literal|1
operator|-
name|data
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
name|transferMode
argument_list|(
name|ImageArrayDrawingMode
argument_list|)
expr_stmt|;
name|bool
name|isBitmap
init|=
name|pixmap
operator|.
name|isQBitmap
argument_list|()
decl_stmt|;
name|bool
name|isOpaque
init|=
operator|!
name|isBitmap
operator|&&
operator|(
operator|!
name|pixmap
operator|.
name|hasAlpha
argument_list|()
operator|||
operator|(
name|hints
operator|&
name|QPainter
operator|::
name|OpaqueHint
operator|)
operator|)
operator|&&
name|allOpaque
decl_stmt|;
name|updateTextureFilter
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|GL_CLAMP_TO_EDGE
argument_list|,
name|q
operator|->
name|state
argument_list|()
operator|->
name|renderHints
operator|&
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|,
name|texture
operator|->
name|id
argument_list|)
expr_stmt|;
comment|// Setup for texture drawing
name|currentBrush
operator|=
name|noBrush
expr_stmt|;
name|shaderManager
operator|->
name|setSrcPixelType
argument_list|(
name|isBitmap
condition|?
name|QGLEngineShaderManager
operator|::
name|PatternSrc
else|:
name|QGLEngineShaderManager
operator|::
name|ImageSrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|prepareForDraw
argument_list|(
name|isOpaque
argument_list|)
condition|)
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|ImageTexture
argument_list|)
argument_list|,
name|QT_IMAGE_TEXTURE_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isBitmap
condition|)
block|{
name|QColor
name|col
init|=
name|qt_premultiplyColor
argument_list|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|pen
operator|.
name|color
argument_list|()
argument_list|,
operator|(
name|GLfloat
operator|)
name|q
operator|->
name|state
argument_list|()
operator|->
name|opacity
argument_list|)
decl_stmt|;
name|shaderManager
operator|->
name|currentProgram
argument_list|()
operator|->
name|setUniformValue
argument_list|(
name|location
argument_list|(
name|QGLEngineShaderManager
operator|::
name|PatternColor
argument_list|)
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
name|glDrawArrays
argument_list|(
name|GL_TRIANGLES
argument_list|,
literal|0
argument_list|,
literal|6
operator|*
name|fragmentCount
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|begin
name|bool
name|QGL2PaintEngineEx
operator|::
name|begin
parameter_list|(
name|QPaintDevice
modifier|*
name|pdev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
comment|//     qDebug("QGL2PaintEngineEx::begin()");
if|if
condition|(
name|pdev
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|OpenGL
condition|)
name|d
operator|->
name|device
operator|=
cast|static_cast
argument_list|<
name|QGLPaintDevice
operator|*
argument_list|>
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|device
operator|=
name|QGLPaintDevice
operator|::
name|getDevice
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|device
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|ctx
operator|=
name|d
operator|->
name|device
operator|->
name|context
argument_list|()
expr_stmt|;
name|d
operator|->
name|ctx
operator|->
name|d_ptr
operator|->
name|active_engine
operator|=
name|this
expr_stmt|;
specifier|const
name|QSize
name|sz
init|=
name|d
operator|->
name|device
operator|->
name|size
argument_list|()
decl_stmt|;
name|d
operator|->
name|width
operator|=
name|sz
operator|.
name|width
argument_list|()
expr_stmt|;
name|d
operator|->
name|height
operator|=
name|sz
operator|.
name|height
argument_list|()
expr_stmt|;
name|d
operator|->
name|mode
operator|=
name|BrushDrawingMode
expr_stmt|;
name|d
operator|->
name|brushTextureDirty
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|brushUniformsDirty
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|matrixUniformDirty
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|matrixDirty
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|compositionModeDirty
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|opacityUniformDirty
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|translateZUniformDirty
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|needsSync
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|useSystemClip
operator|=
operator|!
name|systemClip
argument_list|()
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|d
operator|->
name|currentBrush
operator|=
name|QBrush
argument_list|()
expr_stmt|;
name|d
operator|->
name|dirtyStencilRegion
operator|=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|)
expr_stmt|;
name|d
operator|->
name|stencilClean
operator|=
literal|true
expr_stmt|;
comment|// Calling begin paint should make the correct context current. So, any
comment|// code which calls into GL or otherwise needs a current context *must*
comment|// go after beginPaint:
name|d
operator|->
name|device
operator|->
name|beginPaint
argument_list|()
expr_stmt|;
name|d
operator|->
name|initializeOpenGLFunctions
argument_list|()
expr_stmt|;
name|d
operator|->
name|shaderManager
operator|=
operator|new
name|QGLEngineShaderManager
argument_list|(
name|d
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|d
operator|->
name|glDisable
argument_list|(
name|GL_STENCIL_TEST
argument_list|)
expr_stmt|;
name|d
operator|->
name|glDisable
argument_list|(
name|GL_DEPTH_TEST
argument_list|)
expr_stmt|;
name|d
operator|->
name|glDisable
argument_list|(
name|GL_SCISSOR_TEST
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|d
operator|->
name|ctx
operator|->
name|contextHandle
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
name|d
operator|->
name|glDisable
argument_list|(
name|GL_MULTISAMPLE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|glyphCacheFormat
operator|=
name|QFontEngine
operator|::
name|Format_A8
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_OPENGL_ES_2
argument_list|)
if|if
condition|(
operator|!
name|d
operator|->
name|ctx
operator|->
name|contextHandle
argument_list|()
operator|->
name|isOpenGLES
argument_list|()
condition|)
block|{
name|d
operator|->
name|glyphCacheFormat
operator|=
name|QFontEngine
operator|::
name|Format_A32
expr_stmt|;
name|d
operator|->
name|multisamplingAlwaysEnabled
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|multisamplingAlwaysEnabled
operator|=
name|d
operator|->
name|device
operator|->
name|format
argument_list|()
operator|.
name|sampleBuffers
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
comment|// OpenGL ES can't switch MSAA off, so if the gl paint device is
comment|// multisampled, it's always multisampled.
name|d
operator|->
name|multisamplingAlwaysEnabled
operator|=
name|d
operator|->
name|device
operator|->
name|format
argument_list|()
operator|.
name|sampleBuffers
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|end
name|bool
name|QGL2PaintEngineEx
operator|::
name|end
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|QGLContext
modifier|*
name|ctx
init|=
name|d
operator|->
name|ctx
decl_stmt|;
name|d
operator|->
name|glUseProgram
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|transferMode
argument_list|(
name|BrushDrawingMode
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|->
name|endPaint
argument_list|()
expr_stmt|;
name|ctx
operator|->
name|d_ptr
operator|->
name|active_engine
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|resetGLState
argument_list|()
expr_stmt|;
operator|delete
name|d
operator|->
name|shaderManager
expr_stmt|;
name|d
operator|->
name|shaderManager
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|currentBrush
operator|=
name|QBrush
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_OPENGL_CACHE_AS_VBOS
if|if
condition|(
operator|!
name|d
operator|->
name|unusedVBOSToClean
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|glDeleteBuffers
argument_list|(
name|d
operator|->
name|unusedVBOSToClean
operator|.
name|size
argument_list|()
argument_list|,
name|d
operator|->
name|unusedVBOSToClean
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|unusedVBOSToClean
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|unusedIBOSToClean
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|glDeleteBuffers
argument_list|(
name|d
operator|->
name|unusedIBOSToClean
operator|.
name|size
argument_list|()
argument_list|,
name|d
operator|->
name|unusedIBOSToClean
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|unusedIBOSToClean
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|ensureActive
name|void
name|QGL2PaintEngineEx
operator|::
name|ensureActive
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|QGLContext
modifier|*
name|ctx
init|=
name|d
operator|->
name|ctx
decl_stmt|;
if|if
condition|(
name|isActive
argument_list|()
operator|&&
name|ctx
operator|->
name|d_ptr
operator|->
name|active_engine
operator|!=
name|this
condition|)
block|{
name|ctx
operator|->
name|d_ptr
operator|->
name|active_engine
operator|=
name|this
expr_stmt|;
name|d
operator|->
name|needsSync
operator|=
literal|true
expr_stmt|;
block|}
name|d
operator|->
name|device
operator|->
name|ensureActiveTarget
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsSync
condition|)
block|{
name|d
operator|->
name|transferMode
argument_list|(
name|BrushDrawingMode
argument_list|)
expr_stmt|;
name|d
operator|->
name|glViewport
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|)
expr_stmt|;
name|d
operator|->
name|needsSync
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|lastMaskTextureUsed
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|shaderManager
operator|->
name|setDirty
argument_list|()
expr_stmt|;
name|d
operator|->
name|ctx
operator|->
name|d_func
argument_list|()
operator|->
name|syncGlState
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|vertexAttribPointers
index|[
name|i
index|]
operator|=
operator|(
name|GLfloat
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
comment|// Assume the pointers are clobbered
name|setState
argument_list|(
name|state
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|updateClipScissorTest
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|updateClipScissorTest
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|clipTestEnabled
condition|)
block|{
name|glEnable
argument_list|(
name|GL_STENCIL_TEST
argument_list|)
expr_stmt|;
name|glStencilFunc
argument_list|(
name|GL_LEQUAL
argument_list|,
name|q
operator|->
name|state
argument_list|()
operator|->
name|currentClip
argument_list|,
operator|~
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glDisable
argument_list|(
name|GL_STENCIL_TEST
argument_list|)
expr_stmt|;
name|glStencilFunc
argument_list|(
name|GL_ALWAYS
argument_list|,
literal|0
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_GL_NO_SCISSOR_TEST
name|currentScissorBounds
operator|=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
else|#
directive|else
name|QRect
name|bounds
init|=
name|q
operator|->
name|state
argument_list|()
operator|->
name|rectangleClip
decl_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|state
argument_list|()
operator|->
name|clipEnabled
condition|)
block|{
if|if
condition|(
name|useSystemClip
condition|)
name|bounds
operator|=
name|systemClip
operator|.
name|boundingRect
argument_list|()
expr_stmt|;
else|else
name|bounds
operator|=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|useSystemClip
condition|)
name|bounds
operator|=
name|bounds
operator|.
name|intersected
argument_list|(
name|systemClip
operator|.
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|bounds
operator|=
name|bounds
operator|.
name|intersected
argument_list|(
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|currentScissorBounds
operator|=
name|bounds
expr_stmt|;
if|if
condition|(
name|bounds
operator|==
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
condition|)
block|{
name|glDisable
argument_list|(
name|GL_SCISSOR_TEST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glEnable
argument_list|(
name|GL_SCISSOR_TEST
argument_list|)
expr_stmt|;
name|setScissor
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|setScissor
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|setScissor
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
specifier|const
name|int
name|left
init|=
name|rect
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|int
name|width
init|=
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|bottom
init|=
name|height
operator|-
operator|(
name|rect
operator|.
name|top
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|device
operator|->
name|isFlipped
argument_list|()
condition|)
block|{
name|bottom
operator|=
name|rect
operator|.
name|top
argument_list|()
expr_stmt|;
block|}
specifier|const
name|int
name|height
init|=
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
name|glScissor
argument_list|(
name|left
argument_list|,
name|bottom
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clipEnabledChanged
name|void
name|QGL2PaintEngineEx
operator|::
name|clipEnabledChanged
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|state
argument_list|()
operator|->
name|clipChanged
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|painter
argument_list|()
operator|->
name|hasClipping
argument_list|()
condition|)
name|d
operator|->
name|regenerateClip
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|systemStateChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clearClip
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|clearClip
parameter_list|(
name|uint
name|value
parameter_list|)
block|{
name|dirtyStencilRegion
operator|-=
name|currentScissorBounds
expr_stmt|;
name|glStencilMask
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
name|glClearStencil
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|glClear
argument_list|(
name|GL_STENCIL_BUFFER_BIT
argument_list|)
expr_stmt|;
name|glStencilMask
argument_list|(
literal|0x0
argument_list|)
expr_stmt|;
name|q
operator|->
name|state
argument_list|()
operator|->
name|needsClipBufferClear
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|writeClip
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|writeClip
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
name|uint
name|value
parameter_list|)
block|{
name|transferMode
argument_list|(
name|BrushDrawingMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapToPixelGrid
condition|)
block|{
name|snapToPixelGrid
operator|=
literal|false
expr_stmt|;
name|matrixDirty
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|matrixDirty
condition|)
name|updateMatrix
argument_list|()
expr_stmt|;
name|stencilClean
operator|=
literal|false
expr_stmt|;
specifier|const
name|bool
name|singlePass
init|=
operator|!
name|path
operator|.
name|hasWindingFill
argument_list|()
operator|&&
operator|(
operator|(
operator|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|currentClip
operator|==
name|maxClip
operator|-
literal|1
operator|)
operator|&&
name|q
operator|->
name|state
argument_list|()
operator|->
name|clipTestEnabled
operator|)
operator|||
name|q
operator|->
name|state
argument_list|()
operator|->
name|needsClipBufferClear
operator|)
decl_stmt|;
specifier|const
name|uint
name|referenceClipValue
init|=
name|q
operator|->
name|state
argument_list|()
operator|->
name|needsClipBufferClear
condition|?
literal|1
else|:
name|q
operator|->
name|state
argument_list|()
operator|->
name|currentClip
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|needsClipBufferClear
condition|)
name|clearClip
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|glEnable
argument_list|(
name|GL_STENCIL_TEST
argument_list|)
expr_stmt|;
name|glStencilFunc
argument_list|(
name|GL_LEQUAL
argument_list|,
name|value
argument_list|,
operator|~
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|clipTestEnabled
condition|)
name|glStencilFunc
argument_list|(
name|GL_LEQUAL
argument_list|,
name|q
operator|->
name|state
argument_list|()
operator|->
name|currentClip
argument_list|,
operator|~
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
else|else
name|glStencilFunc
argument_list|(
name|GL_ALWAYS
argument_list|,
literal|0
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|vertexCoordinateArray
operator|.
name|clear
argument_list|()
expr_stmt|;
name|vertexCoordinateArray
operator|.
name|addPath
argument_list|(
name|path
argument_list|,
name|inverseScale
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|singlePass
condition|)
name|fillStencilWithVertexArray
argument_list|(
name|vertexCoordinateArray
argument_list|,
name|path
operator|.
name|hasWindingFill
argument_list|()
argument_list|)
expr_stmt|;
name|glColorMask
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|glEnable
argument_list|(
name|GL_STENCIL_TEST
argument_list|)
expr_stmt|;
name|useSimpleShader
argument_list|()
expr_stmt|;
if|if
condition|(
name|singlePass
condition|)
block|{
comment|// Under these conditions we can set the new stencil value in a single
comment|// pass, by using the current value and the "new value" as the toggles
name|glStencilFunc
argument_list|(
name|GL_LEQUAL
argument_list|,
name|referenceClipValue
argument_list|,
operator|~
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
name|glStencilOp
argument_list|(
name|GL_KEEP
argument_list|,
name|GL_INVERT
argument_list|,
name|GL_INVERT
argument_list|)
expr_stmt|;
name|glStencilMask
argument_list|(
name|value
operator|^
name|referenceClipValue
argument_list|)
expr_stmt|;
name|drawVertexArrays
argument_list|(
name|vertexCoordinateArray
argument_list|,
name|GL_TRIANGLE_FAN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glStencilOp
argument_list|(
name|GL_KEEP
argument_list|,
name|GL_REPLACE
argument_list|,
name|GL_REPLACE
argument_list|)
expr_stmt|;
name|glStencilMask
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|state
argument_list|()
operator|->
name|clipTestEnabled
operator|&&
name|path
operator|.
name|hasWindingFill
argument_list|()
condition|)
block|{
comment|// Pass when any clip bit is set, set high bit
name|glStencilFunc
argument_list|(
name|GL_NOTEQUAL
argument_list|,
name|GL_STENCIL_HIGH_BIT
argument_list|,
operator|~
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
name|composite
argument_list|(
name|vertexCoordinateArray
operator|.
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Pass when high bit is set, replace stencil value with new clip value
name|glStencilFunc
argument_list|(
name|GL_NOTEQUAL
argument_list|,
name|value
argument_list|,
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
name|composite
argument_list|(
name|vertexCoordinateArray
operator|.
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|glStencilFunc
argument_list|(
name|GL_LEQUAL
argument_list|,
name|value
argument_list|,
operator|~
name|GL_STENCIL_HIGH_BIT
argument_list|)
expr_stmt|;
name|glStencilMask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|glColorMask
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clip
name|void
name|QGL2PaintEngineEx
operator|::
name|clip
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
name|Qt
operator|::
name|ClipOperation
name|op
parameter_list|)
block|{
comment|//     qDebug("QGL2PaintEngineEx::clip()");
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|state
argument_list|()
operator|->
name|clipChanged
operator|=
literal|true
expr_stmt|;
name|ensureActive
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|Qt
operator|::
name|ReplaceClip
condition|)
block|{
name|op
operator|=
name|Qt
operator|::
name|IntersectClip
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasClipOperations
argument_list|()
condition|)
block|{
name|d
operator|->
name|systemStateChanged
argument_list|()
expr_stmt|;
name|state
argument_list|()
operator|->
name|canRestoreClip
operator|=
literal|false
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_GL_NO_SCISSOR_TEST
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
operator|&&
name|op
operator|==
name|Qt
operator|::
name|IntersectClip
operator|&&
operator|(
name|path
operator|.
name|shape
argument_list|()
operator|==
name|QVectorPath
operator|::
name|RectangleHint
operator|)
condition|)
block|{
specifier|const
name|QPointF
modifier|*
specifier|const
name|points
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|QPointF
operator|*
argument_list|>
argument_list|(
name|path
operator|.
name|points
argument_list|()
argument_list|)
decl_stmt|;
name|QRectF
name|rect
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|,
name|points
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
argument_list|()
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
operator|||
operator|(
name|state
argument_list|()
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxRotate
operator|&&
name|qFuzzyIsNull
argument_list|(
name|state
argument_list|()
operator|->
name|matrix
operator|.
name|m11
argument_list|()
argument_list|)
operator|&&
name|qFuzzyIsNull
argument_list|(
name|state
argument_list|()
operator|->
name|matrix
operator|.
name|m22
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|state
argument_list|()
operator|->
name|rectangleClip
operator|=
name|state
argument_list|()
operator|->
name|rectangleClip
operator|.
name|intersected
argument_list|(
name|state
argument_list|()
operator|->
name|matrix
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
operator|.
name|toRect
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateClipScissorTest
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
specifier|const
name|QRect
name|pathRect
init|=
name|state
argument_list|()
operator|->
name|matrix
operator|.
name|mapRect
argument_list|(
name|path
operator|.
name|controlPointRect
argument_list|()
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|Qt
operator|::
name|NoClip
case|:
if|if
condition|(
name|d
operator|->
name|useSystemClip
condition|)
block|{
name|state
argument_list|()
operator|->
name|clipTestEnabled
operator|=
literal|true
expr_stmt|;
name|state
argument_list|()
operator|->
name|currentClip
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|state
argument_list|()
operator|->
name|clipTestEnabled
operator|=
literal|false
expr_stmt|;
block|}
name|state
argument_list|()
operator|->
name|rectangleClip
operator|=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|)
expr_stmt|;
name|state
argument_list|()
operator|->
name|canRestoreClip
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|updateClipScissorTest
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|IntersectClip
case|:
name|state
argument_list|()
operator|->
name|rectangleClip
operator|=
name|state
argument_list|()
operator|->
name|rectangleClip
operator|.
name|intersected
argument_list|(
name|pathRect
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateClipScissorTest
argument_list|()
expr_stmt|;
name|d
operator|->
name|resetClipIfNeeded
argument_list|()
expr_stmt|;
operator|++
name|d
operator|->
name|maxClip
expr_stmt|;
name|d
operator|->
name|writeClip
argument_list|(
name|path
argument_list|,
name|d
operator|->
name|maxClip
argument_list|)
expr_stmt|;
name|state
argument_list|()
operator|->
name|currentClip
operator|=
name|d
operator|->
name|maxClip
expr_stmt|;
name|state
argument_list|()
operator|->
name|clipTestEnabled
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_function
DECL|function|regenerateClip
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|regenerateClip
parameter_list|()
block|{
name|systemStateChanged
argument_list|()
expr_stmt|;
name|replayClipOperations
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|systemStateChanged
name|void
name|QGL2PaintEngineExPrivate
operator|::
name|systemStateChanged
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|q
operator|->
name|state
argument_list|()
operator|->
name|clipChanged
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|systemClip
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|useSystemClip
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|q
operator|->
name|paintDevice
argument_list|()
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Widget
operator|&&
name|currentClipDevice
condition|)
block|{
name|QWidgetPrivate
modifier|*
name|widgetPrivate
init|=
name|qt_widget_private
argument_list|(
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|currentClipDevice
argument_list|)
operator|->
name|window
argument_list|()
argument_list|)
decl_stmt|;
name|useSystemClip
operator|=
name|widgetPrivate
operator|->
name|extra
operator|&&
name|widgetPrivate
operator|->
name|extra
operator|->
name|inRenderWithPainter
expr_stmt|;
block|}
else|else
block|{
name|useSystemClip
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|q
operator|->
name|state
argument_list|()
operator|->
name|clipTestEnabled
operator|=
literal|false
expr_stmt|;
name|q
operator|->
name|state
argument_list|()
operator|->
name|needsClipBufferClear
operator|=
literal|true
expr_stmt|;
name|q
operator|->
name|state
argument_list|()
operator|->
name|currentClip
operator|=
literal|1
expr_stmt|;
name|maxClip
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|state
argument_list|()
operator|->
name|rectangleClip
operator|=
name|useSystemClip
condition|?
name|systemClip
operator|.
name|boundingRect
argument_list|()
else|:
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|updateClipScissorTest
argument_list|()
expr_stmt|;
if|if
condition|(
name|systemClip
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|systemClip
operator|.
name|boundingRect
argument_list|()
operator|==
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
condition|)
name|useSystemClip
operator|=
literal|false
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_GL_NO_SCISSOR_TEST
comment|// scissoring takes care of the system clip
return|return;
endif|#
directive|endif
block|}
if|if
condition|(
name|useSystemClip
condition|)
block|{
name|clearClip
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addRegion
argument_list|(
name|systemClip
argument_list|)
expr_stmt|;
name|q
operator|->
name|state
argument_list|()
operator|->
name|currentClip
operator|=
literal|0
expr_stmt|;
name|writeClip
argument_list|(
name|qtVectorPathForPath
argument_list|(
name|q
operator|->
name|state
argument_list|()
operator|->
name|matrix
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|path
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|q
operator|->
name|state
argument_list|()
operator|->
name|currentClip
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|state
argument_list|()
operator|->
name|clipTestEnabled
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setTranslateZ
name|void
name|QGL2PaintEngineEx
operator|::
name|setTranslateZ
parameter_list|(
name|GLfloat
name|z
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|translateZ
operator|!=
name|z
condition|)
block|{
name|d
operator|->
name|translateZ
operator|=
name|z
expr_stmt|;
name|d
operator|->
name|translateZUniformDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setState
name|void
name|QGL2PaintEngineEx
operator|::
name|setState
parameter_list|(
name|QPainterState
modifier|*
name|new_state
parameter_list|)
block|{
comment|//     qDebug("QGL2PaintEngineEx::setState()");
name|Q_D
argument_list|(
name|QGL2PaintEngineEx
argument_list|)
expr_stmt|;
name|QGL2PaintEngineState
modifier|*
name|s
init|=
cast|static_cast
argument_list|<
name|QGL2PaintEngineState
operator|*
argument_list|>
argument_list|(
name|new_state
argument_list|)
decl_stmt|;
name|QGL2PaintEngineState
modifier|*
name|old_state
init|=
name|state
argument_list|()
decl_stmt|;
name|QPaintEngineEx
operator|::
name|setState
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|isNew
condition|)
block|{
comment|// Newly created state object.  The call to setState()
comment|// will either be followed by a call to begin(), or we are
comment|// setting the state as part of a save().
name|s
operator|->
name|isNew
operator|=
literal|false
expr_stmt|;
return|return;
block|}
comment|// Setting the state as part of a restore().
if|if
condition|(
name|old_state
operator|==
name|s
operator|||
name|old_state
operator|->
name|renderHintsChanged
condition|)
name|renderHintsChanged
argument_list|()
expr_stmt|;
if|if
condition|(
name|old_state
operator|==
name|s
operator|||
name|old_state
operator|->
name|matrixChanged
condition|)
name|d
operator|->
name|matrixDirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|old_state
operator|==
name|s
operator|||
name|old_state
operator|->
name|compositionModeChanged
condition|)
name|d
operator|->
name|compositionModeDirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|old_state
operator|==
name|s
operator|||
name|old_state
operator|->
name|opacityChanged
condition|)
name|d
operator|->
name|opacityUniformDirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|old_state
operator|==
name|s
operator|||
name|old_state
operator|->
name|clipChanged
condition|)
block|{
if|if
condition|(
name|old_state
operator|&&
name|old_state
operator|!=
name|s
operator|&&
name|old_state
operator|->
name|canRestoreClip
condition|)
block|{
name|d
operator|->
name|updateClipScissorTest
argument_list|()
expr_stmt|;
name|d
operator|->
name|glDepthFunc
argument_list|(
name|GL_LEQUAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|regenerateClip
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|createState
name|QPainterState
modifier|*
name|QGL2PaintEngineEx
operator|::
name|createState
parameter_list|(
name|QPainterState
modifier|*
name|orig
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|orig
condition|)
cast|const_cast
argument_list|<
name|QGL2PaintEngineEx
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|ensureActive
argument_list|()
expr_stmt|;
name|QGL2PaintEngineState
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|orig
condition|)
name|s
operator|=
operator|new
name|QGL2PaintEngineState
argument_list|()
expr_stmt|;
else|else
name|s
operator|=
operator|new
name|QGL2PaintEngineState
argument_list|(
operator|*
cast|static_cast
argument_list|<
name|QGL2PaintEngineState
operator|*
argument_list|>
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|matrixChanged
operator|=
literal|false
expr_stmt|;
name|s
operator|->
name|compositionModeChanged
operator|=
literal|false
expr_stmt|;
name|s
operator|->
name|opacityChanged
operator|=
literal|false
expr_stmt|;
name|s
operator|->
name|renderHintsChanged
operator|=
literal|false
expr_stmt|;
name|s
operator|->
name|clipChanged
operator|=
literal|false
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_constructor
DECL|function|QGL2PaintEngineState
name|QGL2PaintEngineState
operator|::
name|QGL2PaintEngineState
parameter_list|(
name|QGL2PaintEngineState
modifier|&
name|other
parameter_list|)
member_init_list|:
name|QPainterState
argument_list|(
name|other
argument_list|)
block|{
name|isNew
operator|=
literal|true
expr_stmt|;
name|needsClipBufferClear
operator|=
name|other
operator|.
name|needsClipBufferClear
expr_stmt|;
name|clipTestEnabled
operator|=
name|other
operator|.
name|clipTestEnabled
expr_stmt|;
name|currentClip
operator|=
name|other
operator|.
name|currentClip
expr_stmt|;
name|canRestoreClip
operator|=
name|other
operator|.
name|canRestoreClip
expr_stmt|;
name|rectangleClip
operator|=
name|other
operator|.
name|rectangleClip
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QGL2PaintEngineState
name|QGL2PaintEngineState
operator|::
name|QGL2PaintEngineState
parameter_list|()
block|{
name|isNew
operator|=
literal|true
expr_stmt|;
name|needsClipBufferClear
operator|=
literal|true
expr_stmt|;
name|clipTestEnabled
operator|=
literal|false
expr_stmt|;
name|canRestoreClip
operator|=
literal|true
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QGL2PaintEngineState
name|QGL2PaintEngineState
operator|::
name|~
name|QGL2PaintEngineState
parameter_list|()
block|{ }
end_destructor
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
