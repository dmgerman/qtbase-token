begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtDBus module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdbusintegrator_p.h"
end_include
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qmetaobject.h>
end_include
begin_include
include|#
directive|include
file|<qobject.h>
end_include
begin_include
include|#
directive|include
file|<qsocketnotifier.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qtimer.h>
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|"qdbusargument.h"
end_include
begin_include
include|#
directive|include
file|"qdbusconnection_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusconnectionmanager_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusinterface_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmessage.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmetatype.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmetatype_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusabstractadaptor.h"
end_include
begin_include
include|#
directive|include
file|"qdbusabstractadaptor_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusutil_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusvirtualobject.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmessage_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbuscontext_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbuspendingcall_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusthreaddebug_p.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DBUS
end_ifndef
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|isDebugging
specifier|static
name|bool
name|isDebugging
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|qDBusDebug
define|#
directive|define
name|qDBusDebug
value|if (!::isDebugging); else qDebug
end_define
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|const QString
argument_list|,
argument|orgFreedesktopDBusString
argument_list|,
argument|(QLatin1String(DBUS_SERVICE_DBUS))
argument_list|)
end_macro
begin_function
DECL|function|dbusServiceString
specifier|static
specifier|inline
name|QString
name|dbusServiceString
parameter_list|()
block|{
return|return
operator|*
name|orgFreedesktopDBusString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|dbusInterfaceString
specifier|static
specifier|inline
name|QString
name|dbusInterfaceString
parameter_list|()
block|{
comment|// it's the same string, but just be sure
name|Q_ASSERT
argument_list|(
operator|*
name|orgFreedesktopDBusString
argument_list|()
operator|==
name|QLatin1String
argument_list|(
name|DBUS_INTERFACE_DBUS
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|orgFreedesktopDBusString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|operator <<
specifier|static
specifier|inline
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QThread
modifier|*
name|th
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QThread(ptr="
operator|<<
operator|(
name|void
operator|*
operator|)
name|th
expr_stmt|;
if|if
condition|(
name|th
operator|&&
operator|!
name|th
operator|->
name|objectName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|", name="
operator|<<
name|th
operator|->
name|objectName
argument_list|()
expr_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_if
if|#
directive|if
name|QDBUS_THREAD_DEBUG
end_if
begin_function
DECL|function|operator <<
specifier|static
specifier|inline
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QDBusConnectionPrivate
modifier|*
name|conn
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QDBusConnection("
operator|<<
literal|"ptr="
operator|<<
operator|(
name|void
operator|*
operator|)
name|conn
operator|<<
literal|", name="
operator|<<
name|conn
operator|->
name|name
operator|<<
literal|", baseService="
operator|<<
name|conn
operator|->
name|baseService
operator|<<
literal|", thread="
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|thread
argument_list|()
operator|==
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"same thread"
expr_stmt|;
else|else
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
name|conn
operator|->
name|thread
argument_list|()
expr_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|qdbusDefaultThreadDebug
name|void
name|qdbusDefaultThreadDebug
parameter_list|(
name|int
name|action
parameter_list|,
name|int
name|condition
parameter_list|,
name|QDBusConnectionPrivate
modifier|*
name|conn
parameter_list|)
block|{
name|qDBusDebug
argument_list|()
operator|<<
name|QThread
operator|::
name|currentThread
argument_list|()
operator|<<
literal|"Qt D-Bus threading action"
operator|<<
name|action
operator|<<
operator|(
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|BeforeLock
condition|?
literal|"before lock"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|AfterLock
condition|?
literal|"after lock"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|BeforeUnlock
condition|?
literal|"before unlock"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|AfterUnlock
condition|?
literal|"after unlock"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|BeforePost
condition|?
literal|"before event posting"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|AfterPost
condition|?
literal|"after event posting"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|BeforeDeliver
condition|?
literal|"before event delivery"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|AfterDeliver
condition|?
literal|"after event delivery"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|BeforeAcquire
condition|?
literal|"before acquire"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|AfterAcquire
condition|?
literal|"after acquire"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|BeforeRelease
condition|?
literal|"before release"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|AfterRelease
condition|?
literal|"after release"
else|:
literal|"condition unknown"
operator|)
operator|<<
literal|"in connection"
operator|<<
name|conn
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|qdbusThreadDebug
name|qdbusThreadDebugFunc
name|qdbusThreadDebug
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|QDBusSpyHook
typedef|typedef
name|void
function_decl|(
modifier|*
name|QDBusSpyHook
function_decl|)
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|QDBusSpyHookList
typedef|typedef
name|QVarLengthArray
argument_list|<
name|QDBusSpyHook
argument_list|,
literal|4
argument_list|>
name|QDBusSpyHookList
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QDBusSpyHookList
argument_list|,
argument|qDBusSpyHookList
argument_list|)
end_macro
begin_extern
extern|extern
literal|"C"
block|{
comment|// libdbus-1 callbacks
specifier|static
name|bool
name|qDBusRealAddTimeout
parameter_list|(
name|QDBusConnectionPrivate
modifier|*
name|d
parameter_list|,
name|DBusTimeout
modifier|*
name|timeout
parameter_list|,
name|int
name|ms
parameter_list|)
function_decl|;
DECL|function|qDBusAddTimeout
specifier|static
name|dbus_bool_t
name|qDBusAddTimeout
parameter_list|(
name|DBusTimeout
modifier|*
name|timeout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|//  qDebug("addTimeout %d", q_dbus_timeout_get_interval(timeout));
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|q_dbus_timeout_get_enabled
argument_list|(
name|timeout
argument_list|)
condition|)
return|return
literal|true
return|;
name|QDBusWatchAndTimeoutLocker
name|locker
argument_list|(
name|AddTimeoutAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|&&
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|d
operator|->
name|thread
argument_list|()
condition|)
block|{
comment|// correct thread
return|return
name|qDBusRealAddTimeout
argument_list|(
name|d
argument_list|,
name|timeout
argument_list|,
name|q_dbus_timeout_get_interval
argument_list|(
name|timeout
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|// wrong thread: sync back
name|QDBusConnectionCallbackEvent
modifier|*
name|ev
init|=
operator|new
name|QDBusConnectionCallbackEvent
decl_stmt|;
name|ev
operator|->
name|subtype
operator|=
name|QDBusConnectionCallbackEvent
operator|::
name|AddTimeout
expr_stmt|;
name|d
operator|->
name|timeoutsPendingAdd
operator|.
name|append
argument_list|(
name|qMakePair
argument_list|(
name|timeout
argument_list|,
name|q_dbus_timeout_get_interval
argument_list|(
name|timeout
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|postEventToThread
argument_list|(
name|AddTimeoutAction
argument_list|,
name|d
argument_list|,
name|ev
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
DECL|function|qDBusRealAddTimeout
specifier|static
name|bool
name|qDBusRealAddTimeout
parameter_list|(
name|QDBusConnectionPrivate
modifier|*
name|d
parameter_list|,
name|DBusTimeout
modifier|*
name|timeout
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|timeouts
operator|.
name|keys
argument_list|(
name|timeout
argument_list|)
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|timerId
init|=
name|d
operator|->
name|startTimer
argument_list|(
name|ms
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|timerId
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|timeouts
index|[
name|timerId
index|]
operator|=
name|timeout
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|qDBusRemoveTimeout
specifier|static
name|void
name|qDBusRemoveTimeout
parameter_list|(
name|DBusTimeout
modifier|*
name|timeout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|//  qDebug("removeTimeout");
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|QDBusWatchAndTimeoutLocker
name|locker
argument_list|(
name|RemoveTimeoutAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
comment|// is it pending addition?
name|QDBusConnectionPrivate
operator|::
name|PendingTimeoutList
operator|::
name|iterator
name|pit
init|=
name|d
operator|->
name|timeoutsPendingAdd
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|pit
operator|!=
name|d
operator|->
name|timeoutsPendingAdd
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|pit
operator|->
name|first
operator|==
name|timeout
condition|)
name|pit
operator|=
name|d
operator|->
name|timeoutsPendingAdd
operator|.
name|erase
argument_list|(
name|pit
argument_list|)
expr_stmt|;
else|else
operator|++
name|pit
expr_stmt|;
block|}
comment|// is it a running timer?
name|bool
name|correctThread
init|=
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|&&
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|d
operator|->
name|thread
argument_list|()
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|TimeoutHash
operator|::
name|iterator
name|it
init|=
name|d
operator|->
name|timeouts
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|timeouts
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|==
name|timeout
condition|)
block|{
if|if
condition|(
name|correctThread
condition|)
block|{
comment|// correct thread
name|d
operator|->
name|killTimer
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// incorrect thread or no application, post an event for later
name|QDBusConnectionCallbackEvent
modifier|*
name|ev
init|=
operator|new
name|QDBusConnectionCallbackEvent
decl_stmt|;
name|ev
operator|->
name|subtype
operator|=
name|QDBusConnectionCallbackEvent
operator|::
name|KillTimer
expr_stmt|;
name|ev
operator|->
name|timerId
operator|=
name|it
operator|.
name|key
argument_list|()
expr_stmt|;
name|d
operator|->
name|postEventToThread
argument_list|(
name|KillTimerAction
argument_list|,
name|d
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
name|it
operator|=
name|d
operator|->
name|timeouts
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|++
name|it
expr_stmt|;
block|}
block|}
block|}
DECL|function|qDBusToggleTimeout
specifier|static
name|void
name|qDBusToggleTimeout
parameter_list|(
name|DBusTimeout
modifier|*
name|timeout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|//qDebug("ToggleTimeout");
name|qDBusRemoveTimeout
argument_list|(
name|timeout
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|qDBusAddTimeout
argument_list|(
name|timeout
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
specifier|static
name|bool
name|qDBusRealAddWatch
parameter_list|(
name|QDBusConnectionPrivate
modifier|*
name|d
parameter_list|,
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fd
parameter_list|)
function_decl|;
DECL|function|qDBusAddWatch
specifier|static
name|dbus_bool_t
name|qDBusAddWatch
parameter_list|(
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|watch
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|q_dbus_watch_get_flags
argument_list|(
name|watch
argument_list|)
decl_stmt|;
name|int
name|fd
init|=
name|q_dbus_watch_get_unix_fd
argument_list|(
name|watch
argument_list|)
decl_stmt|;
if|if
condition|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|&&
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|d
operator|->
name|thread
argument_list|()
condition|)
block|{
return|return
name|qDBusRealAddWatch
argument_list|(
name|d
argument_list|,
name|watch
argument_list|,
name|flags
argument_list|,
name|fd
argument_list|)
return|;
block|}
else|else
block|{
name|QDBusConnectionCallbackEvent
modifier|*
name|ev
init|=
operator|new
name|QDBusConnectionCallbackEvent
decl_stmt|;
name|ev
operator|->
name|subtype
operator|=
name|QDBusConnectionCallbackEvent
operator|::
name|AddWatch
expr_stmt|;
name|ev
operator|->
name|watch
operator|=
name|watch
expr_stmt|;
name|ev
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|ev
operator|->
name|extra
operator|=
name|flags
expr_stmt|;
name|d
operator|->
name|postEventToThread
argument_list|(
name|AddWatchAction
argument_list|,
name|d
argument_list|,
name|ev
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
DECL|function|qDBusRealAddWatch
specifier|static
name|bool
name|qDBusRealAddWatch
parameter_list|(
name|QDBusConnectionPrivate
modifier|*
name|d
parameter_list|,
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|QDBusConnectionPrivate
operator|::
name|Watcher
name|watcher
decl_stmt|;
name|QDBusWatchAndTimeoutLocker
name|locker
argument_list|(
name|AddWatchAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_READABLE
condition|)
block|{
comment|//qDebug("addReadWatch %d", fd);
name|watcher
operator|.
name|watch
operator|=
name|watch
expr_stmt|;
if|if
condition|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
condition|)
block|{
name|watcher
operator|.
name|read
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|fd
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|watcher
operator|.
name|read
operator|->
name|setEnabled
argument_list|(
name|q_dbus_watch_get_enabled
argument_list|(
name|watch
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|connect
argument_list|(
name|watcher
operator|.
name|read
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|socketRead
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_WRITABLE
condition|)
block|{
comment|//qDebug("addWriteWatch %d", fd);
name|watcher
operator|.
name|watch
operator|=
name|watch
expr_stmt|;
if|if
condition|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
condition|)
block|{
name|watcher
operator|.
name|write
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|fd
argument_list|,
name|QSocketNotifier
operator|::
name|Write
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|watcher
operator|.
name|write
operator|->
name|setEnabled
argument_list|(
name|q_dbus_watch_get_enabled
argument_list|(
name|watch
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|connect
argument_list|(
name|watcher
operator|.
name|write
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|socketWrite
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|watchers
operator|.
name|insertMulti
argument_list|(
name|fd
argument_list|,
name|watcher
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|qDBusRemoveWatch
specifier|static
name|void
name|qDBusRemoveWatch
parameter_list|(
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|watch
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|//qDebug("remove watch");
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|int
name|fd
init|=
name|q_dbus_watch_get_unix_fd
argument_list|(
name|watch
argument_list|)
decl_stmt|;
name|QDBusWatchAndTimeoutLocker
name|locker
argument_list|(
name|RemoveWatchAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|WatcherHash
operator|::
name|iterator
name|i
init|=
name|d
operator|->
name|watchers
operator|.
name|find
argument_list|(
name|fd
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|d
operator|->
name|watchers
operator|.
name|end
argument_list|()
operator|&&
name|i
operator|.
name|key
argument_list|()
operator|==
name|fd
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|.
name|watch
operator|==
name|watch
condition|)
block|{
if|if
condition|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|&&
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|d
operator|->
name|thread
argument_list|()
condition|)
block|{
comment|// correct thread, delete the socket notifiers
operator|delete
name|i
operator|.
name|value
argument_list|()
operator|.
name|read
expr_stmt|;
operator|delete
name|i
operator|.
name|value
argument_list|()
operator|.
name|write
expr_stmt|;
block|}
else|else
block|{
comment|// incorrect thread or no application, use delete later
if|if
condition|(
name|i
operator|->
name|read
condition|)
name|i
operator|->
name|read
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|write
condition|)
name|i
operator|->
name|write
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
name|i
operator|=
name|d
operator|->
name|watchers
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
specifier|static
name|void
name|qDBusRealToggleWatch
parameter_list|(
name|QDBusConnectionPrivate
modifier|*
name|d
parameter_list|,
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|int
name|fd
parameter_list|)
function_decl|;
DECL|function|qDBusToggleWatch
specifier|static
name|void
name|qDBusToggleWatch
parameter_list|(
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|watch
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|int
name|fd
init|=
name|q_dbus_watch_get_unix_fd
argument_list|(
name|watch
argument_list|)
decl_stmt|;
if|if
condition|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|&&
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|d
operator|->
name|thread
argument_list|()
condition|)
block|{
name|qDBusRealToggleWatch
argument_list|(
name|d
argument_list|,
name|watch
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QDBusConnectionCallbackEvent
modifier|*
name|ev
init|=
operator|new
name|QDBusConnectionCallbackEvent
decl_stmt|;
name|ev
operator|->
name|subtype
operator|=
name|QDBusConnectionCallbackEvent
operator|::
name|ToggleWatch
expr_stmt|;
name|ev
operator|->
name|watch
operator|=
name|watch
expr_stmt|;
name|ev
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|d
operator|->
name|postEventToThread
argument_list|(
name|ToggleWatchAction
argument_list|,
name|d
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|qDBusRealToggleWatch
specifier|static
name|void
name|qDBusRealToggleWatch
parameter_list|(
name|QDBusConnectionPrivate
modifier|*
name|d
parameter_list|,
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|QDBusWatchAndTimeoutLocker
name|locker
argument_list|(
name|ToggleWatchAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|WatcherHash
operator|::
name|iterator
name|i
init|=
name|d
operator|->
name|watchers
operator|.
name|find
argument_list|(
name|fd
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|d
operator|->
name|watchers
operator|.
name|end
argument_list|()
operator|&&
name|i
operator|.
name|key
argument_list|()
operator|==
name|fd
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|.
name|watch
operator|==
name|watch
condition|)
block|{
name|bool
name|enabled
init|=
name|q_dbus_watch_get_enabled
argument_list|(
name|watch
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|q_dbus_watch_get_flags
argument_list|(
name|watch
argument_list|)
decl_stmt|;
comment|//qDebug("toggle watch %d to %d (write: %d, read: %d)", q_dbus_watch_get_fd(watch), enabled, flags& DBUS_WATCH_WRITABLE, flags& DBUS_WATCH_READABLE);
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_READABLE
operator|&&
name|i
operator|.
name|value
argument_list|()
operator|.
name|read
condition|)
name|i
operator|.
name|value
argument_list|()
operator|.
name|read
operator|->
name|setEnabled
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_WRITABLE
operator|&&
name|i
operator|.
name|value
argument_list|()
operator|.
name|write
condition|)
name|i
operator|.
name|value
argument_list|()
operator|.
name|write
operator|->
name|setEnabled
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|i
expr_stmt|;
block|}
block|}
DECL|function|qDBusUpdateDispatchStatus
specifier|static
name|void
name|qDBusUpdateDispatchStatus
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|DBusDispatchStatus
name|new_status
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
specifier|static
name|int
name|slotId
decl_stmt|;
comment|// 0 is QObject::deleteLater()
if|if
condition|(
operator|!
name|slotId
condition|)
block|{
comment|// it's ok to do this: there's no race condition because the store is atomic
comment|// and we always set to the same value
name|slotId
operator|=
name|QDBusConnectionPrivate
operator|::
name|staticMetaObject
operator|.
name|indexOfSlot
argument_list|(
literal|"doDispatch()"
argument_list|)
expr_stmt|;
block|}
comment|//qDBusDebug()<< "Updating dispatcher status"<< slotId;
if|if
condition|(
name|new_status
operator|==
name|DBUS_DISPATCH_DATA_REMAINS
condition|)
name|QDBusConnectionPrivate
operator|::
name|staticMetaObject
operator|.
name|method
argument_list|(
name|slotId
argument_list|)
operator|.
name|invoke
argument_list|(
name|d
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
DECL|function|qDBusNewConnection
specifier|static
name|void
name|qDBusNewConnection
parameter_list|(
name|DBusServer
modifier|*
name|server
parameter_list|,
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
comment|// ### We may want to separate the server from the QDBusConnectionPrivate
name|Q_ASSERT
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|// keep the connection alive
name|q_dbus_connection_ref
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|serverConnection
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|newConnection
init|=
operator|new
name|QDBusConnectionPrivate
argument_list|(
name|serverConnection
operator|->
name|parent
argument_list|()
argument_list|)
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|QDBusConnectionManager
operator|::
name|instance
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|QDBusConnectionManager
operator|::
name|instance
argument_list|()
operator|->
name|setConnection
argument_list|(
name|QLatin1String
argument_list|(
literal|"QDBusServer-"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
cast|reinterpret_cast
argument_list|<
name|qulonglong
argument_list|>
argument_list|(
name|newConnection
argument_list|)
argument_list|)
argument_list|,
name|newConnection
argument_list|)
expr_stmt|;
name|serverConnection
operator|->
name|serverConnectionNames
operator|<<
name|newConnection
operator|->
name|name
expr_stmt|;
comment|// setPeer does the error handling for us
name|QDBusErrorInternal
name|error
decl_stmt|;
name|newConnection
operator|->
name|setPeer
argument_list|(
name|connection
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|QDBusConnection
name|retval
init|=
name|QDBusConnectionPrivate
operator|::
name|q
argument_list|(
name|newConnection
argument_list|)
decl_stmt|;
comment|// make QDBusServer emit the newConnection signal
name|serverConnection
operator|->
name|serverConnection
parameter_list|(
name|retval
parameter_list|)
constructor_decl|;
block|}
block|}
end_extern
begin_comment
comment|// extern "C"
end_comment
begin_function
DECL|function|buildMatchRule
specifier|static
name|QByteArray
name|buildMatchRule
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|objectPath
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|member
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|argMatch
parameter_list|,
specifier|const
name|QString
modifier|&
comment|/*signature*/
parameter_list|)
block|{
name|QString
name|result
init|=
name|QLatin1String
argument_list|(
literal|"type='signal',"
argument_list|)
decl_stmt|;
name|QString
name|keyValue
init|=
name|QLatin1String
argument_list|(
literal|"%1='%2',"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|service
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|+=
name|keyValue
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
literal|"sender"
argument_list|)
argument_list|,
name|service
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|objectPath
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|+=
name|keyValue
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
literal|"path"
argument_list|)
argument_list|,
name|objectPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|+=
name|keyValue
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
literal|"interface"
argument_list|)
argument_list|,
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|member
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|+=
name|keyValue
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
literal|"member"
argument_list|)
argument_list|,
name|member
argument_list|)
expr_stmt|;
comment|// add the argument string-matching now
if|if
condition|(
operator|!
name|argMatch
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|keyValue
operator|=
name|QLatin1String
argument_list|(
literal|"arg%1='%2',"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argMatch
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|argMatch
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isNull
argument_list|()
condition|)
name|result
operator|+=
name|keyValue
operator|.
name|arg
argument_list|(
name|i
argument_list|)
operator|.
name|arg
argument_list|(
name|argMatch
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// remove ending comma
return|return
name|result
operator|.
name|toLatin1
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|findObject
specifier|static
name|bool
name|findObject
parameter_list|(
specifier|const
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|*
name|root
parameter_list|,
specifier|const
name|QString
modifier|&
name|fullpath
parameter_list|,
name|int
modifier|&
name|usedLength
parameter_list|,
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|&
name|result
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fullpath
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
argument_list|)
operator|&&
name|root
operator|->
name|obj
condition|)
block|{
name|usedLength
operator|=
literal|1
expr_stmt|;
name|result
operator|=
operator|*
name|root
expr_stmt|;
return|return
name|root
return|;
block|}
name|int
name|start
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
name|fullpath
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|fullpath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
name|start
operator|=
literal|1
expr_stmt|;
comment|// walk the object tree
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|ConstIterator
name|node
init|=
name|root
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|length
operator|&&
name|node
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportChildObjects
condition|)
break|break;
if|if
condition|(
operator|(
name|node
operator|->
name|flags
operator|&
name|QDBusConnectionPrivate
operator|::
name|VirtualObject
operator|)
operator|&&
operator|(
name|node
operator|->
name|flags
operator|&
name|QDBusConnection
operator|::
name|SubPath
operator|)
condition|)
break|break;
name|int
name|end
init|=
name|fullpath
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|start
argument_list|)
decl_stmt|;
name|end
operator|=
operator|(
name|end
operator|==
operator|-
literal|1
condition|?
name|length
else|:
name|end
operator|)
expr_stmt|;
name|QStringRef
name|pathComponent
argument_list|(
operator|&
name|fullpath
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|ConstIterator
name|it
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|node
operator|->
name|children
operator|.
name|constBegin
argument_list|()
argument_list|,
name|node
operator|->
name|children
operator|.
name|constEnd
argument_list|()
argument_list|,
name|pathComponent
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|node
operator|->
name|children
operator|.
name|constEnd
argument_list|()
operator|&&
name|it
operator|->
name|name
operator|==
name|pathComponent
condition|)
comment|// match
name|node
operator|=
name|it
expr_stmt|;
else|else
name|node
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|end
operator|+
literal|1
expr_stmt|;
block|}
comment|// found our object
name|usedLength
operator|=
operator|(
name|start
operator|>
name|length
condition|?
name|length
else|:
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|obj
operator|||
operator|!
name|node
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|=
operator|*
name|node
expr_stmt|;
else|else
comment|// there really is no object here
comment|// we're just looking at an unused space in the QVector
name|node
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|findChildObject
specifier|static
name|QObject
modifier|*
name|findChildObject
parameter_list|(
specifier|const
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|*
name|root
parameter_list|,
specifier|const
name|QString
modifier|&
name|fullpath
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|length
init|=
name|fullpath
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// any object in the tree can tell us to switch to its own object tree:
specifier|const
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|*
name|node
init|=
name|root
decl_stmt|;
if|if
condition|(
name|node
operator|&&
name|node
operator|->
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportChildObjects
condition|)
block|{
name|QObject
modifier|*
name|obj
init|=
name|node
operator|->
name|obj
decl_stmt|;
while|while
condition|(
name|obj
condition|)
block|{
if|if
condition|(
name|start
operator|>=
name|length
condition|)
comment|// we're at the correct level
return|return
name|obj
return|;
name|int
name|pos
init|=
name|fullpath
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|start
argument_list|)
decl_stmt|;
name|pos
operator|=
operator|(
name|pos
operator|==
operator|-
literal|1
condition|?
name|length
else|:
name|pos
operator|)
expr_stmt|;
name|QStringRef
name|pathComponent
argument_list|(
operator|&
name|fullpath
argument_list|,
name|start
argument_list|,
name|pos
operator|-
name|start
argument_list|)
decl_stmt|;
specifier|const
name|QObjectList
name|children
init|=
name|obj
operator|->
name|children
argument_list|()
decl_stmt|;
comment|// find a child with the proper name
name|QObject
modifier|*
name|next
init|=
literal|0
decl_stmt|;
name|QObjectList
operator|::
name|ConstIterator
name|it
init|=
name|children
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QObjectList
operator|::
name|ConstIterator
name|end
init|=
name|children
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|->
name|objectName
argument_list|()
operator|==
name|pathComponent
condition|)
block|{
name|next
operator|=
operator|*
name|it
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|next
condition|)
break|break;
name|obj
operator|=
name|next
expr_stmt|;
name|start
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|// object not found
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|shouldWatchService
specifier|static
name|bool
name|shouldWatchService
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|)
block|{
return|return
operator|!
name|service
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|service
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function_decl
specifier|extern
name|Q_DBUS_EXPORT
name|void
name|qDBusAddSpyHook
parameter_list|(
name|QDBusSpyHook
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|qDBusAddSpyHook
name|void
name|qDBusAddSpyHook
parameter_list|(
name|QDBusSpyHook
name|hook
parameter_list|)
block|{
name|qDBusSpyHookList
argument_list|()
operator|->
name|append
argument_list|(
name|hook
argument_list|)
expr_stmt|;
block|}
end_function
begin_extern
extern|extern
literal|"C"
block|{
specifier|static
name|DBusHandlerResult
DECL|function|qDBusSignalFilter
name|qDBusSignalFilter
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|QDBusConnectionPrivate
operator|::
name|InvalidMode
condition|)
return|return
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
name|QDBusMessage
name|amsg
init|=
name|QDBusMessagePrivate
operator|::
name|fromDBusMessage
argument_list|(
name|message
argument_list|,
name|d
operator|->
name|capabilities
argument_list|)
decl_stmt|;
name|qDBusDebug
argument_list|()
operator|<<
name|d
operator|<<
literal|"got message (signal):"
operator|<<
name|amsg
expr_stmt|;
return|return
name|d
operator|->
name|handleMessage
argument_list|(
name|amsg
argument_list|)
condition|?
name|DBUS_HANDLER_RESULT_HANDLED
else|:
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
block|}
block|}
end_extern
begin_function
DECL|function|handleMessage
name|bool
name|QDBusConnectionPrivate
operator|::
name|handleMessage
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|amsg
parameter_list|)
block|{
specifier|const
name|QDBusSpyHookList
modifier|*
name|list
init|=
name|qDBusSpyHookList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|qDBusDebug
argument_list|()
operator|<<
literal|"calling the message spy hook"
expr_stmt|;
operator|(
operator|*
operator|(
operator|*
name|list
operator|)
index|[
name|i
index|]
operator|)
operator|(
name|amsg
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ref
operator|.
name|load
argument_list|()
condition|)
return|return
literal|false
return|;
switch|switch
condition|(
name|amsg
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|QDBusMessage
operator|::
name|SignalMessage
case|:
name|handleSignal
argument_list|(
name|amsg
argument_list|)
expr_stmt|;
comment|// if there are any other filters in this DBusConnection,
comment|// let them see the signal too
return|return
literal|false
return|;
case|case
name|QDBusMessage
operator|::
name|MethodCallMessage
case|:
name|handleObjectCall
argument_list|(
name|amsg
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|QDBusMessage
operator|::
name|ReplyMessage
case|:
case|case
name|QDBusMessage
operator|::
name|ErrorMessage
case|:
case|case
name|QDBusMessage
operator|::
name|InvalidMessage
case|:
return|return
literal|false
return|;
comment|// we don't handle those here
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|garbageCollectChildren
specifier|static
name|void
name|garbageCollectChildren
parameter_list|(
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|&
name|node
parameter_list|)
block|{
name|int
name|size
init|=
name|node
operator|.
name|children
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|activeChildren
operator|==
literal|0
condition|)
block|{
comment|// easy case
name|node
operator|.
name|children
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>
name|node
operator|.
name|activeChildren
operator|*
literal|3
operator|||
operator|(
name|size
operator|>
literal|20
operator|&&
name|size
operator|*
literal|2
operator|>
name|node
operator|.
name|activeChildren
operator|*
literal|3
operator|)
condition|)
block|{
comment|// rewrite the vector, keeping only the active children
comment|// if the vector is large (> 20 items) and has one third of inactives
comment|// or if the vector is small and has two thirds of inactives.
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|end
init|=
name|node
operator|.
name|children
operator|.
name|end
argument_list|()
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|it
init|=
name|node
operator|.
name|children
operator|.
name|begin
argument_list|()
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|tgt
init|=
name|it
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|it
operator|->
name|isActive
argument_list|()
condition|)
operator|*
name|tgt
operator|++
operator|=
name|qMove
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
block|}
operator|++
name|tgt
expr_stmt|;
name|node
operator|.
name|children
operator|.
name|erase
argument_list|(
name|tgt
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|huntAndDestroy
specifier|static
name|void
name|huntAndDestroy
parameter_list|(
name|QObject
modifier|*
name|needle
parameter_list|,
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|&
name|haystack
parameter_list|)
block|{
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|it
init|=
name|haystack
operator|.
name|children
operator|.
name|begin
argument_list|()
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|end
init|=
name|haystack
operator|.
name|children
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|!
name|it
operator|->
name|isActive
argument_list|()
condition|)
continue|continue;
name|huntAndDestroy
argument_list|(
name|needle
argument_list|,
operator|*
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|it
operator|->
name|isActive
argument_list|()
condition|)
operator|--
name|haystack
operator|.
name|activeChildren
expr_stmt|;
block|}
if|if
condition|(
name|needle
operator|==
name|haystack
operator|.
name|obj
condition|)
block|{
name|haystack
operator|.
name|obj
operator|=
literal|0
expr_stmt|;
name|haystack
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|garbageCollectChildren
argument_list|(
name|haystack
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|huntAndUnregister
specifier|static
name|void
name|huntAndUnregister
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|pathComponents
parameter_list|,
name|int
name|i
parameter_list|,
name|QDBusConnection
operator|::
name|UnregisterMode
name|mode
parameter_list|,
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|pathComponents
operator|.
name|count
argument_list|()
operator|==
name|i
condition|)
block|{
comment|// found it
name|node
operator|->
name|obj
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|QDBusConnection
operator|::
name|UnregisterTree
condition|)
block|{
comment|// clear the sub-tree as well
name|node
operator|->
name|activeChildren
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|children
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// can't disconnect the objects because we really don't know if they can
comment|// be found somewhere else in the path too
block|}
block|}
else|else
block|{
comment|// keep going
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|end
init|=
name|node
operator|->
name|children
operator|.
name|end
argument_list|()
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|it
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|node
operator|->
name|children
operator|.
name|begin
argument_list|()
argument_list|,
name|end
argument_list|,
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|end
operator|||
name|it
operator|->
name|name
operator|!=
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|||
operator|!
name|it
operator|->
name|isActive
argument_list|()
condition|)
return|return;
comment|// node not found
name|huntAndUnregister
argument_list|(
name|pathComponents
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|mode
argument_list|,
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|it
operator|->
name|isActive
argument_list|()
condition|)
operator|--
name|node
operator|->
name|activeChildren
expr_stmt|;
name|garbageCollectChildren
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|huntAndEmit
specifier|static
name|void
name|huntAndEmit
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|DBusMessage
modifier|*
name|msg
parameter_list|,
name|QObject
modifier|*
name|needle
parameter_list|,
specifier|const
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|&
name|haystack
parameter_list|,
name|bool
name|isScriptable
parameter_list|,
name|bool
name|isAdaptor
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
init|=
name|QString
argument_list|()
parameter_list|)
block|{
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|ConstIterator
name|it
init|=
name|haystack
operator|.
name|children
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|ConstIterator
name|end
init|=
name|haystack
operator|.
name|children
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|it
operator|->
name|isActive
argument_list|()
condition|)
name|huntAndEmit
argument_list|(
name|connection
argument_list|,
name|msg
argument_list|,
name|needle
argument_list|,
operator|*
name|it
argument_list|,
name|isScriptable
argument_list|,
name|isAdaptor
argument_list|,
name|path
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|it
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needle
operator|==
name|haystack
operator|.
name|obj
condition|)
block|{
comment|// is this a signal we should relay?
if|if
condition|(
name|isAdaptor
operator|&&
operator|(
name|haystack
operator|.
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportAdaptors
operator|)
operator|==
literal|0
condition|)
return|return;
comment|// no: it comes from an adaptor and we're not exporting adaptors
elseif|else
if|if
condition|(
operator|!
name|isAdaptor
condition|)
block|{
name|int
name|mask
init|=
name|isScriptable
condition|?
name|QDBusConnection
operator|::
name|ExportScriptableSignals
else|:
name|QDBusConnection
operator|::
name|ExportNonScriptableSignals
decl_stmt|;
if|if
condition|(
operator|(
name|haystack
operator|.
name|flags
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
return|return;
comment|// signal was not exported
block|}
name|QByteArray
name|p
init|=
name|path
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|isEmpty
argument_list|()
condition|)
name|p
operator|=
literal|"/"
expr_stmt|;
name|qDBusDebug
argument_list|()
operator|<<
name|QThread
operator|::
name|currentThread
argument_list|()
operator|<<
literal|"emitting signal at"
operator|<<
name|p
expr_stmt|;
name|DBusMessage
modifier|*
name|msg2
init|=
name|q_dbus_message_copy
argument_list|(
name|msg
argument_list|)
decl_stmt|;
name|q_dbus_message_set_path
argument_list|(
name|msg2
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|q_dbus_connection_send
argument_list|(
name|connection
argument_list|,
name|msg2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_dbus_message_unref
argument_list|(
name|msg2
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|findSlot
specifier|static
name|int
name|findSlot
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|mo
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature_
parameter_list|,
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|metaTypes
parameter_list|)
block|{
name|QByteArray
name|msgSignature
init|=
name|signature_
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
name|mo
operator|->
name|methodCount
argument_list|()
operator|-
literal|1
init|;
name|idx
operator|>=
name|QObject
operator|::
name|staticMetaObject
operator|.
name|methodCount
argument_list|()
condition|;
operator|--
name|idx
control|)
block|{
name|QMetaMethod
name|mm
init|=
name|mo
operator|->
name|method
argument_list|(
name|idx
argument_list|)
decl_stmt|;
comment|// check access:
if|if
condition|(
name|mm
operator|.
name|access
argument_list|()
operator|!=
name|QMetaMethod
operator|::
name|Public
condition|)
continue|continue;
comment|// check type:
if|if
condition|(
name|mm
operator|.
name|methodType
argument_list|()
operator|!=
name|QMetaMethod
operator|::
name|Slot
operator|&&
name|mm
operator|.
name|methodType
argument_list|()
operator|!=
name|QMetaMethod
operator|::
name|Method
condition|)
continue|continue;
comment|// check name:
if|if
condition|(
name|mm
operator|.
name|name
argument_list|()
operator|!=
name|name
condition|)
continue|continue;
name|int
name|returnType
init|=
name|mm
operator|.
name|returnType
argument_list|()
decl_stmt|;
name|bool
name|isAsync
init|=
name|qDBusCheckAsyncTag
argument_list|(
name|mm
operator|.
name|tag
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|isScriptable
init|=
name|mm
operator|.
name|attributes
argument_list|()
operator|&
name|QMetaMethod
operator|::
name|Scriptable
decl_stmt|;
comment|// consistency check:
if|if
condition|(
name|isAsync
operator|&&
name|returnType
operator|!=
name|QMetaType
operator|::
name|Void
condition|)
continue|continue;
name|int
name|inputCount
init|=
name|qDBusParametersForMethod
argument_list|(
name|mm
argument_list|,
name|metaTypes
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputCount
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|// problem parsing
name|metaTypes
index|[
literal|0
index|]
operator|=
name|returnType
expr_stmt|;
name|bool
name|hasMessage
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|inputCount
operator|>
literal|0
operator|&&
name|metaTypes
operator|.
name|at
argument_list|(
name|inputCount
argument_list|)
operator|==
name|QDBusMetaTypeId
operator|::
name|message
argument_list|()
condition|)
block|{
comment|// "no input parameters" is allowed as long as the message meta type is there
name|hasMessage
operator|=
literal|true
expr_stmt|;
operator|--
name|inputCount
expr_stmt|;
block|}
comment|// try to match the parameters
name|int
name|i
decl_stmt|;
name|QByteArray
name|reconstructedSignature
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|inputCount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|typeSignature
init|=
name|QDBusMetaType
operator|::
name|typeToSignature
argument_list|(
name|metaTypes
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|typeSignature
condition|)
break|break;
comment|// invalid
name|reconstructedSignature
operator|+=
name|typeSignature
expr_stmt|;
if|if
condition|(
operator|!
name|msgSignature
operator|.
name|startsWith
argument_list|(
name|reconstructedSignature
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|reconstructedSignature
operator|!=
name|msgSignature
condition|)
continue|continue;
comment|// we didn't match them all
if|if
condition|(
name|hasMessage
condition|)
operator|++
name|i
expr_stmt|;
comment|// make sure that the output parameters have signatures too
if|if
condition|(
name|returnType
operator|!=
name|QMetaType
operator|::
name|UnknownType
operator|&&
name|returnType
operator|!=
name|QMetaType
operator|::
name|Void
operator|&&
name|QDBusMetaType
operator|::
name|typeToSignature
argument_list|(
name|returnType
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|ok
operator|&&
name|j
operator|<
name|metaTypes
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|QDBusMetaType
operator|::
name|typeToSignature
argument_list|(
name|metaTypes
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|ok
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
comment|// consistency check:
if|if
condition|(
name|isAsync
operator|&&
name|metaTypes
operator|.
name|count
argument_list|()
operator|>
name|i
operator|+
literal|1
condition|)
continue|continue;
if|if
condition|(
name|mm
operator|.
name|methodType
argument_list|()
operator|==
name|QMetaMethod
operator|::
name|Slot
condition|)
block|{
if|if
condition|(
name|isScriptable
operator|&&
operator|(
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportScriptableSlots
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|// scriptable slots not exported
if|if
condition|(
operator|!
name|isScriptable
operator|&&
operator|(
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportNonScriptableSlots
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|// non-scriptable slots not exported
block|}
else|else
block|{
if|if
condition|(
name|isScriptable
operator|&&
operator|(
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportScriptableInvokables
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|// scriptable invokables not exported
if|if
condition|(
operator|!
name|isScriptable
operator|&&
operator|(
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportNonScriptableInvokables
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|// non-scriptable invokables not exported
block|}
comment|// if we got here, this slot matched
return|return
name|idx
return|;
block|}
comment|// no slot matched
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|DIRECT_DELIVERY
specifier|static
name|QDBusCallDeliveryEvent
modifier|*
specifier|const
name|DIRECT_DELIVERY
init|=
operator|(
name|QDBusCallDeliveryEvent
operator|*
operator|)
literal|1
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|prepareReply
name|QDBusCallDeliveryEvent
modifier|*
name|QDBusConnectionPrivate
operator|::
name|prepareReply
parameter_list|(
name|QDBusConnectionPrivate
modifier|*
name|target
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|,
name|int
name|idx
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|metaTypes
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|int
name|n
init|=
name|metaTypes
operator|.
name|count
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|metaTypes
index|[
name|n
index|]
operator|==
name|QDBusMetaTypeId
operator|::
name|message
argument_list|()
condition|)
operator|--
name|n
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|arguments
argument_list|()
operator|.
name|count
argument_list|()
operator|<
name|n
condition|)
return|return
literal|0
return|;
comment|// too few arguments
comment|// check that types match
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|metaTypes
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|!=
name|msg
operator|.
name|arguments
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|userType
argument_list|()
operator|&&
name|msg
operator|.
name|arguments
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|userType
argument_list|()
operator|!=
name|qMetaTypeId
argument_list|<
name|QDBusArgument
argument_list|>
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// no match
comment|// we can deliver
comment|// prepare for the call
if|if
condition|(
name|target
operator|==
name|object
condition|)
return|return
name|DIRECT_DELIVERY
return|;
return|return
operator|new
name|QDBusCallDeliveryEvent
argument_list|(
name|QDBusConnection
argument_list|(
name|target
argument_list|)
argument_list|,
name|idx
argument_list|,
name|target
argument_list|,
name|msg
argument_list|,
name|metaTypes
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|activateSignal
name|void
name|QDBusConnectionPrivate
operator|::
name|activateSignal
parameter_list|(
specifier|const
name|QDBusConnectionPrivate
operator|::
name|SignalHook
modifier|&
name|hook
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
comment|// This is called by QDBusConnectionPrivate::handleSignal to deliver a signal
comment|// that was received from D-Bus
comment|//
comment|// Signals are delivered to slots if the parameters match
comment|// Slots can have less parameters than there are on the message
comment|// Slots can optionally have one final parameter that is a QDBusMessage
comment|// Slots receive read-only copies of the message (i.e., pass by value or by const-ref)
name|QDBusCallDeliveryEvent
modifier|*
name|call
init|=
name|prepareReply
argument_list|(
name|this
argument_list|,
name|hook
operator|.
name|obj
argument_list|,
name|hook
operator|.
name|midx
argument_list|,
name|hook
operator|.
name|params
argument_list|,
name|msg
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|==
name|DIRECT_DELIVERY
condition|)
block|{
comment|// short-circuit delivery
name|Q_ASSERT
argument_list|(
name|this
operator|==
name|hook
operator|.
name|obj
argument_list|)
expr_stmt|;
name|deliverCall
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|msg
argument_list|,
name|hook
operator|.
name|params
argument_list|,
name|hook
operator|.
name|midx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|call
condition|)
name|postEventToThread
argument_list|(
name|ActivateSignalAction
argument_list|,
name|hook
operator|.
name|obj
argument_list|,
name|call
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|activateCall
name|bool
name|QDBusConnectionPrivate
operator|::
name|activateCall
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
comment|// This is called by QDBusConnectionPrivate::handleObjectCall to place a call
comment|// to a slot on the object.
comment|//
comment|// The call is delivered to the first slot that matches the following conditions:
comment|//  - has the same name as the message's target member
comment|//  - ALL of the message's types are found in slot's parameter list
comment|//  - optionally has one more parameter of type QDBusMessage
comment|// If none match, then the slot of the same name as the message target and with
comment|// the first type of QDBusMessage is delivered.
comment|//
comment|// The D-Bus specification requires that all MethodCall messages be replied to, unless the
comment|// caller specifically waived this requirement. This means that we inspect if the user slot
comment|// generated a reply and, if it didn't, we will. Obviously, if the user slot doesn't take a
comment|// QDBusMessage parameter, it cannot generate a reply.
comment|//
comment|// When a return message is generated, the slot's return type, if any, will be placed
comment|// in the message's first position. If there are non-const reference parameters to the
comment|// slot, they must appear at the end and will be placed in the subsequent message
comment|// positions.
specifier|static
specifier|const
name|char
name|cachePropertyName
index|[]
init|=
literal|"_qdbus_slotCache"
decl_stmt|;
if|if
condition|(
operator|!
name|object
condition|)
return|return
literal|false
return|;
ifndef|#
directive|ifndef
name|QT_NO_PROPERTIES
name|Q_ASSERT_X
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|object
operator|->
name|thread
argument_list|()
argument_list|,
literal|"QDBusConnection: internal threading error"
argument_list|,
literal|"function called for an object that is in another thread!!"
argument_list|)
expr_stmt|;
name|QDBusSlotCache
name|slotCache
init|=
name|qvariant_cast
argument_list|<
name|QDBusSlotCache
argument_list|>
argument_list|(
name|object
operator|->
name|property
argument_list|(
name|cachePropertyName
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|cacheKey
init|=
name|msg
operator|.
name|member
argument_list|()
decl_stmt|,
name|signature
init|=
name|msg
operator|.
name|signature
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|signature
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cacheKey
operator|.
name|reserve
argument_list|(
name|cacheKey
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|+
name|signature
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|cacheKey
operator|+=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|cacheKey
operator|+=
name|signature
expr_stmt|;
block|}
name|QDBusSlotCache
operator|::
name|Hash
operator|::
name|ConstIterator
name|cacheIt
init|=
name|slotCache
operator|.
name|hash
operator|.
name|constFind
argument_list|(
name|cacheKey
argument_list|)
decl_stmt|;
while|while
condition|(
name|cacheIt
operator|!=
name|slotCache
operator|.
name|hash
operator|.
name|constEnd
argument_list|()
operator|&&
name|cacheIt
operator|->
name|flags
operator|!=
name|flags
operator|&&
name|cacheIt
operator|.
name|key
argument_list|()
operator|==
name|cacheKey
condition|)
operator|++
name|cacheIt
expr_stmt|;
if|if
condition|(
name|cacheIt
operator|==
name|slotCache
operator|.
name|hash
operator|.
name|constEnd
argument_list|()
operator|||
name|cacheIt
operator|.
name|key
argument_list|()
operator|!=
name|cacheKey
condition|)
block|{
comment|// not cached, analyze the meta object
specifier|const
name|QMetaObject
modifier|*
name|mo
init|=
name|object
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|QByteArray
name|memberName
init|=
name|msg
operator|.
name|member
argument_list|()
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
comment|// find a slot that matches according to the rules above
name|QDBusSlotCache
operator|::
name|Data
name|slotData
decl_stmt|;
name|slotData
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|slotData
operator|.
name|slotIdx
operator|=
operator|::
name|findSlot
argument_list|(
name|mo
argument_list|,
name|memberName
argument_list|,
name|flags
argument_list|,
name|msg
operator|.
name|signature
argument_list|()
argument_list|,
name|slotData
operator|.
name|metaTypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotData
operator|.
name|slotIdx
operator|==
operator|-
literal|1
condition|)
block|{
comment|// ### this is where we want to add the connection as an arg too
comment|// try with no parameters, but with a QDBusMessage
name|slotData
operator|.
name|slotIdx
operator|=
operator|::
name|findSlot
argument_list|(
name|mo
argument_list|,
name|memberName
argument_list|,
name|flags
argument_list|,
name|QString
argument_list|()
argument_list|,
name|slotData
operator|.
name|metaTypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotData
operator|.
name|metaTypes
operator|.
name|count
argument_list|()
operator|!=
literal|2
operator|||
name|slotData
operator|.
name|metaTypes
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|!=
name|QDBusMetaTypeId
operator|::
name|message
argument_list|()
condition|)
block|{
comment|// not found
comment|// save the negative lookup
name|slotData
operator|.
name|slotIdx
operator|=
operator|-
literal|1
expr_stmt|;
name|slotData
operator|.
name|metaTypes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|slotCache
operator|.
name|hash
operator|.
name|insert
argument_list|(
name|cacheKey
argument_list|,
name|slotData
argument_list|)
expr_stmt|;
name|object
operator|->
name|setProperty
argument_list|(
name|cachePropertyName
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|(
name|slotCache
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// save to the cache
name|slotCache
operator|.
name|hash
operator|.
name|insert
argument_list|(
name|cacheKey
argument_list|,
name|slotData
argument_list|)
expr_stmt|;
name|object
operator|->
name|setProperty
argument_list|(
name|cachePropertyName
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|(
name|slotCache
argument_list|)
argument_list|)
expr_stmt|;
comment|// found the slot to be called
name|deliverCall
argument_list|(
name|object
argument_list|,
name|flags
argument_list|,
name|msg
argument_list|,
name|slotData
operator|.
name|metaTypes
argument_list|,
name|slotData
operator|.
name|slotIdx
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|cacheIt
operator|->
name|slotIdx
operator|==
operator|-
literal|1
condition|)
block|{
comment|// negative cache
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// use the cache
name|deliverCall
argument_list|(
name|object
argument_list|,
name|flags
argument_list|,
name|msg
argument_list|,
name|cacheIt
operator|->
name|metaTypes
argument_list|,
name|cacheIt
operator|->
name|slotIdx
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
endif|#
directive|endif
comment|// QT_NO_PROPERTIES
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|deliverCall
name|void
name|QDBusConnectionPrivate
operator|::
name|deliverCall
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|,
name|int
comment|/*flags*/
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|metaTypes
parameter_list|,
name|int
name|slotIdx
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
operator|!
name|object
operator|||
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|object
operator|->
name|thread
argument_list|()
argument_list|,
literal|"QDBusConnection: internal threading error"
argument_list|,
literal|"function called for an object that is in another thread!!"
argument_list|)
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|void
modifier|*
argument_list|,
literal|10
argument_list|>
name|params
decl_stmt|;
name|params
operator|.
name|reserve
argument_list|(
name|metaTypes
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|QVariantList
name|auxParameters
decl_stmt|;
comment|// let's create the parameter list
comment|// first one is the return type -- add it below
name|params
operator|.
name|append
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// add the input parameters
name|int
name|i
decl_stmt|;
name|int
name|pCount
init|=
name|qMin
argument_list|(
name|msg
operator|.
name|arguments
argument_list|()
operator|.
name|count
argument_list|()
argument_list|,
name|metaTypes
operator|.
name|count
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|pCount
condition|;
operator|++
name|i
control|)
block|{
name|int
name|id
init|=
name|metaTypes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|QDBusMetaTypeId
operator|::
name|message
argument_list|()
condition|)
break|break;
specifier|const
name|QVariant
modifier|&
name|arg
init|=
name|msg
operator|.
name|arguments
argument_list|()
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|userType
argument_list|()
operator|==
name|id
condition|)
comment|// no conversion needed
name|params
operator|.
name|append
argument_list|(
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|arg
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|.
name|userType
argument_list|()
operator|==
name|qMetaTypeId
argument_list|<
name|QDBusArgument
argument_list|>
argument_list|()
condition|)
block|{
comment|// convert to what the function expects
name|void
modifier|*
name|null
init|=
literal|0
decl_stmt|;
name|auxParameters
operator|.
name|append
argument_list|(
name|QVariant
argument_list|(
name|id
argument_list|,
name|null
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|QDBusArgument
modifier|&
name|in
init|=
operator|*
cast|reinterpret_cast
argument_list|<
specifier|const
name|QDBusArgument
operator|*
argument_list|>
argument_list|(
name|arg
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|QVariant
modifier|&
name|out
init|=
name|auxParameters
index|[
name|auxParameters
operator|.
name|count
argument_list|()
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|QDBusMetaType
operator|::
name|demarshall
argument_list|(
name|in
argument_list|,
name|out
operator|.
name|userType
argument_list|()
argument_list|,
name|out
operator|.
name|data
argument_list|()
argument_list|)
condition|)
name|qFatal
argument_list|(
literal|"Internal error: demarshalling function for type '%s' (%d) failed!"
argument_list|,
name|out
operator|.
name|typeName
argument_list|()
argument_list|,
name|out
operator|.
name|userType
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|append
argument_list|(
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qFatal
argument_list|(
literal|"Internal error: got invalid meta type %d (%s) "
literal|"when trying to convert to meta type %d (%s)"
argument_list|,
name|arg
operator|.
name|userType
argument_list|()
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|arg
operator|.
name|userType
argument_list|()
argument_list|)
argument_list|,
name|id
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|metaTypes
operator|.
name|count
argument_list|()
operator|>
name|i
operator|&&
name|metaTypes
index|[
name|i
index|]
operator|==
name|QDBusMetaTypeId
operator|::
name|message
argument_list|()
condition|)
block|{
name|params
operator|.
name|append
argument_list|(
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|void
operator|*
argument_list|>
argument_list|(
operator|&
name|msg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
comment|// output arguments
name|QVariantList
name|outputArgs
decl_stmt|;
name|void
modifier|*
name|null
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|metaTypes
index|[
literal|0
index|]
operator|!=
name|QMetaType
operator|::
name|Void
operator|&&
name|metaTypes
index|[
literal|0
index|]
operator|!=
name|QMetaType
operator|::
name|UnknownType
condition|)
block|{
name|QVariant
name|arg
argument_list|(
name|metaTypes
index|[
literal|0
index|]
argument_list|,
name|null
argument_list|)
decl_stmt|;
name|outputArgs
operator|.
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|params
index|[
literal|0
index|]
operator|=
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|outputArgs
operator|.
name|at
argument_list|(
name|outputArgs
operator|.
name|count
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|metaTypes
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QVariant
name|arg
argument_list|(
name|metaTypes
index|[
name|i
index|]
argument_list|,
name|null
argument_list|)
decl_stmt|;
name|outputArgs
operator|.
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|params
operator|.
name|append
argument_list|(
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|outputArgs
operator|.
name|at
argument_list|(
name|outputArgs
operator|.
name|count
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// make call:
name|bool
name|fail
decl_stmt|;
if|if
condition|(
operator|!
name|object
condition|)
block|{
name|fail
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// FIXME: save the old sender!
name|QDBusContextPrivate
name|context
argument_list|(
name|QDBusConnection
argument_list|(
name|this
argument_list|)
argument_list|,
name|msg
argument_list|)
decl_stmt|;
name|QDBusContextPrivate
modifier|*
name|old
init|=
name|QDBusContextPrivate
operator|::
name|set
argument_list|(
name|object
argument_list|,
operator|&
name|context
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|setSender
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QPointer
argument_list|<
name|QObject
argument_list|>
name|ptr
init|=
name|object
decl_stmt|;
name|fail
operator|=
name|object
operator|->
name|qt_metacall
argument_list|(
name|QMetaObject
operator|::
name|InvokeMetaMethod
argument_list|,
name|slotIdx
argument_list|,
name|params
operator|.
name|data
argument_list|()
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|QDBusConnectionPrivate
operator|::
name|setSender
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// the object might be deleted in the slot
if|if
condition|(
operator|!
name|ptr
operator|.
name|isNull
argument_list|()
condition|)
name|QDBusContextPrivate
operator|::
name|set
argument_list|(
name|object
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
comment|// do we create a reply? Only if the caller is waiting for a reply and one hasn't been sent
comment|// yet.
if|if
condition|(
name|msg
operator|.
name|isReplyRequired
argument_list|()
operator|&&
operator|!
name|msg
operator|.
name|isDelayedReply
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fail
condition|)
block|{
comment|// normal reply
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"Automatically sending reply:"
operator|<<
name|outputArgs
expr_stmt|;
name|send
argument_list|(
name|msg
operator|.
name|createReply
argument_list|(
name|outputArgs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// generate internal error
name|qWarning
argument_list|(
literal|"Internal error: Failed to deliver message"
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|msg
operator|.
name|createErrorReply
argument_list|(
name|QDBusError
operator|::
name|InternalError
argument_list|,
name|QLatin1String
argument_list|(
literal|"Failed to deliver message"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function
begin_function_decl
specifier|extern
name|bool
name|qDBusInitThreads
parameter_list|()
function_decl|;
end_function_decl
begin_constructor
DECL|function|QDBusConnectionPrivate
name|QDBusConnectionPrivate
operator|::
name|QDBusConnectionPrivate
parameter_list|(
name|QObject
modifier|*
name|p
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|p
argument_list|)
member_init_list|,
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|capabilities
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mode
argument_list|(
name|InvalidMode
argument_list|)
member_init_list|,
name|connection
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|server
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|busService
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|watchAndTimeoutLock
argument_list|(
name|QMutex
operator|::
name|Recursive
argument_list|)
member_init_list|,
name|rootNode
argument_list|(
name|QString
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
block|{
specifier|static
specifier|const
name|bool
name|threads
init|=
name|q_dbus_threads_init_default
argument_list|()
decl_stmt|;
specifier|static
specifier|const
name|int
name|debugging
init|=
name|qgetenv
argument_list|(
literal|"QDBUS_DEBUG"
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
operator|::
name|isDebugging
operator|=
name|debugging
expr_stmt|;
name|Q_UNUSED
argument_list|(
argument|threads
argument_list|)
name|Q_UNUSED
argument_list|(
argument|debugging
argument_list|)
ifdef|#
directive|ifdef
name|QDBUS_THREAD_DEBUG
if|if
condition|(
name|debugging
operator|>
literal|1
condition|)
name|qdbusThreadDebug
operator|=
name|qdbusDefaultThreadDebug
expr_stmt|;
endif|#
directive|endif
name|QDBusMetaTypeId
operator|::
name|init
argument_list|()
expr_stmt|;
name|rootNode
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|// prepopulate watchedServices:
comment|// we know that the owner of org.freedesktop.DBus is itself
name|watchedServices
operator|.
name|insert
argument_list|(
name|dbusServiceString
argument_list|()
argument_list|,
name|WatchedServiceData
argument_list|(
name|dbusServiceString
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// prepopulate matchRefCounts:
comment|// we know that org.freedesktop.DBus will never change owners
name|matchRefCounts
operator|.
name|insert
argument_list|(
literal|"type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged',arg0='org.freedesktop.DBus'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QDBusConnectionPrivate
name|QDBusConnectionPrivate
operator|::
name|~
name|QDBusConnectionPrivate
parameter_list|()
block|{
if|if
condition|(
name|thread
argument_list|()
operator|&&
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QDBusConnection(name=\"%s\")'s last reference in not in its creation thread! "
literal|"Timer and socket errors will follow and the program will probably crash"
argument_list|,
name|qPrintable
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|closeConnection
argument_list|()
expr_stmt|;
name|rootNode
operator|.
name|children
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// free resources
name|qDeleteAll
argument_list|(
name|cachedMetaObjects
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
condition|)
name|q_dbus_server_unref
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
condition|)
name|q_dbus_connection_unref
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|connection
operator|=
literal|0
expr_stmt|;
name|server
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|deleteYourself
name|void
name|QDBusConnectionPrivate
operator|::
name|deleteYourself
parameter_list|()
block|{
if|if
condition|(
name|thread
argument_list|()
operator|&&
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
comment|// last reference dropped while not in the correct thread
comment|// ask the correct thread to delete
comment|// note: since we're posting an event to another thread, we
comment|// must consider deleteLater() to take effect immediately
name|deleteLater
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|delete
name|this
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|closeConnection
name|void
name|QDBusConnectionPrivate
operator|::
name|closeConnection
parameter_list|()
block|{
name|QDBusWriteLocker
name|locker
argument_list|(
name|CloseConnectionAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|ConnectionMode
name|oldMode
init|=
name|mode
decl_stmt|;
name|mode
operator|=
name|InvalidMode
expr_stmt|;
comment|// prevent reentrancy
name|baseService
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|server
condition|)
name|q_dbus_server_disconnect
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldMode
operator|==
name|ClientMode
operator|||
name|oldMode
operator|==
name|PeerMode
condition|)
block|{
if|if
condition|(
name|connection
condition|)
block|{
name|q_dbus_connection_close
argument_list|(
name|connection
argument_list|)
expr_stmt|;
comment|// send the "close" message
while|while
condition|(
name|q_dbus_connection_dispatch
argument_list|(
name|connection
argument_list|)
operator|==
name|DBUS_DISPATCH_DATA_REMAINS
condition|)
empty_stmt|;
block|}
block|}
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"Disconnected"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|checkThread
name|void
name|QDBusConnectionPrivate
operator|::
name|checkThread
parameter_list|()
block|{
if|if
condition|(
operator|!
name|thread
argument_list|()
condition|)
block|{
if|if
condition|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
condition|)
name|moveToThread
argument_list|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|->
name|thread
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"The thread that had QDBusConnection('%s') has died and there is no main thread"
argument_list|,
name|qPrintable
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|handleError
name|bool
name|QDBusConnectionPrivate
operator|::
name|handleError
parameter_list|(
specifier|const
name|QDBusErrorInternal
modifier|&
name|error
parameter_list|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
return|return
literal|false
return|;
comment|// no error
comment|//lock.lockForWrite();
name|lastError
operator|=
name|error
expr_stmt|;
comment|//lock.unlock();
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|timerEvent
name|void
name|QDBusConnectionPrivate
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|e
parameter_list|)
block|{
block|{
name|QDBusWatchAndTimeoutLocker
name|locker
argument_list|(
name|TimerEventAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|DBusTimeout
modifier|*
name|timeout
init|=
name|timeouts
operator|.
name|value
argument_list|(
name|e
operator|->
name|timerId
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|timeout
condition|)
name|q_dbus_timeout_handle
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
name|doDispatch
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|customEvent
name|void
name|QDBusConnectionPrivate
operator|::
name|customEvent
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|User
argument_list|)
expr_stmt|;
name|QDBusConnectionCallbackEvent
modifier|*
name|ev
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionCallbackEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QDBusLockerBase
operator|::
name|reportThreadAction
argument_list|(
name|int
argument_list|(
name|AddTimeoutAction
argument_list|)
operator|+
name|int
argument_list|(
name|ev
operator|->
name|subtype
argument_list|)
argument_list|,
name|QDBusLockerBase
operator|::
name|BeforeDeliver
argument_list|,
name|this
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ev
operator|->
name|subtype
condition|)
block|{
case|case
name|QDBusConnectionCallbackEvent
operator|::
name|AddTimeout
case|:
block|{
name|QDBusWatchAndTimeoutLocker
name|locker
argument_list|(
name|RealAddTimeoutAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|timeoutsPendingAdd
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QPair
argument_list|<
name|DBusTimeout
modifier|*
argument_list|,
name|int
argument_list|>
name|entry
init|=
name|timeoutsPendingAdd
operator|.
name|takeFirst
argument_list|()
decl_stmt|;
name|qDBusRealAddTimeout
argument_list|(
name|this
argument_list|,
name|entry
operator|.
name|first
argument_list|,
name|entry
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QDBusConnectionCallbackEvent
operator|::
name|KillTimer
case|:
name|killTimer
argument_list|(
name|ev
operator|->
name|timerId
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDBusConnectionCallbackEvent
operator|::
name|AddWatch
case|:
name|qDBusRealAddWatch
argument_list|(
name|this
argument_list|,
name|ev
operator|->
name|watch
argument_list|,
name|ev
operator|->
name|extra
argument_list|,
name|ev
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDBusConnectionCallbackEvent
operator|::
name|ToggleWatch
case|:
name|qDBusRealToggleWatch
argument_list|(
name|this
argument_list|,
name|ev
operator|->
name|watch
argument_list|,
name|ev
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
name|QDBusLockerBase
operator|::
name|reportThreadAction
argument_list|(
name|int
argument_list|(
name|AddTimeoutAction
argument_list|)
operator|+
name|int
argument_list|(
name|ev
operator|->
name|subtype
argument_list|)
argument_list|,
name|QDBusLockerBase
operator|::
name|AfterDeliver
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|doDispatch
name|void
name|QDBusConnectionPrivate
operator|::
name|doDispatch
parameter_list|()
block|{
name|QDBusDispatchLocker
name|locker
argument_list|(
name|DoDispatchAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|ClientMode
operator|||
name|mode
operator|==
name|PeerMode
condition|)
while|while
condition|(
name|q_dbus_connection_dispatch
argument_list|(
name|connection
argument_list|)
operator|==
name|DBUS_DISPATCH_DATA_REMAINS
condition|)
empty_stmt|;
block|}
end_function
begin_function
DECL|function|socketRead
name|void
name|QDBusConnectionPrivate
operator|::
name|socketRead
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|QVarLengthArray
argument_list|<
name|DBusWatch
modifier|*
argument_list|,
literal|2
argument_list|>
name|pendingWatches
decl_stmt|;
block|{
name|QDBusWatchAndTimeoutLocker
name|locker
argument_list|(
name|SocketReadAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|WatcherHash
operator|::
name|ConstIterator
name|it
init|=
name|watchers
operator|.
name|constFind
argument_list|(
name|fd
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|watchers
operator|.
name|constEnd
argument_list|()
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|fd
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|watch
operator|&&
name|it
operator|->
name|read
operator|&&
name|it
operator|->
name|read
operator|->
name|isEnabled
argument_list|()
condition|)
name|pendingWatches
operator|.
name|append
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|watch
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pendingWatches
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|q_dbus_watch_handle
argument_list|(
name|pendingWatches
index|[
name|i
index|]
argument_list|,
name|DBUS_WATCH_READABLE
argument_list|)
condition|)
name|qDebug
argument_list|(
literal|"OUT OF MEM"
argument_list|)
expr_stmt|;
name|doDispatch
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|socketWrite
name|void
name|QDBusConnectionPrivate
operator|::
name|socketWrite
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|QVarLengthArray
argument_list|<
name|DBusWatch
modifier|*
argument_list|,
literal|2
argument_list|>
name|pendingWatches
decl_stmt|;
block|{
name|QDBusWatchAndTimeoutLocker
name|locker
argument_list|(
name|SocketWriteAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|WatcherHash
operator|::
name|ConstIterator
name|it
init|=
name|watchers
operator|.
name|constFind
argument_list|(
name|fd
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|watchers
operator|.
name|constEnd
argument_list|()
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|fd
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|watch
operator|&&
name|it
operator|->
name|write
operator|&&
name|it
operator|->
name|write
operator|->
name|isEnabled
argument_list|()
condition|)
name|pendingWatches
operator|.
name|append
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|watch
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pendingWatches
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|q_dbus_watch_handle
argument_list|(
name|pendingWatches
index|[
name|i
index|]
argument_list|,
name|DBUS_WATCH_WRITABLE
argument_list|)
condition|)
name|qDebug
argument_list|(
literal|"OUT OF MEM"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|objectDestroyed
name|void
name|QDBusConnectionPrivate
operator|::
name|objectDestroyed
parameter_list|(
name|QObject
modifier|*
name|obj
parameter_list|)
block|{
name|QDBusWriteLocker
name|locker
argument_list|(
name|ObjectDestroyedAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|huntAndDestroy
argument_list|(
name|obj
argument_list|,
name|rootNode
argument_list|)
expr_stmt|;
name|SignalHookHash
operator|::
name|iterator
name|sit
init|=
name|signalHooks
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|sit
operator|!=
name|signalHooks
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
cast|static_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|sit
operator|.
name|value
argument_list|()
operator|.
name|obj
argument_list|)
operator|==
name|obj
condition|)
name|sit
operator|=
name|disconnectSignal
argument_list|(
name|sit
argument_list|)
expr_stmt|;
else|else
operator|++
name|sit
expr_stmt|;
block|}
name|obj
operator|->
name|disconnect
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|relaySignal
name|void
name|QDBusConnectionPrivate
operator|::
name|relaySignal
parameter_list|(
name|QObject
modifier|*
name|obj
parameter_list|,
specifier|const
name|QMetaObject
modifier|*
name|mo
parameter_list|,
name|int
name|signalId
parameter_list|,
specifier|const
name|QVariantList
modifier|&
name|args
parameter_list|)
block|{
name|QString
name|interface
init|=
name|qDBusInterfaceFromMetaObject
argument_list|(
name|mo
argument_list|)
decl_stmt|;
name|QMetaMethod
name|mm
init|=
name|mo
operator|->
name|method
argument_list|(
name|signalId
argument_list|)
decl_stmt|;
name|QByteArray
name|memberName
init|=
name|mm
operator|.
name|name
argument_list|()
decl_stmt|;
comment|// check if it's scriptable
name|bool
name|isScriptable
init|=
name|mm
operator|.
name|attributes
argument_list|()
operator|&
name|QMetaMethod
operator|::
name|Scriptable
decl_stmt|;
name|bool
name|isAdaptor
init|=
literal|false
decl_stmt|;
for|for
control|(
init|;
name|mo
condition|;
name|mo
operator|=
name|mo
operator|->
name|superClass
argument_list|()
control|)
if|if
condition|(
name|mo
operator|==
operator|&
name|QDBusAbstractAdaptor
operator|::
name|staticMetaObject
condition|)
block|{
name|isAdaptor
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|QDBusReadLocker
name|locker
argument_list|(
name|RelaySignalAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|QDBusMessage
name|message
init|=
name|QDBusMessage
operator|::
name|createSignal
argument_list|(
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
argument_list|,
name|interface
argument_list|,
name|QLatin1String
argument_list|(
name|memberName
argument_list|)
argument_list|)
decl_stmt|;
name|QDBusMessagePrivate
operator|::
name|setParametersValidated
argument_list|(
name|message
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|message
operator|.
name|setArguments
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|QDBusError
name|error
decl_stmt|;
name|DBusMessage
modifier|*
name|msg
init|=
name|QDBusMessagePrivate
operator|::
name|toDBusMessage
argument_list|(
name|message
argument_list|,
name|capabilities
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDBusConnection: Could not emit signal %s.%s: %s"
argument_list|,
name|qPrintable
argument_list|(
name|interface
argument_list|)
argument_list|,
name|memberName
operator|.
name|constData
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|error
operator|.
name|message
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|lastError
operator|=
name|error
expr_stmt|;
return|return;
block|}
comment|//qDBusDebug()<< "Emitting signal"<< message;
comment|//qDBusDebug()<< "for paths:";
name|q_dbus_message_set_no_reply
argument_list|(
name|msg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// the reply would not be delivered to anything
name|huntAndEmit
argument_list|(
name|connection
argument_list|,
name|msg
argument_list|,
name|obj
argument_list|,
name|rootNode
argument_list|,
name|isScriptable
argument_list|,
name|isAdaptor
argument_list|)
expr_stmt|;
name|q_dbus_message_unref
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|serviceOwnerChangedNoLock
name|void
name|QDBusConnectionPrivate
operator|::
name|serviceOwnerChangedNoLock
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|oldOwner
parameter_list|,
specifier|const
name|QString
modifier|&
name|newOwner
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|oldOwner
argument_list|)
expr_stmt|;
comment|//    QDBusWriteLocker locker(UpdateSignalHookOwnerAction, this);
name|WatchedServicesHash
operator|::
name|Iterator
name|it
init|=
name|watchedServices
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|watchedServices
operator|.
name|end
argument_list|()
condition|)
return|return;
if|if
condition|(
name|oldOwner
operator|!=
name|it
operator|->
name|owner
condition|)
name|qWarning
argument_list|(
literal|"QDBusConnection: name '%s' had owner '%s' but we thought it was '%s'"
argument_list|,
name|qPrintable
argument_list|(
name|name
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|oldOwner
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|it
operator|->
name|owner
argument_list|)
argument_list|)
expr_stmt|;
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"Updating name"
operator|<<
name|name
operator|<<
literal|"from"
operator|<<
name|oldOwner
operator|<<
literal|"to"
operator|<<
name|newOwner
expr_stmt|;
name|it
operator|->
name|owner
operator|=
name|newOwner
expr_stmt|;
block|}
end_function
begin_function
DECL|function|findSlot
name|int
name|QDBusConnectionPrivate
operator|::
name|findSlot
parameter_list|(
name|QObject
modifier|*
name|obj
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|normalizedName
parameter_list|,
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|params
parameter_list|)
block|{
name|int
name|midx
init|=
name|obj
operator|->
name|metaObject
argument_list|()
operator|->
name|indexOfMethod
argument_list|(
name|normalizedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|midx
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|inputCount
init|=
name|qDBusParametersForMethod
argument_list|(
name|obj
operator|->
name|metaObject
argument_list|()
operator|->
name|method
argument_list|(
name|midx
argument_list|)
argument_list|,
name|params
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputCount
operator|==
operator|-
literal|1
operator|||
name|inputCount
operator|+
literal|1
operator|!=
name|params
operator|.
name|count
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
comment|// failed to parse or invalid arguments or output arguments
return|return
name|midx
return|;
block|}
end_function
begin_function
DECL|function|prepareHook
name|bool
name|QDBusConnectionPrivate
operator|::
name|prepareHook
parameter_list|(
name|QDBusConnectionPrivate
operator|::
name|SignalHook
modifier|&
name|hook
parameter_list|,
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|argMatch
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|signal
parameter_list|,
name|int
name|minMIdx
parameter_list|,
name|bool
name|buildSignature
parameter_list|)
block|{
name|QByteArray
name|normalizedName
init|=
name|signal
operator|+
literal|1
decl_stmt|;
name|hook
operator|.
name|midx
operator|=
name|findSlot
argument_list|(
name|receiver
argument_list|,
name|signal
operator|+
literal|1
argument_list|,
name|hook
operator|.
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|.
name|midx
operator|==
operator|-
literal|1
condition|)
block|{
name|normalizedName
operator|=
name|QMetaObject
operator|::
name|normalizedSignature
argument_list|(
name|signal
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hook
operator|.
name|midx
operator|=
name|findSlot
argument_list|(
name|receiver
argument_list|,
name|normalizedName
argument_list|,
name|hook
operator|.
name|params
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hook
operator|.
name|midx
operator|<
name|minMIdx
condition|)
block|{
if|if
condition|(
name|hook
operator|.
name|midx
operator|==
operator|-
literal|1
condition|)
block|{}
return|return
literal|false
return|;
block|}
name|hook
operator|.
name|service
operator|=
name|service
expr_stmt|;
name|hook
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|hook
operator|.
name|obj
operator|=
name|receiver
expr_stmt|;
name|hook
operator|.
name|argumentMatch
operator|=
name|argMatch
expr_stmt|;
comment|// build the D-Bus signal name and signature
comment|// This should not happen for QDBusConnection::connect, use buildSignature here, since
comment|// QDBusConnection::connect passes false and everything else uses true
name|QString
name|mname
init|=
name|name
decl_stmt|;
if|if
condition|(
name|buildSignature
operator|&&
name|mname
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|normalizedName
operator|.
name|truncate
argument_list|(
name|normalizedName
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
argument_list|)
expr_stmt|;
name|mname
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|normalizedName
argument_list|)
expr_stmt|;
block|}
name|key
operator|=
name|mname
expr_stmt|;
name|key
operator|.
name|reserve
argument_list|(
name|interface
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|+
name|mname
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|+=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|key
operator|+=
name|interface
expr_stmt|;
if|if
condition|(
name|buildSignature
condition|)
block|{
name|hook
operator|.
name|signature
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|hook
operator|.
name|params
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|hook
operator|.
name|params
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|QDBusMetaTypeId
operator|::
name|message
argument_list|()
condition|)
name|hook
operator|.
name|signature
operator|+=
name|QLatin1String
argument_list|(
name|QDBusMetaType
operator|::
name|typeToSignature
argument_list|(
name|hook
operator|.
name|params
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hook
operator|.
name|matchRule
operator|=
name|buildMatchRule
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|mname
argument_list|,
name|argMatch
argument_list|,
name|hook
operator|.
name|signature
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// connect to this signal
block|}
end_function
begin_function
DECL|function|sendError
name|void
name|QDBusConnectionPrivate
operator|::
name|sendError
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|,
name|QDBusError
operator|::
name|ErrorType
name|code
parameter_list|)
block|{
if|if
condition|(
name|code
operator|==
name|QDBusError
operator|::
name|UnknownMethod
condition|)
block|{
name|QString
name|interfaceMsg
decl_stmt|;
if|if
condition|(
name|msg
operator|.
name|interface
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|interfaceMsg
operator|=
name|QLatin1String
argument_list|(
literal|"any interface"
argument_list|)
expr_stmt|;
else|else
name|interfaceMsg
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"interface '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|msg
operator|.
name|interface
argument_list|()
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|msg
operator|.
name|createErrorReply
argument_list|(
name|code
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"No such method '%1' in %2 at object path '%3' "
literal|"(signature '%4')"
argument_list|)
operator|.
name|arg
argument_list|(
name|msg
operator|.
name|member
argument_list|()
argument_list|,
name|interfaceMsg
argument_list|,
name|msg
operator|.
name|path
argument_list|()
argument_list|,
name|msg
operator|.
name|signature
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|QDBusError
operator|::
name|UnknownInterface
condition|)
block|{
name|send
argument_list|(
name|msg
operator|.
name|createErrorReply
argument_list|(
name|QDBusError
operator|::
name|UnknownInterface
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"No such interface '%1' at object path '%2'"
argument_list|)
operator|.
name|arg
argument_list|(
name|msg
operator|.
name|interface
argument_list|()
argument_list|,
name|msg
operator|.
name|path
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|QDBusError
operator|::
name|UnknownObject
condition|)
block|{
name|send
argument_list|(
name|msg
operator|.
name|createErrorReply
argument_list|(
name|QDBusError
operator|::
name|UnknownObject
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"No such object path '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|msg
operator|.
name|path
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|activateInternalFilters
name|bool
name|QDBusConnectionPrivate
operator|::
name|activateInternalFilters
parameter_list|(
specifier|const
name|ObjectTreeNode
modifier|&
name|node
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
comment|// object may be null
specifier|const
name|QString
name|interface
init|=
name|msg
operator|.
name|interface
argument_list|()
decl_stmt|;
if|if
condition|(
name|interface
operator|.
name|isEmpty
argument_list|()
operator|||
name|interface
operator|==
name|QLatin1String
argument_list|(
name|DBUS_INTERFACE_INTROSPECTABLE
argument_list|)
condition|)
block|{
if|if
condition|(
name|msg
operator|.
name|member
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"Introspect"
argument_list|)
operator|&&
name|msg
operator|.
name|signature
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//qDebug()<< "QDBusConnectionPrivate::activateInternalFilters introspect"<< msg.d_ptr->msg;
name|QDBusMessage
name|reply
init|=
name|msg
operator|.
name|createReply
argument_list|(
name|qDBusIntrospectObject
argument_list|(
name|node
argument_list|,
name|msg
operator|.
name|path
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|send
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownMethod
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|obj
operator|&&
operator|(
name|interface
operator|.
name|isEmpty
argument_list|()
operator|||
name|interface
operator|==
name|QLatin1String
argument_list|(
name|DBUS_INTERFACE_PROPERTIES
argument_list|)
operator|)
condition|)
block|{
comment|//qDebug()<< "QDBusConnectionPrivate::activateInternalFilters properties"<< msg.d_ptr->msg;
if|if
condition|(
name|msg
operator|.
name|member
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"Get"
argument_list|)
operator|&&
name|msg
operator|.
name|signature
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"ss"
argument_list|)
condition|)
block|{
name|QDBusMessage
name|reply
init|=
name|qDBusPropertyGet
argument_list|(
name|node
argument_list|,
name|msg
argument_list|)
decl_stmt|;
name|send
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|msg
operator|.
name|member
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"Set"
argument_list|)
operator|&&
name|msg
operator|.
name|signature
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"ssv"
argument_list|)
condition|)
block|{
name|QDBusMessage
name|reply
init|=
name|qDBusPropertySet
argument_list|(
name|node
argument_list|,
name|msg
argument_list|)
decl_stmt|;
name|send
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|msg
operator|.
name|member
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"GetAll"
argument_list|)
operator|&&
name|msg
operator|.
name|signature
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"s"
argument_list|)
condition|)
block|{
name|QDBusMessage
name|reply
init|=
name|qDBusPropertyGetAll
argument_list|(
name|node
argument_list|,
name|msg
argument_list|)
decl_stmt|;
name|send
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownMethod
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|activateObject
name|void
name|QDBusConnectionPrivate
operator|::
name|activateObject
parameter_list|(
name|ObjectTreeNode
modifier|&
name|node
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|,
name|int
name|pathStartPos
parameter_list|)
block|{
comment|// This is called by QDBusConnectionPrivate::handleObjectCall to place a call to a slot
comment|// on the object.
comment|//
comment|// The call is routed through the adaptor sub-objects if we have any
comment|// object may be null
if|if
condition|(
name|node
operator|.
name|flags
operator|&
name|QDBusConnectionPrivate
operator|::
name|VirtualObject
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|treeNode
operator|->
name|handleMessage
argument_list|(
name|msg
argument_list|,
name|q
argument_list|(
name|this
argument_list|)
argument_list|)
condition|)
block|{
return|return;
block|}
else|else
block|{
if|if
condition|(
name|activateInternalFilters
argument_list|(
name|node
argument_list|,
name|msg
argument_list|)
condition|)
return|return;
block|}
block|}
if|if
condition|(
name|pathStartPos
operator|!=
name|msg
operator|.
name|path
argument_list|()
operator|.
name|length
argument_list|()
condition|)
block|{
name|node
operator|.
name|flags
operator|&=
operator|~
name|QDBusConnection
operator|::
name|ExportAllSignals
expr_stmt|;
name|node
operator|.
name|obj
operator|=
name|findChildObject
argument_list|(
operator|&
name|node
argument_list|,
name|msg
operator|.
name|path
argument_list|()
argument_list|,
name|pathStartPos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|.
name|obj
condition|)
block|{
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownObject
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|QDBusAdaptorConnector
modifier|*
name|connector
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportAdaptors
operator|&&
operator|(
name|connector
operator|=
name|qDBusFindAdaptorConnector
argument_list|(
name|node
operator|.
name|obj
argument_list|)
operator|)
condition|)
block|{
name|int
name|newflags
init|=
name|node
operator|.
name|flags
operator||
name|QDBusConnection
operator|::
name|ExportAllSlots
decl_stmt|;
if|if
condition|(
name|msg
operator|.
name|interface
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// place the call in all interfaces
comment|// let the first one that handles it to work
name|QDBusAdaptorConnector
operator|::
name|AdaptorMap
operator|::
name|ConstIterator
name|it
init|=
name|connector
operator|->
name|adaptors
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QDBusAdaptorConnector
operator|::
name|AdaptorMap
operator|::
name|ConstIterator
name|end
init|=
name|connector
operator|->
name|adaptors
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
if|if
condition|(
name|activateCall
argument_list|(
name|it
operator|->
name|adaptor
argument_list|,
name|newflags
argument_list|,
name|msg
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
comment|// check if we have an interface matching the name that was asked:
name|QDBusAdaptorConnector
operator|::
name|AdaptorMap
operator|::
name|ConstIterator
name|it
decl_stmt|;
name|it
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|connector
operator|->
name|adaptors
operator|.
name|constBegin
argument_list|()
argument_list|,
name|connector
operator|->
name|adaptors
operator|.
name|constEnd
argument_list|()
argument_list|,
name|msg
operator|.
name|interface
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|connector
operator|->
name|adaptors
operator|.
name|constEnd
argument_list|()
operator|&&
name|msg
operator|.
name|interface
argument_list|()
operator|==
name|QLatin1String
argument_list|(
name|it
operator|->
name|interface
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|activateCall
argument_list|(
name|it
operator|->
name|adaptor
argument_list|,
name|newflags
argument_list|,
name|msg
argument_list|)
condition|)
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownMethod
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// no adaptors matched or were exported
comment|// try our standard filters
if|if
condition|(
name|activateInternalFilters
argument_list|(
name|node
argument_list|,
name|msg
argument_list|)
condition|)
return|return;
comment|// internal filters have already run or an error has been sent
comment|// try the object itself:
if|if
condition|(
name|node
operator|.
name|flags
operator|&
operator|(
name|QDBusConnection
operator|::
name|ExportScriptableSlots
operator||
name|QDBusConnection
operator|::
name|ExportNonScriptableSlots
operator|)
operator|||
name|node
operator|.
name|flags
operator|&
operator|(
name|QDBusConnection
operator|::
name|ExportScriptableInvokables
operator||
name|QDBusConnection
operator|::
name|ExportNonScriptableInvokables
operator|)
condition|)
block|{
name|bool
name|interfaceFound
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|msg
operator|.
name|interface
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|interfaceFound
operator|=
name|qDBusInterfaceInObject
argument_list|(
name|node
operator|.
name|obj
argument_list|,
name|msg
operator|.
name|interface
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|interfaceFound
condition|)
block|{
if|if
condition|(
operator|!
name|activateCall
argument_list|(
name|node
operator|.
name|obj
argument_list|,
name|node
operator|.
name|flags
argument_list|,
name|msg
argument_list|)
condition|)
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownMethod
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// nothing matched, send an error code
if|if
condition|(
name|msg
operator|.
name|interface
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownMethod
argument_list|)
expr_stmt|;
else|else
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownInterface
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleObjectCall
name|void
name|QDBusConnectionPrivate
operator|::
name|handleObjectCall
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
comment|// if the msg is external, we were called from inside doDispatch
comment|// that means the dispatchLock mutex is locked
comment|// must not call out to user code in that case
comment|//
comment|// however, if the message is internal, handleMessage was called
comment|// directly and no lock is in place. We can therefore call out to
comment|// user code, if necessary
name|ObjectTreeNode
name|result
decl_stmt|;
name|int
name|usedLength
decl_stmt|;
name|QThread
modifier|*
name|objThread
init|=
literal|0
decl_stmt|;
name|QSemaphore
name|sem
decl_stmt|;
name|bool
name|semWait
decl_stmt|;
block|{
name|QDBusReadLocker
name|locker
argument_list|(
name|HandleObjectCallAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|findObject
argument_list|(
operator|&
name|rootNode
argument_list|,
name|msg
operator|.
name|path
argument_list|()
argument_list|,
name|usedLength
argument_list|,
name|result
argument_list|)
condition|)
block|{
comment|// qDebug("Call failed: no object found at %s", qPrintable(msg.path()));
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownObject
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|result
operator|.
name|obj
condition|)
block|{
comment|// no object -> no threading issues
comment|// it's either going to be an error, or an internal filter
name|activateObject
argument_list|(
name|result
argument_list|,
name|msg
argument_list|,
name|usedLength
argument_list|)
expr_stmt|;
return|return;
block|}
name|objThread
operator|=
name|result
operator|.
name|obj
operator|->
name|thread
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|objThread
condition|)
block|{
name|send
argument_list|(
name|msg
operator|.
name|createErrorReply
argument_list|(
name|QDBusError
operator|::
name|InternalError
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Object '%1' (at path '%2')"
literal|" has no thread. Cannot deliver message."
argument_list|)
operator|.
name|arg
argument_list|(
name|result
operator|.
name|obj
operator|->
name|objectName
argument_list|()
argument_list|,
name|msg
operator|.
name|path
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|QDBusMessagePrivate
operator|::
name|isLocal
argument_list|(
name|msg
argument_list|)
condition|)
block|{
comment|// external incoming message
comment|// post it and forget
name|postEventToThread
argument_list|(
name|HandleObjectCallPostEventAction
argument_list|,
name|result
operator|.
name|obj
argument_list|,
operator|new
name|QDBusActivateObjectEvent
argument_list|(
name|QDBusConnection
argument_list|(
name|this
argument_list|)
argument_list|,
name|this
argument_list|,
name|result
argument_list|,
name|usedLength
argument_list|,
name|msg
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|objThread
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
comment|// synchronize with other thread
name|postEventToThread
argument_list|(
name|HandleObjectCallPostEventAction
argument_list|,
name|result
operator|.
name|obj
argument_list|,
operator|new
name|QDBusActivateObjectEvent
argument_list|(
name|QDBusConnection
argument_list|(
name|this
argument_list|)
argument_list|,
name|this
argument_list|,
name|result
argument_list|,
name|usedLength
argument_list|,
name|msg
argument_list|,
operator|&
name|sem
argument_list|)
argument_list|)
expr_stmt|;
name|semWait
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|semWait
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// release the lock
if|if
condition|(
name|semWait
condition|)
name|SEM_ACQUIRE
argument_list|(
name|HandleObjectCallSemaphoreAction
argument_list|,
name|sem
argument_list|)
expr_stmt|;
else|else
name|activateObject
argument_list|(
name|result
argument_list|,
name|msg
argument_list|,
name|usedLength
argument_list|)
expr_stmt|;
block|}
end_function
begin_destructor
DECL|function|~QDBusActivateObjectEvent
name|QDBusActivateObjectEvent
operator|::
name|~
name|QDBusActivateObjectEvent
parameter_list|()
block|{
if|if
condition|(
operator|!
name|handled
condition|)
block|{
comment|// we're being destroyed without delivering
comment|// it means the object was deleted between posting and delivering
name|QDBusConnectionPrivate
modifier|*
name|that
init|=
name|QDBusConnectionPrivate
operator|::
name|d
argument_list|(
name|connection
argument_list|)
decl_stmt|;
name|that
operator|->
name|sendError
argument_list|(
name|message
argument_list|,
name|QDBusError
operator|::
name|UnknownObject
argument_list|)
expr_stmt|;
block|}
comment|// semaphore releasing happens in ~QMetaCallEvent
block|}
end_destructor
begin_function
DECL|function|placeMetaCall
name|void
name|QDBusActivateObjectEvent
operator|::
name|placeMetaCall
parameter_list|(
name|QObject
modifier|*
parameter_list|)
block|{
name|QDBusConnectionPrivate
modifier|*
name|that
init|=
name|QDBusConnectionPrivate
operator|::
name|d
argument_list|(
name|connection
argument_list|)
decl_stmt|;
name|QDBusLockerBase
operator|::
name|reportThreadAction
argument_list|(
name|HandleObjectCallPostEventAction
argument_list|,
name|QDBusLockerBase
operator|::
name|BeforeDeliver
argument_list|,
name|that
argument_list|)
expr_stmt|;
name|that
operator|->
name|activateObject
argument_list|(
name|node
argument_list|,
name|message
argument_list|,
name|pathStartPos
argument_list|)
expr_stmt|;
name|QDBusLockerBase
operator|::
name|reportThreadAction
argument_list|(
name|HandleObjectCallPostEventAction
argument_list|,
name|QDBusLockerBase
operator|::
name|AfterDeliver
argument_list|,
name|that
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleSignal
name|void
name|QDBusConnectionPrivate
operator|::
name|handleSignal
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
name|SignalHookHash
operator|::
name|const_iterator
name|it
init|=
name|signalHooks
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|SignalHookHash
operator|::
name|const_iterator
name|end
init|=
name|signalHooks
operator|.
name|constEnd
argument_list|()
decl_stmt|;
comment|//qDebug("looking for: %s", path.toLocal8Bit().constData());
comment|//qDBusDebug()<< signalHooks.keys();
for|for
control|(
init|;
name|it
operator|!=
name|end
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|key
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|SignalHook
modifier|&
name|hook
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hook
operator|.
name|service
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|QString
name|owner
init|=
name|shouldWatchService
argument_list|(
name|hook
operator|.
name|service
argument_list|)
condition|?
name|watchedServices
operator|.
name|value
argument_list|(
name|hook
operator|.
name|service
argument_list|)
operator|.
name|owner
else|:
name|hook
operator|.
name|service
decl_stmt|;
if|if
condition|(
name|owner
operator|!=
name|msg
operator|.
name|service
argument_list|()
condition|)
continue|continue;
block|}
if|if
condition|(
operator|!
name|hook
operator|.
name|path
operator|.
name|isEmpty
argument_list|()
operator|&&
name|hook
operator|.
name|path
operator|!=
name|msg
operator|.
name|path
argument_list|()
condition|)
continue|continue;
if|if
condition|(
operator|!
name|hook
operator|.
name|signature
operator|.
name|isEmpty
argument_list|()
operator|&&
name|hook
operator|.
name|signature
operator|!=
name|msg
operator|.
name|signature
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|hook
operator|.
name|signature
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|hook
operator|.
name|signature
operator|.
name|isNull
argument_list|()
operator|&&
operator|!
name|msg
operator|.
name|signature
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
if|if
condition|(
operator|!
name|hook
operator|.
name|argumentMatch
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|QVariantList
name|arguments
init|=
name|msg
operator|.
name|arguments
argument_list|()
decl_stmt|;
if|if
condition|(
name|hook
operator|.
name|argumentMatch
operator|.
name|size
argument_list|()
operator|>
name|arguments
operator|.
name|size
argument_list|()
condition|)
continue|continue;
name|bool
name|matched
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hook
operator|.
name|argumentMatch
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
modifier|&
name|param
init|=
name|hook
operator|.
name|argumentMatch
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|param
operator|.
name|isNull
argument_list|()
condition|)
continue|continue;
comment|// don't try to match against this
if|if
condition|(
name|param
operator|==
name|arguments
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
condition|)
continue|continue;
comment|// matched
name|matched
operator|=
literal|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|matched
condition|)
continue|continue;
block|}
name|activateSignal
argument_list|(
name|hook
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|handleSignal
name|void
name|QDBusConnectionPrivate
operator|::
name|handleSignal
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
comment|// We call handlesignal(QString, QDBusMessage) three times:
comment|//  one with member:interface
comment|//  one with member:
comment|//  one with :interface
comment|// This allows us to match signals with wildcards on member or interface
comment|// (but not both)
name|QString
name|key
init|=
name|msg
operator|.
name|member
argument_list|()
decl_stmt|;
name|key
operator|.
name|reserve
argument_list|(
name|key
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|+
name|msg
operator|.
name|interface
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|+=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|key
operator|+=
name|msg
operator|.
name|interface
argument_list|()
expr_stmt|;
name|QDBusReadLocker
name|locker
argument_list|(
name|HandleSignalAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|handleSignal
argument_list|(
name|key
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// one try
name|key
operator|.
name|truncate
argument_list|(
name|msg
operator|.
name|member
argument_list|()
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// keep the ':'
name|handleSignal
argument_list|(
name|key
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// second try
name|key
operator|=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|key
operator|+=
name|msg
operator|.
name|interface
argument_list|()
expr_stmt|;
name|handleSignal
argument_list|(
name|key
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// third try
block|}
end_function
begin_decl_stmt
DECL|variable|server_slot
specifier|static
name|dbus_int32_t
name|server_slot
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|setServer
name|void
name|QDBusConnectionPrivate
operator|::
name|setServer
parameter_list|(
name|DBusServer
modifier|*
name|s
parameter_list|,
specifier|const
name|QDBusErrorInternal
modifier|&
name|error
parameter_list|)
block|{
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|handleError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|server
operator|=
name|s
expr_stmt|;
name|mode
operator|=
name|ServerMode
expr_stmt|;
name|dbus_bool_t
name|data_allocated
init|=
name|q_dbus_server_allocate_data_slot
argument_list|(
operator|&
name|server_slot
argument_list|)
decl_stmt|;
if|if
condition|(
name|data_allocated
operator|&&
name|server_slot
operator|<
literal|0
condition|)
return|return;
name|dbus_bool_t
name|watch_functions_set
init|=
name|q_dbus_server_set_watch_functions
argument_list|(
name|server
argument_list|,
name|qDBusAddWatch
argument_list|,
name|qDBusRemoveWatch
argument_list|,
name|qDBusToggleWatch
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|//qDebug()<< "watch_functions_set"<< watch_functions_set;
name|Q_UNUSED
argument_list|(
name|watch_functions_set
argument_list|)
expr_stmt|;
name|dbus_bool_t
name|time_functions_set
init|=
name|q_dbus_server_set_timeout_functions
argument_list|(
name|server
argument_list|,
name|qDBusAddTimeout
argument_list|,
name|qDBusRemoveTimeout
argument_list|,
name|qDBusToggleTimeout
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|//qDebug()<< "time_functions_set"<< time_functions_set;
name|Q_UNUSED
argument_list|(
name|time_functions_set
argument_list|)
expr_stmt|;
name|q_dbus_server_set_new_connection_function
argument_list|(
name|server
argument_list|,
name|qDBusNewConnection
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbus_bool_t
name|data_set
init|=
name|q_dbus_server_set_data
argument_list|(
name|server
argument_list|,
name|server_slot
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|//qDebug()<< "data_set"<< data_set;
name|Q_UNUSED
argument_list|(
name|data_set
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setPeer
name|void
name|QDBusConnectionPrivate
operator|::
name|setPeer
parameter_list|(
name|DBusConnection
modifier|*
name|c
parameter_list|,
specifier|const
name|QDBusErrorInternal
modifier|&
name|error
parameter_list|)
block|{
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|handleError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|connection
operator|=
name|c
expr_stmt|;
name|mode
operator|=
name|PeerMode
expr_stmt|;
name|q_dbus_connection_set_exit_on_disconnect
argument_list|(
name|connection
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|q_dbus_connection_set_watch_functions
argument_list|(
name|connection
argument_list|,
name|qDBusAddWatch
argument_list|,
name|qDBusRemoveWatch
argument_list|,
name|qDBusToggleWatch
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_dbus_connection_set_timeout_functions
argument_list|(
name|connection
argument_list|,
name|qDBusAddTimeout
argument_list|,
name|qDBusRemoveTimeout
argument_list|,
name|qDBusToggleTimeout
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_dbus_connection_set_dispatch_status_function
argument_list|(
name|connection
argument_list|,
name|qDBusUpdateDispatchStatus
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_dbus_connection_add_filter
argument_list|(
name|connection
argument_list|,
name|qDBusSignalFilter
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"doDispatch"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|connectionCapabilies
specifier|static
name|QDBusConnection
operator|::
name|ConnectionCapabilities
name|connectionCapabilies
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|)
block|{
name|QDBusConnection
operator|::
name|ConnectionCapabilities
name|result
init|=
literal|0
decl_stmt|;
typedef|typedef
name|dbus_bool_t
function_decl|(
modifier|*
name|can_send_type_t
function_decl|)
parameter_list|(
name|DBusConnection
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|static
name|can_send_type_t
name|can_send_type
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_LINKED_LIBDBUS
argument_list|)
if|#
directive|if
name|DBUS_VERSION
operator|-
literal|0
operator|>=
literal|0x010400
name|can_send_type
operator|=
name|dbus_connection_can_send_type
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|// run-time check if the next functions are available
name|can_send_type
operator|=
operator|(
name|can_send_type_t
operator|)
name|qdbus_resolve_conditionally
argument_list|(
literal|"dbus_connection_can_send_type"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DBUS_TYPE_UNIX_FD
DECL|macro|DBUS_TYPE_UNIX_FD
define|#
directive|define
name|DBUS_TYPE_UNIX_FD
value|int('h')
endif|#
directive|endif
if|if
condition|(
name|can_send_type
operator|&&
name|can_send_type
argument_list|(
name|connection
argument_list|,
name|DBUS_TYPE_UNIX_FD
argument_list|)
condition|)
name|result
operator||=
name|QDBusConnection
operator|::
name|UnixFileDescriptorPassing
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|setConnection
name|void
name|QDBusConnectionPrivate
operator|::
name|setConnection
parameter_list|(
name|DBusConnection
modifier|*
name|dbc
parameter_list|,
specifier|const
name|QDBusErrorInternal
modifier|&
name|error
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dbc
condition|)
block|{
name|handleError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|connection
operator|=
name|dbc
expr_stmt|;
name|mode
operator|=
name|ClientMode
expr_stmt|;
specifier|const
name|char
modifier|*
name|service
init|=
name|q_dbus_bus_get_unique_name
argument_list|(
name|connection
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|baseService
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|capabilities
operator|=
name|connectionCapabilies
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|q_dbus_connection_set_exit_on_disconnect
argument_list|(
name|connection
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|q_dbus_connection_set_watch_functions
argument_list|(
name|connection
argument_list|,
name|qDBusAddWatch
argument_list|,
name|qDBusRemoveWatch
argument_list|,
name|qDBusToggleWatch
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_dbus_connection_set_timeout_functions
argument_list|(
name|connection
argument_list|,
name|qDBusAddTimeout
argument_list|,
name|qDBusRemoveTimeout
argument_list|,
name|qDBusToggleTimeout
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_dbus_connection_set_dispatch_status_function
argument_list|(
name|connection
argument_list|,
name|qDBusUpdateDispatchStatus
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_dbus_connection_add_filter
argument_list|(
name|connection
argument_list|,
name|qDBusSignalFilter
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Initialize the hooks for the NameAcquired and NameLost signals
comment|// we don't use connectSignal here because we don't need the rules to be sent to the bus
comment|// the bus will always send us these two signals
name|SignalHook
name|hook
decl_stmt|;
name|hook
operator|.
name|service
operator|=
name|dbusServiceString
argument_list|()
expr_stmt|;
name|hook
operator|.
name|path
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// no matching
name|hook
operator|.
name|obj
operator|=
name|this
expr_stmt|;
name|hook
operator|.
name|params
operator|<<
name|QMetaType
operator|::
name|Void
operator|<<
name|QVariant
operator|::
name|String
expr_stmt|;
comment|// both functions take a QString as parameter and return void
name|hook
operator|.
name|midx
operator|=
name|staticMetaObject
operator|.
name|indexOfSlot
argument_list|(
literal|"registerServiceNoLock(QString)"
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|hook
operator|.
name|midx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|signalHooks
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|"NameAcquired:"
name|DBUS_INTERFACE_DBUS
argument_list|)
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|hook
operator|.
name|midx
operator|=
name|staticMetaObject
operator|.
name|indexOfSlot
argument_list|(
literal|"unregisterServiceNoLock(QString)"
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|hook
operator|.
name|midx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|signalHooks
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|"NameLost:"
name|DBUS_INTERFACE_DBUS
argument_list|)
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|": connected successfully"
expr_stmt|;
comment|// schedule a dispatch:
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"doDispatch"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_extern
extern|extern
literal|"C"
block|{
DECL|function|qDBusResultReceived
specifier|static
name|void
name|qDBusResultReceived
parameter_list|(
name|DBusPendingCall
modifier|*
name|pending
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|QDBusPendingCallPrivate
modifier|*
name|call
init|=
cast|reinterpret_cast
argument_list|<
name|QDBusPendingCallPrivate
operator|*
argument_list|>
argument_list|(
name|user_data
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|call
operator|->
name|pending
operator|==
name|pending
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|pending
argument_list|)
expr_stmt|;
name|QDBusConnectionPrivate
operator|::
name|processFinishedCall
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
block|}
end_extern
begin_function
DECL|function|waitForFinished
name|void
name|QDBusConnectionPrivate
operator|::
name|waitForFinished
parameter_list|(
name|QDBusPendingCallPrivate
modifier|*
name|pcall
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|pcall
operator|->
name|pending
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|pcall
operator|->
name|autoDelete
argument_list|)
expr_stmt|;
comment|//Q_ASSERT(pcall->mutex.isLocked()); // there's no such function
if|if
condition|(
name|pcall
operator|->
name|waitingForFinished
condition|)
block|{
comment|// another thread is already waiting
name|pcall
operator|->
name|waitForFinishedCondition
operator|.
name|wait
argument_list|(
operator|&
name|pcall
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcall
operator|->
name|waitingForFinished
operator|=
literal|true
expr_stmt|;
name|pcall
operator|->
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|{
name|QDBusDispatchLocker
name|locker
argument_list|(
name|PendingCallBlockAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|q_dbus_pending_call_block
argument_list|(
name|pcall
operator|->
name|pending
argument_list|)
expr_stmt|;
comment|// QDBusConnectionPrivate::processFinishedCall() is called automatically
block|}
name|pcall
operator|->
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|pcall
operator|->
name|waitForFinishedCondition
operator|.
name|wakeAll
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// this function is called only in a Q_ASSERT
end_comment
begin_function
DECL|function|waitingForFinishedIsSet
specifier|static
specifier|inline
name|Q_DECL_UNUSED
name|bool
name|waitingForFinishedIsSet
parameter_list|(
name|QDBusPendingCallPrivate
modifier|*
name|call
parameter_list|)
block|{
specifier|const
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|call
operator|->
name|mutex
argument_list|)
decl_stmt|;
return|return
name|call
operator|->
name|waitingForFinished
return|;
block|}
end_function
begin_function
DECL|function|processFinishedCall
name|void
name|QDBusConnectionPrivate
operator|::
name|processFinishedCall
parameter_list|(
name|QDBusPendingCallPrivate
modifier|*
name|call
parameter_list|)
block|{
name|QDBusConnectionPrivate
modifier|*
name|connection
init|=
cast|const_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|call
operator|->
name|connection
argument_list|)
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|call
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|QDBusMessage
modifier|&
name|msg
init|=
name|call
operator|->
name|replyMessage
decl_stmt|;
if|if
condition|(
name|call
operator|->
name|pending
condition|)
block|{
comment|// decode the message
name|DBusMessage
modifier|*
name|reply
init|=
name|q_dbus_pending_call_steal_reply
argument_list|(
name|call
operator|->
name|pending
argument_list|)
decl_stmt|;
name|msg
operator|=
name|QDBusMessagePrivate
operator|::
name|fromDBusMessage
argument_list|(
name|reply
argument_list|,
name|connection
operator|->
name|capabilities
argument_list|)
expr_stmt|;
name|q_dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
name|qDBusDebug
argument_list|()
operator|<<
name|connection
operator|<<
literal|"got message reply (async):"
operator|<<
name|msg
expr_stmt|;
comment|// Check if the reply has the expected signature
name|call
operator|->
name|checkReceivedSignature
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|call
operator|->
name|receiver
operator|.
name|isNull
argument_list|()
operator|&&
name|call
operator|->
name|methodIdx
operator|!=
operator|-
literal|1
operator|&&
name|msg
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ReplyMessage
condition|)
block|{
comment|// Deliver the return values of a remote function call.
comment|//
comment|// There is only one connection and it is specified by idx
comment|// The slot must have the same parameter types that the message does
comment|// The slot may have less parameters than the message
comment|// The slot may optionally have one final parameter that is QDBusMessage
comment|// The slot receives read-only copies of the message (i.e., pass by value or by const-ref)
name|QDBusCallDeliveryEvent
modifier|*
name|e
init|=
name|prepareReply
argument_list|(
name|connection
argument_list|,
name|call
operator|->
name|receiver
argument_list|,
name|call
operator|->
name|methodIdx
argument_list|,
name|call
operator|->
name|metaTypes
argument_list|,
name|msg
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
condition|)
name|connection
operator|->
name|postEventToThread
argument_list|(
name|MessageResultReceivedAction
argument_list|,
name|call
operator|->
name|receiver
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|qDBusDebug
argument_list|()
operator|<<
literal|"Deliver failed!"
expr_stmt|;
block|}
if|if
condition|(
name|call
operator|->
name|pending
condition|)
name|q_dbus_pending_call_unref
argument_list|(
name|call
operator|->
name|pending
argument_list|)
expr_stmt|;
name|call
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// Are there any watchers?
if|if
condition|(
name|call
operator|->
name|watcherHelper
condition|)
name|call
operator|->
name|watcherHelper
operator|->
name|emitSignals
argument_list|(
name|msg
argument_list|,
name|call
operator|->
name|sentMessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ErrorMessage
condition|)
emit|emit
name|connection
operator|->
name|callWithCallbackFailed
argument_list|(
name|QDBusError
argument_list|(
name|msg
argument_list|)
argument_list|,
name|call
operator|->
name|sentMessage
argument_list|)
emit|;
if|if
condition|(
name|call
operator|->
name|autoDelete
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|waitingForFinishedIsSet
argument_list|(
name|call
argument_list|)
argument_list|)
expr_stmt|;
comment|// can't wait on a call with autoDelete!
operator|delete
name|call
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|send
name|int
name|QDBusConnectionPrivate
operator|::
name|send
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|)
block|{
if|if
condition|(
name|QDBusMessagePrivate
operator|::
name|isLocal
argument_list|(
name|message
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|// don't send; the reply will be retrieved by the caller
comment|// through the d_ptr->localReply link
name|QDBusError
name|error
decl_stmt|;
name|DBusMessage
modifier|*
name|msg
init|=
name|QDBusMessagePrivate
operator|::
name|toDBusMessage
argument_list|(
name|message
argument_list|,
name|capabilities
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
block|{
if|if
condition|(
name|message
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|MethodCallMessage
condition|)
name|qWarning
argument_list|(
literal|"QDBusConnection: error: could not send message to service \"%s\" path \"%s\" interface \"%s\" member \"%s\": %s"
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|service
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|path
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|interface
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|member
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|error
operator|.
name|message
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|message
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|SignalMessage
condition|)
name|qWarning
argument_list|(
literal|"QDBusConnection: error: could not send signal path \"%s\" interface \"%s\" member \"%s\": %s"
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|path
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|interface
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|member
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|error
operator|.
name|message
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QDBusConnection: error: could not send %s message to service \"%s\": %s"
argument_list|,
name|message
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ReplyMessage
condition|?
literal|"reply"
else|:
name|message
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ErrorMessage
condition|?
literal|"error"
else|:
literal|"invalid"
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|service
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|error
operator|.
name|message
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|lastError
operator|=
name|error
expr_stmt|;
return|return
literal|0
return|;
block|}
name|q_dbus_message_set_no_reply
argument_list|(
name|msg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// the reply would not be delivered to anything
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"sending message (no reply):"
operator|<<
name|message
expr_stmt|;
name|checkThread
argument_list|()
expr_stmt|;
name|bool
name|isOk
init|=
name|q_dbus_connection_send
argument_list|(
name|connection
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|serial
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isOk
condition|)
name|serial
operator|=
name|q_dbus_message_get_serial
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|q_dbus_message_unref
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|serial
return|;
block|}
end_function
begin_function
DECL|function|sendWithReply
name|QDBusMessage
name|QDBusConnectionPrivate
operator|::
name|sendWithReply
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|,
name|int
name|sendMode
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|checkThread
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sendMode
operator|==
name|QDBus
operator|::
name|BlockWithGui
operator|||
name|sendMode
operator|==
name|QDBus
operator|::
name|Block
operator|)
operator|&&
name|isServiceRegisteredByThread
argument_list|(
name|message
operator|.
name|service
argument_list|()
argument_list|)
condition|)
comment|// special case for synchronous local calls
return|return
name|sendWithReplyLocal
argument_list|(
name|message
argument_list|)
return|;
if|if
condition|(
operator|!
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|||
name|sendMode
operator|==
name|QDBus
operator|::
name|Block
condition|)
block|{
name|QDBusError
name|err
decl_stmt|;
name|DBusMessage
modifier|*
name|msg
init|=
name|QDBusMessagePrivate
operator|::
name|toDBusMessage
argument_list|(
name|message
argument_list|,
name|capabilities
argument_list|,
operator|&
name|err
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDBusConnection: error: could not send message to service \"%s\" path \"%s\" interface \"%s\" member \"%s\": %s"
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|service
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|path
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|interface
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|member
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|err
operator|.
name|message
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|lastError
operator|=
name|err
expr_stmt|;
return|return
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|err
argument_list|)
return|;
block|}
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"sending message (blocking):"
operator|<<
name|message
expr_stmt|;
name|QDBusErrorInternal
name|error
decl_stmt|;
name|DBusMessage
modifier|*
name|reply
init|=
name|q_dbus_connection_send_with_reply_and_block
argument_list|(
name|connection
argument_list|,
name|msg
argument_list|,
name|timeout
argument_list|,
name|error
argument_list|)
decl_stmt|;
name|q_dbus_message_unref
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|!
name|error
condition|)
block|{
name|lastError
operator|=
name|err
operator|=
name|error
expr_stmt|;
return|return
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|err
argument_list|)
return|;
block|}
name|QDBusMessage
name|amsg
init|=
name|QDBusMessagePrivate
operator|::
name|fromDBusMessage
argument_list|(
name|reply
argument_list|,
name|capabilities
argument_list|)
decl_stmt|;
name|q_dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"got message reply (blocking):"
operator|<<
name|amsg
expr_stmt|;
return|return
name|amsg
return|;
block|}
else|else
block|{
comment|// use the event loop
name|QDBusPendingCallPrivate
modifier|*
name|pcall
init|=
name|sendWithReplyAsync
argument_list|(
name|message
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|pcall
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcall
operator|->
name|replyMessage
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|InvalidMessage
condition|)
block|{
name|pcall
operator|->
name|watcherHelper
operator|=
operator|new
name|QDBusPendingCallWatcherHelper
expr_stmt|;
name|QEventLoop
name|loop
decl_stmt|;
name|loop
operator|.
name|connect
argument_list|(
name|pcall
operator|->
name|watcherHelper
argument_list|,
name|SIGNAL
argument_list|(
name|reply
argument_list|(
name|QDBusMessage
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|quit
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|.
name|connect
argument_list|(
name|pcall
operator|->
name|watcherHelper
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QDBusError
argument_list|,
name|QDBusMessage
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|quit
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// enter the event loop and wait for a reply
name|loop
operator|.
name|exec
argument_list|(
name|QEventLoop
operator|::
name|ExcludeUserInputEvents
operator||
name|QEventLoop
operator|::
name|WaitForMoreEvents
argument_list|)
expr_stmt|;
block|}
name|QDBusMessage
name|reply
init|=
name|pcall
operator|->
name|replyMessage
decl_stmt|;
name|lastError
operator|=
name|QDBusError
argument_list|(
name|reply
argument_list|)
expr_stmt|;
comment|// set or clear error
operator|delete
name|pcall
expr_stmt|;
return|return
name|reply
return|;
block|}
block|}
end_function
begin_function
DECL|function|sendWithReplyLocal
name|QDBusMessage
name|QDBusConnectionPrivate
operator|::
name|sendWithReplyLocal
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|)
block|{
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"sending message via local-loop:"
operator|<<
name|message
expr_stmt|;
name|QDBusMessage
name|localCallMsg
init|=
name|QDBusMessagePrivate
operator|::
name|makeLocal
argument_list|(
operator|*
name|this
argument_list|,
name|message
argument_list|)
decl_stmt|;
name|bool
name|handled
init|=
name|handleMessage
argument_list|(
name|localCallMsg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|handled
condition|)
block|{
name|QString
name|interface
init|=
name|message
operator|.
name|interface
argument_list|()
decl_stmt|;
if|if
condition|(
name|interface
operator|.
name|isEmpty
argument_list|()
condition|)
name|interface
operator|=
name|QLatin1String
argument_list|(
literal|"<no-interface>"
argument_list|)
expr_stmt|;
return|return
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|QDBusError
operator|::
name|InternalError
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Internal error trying to call %1.%2 at %3 (signature '%4'"
argument_list|)
operator|.
name|arg
argument_list|(
name|interface
argument_list|,
name|message
operator|.
name|member
argument_list|()
argument_list|,
name|message
operator|.
name|path
argument_list|()
argument_list|,
name|message
operator|.
name|signature
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|// if the message was handled, there might be a reply
name|QDBusMessage
name|localReplyMsg
init|=
name|QDBusMessagePrivate
operator|::
name|makeLocalReply
argument_list|(
operator|*
name|this
argument_list|,
name|localCallMsg
argument_list|)
decl_stmt|;
if|if
condition|(
name|localReplyMsg
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|InvalidMessage
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDBusConnection: cannot call local method '%s' at object %s (with signature '%s') "
literal|"on blocking mode"
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|member
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|path
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|signature
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|InternalError
argument_list|,
name|QLatin1String
argument_list|(
literal|"local-loop message cannot have delayed replies"
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|// there is a reply
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"got message via local-loop:"
operator|<<
name|localReplyMsg
expr_stmt|;
return|return
name|localReplyMsg
return|;
block|}
end_function
begin_function
DECL|function|sendWithReplyAsync
name|QDBusPendingCallPrivate
modifier|*
name|QDBusConnectionPrivate
operator|::
name|sendWithReplyAsync
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
if|if
condition|(
name|isServiceRegisteredByThread
argument_list|(
name|message
operator|.
name|service
argument_list|()
argument_list|)
condition|)
block|{
comment|// special case for local calls
name|QDBusPendingCallPrivate
modifier|*
name|pcall
init|=
operator|new
name|QDBusPendingCallPrivate
argument_list|(
name|message
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|pcall
operator|->
name|replyMessage
operator|=
name|sendWithReplyLocal
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
name|pcall
return|;
block|}
name|checkThread
argument_list|()
expr_stmt|;
name|QDBusPendingCallPrivate
modifier|*
name|pcall
init|=
operator|new
name|QDBusPendingCallPrivate
argument_list|(
name|message
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|pcall
operator|->
name|ref
operator|.
name|store
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QDBusError
name|error
decl_stmt|;
name|DBusMessage
modifier|*
name|msg
init|=
name|QDBusMessagePrivate
operator|::
name|toDBusMessage
argument_list|(
name|message
argument_list|,
name|capabilities
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDBusConnection: error: could not send message to service \"%s\" path \"%s\" interface \"%s\" member \"%s\": %s"
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|service
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|path
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|interface
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|member
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|error
operator|.
name|message
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pcall
operator|->
name|replyMessage
operator|=
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|lastError
operator|=
name|error
expr_stmt|;
return|return
name|pcall
return|;
block|}
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"sending message (async):"
operator|<<
name|message
expr_stmt|;
name|DBusPendingCall
modifier|*
name|pending
init|=
literal|0
decl_stmt|;
name|QDBusDispatchLocker
name|locker
argument_list|(
name|SendWithReplyAsyncAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|q_dbus_connection_send_with_reply
argument_list|(
name|connection
argument_list|,
name|msg
argument_list|,
operator|&
name|pending
argument_list|,
name|timeout
argument_list|)
condition|)
block|{
if|if
condition|(
name|pending
condition|)
block|{
name|q_dbus_message_unref
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|pcall
operator|->
name|pending
operator|=
name|pending
expr_stmt|;
name|q_dbus_pending_call_set_notify
argument_list|(
name|pending
argument_list|,
name|qDBusResultReceived
argument_list|,
name|pcall
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|pcall
return|;
block|}
else|else
block|{
comment|// we're probably disconnected at this point
name|lastError
operator|=
name|error
operator|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|Disconnected
argument_list|,
name|QLatin1String
argument_list|(
literal|"Not connected to server"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lastError
operator|=
name|error
operator|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|NoMemory
argument_list|,
name|QLatin1String
argument_list|(
literal|"Out of memory"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|q_dbus_message_unref
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|pcall
operator|->
name|replyMessage
operator|=
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
name|pcall
return|;
block|}
end_function
begin_function
DECL|function|sendWithReplyAsync
name|int
name|QDBusConnectionPrivate
operator|::
name|sendWithReplyAsync
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|returnMethod
parameter_list|,
specifier|const
name|char
modifier|*
name|errorMethod
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|QDBusPendingCallPrivate
modifier|*
name|pcall
init|=
name|sendWithReplyAsync
argument_list|(
name|message
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|pcall
argument_list|)
expr_stmt|;
comment|// has it already finished with success (dispatched locally)?
if|if
condition|(
name|pcall
operator|->
name|replyMessage
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ReplyMessage
condition|)
block|{
name|pcall
operator|->
name|setReplyCallback
argument_list|(
name|receiver
argument_list|,
name|returnMethod
argument_list|)
expr_stmt|;
name|processFinishedCall
argument_list|(
name|pcall
argument_list|)
expr_stmt|;
operator|delete
name|pcall
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|// either it hasn't finished or it has finished with error
if|if
condition|(
name|errorMethod
condition|)
block|{
name|pcall
operator|->
name|watcherHelper
operator|=
operator|new
name|QDBusPendingCallWatcherHelper
expr_stmt|;
name|connect
argument_list|(
name|pcall
operator|->
name|watcherHelper
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QDBusError
argument_list|,
name|QDBusMessage
argument_list|)
argument_list|)
argument_list|,
name|receiver
argument_list|,
name|errorMethod
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|pcall
operator|->
name|watcherHelper
operator|->
name|moveToThread
argument_list|(
name|thread
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// has it already finished and is an error reply message?
if|if
condition|(
name|pcall
operator|->
name|replyMessage
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ErrorMessage
condition|)
block|{
name|processFinishedCall
argument_list|(
name|pcall
argument_list|)
expr_stmt|;
operator|delete
name|pcall
expr_stmt|;
return|return
literal|1
return|;
block|}
name|pcall
operator|->
name|autoDelete
operator|=
literal|true
expr_stmt|;
name|pcall
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|pcall
operator|->
name|setReplyCallback
argument_list|(
name|receiver
argument_list|,
name|returnMethod
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|connectSignal
name|bool
name|QDBusConnectionPrivate
operator|::
name|connectSignal
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|argumentMatch
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
comment|// check the slot
name|QDBusConnectionPrivate
operator|::
name|SignalHook
name|hook
decl_stmt|;
name|QString
name|key
decl_stmt|;
name|QString
name|name2
init|=
name|name
decl_stmt|;
if|if
condition|(
name|name2
operator|.
name|isNull
argument_list|()
condition|)
name|name2
operator|.
name|detach
argument_list|()
expr_stmt|;
name|hook
operator|.
name|signature
operator|=
name|signature
expr_stmt|;
if|if
condition|(
operator|!
name|prepareHook
argument_list|(
name|hook
argument_list|,
name|key
argument_list|,
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|argumentMatch
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// don't connect
comment|// avoid duplicating:
name|QDBusConnectionPrivate
operator|::
name|SignalHookHash
operator|::
name|ConstIterator
name|it
init|=
name|signalHooks
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|SignalHookHash
operator|::
name|ConstIterator
name|end
init|=
name|signalHooks
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|key
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QDBusConnectionPrivate
operator|::
name|SignalHook
modifier|&
name|entry
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|service
operator|==
name|hook
operator|.
name|service
operator|&&
name|entry
operator|.
name|path
operator|==
name|hook
operator|.
name|path
operator|&&
name|entry
operator|.
name|signature
operator|==
name|hook
operator|.
name|signature
operator|&&
name|entry
operator|.
name|obj
operator|==
name|hook
operator|.
name|obj
operator|&&
name|entry
operator|.
name|midx
operator|==
name|hook
operator|.
name|midx
operator|&&
name|entry
operator|.
name|argumentMatch
operator|==
name|hook
operator|.
name|argumentMatch
condition|)
block|{
comment|// no need to compare the parameters if it's the same slot
return|return
literal|true
return|;
comment|// already there
block|}
block|}
name|connectSignal
argument_list|(
name|key
argument_list|,
name|hook
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|connectSignal
name|void
name|QDBusConnectionPrivate
operator|::
name|connectSignal
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|SignalHook
modifier|&
name|hook
parameter_list|)
block|{
name|signalHooks
operator|.
name|insertMulti
argument_list|(
name|key
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|hook
operator|.
name|obj
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|objectDestroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|ConnectionType
argument_list|(
name|Qt
operator|::
name|DirectConnection
operator||
name|Qt
operator|::
name|UniqueConnection
argument_list|)
argument_list|)
expr_stmt|;
name|MatchRefCountHash
operator|::
name|iterator
name|it
init|=
name|matchRefCounts
operator|.
name|find
argument_list|(
name|hook
operator|.
name|matchRule
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|matchRefCounts
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// Match already present
name|it
operator|.
name|value
argument_list|()
operator|=
name|it
operator|.
name|value
argument_list|()
operator|+
literal|1
expr_stmt|;
return|return;
block|}
name|matchRefCounts
operator|.
name|insert
argument_list|(
name|hook
operator|.
name|matchRule
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|QDBusConnectionPrivate
operator|::
name|PeerMode
condition|)
block|{
name|qDBusDebug
argument_list|(
literal|"Adding rule: %s"
argument_list|,
name|hook
operator|.
name|matchRule
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|q_dbus_bus_add_match
argument_list|(
name|connection
argument_list|,
name|hook
operator|.
name|matchRule
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|// Successfully connected the signal
comment|// Do we need to watch for this name?
if|if
condition|(
name|shouldWatchService
argument_list|(
name|hook
operator|.
name|service
argument_list|)
condition|)
block|{
name|WatchedServicesHash
operator|::
name|mapped_type
modifier|&
name|data
init|=
name|watchedServices
index|[
name|hook
operator|.
name|service
index|]
decl_stmt|;
if|if
condition|(
operator|++
name|data
operator|.
name|refcount
operator|==
literal|1
condition|)
block|{
comment|// we need to watch for this service changing
name|connectSignal
argument_list|(
name|dbusServiceString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|dbusInterfaceString
argument_list|()
argument_list|,
name|QLatin1String
argument_list|(
literal|"NameOwnerChanged"
argument_list|)
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|hook
operator|.
name|service
argument_list|,
name|QString
argument_list|()
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|serviceOwnerChangedNoLock
argument_list|(
name|QString
argument_list|,
name|QString
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|owner
operator|=
name|getNameOwnerNoCache
argument_list|(
name|hook
operator|.
name|service
argument_list|)
expr_stmt|;
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"Watching service"
operator|<<
name|hook
operator|.
name|service
operator|<<
literal|"for owner changes (current owner:"
operator|<<
name|data
operator|.
name|owner
operator|<<
literal|")"
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|disconnectSignal
name|bool
name|QDBusConnectionPrivate
operator|::
name|disconnectSignal
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|argumentMatch
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
comment|// check the slot
name|QDBusConnectionPrivate
operator|::
name|SignalHook
name|hook
decl_stmt|;
name|QString
name|key
decl_stmt|;
name|QString
name|name2
init|=
name|name
decl_stmt|;
if|if
condition|(
name|name2
operator|.
name|isNull
argument_list|()
condition|)
name|name2
operator|.
name|detach
argument_list|()
expr_stmt|;
name|hook
operator|.
name|signature
operator|=
name|signature
expr_stmt|;
if|if
condition|(
operator|!
name|prepareHook
argument_list|(
name|hook
argument_list|,
name|key
argument_list|,
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|argumentMatch
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// don't disconnect
comment|// avoid duplicating:
name|QDBusConnectionPrivate
operator|::
name|SignalHookHash
operator|::
name|Iterator
name|it
init|=
name|signalHooks
operator|.
name|find
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|SignalHookHash
operator|::
name|Iterator
name|end
init|=
name|signalHooks
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|key
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QDBusConnectionPrivate
operator|::
name|SignalHook
modifier|&
name|entry
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|service
operator|==
name|hook
operator|.
name|service
operator|&&
name|entry
operator|.
name|path
operator|==
name|hook
operator|.
name|path
operator|&&
name|entry
operator|.
name|signature
operator|==
name|hook
operator|.
name|signature
operator|&&
name|entry
operator|.
name|obj
operator|==
name|hook
operator|.
name|obj
operator|&&
name|entry
operator|.
name|midx
operator|==
name|hook
operator|.
name|midx
operator|&&
name|entry
operator|.
name|argumentMatch
operator|==
name|hook
operator|.
name|argumentMatch
condition|)
block|{
comment|// no need to compare the parameters if it's the same slot
name|disconnectSignal
argument_list|(
name|it
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// it was there
block|}
block|}
comment|// the slot was not found
return|return
literal|false
return|;
block|}
end_function
begin_function
name|QDBusConnectionPrivate
operator|::
name|SignalHookHash
operator|::
name|Iterator
DECL|function|disconnectSignal
name|QDBusConnectionPrivate
operator|::
name|disconnectSignal
parameter_list|(
name|SignalHookHash
operator|::
name|Iterator
modifier|&
name|it
parameter_list|)
block|{
specifier|const
name|SignalHook
modifier|&
name|hook
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|bool
name|erase
init|=
literal|false
decl_stmt|;
name|MatchRefCountHash
operator|::
name|iterator
name|i
init|=
name|matchRefCounts
operator|.
name|find
argument_list|(
name|hook
operator|.
name|matchRule
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|matchRefCounts
operator|.
name|end
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDBusConnectionPrivate::disconnectSignal: MatchRule not found in matchRefCounts!!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|==
literal|1
condition|)
block|{
name|erase
operator|=
literal|true
expr_stmt|;
name|matchRefCounts
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|value
argument_list|()
operator|=
name|i
operator|.
name|value
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|// we don't care about errors here
if|if
condition|(
name|connection
operator|&&
name|erase
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|QDBusConnectionPrivate
operator|::
name|PeerMode
condition|)
block|{
name|qDBusDebug
argument_list|(
literal|"Removing rule: %s"
argument_list|,
name|hook
operator|.
name|matchRule
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|q_dbus_bus_remove_match
argument_list|(
name|connection
argument_list|,
name|hook
operator|.
name|matchRule
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|// Successfully disconnected the signal
comment|// Were we watching for this name?
name|WatchedServicesHash
operator|::
name|Iterator
name|sit
init|=
name|watchedServices
operator|.
name|find
argument_list|(
name|hook
operator|.
name|service
argument_list|)
decl_stmt|;
if|if
condition|(
name|sit
operator|!=
name|watchedServices
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|--
name|sit
operator|.
name|value
argument_list|()
operator|.
name|refcount
operator|==
literal|0
condition|)
block|{
name|watchedServices
operator|.
name|erase
argument_list|(
name|sit
argument_list|)
expr_stmt|;
name|disconnectSignal
argument_list|(
name|dbusServiceString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|dbusInterfaceString
argument_list|()
argument_list|,
name|QLatin1String
argument_list|(
literal|"NameOwnerChanged"
argument_list|)
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|hook
operator|.
name|service
argument_list|,
name|QString
argument_list|()
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_serviceOwnerChanged
argument_list|(
name|QString
argument_list|,
name|QString
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|signalHooks
operator|.
name|erase
argument_list|(
name|it
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|registerObject
name|void
name|QDBusConnectionPrivate
operator|::
name|registerObject
parameter_list|(
specifier|const
name|ObjectTreeNode
modifier|*
name|node
parameter_list|)
block|{
name|connect
argument_list|(
name|node
operator|->
name|obj
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|objectDestroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
operator|(
name|QDBusConnection
operator|::
name|ExportAdaptors
operator||
name|QDBusConnection
operator|::
name|ExportScriptableSignals
operator||
name|QDBusConnection
operator|::
name|ExportNonScriptableSignals
operator|)
condition|)
block|{
name|QDBusAdaptorConnector
modifier|*
name|connector
init|=
name|qDBusCreateAdaptorConnector
argument_list|(
name|node
operator|->
name|obj
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
operator|(
name|QDBusConnection
operator|::
name|ExportScriptableSignals
operator||
name|QDBusConnection
operator|::
name|ExportNonScriptableSignals
operator|)
condition|)
block|{
name|connector
operator|->
name|disconnectAllSignals
argument_list|(
name|node
operator|->
name|obj
argument_list|)
expr_stmt|;
name|connector
operator|->
name|connectAllSignals
argument_list|(
name|node
operator|->
name|obj
argument_list|)
expr_stmt|;
block|}
comment|// disconnect and reconnect to avoid duplicates
name|connector
operator|->
name|disconnect
argument_list|(
name|SIGNAL
argument_list|(
name|relaySignal
argument_list|(
name|QObject
operator|*
argument_list|,
specifier|const
name|QMetaObject
operator|*
argument_list|,
name|int
argument_list|,
name|QVariantList
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|relaySignal
argument_list|(
name|QObject
operator|*
argument_list|,
specifier|const
name|QMetaObject
operator|*
argument_list|,
name|int
argument_list|,
name|QVariantList
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|connector
argument_list|,
name|SIGNAL
argument_list|(
name|relaySignal
argument_list|(
name|QObject
operator|*
argument_list|,
specifier|const
name|QMetaObject
operator|*
argument_list|,
name|int
argument_list|,
name|QVariantList
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|relaySignal
argument_list|(
name|QObject
operator|*
argument_list|,
specifier|const
name|QMetaObject
operator|*
argument_list|,
name|int
argument_list|,
name|QVariantList
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|unregisterObject
name|void
name|QDBusConnectionPrivate
operator|::
name|unregisterObject
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|QDBusConnection
operator|::
name|UnregisterMode
name|mode
parameter_list|)
block|{
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|*
name|node
init|=
operator|&
name|rootNode
decl_stmt|;
name|QStringList
name|pathComponents
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pathComponents
operator|=
name|path
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
name|huntAndUnregister
argument_list|(
name|pathComponents
argument_list|,
name|i
argument_list|,
name|mode
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|connectRelay
name|void
name|QDBusConnectionPrivate
operator|::
name|connectRelay
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
name|QDBusAbstractInterface
modifier|*
name|receiver
parameter_list|,
specifier|const
name|QMetaMethod
modifier|&
name|signal
parameter_list|)
block|{
comment|// this function is called by QDBusAbstractInterface when one of its signals is connected
comment|// we set up a relay from D-Bus into it
name|SignalHook
name|hook
decl_stmt|;
name|QString
name|key
decl_stmt|;
name|QByteArray
name|sig
decl_stmt|;
name|sig
operator|.
name|append
argument_list|(
name|QSIGNAL_CODE
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|sig
operator|.
name|append
argument_list|(
name|signal
operator|.
name|methodSignature
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prepareHook
argument_list|(
name|hook
argument_list|,
name|key
argument_list|,
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QStringList
argument_list|()
argument_list|,
name|receiver
argument_list|,
name|sig
argument_list|,
name|QDBusAbstractInterface
operator|::
name|staticMetaObject
operator|.
name|methodCount
argument_list|()
argument_list|,
literal|true
argument_list|)
condition|)
return|return;
comment|// don't connect
comment|// add it to our list:
name|QDBusWriteLocker
name|locker
argument_list|(
name|ConnectRelayAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|SignalHookHash
operator|::
name|ConstIterator
name|it
init|=
name|signalHooks
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|SignalHookHash
operator|::
name|ConstIterator
name|end
init|=
name|signalHooks
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|key
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|SignalHook
modifier|&
name|entry
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|service
operator|==
name|hook
operator|.
name|service
operator|&&
name|entry
operator|.
name|path
operator|==
name|hook
operator|.
name|path
operator|&&
name|entry
operator|.
name|signature
operator|==
name|hook
operator|.
name|signature
operator|&&
name|entry
operator|.
name|obj
operator|==
name|hook
operator|.
name|obj
operator|&&
name|entry
operator|.
name|midx
operator|==
name|hook
operator|.
name|midx
condition|)
return|return;
comment|// already there, no need to re-add
block|}
name|connectSignal
argument_list|(
name|key
argument_list|,
name|hook
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|disconnectRelay
name|void
name|QDBusConnectionPrivate
operator|::
name|disconnectRelay
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
name|QDBusAbstractInterface
modifier|*
name|receiver
parameter_list|,
specifier|const
name|QMetaMethod
modifier|&
name|signal
parameter_list|)
block|{
comment|// this function is called by QDBusAbstractInterface when one of its signals is disconnected
comment|// we remove relay from D-Bus into it
name|SignalHook
name|hook
decl_stmt|;
name|QString
name|key
decl_stmt|;
name|QByteArray
name|sig
decl_stmt|;
name|sig
operator|.
name|append
argument_list|(
name|QSIGNAL_CODE
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|sig
operator|.
name|append
argument_list|(
name|signal
operator|.
name|methodSignature
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prepareHook
argument_list|(
name|hook
argument_list|,
name|key
argument_list|,
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QStringList
argument_list|()
argument_list|,
name|receiver
argument_list|,
name|sig
argument_list|,
name|QDBusAbstractInterface
operator|::
name|staticMetaObject
operator|.
name|methodCount
argument_list|()
argument_list|,
literal|true
argument_list|)
condition|)
return|return;
comment|// don't connect
comment|// remove it from our list:
name|QDBusWriteLocker
name|locker
argument_list|(
name|DisconnectRelayAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|SignalHookHash
operator|::
name|Iterator
name|it
init|=
name|signalHooks
operator|.
name|find
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|SignalHookHash
operator|::
name|Iterator
name|end
init|=
name|signalHooks
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|key
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|SignalHook
modifier|&
name|entry
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|service
operator|==
name|hook
operator|.
name|service
operator|&&
name|entry
operator|.
name|path
operator|==
name|hook
operator|.
name|path
operator|&&
name|entry
operator|.
name|signature
operator|==
name|hook
operator|.
name|signature
operator|&&
name|entry
operator|.
name|obj
operator|==
name|hook
operator|.
name|obj
operator|&&
name|entry
operator|.
name|midx
operator|==
name|hook
operator|.
name|midx
condition|)
block|{
comment|// found it
name|disconnectSignal
argument_list|(
name|it
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|qWarning
argument_list|(
literal|"QDBusConnectionPrivate::disconnectRelay called for a signal that was not found"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getNameOwner
name|QString
name|QDBusConnectionPrivate
operator|::
name|getNameOwner
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
if|if
condition|(
name|QDBusUtil
operator|::
name|isValidUniqueConnectionName
argument_list|(
name|serviceName
argument_list|)
condition|)
return|return
name|serviceName
return|;
if|if
condition|(
operator|!
name|connection
condition|)
return|return
name|QString
argument_list|()
return|;
block|{
comment|// acquire a read lock for the cache
name|QReadLocker
name|locker
argument_list|(
operator|&
name|lock
argument_list|)
decl_stmt|;
name|WatchedServicesHash
operator|::
name|ConstIterator
name|it
init|=
name|watchedServices
operator|.
name|constFind
argument_list|(
name|serviceName
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|watchedServices
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|it
operator|->
name|owner
return|;
block|}
comment|// not cached
return|return
name|getNameOwnerNoCache
argument_list|(
name|serviceName
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getNameOwnerNoCache
name|QString
name|QDBusConnectionPrivate
operator|::
name|getNameOwnerNoCache
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
name|QDBusMessage
name|msg
init|=
name|QDBusMessage
operator|::
name|createMethodCall
argument_list|(
name|dbusServiceString
argument_list|()
argument_list|,
name|QLatin1String
argument_list|(
name|DBUS_PATH_DBUS
argument_list|)
argument_list|,
name|dbusInterfaceString
argument_list|()
argument_list|,
name|QLatin1String
argument_list|(
literal|"GetNameOwner"
argument_list|)
argument_list|)
decl_stmt|;
name|QDBusMessagePrivate
operator|::
name|setParametersValidated
argument_list|(
name|msg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|msg
operator|<<
name|serviceName
expr_stmt|;
name|QDBusMessage
name|reply
init|=
name|sendWithReply
argument_list|(
name|msg
argument_list|,
name|QDBus
operator|::
name|Block
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ReplyMessage
condition|)
return|return
name|reply
operator|.
name|arguments
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
name|QDBusMetaObject
modifier|*
DECL|function|findMetaObject
name|QDBusConnectionPrivate
operator|::
name|findMetaObject
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
name|QDBusError
modifier|&
name|error
parameter_list|)
block|{
comment|// service must be a unique connection name
if|if
condition|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QDBusReadLocker
name|locker
argument_list|(
name|FindMetaObject1Action
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|QDBusMetaObject
modifier|*
name|mo
init|=
name|cachedMetaObjects
operator|.
name|value
argument_list|(
name|interface
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mo
condition|)
return|return
name|mo
return|;
block|}
comment|// introspect the target object
name|QDBusMessage
name|msg
init|=
name|QDBusMessage
operator|::
name|createMethodCall
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|QLatin1String
argument_list|(
name|DBUS_INTERFACE_INTROSPECTABLE
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"Introspect"
argument_list|)
argument_list|)
decl_stmt|;
name|QDBusMessagePrivate
operator|::
name|setParametersValidated
argument_list|(
name|msg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QDBusMessage
name|reply
init|=
name|sendWithReply
argument_list|(
name|msg
argument_list|,
name|QDBus
operator|::
name|Block
argument_list|)
decl_stmt|;
comment|// it doesn't exist yet, we have to create it
name|QDBusWriteLocker
name|locker
argument_list|(
name|FindMetaObject2Action
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|QDBusMetaObject
modifier|*
name|mo
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
condition|)
name|mo
operator|=
name|cachedMetaObjects
operator|.
name|value
argument_list|(
name|interface
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mo
condition|)
comment|// maybe it got created when we switched from read to write lock
return|return
name|mo
return|;
name|QString
name|xml
decl_stmt|;
if|if
condition|(
name|reply
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ReplyMessage
condition|)
block|{
if|if
condition|(
name|reply
operator|.
name|signature
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"s"
argument_list|)
condition|)
comment|// fetch the XML description
name|xml
operator|=
name|reply
operator|.
name|arguments
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|QDBusError
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|lastError
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|reply
operator|.
name|type
argument_list|()
operator|!=
name|QDBusMessage
operator|::
name|ErrorMessage
operator|||
name|error
operator|.
name|type
argument_list|()
operator|!=
name|QDBusError
operator|::
name|UnknownMethod
condition|)
return|return
literal|0
return|;
comment|// error
block|}
comment|// release the lock and return
name|QDBusMetaObject
modifier|*
name|result
init|=
name|QDBusMetaObject
operator|::
name|createMetaObject
argument_list|(
name|interface
argument_list|,
name|xml
argument_list|,
name|cachedMetaObjects
argument_list|,
name|error
argument_list|)
decl_stmt|;
name|lastError
operator|=
name|error
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|registerService
name|void
name|QDBusConnectionPrivate
operator|::
name|registerService
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
name|QDBusWriteLocker
name|locker
argument_list|(
name|RegisterServiceAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|registerServiceNoLock
argument_list|(
name|serviceName
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|registerServiceNoLock
name|void
name|QDBusConnectionPrivate
operator|::
name|registerServiceNoLock
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
name|serviceNames
operator|.
name|append
argument_list|(
name|serviceName
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unregisterService
name|void
name|QDBusConnectionPrivate
operator|::
name|unregisterService
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
name|QDBusWriteLocker
name|locker
argument_list|(
name|UnregisterServiceAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|unregisterServiceNoLock
argument_list|(
name|serviceName
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unregisterServiceNoLock
name|void
name|QDBusConnectionPrivate
operator|::
name|unregisterServiceNoLock
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
name|serviceNames
operator|.
name|removeAll
argument_list|(
name|serviceName
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isServiceRegisteredByThread
name|bool
name|QDBusConnectionPrivate
operator|::
name|isServiceRegisteredByThread
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|serviceName
operator|.
name|isEmpty
argument_list|()
operator|&&
name|serviceName
operator|==
name|baseService
condition|)
return|return
literal|true
return|;
name|QStringList
name|copy
init|=
name|serviceNames
decl_stmt|;
return|return
name|copy
operator|.
name|contains
argument_list|(
name|serviceName
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|postEventToThread
name|void
name|QDBusConnectionPrivate
operator|::
name|postEventToThread
parameter_list|(
name|int
name|action
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|,
name|QEvent
modifier|*
name|ev
parameter_list|)
block|{
name|QDBusLockerBase
operator|::
name|reportThreadAction
argument_list|(
name|action
argument_list|,
name|QDBusLockerBase
operator|::
name|BeforePost
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|object
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|QDBusLockerBase
operator|::
name|reportThreadAction
argument_list|(
name|action
argument_list|,
name|QDBusLockerBase
operator|::
name|AfterPost
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DBUS
end_comment
end_unit
