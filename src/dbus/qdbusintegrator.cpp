begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Copyright (C) 2016 Intel Corporation. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtDBus module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdbusintegrator_p.h"
end_include
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<qelapsedtimer.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qmetaobject.h>
end_include
begin_include
include|#
directive|include
file|<qobject.h>
end_include
begin_include
include|#
directive|include
file|<qsocketnotifier.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qtimer.h>
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|"qdbusargument.h"
end_include
begin_include
include|#
directive|include
file|"qdbusconnection_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusconnectionmanager_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusinterface_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmessage.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmetatype.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmetatype_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusabstractadaptor.h"
end_include
begin_include
include|#
directive|include
file|"qdbusabstractadaptor_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusserver.h"
end_include
begin_include
include|#
directive|include
file|"qdbusutil_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusvirtualobject.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmessage_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbuscontext_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbuspendingcall_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusthreaddebug_p.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|interface
end_ifdef
begin_undef
DECL|macro|interface
undef|#
directive|undef
name|interface
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DBUS
end_ifndef
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|// used with dbus_server_allocate_data_slot
DECL|variable|server_slot
specifier|static
name|dbus_int32_t
name|server_slot
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|isDebugging
specifier|static
name|QBasicAtomicInt
name|isDebugging
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|qDBusDebug
define|#
directive|define
name|qDBusDebug
value|if (::isDebugging == 0); else qDebug
end_define
begin_function
DECL|function|operator <<
specifier|static
specifier|inline
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QThread
modifier|*
name|th
parameter_list|)
block|{
name|QDebugStateSaver
name|saver
argument_list|(
name|dbg
argument_list|)
decl_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QThread(ptr="
operator|<<
operator|(
specifier|const
name|void
operator|*
operator|)
name|th
expr_stmt|;
if|if
condition|(
name|th
operator|&&
operator|!
name|th
operator|->
name|objectName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|", name="
operator|<<
name|th
operator|->
name|objectName
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|th
condition|)
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|", name="
operator|<<
name|th
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
expr_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_if
if|#
directive|if
name|QDBUS_THREAD_DEBUG
end_if
begin_function
DECL|function|operator <<
specifier|static
specifier|inline
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QDBusConnectionPrivate
modifier|*
name|conn
parameter_list|)
block|{
name|QDebugStateSaver
name|saver
argument_list|(
name|dbg
argument_list|)
decl_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QDBusConnection("
operator|<<
literal|"ptr="
operator|<<
operator|(
specifier|const
name|void
operator|*
operator|)
name|conn
operator|<<
literal|", name="
operator|<<
name|conn
operator|->
name|name
operator|<<
literal|", baseService="
operator|<<
name|conn
operator|->
name|baseService
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_function
DECL|function|qdbusDefaultThreadDebug
name|void
name|qdbusDefaultThreadDebug
parameter_list|(
name|int
name|action
parameter_list|,
name|int
name|condition
parameter_list|,
name|QDBusConnectionPrivate
modifier|*
name|conn
parameter_list|)
block|{
name|qDBusDebug
argument_list|()
operator|<<
name|QThread
operator|::
name|currentThread
argument_list|()
operator|<<
literal|"Qt D-Bus threading action"
operator|<<
name|action
operator|<<
operator|(
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|BeforeLock
condition|?
literal|"before lock"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|AfterLock
condition|?
literal|"after lock"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|BeforeUnlock
condition|?
literal|"before unlock"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|AfterUnlock
condition|?
literal|"after unlock"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|BeforePost
condition|?
literal|"before event posting"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|AfterPost
condition|?
literal|"after event posting"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|BeforeDeliver
condition|?
literal|"before event delivery"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|AfterDeliver
condition|?
literal|"after event delivery"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|BeforeAcquire
condition|?
literal|"before acquire"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|AfterAcquire
condition|?
literal|"after acquire"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|BeforeRelease
condition|?
literal|"before release"
else|:
name|condition
operator|==
name|QDBusLockerBase
operator|::
name|AfterRelease
condition|?
literal|"after release"
else|:
literal|"condition unknown"
operator|)
operator|<<
literal|"in connection"
operator|<<
name|conn
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|qdbusThreadDebug
name|qdbusThreadDebugFunc
name|qdbusThreadDebug
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|QDBusSpyHookList
typedef|typedef
name|QVarLengthArray
argument_list|<
name|QDBusSpyCallEvent
operator|::
name|Hook
argument_list|,
literal|4
argument_list|>
name|QDBusSpyHookList
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QDBusSpyHookList
argument_list|,
argument|qDBusSpyHookList
argument_list|)
end_macro
begin_extern
extern|extern
literal|"C"
block|{
comment|// libdbus-1 callbacks
DECL|function|qDBusAddTimeout
specifier|static
name|dbus_bool_t
name|qDBusAddTimeout
parameter_list|(
name|DBusTimeout
modifier|*
name|timeout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|//  qDebug("addTimeout %d", q_dbus_timeout_get_interval(timeout));
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|d
operator|->
name|thread
argument_list|()
argument_list|)
expr_stmt|;
comment|// we may get called from qDBusToggleTimeout
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
operator|!
name|q_dbus_timeout_get_enabled
argument_list|(
name|timeout
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
name|QDBusDispatchLocker
name|locker
argument_list|(
name|AddTimeoutAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|timeouts
operator|.
name|key
argument_list|(
name|timeout
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|int
name|timerId
init|=
name|d
operator|->
name|startTimer
argument_list|(
name|q_dbus_timeout_get_interval
argument_list|(
name|timeout
argument_list|)
argument_list|)
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
name|timerId
argument_list|,
literal|"QDBusConnection"
argument_list|,
literal|"Failed to start a timer"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|timerId
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|timeouts
index|[
name|timerId
index|]
operator|=
name|timeout
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|qDBusRemoveTimeout
specifier|static
name|void
name|qDBusRemoveTimeout
parameter_list|(
name|DBusTimeout
modifier|*
name|timeout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|//  qDebug("removeTimeout");
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|d
operator|->
name|thread
argument_list|()
argument_list|)
expr_stmt|;
name|QDBusDispatchLocker
name|locker
argument_list|(
name|RemoveTimeoutAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|TimeoutHash
operator|::
name|iterator
name|it
init|=
name|d
operator|->
name|timeouts
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|timeouts
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|==
name|timeout
condition|)
block|{
name|d
operator|->
name|killTimer
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
name|it
operator|=
name|d
operator|->
name|timeouts
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|++
name|it
expr_stmt|;
block|}
block|}
block|}
DECL|function|qDBusToggleTimeout
specifier|static
name|void
name|qDBusToggleTimeout
parameter_list|(
name|DBusTimeout
modifier|*
name|timeout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|//qDebug("ToggleTimeout");
name|qDBusRemoveTimeout
argument_list|(
name|timeout
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|qDBusAddTimeout
argument_list|(
name|timeout
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
DECL|function|qDBusAddWatch
specifier|static
name|dbus_bool_t
name|qDBusAddWatch
parameter_list|(
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|watch
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|d
operator|->
name|thread
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|flags
init|=
name|q_dbus_watch_get_flags
argument_list|(
name|watch
argument_list|)
decl_stmt|;
name|int
name|fd
init|=
name|q_dbus_watch_get_unix_fd
argument_list|(
name|watch
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|Watcher
name|watcher
decl_stmt|;
name|QDBusDispatchLocker
name|locker
argument_list|(
name|AddWatchAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_READABLE
condition|)
block|{
comment|//qDebug("addReadWatch %d", fd);
name|watcher
operator|.
name|watch
operator|=
name|watch
expr_stmt|;
name|watcher
operator|.
name|read
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|fd
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|watcher
operator|.
name|read
operator|->
name|setEnabled
argument_list|(
name|q_dbus_watch_get_enabled
argument_list|(
name|watch
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|connect
argument_list|(
name|watcher
operator|.
name|read
argument_list|,
operator|&
name|QSocketNotifier
operator|::
name|activated
argument_list|,
name|d
argument_list|,
operator|&
name|QDBusConnectionPrivate
operator|::
name|socketRead
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_WRITABLE
condition|)
block|{
comment|//qDebug("addWriteWatch %d", fd);
name|watcher
operator|.
name|watch
operator|=
name|watch
expr_stmt|;
name|watcher
operator|.
name|write
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|fd
argument_list|,
name|QSocketNotifier
operator|::
name|Write
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|watcher
operator|.
name|write
operator|->
name|setEnabled
argument_list|(
name|q_dbus_watch_get_enabled
argument_list|(
name|watch
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|connect
argument_list|(
name|watcher
operator|.
name|write
argument_list|,
operator|&
name|QSocketNotifier
operator|::
name|activated
argument_list|,
name|d
argument_list|,
operator|&
name|QDBusConnectionPrivate
operator|::
name|socketWrite
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|watchers
operator|.
name|insertMulti
argument_list|(
name|fd
argument_list|,
name|watcher
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|qDBusRemoveWatch
specifier|static
name|void
name|qDBusRemoveWatch
parameter_list|(
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|watch
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|//qDebug("remove watch");
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|d
operator|->
name|thread
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|fd
init|=
name|q_dbus_watch_get_unix_fd
argument_list|(
name|watch
argument_list|)
decl_stmt|;
name|QDBusDispatchLocker
name|locker
argument_list|(
name|RemoveWatchAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|WatcherHash
operator|::
name|iterator
name|i
init|=
name|d
operator|->
name|watchers
operator|.
name|find
argument_list|(
name|fd
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|d
operator|->
name|watchers
operator|.
name|end
argument_list|()
operator|&&
name|i
operator|.
name|key
argument_list|()
operator|==
name|fd
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|.
name|watch
operator|==
name|watch
condition|)
block|{
operator|delete
name|i
operator|.
name|value
argument_list|()
operator|.
name|read
expr_stmt|;
operator|delete
name|i
operator|.
name|value
argument_list|()
operator|.
name|write
expr_stmt|;
name|i
operator|=
name|d
operator|->
name|watchers
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
DECL|function|qDBusToggleWatch
specifier|static
name|void
name|qDBusToggleWatch
parameter_list|(
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|watch
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|d
operator|->
name|thread
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|fd
init|=
name|q_dbus_watch_get_unix_fd
argument_list|(
name|watch
argument_list|)
decl_stmt|;
name|QDBusDispatchLocker
name|locker
argument_list|(
name|ToggleWatchAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|WatcherHash
operator|::
name|iterator
name|i
init|=
name|d
operator|->
name|watchers
operator|.
name|find
argument_list|(
name|fd
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|d
operator|->
name|watchers
operator|.
name|end
argument_list|()
operator|&&
name|i
operator|.
name|key
argument_list|()
operator|==
name|fd
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|.
name|watch
operator|==
name|watch
condition|)
block|{
name|bool
name|enabled
init|=
name|q_dbus_watch_get_enabled
argument_list|(
name|watch
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|q_dbus_watch_get_flags
argument_list|(
name|watch
argument_list|)
decl_stmt|;
comment|//qDebug("toggle watch %d to %d (write: %d, read: %d)", q_dbus_watch_get_fd(watch), enabled, flags& DBUS_WATCH_WRITABLE, flags& DBUS_WATCH_READABLE);
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_READABLE
operator|&&
name|i
operator|.
name|value
argument_list|()
operator|.
name|read
condition|)
name|i
operator|.
name|value
argument_list|()
operator|.
name|read
operator|->
name|setEnabled
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_WRITABLE
operator|&&
name|i
operator|.
name|value
argument_list|()
operator|.
name|write
condition|)
name|i
operator|.
name|value
argument_list|()
operator|.
name|write
operator|->
name|setEnabled
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|i
expr_stmt|;
block|}
block|}
DECL|function|qDBusUpdateDispatchStatus
specifier|static
name|void
name|qDBusUpdateDispatchStatus
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|DBusDispatchStatus
name|new_status
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_status
operator|==
name|DBUS_DISPATCH_DATA_REMAINS
condition|)
emit|emit
name|d
operator|->
name|dispatchStatusChanged
argument_list|()
emit|;
block|}
DECL|function|qDBusNewConnection
specifier|static
name|void
name|qDBusNewConnection
parameter_list|(
name|DBusServer
modifier|*
name|server
parameter_list|,
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
comment|// ### We may want to separate the server from the QDBusConnectionPrivate
name|Q_ASSERT
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|// keep the connection alive
name|q_dbus_connection_ref
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|serverConnection
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
comment|// allow anonymous authentication
if|if
condition|(
name|serverConnection
operator|->
name|anonymousAuthenticationAllowed
condition|)
name|q_dbus_connection_set_allow_anonymous
argument_list|(
name|connection
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|newConnection
init|=
operator|new
name|QDBusConnectionPrivate
argument_list|(
name|serverConnection
operator|->
name|parent
argument_list|()
argument_list|)
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|QDBusConnectionManager
operator|::
name|instance
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|QDBusConnectionManager
operator|::
name|instance
argument_list|()
operator|->
name|setConnection
argument_list|(
name|QLatin1String
argument_list|(
literal|"QDBusServer-"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
cast|reinterpret_cast
argument_list|<
name|qulonglong
argument_list|>
argument_list|(
name|newConnection
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|,
name|newConnection
argument_list|)
expr_stmt|;
name|serverConnection
operator|->
name|serverConnectionNames
operator|<<
name|newConnection
operator|->
name|name
expr_stmt|;
comment|// setPeer does the error handling for us
name|QDBusErrorInternal
name|error
decl_stmt|;
name|newConnection
operator|->
name|setPeer
argument_list|(
name|connection
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|// this is a queued connection and will resume in the QDBusServer's thread
emit|emit
name|serverConnection
operator|->
name|newServerConnection
argument_list|(
name|newConnection
argument_list|)
emit|;
block|}
DECL|function|_q_newConnection
name|void
name|QDBusConnectionPrivate
operator|::
name|_q_newConnection
parameter_list|(
name|QDBusConnectionPrivate
modifier|*
name|newConnection
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|mode
operator|==
name|ServerMode
argument_list|)
expr_stmt|;
emit|emit
name|serverObject
operator|->
name|newConnection
argument_list|(
name|QDBusConnectionPrivate
operator|::
name|q
argument_list|(
name|newConnection
argument_list|)
argument_list|)
emit|;
block|}
block|}
end_extern
begin_comment
comment|// extern "C"
end_comment
begin_function
DECL|function|buildMatchRule
specifier|static
name|QByteArray
name|buildMatchRule
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|objectPath
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|member
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|argMatch
parameter_list|,
specifier|const
name|QString
modifier|&
comment|/*signature*/
parameter_list|)
block|{
name|QString
name|result
init|=
name|QLatin1String
argument_list|(
literal|"type='signal',"
argument_list|)
decl_stmt|;
name|QString
name|keyValue
init|=
name|QLatin1String
argument_list|(
literal|"%1='%2',"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|service
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|+=
name|keyValue
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
literal|"sender"
argument_list|)
argument_list|,
name|service
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|objectPath
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|+=
name|keyValue
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
literal|"path"
argument_list|)
argument_list|,
name|objectPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|+=
name|keyValue
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
literal|"interface"
argument_list|)
argument_list|,
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|member
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|+=
name|keyValue
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
literal|"member"
argument_list|)
argument_list|,
name|member
argument_list|)
expr_stmt|;
comment|// add the argument string-matching now
if|if
condition|(
operator|!
name|argMatch
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|keyValue
operator|=
name|QLatin1String
argument_list|(
literal|"arg%1='%2',"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argMatch
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|argMatch
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isNull
argument_list|()
condition|)
name|result
operator|+=
name|keyValue
operator|.
name|arg
argument_list|(
name|i
argument_list|)
operator|.
name|arg
argument_list|(
name|argMatch
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// remove ending comma
return|return
name|result
operator|.
name|toLatin1
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|findObject
specifier|static
name|bool
name|findObject
parameter_list|(
specifier|const
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|*
name|root
parameter_list|,
specifier|const
name|QString
modifier|&
name|fullpath
parameter_list|,
name|int
modifier|&
name|usedLength
parameter_list|,
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|&
name|result
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fullpath
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
argument_list|)
operator|&&
name|root
operator|->
name|obj
condition|)
block|{
name|usedLength
operator|=
literal|1
expr_stmt|;
name|result
operator|=
operator|*
name|root
expr_stmt|;
return|return
name|root
return|;
block|}
name|int
name|start
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
name|fullpath
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|fullpath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
name|start
operator|=
literal|1
expr_stmt|;
comment|// walk the object tree
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|ConstIterator
name|node
init|=
name|root
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|length
operator|&&
name|node
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportChildObjects
condition|)
break|break;
if|if
condition|(
operator|(
name|node
operator|->
name|flags
operator|&
name|QDBusConnectionPrivate
operator|::
name|VirtualObject
operator|)
operator|&&
operator|(
name|node
operator|->
name|flags
operator|&
name|QDBusConnection
operator|::
name|SubPath
operator|)
condition|)
break|break;
name|int
name|end
init|=
name|fullpath
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|start
argument_list|)
decl_stmt|;
name|end
operator|=
operator|(
name|end
operator|==
operator|-
literal|1
condition|?
name|length
else|:
name|end
operator|)
expr_stmt|;
name|QStringRef
name|pathComponent
argument_list|(
operator|&
name|fullpath
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|ConstIterator
name|it
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|node
operator|->
name|children
operator|.
name|constBegin
argument_list|()
argument_list|,
name|node
operator|->
name|children
operator|.
name|constEnd
argument_list|()
argument_list|,
name|pathComponent
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|node
operator|->
name|children
operator|.
name|constEnd
argument_list|()
operator|&&
name|it
operator|->
name|name
operator|==
name|pathComponent
condition|)
comment|// match
name|node
operator|=
name|it
expr_stmt|;
else|else
name|node
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|end
operator|+
literal|1
expr_stmt|;
block|}
comment|// found our object
name|usedLength
operator|=
operator|(
name|start
operator|>
name|length
condition|?
name|length
else|:
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|obj
operator|||
operator|!
name|node
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|=
operator|*
name|node
expr_stmt|;
else|else
comment|// there really is no object here
comment|// we're just looking at an unused space in the QVector
name|node
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function
begin_function
DECL|function|findChildObject
specifier|static
name|QObject
modifier|*
name|findChildObject
parameter_list|(
specifier|const
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|*
name|root
parameter_list|,
specifier|const
name|QString
modifier|&
name|fullpath
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|length
init|=
name|fullpath
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// any object in the tree can tell us to switch to its own object tree:
specifier|const
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|*
name|node
init|=
name|root
decl_stmt|;
if|if
condition|(
name|node
operator|&&
name|node
operator|->
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportChildObjects
condition|)
block|{
name|QObject
modifier|*
name|obj
init|=
name|node
operator|->
name|obj
decl_stmt|;
while|while
condition|(
name|obj
condition|)
block|{
if|if
condition|(
name|start
operator|>=
name|length
condition|)
comment|// we're at the correct level
return|return
name|obj
return|;
name|int
name|pos
init|=
name|fullpath
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|start
argument_list|)
decl_stmt|;
name|pos
operator|=
operator|(
name|pos
operator|==
operator|-
literal|1
condition|?
name|length
else|:
name|pos
operator|)
expr_stmt|;
name|QStringRef
name|pathComponent
argument_list|(
operator|&
name|fullpath
argument_list|,
name|start
argument_list|,
name|pos
operator|-
name|start
argument_list|)
decl_stmt|;
specifier|const
name|QObjectList
name|children
init|=
name|obj
operator|->
name|children
argument_list|()
decl_stmt|;
comment|// find a child with the proper name
name|QObject
modifier|*
name|next
init|=
literal|0
decl_stmt|;
name|QObjectList
operator|::
name|ConstIterator
name|it
init|=
name|children
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QObjectList
operator|::
name|ConstIterator
name|end
init|=
name|children
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|->
name|objectName
argument_list|()
operator|==
name|pathComponent
condition|)
block|{
name|next
operator|=
operator|*
name|it
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|next
condition|)
break|break;
name|obj
operator|=
name|next
expr_stmt|;
name|start
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|// object not found
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|matchArgsForService
specifier|static
name|QStringList
name|matchArgsForService
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
name|QDBusServiceWatcher
operator|::
name|WatchMode
name|mode
parameter_list|)
block|{
name|QStringList
name|matchArgs
decl_stmt|;
name|matchArgs
operator|<<
name|service
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QDBusServiceWatcher
operator|::
name|WatchForOwnerChange
case|:
break|break;
case|case
name|QDBusServiceWatcher
operator|::
name|WatchForRegistration
case|:
name|matchArgs
operator|<<
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDBusServiceWatcher
operator|::
name|WatchForUnregistration
case|:
name|matchArgs
operator|<<
name|QString
argument_list|()
operator|<<
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|matchArgs
return|;
block|}
end_function
begin_function_decl
specifier|extern
name|Q_DBUS_EXPORT
name|void
name|qDBusAddSpyHook
parameter_list|(
name|QDBusSpyCallEvent
operator|::
name|Hook
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|qDBusAddSpyHook
name|void
name|qDBusAddSpyHook
parameter_list|(
name|QDBusSpyCallEvent
operator|::
name|Hook
name|hook
parameter_list|)
block|{
name|qDBusSpyHookList
argument_list|()
operator|->
name|append
argument_list|(
name|hook
argument_list|)
expr_stmt|;
block|}
end_function
begin_destructor
DECL|function|~QDBusSpyCallEvent
name|QDBusSpyCallEvent
operator|::
name|~
name|QDBusSpyCallEvent
parameter_list|()
block|{
comment|// Reinsert the message into the processing queue for the connection.
comment|// This is done in the destructor so the message is reinserted even if
comment|// QCoreApplication is destroyed.
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|qDBusDebug
argument_list|()
operator|<<
name|d
operator|<<
literal|"message spies done for"
operator|<<
name|msg
expr_stmt|;
emit|emit
name|d
operator|->
name|spyHooksFinished
argument_list|(
name|msg
argument_list|)
emit|;
block|}
end_destructor
begin_function
DECL|function|placeMetaCall
name|void
name|QDBusSpyCallEvent
operator|::
name|placeMetaCall
parameter_list|(
name|QObject
modifier|*
parameter_list|)
block|{
name|invokeSpyHooks
argument_list|(
name|msg
argument_list|,
name|hooks
argument_list|,
name|hookCount
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|invokeSpyHooks
specifier|inline
name|void
name|QDBusSpyCallEvent
operator|::
name|invokeSpyHooks
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|,
specifier|const
name|Hook
modifier|*
name|hooks
parameter_list|,
name|int
name|hookCount
parameter_list|)
block|{
comment|// call the spy hook list
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hookCount
condition|;
operator|++
name|i
control|)
name|hooks
index|[
name|i
index|]
operator|(
name|msg
operator|)
expr_stmt|;
block|}
end_function
begin_extern
extern|extern
literal|"C"
block|{
specifier|static
name|DBusHandlerResult
DECL|function|qDBusSignalFilter
name|qDBusSignalFilter
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|QDBusConnectionPrivate
operator|::
name|InvalidMode
condition|)
return|return
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
name|QDBusMessage
name|amsg
init|=
name|QDBusMessagePrivate
operator|::
name|fromDBusMessage
argument_list|(
name|message
argument_list|,
name|d
operator|->
name|capabilities
argument_list|)
decl_stmt|;
name|qDBusDebug
argument_list|()
operator|<<
name|d
operator|<<
literal|"got message (signal):"
operator|<<
name|amsg
expr_stmt|;
return|return
name|d
operator|->
name|handleMessage
argument_list|(
name|amsg
argument_list|)
condition|?
name|DBUS_HANDLER_RESULT_HANDLED
else|:
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
block|}
block|}
end_extern
begin_function
DECL|function|handleMessage
name|bool
name|QDBusConnectionPrivate
operator|::
name|handleMessage
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|amsg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ref
operator|.
name|load
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// local message are always delivered, regardless of filtering
comment|// or whether the dispatcher is enabled
name|bool
name|isLocal
init|=
name|QDBusMessagePrivate
operator|::
name|isLocal
argument_list|(
name|amsg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dispatchEnabled
operator|&&
operator|!
name|isLocal
condition|)
block|{
comment|// queue messages only, we'll handle them later
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"delivery is suspended"
expr_stmt|;
name|pendingMessages
operator|<<
name|amsg
expr_stmt|;
return|return
name|amsg
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|MethodCallMessage
return|;
block|}
switch|switch
condition|(
name|amsg
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|QDBusMessage
operator|::
name|SignalMessage
case|:
name|handleSignal
argument_list|(
name|amsg
argument_list|)
expr_stmt|;
comment|// if there are any other filters in this DBusConnection,
comment|// let them see the signal too
return|return
literal|false
return|;
case|case
name|QDBusMessage
operator|::
name|MethodCallMessage
case|:
comment|// run it through the spy filters (if any) before the regular processing:
comment|// a) if it's a local message, we're in the caller's thread, so invoke the filter directly
comment|// b) if it's an external message, post to the main thread
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|qDBusSpyHookList
operator|.
name|exists
argument_list|()
argument_list|)
operator|&&
name|qApp
condition|)
block|{
specifier|const
name|QDBusSpyHookList
modifier|&
name|list
init|=
operator|*
name|qDBusSpyHookList
decl_stmt|;
if|if
condition|(
name|isLocal
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|!=
name|thread
argument_list|()
argument_list|)
expr_stmt|;
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"invoking message spies directly"
expr_stmt|;
name|QDBusSpyCallEvent
operator|::
name|invokeSpyHooks
argument_list|(
name|amsg
argument_list|,
name|list
operator|.
name|constData
argument_list|()
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"invoking message spies via event"
expr_stmt|;
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|qApp
argument_list|,
operator|new
name|QDBusSpyCallEvent
argument_list|(
name|this
argument_list|,
name|QDBusConnection
argument_list|(
name|this
argument_list|)
argument_list|,
name|amsg
argument_list|,
name|list
operator|.
name|constData
argument_list|()
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// we'll be called back, so return
return|return
literal|true
return|;
block|}
block|}
name|handleObjectCall
argument_list|(
name|amsg
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|QDBusMessage
operator|::
name|ReplyMessage
case|:
case|case
name|QDBusMessage
operator|::
name|ErrorMessage
case|:
case|case
name|QDBusMessage
operator|::
name|InvalidMessage
case|:
return|return
literal|false
return|;
comment|// we don't handle those here
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|huntAndDestroy
specifier|static
name|void
name|huntAndDestroy
parameter_list|(
name|QObject
modifier|*
name|needle
parameter_list|,
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|&
name|haystack
parameter_list|)
block|{
for|for
control|(
name|auto
operator|&
name|node
operator|:
name|haystack
operator|.
name|children
control|)
name|huntAndDestroy
argument_list|(
name|needle
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|auto
name|isInactive
init|=
capture|[]
parameter_list|(
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|&
name|node
parameter_list|)
block|{
return|return
operator|!
name|node
operator|.
name|isActive
argument_list|()
return|;
block|}
decl_stmt|;
name|haystack
operator|.
name|children
operator|.
name|erase
argument_list|(
name|std
operator|::
name|remove_if
argument_list|(
name|haystack
operator|.
name|children
operator|.
name|begin
argument_list|()
argument_list|,
name|haystack
operator|.
name|children
operator|.
name|end
argument_list|()
argument_list|,
name|isInactive
argument_list|)
argument_list|,
name|haystack
operator|.
name|children
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|needle
operator|==
name|haystack
operator|.
name|obj
condition|)
block|{
name|haystack
operator|.
name|obj
operator|=
literal|0
expr_stmt|;
name|haystack
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|huntAndUnregister
specifier|static
name|void
name|huntAndUnregister
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|QStringRef
argument_list|>
modifier|&
name|pathComponents
parameter_list|,
name|int
name|i
parameter_list|,
name|QDBusConnection
operator|::
name|UnregisterMode
name|mode
parameter_list|,
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|pathComponents
operator|.
name|count
argument_list|()
operator|==
name|i
condition|)
block|{
comment|// found it
name|node
operator|->
name|obj
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|QDBusConnection
operator|::
name|UnregisterTree
condition|)
block|{
comment|// clear the sub-tree as well
name|node
operator|->
name|children
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// can't disconnect the objects because we really don't know if they can
comment|// be found somewhere else in the path too
block|}
block|}
else|else
block|{
comment|// keep going
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|end
init|=
name|node
operator|->
name|children
operator|.
name|end
argument_list|()
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|it
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|node
operator|->
name|children
operator|.
name|begin
argument_list|()
argument_list|,
name|end
argument_list|,
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|end
operator|||
name|it
operator|->
name|name
operator|!=
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
return|return;
comment|// node not found
name|huntAndUnregister
argument_list|(
name|pathComponents
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|mode
argument_list|,
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|it
operator|->
name|isActive
argument_list|()
condition|)
name|node
operator|->
name|children
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|huntAndEmit
specifier|static
name|void
name|huntAndEmit
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|DBusMessage
modifier|*
name|msg
parameter_list|,
name|QObject
modifier|*
name|needle
parameter_list|,
specifier|const
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|&
name|haystack
parameter_list|,
name|bool
name|isScriptable
parameter_list|,
name|bool
name|isAdaptor
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
init|=
name|QString
argument_list|()
parameter_list|)
block|{
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|ConstIterator
name|it
init|=
name|haystack
operator|.
name|children
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|ConstIterator
name|end
init|=
name|haystack
operator|.
name|children
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|it
operator|->
name|isActive
argument_list|()
condition|)
name|huntAndEmit
argument_list|(
name|connection
argument_list|,
name|msg
argument_list|,
name|needle
argument_list|,
operator|*
name|it
argument_list|,
name|isScriptable
argument_list|,
name|isAdaptor
argument_list|,
name|path
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|it
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needle
operator|==
name|haystack
operator|.
name|obj
condition|)
block|{
comment|// is this a signal we should relay?
if|if
condition|(
name|isAdaptor
operator|&&
operator|(
name|haystack
operator|.
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportAdaptors
operator|)
operator|==
literal|0
condition|)
return|return;
comment|// no: it comes from an adaptor and we're not exporting adaptors
elseif|else
if|if
condition|(
operator|!
name|isAdaptor
condition|)
block|{
name|int
name|mask
init|=
name|isScriptable
condition|?
name|QDBusConnection
operator|::
name|ExportScriptableSignals
else|:
name|QDBusConnection
operator|::
name|ExportNonScriptableSignals
decl_stmt|;
if|if
condition|(
operator|(
name|haystack
operator|.
name|flags
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
return|return;
comment|// signal was not exported
block|}
name|QByteArray
name|p
init|=
name|path
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|isEmpty
argument_list|()
condition|)
name|p
operator|=
literal|"/"
expr_stmt|;
name|qDBusDebug
argument_list|()
operator|<<
name|QThread
operator|::
name|currentThread
argument_list|()
operator|<<
literal|"emitting signal at"
operator|<<
name|p
expr_stmt|;
name|DBusMessage
modifier|*
name|msg2
init|=
name|q_dbus_message_copy
argument_list|(
name|msg
argument_list|)
decl_stmt|;
name|q_dbus_message_set_path
argument_list|(
name|msg2
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|q_dbus_connection_send
argument_list|(
name|connection
argument_list|,
name|msg2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_dbus_message_unref
argument_list|(
name|msg2
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|findSlot
specifier|static
name|int
name|findSlot
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|mo
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature_
parameter_list|,
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|metaTypes
parameter_list|)
block|{
name|QByteArray
name|msgSignature
init|=
name|signature_
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
name|mo
operator|->
name|methodCount
argument_list|()
operator|-
literal|1
init|;
name|idx
operator|>=
name|QObject
operator|::
name|staticMetaObject
operator|.
name|methodCount
argument_list|()
condition|;
operator|--
name|idx
control|)
block|{
name|QMetaMethod
name|mm
init|=
name|mo
operator|->
name|method
argument_list|(
name|idx
argument_list|)
decl_stmt|;
comment|// check access:
if|if
condition|(
name|mm
operator|.
name|access
argument_list|()
operator|!=
name|QMetaMethod
operator|::
name|Public
condition|)
continue|continue;
comment|// check type:
if|if
condition|(
name|mm
operator|.
name|methodType
argument_list|()
operator|!=
name|QMetaMethod
operator|::
name|Slot
operator|&&
name|mm
operator|.
name|methodType
argument_list|()
operator|!=
name|QMetaMethod
operator|::
name|Method
condition|)
continue|continue;
comment|// check name:
if|if
condition|(
name|mm
operator|.
name|name
argument_list|()
operator|!=
name|name
condition|)
continue|continue;
name|int
name|returnType
init|=
name|mm
operator|.
name|returnType
argument_list|()
decl_stmt|;
name|bool
name|isAsync
init|=
name|qDBusCheckAsyncTag
argument_list|(
name|mm
operator|.
name|tag
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|isScriptable
init|=
name|mm
operator|.
name|attributes
argument_list|()
operator|&
name|QMetaMethod
operator|::
name|Scriptable
decl_stmt|;
comment|// consistency check:
if|if
condition|(
name|isAsync
operator|&&
name|returnType
operator|!=
name|QMetaType
operator|::
name|Void
condition|)
continue|continue;
name|QString
name|errorMsg
decl_stmt|;
name|int
name|inputCount
init|=
name|qDBusParametersForMethod
argument_list|(
name|mm
argument_list|,
name|metaTypes
argument_list|,
name|errorMsg
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputCount
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|// problem parsing
name|metaTypes
index|[
literal|0
index|]
operator|=
name|returnType
expr_stmt|;
name|bool
name|hasMessage
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|inputCount
operator|>
literal|0
operator|&&
name|metaTypes
operator|.
name|at
argument_list|(
name|inputCount
argument_list|)
operator|==
name|QDBusMetaTypeId
operator|::
name|message
argument_list|()
condition|)
block|{
comment|// "no input parameters" is allowed as long as the message meta type is there
name|hasMessage
operator|=
literal|true
expr_stmt|;
operator|--
name|inputCount
expr_stmt|;
block|}
comment|// try to match the parameters
name|int
name|i
decl_stmt|;
name|QByteArray
name|reconstructedSignature
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|inputCount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|typeSignature
init|=
name|QDBusMetaType
operator|::
name|typeToSignature
argument_list|(
name|metaTypes
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|typeSignature
condition|)
break|break;
comment|// invalid
name|reconstructedSignature
operator|+=
name|typeSignature
expr_stmt|;
if|if
condition|(
operator|!
name|msgSignature
operator|.
name|startsWith
argument_list|(
name|reconstructedSignature
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|reconstructedSignature
operator|!=
name|msgSignature
condition|)
continue|continue;
comment|// we didn't match them all
if|if
condition|(
name|hasMessage
condition|)
operator|++
name|i
expr_stmt|;
comment|// make sure that the output parameters have signatures too
if|if
condition|(
name|returnType
operator|!=
name|QMetaType
operator|::
name|UnknownType
operator|&&
name|returnType
operator|!=
name|QMetaType
operator|::
name|Void
operator|&&
name|QDBusMetaType
operator|::
name|typeToSignature
argument_list|(
name|returnType
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|ok
operator|&&
name|j
operator|<
name|metaTypes
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|QDBusMetaType
operator|::
name|typeToSignature
argument_list|(
name|metaTypes
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|ok
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
comment|// consistency check:
if|if
condition|(
name|isAsync
operator|&&
name|metaTypes
operator|.
name|count
argument_list|()
operator|>
name|i
operator|+
literal|1
condition|)
continue|continue;
if|if
condition|(
name|mm
operator|.
name|methodType
argument_list|()
operator|==
name|QMetaMethod
operator|::
name|Slot
condition|)
block|{
if|if
condition|(
name|isScriptable
operator|&&
operator|(
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportScriptableSlots
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|// scriptable slots not exported
if|if
condition|(
operator|!
name|isScriptable
operator|&&
operator|(
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportNonScriptableSlots
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|// non-scriptable slots not exported
block|}
else|else
block|{
if|if
condition|(
name|isScriptable
operator|&&
operator|(
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportScriptableInvokables
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|// scriptable invokables not exported
if|if
condition|(
operator|!
name|isScriptable
operator|&&
operator|(
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportNonScriptableInvokables
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|// non-scriptable invokables not exported
block|}
comment|// if we got here, this slot matched
return|return
name|idx
return|;
block|}
comment|// no slot matched
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Enables or disables the delivery of incoming method calls and signals. If     \a enable is true, this will also cause any queued, pending messages to be     delivered.  */
end_comment
begin_function
DECL|function|setDispatchEnabled
name|void
name|QDBusConnectionPrivate
operator|::
name|setDispatchEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|QDBusDispatchLocker
name|locker
argument_list|(
name|SetDispatchEnabledAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|dispatchEnabled
operator|=
name|enable
expr_stmt|;
if|if
condition|(
name|enable
condition|)
emit|emit
name|dispatchStatusChanged
argument_list|()
emit|;
block|}
end_function
begin_decl_stmt
DECL|variable|DIRECT_DELIVERY
specifier|static
name|QDBusCallDeliveryEvent
modifier|*
specifier|const
name|DIRECT_DELIVERY
init|=
operator|(
name|QDBusCallDeliveryEvent
operator|*
operator|)
literal|1
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|prepareReply
name|QDBusCallDeliveryEvent
modifier|*
name|QDBusConnectionPrivate
operator|::
name|prepareReply
parameter_list|(
name|QDBusConnectionPrivate
modifier|*
name|target
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|,
name|int
name|idx
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|metaTypes
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|int
name|n
init|=
name|metaTypes
operator|.
name|count
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|metaTypes
index|[
name|n
index|]
operator|==
name|QDBusMetaTypeId
operator|::
name|message
argument_list|()
condition|)
operator|--
name|n
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|arguments
argument_list|()
operator|.
name|count
argument_list|()
operator|<
name|n
condition|)
return|return
literal|0
return|;
comment|// too few arguments
comment|// check that types match
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|metaTypes
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|!=
name|msg
operator|.
name|arguments
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|userType
argument_list|()
operator|&&
name|msg
operator|.
name|arguments
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|userType
argument_list|()
operator|!=
name|qMetaTypeId
argument_list|<
name|QDBusArgument
argument_list|>
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// no match
comment|// we can deliver
comment|// prepare for the call
if|if
condition|(
name|target
operator|==
name|object
condition|)
return|return
name|DIRECT_DELIVERY
return|;
return|return
operator|new
name|QDBusCallDeliveryEvent
argument_list|(
name|QDBusConnection
argument_list|(
name|target
argument_list|)
argument_list|,
name|idx
argument_list|,
name|target
argument_list|,
name|msg
argument_list|,
name|metaTypes
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|activateSignal
name|void
name|QDBusConnectionPrivate
operator|::
name|activateSignal
parameter_list|(
specifier|const
name|QDBusConnectionPrivate
operator|::
name|SignalHook
modifier|&
name|hook
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
comment|// This is called by QDBusConnectionPrivate::handleSignal to deliver a signal
comment|// that was received from D-Bus
comment|//
comment|// Signals are delivered to slots if the parameters match
comment|// Slots can have less parameters than there are on the message
comment|// Slots can optionally have one final parameter that is a QDBusMessage
comment|// Slots receive read-only copies of the message (i.e., pass by value or by const-ref)
name|QDBusCallDeliveryEvent
modifier|*
name|call
init|=
name|prepareReply
argument_list|(
name|this
argument_list|,
name|hook
operator|.
name|obj
argument_list|,
name|hook
operator|.
name|midx
argument_list|,
name|hook
operator|.
name|params
argument_list|,
name|msg
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|==
name|DIRECT_DELIVERY
condition|)
block|{
comment|// short-circuit delivery
name|Q_ASSERT
argument_list|(
name|this
operator|==
name|hook
operator|.
name|obj
argument_list|)
expr_stmt|;
name|deliverCall
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|msg
argument_list|,
name|hook
operator|.
name|params
argument_list|,
name|hook
operator|.
name|midx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|call
condition|)
name|postEventToThread
argument_list|(
name|ActivateSignalAction
argument_list|,
name|hook
operator|.
name|obj
argument_list|,
name|call
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|activateCall
name|bool
name|QDBusConnectionPrivate
operator|::
name|activateCall
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
comment|// This is called by QDBusConnectionPrivate::handleObjectCall to place a call
comment|// to a slot on the object.
comment|//
comment|// The call is delivered to the first slot that matches the following conditions:
comment|//  - has the same name as the message's target member
comment|//  - ALL of the message's types are found in slot's parameter list
comment|//  - optionally has one more parameter of type QDBusMessage
comment|// If none match, then the slot of the same name as the message target and with
comment|// the first type of QDBusMessage is delivered.
comment|//
comment|// The D-Bus specification requires that all MethodCall messages be replied to, unless the
comment|// caller specifically waived this requirement. This means that we inspect if the user slot
comment|// generated a reply and, if it didn't, we will. Obviously, if the user slot doesn't take a
comment|// QDBusMessage parameter, it cannot generate a reply.
comment|//
comment|// When a return message is generated, the slot's return type, if any, will be placed
comment|// in the message's first position. If there are non-const reference parameters to the
comment|// slot, they must appear at the end and will be placed in the subsequent message
comment|// positions.
specifier|static
specifier|const
name|char
name|cachePropertyName
index|[]
init|=
literal|"_qdbus_slotCache"
decl_stmt|;
if|if
condition|(
operator|!
name|object
condition|)
return|return
literal|false
return|;
name|Q_ASSERT_X
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|object
operator|->
name|thread
argument_list|()
argument_list|,
literal|"QDBusConnection: internal threading error"
argument_list|,
literal|"function called for an object that is in another thread!!"
argument_list|)
expr_stmt|;
name|QDBusSlotCache
name|slotCache
init|=
name|qvariant_cast
argument_list|<
name|QDBusSlotCache
argument_list|>
argument_list|(
name|object
operator|->
name|property
argument_list|(
name|cachePropertyName
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|cacheKey
init|=
name|msg
operator|.
name|member
argument_list|()
decl_stmt|,
name|signature
init|=
name|msg
operator|.
name|signature
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|signature
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cacheKey
operator|.
name|reserve
argument_list|(
name|cacheKey
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|+
name|signature
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|cacheKey
operator|+=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|cacheKey
operator|+=
name|signature
expr_stmt|;
block|}
name|QDBusSlotCache
operator|::
name|Hash
operator|::
name|ConstIterator
name|cacheIt
init|=
name|slotCache
operator|.
name|hash
operator|.
name|constFind
argument_list|(
name|cacheKey
argument_list|)
decl_stmt|;
while|while
condition|(
name|cacheIt
operator|!=
name|slotCache
operator|.
name|hash
operator|.
name|constEnd
argument_list|()
operator|&&
name|cacheIt
operator|->
name|flags
operator|!=
name|flags
operator|&&
name|cacheIt
operator|.
name|key
argument_list|()
operator|==
name|cacheKey
condition|)
operator|++
name|cacheIt
expr_stmt|;
if|if
condition|(
name|cacheIt
operator|==
name|slotCache
operator|.
name|hash
operator|.
name|constEnd
argument_list|()
operator|||
name|cacheIt
operator|.
name|key
argument_list|()
operator|!=
name|cacheKey
condition|)
block|{
comment|// not cached, analyze the meta object
specifier|const
name|QMetaObject
modifier|*
name|mo
init|=
name|object
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|QByteArray
name|memberName
init|=
name|msg
operator|.
name|member
argument_list|()
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
comment|// find a slot that matches according to the rules above
name|QDBusSlotCache
operator|::
name|Data
name|slotData
decl_stmt|;
name|slotData
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|slotData
operator|.
name|slotIdx
operator|=
operator|::
name|findSlot
argument_list|(
name|mo
argument_list|,
name|memberName
argument_list|,
name|flags
argument_list|,
name|msg
operator|.
name|signature
argument_list|()
argument_list|,
name|slotData
operator|.
name|metaTypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotData
operator|.
name|slotIdx
operator|==
operator|-
literal|1
condition|)
block|{
comment|// ### this is where we want to add the connection as an arg too
comment|// try with no parameters, but with a QDBusMessage
name|slotData
operator|.
name|slotIdx
operator|=
operator|::
name|findSlot
argument_list|(
name|mo
argument_list|,
name|memberName
argument_list|,
name|flags
argument_list|,
name|QString
argument_list|()
argument_list|,
name|slotData
operator|.
name|metaTypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotData
operator|.
name|metaTypes
operator|.
name|count
argument_list|()
operator|!=
literal|2
operator|||
name|slotData
operator|.
name|metaTypes
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|!=
name|QDBusMetaTypeId
operator|::
name|message
argument_list|()
condition|)
block|{
comment|// not found
comment|// save the negative lookup
name|slotData
operator|.
name|slotIdx
operator|=
operator|-
literal|1
expr_stmt|;
name|slotData
operator|.
name|metaTypes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|slotCache
operator|.
name|hash
operator|.
name|insert
argument_list|(
name|cacheKey
argument_list|,
name|slotData
argument_list|)
expr_stmt|;
name|object
operator|->
name|setProperty
argument_list|(
name|cachePropertyName
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|(
name|slotCache
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// save to the cache
name|slotCache
operator|.
name|hash
operator|.
name|insert
argument_list|(
name|cacheKey
argument_list|,
name|slotData
argument_list|)
expr_stmt|;
name|object
operator|->
name|setProperty
argument_list|(
name|cachePropertyName
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|(
name|slotCache
argument_list|)
argument_list|)
expr_stmt|;
comment|// found the slot to be called
name|deliverCall
argument_list|(
name|object
argument_list|,
name|flags
argument_list|,
name|msg
argument_list|,
name|slotData
operator|.
name|metaTypes
argument_list|,
name|slotData
operator|.
name|slotIdx
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|cacheIt
operator|->
name|slotIdx
operator|==
operator|-
literal|1
condition|)
block|{
comment|// negative cache
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// use the cache
name|deliverCall
argument_list|(
name|object
argument_list|,
name|flags
argument_list|,
name|msg
argument_list|,
name|cacheIt
operator|->
name|metaTypes
argument_list|,
name|cacheIt
operator|->
name|slotIdx
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|deliverCall
name|void
name|QDBusConnectionPrivate
operator|::
name|deliverCall
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|,
name|int
comment|/*flags*/
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|metaTypes
parameter_list|,
name|int
name|slotIdx
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
operator|!
name|object
operator|||
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|object
operator|->
name|thread
argument_list|()
argument_list|,
literal|"QDBusConnection: internal threading error"
argument_list|,
literal|"function called for an object that is in another thread!!"
argument_list|)
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|void
modifier|*
argument_list|,
literal|10
argument_list|>
name|params
decl_stmt|;
name|params
operator|.
name|reserve
argument_list|(
name|metaTypes
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|QVariantList
name|auxParameters
decl_stmt|;
comment|// let's create the parameter list
comment|// first one is the return type -- add it below
name|params
operator|.
name|append
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// add the input parameters
name|int
name|i
decl_stmt|;
name|int
name|pCount
init|=
name|qMin
argument_list|(
name|msg
operator|.
name|arguments
argument_list|()
operator|.
name|count
argument_list|()
argument_list|,
name|metaTypes
operator|.
name|count
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|pCount
condition|;
operator|++
name|i
control|)
block|{
name|int
name|id
init|=
name|metaTypes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|QDBusMetaTypeId
operator|::
name|message
argument_list|()
condition|)
break|break;
specifier|const
name|QVariant
modifier|&
name|arg
init|=
name|msg
operator|.
name|arguments
argument_list|()
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|userType
argument_list|()
operator|==
name|id
condition|)
comment|// no conversion needed
name|params
operator|.
name|append
argument_list|(
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|arg
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|.
name|userType
argument_list|()
operator|==
name|qMetaTypeId
argument_list|<
name|QDBusArgument
argument_list|>
argument_list|()
condition|)
block|{
comment|// convert to what the function expects
name|void
modifier|*
name|null
init|=
literal|0
decl_stmt|;
name|auxParameters
operator|.
name|append
argument_list|(
name|QVariant
argument_list|(
name|id
argument_list|,
name|null
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|QDBusArgument
modifier|&
name|in
init|=
operator|*
cast|reinterpret_cast
argument_list|<
specifier|const
name|QDBusArgument
operator|*
argument_list|>
argument_list|(
name|arg
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|QVariant
modifier|&
name|out
init|=
name|auxParameters
index|[
name|auxParameters
operator|.
name|count
argument_list|()
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
operator|!
name|QDBusMetaType
operator|::
name|demarshall
argument_list|(
name|in
argument_list|,
name|out
operator|.
name|userType
argument_list|()
argument_list|,
name|out
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
condition|)
name|qFatal
argument_list|(
literal|"Internal error: demarshalling function for type '%s' (%d) failed!"
argument_list|,
name|out
operator|.
name|typeName
argument_list|()
argument_list|,
name|out
operator|.
name|userType
argument_list|()
argument_list|)
expr_stmt|;
name|params
operator|.
name|append
argument_list|(
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qFatal
argument_list|(
literal|"Internal error: got invalid meta type %d (%s) "
literal|"when trying to convert to meta type %d (%s)"
argument_list|,
name|arg
operator|.
name|userType
argument_list|()
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|arg
operator|.
name|userType
argument_list|()
argument_list|)
argument_list|,
name|id
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|metaTypes
operator|.
name|count
argument_list|()
operator|>
name|i
operator|&&
name|metaTypes
index|[
name|i
index|]
operator|==
name|QDBusMetaTypeId
operator|::
name|message
argument_list|()
condition|)
block|{
name|params
operator|.
name|append
argument_list|(
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|void
operator|*
argument_list|>
argument_list|(
operator|&
name|msg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
comment|// output arguments
specifier|const
name|int
name|numMetaTypes
init|=
name|metaTypes
operator|.
name|count
argument_list|()
decl_stmt|;
name|QVariantList
name|outputArgs
decl_stmt|;
name|void
modifier|*
name|null
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|metaTypes
index|[
literal|0
index|]
operator|!=
name|QMetaType
operator|::
name|Void
operator|&&
name|metaTypes
index|[
literal|0
index|]
operator|!=
name|QMetaType
operator|::
name|UnknownType
condition|)
block|{
name|outputArgs
operator|.
name|reserve
argument_list|(
name|numMetaTypes
operator|-
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|QVariant
name|arg
argument_list|(
name|metaTypes
index|[
literal|0
index|]
argument_list|,
name|null
argument_list|)
decl_stmt|;
name|outputArgs
operator|.
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|params
index|[
literal|0
index|]
operator|=
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|outputArgs
operator|.
name|at
argument_list|(
name|outputArgs
operator|.
name|count
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputArgs
operator|.
name|reserve
argument_list|(
name|numMetaTypes
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|numMetaTypes
condition|;
operator|++
name|i
control|)
block|{
name|QVariant
name|arg
argument_list|(
name|metaTypes
index|[
name|i
index|]
argument_list|,
name|null
argument_list|)
decl_stmt|;
name|outputArgs
operator|.
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|params
operator|.
name|append
argument_list|(
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|outputArgs
operator|.
name|at
argument_list|(
name|outputArgs
operator|.
name|count
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// make call:
name|bool
name|fail
decl_stmt|;
if|if
condition|(
operator|!
name|object
condition|)
block|{
name|fail
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// FIXME: save the old sender!
name|QDBusContextPrivate
name|context
argument_list|(
name|QDBusConnection
argument_list|(
name|this
argument_list|)
argument_list|,
name|msg
argument_list|)
decl_stmt|;
name|QDBusContextPrivate
modifier|*
name|old
init|=
name|QDBusContextPrivate
operator|::
name|set
argument_list|(
name|object
argument_list|,
operator|&
name|context
argument_list|)
decl_stmt|;
name|QPointer
argument_list|<
name|QObject
argument_list|>
name|ptr
init|=
name|object
decl_stmt|;
name|fail
operator|=
name|object
operator|->
name|qt_metacall
argument_list|(
name|QMetaObject
operator|::
name|InvokeMetaMethod
argument_list|,
name|slotIdx
argument_list|,
name|params
operator|.
name|data
argument_list|()
argument_list|)
operator|>=
literal|0
expr_stmt|;
comment|// the object might be deleted in the slot
if|if
condition|(
operator|!
name|ptr
operator|.
name|isNull
argument_list|()
condition|)
name|QDBusContextPrivate
operator|::
name|set
argument_list|(
name|object
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
comment|// do we create a reply? Only if the caller is waiting for a reply and one hasn't been sent
comment|// yet.
if|if
condition|(
name|msg
operator|.
name|isReplyRequired
argument_list|()
operator|&&
operator|!
name|msg
operator|.
name|isDelayedReply
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fail
condition|)
block|{
comment|// normal reply
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"Automatically sending reply:"
operator|<<
name|outputArgs
expr_stmt|;
name|send
argument_list|(
name|msg
operator|.
name|createReply
argument_list|(
name|outputArgs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// generate internal error
name|qWarning
argument_list|(
literal|"Internal error: Failed to deliver message"
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|msg
operator|.
name|createErrorReply
argument_list|(
name|QDBusError
operator|::
name|InternalError
argument_list|,
name|QLatin1String
argument_list|(
literal|"Failed to deliver message"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function
begin_function_decl
specifier|extern
name|bool
name|qDBusInitThreads
parameter_list|()
function_decl|;
end_function_decl
begin_constructor
DECL|function|QDBusConnectionPrivate
name|QDBusConnectionPrivate
operator|::
name|QDBusConnectionPrivate
parameter_list|(
name|QObject
modifier|*
name|p
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|p
argument_list|)
member_init_list|,
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|capabilities
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mode
argument_list|(
name|InvalidMode
argument_list|)
member_init_list|,
name|busService
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|dispatchLock
argument_list|(
name|QMutex
operator|::
name|Recursive
argument_list|)
member_init_list|,
name|connection
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|rootNode
argument_list|(
name|QString
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
member_init_list|,
name|anonymousAuthenticationAllowed
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|dispatchEnabled
argument_list|(
literal|true
argument_list|)
block|{
specifier|static
specifier|const
name|bool
name|threads
init|=
name|q_dbus_threads_init_default
argument_list|()
decl_stmt|;
if|if
condition|(
operator|::
name|isDebugging
operator|==
operator|-
literal|1
condition|)
operator|::
name|isDebugging
operator|=
name|qEnvironmentVariableIntValue
argument_list|(
literal|"QDBUS_DEBUG"
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
argument|threads
argument_list|)
ifdef|#
directive|ifdef
name|QDBUS_THREAD_DEBUG
if|if
condition|(
operator|::
name|isDebugging
operator|>
literal|1
condition|)
name|qdbusThreadDebug
operator|=
name|qdbusDefaultThreadDebug
expr_stmt|;
endif|#
directive|endif
name|QDBusMetaTypeId
operator|::
name|init
argument_list|()
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
operator|&
name|QDBusConnectionPrivate
operator|::
name|dispatchStatusChanged
argument_list|,
name|this
argument_list|,
operator|&
name|QDBusConnectionPrivate
operator|::
name|doDispatch
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
operator|&
name|QDBusConnectionPrivate
operator|::
name|spyHooksFinished
argument_list|,
name|this
argument_list|,
operator|&
name|QDBusConnectionPrivate
operator|::
name|handleObjectCall
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
operator|&
name|QDBusConnectionPrivate
operator|::
name|messageNeedsSending
argument_list|,
name|this
argument_list|,
operator|&
name|QDBusConnectionPrivate
operator|::
name|sendInternal
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
operator|&
name|QDBusConnectionPrivate
operator|::
name|signalNeedsConnecting
argument_list|,
name|this
argument_list|,
operator|&
name|QDBusConnectionPrivate
operator|::
name|addSignalHook
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
operator|&
name|QDBusConnectionPrivate
operator|::
name|signalNeedsDisconnecting
argument_list|,
name|this
argument_list|,
operator|&
name|QDBusConnectionPrivate
operator|::
name|removeSignalHook
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
name|rootNode
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|// prepopulate watchedServices:
comment|// we know that the owner of org.freedesktop.DBus is itself
name|watchedServices
operator|.
name|insert
argument_list|(
name|QDBusUtil
operator|::
name|dbusService
argument_list|()
argument_list|,
name|WatchedServiceData
argument_list|(
name|QDBusUtil
operator|::
name|dbusService
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// prepopulate matchRefCounts:
comment|// we know that org.freedesktop.DBus will never change owners
name|matchRefCounts
operator|.
name|insert
argument_list|(
literal|"type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged',arg0='org.freedesktop.DBus'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QDBusConnectionPrivate
name|QDBusConnectionPrivate
operator|::
name|~
name|QDBusConnectionPrivate
parameter_list|()
block|{
if|if
condition|(
name|thread
argument_list|()
operator|&&
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QDBusConnection(name=\"%s\")'s last reference in not in its creation thread! "
literal|"Timer and socket errors will follow and the program will probably crash"
argument_list|,
name|qPrintable
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|closeConnection
argument_list|()
expr_stmt|;
name|qDeleteAll
argument_list|(
name|cachedMetaObjects
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|ClientMode
operator|||
name|mode
operator|==
name|PeerMode
condition|)
block|{
comment|// the bus service object holds a reference back to us;
comment|// we need to destroy it before we finish destroying ourselves
name|Q_ASSERT
argument_list|(
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|QObject
modifier|*
name|obj
init|=
operator|(
name|QObject
operator|*
operator|)
name|busService
decl_stmt|;
if|if
condition|(
name|obj
condition|)
block|{
name|disconnect
argument_list|(
name|obj
argument_list|,
name|Q_NULLPTR
argument_list|,
name|this
argument_list|,
name|Q_NULLPTR
argument_list|)
expr_stmt|;
operator|delete
name|obj
expr_stmt|;
block|}
if|if
condition|(
name|connection
condition|)
name|q_dbus_connection_unref
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|connection
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|ServerMode
condition|)
block|{
if|if
condition|(
name|server
condition|)
name|q_dbus_server_unref
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|server
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_destructor
begin_function
DECL|function|disconnectObjectTree
name|void
name|QDBusConnectionPrivate
operator|::
name|disconnectObjectTree
parameter_list|(
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|&
name|haystack
parameter_list|)
block|{
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|it
init|=
name|haystack
operator|.
name|children
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|haystack
operator|.
name|children
operator|.
name|end
argument_list|()
condition|)
block|{
name|disconnectObjectTree
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
name|it
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|haystack
operator|.
name|obj
condition|)
name|haystack
operator|.
name|obj
operator|->
name|disconnect
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|closeConnection
name|void
name|QDBusConnectionPrivate
operator|::
name|closeConnection
parameter_list|()
block|{
name|QDBusWriteLocker
name|locker
argument_list|(
name|CloseConnectionAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"Disconnected"
expr_stmt|;
name|ConnectionMode
name|oldMode
init|=
name|mode
decl_stmt|;
name|mode
operator|=
name|InvalidMode
expr_stmt|;
comment|// prevent reentrancy
name|baseService
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldMode
operator|==
name|ServerMode
operator|&&
name|server
condition|)
block|{
name|q_dbus_server_disconnect
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|q_dbus_server_free_data_slot
argument_list|(
operator|&
name|server_slot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldMode
operator|==
name|ClientMode
operator|||
name|oldMode
operator|==
name|PeerMode
condition|)
block|{
if|if
condition|(
name|connection
condition|)
block|{
name|q_dbus_connection_close
argument_list|(
name|connection
argument_list|)
expr_stmt|;
comment|// send the "close" message
while|while
condition|(
name|q_dbus_connection_dispatch
argument_list|(
name|connection
argument_list|)
operator|==
name|DBUS_DISPATCH_DATA_REMAINS
condition|)
empty_stmt|;
block|}
block|}
name|qDeleteAll
argument_list|(
name|pendingCalls
argument_list|)
expr_stmt|;
comment|// Disconnect all signals from signal hooks and from the object tree to
comment|// avoid QObject::destroyed being sent to dbus daemon thread which has
comment|// already quit.
name|SignalHookHash
operator|::
name|iterator
name|sit
init|=
name|signalHooks
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|sit
operator|!=
name|signalHooks
operator|.
name|end
argument_list|()
condition|)
block|{
name|sit
operator|.
name|value
argument_list|()
operator|.
name|obj
operator|->
name|disconnect
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|sit
operator|++
expr_stmt|;
block|}
name|disconnectObjectTree
argument_list|(
name|rootNode
argument_list|)
expr_stmt|;
name|rootNode
operator|.
name|children
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// free resources
block|}
end_function
begin_function
DECL|function|handleDBusDisconnection
name|void
name|QDBusConnectionPrivate
operator|::
name|handleDBusDisconnection
parameter_list|()
block|{
while|while
condition|(
operator|!
name|pendingCalls
operator|.
name|isEmpty
argument_list|()
condition|)
name|processFinishedCall
argument_list|(
name|pendingCalls
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|checkThread
name|void
name|QDBusConnectionPrivate
operator|::
name|checkThread
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|thread
argument_list|()
operator|==
name|QDBusConnectionManager
operator|::
name|instance
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|thread
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleError
name|bool
name|QDBusConnectionPrivate
operator|::
name|handleError
parameter_list|(
specifier|const
name|QDBusErrorInternal
modifier|&
name|error
parameter_list|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
return|return
literal|false
return|;
comment|// no error
comment|//lock.lockForWrite();
name|lastError
operator|=
name|error
expr_stmt|;
comment|//lock.unlock();
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|timerEvent
name|void
name|QDBusConnectionPrivate
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|e
parameter_list|)
block|{
block|{
name|QDBusDispatchLocker
name|locker
argument_list|(
name|TimerEventAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|DBusTimeout
modifier|*
name|timeout
init|=
name|timeouts
operator|.
name|value
argument_list|(
name|e
operator|->
name|timerId
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|timeout
condition|)
name|q_dbus_timeout_handle
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
name|doDispatch
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|doDispatch
name|void
name|QDBusConnectionPrivate
operator|::
name|doDispatch
parameter_list|()
block|{
name|QDBusDispatchLocker
name|locker
argument_list|(
name|DoDispatchAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|ClientMode
operator|||
name|mode
operator|==
name|PeerMode
condition|)
block|{
while|while
condition|(
name|q_dbus_connection_dispatch
argument_list|(
name|connection
argument_list|)
operator|==
name|DBUS_DISPATCH_DATA_REMAINS
condition|)
empty_stmt|;
if|if
condition|(
name|dispatchEnabled
operator|&&
operator|!
name|pendingMessages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// dispatch previously queued messages
name|PendingMessageList
operator|::
name|Iterator
name|it
init|=
name|pendingMessages
operator|.
name|begin
argument_list|()
decl_stmt|;
name|PendingMessageList
operator|::
name|Iterator
name|end
init|=
name|pendingMessages
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"dequeueing message"
operator|<<
operator|*
name|it
expr_stmt|;
name|handleMessage
argument_list|(
name|qMove
argument_list|(
operator|*
name|it
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pendingMessages
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|socketRead
name|void
name|QDBusConnectionPrivate
operator|::
name|socketRead
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|QDBusDispatchLocker
name|locker
argument_list|(
name|SocketReadAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|WatcherHash
operator|::
name|ConstIterator
name|it
init|=
name|watchers
operator|.
name|constFind
argument_list|(
name|fd
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|watchers
operator|.
name|constEnd
argument_list|()
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|fd
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|watch
operator|&&
name|it
operator|->
name|read
operator|&&
name|it
operator|->
name|read
operator|->
name|isEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|q_dbus_watch_handle
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|watch
argument_list|,
name|DBUS_WATCH_READABLE
argument_list|)
condition|)
name|qDebug
argument_list|(
literal|"OUT OF MEM"
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|it
expr_stmt|;
block|}
name|doDispatch
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|socketWrite
name|void
name|QDBusConnectionPrivate
operator|::
name|socketWrite
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|QDBusDispatchLocker
name|locker
argument_list|(
name|SocketWriteAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|WatcherHash
operator|::
name|ConstIterator
name|it
init|=
name|watchers
operator|.
name|constFind
argument_list|(
name|fd
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|watchers
operator|.
name|constEnd
argument_list|()
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|fd
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|watch
operator|&&
name|it
operator|->
name|write
operator|&&
name|it
operator|->
name|write
operator|->
name|isEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|q_dbus_watch_handle
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|watch
argument_list|,
name|DBUS_WATCH_WRITABLE
argument_list|)
condition|)
name|qDebug
argument_list|(
literal|"OUT OF MEM"
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|objectDestroyed
name|void
name|QDBusConnectionPrivate
operator|::
name|objectDestroyed
parameter_list|(
name|QObject
modifier|*
name|obj
parameter_list|)
block|{
name|QDBusWriteLocker
name|locker
argument_list|(
name|ObjectDestroyedAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|huntAndDestroy
argument_list|(
name|obj
argument_list|,
name|rootNode
argument_list|)
expr_stmt|;
name|SignalHookHash
operator|::
name|iterator
name|sit
init|=
name|signalHooks
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|sit
operator|!=
name|signalHooks
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
cast|static_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|sit
operator|.
name|value
argument_list|()
operator|.
name|obj
argument_list|)
operator|==
name|obj
condition|)
name|sit
operator|=
name|removeSignalHookNoLock
argument_list|(
name|sit
argument_list|)
expr_stmt|;
else|else
operator|++
name|sit
expr_stmt|;
block|}
name|obj
operator|->
name|disconnect
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|relaySignal
name|void
name|QDBusConnectionPrivate
operator|::
name|relaySignal
parameter_list|(
name|QObject
modifier|*
name|obj
parameter_list|,
specifier|const
name|QMetaObject
modifier|*
name|mo
parameter_list|,
name|int
name|signalId
parameter_list|,
specifier|const
name|QVariantList
modifier|&
name|args
parameter_list|)
block|{
name|QString
name|interface
init|=
name|qDBusInterfaceFromMetaObject
argument_list|(
name|mo
argument_list|)
decl_stmt|;
name|QMetaMethod
name|mm
init|=
name|mo
operator|->
name|method
argument_list|(
name|signalId
argument_list|)
decl_stmt|;
name|QByteArray
name|memberName
init|=
name|mm
operator|.
name|name
argument_list|()
decl_stmt|;
comment|// check if it's scriptable
name|bool
name|isScriptable
init|=
name|mm
operator|.
name|attributes
argument_list|()
operator|&
name|QMetaMethod
operator|::
name|Scriptable
decl_stmt|;
name|bool
name|isAdaptor
init|=
literal|false
decl_stmt|;
for|for
control|(
init|;
name|mo
condition|;
name|mo
operator|=
name|mo
operator|->
name|superClass
argument_list|()
control|)
if|if
condition|(
name|mo
operator|==
operator|&
name|QDBusAbstractAdaptor
operator|::
name|staticMetaObject
condition|)
block|{
name|isAdaptor
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|QDBusReadLocker
name|locker
argument_list|(
name|RelaySignalAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|QDBusMessage
name|message
init|=
name|QDBusMessage
operator|::
name|createSignal
argument_list|(
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
argument_list|,
name|interface
argument_list|,
name|QLatin1String
argument_list|(
name|memberName
argument_list|)
argument_list|)
decl_stmt|;
name|QDBusMessagePrivate
operator|::
name|setParametersValidated
argument_list|(
name|message
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|message
operator|.
name|setArguments
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|QDBusError
name|error
decl_stmt|;
name|DBusMessage
modifier|*
name|msg
init|=
name|QDBusMessagePrivate
operator|::
name|toDBusMessage
argument_list|(
name|message
argument_list|,
name|capabilities
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDBusConnection: Could not emit signal %s.%s: %s"
argument_list|,
name|qPrintable
argument_list|(
name|interface
argument_list|)
argument_list|,
name|memberName
operator|.
name|constData
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|error
operator|.
name|message
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|lastError
operator|=
name|error
expr_stmt|;
return|return;
block|}
comment|//qDBusDebug()<< "Emitting signal"<< message;
comment|//qDBusDebug()<< "for paths:";
name|q_dbus_message_set_no_reply
argument_list|(
name|msg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// the reply would not be delivered to anything
block|{
name|QDBusDispatchLocker
name|locker
argument_list|(
name|HuntAndEmitAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|huntAndEmit
argument_list|(
name|connection
argument_list|,
name|msg
argument_list|,
name|obj
argument_list|,
name|rootNode
argument_list|,
name|isScriptable
argument_list|,
name|isAdaptor
argument_list|)
expr_stmt|;
block|}
name|q_dbus_message_unref
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|serviceOwnerChangedNoLock
name|void
name|QDBusConnectionPrivate
operator|::
name|serviceOwnerChangedNoLock
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|oldOwner
parameter_list|,
specifier|const
name|QString
modifier|&
name|newOwner
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|oldOwner
argument_list|)
expr_stmt|;
comment|//    QDBusWriteLocker locker(UpdateSignalHookOwnerAction, this);
name|WatchedServicesHash
operator|::
name|Iterator
name|it
init|=
name|watchedServices
operator|.
name|find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|watchedServices
operator|.
name|end
argument_list|()
condition|)
return|return;
if|if
condition|(
name|oldOwner
operator|!=
name|it
operator|->
name|owner
condition|)
name|qWarning
argument_list|(
literal|"QDBusConnection: name '%s' had owner '%s' but we thought it was '%s'"
argument_list|,
name|qPrintable
argument_list|(
name|name
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|oldOwner
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|it
operator|->
name|owner
argument_list|)
argument_list|)
expr_stmt|;
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"Updating name"
operator|<<
name|name
operator|<<
literal|"from"
operator|<<
name|oldOwner
operator|<<
literal|"to"
operator|<<
name|newOwner
expr_stmt|;
name|it
operator|->
name|owner
operator|=
name|newOwner
expr_stmt|;
block|}
end_function
begin_function
DECL|function|findSlot
name|int
name|QDBusConnectionPrivate
operator|::
name|findSlot
parameter_list|(
name|QObject
modifier|*
name|obj
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|normalizedName
parameter_list|,
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|params
parameter_list|)
block|{
name|int
name|midx
init|=
name|obj
operator|->
name|metaObject
argument_list|()
operator|->
name|indexOfMethod
argument_list|(
name|normalizedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|midx
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|QString
name|errorMsg
decl_stmt|;
name|int
name|inputCount
init|=
name|qDBusParametersForMethod
argument_list|(
name|obj
operator|->
name|metaObject
argument_list|()
operator|->
name|method
argument_list|(
name|midx
argument_list|)
argument_list|,
name|params
argument_list|,
name|errorMsg
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputCount
operator|==
operator|-
literal|1
operator|||
name|inputCount
operator|+
literal|1
operator|!=
name|params
operator|.
name|count
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
comment|// failed to parse or invalid arguments or output arguments
return|return
name|midx
return|;
block|}
end_function
begin_function
DECL|function|prepareHook
name|bool
name|QDBusConnectionPrivate
operator|::
name|prepareHook
parameter_list|(
name|QDBusConnectionPrivate
operator|::
name|SignalHook
modifier|&
name|hook
parameter_list|,
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|argMatch
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|signal
parameter_list|,
name|int
name|minMIdx
parameter_list|,
name|bool
name|buildSignature
parameter_list|)
block|{
name|QByteArray
name|normalizedName
init|=
name|signal
operator|+
literal|1
decl_stmt|;
name|hook
operator|.
name|midx
operator|=
name|findSlot
argument_list|(
name|receiver
argument_list|,
name|signal
operator|+
literal|1
argument_list|,
name|hook
operator|.
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|.
name|midx
operator|==
operator|-
literal|1
condition|)
block|{
name|normalizedName
operator|=
name|QMetaObject
operator|::
name|normalizedSignature
argument_list|(
name|signal
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hook
operator|.
name|midx
operator|=
name|findSlot
argument_list|(
name|receiver
argument_list|,
name|normalizedName
argument_list|,
name|hook
operator|.
name|params
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hook
operator|.
name|midx
operator|<
name|minMIdx
condition|)
block|{
if|if
condition|(
name|hook
operator|.
name|midx
operator|==
operator|-
literal|1
condition|)
block|{}
return|return
literal|false
return|;
block|}
name|hook
operator|.
name|service
operator|=
name|service
expr_stmt|;
name|hook
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|hook
operator|.
name|obj
operator|=
name|receiver
expr_stmt|;
name|hook
operator|.
name|argumentMatch
operator|=
name|argMatch
expr_stmt|;
comment|// build the D-Bus signal name and signature
comment|// This should not happen for QDBusConnection::connect, use buildSignature here, since
comment|// QDBusConnection::connect passes false and everything else uses true
name|QString
name|mname
init|=
name|name
decl_stmt|;
if|if
condition|(
name|buildSignature
operator|&&
name|mname
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|normalizedName
operator|.
name|truncate
argument_list|(
name|normalizedName
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
argument_list|)
expr_stmt|;
name|mname
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|normalizedName
argument_list|)
expr_stmt|;
block|}
name|key
operator|=
name|mname
expr_stmt|;
name|key
operator|.
name|reserve
argument_list|(
name|interface
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|+
name|mname
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|+=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|key
operator|+=
name|interface
expr_stmt|;
if|if
condition|(
name|buildSignature
condition|)
block|{
name|hook
operator|.
name|signature
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|hook
operator|.
name|params
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|hook
operator|.
name|params
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|QDBusMetaTypeId
operator|::
name|message
argument_list|()
condition|)
name|hook
operator|.
name|signature
operator|+=
name|QLatin1String
argument_list|(
name|QDBusMetaType
operator|::
name|typeToSignature
argument_list|(
name|hook
operator|.
name|params
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hook
operator|.
name|matchRule
operator|=
name|buildMatchRule
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|mname
argument_list|,
name|argMatch
argument_list|,
name|hook
operator|.
name|signature
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// connect to this signal
block|}
end_function
begin_function
DECL|function|sendError
name|void
name|QDBusConnectionPrivate
operator|::
name|sendError
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|,
name|QDBusError
operator|::
name|ErrorType
name|code
parameter_list|)
block|{
if|if
condition|(
name|code
operator|==
name|QDBusError
operator|::
name|UnknownMethod
condition|)
block|{
name|QString
name|interfaceMsg
decl_stmt|;
if|if
condition|(
name|msg
operator|.
name|interface
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|interfaceMsg
operator|=
name|QLatin1String
argument_list|(
literal|"any interface"
argument_list|)
expr_stmt|;
else|else
name|interfaceMsg
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"interface '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|msg
operator|.
name|interface
argument_list|()
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|msg
operator|.
name|createErrorReply
argument_list|(
name|code
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"No such method '%1' in %2 at object path '%3' "
literal|"(signature '%4')"
argument_list|)
operator|.
name|arg
argument_list|(
name|msg
operator|.
name|member
argument_list|()
argument_list|,
name|interfaceMsg
argument_list|,
name|msg
operator|.
name|path
argument_list|()
argument_list|,
name|msg
operator|.
name|signature
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|QDBusError
operator|::
name|UnknownInterface
condition|)
block|{
name|send
argument_list|(
name|msg
operator|.
name|createErrorReply
argument_list|(
name|QDBusError
operator|::
name|UnknownInterface
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"No such interface '%1' at object path '%2'"
argument_list|)
operator|.
name|arg
argument_list|(
name|msg
operator|.
name|interface
argument_list|()
argument_list|,
name|msg
operator|.
name|path
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|QDBusError
operator|::
name|UnknownObject
condition|)
block|{
name|send
argument_list|(
name|msg
operator|.
name|createErrorReply
argument_list|(
name|QDBusError
operator|::
name|UnknownObject
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"No such object path '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|msg
operator|.
name|path
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|activateInternalFilters
name|bool
name|QDBusConnectionPrivate
operator|::
name|activateInternalFilters
parameter_list|(
specifier|const
name|ObjectTreeNode
modifier|&
name|node
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
comment|// object may be null
specifier|const
name|QString
name|interface
init|=
name|msg
operator|.
name|interface
argument_list|()
decl_stmt|;
if|if
condition|(
name|interface
operator|.
name|isEmpty
argument_list|()
operator|||
name|interface
operator|==
name|QDBusUtil
operator|::
name|dbusInterfaceIntrospectable
argument_list|()
condition|)
block|{
if|if
condition|(
name|msg
operator|.
name|member
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"Introspect"
argument_list|)
operator|&&
name|msg
operator|.
name|signature
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//qDebug()<< "QDBusConnectionPrivate::activateInternalFilters introspect"<< msg.d_ptr->msg;
name|QDBusMessage
name|reply
init|=
name|msg
operator|.
name|createReply
argument_list|(
name|qDBusIntrospectObject
argument_list|(
name|node
argument_list|,
name|msg
operator|.
name|path
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|send
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownMethod
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|node
operator|.
name|obj
operator|&&
operator|(
name|interface
operator|.
name|isEmpty
argument_list|()
operator|||
name|interface
operator|==
name|QDBusUtil
operator|::
name|dbusInterfaceProperties
argument_list|()
operator|)
condition|)
block|{
comment|//qDebug()<< "QDBusConnectionPrivate::activateInternalFilters properties"<< msg.d_ptr->msg;
if|if
condition|(
name|msg
operator|.
name|member
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"Get"
argument_list|)
operator|&&
name|msg
operator|.
name|signature
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"ss"
argument_list|)
condition|)
block|{
name|QDBusMessage
name|reply
init|=
name|qDBusPropertyGet
argument_list|(
name|node
argument_list|,
name|msg
argument_list|)
decl_stmt|;
name|send
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|msg
operator|.
name|member
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"Set"
argument_list|)
operator|&&
name|msg
operator|.
name|signature
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"ssv"
argument_list|)
condition|)
block|{
name|QDBusMessage
name|reply
init|=
name|qDBusPropertySet
argument_list|(
name|node
argument_list|,
name|msg
argument_list|)
decl_stmt|;
name|send
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|msg
operator|.
name|member
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"GetAll"
argument_list|)
operator|&&
name|msg
operator|.
name|signature
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"s"
argument_list|)
condition|)
block|{
name|QDBusMessage
name|reply
init|=
name|qDBusPropertyGetAll
argument_list|(
name|node
argument_list|,
name|msg
argument_list|)
decl_stmt|;
name|send
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownMethod
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|activateObject
name|void
name|QDBusConnectionPrivate
operator|::
name|activateObject
parameter_list|(
name|ObjectTreeNode
modifier|&
name|node
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|,
name|int
name|pathStartPos
parameter_list|)
block|{
comment|// This is called by QDBusConnectionPrivate::handleObjectCall to place a call to a slot
comment|// on the object.
comment|//
comment|// The call is routed through the adaptor sub-objects if we have any
comment|// object may be null
if|if
condition|(
name|node
operator|.
name|flags
operator|&
name|QDBusConnectionPrivate
operator|::
name|VirtualObject
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|treeNode
operator|->
name|handleMessage
argument_list|(
name|msg
argument_list|,
name|q
argument_list|(
name|this
argument_list|)
argument_list|)
condition|)
block|{
return|return;
block|}
else|else
block|{
if|if
condition|(
name|activateInternalFilters
argument_list|(
name|node
argument_list|,
name|msg
argument_list|)
condition|)
return|return;
block|}
block|}
if|if
condition|(
name|pathStartPos
operator|!=
name|msg
operator|.
name|path
argument_list|()
operator|.
name|length
argument_list|()
condition|)
block|{
name|node
operator|.
name|flags
operator|&=
operator|~
name|QDBusConnection
operator|::
name|ExportAllSignals
expr_stmt|;
name|node
operator|.
name|obj
operator|=
name|findChildObject
argument_list|(
operator|&
name|node
argument_list|,
name|msg
operator|.
name|path
argument_list|()
argument_list|,
name|pathStartPos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|.
name|obj
condition|)
block|{
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownObject
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|QDBusAdaptorConnector
modifier|*
name|connector
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|flags
operator|&
name|QDBusConnection
operator|::
name|ExportAdaptors
operator|&&
operator|(
name|connector
operator|=
name|qDBusFindAdaptorConnector
argument_list|(
name|node
operator|.
name|obj
argument_list|)
operator|)
condition|)
block|{
name|int
name|newflags
init|=
name|node
operator|.
name|flags
operator||
name|QDBusConnection
operator|::
name|ExportAllSlots
decl_stmt|;
if|if
condition|(
name|msg
operator|.
name|interface
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// place the call in all interfaces
comment|// let the first one that handles it to work
name|QDBusAdaptorConnector
operator|::
name|AdaptorMap
operator|::
name|ConstIterator
name|it
init|=
name|connector
operator|->
name|adaptors
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QDBusAdaptorConnector
operator|::
name|AdaptorMap
operator|::
name|ConstIterator
name|end
init|=
name|connector
operator|->
name|adaptors
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
if|if
condition|(
name|activateCall
argument_list|(
name|it
operator|->
name|adaptor
argument_list|,
name|newflags
argument_list|,
name|msg
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
comment|// check if we have an interface matching the name that was asked:
name|QDBusAdaptorConnector
operator|::
name|AdaptorMap
operator|::
name|ConstIterator
name|it
decl_stmt|;
name|it
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|connector
operator|->
name|adaptors
operator|.
name|constBegin
argument_list|()
argument_list|,
name|connector
operator|->
name|adaptors
operator|.
name|constEnd
argument_list|()
argument_list|,
name|msg
operator|.
name|interface
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|connector
operator|->
name|adaptors
operator|.
name|constEnd
argument_list|()
operator|&&
name|msg
operator|.
name|interface
argument_list|()
operator|==
name|QLatin1String
argument_list|(
name|it
operator|->
name|interface
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|activateCall
argument_list|(
name|it
operator|->
name|adaptor
argument_list|,
name|newflags
argument_list|,
name|msg
argument_list|)
condition|)
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownMethod
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// no adaptors matched or were exported
comment|// try our standard filters
if|if
condition|(
name|activateInternalFilters
argument_list|(
name|node
argument_list|,
name|msg
argument_list|)
condition|)
return|return;
comment|// internal filters have already run or an error has been sent
comment|// try the object itself:
if|if
condition|(
name|node
operator|.
name|flags
operator|&
operator|(
name|QDBusConnection
operator|::
name|ExportScriptableSlots
operator||
name|QDBusConnection
operator|::
name|ExportNonScriptableSlots
operator|)
operator|||
name|node
operator|.
name|flags
operator|&
operator|(
name|QDBusConnection
operator|::
name|ExportScriptableInvokables
operator||
name|QDBusConnection
operator|::
name|ExportNonScriptableInvokables
operator|)
condition|)
block|{
name|bool
name|interfaceFound
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|msg
operator|.
name|interface
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|node
operator|.
name|interfaceName
operator|.
name|isEmpty
argument_list|()
condition|)
name|interfaceFound
operator|=
name|msg
operator|.
name|interface
argument_list|()
operator|==
name|node
operator|.
name|interfaceName
expr_stmt|;
else|else
name|interfaceFound
operator|=
name|qDBusInterfaceInObject
argument_list|(
name|node
operator|.
name|obj
argument_list|,
name|msg
operator|.
name|interface
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interfaceFound
condition|)
block|{
if|if
condition|(
operator|!
name|activateCall
argument_list|(
name|node
operator|.
name|obj
argument_list|,
name|node
operator|.
name|flags
argument_list|,
name|msg
argument_list|)
condition|)
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownMethod
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// nothing matched, send an error code
if|if
condition|(
name|msg
operator|.
name|interface
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownMethod
argument_list|)
expr_stmt|;
else|else
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownInterface
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleObjectCall
name|void
name|QDBusConnectionPrivate
operator|::
name|handleObjectCall
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
comment|// if the msg is external, we were called from inside doDispatch
comment|// that means the dispatchLock mutex is locked
comment|// must not call out to user code in that case
comment|//
comment|// however, if the message is internal, handleMessage was called directly
comment|// (user's thread) and no lock is in place. We can therefore call out to
comment|// user code, if necessary.
name|ObjectTreeNode
name|result
decl_stmt|;
name|int
name|usedLength
decl_stmt|;
name|QThread
modifier|*
name|objThread
init|=
literal|0
decl_stmt|;
name|QSemaphore
name|sem
decl_stmt|;
name|bool
name|semWait
decl_stmt|;
block|{
name|QDBusReadLocker
name|locker
argument_list|(
name|HandleObjectCallAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|findObject
argument_list|(
operator|&
name|rootNode
argument_list|,
name|msg
operator|.
name|path
argument_list|()
argument_list|,
name|usedLength
argument_list|,
name|result
argument_list|)
condition|)
block|{
comment|// qDebug("Call failed: no object found at %s", qPrintable(msg.path()));
name|sendError
argument_list|(
name|msg
argument_list|,
name|QDBusError
operator|::
name|UnknownObject
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|result
operator|.
name|obj
condition|)
block|{
comment|// no object -> no threading issues
comment|// it's either going to be an error, or an internal filter
name|activateObject
argument_list|(
name|result
argument_list|,
name|msg
argument_list|,
name|usedLength
argument_list|)
expr_stmt|;
return|return;
block|}
name|objThread
operator|=
name|result
operator|.
name|obj
operator|->
name|thread
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|objThread
condition|)
block|{
name|send
argument_list|(
name|msg
operator|.
name|createErrorReply
argument_list|(
name|QDBusError
operator|::
name|InternalError
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Object '%1' (at path '%2')"
literal|" has no thread. Cannot deliver message."
argument_list|)
operator|.
name|arg
argument_list|(
name|result
operator|.
name|obj
operator|->
name|objectName
argument_list|()
argument_list|,
name|msg
operator|.
name|path
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|QDBusMessagePrivate
operator|::
name|isLocal
argument_list|(
name|msg
argument_list|)
condition|)
block|{
comment|// external incoming message
comment|// post it and forget
name|postEventToThread
argument_list|(
name|HandleObjectCallPostEventAction
argument_list|,
name|result
operator|.
name|obj
argument_list|,
operator|new
name|QDBusActivateObjectEvent
argument_list|(
name|QDBusConnection
argument_list|(
name|this
argument_list|)
argument_list|,
name|this
argument_list|,
name|result
argument_list|,
name|usedLength
argument_list|,
name|msg
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|objThread
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
comment|// looped-back message, targeting another thread:
comment|// synchronize with it
name|postEventToThread
argument_list|(
name|HandleObjectCallPostEventAction
argument_list|,
name|result
operator|.
name|obj
argument_list|,
operator|new
name|QDBusActivateObjectEvent
argument_list|(
name|QDBusConnection
argument_list|(
name|this
argument_list|)
argument_list|,
name|this
argument_list|,
name|result
argument_list|,
name|usedLength
argument_list|,
name|msg
argument_list|,
operator|&
name|sem
argument_list|)
argument_list|)
expr_stmt|;
name|semWait
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// looped-back message, targeting current thread
name|semWait
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// release the lock
if|if
condition|(
name|semWait
condition|)
name|SEM_ACQUIRE
argument_list|(
name|HandleObjectCallSemaphoreAction
argument_list|,
name|sem
argument_list|)
expr_stmt|;
else|else
name|activateObject
argument_list|(
name|result
argument_list|,
name|msg
argument_list|,
name|usedLength
argument_list|)
expr_stmt|;
block|}
end_function
begin_destructor
DECL|function|~QDBusActivateObjectEvent
name|QDBusActivateObjectEvent
operator|::
name|~
name|QDBusActivateObjectEvent
parameter_list|()
block|{
if|if
condition|(
operator|!
name|handled
condition|)
block|{
comment|// we're being destroyed without delivering
comment|// it means the object was deleted between posting and delivering
name|QDBusConnectionPrivate
modifier|*
name|that
init|=
name|QDBusConnectionPrivate
operator|::
name|d
argument_list|(
name|connection
argument_list|)
decl_stmt|;
name|that
operator|->
name|sendError
argument_list|(
name|message
argument_list|,
name|QDBusError
operator|::
name|UnknownObject
argument_list|)
expr_stmt|;
block|}
comment|// semaphore releasing happens in ~QMetaCallEvent
block|}
end_destructor
begin_function
DECL|function|placeMetaCall
name|void
name|QDBusActivateObjectEvent
operator|::
name|placeMetaCall
parameter_list|(
name|QObject
modifier|*
parameter_list|)
block|{
name|QDBusConnectionPrivate
modifier|*
name|that
init|=
name|QDBusConnectionPrivate
operator|::
name|d
argument_list|(
name|connection
argument_list|)
decl_stmt|;
name|QDBusLockerBase
operator|::
name|reportThreadAction
argument_list|(
name|HandleObjectCallPostEventAction
argument_list|,
name|QDBusLockerBase
operator|::
name|BeforeDeliver
argument_list|,
name|that
argument_list|)
expr_stmt|;
name|that
operator|->
name|activateObject
argument_list|(
name|node
argument_list|,
name|message
argument_list|,
name|pathStartPos
argument_list|)
expr_stmt|;
name|QDBusLockerBase
operator|::
name|reportThreadAction
argument_list|(
name|HandleObjectCallPostEventAction
argument_list|,
name|QDBusLockerBase
operator|::
name|AfterDeliver
argument_list|,
name|that
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleSignal
name|void
name|QDBusConnectionPrivate
operator|::
name|handleSignal
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
name|SignalHookHash
operator|::
name|const_iterator
name|it
init|=
name|signalHooks
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|SignalHookHash
operator|::
name|const_iterator
name|end
init|=
name|signalHooks
operator|.
name|constEnd
argument_list|()
decl_stmt|;
comment|//qDebug("looking for: %s", path.toLocal8Bit().constData());
comment|//qDBusDebug()<< signalHooks.keys();
for|for
control|(
init|;
name|it
operator|!=
name|end
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|key
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|SignalHook
modifier|&
name|hook
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hook
operator|.
name|service
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|owner
init|=
name|watchedServices
operator|.
name|value
argument_list|(
name|hook
operator|.
name|service
argument_list|,
name|WatchedServiceData
argument_list|(
name|hook
operator|.
name|service
argument_list|)
argument_list|)
operator|.
name|owner
decl_stmt|;
if|if
condition|(
name|owner
operator|!=
name|msg
operator|.
name|service
argument_list|()
condition|)
continue|continue;
block|}
if|if
condition|(
operator|!
name|hook
operator|.
name|path
operator|.
name|isEmpty
argument_list|()
operator|&&
name|hook
operator|.
name|path
operator|!=
name|msg
operator|.
name|path
argument_list|()
condition|)
continue|continue;
if|if
condition|(
operator|!
name|hook
operator|.
name|signature
operator|.
name|isEmpty
argument_list|()
operator|&&
name|hook
operator|.
name|signature
operator|!=
name|msg
operator|.
name|signature
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|hook
operator|.
name|signature
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|hook
operator|.
name|signature
operator|.
name|isNull
argument_list|()
operator|&&
operator|!
name|msg
operator|.
name|signature
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
if|if
condition|(
operator|!
name|hook
operator|.
name|argumentMatch
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|QVariantList
name|arguments
init|=
name|msg
operator|.
name|arguments
argument_list|()
decl_stmt|;
if|if
condition|(
name|hook
operator|.
name|argumentMatch
operator|.
name|size
argument_list|()
operator|>
name|arguments
operator|.
name|size
argument_list|()
condition|)
continue|continue;
name|bool
name|matched
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hook
operator|.
name|argumentMatch
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
modifier|&
name|param
init|=
name|hook
operator|.
name|argumentMatch
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|param
operator|.
name|isNull
argument_list|()
condition|)
continue|continue;
comment|// don't try to match against this
if|if
condition|(
name|param
operator|==
name|arguments
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
condition|)
continue|continue;
comment|// matched
name|matched
operator|=
literal|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|matched
condition|)
continue|continue;
block|}
name|activateSignal
argument_list|(
name|hook
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|handleSignal
name|void
name|QDBusConnectionPrivate
operator|::
name|handleSignal
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
comment|// We call handlesignal(QString, QDBusMessage) three times:
comment|//  one with member:interface
comment|//  one with member:
comment|//  one with :interface
comment|// This allows us to match signals with wildcards on member or interface
comment|// (but not both)
name|QString
name|key
init|=
name|msg
operator|.
name|member
argument_list|()
decl_stmt|;
name|key
operator|.
name|reserve
argument_list|(
name|key
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|+
name|msg
operator|.
name|interface
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|+=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|key
operator|+=
name|msg
operator|.
name|interface
argument_list|()
expr_stmt|;
name|QDBusReadLocker
name|locker
argument_list|(
name|HandleSignalAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|handleSignal
argument_list|(
name|key
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// one try
name|key
operator|.
name|truncate
argument_list|(
name|msg
operator|.
name|member
argument_list|()
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// keep the ':'
name|handleSignal
argument_list|(
name|key
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// second try
name|key
operator|=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|key
operator|+=
name|msg
operator|.
name|interface
argument_list|()
expr_stmt|;
name|handleSignal
argument_list|(
name|key
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// third try
block|}
end_function
begin_function
DECL|function|watchForDBusDisconnection
name|void
name|QDBusConnectionPrivate
operator|::
name|watchForDBusDisconnection
parameter_list|()
block|{
name|SignalHook
name|hook
decl_stmt|;
comment|// Initialize the hook for Disconnected signal
name|hook
operator|.
name|service
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// org.freedesktop.DBus.Local.Disconnected uses empty service name
name|hook
operator|.
name|path
operator|=
name|QDBusUtil
operator|::
name|dbusPathLocal
argument_list|()
expr_stmt|;
name|hook
operator|.
name|obj
operator|=
name|this
expr_stmt|;
name|hook
operator|.
name|params
operator|<<
name|QMetaType
operator|::
name|Void
expr_stmt|;
name|hook
operator|.
name|midx
operator|=
name|staticMetaObject
operator|.
name|indexOfSlot
argument_list|(
literal|"handleDBusDisconnection()"
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|hook
operator|.
name|midx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|signalHooks
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|"Disconnected:"
name|DBUS_INTERFACE_LOCAL
argument_list|)
argument_list|,
name|hook
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setServer
name|void
name|QDBusConnectionPrivate
operator|::
name|setServer
parameter_list|(
name|QDBusServer
modifier|*
name|object
parameter_list|,
name|DBusServer
modifier|*
name|s
parameter_list|,
specifier|const
name|QDBusErrorInternal
modifier|&
name|error
parameter_list|)
block|{
name|mode
operator|=
name|ServerMode
expr_stmt|;
name|serverObject
operator|=
name|object
expr_stmt|;
name|object
operator|->
name|d
operator|=
name|this
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|handleError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|server
operator|=
name|s
expr_stmt|;
name|dbus_bool_t
name|data_allocated
init|=
name|q_dbus_server_allocate_data_slot
argument_list|(
operator|&
name|server_slot
argument_list|)
decl_stmt|;
if|if
condition|(
name|data_allocated
operator|&&
name|server_slot
operator|<
literal|0
condition|)
return|return;
name|dbus_bool_t
name|watch_functions_set
init|=
name|q_dbus_server_set_watch_functions
argument_list|(
name|server
argument_list|,
name|qDBusAddWatch
argument_list|,
name|qDBusRemoveWatch
argument_list|,
name|qDBusToggleWatch
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|//qDebug()<< "watch_functions_set"<< watch_functions_set;
name|Q_UNUSED
argument_list|(
name|watch_functions_set
argument_list|)
expr_stmt|;
name|dbus_bool_t
name|time_functions_set
init|=
name|q_dbus_server_set_timeout_functions
argument_list|(
name|server
argument_list|,
name|qDBusAddTimeout
argument_list|,
name|qDBusRemoveTimeout
argument_list|,
name|qDBusToggleTimeout
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|//qDebug()<< "time_functions_set"<< time_functions_set;
name|Q_UNUSED
argument_list|(
name|time_functions_set
argument_list|)
expr_stmt|;
name|q_dbus_server_set_new_connection_function
argument_list|(
name|server
argument_list|,
name|qDBusNewConnection
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbus_bool_t
name|data_set
init|=
name|q_dbus_server_set_data
argument_list|(
name|server
argument_list|,
name|server_slot
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|//qDebug()<< "data_set"<< data_set;
name|Q_UNUSED
argument_list|(
name|data_set
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setPeer
name|void
name|QDBusConnectionPrivate
operator|::
name|setPeer
parameter_list|(
name|DBusConnection
modifier|*
name|c
parameter_list|,
specifier|const
name|QDBusErrorInternal
modifier|&
name|error
parameter_list|)
block|{
name|mode
operator|=
name|PeerMode
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|handleError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|connection
operator|=
name|c
expr_stmt|;
name|q_dbus_connection_set_exit_on_disconnect
argument_list|(
name|connection
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|q_dbus_connection_set_watch_functions
argument_list|(
name|connection
argument_list|,
name|qDBusAddWatch
argument_list|,
name|qDBusRemoveWatch
argument_list|,
name|qDBusToggleWatch
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_dbus_connection_set_timeout_functions
argument_list|(
name|connection
argument_list|,
name|qDBusAddTimeout
argument_list|,
name|qDBusRemoveTimeout
argument_list|,
name|qDBusToggleTimeout
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_dbus_connection_set_dispatch_status_function
argument_list|(
name|connection
argument_list|,
name|qDBusUpdateDispatchStatus
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_dbus_connection_add_filter
argument_list|(
name|connection
argument_list|,
name|qDBusSignalFilter
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|watchForDBusDisconnection
argument_list|()
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"doDispatch"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|connectionCapabilies
specifier|static
name|QDBusConnection
operator|::
name|ConnectionCapabilities
name|connectionCapabilies
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|)
block|{
name|QDBusConnection
operator|::
name|ConnectionCapabilities
name|result
init|=
literal|0
decl_stmt|;
typedef|typedef
name|dbus_bool_t
function_decl|(
modifier|*
name|can_send_type_t
function_decl|)
parameter_list|(
name|DBusConnection
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|static
name|can_send_type_t
name|can_send_type
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_LINKED_LIBDBUS
argument_list|)
if|#
directive|if
name|DBUS_VERSION
operator|-
literal|0
operator|>=
literal|0x010400
name|can_send_type
operator|=
name|dbus_connection_can_send_type
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|QT_NO_LIBRARY
argument_list|)
comment|// run-time check if the next functions are available
name|can_send_type
operator|=
operator|(
name|can_send_type_t
operator|)
name|qdbus_resolve_conditionally
argument_list|(
literal|"dbus_connection_can_send_type"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DBUS_TYPE_UNIX_FD
DECL|macro|DBUS_TYPE_UNIX_FD
define|#
directive|define
name|DBUS_TYPE_UNIX_FD
value|int('h')
endif|#
directive|endif
if|if
condition|(
name|can_send_type
operator|&&
name|can_send_type
argument_list|(
name|connection
argument_list|,
name|DBUS_TYPE_UNIX_FD
argument_list|)
condition|)
name|result
operator||=
name|QDBusConnection
operator|::
name|UnixFileDescriptorPassing
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|setConnection
name|void
name|QDBusConnectionPrivate
operator|::
name|setConnection
parameter_list|(
name|DBusConnection
modifier|*
name|dbc
parameter_list|,
specifier|const
name|QDBusErrorInternal
modifier|&
name|error
parameter_list|)
block|{
name|mode
operator|=
name|ClientMode
expr_stmt|;
if|if
condition|(
operator|!
name|dbc
condition|)
block|{
name|handleError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|connection
operator|=
name|dbc
expr_stmt|;
specifier|const
name|char
modifier|*
name|service
init|=
name|q_dbus_bus_get_unique_name
argument_list|(
name|connection
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|baseService
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|capabilities
operator|=
name|connectionCapabilies
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|q_dbus_connection_set_exit_on_disconnect
argument_list|(
name|connection
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|q_dbus_connection_set_watch_functions
argument_list|(
name|connection
argument_list|,
name|qDBusAddWatch
argument_list|,
name|qDBusRemoveWatch
argument_list|,
name|qDBusToggleWatch
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_dbus_connection_set_timeout_functions
argument_list|(
name|connection
argument_list|,
name|qDBusAddTimeout
argument_list|,
name|qDBusRemoveTimeout
argument_list|,
name|qDBusToggleTimeout
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_dbus_connection_set_dispatch_status_function
argument_list|(
name|connection
argument_list|,
name|qDBusUpdateDispatchStatus
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_dbus_connection_add_filter
argument_list|(
name|connection
argument_list|,
name|qDBusSignalFilter
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Initialize the hooks for the NameAcquired and NameLost signals
comment|// we don't use connectSignal here because we don't need the rules to be sent to the bus
comment|// the bus will always send us these two signals
name|SignalHook
name|hook
decl_stmt|;
name|hook
operator|.
name|service
operator|=
name|QDBusUtil
operator|::
name|dbusService
argument_list|()
expr_stmt|;
name|hook
operator|.
name|path
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// no matching
name|hook
operator|.
name|obj
operator|=
name|this
expr_stmt|;
name|hook
operator|.
name|params
operator|<<
name|QMetaType
operator|::
name|Void
operator|<<
name|QVariant
operator|::
name|String
expr_stmt|;
comment|// both functions take a QString as parameter and return void
name|hook
operator|.
name|midx
operator|=
name|staticMetaObject
operator|.
name|indexOfSlot
argument_list|(
literal|"registerServiceNoLock(QString)"
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|hook
operator|.
name|midx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|signalHooks
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|"NameAcquired:"
name|DBUS_INTERFACE_DBUS
argument_list|)
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|hook
operator|.
name|midx
operator|=
name|staticMetaObject
operator|.
name|indexOfSlot
argument_list|(
literal|"unregisterServiceNoLock(QString)"
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|hook
operator|.
name|midx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|signalHooks
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|"NameLost:"
name|DBUS_INTERFACE_DBUS
argument_list|)
argument_list|,
name|hook
argument_list|)
expr_stmt|;
comment|// And initialize the hook for the NameOwnerChanged signal;
comment|// we don't use connectSignal here because the rules are added by connectSignal on a per-need basis
name|hook
operator|.
name|params
operator|.
name|clear
argument_list|()
expr_stmt|;
name|hook
operator|.
name|params
operator|.
name|reserve
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|hook
operator|.
name|params
operator|<<
name|QMetaType
operator|::
name|Void
operator|<<
name|QVariant
operator|::
name|String
operator|<<
name|QVariant
operator|::
name|String
operator|<<
name|QVariant
operator|::
name|String
expr_stmt|;
name|hook
operator|.
name|midx
operator|=
name|staticMetaObject
operator|.
name|indexOfSlot
argument_list|(
literal|"serviceOwnerChangedNoLock(QString,QString,QString)"
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|hook
operator|.
name|midx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|signalHooks
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|"NameOwnerChanged:"
name|DBUS_INTERFACE_DBUS
argument_list|)
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|watchForDBusDisconnection
argument_list|()
expr_stmt|;
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|": connected successfully"
expr_stmt|;
comment|// schedule a dispatch:
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"doDispatch"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_extern
extern|extern
literal|"C"
block|{
DECL|function|qDBusResultReceived
specifier|static
name|void
name|qDBusResultReceived
parameter_list|(
name|DBusPendingCall
modifier|*
name|pending
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|QDBusPendingCallPrivate
modifier|*
name|call
init|=
cast|reinterpret_cast
argument_list|<
name|QDBusPendingCallPrivate
operator|*
argument_list|>
argument_list|(
name|user_data
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|call
operator|->
name|pending
operator|==
name|pending
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|pending
argument_list|)
expr_stmt|;
name|QDBusConnectionPrivate
operator|::
name|processFinishedCall
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
block|}
end_extern
begin_function
DECL|function|processFinishedCall
name|void
name|QDBusConnectionPrivate
operator|::
name|processFinishedCall
parameter_list|(
name|QDBusPendingCallPrivate
modifier|*
name|call
parameter_list|)
block|{
name|QDBusConnectionPrivate
modifier|*
name|connection
init|=
cast|const_cast
argument_list|<
name|QDBusConnectionPrivate
operator|*
argument_list|>
argument_list|(
name|call
operator|->
name|connection
argument_list|)
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|call
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|connection
operator|->
name|pendingCalls
operator|.
name|removeOne
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|QDBusMessage
modifier|&
name|msg
init|=
name|call
operator|->
name|replyMessage
decl_stmt|;
if|if
condition|(
name|call
operator|->
name|pending
condition|)
block|{
comment|// when processFinishedCall is called and pending call is not completed,
comment|// it means we received disconnected signal from libdbus
if|if
condition|(
name|q_dbus_pending_call_get_completed
argument_list|(
name|call
operator|->
name|pending
argument_list|)
condition|)
block|{
comment|// decode the message
name|DBusMessage
modifier|*
name|reply
init|=
name|q_dbus_pending_call_steal_reply
argument_list|(
name|call
operator|->
name|pending
argument_list|)
decl_stmt|;
name|msg
operator|=
name|QDBusMessagePrivate
operator|::
name|fromDBusMessage
argument_list|(
name|reply
argument_list|,
name|connection
operator|->
name|capabilities
argument_list|)
expr_stmt|;
name|q_dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|QDBusError
operator|::
name|Disconnected
argument_list|,
name|QDBusUtil
operator|::
name|disconnectedErrorMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|qDBusDebug
argument_list|()
operator|<<
name|connection
operator|<<
literal|"got message reply:"
operator|<<
name|msg
expr_stmt|;
comment|// Check if the reply has the expected signature
name|call
operator|->
name|checkReceivedSignature
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|call
operator|->
name|receiver
operator|.
name|isNull
argument_list|()
operator|&&
name|call
operator|->
name|methodIdx
operator|!=
operator|-
literal|1
operator|&&
name|msg
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ReplyMessage
condition|)
block|{
comment|// Deliver the return values of a remote function call.
comment|//
comment|// There is only one connection and it is specified by idx
comment|// The slot must have the same parameter types that the message does
comment|// The slot may have less parameters than the message
comment|// The slot may optionally have one final parameter that is QDBusMessage
comment|// The slot receives read-only copies of the message (i.e., pass by value or by const-ref)
name|QDBusCallDeliveryEvent
modifier|*
name|e
init|=
name|prepareReply
argument_list|(
name|connection
argument_list|,
name|call
operator|->
name|receiver
argument_list|,
name|call
operator|->
name|methodIdx
argument_list|,
name|call
operator|->
name|metaTypes
argument_list|,
name|msg
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
condition|)
name|connection
operator|->
name|postEventToThread
argument_list|(
name|MessageResultReceivedAction
argument_list|,
name|call
operator|->
name|receiver
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|qDBusDebug
argument_list|(
literal|"Deliver failed!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|call
operator|->
name|pending
condition|)
block|{
name|q_dbus_pending_call_unref
argument_list|(
name|call
operator|->
name|pending
argument_list|)
expr_stmt|;
name|call
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
block|}
comment|// Are there any watchers?
if|if
condition|(
name|call
operator|->
name|watcherHelper
condition|)
name|call
operator|->
name|watcherHelper
operator|->
name|emitSignals
argument_list|(
name|msg
argument_list|,
name|call
operator|->
name|sentMessage
argument_list|)
expr_stmt|;
name|call
operator|->
name|waitForFinishedCondition
operator|.
name|wakeAll
argument_list|()
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ErrorMessage
condition|)
emit|emit
name|connection
operator|->
name|callWithCallbackFailed
argument_list|(
name|QDBusError
argument_list|(
name|msg
argument_list|)
argument_list|,
name|call
operator|->
name|sentMessage
argument_list|)
emit|;
if|if
condition|(
operator|!
name|call
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|call
expr_stmt|;
block|}
end_function
begin_function
DECL|function|send
name|bool
name|QDBusConnectionPrivate
operator|::
name|send
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|)
block|{
if|if
condition|(
name|QDBusMessagePrivate
operator|::
name|isLocal
argument_list|(
name|message
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// don't send; the reply will be retrieved by the caller
comment|// through the d_ptr->localReply link
name|QDBusError
name|error
decl_stmt|;
name|DBusMessage
modifier|*
name|msg
init|=
name|QDBusMessagePrivate
operator|::
name|toDBusMessage
argument_list|(
name|message
argument_list|,
name|capabilities
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
block|{
if|if
condition|(
name|message
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|MethodCallMessage
condition|)
name|qWarning
argument_list|(
literal|"QDBusConnection: error: could not send message to service \"%s\" path \"%s\" interface \"%s\" member \"%s\": %s"
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|service
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|path
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|interface
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|member
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|error
operator|.
name|message
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|message
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|SignalMessage
condition|)
name|qWarning
argument_list|(
literal|"QDBusConnection: error: could not send signal to service \"%s\" path \"%s\" interface \"%s\" member \"%s\": %s"
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|service
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|path
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|interface
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|member
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|error
operator|.
name|message
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QDBusConnection: error: could not send %s message to service \"%s\": %s"
argument_list|,
name|message
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ReplyMessage
condition|?
literal|"reply"
else|:
name|message
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ErrorMessage
condition|?
literal|"error"
else|:
literal|"invalid"
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|service
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|error
operator|.
name|message
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|lastError
operator|=
name|error
expr_stmt|;
return|return
literal|false
return|;
block|}
name|q_dbus_message_set_no_reply
argument_list|(
name|msg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// the reply would not be delivered to anything
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"sending message (no reply):"
operator|<<
name|message
expr_stmt|;
emit|emit
name|messageNeedsSending
argument_list|(
name|Q_NULLPTR
argument_list|,
name|msg
argument_list|)
emit|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// small helper to note long running blocking dbus calls.
end_comment
begin_comment
comment|// these are generally a sign of fragile software (too long a call can either
end_comment
begin_comment
comment|// lead to bad user experience, if it's running on the GUI thread for instance)
end_comment
begin_comment
comment|// or break completely under load (hitting the call timeout).
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// as a result, this is something we want to watch for.
end_comment
begin_class
DECL|class|QDBusBlockingCallWatcher
class|class
name|QDBusBlockingCallWatcher
block|{
public|public:
DECL|function|QDBusBlockingCallWatcher
name|QDBusBlockingCallWatcher
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|)
member_init_list|:
name|m_message
argument_list|(
name|message
argument_list|)
member_init_list|,
name|m_maxCallTimeoutMs
argument_list|(
literal|0
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
comment|// when in a release build, we default these to off.
comment|// this means that we only affect code that explicitly enables the warning.
specifier|static
name|int
name|mainThreadWarningAmount
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|int
name|otherThreadWarningAmount
init|=
operator|-
literal|1
decl_stmt|;
else|#
directive|else
specifier|static
name|int
name|mainThreadWarningAmount
init|=
literal|200
decl_stmt|;
specifier|static
name|int
name|otherThreadWarningAmount
init|=
literal|500
decl_stmt|;
endif|#
directive|endif
specifier|static
name|bool
name|initializedAmounts
init|=
literal|false
decl_stmt|;
specifier|static
name|QBasicMutex
name|initializeMutex
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|initializeMutex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|initializedAmounts
condition|)
block|{
name|int
name|tmp
init|=
literal|0
decl_stmt|;
name|QByteArray
name|env
decl_stmt|;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
name|env
operator|=
name|qgetenv
argument_list|(
literal|"Q_DBUS_BLOCKING_CALL_MAIN_THREAD_WARNING_MS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|env
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|env
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
name|mainThreadWarningAmount
operator|=
name|tmp
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QDBusBlockingCallWatcher: Q_DBUS_BLOCKING_CALL_MAIN_THREAD_WARNING_MS must be an integer; value ignored"
argument_list|)
expr_stmt|;
block|}
name|env
operator|=
name|qgetenv
argument_list|(
literal|"Q_DBUS_BLOCKING_CALL_OTHER_THREAD_WARNING_MS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|env
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|env
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
name|otherThreadWarningAmount
operator|=
name|tmp
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QDBusBlockingCallWatcher: Q_DBUS_BLOCKING_CALL_OTHER_THREAD_WARNING_MS must be an integer; value ignored"
argument_list|)
expr_stmt|;
block|}
name|initializedAmounts
operator|=
literal|true
expr_stmt|;
block|}
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// if this call is running on the main thread, we have a much lower
comment|// tolerance for delay because any long-term delay will wreck user
comment|// interactivity.
if|if
condition|(
name|qApp
operator|&&
name|qApp
operator|->
name|thread
argument_list|()
operator|==
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
name|m_maxCallTimeoutMs
operator|=
name|mainThreadWarningAmount
expr_stmt|;
else|else
name|m_maxCallTimeoutMs
operator|=
name|otherThreadWarningAmount
expr_stmt|;
name|m_callTimer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|function|~QDBusBlockingCallWatcher
name|~
name|QDBusBlockingCallWatcher
parameter_list|()
block|{
if|if
condition|(
name|m_maxCallTimeoutMs
operator|<
literal|0
condition|)
return|return;
comment|// disabled
if|if
condition|(
name|m_callTimer
operator|.
name|elapsed
argument_list|()
operator|>=
name|m_maxCallTimeoutMs
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDBusConnection: warning: blocking call took a long time (%d ms, max for this thread is %d ms) to service \"%s\" path \"%s\" interface \"%s\" member \"%s\""
argument_list|,
name|int
argument_list|(
name|m_callTimer
operator|.
name|elapsed
argument_list|()
argument_list|)
argument_list|,
name|m_maxCallTimeoutMs
argument_list|,
name|qPrintable
argument_list|(
name|m_message
operator|.
name|service
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|m_message
operator|.
name|path
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|m_message
operator|.
name|interface
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|m_message
operator|.
name|member
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
private|private:
DECL|member|m_message
name|QDBusMessage
name|m_message
decl_stmt|;
DECL|member|m_maxCallTimeoutMs
name|int
name|m_maxCallTimeoutMs
decl_stmt|;
DECL|member|m_callTimer
name|QElapsedTimer
name|m_callTimer
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|sendWithReply
name|QDBusMessage
name|QDBusConnectionPrivate
operator|::
name|sendWithReply
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|,
name|int
name|sendMode
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|QDBusBlockingCallWatcher
name|watcher
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|QDBusPendingCallPrivate
modifier|*
name|pcall
init|=
name|sendWithReplyAsync
argument_list|(
name|message
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|pcall
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcall
operator|->
name|replyMessage
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|InvalidMessage
condition|)
block|{
comment|// need to wait for the reply
if|if
condition|(
name|sendMode
operator|==
name|QDBus
operator|::
name|BlockWithGui
condition|)
block|{
name|pcall
operator|->
name|watcherHelper
operator|=
operator|new
name|QDBusPendingCallWatcherHelper
expr_stmt|;
name|QEventLoop
name|loop
decl_stmt|;
name|loop
operator|.
name|connect
argument_list|(
name|pcall
operator|->
name|watcherHelper
argument_list|,
operator|&
name|QDBusPendingCallWatcherHelper
operator|::
name|reply
argument_list|,
operator|&
name|loop
argument_list|,
operator|&
name|QEventLoop
operator|::
name|quit
argument_list|)
expr_stmt|;
name|loop
operator|.
name|connect
argument_list|(
name|pcall
operator|->
name|watcherHelper
argument_list|,
operator|&
name|QDBusPendingCallWatcherHelper
operator|::
name|error
argument_list|,
operator|&
name|loop
argument_list|,
operator|&
name|QEventLoop
operator|::
name|quit
argument_list|)
expr_stmt|;
comment|// enter the event loop and wait for a reply
name|loop
operator|.
name|exec
argument_list|(
name|QEventLoop
operator|::
name|ExcludeUserInputEvents
operator||
name|QEventLoop
operator|::
name|WaitForMoreEvents
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcall
operator|->
name|waitForFinished
argument_list|()
expr_stmt|;
block|}
block|}
name|QDBusMessage
name|reply
init|=
name|pcall
operator|->
name|replyMessage
decl_stmt|;
name|lastError
operator|=
name|QDBusError
argument_list|(
name|reply
argument_list|)
expr_stmt|;
comment|// set or clear error
if|if
condition|(
operator|!
name|pcall
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|pcall
expr_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_function
DECL|function|sendWithReplyLocal
name|QDBusMessage
name|QDBusConnectionPrivate
operator|::
name|sendWithReplyLocal
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|)
block|{
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"sending message via local-loop:"
operator|<<
name|message
expr_stmt|;
name|QDBusMessage
name|localCallMsg
init|=
name|QDBusMessagePrivate
operator|::
name|makeLocal
argument_list|(
operator|*
name|this
argument_list|,
name|message
argument_list|)
decl_stmt|;
name|bool
name|handled
init|=
name|handleMessage
argument_list|(
name|localCallMsg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|handled
condition|)
block|{
name|QString
name|interface
init|=
name|message
operator|.
name|interface
argument_list|()
decl_stmt|;
if|if
condition|(
name|interface
operator|.
name|isEmpty
argument_list|()
condition|)
name|interface
operator|=
name|QLatin1String
argument_list|(
literal|"<no-interface>"
argument_list|)
expr_stmt|;
return|return
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|QDBusError
operator|::
name|InternalError
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Internal error trying to call %1.%2 at %3 (signature '%4'"
argument_list|)
operator|.
name|arg
argument_list|(
name|interface
argument_list|,
name|message
operator|.
name|member
argument_list|()
argument_list|,
name|message
operator|.
name|path
argument_list|()
argument_list|,
name|message
operator|.
name|signature
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|// if the message was handled, there might be a reply
name|QDBusMessage
name|localReplyMsg
init|=
name|QDBusMessagePrivate
operator|::
name|makeLocalReply
argument_list|(
operator|*
name|this
argument_list|,
name|localCallMsg
argument_list|)
decl_stmt|;
if|if
condition|(
name|localReplyMsg
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|InvalidMessage
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDBusConnection: cannot call local method '%s' at object %s (with signature '%s') "
literal|"on blocking mode"
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|member
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|path
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|signature
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|InternalError
argument_list|,
name|QLatin1String
argument_list|(
literal|"local-loop message cannot have delayed replies"
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|// there is a reply
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"got message via local-loop:"
operator|<<
name|localReplyMsg
expr_stmt|;
return|return
name|localReplyMsg
return|;
block|}
end_function
begin_function
DECL|function|sendWithReplyAsync
name|QDBusPendingCallPrivate
modifier|*
name|QDBusConnectionPrivate
operator|::
name|sendWithReplyAsync
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|returnMethod
parameter_list|,
specifier|const
name|char
modifier|*
name|errorMethod
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|QDBusPendingCallPrivate
modifier|*
name|pcall
init|=
operator|new
name|QDBusPendingCallPrivate
argument_list|(
name|message
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|bool
name|isLoopback
decl_stmt|;
if|if
condition|(
operator|(
name|isLoopback
operator|=
name|isServiceRegisteredByThread
argument_list|(
name|message
operator|.
name|service
argument_list|()
argument_list|)
operator|)
condition|)
block|{
comment|// special case for local calls
name|pcall
operator|->
name|replyMessage
operator|=
name|sendWithReplyLocal
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|receiver
operator|&&
name|returnMethod
condition|)
name|pcall
operator|->
name|setReplyCallback
argument_list|(
name|receiver
argument_list|,
name|returnMethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorMethod
condition|)
block|{
name|pcall
operator|->
name|watcherHelper
operator|=
operator|new
name|QDBusPendingCallWatcherHelper
expr_stmt|;
name|connect
argument_list|(
name|pcall
operator|->
name|watcherHelper
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QDBusError
argument_list|,
name|QDBusMessage
argument_list|)
argument_list|)
argument_list|,
name|receiver
argument_list|,
name|errorMethod
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|pcall
operator|->
name|watcherHelper
operator|->
name|moveToThread
argument_list|(
name|thread
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|receiver
operator|&&
name|returnMethod
operator|)
operator|||
name|errorMethod
condition|)
block|{
comment|// no one waiting, will delete pcall in processFinishedCall()
name|pcall
operator|->
name|ref
operator|.
name|store
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// set double ref to prevent race between processFinishedCall() and ref counting
comment|// by QDBusPendingCall::QExplicitlySharedDataPointer<QDBusPendingCallPrivate>
name|pcall
operator|->
name|ref
operator|.
name|store
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isLoopback
condition|)
block|{
comment|// a loopback call
name|processFinishedCall
argument_list|(
name|pcall
argument_list|)
expr_stmt|;
return|return
name|pcall
return|;
block|}
name|QDBusError
name|error
decl_stmt|;
name|DBusMessage
modifier|*
name|msg
init|=
name|QDBusMessagePrivate
operator|::
name|toDBusMessage
argument_list|(
name|message
argument_list|,
name|capabilities
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDBusConnection: error: could not send message to service \"%s\" path \"%s\" interface \"%s\" member \"%s\": %s"
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|service
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|path
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|interface
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|message
operator|.
name|member
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|error
operator|.
name|message
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pcall
operator|->
name|replyMessage
operator|=
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|lastError
operator|=
name|error
expr_stmt|;
name|processFinishedCall
argument_list|(
name|pcall
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"sending message:"
operator|<<
name|message
expr_stmt|;
emit|emit
name|messageNeedsSending
argument_list|(
name|pcall
argument_list|,
name|msg
argument_list|,
name|timeout
argument_list|)
emit|;
block|}
return|return
name|pcall
return|;
block|}
end_function
begin_function
DECL|function|sendInternal
name|void
name|QDBusConnectionPrivate
operator|::
name|sendInternal
parameter_list|(
name|QDBusPendingCallPrivate
modifier|*
name|pcall
parameter_list|,
name|void
modifier|*
name|message
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|QDBusError
name|error
decl_stmt|;
name|DBusPendingCall
modifier|*
name|pending
init|=
literal|0
decl_stmt|;
name|DBusMessage
modifier|*
name|msg
init|=
cast|static_cast
argument_list|<
name|DBusMessage
operator|*
argument_list|>
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|bool
name|isNoReply
init|=
operator|!
name|pcall
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|isNoReply
operator|==
operator|!
operator|!
name|q_dbus_message_get_no_reply
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|checkThread
argument_list|()
expr_stmt|;
name|QDBusDispatchLocker
name|locker
argument_list|(
name|SendMessageAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNoReply
operator|&&
name|q_dbus_connection_send
argument_list|(
name|connection
argument_list|,
name|msg
argument_list|,
name|Q_NULLPTR
argument_list|)
condition|)
block|{
comment|// success
block|}
elseif|else
if|if
condition|(
operator|!
name|isNoReply
operator|&&
name|q_dbus_connection_send_with_reply
argument_list|(
name|connection
argument_list|,
name|msg
argument_list|,
operator|&
name|pending
argument_list|,
name|timeout
argument_list|)
condition|)
block|{
if|if
condition|(
name|pending
condition|)
block|{
name|q_dbus_message_unref
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|pcall
operator|->
name|pending
operator|=
name|pending
expr_stmt|;
name|q_dbus_pending_call_set_notify
argument_list|(
name|pending
argument_list|,
name|qDBusResultReceived
argument_list|,
name|pcall
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// DBus won't notify us when a peer disconnects or server terminates so we need to track these ourselves
if|if
condition|(
name|mode
operator|==
name|QDBusConnectionPrivate
operator|::
name|PeerMode
operator|||
name|mode
operator|==
name|QDBusConnectionPrivate
operator|::
name|ClientMode
condition|)
name|pendingCalls
operator|.
name|append
argument_list|(
name|pcall
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|// we're probably disconnected at this point
name|lastError
operator|=
name|error
operator|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|Disconnected
argument_list|,
name|QDBusUtil
operator|::
name|disconnectedErrorMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lastError
operator|=
name|error
operator|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|NoMemory
argument_list|,
name|QStringLiteral
argument_list|(
literal|"Out of memory"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|q_dbus_message_unref
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcall
condition|)
block|{
name|pcall
operator|->
name|replyMessage
operator|=
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|processFinishedCall
argument_list|(
name|pcall
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|connectSignal
name|bool
name|QDBusConnectionPrivate
operator|::
name|connectSignal
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|argumentMatch
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
comment|// check the slot
name|QDBusConnectionPrivate
operator|::
name|SignalHook
name|hook
decl_stmt|;
name|QString
name|key
decl_stmt|;
name|QString
name|name2
init|=
name|name
decl_stmt|;
if|if
condition|(
name|name2
operator|.
name|isNull
argument_list|()
condition|)
name|name2
operator|.
name|detach
argument_list|()
expr_stmt|;
name|hook
operator|.
name|signature
operator|=
name|signature
expr_stmt|;
if|if
condition|(
operator|!
name|prepareHook
argument_list|(
name|hook
argument_list|,
name|key
argument_list|,
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|argumentMatch
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// don't connect
name|Q_ASSERT
argument_list|(
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
emit|emit
name|signalNeedsConnecting
argument_list|(
name|key
argument_list|,
name|hook
argument_list|)
emit|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|addSignalHook
name|void
name|QDBusConnectionPrivate
operator|::
name|addSignalHook
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|SignalHook
modifier|&
name|hook
parameter_list|)
block|{
name|QDBusWriteLocker
name|locker
argument_list|(
name|ConnectAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
comment|// avoid duplicating:
name|QDBusConnectionPrivate
operator|::
name|SignalHookHash
operator|::
name|ConstIterator
name|it
init|=
name|signalHooks
operator|.
name|constFind
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|SignalHookHash
operator|::
name|ConstIterator
name|end
init|=
name|signalHooks
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|key
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QDBusConnectionPrivate
operator|::
name|SignalHook
modifier|&
name|entry
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|service
operator|==
name|hook
operator|.
name|service
operator|&&
name|entry
operator|.
name|path
operator|==
name|hook
operator|.
name|path
operator|&&
name|entry
operator|.
name|signature
operator|==
name|hook
operator|.
name|signature
operator|&&
name|entry
operator|.
name|obj
operator|==
name|hook
operator|.
name|obj
operator|&&
name|entry
operator|.
name|midx
operator|==
name|hook
operator|.
name|midx
operator|&&
name|entry
operator|.
name|argumentMatch
operator|==
name|hook
operator|.
name|argumentMatch
condition|)
block|{
comment|// no need to compare the parameters if it's the same slot
return|return;
comment|// already there
block|}
block|}
name|signalHooks
operator|.
name|insertMulti
argument_list|(
name|key
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|hook
operator|.
name|obj
argument_list|,
operator|&
name|QObject
operator|::
name|destroyed
argument_list|,
name|this
argument_list|,
operator|&
name|QDBusConnectionPrivate
operator|::
name|objectDestroyed
argument_list|,
name|Qt
operator|::
name|ConnectionType
argument_list|(
name|Qt
operator|::
name|BlockingQueuedConnection
operator||
name|Qt
operator|::
name|UniqueConnection
argument_list|)
argument_list|)
expr_stmt|;
name|MatchRefCountHash
operator|::
name|iterator
name|mit
init|=
name|matchRefCounts
operator|.
name|find
argument_list|(
name|hook
operator|.
name|matchRule
argument_list|)
decl_stmt|;
if|if
condition|(
name|mit
operator|!=
name|matchRefCounts
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// Match already present
name|mit
operator|.
name|value
argument_list|()
operator|=
name|mit
operator|.
name|value
argument_list|()
operator|+
literal|1
expr_stmt|;
return|return;
block|}
name|matchRefCounts
operator|.
name|insert
argument_list|(
name|hook
operator|.
name|matchRule
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|QDBusConnectionPrivate
operator|::
name|PeerMode
condition|)
block|{
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"Adding rule:"
operator|<<
name|hook
operator|.
name|matchRule
expr_stmt|;
name|q_dbus_bus_add_match
argument_list|(
name|connection
argument_list|,
name|hook
operator|.
name|matchRule
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|// Successfully connected the signal
comment|// Do we need to watch for this name?
if|if
condition|(
name|shouldWatchService
argument_list|(
name|hook
operator|.
name|service
argument_list|)
condition|)
block|{
name|WatchedServicesHash
operator|::
name|mapped_type
modifier|&
name|data
init|=
name|watchedServices
index|[
name|hook
operator|.
name|service
index|]
decl_stmt|;
if|if
condition|(
operator|++
name|data
operator|.
name|refcount
operator|==
literal|1
condition|)
block|{
comment|// we need to watch for this service changing
name|q_dbus_bus_add_match
argument_list|(
name|connection
argument_list|,
name|buildMatchRule
argument_list|(
name|QDBusUtil
operator|::
name|dbusService
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QDBusUtil
operator|::
name|dbusInterface
argument_list|()
argument_list|,
name|QDBusUtil
operator|::
name|nameOwnerChanged
argument_list|()
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|hook
operator|.
name|service
argument_list|,
name|QString
argument_list|()
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|data
operator|.
name|owner
operator|=
name|getNameOwnerNoCache
argument_list|(
name|hook
operator|.
name|service
argument_list|)
expr_stmt|;
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"Watching service"
operator|<<
name|hook
operator|.
name|service
operator|<<
literal|"for owner changes (current owner:"
operator|<<
name|data
operator|.
name|owner
operator|<<
literal|")"
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|disconnectSignal
name|bool
name|QDBusConnectionPrivate
operator|::
name|disconnectSignal
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|argumentMatch
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
comment|// check the slot
name|QDBusConnectionPrivate
operator|::
name|SignalHook
name|hook
decl_stmt|;
name|QString
name|key
decl_stmt|;
name|QString
name|name2
init|=
name|name
decl_stmt|;
if|if
condition|(
name|name2
operator|.
name|isNull
argument_list|()
condition|)
name|name2
operator|.
name|detach
argument_list|()
expr_stmt|;
name|hook
operator|.
name|signature
operator|=
name|signature
expr_stmt|;
if|if
condition|(
operator|!
name|prepareHook
argument_list|(
name|hook
argument_list|,
name|key
argument_list|,
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|argumentMatch
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// don't disconnect
name|Q_ASSERT
argument_list|(
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
return|return
emit|emit
name|signalNeedsDisconnecting
argument_list|(
name|key
argument_list|,
name|hook
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|removeSignalHook
name|bool
name|QDBusConnectionPrivate
operator|::
name|removeSignalHook
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|SignalHook
modifier|&
name|hook
parameter_list|)
block|{
comment|// remove it from our list:
name|QDBusWriteLocker
name|locker
argument_list|(
name|ConnectAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|SignalHookHash
operator|::
name|Iterator
name|it
init|=
name|signalHooks
operator|.
name|find
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|SignalHookHash
operator|::
name|Iterator
name|end
init|=
name|signalHooks
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|key
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QDBusConnectionPrivate
operator|::
name|SignalHook
modifier|&
name|entry
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|service
operator|==
name|hook
operator|.
name|service
operator|&&
name|entry
operator|.
name|path
operator|==
name|hook
operator|.
name|path
operator|&&
name|entry
operator|.
name|signature
operator|==
name|hook
operator|.
name|signature
operator|&&
name|entry
operator|.
name|obj
operator|==
name|hook
operator|.
name|obj
operator|&&
name|entry
operator|.
name|midx
operator|==
name|hook
operator|.
name|midx
operator|&&
name|entry
operator|.
name|argumentMatch
operator|==
name|hook
operator|.
name|argumentMatch
condition|)
block|{
comment|// no need to compare the parameters if it's the same slot
name|removeSignalHookNoLock
argument_list|(
name|it
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// it was there
block|}
block|}
comment|// the slot was not found
return|return
literal|false
return|;
block|}
end_function
begin_function
name|QDBusConnectionPrivate
operator|::
name|SignalHookHash
operator|::
name|Iterator
DECL|function|removeSignalHookNoLock
name|QDBusConnectionPrivate
operator|::
name|removeSignalHookNoLock
parameter_list|(
name|SignalHookHash
operator|::
name|Iterator
name|it
parameter_list|)
block|{
specifier|const
name|SignalHook
modifier|&
name|hook
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|bool
name|erase
init|=
literal|false
decl_stmt|;
name|MatchRefCountHash
operator|::
name|iterator
name|i
init|=
name|matchRefCounts
operator|.
name|find
argument_list|(
name|hook
operator|.
name|matchRule
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|matchRefCounts
operator|.
name|end
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDBusConnectionPrivate::disconnectSignal: MatchRule not found in matchRefCounts!!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|.
name|value
argument_list|()
operator|==
literal|1
condition|)
block|{
name|erase
operator|=
literal|true
expr_stmt|;
name|matchRefCounts
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|value
argument_list|()
operator|=
name|i
operator|.
name|value
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|// we don't care about errors here
if|if
condition|(
name|connection
operator|&&
name|erase
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|QDBusConnectionPrivate
operator|::
name|PeerMode
condition|)
block|{
name|qDBusDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|"Removing rule:"
operator|<<
name|hook
operator|.
name|matchRule
expr_stmt|;
name|q_dbus_bus_remove_match
argument_list|(
name|connection
argument_list|,
name|hook
operator|.
name|matchRule
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|// Successfully disconnected the signal
comment|// Were we watching for this name?
name|WatchedServicesHash
operator|::
name|Iterator
name|sit
init|=
name|watchedServices
operator|.
name|find
argument_list|(
name|hook
operator|.
name|service
argument_list|)
decl_stmt|;
if|if
condition|(
name|sit
operator|!=
name|watchedServices
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|--
name|sit
operator|.
name|value
argument_list|()
operator|.
name|refcount
operator|==
literal|0
condition|)
block|{
name|watchedServices
operator|.
name|erase
argument_list|(
name|sit
argument_list|)
expr_stmt|;
name|q_dbus_bus_remove_match
argument_list|(
name|connection
argument_list|,
name|buildMatchRule
argument_list|(
name|QDBusUtil
operator|::
name|dbusService
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QDBusUtil
operator|::
name|dbusInterface
argument_list|()
argument_list|,
name|QDBusUtil
operator|::
name|nameOwnerChanged
argument_list|()
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|hook
operator|.
name|service
argument_list|,
name|QString
argument_list|()
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|signalHooks
operator|.
name|erase
argument_list|(
name|it
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|registerObject
name|void
name|QDBusConnectionPrivate
operator|::
name|registerObject
parameter_list|(
specifier|const
name|ObjectTreeNode
modifier|*
name|node
parameter_list|)
block|{
name|connect
argument_list|(
name|node
operator|->
name|obj
argument_list|,
operator|&
name|QObject
operator|::
name|destroyed
argument_list|,
name|this
argument_list|,
operator|&
name|QDBusConnectionPrivate
operator|::
name|objectDestroyed
argument_list|,
name|Qt
operator|::
name|ConnectionType
argument_list|(
name|Qt
operator|::
name|BlockingQueuedConnection
operator||
name|Qt
operator|::
name|UniqueConnection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
operator|(
name|QDBusConnection
operator|::
name|ExportAdaptors
operator||
name|QDBusConnection
operator|::
name|ExportScriptableSignals
operator||
name|QDBusConnection
operator|::
name|ExportNonScriptableSignals
operator|)
condition|)
block|{
name|QDBusAdaptorConnector
modifier|*
name|connector
init|=
name|qDBusCreateAdaptorConnector
argument_list|(
name|node
operator|->
name|obj
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
operator|(
name|QDBusConnection
operator|::
name|ExportScriptableSignals
operator||
name|QDBusConnection
operator|::
name|ExportNonScriptableSignals
operator|)
condition|)
block|{
name|connector
operator|->
name|disconnectAllSignals
argument_list|(
name|node
operator|->
name|obj
argument_list|)
expr_stmt|;
name|connector
operator|->
name|connectAllSignals
argument_list|(
name|node
operator|->
name|obj
argument_list|)
expr_stmt|;
block|}
comment|// disconnect and reconnect to avoid duplicates
name|connector
operator|->
name|disconnect
argument_list|(
name|SIGNAL
argument_list|(
name|relaySignal
argument_list|(
name|QObject
operator|*
argument_list|,
specifier|const
name|QMetaObject
operator|*
argument_list|,
name|int
argument_list|,
name|QVariantList
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|relaySignal
argument_list|(
name|QObject
operator|*
argument_list|,
specifier|const
name|QMetaObject
operator|*
argument_list|,
name|int
argument_list|,
name|QVariantList
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|connector
argument_list|,
name|SIGNAL
argument_list|(
name|relaySignal
argument_list|(
name|QObject
operator|*
argument_list|,
specifier|const
name|QMetaObject
operator|*
argument_list|,
name|int
argument_list|,
name|QVariantList
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|relaySignal
argument_list|(
name|QObject
operator|*
argument_list|,
specifier|const
name|QMetaObject
operator|*
argument_list|,
name|int
argument_list|,
name|QVariantList
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|unregisterObject
name|void
name|QDBusConnectionPrivate
operator|::
name|unregisterObject
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|QDBusConnection
operator|::
name|UnregisterMode
name|mode
parameter_list|)
block|{
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|*
name|node
init|=
operator|&
name|rootNode
decl_stmt|;
name|QVector
argument_list|<
name|QStringRef
argument_list|>
name|pathComponents
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pathComponents
operator|=
name|path
operator|.
name|splitRef
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
name|huntAndUnregister
argument_list|(
name|pathComponents
argument_list|,
name|i
argument_list|,
name|mode
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|connectRelay
name|void
name|QDBusConnectionPrivate
operator|::
name|connectRelay
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
name|QDBusAbstractInterface
modifier|*
name|receiver
parameter_list|,
specifier|const
name|QMetaMethod
modifier|&
name|signal
parameter_list|)
block|{
comment|// this function is called by QDBusAbstractInterface when one of its signals is connected
comment|// we set up a relay from D-Bus into it
name|SignalHook
name|hook
decl_stmt|;
name|QString
name|key
decl_stmt|;
name|QByteArray
name|sig
decl_stmt|;
name|sig
operator|.
name|append
argument_list|(
name|QSIGNAL_CODE
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|sig
operator|.
name|append
argument_list|(
name|signal
operator|.
name|methodSignature
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prepareHook
argument_list|(
name|hook
argument_list|,
name|key
argument_list|,
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QStringList
argument_list|()
argument_list|,
name|receiver
argument_list|,
name|sig
argument_list|,
name|QDBusAbstractInterface
operator|::
name|staticMetaObject
operator|.
name|methodCount
argument_list|()
argument_list|,
literal|true
argument_list|)
condition|)
return|return;
comment|// don't connect
name|Q_ASSERT
argument_list|(
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
emit|emit
name|signalNeedsConnecting
argument_list|(
name|key
argument_list|,
name|hook
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|disconnectRelay
name|void
name|QDBusConnectionPrivate
operator|::
name|disconnectRelay
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
name|QDBusAbstractInterface
modifier|*
name|receiver
parameter_list|,
specifier|const
name|QMetaMethod
modifier|&
name|signal
parameter_list|)
block|{
comment|// this function is called by QDBusAbstractInterface when one of its signals is disconnected
comment|// we remove relay from D-Bus into it
name|SignalHook
name|hook
decl_stmt|;
name|QString
name|key
decl_stmt|;
name|QByteArray
name|sig
decl_stmt|;
name|sig
operator|.
name|append
argument_list|(
name|QSIGNAL_CODE
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|sig
operator|.
name|append
argument_list|(
name|signal
operator|.
name|methodSignature
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prepareHook
argument_list|(
name|hook
argument_list|,
name|key
argument_list|,
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QStringList
argument_list|()
argument_list|,
name|receiver
argument_list|,
name|sig
argument_list|,
name|QDBusAbstractInterface
operator|::
name|staticMetaObject
operator|.
name|methodCount
argument_list|()
argument_list|,
literal|true
argument_list|)
condition|)
return|return;
comment|// don't disconnect
name|Q_ASSERT
argument_list|(
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
emit|emit
name|signalNeedsDisconnecting
argument_list|(
name|key
argument_list|,
name|hook
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|shouldWatchService
name|bool
name|QDBusConnectionPrivate
operator|::
name|shouldWatchService
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|)
block|{
comment|// we don't have to watch anything in peer mode
if|if
condition|(
name|mode
operator|!=
name|ClientMode
condition|)
return|return
literal|false
return|;
comment|// we don't have to watch wildcard services (empty strings)
if|if
condition|(
name|service
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// we don't have to watch the bus driver
if|if
condition|(
name|service
operator|==
name|QDBusUtil
operator|::
name|dbusService
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Sets up a watch rule for service \a service for the change described by     mode \a mode. When the change happens, slot \a member in object \a obj will     be called.      The caller should call QDBusConnectionPrivate::shouldWatchService() before     calling this function to check whether the service needs to be watched at     all. Failing to do so may add rules that are never activated. */
end_comment
begin_function
DECL|function|watchService
name|void
name|QDBusConnectionPrivate
operator|::
name|watchService
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
name|QDBusServiceWatcher
operator|::
name|WatchMode
name|mode
parameter_list|,
name|QObject
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|member
parameter_list|)
block|{
name|QStringList
name|matchArgs
init|=
name|matchArgsForService
argument_list|(
name|service
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|connectSignal
argument_list|(
name|QDBusUtil
operator|::
name|dbusService
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QDBusUtil
operator|::
name|dbusInterface
argument_list|()
argument_list|,
name|QDBusUtil
operator|::
name|nameOwnerChanged
argument_list|()
argument_list|,
name|matchArgs
argument_list|,
name|QString
argument_list|()
argument_list|,
name|obj
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes a watch rule set up by QDBusConnectionPrivate::watchService(). The     arguments to this function must be the same as the ones for that function.      Sets up a watch rule for service \a service for the change described by     mode \a mode. When the change happens, slot \a member in object \a obj will     be called. */
end_comment
begin_function
DECL|function|unwatchService
name|void
name|QDBusConnectionPrivate
operator|::
name|unwatchService
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
name|QDBusServiceWatcher
operator|::
name|WatchMode
name|mode
parameter_list|,
name|QObject
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|member
parameter_list|)
block|{
name|QStringList
name|matchArgs
init|=
name|matchArgsForService
argument_list|(
name|service
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|disconnectSignal
argument_list|(
name|QDBusUtil
operator|::
name|dbusService
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QDBusUtil
operator|::
name|dbusInterface
argument_list|()
argument_list|,
name|QDBusUtil
operator|::
name|nameOwnerChanged
argument_list|()
argument_list|,
name|matchArgs
argument_list|,
name|QString
argument_list|()
argument_list|,
name|obj
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getNameOwner
name|QString
name|QDBusConnectionPrivate
operator|::
name|getNameOwner
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
if|if
condition|(
name|QDBusUtil
operator|::
name|isValidUniqueConnectionName
argument_list|(
name|serviceName
argument_list|)
condition|)
return|return
name|serviceName
return|;
if|if
condition|(
operator|!
name|connection
condition|)
return|return
name|QString
argument_list|()
return|;
block|{
comment|// acquire a read lock for the cache
name|QReadLocker
name|locker
argument_list|(
operator|&
name|lock
argument_list|)
decl_stmt|;
name|WatchedServicesHash
operator|::
name|ConstIterator
name|it
init|=
name|watchedServices
operator|.
name|constFind
argument_list|(
name|serviceName
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|watchedServices
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|it
operator|->
name|owner
return|;
block|}
comment|// not cached
return|return
name|getNameOwnerNoCache
argument_list|(
name|serviceName
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getNameOwnerNoCache
name|QString
name|QDBusConnectionPrivate
operator|::
name|getNameOwnerNoCache
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
name|QDBusMessage
name|msg
init|=
name|QDBusMessage
operator|::
name|createMethodCall
argument_list|(
name|QDBusUtil
operator|::
name|dbusService
argument_list|()
argument_list|,
name|QDBusUtil
operator|::
name|dbusPath
argument_list|()
argument_list|,
name|QDBusUtil
operator|::
name|dbusInterface
argument_list|()
argument_list|,
name|QStringLiteral
argument_list|(
literal|"GetNameOwner"
argument_list|)
argument_list|)
decl_stmt|;
name|QDBusMessagePrivate
operator|::
name|setParametersValidated
argument_list|(
name|msg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|msg
operator|<<
name|serviceName
expr_stmt|;
name|QDBusPendingCallPrivate
modifier|*
name|pcall
init|=
name|sendWithReplyAsync
argument_list|(
name|msg
argument_list|,
name|Q_NULLPTR
argument_list|,
name|Q_NULLPTR
argument_list|,
name|Q_NULLPTR
argument_list|)
decl_stmt|;
if|if
condition|(
name|thread
argument_list|()
operator|==
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
comment|// this function may be called in our own thread and
comment|// QDBusPendingCallPrivate::waitForFinished() would deadlock there
name|q_dbus_pending_call_block
argument_list|(
name|pcall
operator|->
name|pending
argument_list|)
expr_stmt|;
block|}
name|pcall
operator|->
name|waitForFinished
argument_list|()
expr_stmt|;
name|msg
operator|=
name|pcall
operator|->
name|replyMessage
expr_stmt|;
if|if
condition|(
operator|!
name|pcall
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|pcall
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ReplyMessage
condition|)
return|return
name|msg
operator|.
name|arguments
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
name|QDBusMetaObject
modifier|*
DECL|function|findMetaObject
name|QDBusConnectionPrivate
operator|::
name|findMetaObject
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
name|QDBusError
modifier|&
name|error
parameter_list|)
block|{
comment|// service must be a unique connection name
if|if
condition|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QDBusReadLocker
name|locker
argument_list|(
name|FindMetaObject1Action
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|QDBusMetaObject
modifier|*
name|mo
init|=
name|cachedMetaObjects
operator|.
name|value
argument_list|(
name|interface
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mo
condition|)
return|return
name|mo
return|;
block|}
comment|// introspect the target object
name|QDBusMessage
name|msg
init|=
name|QDBusMessage
operator|::
name|createMethodCall
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|QDBusUtil
operator|::
name|dbusInterfaceIntrospectable
argument_list|()
argument_list|,
name|QStringLiteral
argument_list|(
literal|"Introspect"
argument_list|)
argument_list|)
decl_stmt|;
name|QDBusMessagePrivate
operator|::
name|setParametersValidated
argument_list|(
name|msg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QDBusMessage
name|reply
init|=
name|sendWithReply
argument_list|(
name|msg
argument_list|,
name|QDBus
operator|::
name|Block
argument_list|)
decl_stmt|;
comment|// it doesn't exist yet, we have to create it
name|QDBusWriteLocker
name|locker
argument_list|(
name|FindMetaObject2Action
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|QDBusMetaObject
modifier|*
name|mo
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
condition|)
name|mo
operator|=
name|cachedMetaObjects
operator|.
name|value
argument_list|(
name|interface
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mo
condition|)
comment|// maybe it got created when we switched from read to write lock
return|return
name|mo
return|;
name|QString
name|xml
decl_stmt|;
if|if
condition|(
name|reply
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ReplyMessage
condition|)
block|{
if|if
condition|(
name|reply
operator|.
name|signature
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"s"
argument_list|)
condition|)
comment|// fetch the XML description
name|xml
operator|=
name|reply
operator|.
name|arguments
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|QDBusError
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|lastError
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|reply
operator|.
name|type
argument_list|()
operator|!=
name|QDBusMessage
operator|::
name|ErrorMessage
operator|||
name|error
operator|.
name|type
argument_list|()
operator|!=
name|QDBusError
operator|::
name|UnknownMethod
condition|)
return|return
literal|0
return|;
comment|// error
block|}
comment|// release the lock and return
name|QDBusMetaObject
modifier|*
name|result
init|=
name|QDBusMetaObject
operator|::
name|createMetaObject
argument_list|(
name|interface
argument_list|,
name|xml
argument_list|,
name|cachedMetaObjects
argument_list|,
name|error
argument_list|)
decl_stmt|;
name|lastError
operator|=
name|error
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|registerService
name|void
name|QDBusConnectionPrivate
operator|::
name|registerService
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
name|QDBusWriteLocker
name|locker
argument_list|(
name|RegisterServiceAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|registerServiceNoLock
argument_list|(
name|serviceName
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|registerServiceNoLock
name|void
name|QDBusConnectionPrivate
operator|::
name|registerServiceNoLock
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
name|serviceNames
operator|.
name|append
argument_list|(
name|serviceName
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unregisterService
name|void
name|QDBusConnectionPrivate
operator|::
name|unregisterService
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
name|QDBusWriteLocker
name|locker
argument_list|(
name|UnregisterServiceAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|unregisterServiceNoLock
argument_list|(
name|serviceName
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unregisterServiceNoLock
name|void
name|QDBusConnectionPrivate
operator|::
name|unregisterServiceNoLock
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
name|serviceNames
operator|.
name|removeAll
argument_list|(
name|serviceName
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isServiceRegisteredByThread
name|bool
name|QDBusConnectionPrivate
operator|::
name|isServiceRegisteredByThread
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|serviceName
operator|.
name|isEmpty
argument_list|()
operator|&&
name|serviceName
operator|==
name|baseService
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|serviceName
operator|==
name|QDBusUtil
operator|::
name|dbusService
argument_list|()
condition|)
return|return
literal|false
return|;
name|QDBusReadLocker
name|locker
argument_list|(
name|UnregisterServiceAction
argument_list|,
name|this
argument_list|)
decl_stmt|;
return|return
name|serviceNames
operator|.
name|contains
argument_list|(
name|serviceName
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|postEventToThread
name|void
name|QDBusConnectionPrivate
operator|::
name|postEventToThread
parameter_list|(
name|int
name|action
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|,
name|QEvent
modifier|*
name|ev
parameter_list|)
block|{
name|QDBusLockerBase
operator|::
name|reportThreadAction
argument_list|(
name|action
argument_list|,
name|QDBusLockerBase
operator|::
name|BeforePost
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|object
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|QDBusLockerBase
operator|::
name|reportThreadAction
argument_list|(
name|action
argument_list|,
name|QDBusLockerBase
operator|::
name|AfterPost
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DBUS
end_comment
end_unit
