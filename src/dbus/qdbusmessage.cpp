begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtDBus module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdbusmessage.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmessage_p.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|"qdbus_symbols_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusargument_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbuserror.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmetatype.h"
end_include
begin_include
include|#
directive|include
file|"qdbusconnection_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusutil_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DBUS
end_ifndef
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|data
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|data
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|arr
parameter_list|)
block|{
return|return
name|arr
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|arr
operator|.
name|constData
argument_list|()
return|;
block|}
end_function
begin_constructor
DECL|function|QDBusMessagePrivate
name|QDBusMessagePrivate
operator|::
name|QDBusMessagePrivate
parameter_list|()
member_init_list|:
name|msg
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|reply
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|type
argument_list|(
name|DBUS_MESSAGE_TYPE_INVALID
argument_list|)
member_init_list|,
name|timeout
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|localReply
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|delayedReply
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|localMessage
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|parametersValidated
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|autoStartService
argument_list|(
literal|true
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QDBusMessagePrivate
name|QDBusMessagePrivate
operator|::
name|~
name|QDBusMessagePrivate
parameter_list|()
block|{
if|if
condition|(
name|msg
condition|)
name|q_dbus_message_unref
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
name|q_dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
operator|delete
name|localReply
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \since 4.3      Returns the human-readable message associated with the error that was received. */
end_comment
begin_function
DECL|function|errorMessage
name|QString
name|QDBusMessage
operator|::
name|errorMessage
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|type
operator|==
name|ErrorMessage
condition|)
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|message
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|d_ptr
operator|->
name|message
return|;
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|arguments
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|d_ptr
operator|->
name|arguments
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Constructs a DBusMessage object from \a message. The returned value must be de-referenced     with q_dbus_message_unref. The \a capabilities flags indicates which capabilities to use.      The \a error object is set to indicate the error if anything went wrong with the     marshalling. Usually, this error message will be placed in the reply, as if the call failed.     The \a error pointer must not be null. */
end_comment
begin_function
DECL|function|toDBusMessage
name|DBusMessage
modifier|*
name|QDBusMessagePrivate
operator|::
name|toDBusMessage
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|,
name|QDBusConnection
operator|::
name|ConnectionCapabilities
name|capabilities
parameter_list|,
name|QDBusError
modifier|*
name|error
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qdbus_loadLibDBus
argument_list|()
condition|)
block|{
operator|*
name|error
operator|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|Failed
argument_list|,
name|QLatin1String
argument_list|(
literal|"Could not open lidbus-1 library"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DBusMessage
modifier|*
name|msg
init|=
literal|0
decl_stmt|;
specifier|const
name|QDBusMessagePrivate
modifier|*
name|d_ptr
init|=
name|message
operator|.
name|d_ptr
decl_stmt|;
switch|switch
condition|(
name|d_ptr
operator|->
name|type
condition|)
block|{
case|case
name|DBUS_MESSAGE_TYPE_INVALID
case|:
comment|//qDebug()<< "QDBusMessagePrivate::toDBusMessage"<<  "message is invalid";
break|break;
case|case
name|DBUS_MESSAGE_TYPE_METHOD_CALL
case|:
comment|// only service and interface can be empty -> path and name must not be empty
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|parametersValidated
condition|)
block|{
if|if
condition|(
operator|!
name|QDBusUtil
operator|::
name|checkBusName
argument_list|(
name|d_ptr
operator|->
name|service
argument_list|,
name|QDBusUtil
operator|::
name|EmptyAllowed
argument_list|,
name|error
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|QDBusUtil
operator|::
name|checkObjectPath
argument_list|(
name|d_ptr
operator|->
name|path
argument_list|,
name|QDBusUtil
operator|::
name|EmptyNotAllowed
argument_list|,
name|error
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|QDBusUtil
operator|::
name|checkInterfaceName
argument_list|(
name|d_ptr
operator|->
name|interface
argument_list|,
name|QDBusUtil
operator|::
name|EmptyAllowed
argument_list|,
name|error
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|QDBusUtil
operator|::
name|checkMemberName
argument_list|(
name|d_ptr
operator|->
name|name
argument_list|,
name|QDBusUtil
operator|::
name|EmptyNotAllowed
argument_list|,
name|error
argument_list|,
literal|"method"
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|msg
operator|=
name|q_dbus_message_new_method_call
argument_list|(
name|data
argument_list|(
name|d_ptr
operator|->
name|service
operator|.
name|toUtf8
argument_list|()
argument_list|)
argument_list|,
name|d_ptr
operator|->
name|path
operator|.
name|toUtf8
argument_list|()
argument_list|,
name|data
argument_list|(
name|d_ptr
operator|->
name|interface
operator|.
name|toUtf8
argument_list|()
argument_list|)
argument_list|,
name|d_ptr
operator|->
name|name
operator|.
name|toUtf8
argument_list|()
argument_list|)
expr_stmt|;
name|q_dbus_message_set_auto_start
argument_list|(
name|msg
argument_list|,
name|d_ptr
operator|->
name|autoStartService
argument_list|)
expr_stmt|;
break|break;
case|case
name|DBUS_MESSAGE_TYPE_METHOD_RETURN
case|:
name|msg
operator|=
name|q_dbus_message_new
argument_list|(
name|DBUS_MESSAGE_TYPE_METHOD_RETURN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|localMessage
condition|)
block|{
name|q_dbus_message_set_destination
argument_list|(
name|msg
argument_list|,
name|q_dbus_message_get_sender
argument_list|(
name|d_ptr
operator|->
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|q_dbus_message_set_reply_serial
argument_list|(
name|msg
argument_list|,
name|q_dbus_message_get_serial
argument_list|(
name|d_ptr
operator|->
name|reply
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DBUS_MESSAGE_TYPE_ERROR
case|:
comment|// error name can't be empty
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|parametersValidated
operator|&&
operator|!
name|QDBusUtil
operator|::
name|checkErrorName
argument_list|(
name|d_ptr
operator|->
name|name
argument_list|,
name|QDBusUtil
operator|::
name|EmptyNotAllowed
argument_list|,
name|error
argument_list|)
condition|)
return|return
literal|0
return|;
name|msg
operator|=
name|q_dbus_message_new
argument_list|(
name|DBUS_MESSAGE_TYPE_ERROR
argument_list|)
expr_stmt|;
name|q_dbus_message_set_error_name
argument_list|(
name|msg
argument_list|,
name|d_ptr
operator|->
name|name
operator|.
name|toUtf8
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|localMessage
condition|)
block|{
name|q_dbus_message_set_destination
argument_list|(
name|msg
argument_list|,
name|q_dbus_message_get_sender
argument_list|(
name|d_ptr
operator|->
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|q_dbus_message_set_reply_serial
argument_list|(
name|msg
argument_list|,
name|q_dbus_message_get_serial
argument_list|(
name|d_ptr
operator|->
name|reply
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DBUS_MESSAGE_TYPE_SIGNAL
case|:
comment|// nothing can be empty here
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|parametersValidated
condition|)
block|{
if|if
condition|(
operator|!
name|QDBusUtil
operator|::
name|checkObjectPath
argument_list|(
name|d_ptr
operator|->
name|path
argument_list|,
name|QDBusUtil
operator|::
name|EmptyNotAllowed
argument_list|,
name|error
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|QDBusUtil
operator|::
name|checkInterfaceName
argument_list|(
name|d_ptr
operator|->
name|interface
argument_list|,
name|QDBusUtil
operator|::
name|EmptyAllowed
argument_list|,
name|error
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|QDBusUtil
operator|::
name|checkMemberName
argument_list|(
name|d_ptr
operator|->
name|name
argument_list|,
name|QDBusUtil
operator|::
name|EmptyNotAllowed
argument_list|,
name|error
argument_list|,
literal|"method"
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|msg
operator|=
name|q_dbus_message_new_signal
argument_list|(
name|d_ptr
operator|->
name|path
operator|.
name|toUtf8
argument_list|()
argument_list|,
name|d_ptr
operator|->
name|interface
operator|.
name|toUtf8
argument_list|()
argument_list|,
name|d_ptr
operator|->
name|name
operator|.
name|toUtf8
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// if we got here, the parameters validated
comment|// and since the message parameters cannot be changed once the message is created
comment|// we can record this fact
name|d_ptr
operator|->
name|parametersValidated
operator|=
literal|true
expr_stmt|;
name|QDBusMarshaller
name|marshaller
argument_list|(
name|capabilities
argument_list|)
decl_stmt|;
name|QVariantList
operator|::
name|ConstIterator
name|it
init|=
name|d_ptr
operator|->
name|arguments
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QVariantList
operator|::
name|ConstIterator
name|cend
init|=
name|d_ptr
operator|->
name|arguments
operator|.
name|constEnd
argument_list|()
decl_stmt|;
name|q_dbus_message_iter_init_append
argument_list|(
name|msg
argument_list|,
operator|&
name|marshaller
operator|.
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|message
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// prepend the error message
name|marshaller
operator|.
name|append
argument_list|(
name|d_ptr
operator|->
name|message
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|cend
condition|;
operator|++
name|it
control|)
name|marshaller
operator|.
name|appendVariantInternal
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
comment|// check if everything is ok
if|if
condition|(
name|marshaller
operator|.
name|ok
condition|)
return|return
name|msg
return|;
comment|// not ok;
name|q_dbus_message_unref
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|Failed
argument_list|,
name|QLatin1String
argument_list|(
literal|"Marshalling failed: "
argument_list|)
operator|+
name|marshaller
operator|.
name|errorString
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* struct DBusMessage {     DBusAtomic refcount;     DBusHeader header;     DBusString body;     char byte_order;     unsigned int locked : 1; DBUS_DISABLE_CHECKS     unsigned int in_cache : 1; #endif     DBusList *size_counters;     long size_counter_delta;     dbus_uint32_t changed_stamp : CHANGED_STAMP_BITS;     DBusDataSlotList slot_list; #ifndef DBUS_DISABLE_CHECKS     int generation; #endif }; */
end_comment
begin_comment
comment|/*!     \internal     Constructs a QDBusMessage by parsing the given DBusMessage object. */
end_comment
begin_function
DECL|function|fromDBusMessage
name|QDBusMessage
name|QDBusMessagePrivate
operator|::
name|fromDBusMessage
parameter_list|(
name|DBusMessage
modifier|*
name|dmsg
parameter_list|,
name|QDBusConnection
operator|::
name|ConnectionCapabilities
name|capabilities
parameter_list|)
block|{
name|QDBusMessage
name|message
decl_stmt|;
if|if
condition|(
operator|!
name|dmsg
condition|)
return|return
name|message
return|;
name|message
operator|.
name|d_ptr
operator|->
name|type
operator|=
name|q_dbus_message_get_type
argument_list|(
name|dmsg
argument_list|)
expr_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|path
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|q_dbus_message_get_path
argument_list|(
name|dmsg
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|interface
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|q_dbus_message_get_interface
argument_list|(
name|dmsg
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|name
operator|=
name|message
operator|.
name|d_ptr
operator|->
name|type
operator|==
name|DBUS_MESSAGE_TYPE_ERROR
condition|?
name|QString
operator|::
name|fromUtf8
argument_list|(
name|q_dbus_message_get_error_name
argument_list|(
name|dmsg
argument_list|)
argument_list|)
else|:
name|QString
operator|::
name|fromUtf8
argument_list|(
name|q_dbus_message_get_member
argument_list|(
name|dmsg
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|service
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|q_dbus_message_get_sender
argument_list|(
name|dmsg
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|signature
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|q_dbus_message_get_signature
argument_list|(
name|dmsg
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|msg
operator|=
name|q_dbus_message_ref
argument_list|(
name|dmsg
argument_list|)
expr_stmt|;
name|QDBusDemarshaller
name|demarshaller
argument_list|(
name|capabilities
argument_list|)
decl_stmt|;
name|demarshaller
operator|.
name|message
operator|=
name|q_dbus_message_ref
argument_list|(
name|dmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|q_dbus_message_iter_init
argument_list|(
name|demarshaller
operator|.
name|message
argument_list|,
operator|&
name|demarshaller
operator|.
name|iterator
argument_list|)
condition|)
while|while
condition|(
operator|!
name|demarshaller
operator|.
name|atEnd
argument_list|()
condition|)
name|message
operator|<<
name|demarshaller
operator|.
name|toVariantInternal
argument_list|()
expr_stmt|;
return|return
name|message
return|;
block|}
end_function
begin_function
DECL|function|isLocal
name|bool
name|QDBusMessagePrivate
operator|::
name|isLocal
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|)
block|{
return|return
name|message
operator|.
name|d_ptr
operator|->
name|localMessage
return|;
block|}
end_function
begin_function
DECL|function|makeLocal
name|QDBusMessage
name|QDBusMessagePrivate
operator|::
name|makeLocal
parameter_list|(
specifier|const
name|QDBusConnectionPrivate
modifier|&
name|conn
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|asSent
parameter_list|)
block|{
comment|// simulate the message being sent to the bus and then received back
comment|// the only field that the bus sets when delivering the message
comment|// (as opposed to the message as we send it), is the sender
comment|// so we simply set the sender to our unique name
comment|// determine if we are carrying any complex types
name|QString
name|computedSignature
decl_stmt|;
name|QVariantList
operator|::
name|ConstIterator
name|it
init|=
name|asSent
operator|.
name|d_ptr
operator|->
name|arguments
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QVariantList
operator|::
name|ConstIterator
name|end
init|=
name|asSent
operator|.
name|d_ptr
operator|->
name|arguments
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|int
name|id
init|=
name|it
operator|->
name|userType
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|signature
init|=
name|QDBusMetaType
operator|::
name|typeToSignature
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|id
operator|!=
name|QVariant
operator|::
name|StringList
operator|&&
name|id
operator|!=
name|QVariant
operator|::
name|ByteArray
operator|&&
name|qstrlen
argument_list|(
name|signature
argument_list|)
operator|!=
literal|1
operator|)
operator|||
name|id
operator|==
name|qMetaTypeId
argument_list|<
name|QDBusVariant
argument_list|>
argument_list|()
condition|)
block|{
comment|// yes, we are
comment|// we must marshall and demarshall again so as to create QDBusArgument
comment|// entries for the complex types
name|QDBusError
name|error
decl_stmt|;
name|DBusMessage
modifier|*
name|message
init|=
name|toDBusMessage
argument_list|(
name|asSent
argument_list|,
name|conn
operator|.
name|capabilities
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|message
condition|)
block|{
comment|// failed to marshall, so it's a call error
return|return
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|error
argument_list|)
return|;
block|}
name|q_dbus_message_set_sender
argument_list|(
name|message
argument_list|,
name|conn
operator|.
name|baseService
operator|.
name|toUtf8
argument_list|()
argument_list|)
expr_stmt|;
name|QDBusMessage
name|retval
init|=
name|fromDBusMessage
argument_list|(
name|message
argument_list|,
name|conn
operator|.
name|capabilities
argument_list|)
decl_stmt|;
name|retval
operator|.
name|d_ptr
operator|->
name|localMessage
operator|=
literal|true
expr_stmt|;
name|q_dbus_message_unref
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|.
name|d_ptr
operator|->
name|service
operator|.
name|isEmpty
argument_list|()
condition|)
name|retval
operator|.
name|d_ptr
operator|->
name|service
operator|=
name|conn
operator|.
name|baseService
expr_stmt|;
return|return
name|retval
return|;
block|}
else|else
block|{
name|computedSignature
operator|+=
name|QLatin1String
argument_list|(
name|signature
argument_list|)
expr_stmt|;
block|}
block|}
comment|// no complex types seen
comment|// optimize by using the variant list itself
name|QDBusMessage
name|retval
decl_stmt|;
name|QDBusMessagePrivate
modifier|*
name|d
init|=
name|retval
operator|.
name|d_ptr
decl_stmt|;
name|d
operator|->
name|arguments
operator|=
name|asSent
operator|.
name|d_ptr
operator|->
name|arguments
expr_stmt|;
name|d
operator|->
name|path
operator|=
name|asSent
operator|.
name|d_ptr
operator|->
name|path
expr_stmt|;
name|d
operator|->
name|interface
operator|=
name|asSent
operator|.
name|d_ptr
operator|->
name|interface
expr_stmt|;
name|d
operator|->
name|name
operator|=
name|asSent
operator|.
name|d_ptr
operator|->
name|name
expr_stmt|;
name|d
operator|->
name|message
operator|=
name|asSent
operator|.
name|d_ptr
operator|->
name|message
expr_stmt|;
name|d
operator|->
name|type
operator|=
name|asSent
operator|.
name|d_ptr
operator|->
name|type
expr_stmt|;
name|d
operator|->
name|service
operator|=
name|conn
operator|.
name|baseService
expr_stmt|;
name|d
operator|->
name|signature
operator|=
name|computedSignature
expr_stmt|;
name|d
operator|->
name|localMessage
operator|=
literal|true
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|makeLocalReply
name|QDBusMessage
name|QDBusMessagePrivate
operator|::
name|makeLocalReply
parameter_list|(
specifier|const
name|QDBusConnectionPrivate
modifier|&
name|conn
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|callMsg
parameter_list|)
block|{
comment|// simulate the reply (return or error) message being sent to the bus and
comment|// then received back.
if|if
condition|(
name|callMsg
operator|.
name|d_ptr
operator|->
name|localReply
condition|)
return|return
name|makeLocal
argument_list|(
name|conn
argument_list|,
operator|*
name|callMsg
operator|.
name|d_ptr
operator|->
name|localReply
argument_list|)
return|;
return|return
name|QDBusMessage
argument_list|()
return|;
comment|// failed
block|}
end_function
begin_comment
comment|/*!     \class QDBusMessage     \inmodule QtDBus     \since 4.2      \brief The QDBusMessage class represents one message sent or     received over the D-Bus bus.      This object can represent any of the four different types of     messages (MessageType) that can occur on the bus:      \list       \li Method calls       \li Method return values       \li Signal emissions       \li Error codes     \endlist      Objects of this type are created with the static createError(),     createMethodCall() and createSignal() functions. Use the     QDBusConnection::send() function to send the messages. */
end_comment
begin_comment
comment|/*!     \enum QDBusMessage::MessageType     The possible message types:      \value MethodCallMessage    a message representing an outgoing or incoming method call     \value SignalMessage        a message representing an outgoing or incoming signal emission     \value ReplyMessage         a message representing the return values of a method call     \value ErrorMessage         a message representing an error condition in response to a method call     \value InvalidMessage       an invalid message: this is never set on messages received from D-Bus */
end_comment
begin_comment
comment|/*!     Constructs a new DBus message with the given \a path, \a interface     and \a name, representing a signal emission.      A DBus signal is emitted from one application and is received by     all applications that are listening for that signal from that     interface.      The QDBusMessage object that is returned can be sent using the     QDBusConnection::send() function. */
end_comment
begin_function
DECL|function|createSignal
name|QDBusMessage
name|QDBusMessage
operator|::
name|createSignal
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QDBusMessage
name|message
decl_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|type
operator|=
name|DBUS_MESSAGE_TYPE_SIGNAL
expr_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|interface
operator|=
name|interface
expr_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|name
operator|=
name|name
expr_stmt|;
return|return
name|message
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a new DBus message representing a method call.     A method call always informs its destination address     (\a service, \a path, \a interface and \a method).      The DBus bus allows calling a method on a given remote object without specifying the     destination interface, if the method name is unique. However, if two interfaces on the     remote object export the same method name, the result is undefined (one of the two may be     called or an error may be returned).      When using DBus in a peer-to-peer context (i.e., not on a bus), the \a service parameter is     optional.      The QDBusInterface class provides a simpler abstraction to synchronous     method calling.      This function returns a QDBusMessage object that can be sent with     QDBusConnection::call(). */
end_comment
begin_function
DECL|function|createMethodCall
name|QDBusMessage
name|QDBusMessage
operator|::
name|createMethodCall
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|method
parameter_list|)
block|{
name|QDBusMessage
name|message
decl_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|type
operator|=
name|DBUS_MESSAGE_TYPE_METHOD_CALL
expr_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|service
operator|=
name|service
expr_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|interface
operator|=
name|interface
expr_stmt|;
name|message
operator|.
name|d_ptr
operator|->
name|name
operator|=
name|method
expr_stmt|;
return|return
name|message
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a new DBus message representing an error,     with the given \a name and \a msg. */
end_comment
begin_function
DECL|function|createError
name|QDBusMessage
name|QDBusMessage
operator|::
name|createError
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|msg
parameter_list|)
block|{
name|QDBusMessage
name|error
decl_stmt|;
name|error
operator|.
name|d_ptr
operator|->
name|type
operator|=
name|DBUS_MESSAGE_TYPE_ERROR
expr_stmt|;
name|error
operator|.
name|d_ptr
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|error
operator|.
name|d_ptr
operator|->
name|message
operator|=
name|msg
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDBusMessage QDBusMessage::createError(const QDBusError&error)      Constructs a new DBus message representing the given \a error. */
end_comment
begin_comment
comment|/*!   \fn QDBusMessage QDBusMessage::createError(QDBusError::ErrorType type, const QString&msg)    Constructs a new DBus message for the error type \a type using   the message \a msg. Returns the DBus message. */
end_comment
begin_comment
comment|/*!     \fn QDBusMessage QDBusMessage::createReply(const QList<QVariant>&arguments) const      Constructs a new DBus message representing a reply, with the given     \a arguments. */
end_comment
begin_function
DECL|function|createReply
name|QDBusMessage
name|QDBusMessage
operator|::
name|createReply
parameter_list|(
specifier|const
name|QVariantList
modifier|&
name|arguments
parameter_list|)
specifier|const
block|{
name|QDBusMessage
name|reply
decl_stmt|;
name|reply
operator|.
name|setArguments
argument_list|(
name|arguments
argument_list|)
expr_stmt|;
name|reply
operator|.
name|d_ptr
operator|->
name|type
operator|=
name|DBUS_MESSAGE_TYPE_METHOD_RETURN
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|msg
condition|)
name|reply
operator|.
name|d_ptr
operator|->
name|reply
operator|=
name|q_dbus_message_ref
argument_list|(
name|d_ptr
operator|->
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|localMessage
condition|)
block|{
name|reply
operator|.
name|d_ptr
operator|->
name|localMessage
operator|=
literal|true
expr_stmt|;
name|d_ptr
operator|->
name|localReply
operator|=
operator|new
name|QDBusMessage
argument_list|(
name|reply
argument_list|)
expr_stmt|;
comment|// keep an internal copy
block|}
comment|// the reply must have a msg or be a local-loop optimization
name|Q_ASSERT
argument_list|(
name|reply
operator|.
name|d_ptr
operator|->
name|reply
operator|||
name|reply
operator|.
name|d_ptr
operator|->
name|localMessage
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a new DBus message representing an error reply message,     with the given \a name and \a msg. */
end_comment
begin_function
DECL|function|createErrorReply
name|QDBusMessage
name|QDBusMessage
operator|::
name|createErrorReply
parameter_list|(
specifier|const
name|QString
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|msg
parameter_list|)
specifier|const
block|{
name|QDBusMessage
name|reply
init|=
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|name
argument_list|,
name|msg
argument_list|)
decl_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|msg
condition|)
name|reply
operator|.
name|d_ptr
operator|->
name|reply
operator|=
name|q_dbus_message_ref
argument_list|(
name|d_ptr
operator|->
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|localMessage
condition|)
block|{
name|reply
operator|.
name|d_ptr
operator|->
name|localMessage
operator|=
literal|true
expr_stmt|;
name|d_ptr
operator|->
name|localReply
operator|=
operator|new
name|QDBusMessage
argument_list|(
name|reply
argument_list|)
expr_stmt|;
comment|// keep an internal copy
block|}
comment|// the reply must have a msg or be a local-loop optimization
name|Q_ASSERT
argument_list|(
name|reply
operator|.
name|d_ptr
operator|->
name|reply
operator|||
name|reply
operator|.
name|d_ptr
operator|->
name|localMessage
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_comment
comment|/*!    \fn QDBusMessage QDBusMessage::createReply(const QVariant&argument) const      Constructs a new DBus message representing a reply, with the     given \a argument. */
end_comment
begin_comment
comment|/*!     \fn QDBusMessage QDBusMessage::createErrorReply(const QDBusError&error) const      Constructs a new DBus message representing an error reply message,     from the given \a error object. */
end_comment
begin_comment
comment|/*!   \fn QDBusMessage QDBusMessage::createErrorReply(QDBusError::ErrorType type, const QString&msg) const    Constructs a new DBus reply message for the error type \a type using   the message \a msg. Returns the DBus message. */
end_comment
begin_function
DECL|function|createErrorReply
name|QDBusMessage
name|QDBusMessage
operator|::
name|createErrorReply
parameter_list|(
name|QDBusError
operator|::
name|ErrorType
name|atype
parameter_list|,
specifier|const
name|QString
modifier|&
name|amsg
parameter_list|)
specifier|const
block|{
name|QDBusMessage
name|msg
init|=
name|createErrorReply
argument_list|(
name|QDBusError
operator|::
name|errorString
argument_list|(
name|atype
argument_list|)
argument_list|,
name|amsg
argument_list|)
decl_stmt|;
name|msg
operator|.
name|d_ptr
operator|->
name|parametersValidated
operator|=
literal|true
expr_stmt|;
return|return
name|msg
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs an empty, invalid QDBusMessage object.      \sa createError(), createMethodCall(), createSignal() */
end_comment
begin_constructor
DECL|function|QDBusMessage
name|QDBusMessage
operator|::
name|QDBusMessage
parameter_list|()
block|{
name|d_ptr
operator|=
operator|new
name|QDBusMessagePrivate
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of the object given by \a other.      Note: QDBusMessage objects are shared. Modifications made to the     copy will affect the original one as well. See setDelayedReply()     for more information. */
end_comment
begin_constructor
DECL|function|QDBusMessage
name|QDBusMessage
operator|::
name|QDBusMessage
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|other
parameter_list|)
block|{
name|d_ptr
operator|=
name|other
operator|.
name|d_ptr
expr_stmt|;
name|d_ptr
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Disposes of the object and frees any resources that were being held. */
end_comment
begin_destructor
DECL|function|~QDBusMessage
name|QDBusMessage
operator|::
name|~
name|QDBusMessage
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d_ptr
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Copies the contents of the object given by \a other.      Note: QDBusMessage objects are shared. Modifications made to the     copy will affect the original one as well. See setDelayedReply()     for more information. */
end_comment
begin_function
DECL|function|operator =
name|QDBusMessage
modifier|&
name|QDBusMessage
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|other
parameter_list|)
block|{
name|qAtomicAssign
argument_list|(
name|d_ptr
argument_list|,
name|other
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the service or the bus address of the remote method call. */
end_comment
begin_function
DECL|function|service
name|QString
name|QDBusMessage
operator|::
name|service
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|service
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the path of the object that this message is being sent to (in the case of a     method call) or being received from (for a signal). */
end_comment
begin_function
DECL|function|path
name|QString
name|QDBusMessage
operator|::
name|path
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|path
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the interface of the method being called (in the case of a method call) or of     the signal being received from. */
end_comment
begin_function
DECL|function|interface
name|QString
name|QDBusMessage
operator|::
name|interface
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|interface
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the signal that was emitted or the name of the method that was called. */
end_comment
begin_function
DECL|function|member
name|QString
name|QDBusMessage
operator|::
name|member
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|type
operator|!=
name|ErrorMessage
condition|)
return|return
name|d_ptr
operator|->
name|name
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the error that was received. */
end_comment
begin_function
DECL|function|errorName
name|QString
name|QDBusMessage
operator|::
name|errorName
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|type
operator|==
name|ErrorMessage
condition|)
return|return
name|d_ptr
operator|->
name|name
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the signature of the signal that was received or for the output arguments     of a method call. */
end_comment
begin_function
DECL|function|signature
name|QString
name|QDBusMessage
operator|::
name|signature
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|signature
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the flag that indicates if this message should see a reply     or not. This is only meaningful for \l {MethodCallMessage}{method     call messages}: any other kind of message cannot have replies and     this function will always return false for them. */
end_comment
begin_function
DECL|function|isReplyRequired
name|bool
name|QDBusMessage
operator|::
name|isReplyRequired
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|msg
condition|)
return|return
name|d_ptr
operator|->
name|localMessage
return|;
comment|// if it's a local message, reply is required
return|return
operator|!
name|q_dbus_message_get_no_reply
argument_list|(
name|d_ptr
operator|->
name|msg
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets whether the message will be replied later (if \a enable is     true) or if an automatic reply should be generated by Qt D-Bus     (if \a enable is false).      In D-Bus, all method calls must generate a reply to the caller, unless the     caller explicitly indicates otherwise (see isReplyRequired()). QtDBus     automatically generates such replies for any slots being called, but it     also allows slots to indicate whether they will take responsibility     of sending the reply at a later time, after the function has finished     processing.      \sa {Delayed Replies} */
end_comment
begin_function
DECL|function|setDelayedReply
name|void
name|QDBusMessage
operator|::
name|setDelayedReply
parameter_list|(
name|bool
name|enable
parameter_list|)
specifier|const
block|{
name|d_ptr
operator|->
name|delayedReply
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the delayed reply flag, as set by setDelayedReply(). By default, this     flag is false, which means Qt D-Bus will generate automatic replies     when necessary. */
end_comment
begin_function
DECL|function|isDelayedReply
name|bool
name|QDBusMessage
operator|::
name|isDelayedReply
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|delayedReply
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the auto start flag to \a enable. This flag only makes sense     for method call messages, where it tells the D-Bus server to     either auto start the service responsible for the service name, or     not to auto start it.      By default this flag is true, i.e. a service is autostarted.     This means:      When the service that this method call is sent to is already     running, the method call is sent to it. If the service is not     running yet, the D-Bus daemon is requested to autostart the     service that is assigned to this service name. This is     handled by .service files that are placed in a directory known     to the D-Bus server. These files then each contain a service     name and the path to a program that should be executed when     this service name is requested.      \since 4.7 */
end_comment
begin_function
DECL|function|setAutoStartService
name|void
name|QDBusMessage
operator|::
name|setAutoStartService
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|d_ptr
operator|->
name|autoStartService
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the auto start flag, as set by setAutoStartService(). By default, this     flag is true, which means Qt D-Bus will auto start a service, if it is     not running already.      \sa setAutoStartService()      \since 4.7 */
end_comment
begin_function
DECL|function|autoStartService
name|bool
name|QDBusMessage
operator|::
name|autoStartService
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|autoStartService
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the arguments that are going to be sent over D-Bus to \a arguments. Those     will be the arguments to a method call or the parameters in the signal.      \sa arguments() */
end_comment
begin_function
DECL|function|setArguments
name|void
name|QDBusMessage
operator|::
name|setArguments
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|arguments
parameter_list|)
block|{
comment|// FIXME: should we detach?
name|d_ptr
operator|->
name|arguments
operator|=
name|arguments
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the list of arguments that are going to be sent or were received from     D-Bus. */
end_comment
begin_function
DECL|function|arguments
name|QList
argument_list|<
name|QVariant
argument_list|>
name|QDBusMessage
operator|::
name|arguments
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|arguments
return|;
block|}
end_function
begin_comment
comment|/*!     Appends the argument \a arg to the list of arguments to be sent over D-Bus in     a method call or signal emission. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusMessage
modifier|&
name|QDBusMessage
operator|::
name|operator
name|<<
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|arg
parameter_list|)
block|{
comment|// FIXME: should we detach?
name|d_ptr
operator|->
name|arguments
operator|.
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the message type. */
end_comment
begin_function
DECL|function|type
name|QDBusMessage
operator|::
name|MessageType
name|QDBusMessage
operator|::
name|type
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|d_ptr
operator|->
name|type
condition|)
block|{
case|case
name|DBUS_MESSAGE_TYPE_METHOD_CALL
case|:
return|return
name|MethodCallMessage
return|;
case|case
name|DBUS_MESSAGE_TYPE_METHOD_RETURN
case|:
return|return
name|ReplyMessage
return|;
case|case
name|DBUS_MESSAGE_TYPE_ERROR
case|:
return|return
name|ErrorMessage
return|;
case|case
name|DBUS_MESSAGE_TYPE_SIGNAL
case|:
return|return
name|SignalMessage
return|;
default|default:
break|break;
block|}
return|return
name|InvalidMessage
return|;
block|}
end_function
begin_comment
comment|/*!     Sends the message without waiting for a reply. This is suitable     for errors, signals, and return values as well as calls whose     return values are not necessary.      Returns \c true if the message was queued successfully;     otherwise returns \c false.      \sa QDBusConnection::send() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
specifier|static
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
name|QDBusMessage
operator|::
name|MessageType
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|QDBusMessage
operator|::
name|MethodCallMessage
case|:
return|return
name|dbg
operator|<<
literal|"MethodCall"
return|;
case|case
name|QDBusMessage
operator|::
name|ReplyMessage
case|:
return|return
name|dbg
operator|<<
literal|"MethodReturn"
return|;
case|case
name|QDBusMessage
operator|::
name|SignalMessage
case|:
return|return
name|dbg
operator|<<
literal|"Signal"
return|;
case|case
name|QDBusMessage
operator|::
name|ErrorMessage
case|:
return|return
name|dbg
operator|<<
literal|"Error"
return|;
default|default:
return|return
name|dbg
operator|<<
literal|"Invalid"
return|;
block|}
block|}
end_function
begin_function
DECL|function|debugVariantList
specifier|static
name|void
name|debugVariantList
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QVariantList
modifier|&
name|list
parameter_list|)
block|{
name|bool
name|first
init|=
literal|true
decl_stmt|;
name|QVariantList
operator|::
name|ConstIterator
name|it
init|=
name|list
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QVariantList
operator|::
name|ConstIterator
name|end
init|=
name|list
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|", "
expr_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
name|qPrintable
argument_list|(
name|QDBusUtil
operator|::
name|argumentToString
argument_list|(
operator|*
name|it
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QDBusMessage
modifier|&
name|msg
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QDBusMessage(type="
operator|<<
name|msg
operator|.
name|type
argument_list|()
operator|<<
literal|", service="
operator|<<
name|msg
operator|.
name|service
argument_list|()
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|MethodCallMessage
operator|||
name|msg
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|SignalMessage
condition|)
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|", path="
operator|<<
name|msg
operator|.
name|path
argument_list|()
operator|<<
literal|", interface="
operator|<<
name|msg
operator|.
name|interface
argument_list|()
operator|<<
literal|", member="
operator|<<
name|msg
operator|.
name|member
argument_list|()
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|type
argument_list|()
operator|==
name|QDBusMessage
operator|::
name|ErrorMessage
condition|)
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|", error name="
operator|<<
name|msg
operator|.
name|errorName
argument_list|()
operator|<<
literal|", error message="
operator|<<
name|msg
operator|.
name|errorMessage
argument_list|()
expr_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|", signature="
operator|<<
name|msg
operator|.
name|signature
argument_list|()
operator|<<
literal|", contents=("
expr_stmt|;
name|debugVariantList
argument_list|(
name|dbg
argument_list|,
name|msg
operator|.
name|arguments
argument_list|()
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|") )"
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DBUS
end_comment
end_unit
