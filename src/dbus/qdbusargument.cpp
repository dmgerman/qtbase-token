begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtDBus module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdbusargument.h"
end_include
begin_include
include|#
directive|include
file|"qdbusargument_p.h"
end_include
begin_include
include|#
directive|include
file|<qatomic.h>
end_include
begin_include
include|#
directive|include
file|<qbytearray.h>
end_include
begin_include
include|#
directive|include
file|<qlist.h>
end_include
begin_include
include|#
directive|include
file|<qmap.h>
end_include
begin_include
include|#
directive|include
file|<qstring.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qvariant.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<qrect.h>
end_include
begin_include
include|#
directive|include
file|<qline.h>
end_include
begin_include
include|#
directive|include
file|"qdbusmetatype_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusutil_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DBUS
end_ifndef
begin_expr_stmt
name|QT_BEGIN_NAMESPACE
DECL|function|~QDBusArgumentPrivate
name|QDBusArgumentPrivate
operator|::
name|~
name|QDBusArgumentPrivate
operator|(
operator|)
block|{
if|if
condition|(
name|message
condition|)
name|q_dbus_message_unref
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
end_expr_stmt
begin_function
DECL|function|createSignature
name|QByteArray
name|QDBusArgumentPrivate
operator|::
name|createSignature
parameter_list|(
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qdbus_loadLibDBus
argument_list|()
condition|)
return|return
literal|""
return|;
name|QByteArray
name|signature
decl_stmt|;
name|QDBusMarshaller
modifier|*
name|marshaller
init|=
operator|new
name|QDBusMarshaller
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|marshaller
operator|->
name|ba
operator|=
operator|&
name|signature
expr_stmt|;
comment|// run it
name|void
modifier|*
name|null
init|=
literal|0
decl_stmt|;
name|QVariant
name|v
argument_list|(
name|id
argument_list|,
name|null
argument_list|)
decl_stmt|;
name|QDBusArgument
name|arg
argument_list|(
name|marshaller
argument_list|)
decl_stmt|;
name|QDBusMetaType
operator|::
name|marshall
argument_list|(
name|arg
argument_list|,
name|v
operator|.
name|userType
argument_list|()
argument_list|,
name|v
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|arg
operator|.
name|d
operator|=
literal|0
expr_stmt|;
comment|// delete it
name|bool
name|ok
init|=
name|marshaller
operator|->
name|ok
decl_stmt|;
operator|delete
name|marshaller
expr_stmt|;
if|if
condition|(
name|signature
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|ok
operator|||
operator|!
name|QDBusUtil
operator|::
name|isValidSingleSignature
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|signature
argument_list|)
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDBusMarshaller: type `%s' produces invalid D-BUS signature `%s' "
literal|"(Did you forget to call beginStructure() ?)"
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|id
argument_list|)
argument_list|,
name|signature
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"<empty>"
else|:
name|signature
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|signature
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
name|DBUS_TYPE_ARRAY
operator|&&
name|signature
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
name|DBUS_STRUCT_BEGIN_CHAR
operator|)
operator|||
operator|(
name|signature
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|DBUS_TYPE_ARRAY
operator|&&
operator|(
name|signature
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|DBUS_TYPE_BYTE
operator|||
name|signature
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|DBUS_TYPE_STRING
operator|)
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDBusMarshaller: type `%s' attempts to redefine basic D-BUS type '%s' (%s) "
literal|"(Did you forget to call beginStructure() ?)"
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|id
argument_list|)
argument_list|,
name|signature
operator|.
name|constData
argument_list|()
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|QDBusMetaType
operator|::
name|signatureToType
argument_list|(
name|signature
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
return|return
name|signature
return|;
block|}
end_function
begin_function
DECL|function|checkWrite
name|bool
name|QDBusArgumentPrivate
operator|::
name|checkWrite
parameter_list|(
name|QDBusArgumentPrivate
modifier|*
modifier|&
name|d
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|direction
operator|==
name|Marshalling
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|ok
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|message
operator|&&
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|QDBusMarshaller
modifier|*
name|dd
init|=
operator|new
name|QDBusMarshaller
argument_list|(
name|d
operator|->
name|capabilities
argument_list|)
decl_stmt|;
name|dd
operator|->
name|message
operator|=
name|q_dbus_message_copy
argument_list|(
name|d
operator|->
name|message
argument_list|)
expr_stmt|;
name|q_dbus_message_iter_init_append
argument_list|(
name|dd
operator|->
name|message
argument_list|,
operator|&
name|dd
operator|->
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|dd
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
ifdef|#
directive|ifdef
name|QT_DEBUG
name|qFatal
argument_list|(
literal|"QDBusArgument: write from a read-only object"
argument_list|)
expr_stmt|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"QDBusArgument: write from a read-only object"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|checkRead
name|bool
name|QDBusArgumentPrivate
operator|::
name|checkRead
parameter_list|(
name|QDBusArgumentPrivate
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|direction
operator|==
name|Demarshalling
condition|)
return|return
literal|true
return|;
ifdef|#
directive|ifdef
name|QT_DEBUG
name|qFatal
argument_list|(
literal|"QDBusArgument: read from a write-only object"
argument_list|)
expr_stmt|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"QDBusArgument: read from a write-only object"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|checkReadAndDetach
name|bool
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
parameter_list|(
name|QDBusArgumentPrivate
modifier|*
modifier|&
name|d
parameter_list|)
block|{
if|if
condition|(
operator|!
name|checkRead
argument_list|(
name|d
argument_list|)
condition|)
return|return
literal|false
return|;
comment|//  don't bother
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
condition|)
return|return
literal|true
return|;
comment|// no need to detach
name|QDBusDemarshaller
modifier|*
name|dd
init|=
operator|new
name|QDBusDemarshaller
argument_list|(
name|d
operator|->
name|capabilities
argument_list|)
decl_stmt|;
name|dd
operator|->
name|message
operator|=
name|q_dbus_message_ref
argument_list|(
name|d
operator|->
name|message
argument_list|)
expr_stmt|;
name|dd
operator|->
name|iterator
operator|=
cast|static_cast
argument_list|<
name|QDBusDemarshaller
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|iterator
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|dd
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \class QDBusArgument     \inmodule QtDBus     \since 4.2      \brief The QDBusArgument class is used to marshall and demarshall D-Bus arguments.      The class is used to send arguments over D-Bus to remote     applications and to receive them back. D-Bus offers an extensible     type system, based on a few primitive types and associations of     them. See the \l {qdbustypesystem.html}{Qt D-Bus Type System} page     for more information on the type system.      QDBusArgument is the central class in the Qt D-Bus type system,     providing functions to marshall and demarshall the primitive     types. The compound types are then created by association of one     or more of the primitive types in arrays, dictionaries or     structures.      The following example illustrates how a structure containing an     integer and a string can be constructed using the \l     {qdbustypesystem.html}{Qt D-Bus type system}:      \snippet code/src_qdbus_qdbusargument.cpp 0      The type has to be registered with qDBusRegisterMetaType() before     it can be used with QDBusArgument. Therefore, somewhere in your     program, you should add the following code:      \snippet code/src_qdbus_qdbusargument.cpp 1      Once registered, a type can be used in outgoing method calls     (placed with QDBusAbstractInterface::call()), signal emissions     from registered objects or in incoming calls from remote     applications.      It is important to note that the \c{operator<<} and \c{operator>>}     streaming functions must always produce the same number of entries     in case of structures, both in reading and in writing (marshalling     and demarshalling), otherwise calls and signals may start to     silently fail.      The following example illustrates this wrong usage     in context of a class that may contain invalid data:      \badcode         // Wrongly marshall the MyTime data into a D-Bus argument         QDBusArgument&operator<<(QDBusArgument&argument, const MyTime&mytime)         {             argument.beginStructure();             if (mytime.isValid)                 argument<< true<< mytime.hour<< mytime.minute<< mytime.second;             else                 argument<< false;             argument.endStructure();             return argument;         }     \endcode      In this example, both the \c{operator<<} and the \c{operator>>}     functions may produce a different number of reads/writes. This can     confuse the Qt D-Bus type system and should be avoided.      \sa QDBusAbstractInterface, {qdbustypesystem.html}{The Qt D-Bus type     system}, {usingadaptors.html}{Using Adaptors}, qdbus_cast() */
end_comment
begin_comment
comment|/*!     \enum QDBusArgument::ElementType     \since 4.5      This enum describes the type of element held by the argument.      \value BasicType A basic element, which is understood by         QVariant. The following types are considered basic: bool,         byte, short, ushort, int, uint, qint64, quint64, double,         QString, QByteArray, QDBusObjectPath, QDBusSignature      \value VariantType The variant element (QDBusVariant)      \value ArrayType An array element, usually represented by QList<T>     or QVector<T>. Note: QByteArray and associative maps are not     considered arrays, even if the D-Bus protocol transports them as such.      \value StructureType A custom type represented by a structure,     like QDateTime, QPoint, etc.      \value MapType An associative container, like QMap<Key, Value> or     QHash<Key, Value>      \value MapEntryType One entry in an associative container: both     the key and the value form one map-entry type.      \value UnknownType The type is unknown or we have reached the end     of the list.      \sa currentType() */
end_comment
begin_comment
comment|/*!     \fn qdbus_cast(const QDBusArgument&argument)     \relates QDBusArgument     \since 4.2      Attempts to demarshall the contents of \a argument into the type     \c{T}. For example:      \snippet code/src_qdbus_qdbusargument.cpp 2      Note that it is equivalent to the following:      \snippet code/src_qdbus_qdbusargument.cpp 3 */
end_comment
begin_comment
comment|/*!     Constructs an empty QDBusArgument argument.      An empty QDBusArgument object does not allow either reading or     writing to be performed. */
end_comment
begin_constructor
DECL|function|QDBusArgument
name|QDBusArgument
operator|::
name|QDBusArgument
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qdbus_loadLibDBus
argument_list|()
condition|)
block|{
name|d
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|QDBusMarshaller
modifier|*
name|dd
init|=
operator|new
name|QDBusMarshaller
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|d
operator|=
name|dd
expr_stmt|;
comment|// create a new message with any type, we won't sent it anyways
name|dd
operator|->
name|message
operator|=
name|q_dbus_message_new
argument_list|(
name|DBUS_MESSAGE_TYPE_METHOD_CALL
argument_list|)
expr_stmt|;
name|q_dbus_message_iter_init_append
argument_list|(
name|dd
operator|->
name|message
argument_list|,
operator|&
name|dd
operator|->
name|iterator
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of the \a other QDBusArgument object.      Both objects will therefore contain the same state from this point     forward. QDBusArguments are explicitly shared and, therefore, any     modification to either copy will affect the other one too. */
end_comment
begin_constructor
DECL|function|QDBusArgument
name|QDBusArgument
operator|::
name|QDBusArgument
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QDBusArgument
name|QDBusArgument
operator|::
name|QDBusArgument
parameter_list|(
name|QDBusArgumentPrivate
modifier|*
name|dd
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|dd
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Copies the \a other QDBusArgument object into this one.      Both objects will therefore contain the same state from this point     forward. QDBusArguments are explicitly shared and, therefore, any     modification to either copy will affect the other one too. */
end_comment
begin_function
DECL|function|operator =
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|other
parameter_list|)
block|{
name|qAtomicAssign
argument_list|(
name|d
argument_list|,
name|other
operator|.
name|d
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Disposes of the resources associated with this QDBusArgument     object. */
end_comment
begin_destructor
DECL|function|~QDBusArgument
name|QDBusArgument
operator|::
name|~
name|QDBusArgument
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Appends the primitive value \a arg of type \c{BYTE} to the D-Bus stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
name|uchar
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Appends the primitive value \a arg of type \c{BOOLEAN} to the D-Bus stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
name|bool
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Appends the primitive value \a arg of type \c{INT16} to the D-Bus stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
name|short
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Appends the primitive value \a arg of type \c{UINT16} to the D-Bus stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
name|ushort
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Appends the primitive value \a arg of type \c{INT32} to the D-Bus stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Appends the primitive value \a arg of type \c{UINT32} to the D-Bus stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
name|uint
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Appends the primitive value \a arg of type \c{INT64} to the D-Bus stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
name|qlonglong
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Appends the primitive value \a arg of type \c{UINT64} to the D-Bus stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
name|qulonglong
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Appends the primitive value \a arg of type \c{DOUBLE} (double-precision     floating-point) to the D-Bus stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
name|double
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Appends the primitive value \a arg of type \c{STRING} (Unicode character     string) to the D-Bus stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
specifier|const
name|QString
modifier|&
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \internal     Appends the primitive value \a arg of type \c{OBJECT_PATH} (path to a D-Bus     object) to the D-Bus stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
specifier|const
name|QDBusObjectPath
modifier|&
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \internal     Appends the primitive value \a arg of type \c{SIGNATURE} (D-Bus type     signature) to the D-Bus stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
specifier|const
name|QDBusSignature
modifier|&
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.8     \internal     Appends the primitive value \a arg of type \c{UNIX_FILE_DESCRIPTOR} (Unix     File Descriptor) to the D-Bus stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
specifier|const
name|QDBusUnixFileDescriptor
modifier|&
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Appends the primitive value \a arg of type \c{VARIANT} to the D-Bus stream.      A D-Bus variant type can contain any type, including other     variants. It is similar to the Qt QVariant type. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
specifier|const
name|QDBusVariant
modifier|&
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Appends the QStringList given by \a arg as \c{ARRAY of STRING}     to the D-Bus stream.      QStringList and QByteArray are the only two non-primitive types     that are supported directly by QDBusArgument because of their     widespread usage in Qt applications.      Other arrays are supported through compound types in Qt D-Bus. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Appends the QByteArray given by \a arg as \c{ARRAY of BYTE}     to the D-Bus stream.      QStringList and QByteArray are the only two non-primitive types     that are supported directly by QDBusArgument because of their     widespread usage in Qt applications.      Other arrays are supported through compound types in Qt D-Bus. */
end_comment
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|<<
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|arg
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 4.5      Appends the variant \a v.      \sa asVariant() */
end_comment
begin_function
DECL|function|appendVariant
name|void
name|QDBusArgument
operator|::
name|appendVariant
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|v
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|appendVariantInternal
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Returns the type signature of the D-Bus type this QDBusArgument     object is currently pointing to. */
end_comment
begin_function
DECL|function|currentSignature
name|QString
name|QDBusArgument
operator|::
name|currentSignature
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|direction
operator|==
name|QDBusArgumentPrivate
operator|::
name|Demarshalling
condition|)
return|return
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|currentSignature
argument_list|()
return|;
else|else
return|return
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|currentSignature
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     Returns the classification of the current element type. If an     error decoding the type occurs or if we're at the end of the     argument, this function returns QDBusArgument::UnknownType.      This function only makes sense when demarshalling arguments. If it     is used while marshalling, it will always return UnknownType. */
end_comment
begin_function
DECL|function|currentType
name|QDBusArgument
operator|::
name|ElementType
name|QDBusArgument
operator|::
name|currentType
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|UnknownType
return|;
if|if
condition|(
name|d
operator|->
name|direction
operator|==
name|QDBusArgumentPrivate
operator|::
name|Demarshalling
condition|)
return|return
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|currentType
argument_list|()
return|;
return|return
name|UnknownType
return|;
block|}
end_function
begin_comment
comment|/*!     Extracts one D-BUS primitive argument of type \c{BYTE} from the     D-BUS stream and puts it into \a arg. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|uchar
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toByte
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Extracts one D-Bus primitive argument of type \c{BOOLEAN} from the     D-Bus stream. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|bool
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toBool
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Extracts one D-Bus primitive argument of type \c{UINT16} from the     D-Bus stream. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|ushort
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toUShort
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Extracts one D-Bus primitive argument of type \c{INT16} from the     D-Bus stream. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|short
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toShort
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Extracts one D-Bus primitive argument of type \c{INT32} from the     D-Bus stream. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|int
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toInt
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Extracts one D-Bus primitive argument of type \c{UINT32} from the     D-Bus stream. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|uint
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toUInt
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Extracts one D-Bus primitive argument of type \c{INT64} from the     D-Bus stream. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|qlonglong
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toLongLong
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Extracts one D-Bus primitive argument of type \c{UINT64} from the     D-Bus stream. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|qulonglong
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toULongLong
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Extracts one D-Bus primitive argument of type \c{DOUBLE}     (double-precision floating pount) from the D-Bus stream. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|double
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toDouble
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Extracts one D-Bus primitive argument of type \c{STRING} (Unicode     character string) from the D-Bus stream. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|QString
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toString
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \internal     Extracts one D-Bus primitive argument of type \c{OBJECT_PATH}     (D-Bus path to an object) from the D-Bus stream. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|QDBusObjectPath
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toObjectPath
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \internal     Extracts one D-Bus primitive argument of type \c{SIGNATURE} (D-Bus     type signature) from the D-Bus stream. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|QDBusSignature
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toSignature
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.8     \internal     Extracts one D-Bus primitive argument of type \c{UNIX_FILE_DESCRIPTOR}     (Unix file descriptor) from the D-Bus stream. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|QDBusUnixFileDescriptor
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toUnixFileDescriptor
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Extracts one D-Bus primitive argument of type \c{VARIANT} from the     D-Bus stream.      A D-Bus variant type can contain any type, including other     variants. It is similar to the Qt QVariant type.      In case the variant contains a type not directly supported by     QDBusArgument, the value of the returned QDBusVariant will contain     another QDBusArgument. It is your responsibility to further     demarshall it into another type. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|QDBusVariant
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toVariant
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Extracts an array of strings from the D-Bus stream and return it     as a QStringList.      QStringList and QByteArray are the only two non-primitive types     that are supported directly by QDBusArgument because of their     widespread usage in Qt applications.      Other arrays are supported through compound types in Qt D-Bus. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|QStringList
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toStringList
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Extracts an array of bytes from the D-Bus stream and return it     as a QByteArray.      QStringList and QByteArray are the only two non-primitive types     that are supported directly by QDBusArgument because of their     widespread usage in Qt applications.      Other arrays are supported through compound types in Qt D-Bus. */
end_comment
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|QDBusArgument
operator|::
name|operator
name|>>
parameter_list|(
name|QByteArray
modifier|&
name|arg
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|arg
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toByteArray
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Opens a new D-Bus structure suitable for appending new arguments.      This function is used usually in \c{operator<<} streaming     operators, as in the following example:      \snippet code/src_qdbus_qdbusargument.cpp 4      Structures can contain other structures, so the following code is     also valid:      \snippet code/src_qdbus_qdbusargument.cpp 5      \sa endStructure(), beginArray(), beginMap() */
end_comment
begin_function
DECL|function|beginStructure
name|void
name|QDBusArgument
operator|::
name|beginStructure
parameter_list|()
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|beginStructure
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Closes a D-Bus structure opened with beginStructure(). This function must be called     same number of times that beginStructure() is called.      \sa beginStructure(), endArray(), endMap() */
end_comment
begin_function
DECL|function|endStructure
name|void
name|QDBusArgument
operator|::
name|endStructure
parameter_list|()
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|endStructure
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Opens a new D-Bus array suitable for appending elements of meta-type \a id.      This function is used usually in \c{operator<<} streaming     operators, as in the following example:      \snippet code/src_qdbus_qdbusargument.cpp 6      If the type you want to marshall is a QList, QVector or any of the     Qt's \l {Container Classes} that take one template parameter,     you need not declare an \c{operator<<} function for it, since     Qt D-Bus provides generic templates to do the job of marshalling     the data. The same applies for STL's sequence containers, such     as \c {std::list}, \c {std::vector}, etc.      \sa endArray(), beginStructure(), beginMap() */
end_comment
begin_function
DECL|function|beginArray
name|void
name|QDBusArgument
operator|::
name|beginArray
parameter_list|(
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|beginArray
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Closes a D-Bus array opened with beginArray(). This function must be called     same number of times that beginArray() is called.      \sa beginArray(), endStructure(), endMap() */
end_comment
begin_function
DECL|function|endArray
name|void
name|QDBusArgument
operator|::
name|endArray
parameter_list|()
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|endArray
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Opens a new D-Bus map suitable for     appending elements. Maps are containers that associate one entry     (the key) to another (the value), such as Qt's QMap or QHash. The     ids of the map's key and value meta types must be passed in \a kid     and \a vid respectively.      This function is used usually in \c{operator<<} streaming     operators, as in the following example:      \snippet code/src_qdbus_qdbusargument.cpp 7      If the type you want to marshall is a QMap or QHash, you need not     declare an \c{operator<<} function for it, since Qt D-Bus provides     generic templates to do the job of marshalling the data.      \sa endMap(), beginStructure(), beginArray(), beginMapEntry() */
end_comment
begin_function
DECL|function|beginMap
name|void
name|QDBusArgument
operator|::
name|beginMap
parameter_list|(
name|int
name|kid
parameter_list|,
name|int
name|vid
parameter_list|)
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|beginMap
argument_list|(
name|kid
argument_list|,
name|vid
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Closes a D-Bus map opened with beginMap(). This function must be called     same number of times that beginMap() is called.      \sa beginMap(), endStructure(), endArray() */
end_comment
begin_function
DECL|function|endMap
name|void
name|QDBusArgument
operator|::
name|endMap
parameter_list|()
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|endMap
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Opens a D-Bus map entry suitable for     appending the key and value entries. This function is only valid     when a map has been opened with beginMap().      See beginMap() for an example of usage of this function.      \sa endMapEntry(), beginMap() */
end_comment
begin_function
DECL|function|beginMapEntry
name|void
name|QDBusArgument
operator|::
name|beginMapEntry
parameter_list|()
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|beginMapEntry
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Closes a D-Bus map entry opened with beginMapEntry(). This function must be called     same number of times that beginMapEntry() is called.      \sa beginMapEntry() */
end_comment
begin_function
DECL|function|endMapEntry
name|void
name|QDBusArgument
operator|::
name|endMapEntry
parameter_list|()
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkWrite
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|marshaller
argument_list|()
operator|->
name|endMapEntry
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Opens a D-Bus structure suitable for extracting elements.      This function is used usually in \c{operator>>} streaming     operators, as in the following example:      \snippet code/src_qdbus_qdbusargument.cpp 8      \sa endStructure(), beginArray(), beginMap() */
end_comment
begin_function
DECL|function|beginStructure
name|void
name|QDBusArgument
operator|::
name|beginStructure
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|beginStructure
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Closes the D-Bus structure and allow extracting of the next element     after the structure.      \sa beginStructure() */
end_comment
begin_function
DECL|function|endStructure
name|void
name|QDBusArgument
operator|::
name|endStructure
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|endStructure
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Recurses into the D-Bus array to allow extraction of     the array elements.      This function is used usually in \c{operator>>} streaming     operators, as in the following example:      \snippet code/src_qdbus_qdbusargument.cpp 9      If the type you want to demarshall is a QList, QVector or any of the     Qt's \l {Container Classes} that take one template parameter, you     need not declare an \c{operator>>} function for it, since Qt D-Bus     provides generic templates to do the job of demarshalling the data.     The same applies for STL's sequence containers, such as \c {std::list},     \c {std::vector}, etc.      \sa atEnd(), beginStructure(), beginMap() */
end_comment
begin_function
DECL|function|beginArray
name|void
name|QDBusArgument
operator|::
name|beginArray
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|beginArray
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Closes the D-Bus array and allow extracting of the next element     after the array.      \sa beginArray() */
end_comment
begin_function
DECL|function|endArray
name|void
name|QDBusArgument
operator|::
name|endArray
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|endArray
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Recurses into the D-Bus map to allow extraction of     the map's elements.      This function is used usually in \c{operator>>} streaming     operators, as in the following example:      \snippet code/src_qdbus_qdbusargument.cpp 10      If the type you want to demarshall is a QMap or QHash, you need not     declare an \c{operator>>} function for it, since Qt D-Bus provides     generic templates to do the job of demarshalling the data.      \sa endMap(), beginStructure(), beginArray(), beginMapEntry() */
end_comment
begin_function
DECL|function|beginMap
name|void
name|QDBusArgument
operator|::
name|beginMap
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|beginMap
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Closes the D-Bus map and allow extracting of the next element     after the map.      \sa beginMap() */
end_comment
begin_function
DECL|function|endMap
name|void
name|QDBusArgument
operator|::
name|endMap
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|endMap
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Recurses into the D-Bus map entry to allow extraction     of the key and value pair.      See beginMap() for an example of how this function is usually used.      \sa endMapEntry(), beginMap() */
end_comment
begin_function
DECL|function|beginMapEntry
name|void
name|QDBusArgument
operator|::
name|beginMapEntry
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|beginMapEntry
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Closes the D-Bus map entry and allow extracting of the next element     on the map.      \sa beginMapEntry() */
end_comment
begin_function
DECL|function|endMapEntry
name|void
name|QDBusArgument
operator|::
name|endMapEntry
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkReadAndDetach
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|endMapEntry
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if there are no more elements to be extracted from     this QDBusArgument. This function is usually used in QDBusArgument     objects returned from beginMap() and beginArray(). */
end_comment
begin_function
DECL|function|atEnd
name|bool
name|QDBusArgument
operator|::
name|atEnd
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkRead
argument_list|(
name|d
argument_list|)
condition|)
return|return
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|atEnd
argument_list|()
return|;
return|return
literal|true
return|;
comment|// at least, stop reading
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the current argument in the form of a QVariant. Basic     types will be decoded and returned in the QVariant, but for     complex types, this function will return a QDBusArgument object in     the QVariant. It is the caller's responsibility to decode the     argument (for example, by calling asVariant() in it).      For example, if the current argument is an INT32, this function     will return a QVariant with an argument of type QVariant::Int. For     an array of INT32, it will return a QVariant containing a     QDBusArgument.      If an error occurs or if there are no more arguments to decode     (i.e., we are at the end of the argument list), this function will     return an invalid QVariant.      \sa atEnd() */
end_comment
begin_function
DECL|function|asVariant
name|QVariant
name|QDBusArgument
operator|::
name|asVariant
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QDBusArgumentPrivate
operator|::
name|checkRead
argument_list|(
name|d
argument_list|)
condition|)
return|return
name|d
operator|->
name|demarshaller
argument_list|()
operator|->
name|toVariantInternal
argument_list|()
return|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_function
name|QT_END_NAMESPACE
comment|// for optimization purposes, we include the marshallers here
include|#
directive|include
file|"qdbusmarshaller.cpp"
include|#
directive|include
file|"qdbusdemarshaller.cpp"
name|QT_BEGIN_NAMESPACE
comment|// QDBusArgument operators
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|operator
name|>>
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|a
parameter_list|,
name|QVariant
modifier|&
name|v
parameter_list|)
block|{
name|QDBusVariant
name|dbv
decl_stmt|;
name|a
operator|>>
name|dbv
expr_stmt|;
name|v
operator|=
name|dbv
operator|.
name|variant
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_comment
comment|// QVariant types
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QDBUS_NO_SPECIALTYPES
end_ifndef
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|operator
name|>>
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|a
parameter_list|,
name|QDate
modifier|&
name|date
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|>>
name|y
operator|>>
name|m
operator|>>
name|d
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
operator|&&
name|m
operator|!=
literal|0
operator|&&
name|d
operator|!=
literal|0
condition|)
name|date
operator|.
name|setDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|else
name|date
operator|=
name|QDate
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|operator
name|<<
parameter_list|(
name|QDBusArgument
modifier|&
name|a
parameter_list|,
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
block|{
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
if|if
condition|(
name|date
operator|.
name|isValid
argument_list|()
condition|)
name|a
operator|<<
name|date
operator|.
name|year
argument_list|()
operator|<<
name|date
operator|.
name|month
argument_list|()
operator|<<
name|date
operator|.
name|day
argument_list|()
expr_stmt|;
else|else
name|a
operator|<<
literal|0
operator|<<
literal|0
operator|<<
literal|0
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|operator
name|>>
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|a
parameter_list|,
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|int
name|h
decl_stmt|,
name|m
decl_stmt|,
name|s
decl_stmt|,
name|ms
decl_stmt|;
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|>>
name|h
operator|>>
name|m
operator|>>
name|s
operator|>>
name|ms
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
if|if
condition|(
name|h
operator|<
literal|0
condition|)
name|time
operator|=
name|QTime
argument_list|()
expr_stmt|;
else|else
name|time
operator|.
name|setHMS
argument_list|(
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|,
name|ms
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|operator
name|<<
parameter_list|(
name|QDBusArgument
modifier|&
name|a
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
if|if
condition|(
name|time
operator|.
name|isValid
argument_list|()
condition|)
name|a
operator|<<
name|time
operator|.
name|hour
argument_list|()
operator|<<
name|time
operator|.
name|minute
argument_list|()
operator|<<
name|time
operator|.
name|second
argument_list|()
operator|<<
name|time
operator|.
name|msec
argument_list|()
expr_stmt|;
else|else
name|a
operator|<<
operator|-
literal|1
operator|<<
operator|-
literal|1
operator|<<
operator|-
literal|1
operator|<<
operator|-
literal|1
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|operator
name|>>
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|a
parameter_list|,
name|QDateTime
modifier|&
name|dt
parameter_list|)
block|{
name|QDate
name|date
decl_stmt|;
name|QTime
name|time
decl_stmt|;
name|int
name|timespec
decl_stmt|;
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|>>
name|date
operator|>>
name|time
operator|>>
name|timespec
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
name|dt
operator|=
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|TimeSpec
argument_list|(
name|timespec
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|operator
name|<<
parameter_list|(
name|QDBusArgument
modifier|&
name|a
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|dt
parameter_list|)
block|{
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|<<
name|dt
operator|.
name|date
argument_list|()
operator|<<
name|dt
operator|.
name|time
argument_list|()
operator|<<
name|int
argument_list|(
name|dt
operator|.
name|timeSpec
argument_list|()
argument_list|)
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|operator
name|>>
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|a
parameter_list|,
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|>>
name|x
operator|>>
name|y
operator|>>
name|width
operator|>>
name|height
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
name|rect
operator|.
name|setRect
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|operator
name|<<
parameter_list|(
name|QDBusArgument
modifier|&
name|a
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|<<
name|rect
operator|.
name|x
argument_list|()
operator|<<
name|rect
operator|.
name|y
argument_list|()
operator|<<
name|rect
operator|.
name|width
argument_list|()
operator|<<
name|rect
operator|.
name|height
argument_list|()
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|operator
name|>>
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|a
parameter_list|,
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|double
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|>>
name|x
operator|>>
name|y
operator|>>
name|width
operator|>>
name|height
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
name|rect
operator|.
name|setRect
argument_list|(
name|qreal
argument_list|(
name|x
argument_list|)
argument_list|,
name|qreal
argument_list|(
name|y
argument_list|)
argument_list|,
name|qreal
argument_list|(
name|width
argument_list|)
argument_list|,
name|qreal
argument_list|(
name|height
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|operator
name|<<
parameter_list|(
name|QDBusArgument
modifier|&
name|a
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|<<
name|double
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|rect
operator|.
name|y
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|rect
operator|.
name|width
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|rect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|operator
name|>>
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|a
parameter_list|,
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|>>
name|size
operator|.
name|rwidth
argument_list|()
operator|>>
name|size
operator|.
name|rheight
argument_list|()
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|operator
name|<<
parameter_list|(
name|QDBusArgument
modifier|&
name|a
parameter_list|,
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|<<
name|size
operator|.
name|width
argument_list|()
operator|<<
name|size
operator|.
name|height
argument_list|()
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|operator
name|>>
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|a
parameter_list|,
name|QSizeF
modifier|&
name|size
parameter_list|)
block|{
name|double
name|width
decl_stmt|,
name|height
decl_stmt|;
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|>>
name|width
operator|>>
name|height
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
name|size
operator|.
name|setWidth
argument_list|(
name|qreal
argument_list|(
name|width
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|.
name|setHeight
argument_list|(
name|qreal
argument_list|(
name|height
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|operator
name|<<
parameter_list|(
name|QDBusArgument
modifier|&
name|a
parameter_list|,
specifier|const
name|QSizeF
modifier|&
name|size
parameter_list|)
block|{
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|<<
name|double
argument_list|(
name|size
operator|.
name|width
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|operator
name|>>
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|a
parameter_list|,
name|QPoint
modifier|&
name|pt
parameter_list|)
block|{
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|>>
name|pt
operator|.
name|rx
argument_list|()
operator|>>
name|pt
operator|.
name|ry
argument_list|()
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|operator
name|<<
parameter_list|(
name|QDBusArgument
modifier|&
name|a
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|pt
parameter_list|)
block|{
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|<<
name|pt
operator|.
name|x
argument_list|()
operator|<<
name|pt
operator|.
name|y
argument_list|()
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|operator
name|>>
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|a
parameter_list|,
name|QPointF
modifier|&
name|pt
parameter_list|)
block|{
name|double
name|x
decl_stmt|,
name|y
decl_stmt|;
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|>>
name|x
operator|>>
name|y
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
name|pt
operator|.
name|setX
argument_list|(
name|qreal
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|.
name|setY
argument_list|(
name|qreal
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|operator
name|<<
parameter_list|(
name|QDBusArgument
modifier|&
name|a
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pt
parameter_list|)
block|{
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|<<
name|double
argument_list|(
name|pt
operator|.
name|x
argument_list|()
argument_list|)
operator|<<
name|double
argument_list|(
name|pt
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|operator
name|>>
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|a
parameter_list|,
name|QLine
modifier|&
name|line
parameter_list|)
block|{
name|QPoint
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|>>
name|p1
operator|>>
name|p2
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
name|line
operator|=
name|QLine
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|operator
name|<<
parameter_list|(
name|QDBusArgument
modifier|&
name|a
parameter_list|,
specifier|const
name|QLine
modifier|&
name|line
parameter_list|)
block|{
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|<<
name|line
operator|.
name|p1
argument_list|()
operator|<<
name|line
operator|.
name|p2
argument_list|()
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator >>
specifier|const
name|QDBusArgument
modifier|&
name|operator
name|>>
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|a
parameter_list|,
name|QLineF
modifier|&
name|line
parameter_list|)
block|{
name|QPointF
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|>>
name|p1
operator|>>
name|p2
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
name|line
operator|=
name|QLineF
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDBusArgument
modifier|&
name|operator
name|<<
parameter_list|(
name|QDBusArgument
modifier|&
name|a
parameter_list|,
specifier|const
name|QLineF
modifier|&
name|line
parameter_list|)
block|{
name|a
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|a
operator|<<
name|line
operator|.
name|p1
argument_list|()
operator|<<
name|line
operator|.
name|p2
argument_list|()
expr_stmt|;
name|a
operator|.
name|endStructure
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DBUS
end_comment
end_unit
