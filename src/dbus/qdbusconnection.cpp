begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Copyright (C) 2015 Intel Corporation. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtDBus module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdbusconnection.h"
end_include
begin_include
include|#
directive|include
file|"qdbusconnection_p.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qtimer.h>
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|"qdbusconnectioninterface.h"
end_include
begin_include
include|#
directive|include
file|"qdbuserror.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmessage.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmessage_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusinterface_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusutil_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusconnectionmanager_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbuspendingcall_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusthreaddebug_p.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|interface
end_ifdef
begin_undef
DECL|macro|interface
undef|#
directive|undef
name|interface
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DBUS
end_ifndef
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|Q_GLOBAL_STATIC
argument_list|(
name|QDBusConnectionManager
argument_list|,
name|_q_manager
argument_list|)
comment|// can be replaced with a lambda in Qt 5.7
DECL|class|QDBusConnectionDispatchEnabler
name|class
name|QDBusConnectionDispatchEnabler
range|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
DECL|member|con
name|QDBusConnectionPrivate
operator|*
name|con
block|;
specifier|public
operator|:
DECL|function|QDBusConnectionDispatchEnabler
name|QDBusConnectionDispatchEnabler
argument_list|(
name|QDBusConnectionPrivate
operator|*
name|con
argument_list|)
operator|:
name|con
argument_list|(
argument|con
argument_list|)
block|{}
specifier|public
name|slots
operator|:
DECL|function|execute
name|void
name|execute
argument_list|()
block|{
name|con
operator|->
name|setDispatchEnabled
argument_list|(
literal|true
argument_list|)
block|;
if|if
condition|(
operator|!
name|con
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|con
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
name|deleteLater
argument_list|()
block|;     }
end_decl_stmt
begin_struct
DECL|struct|ConnectionRequestData
unit|};
struct|struct
name|QDBusConnectionManager
operator|::
name|ConnectionRequestData
block|{
DECL|enum|RequestType
enum|enum
name|RequestType
block|{
DECL|enumerator|ConnectToStandardBus
name|ConnectToStandardBus
block|,
DECL|enumerator|ConnectToBusByAddress
name|ConnectToBusByAddress
block|,
DECL|enumerator|ConnectToPeerByAddress
name|ConnectToPeerByAddress
block|}
DECL|member|type
name|type
enum|;
union|union
block|{
DECL|member|busType
name|QDBusConnection
operator|::
name|BusType
name|busType
decl_stmt|;
DECL|member|busAddress
specifier|const
name|QString
modifier|*
name|busAddress
decl_stmt|;
block|}
union|;
DECL|member|name
specifier|const
name|QString
modifier|*
name|name
decl_stmt|;
DECL|member|result
name|QDBusConnectionPrivate
modifier|*
name|result
decl_stmt|;
DECL|member|suspendedDelivery
name|bool
name|suspendedDelivery
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|busConnection
name|QDBusConnectionPrivate
modifier|*
name|QDBusConnectionManager
operator|::
name|busConnection
parameter_list|(
name|QDBusConnection
operator|::
name|BusType
name|type
parameter_list|)
block|{
name|Q_STATIC_ASSERT
argument_list|(
name|int
argument_list|(
name|QDBusConnection
operator|::
name|SessionBus
argument_list|)
operator|+
name|int
argument_list|(
name|QDBusConnection
operator|::
name|SystemBus
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|type
operator|==
name|QDBusConnection
operator|::
name|SessionBus
operator|||
name|type
operator|==
name|QDBusConnection
operator|::
name|SystemBus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qdbus_loadLibDBus
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// we'll start in suspended delivery mode if we're in the main thread
comment|// (the event loop will resume delivery)
name|bool
name|suspendedDelivery
init|=
name|qApp
operator|&&
name|qApp
operator|->
name|thread
argument_list|()
operator|==
name|QThread
operator|::
name|currentThread
argument_list|()
decl_stmt|;
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|defaultBusMutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultBuses
index|[
name|type
index|]
condition|)
return|return
name|defaultBuses
index|[
name|type
index|]
return|;
name|QString
name|name
init|=
name|QStringLiteral
argument_list|(
literal|"qt_default_session_bus"
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|QDBusConnection
operator|::
name|SystemBus
condition|)
name|name
operator|=
name|QStringLiteral
argument_list|(
literal|"qt_default_system_bus"
argument_list|)
expr_stmt|;
return|return
name|defaultBuses
index|[
name|type
index|]
operator|=
name|connectToBus
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
name|suspendedDelivery
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|connection
name|QDBusConnectionPrivate
modifier|*
name|QDBusConnectionManager
operator|::
name|connection
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|connectionHash
operator|.
name|value
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|removeConnection
name|void
name|QDBusConnectionManager
operator|::
name|removeConnection
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
literal|0
decl_stmt|;
name|d
operator|=
name|connectionHash
operator|.
name|take
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|d
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
comment|// Static objects may be keeping the connection open.
comment|// However, it is harmless to have outstanding references to a connection that is
comment|// closing as long as those references will be soon dropped without being used.
comment|// ### Output a warning if connections are being used after they have been removed.
block|}
end_function
begin_constructor
DECL|function|QDBusConnectionManager
name|QDBusConnectionManager
operator|::
name|QDBusConnectionManager
parameter_list|()
block|{
name|connect
argument_list|(
name|this
argument_list|,
operator|&
name|QDBusConnectionManager
operator|::
name|connectionRequested
argument_list|,
name|this
argument_list|,
operator|&
name|QDBusConnectionManager
operator|::
name|executeConnectionRequest
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
operator|&
name|QDBusConnectionManager
operator|::
name|serverRequested
argument_list|,
name|this
argument_list|,
operator|&
name|QDBusConnectionManager
operator|::
name|createServer
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
name|moveToThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// ugly, don't do this in other projects
name|defaultBuses
index|[
literal|0
index|]
operator|=
name|defaultBuses
index|[
literal|1
index|]
operator|=
name|Q_NULLPTR
expr_stmt|;
name|start
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QDBusConnectionManager
name|QDBusConnectionManager
operator|::
name|~
name|QDBusConnectionManager
parameter_list|()
block|{
name|quit
argument_list|()
expr_stmt|;
name|wait
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|instance
name|QDBusConnectionManager
modifier|*
name|QDBusConnectionManager
operator|::
name|instance
parameter_list|()
block|{
return|return
name|_q_manager
argument_list|()
return|;
block|}
end_function
begin_function_decl
name|Q_DBUS_EXPORT
name|void
name|qDBusBindToApplication
parameter_list|()
function_decl|;
end_function_decl
begin_function
DECL|function|qDBusBindToApplication
name|void
name|qDBusBindToApplication
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|setConnection
name|void
name|QDBusConnectionManager
operator|::
name|setConnection
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|QDBusConnectionPrivate
modifier|*
name|c
parameter_list|)
block|{
name|connectionHash
index|[
name|name
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function
begin_function
DECL|function|run
name|void
name|QDBusConnectionManager
operator|::
name|run
parameter_list|()
block|{
name|exec
argument_list|()
expr_stmt|;
comment|// cleanup:
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
for|for
control|(
name|QHash
argument_list|<
name|QString
argument_list|,
name|QDBusConnectionPrivate
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|connectionHash
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|connectionHash
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
block|{
operator|delete
name|d
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|closeConnection
argument_list|()
expr_stmt|;
name|d
operator|->
name|moveToThread
argument_list|(
name|Q_NULLPTR
argument_list|)
expr_stmt|;
comment|// allow it to be deleted in another thread
block|}
block|}
name|connectionHash
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// allow deletion from any thread without warning
name|moveToThread
argument_list|(
name|Q_NULLPTR
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|connectToBus
name|QDBusConnectionPrivate
modifier|*
name|QDBusConnectionManager
operator|::
name|connectToBus
parameter_list|(
name|QDBusConnection
operator|::
name|BusType
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|suspendedDelivery
parameter_list|)
block|{
name|ConnectionRequestData
name|data
decl_stmt|;
name|data
operator|.
name|type
operator|=
name|ConnectionRequestData
operator|::
name|ConnectToStandardBus
expr_stmt|;
name|data
operator|.
name|busType
operator|=
name|type
expr_stmt|;
name|data
operator|.
name|name
operator|=
operator|&
name|name
expr_stmt|;
name|data
operator|.
name|suspendedDelivery
operator|=
name|suspendedDelivery
expr_stmt|;
emit|emit
name|connectionRequested
argument_list|(
operator|&
name|data
argument_list|)
emit|;
if|if
condition|(
name|suspendedDelivery
operator|&&
name|data
operator|.
name|result
operator|->
name|connection
condition|)
block|{
name|data
operator|.
name|result
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|QDBusConnectionDispatchEnabler
modifier|*
name|o
init|=
operator|new
name|QDBusConnectionDispatchEnabler
argument_list|(
name|data
operator|.
name|result
argument_list|)
decl_stmt|;
name|QTimer
operator|::
name|singleShot
argument_list|(
literal|0
argument_list|,
name|o
argument_list|,
name|SLOT
argument_list|(
name|execute
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|moveToThread
argument_list|(
name|qApp
operator|->
name|thread
argument_list|()
argument_list|)
expr_stmt|;
comment|// qApp was checked in the caller
block|}
return|return
name|data
operator|.
name|result
return|;
block|}
end_function
begin_function
DECL|function|connectToBus
name|QDBusConnectionPrivate
modifier|*
name|QDBusConnectionManager
operator|::
name|connectToBus
parameter_list|(
specifier|const
name|QString
modifier|&
name|address
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|ConnectionRequestData
name|data
decl_stmt|;
name|data
operator|.
name|type
operator|=
name|ConnectionRequestData
operator|::
name|ConnectToBusByAddress
expr_stmt|;
name|data
operator|.
name|busAddress
operator|=
operator|&
name|address
expr_stmt|;
name|data
operator|.
name|name
operator|=
operator|&
name|name
expr_stmt|;
name|data
operator|.
name|suspendedDelivery
operator|=
literal|false
expr_stmt|;
emit|emit
name|connectionRequested
argument_list|(
operator|&
name|data
argument_list|)
emit|;
return|return
name|data
operator|.
name|result
return|;
block|}
end_function
begin_function
DECL|function|connectToPeer
name|QDBusConnectionPrivate
modifier|*
name|QDBusConnectionManager
operator|::
name|connectToPeer
parameter_list|(
specifier|const
name|QString
modifier|&
name|address
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|ConnectionRequestData
name|data
decl_stmt|;
name|data
operator|.
name|type
operator|=
name|ConnectionRequestData
operator|::
name|ConnectToPeerByAddress
expr_stmt|;
name|data
operator|.
name|busAddress
operator|=
operator|&
name|address
expr_stmt|;
name|data
operator|.
name|name
operator|=
operator|&
name|name
expr_stmt|;
name|data
operator|.
name|suspendedDelivery
operator|=
literal|false
expr_stmt|;
emit|emit
name|connectionRequested
argument_list|(
operator|&
name|data
argument_list|)
emit|;
return|return
name|data
operator|.
name|result
return|;
block|}
end_function
begin_function
DECL|function|executeConnectionRequest
name|void
name|QDBusConnectionManager
operator|::
name|executeConnectionRequest
parameter_list|(
name|QDBusConnectionManager
operator|::
name|ConnectionRequestData
modifier|*
name|data
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
specifier|const
name|QString
modifier|&
name|name
init|=
operator|*
name|data
operator|->
name|name
decl_stmt|;
name|QDBusConnectionPrivate
modifier|*
modifier|&
name|d
init|=
name|data
operator|->
name|result
decl_stmt|;
comment|// check if the connection exists by name
name|d
operator|=
name|connection
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|||
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|d
operator|=
operator|new
name|QDBusConnectionPrivate
expr_stmt|;
name|DBusConnection
modifier|*
name|c
init|=
literal|0
decl_stmt|;
name|QDBusErrorInternal
name|error
decl_stmt|;
switch|switch
condition|(
name|data
operator|->
name|type
condition|)
block|{
case|case
name|ConnectionRequestData
operator|::
name|ConnectToStandardBus
case|:
switch|switch
condition|(
name|data
operator|->
name|busType
condition|)
block|{
case|case
name|QDBusConnection
operator|::
name|SystemBus
case|:
name|c
operator|=
name|q_dbus_bus_get_private
argument_list|(
name|DBUS_BUS_SYSTEM
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDBusConnection
operator|::
name|SessionBus
case|:
name|c
operator|=
name|q_dbus_bus_get_private
argument_list|(
name|DBUS_BUS_SESSION
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDBusConnection
operator|::
name|ActivationBus
case|:
name|c
operator|=
name|q_dbus_bus_get_private
argument_list|(
name|DBUS_BUS_STARTER
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ConnectionRequestData
operator|::
name|ConnectToBusByAddress
case|:
case|case
name|ConnectionRequestData
operator|::
name|ConnectToPeerByAddress
case|:
name|c
operator|=
name|q_dbus_connection_open_private
argument_list|(
name|data
operator|->
name|busAddress
operator|->
name|toUtf8
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&&
name|data
operator|->
name|type
operator|==
name|ConnectionRequestData
operator|::
name|ConnectToBusByAddress
condition|)
block|{
comment|// register on the bus
if|if
condition|(
operator|!
name|q_dbus_bus_register
argument_list|(
name|c
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|q_dbus_connection_unref
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
block|}
name|setConnection
argument_list|(
name|name
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|type
operator|==
name|ConnectionRequestData
operator|::
name|ConnectToPeerByAddress
condition|)
block|{
name|d
operator|->
name|setPeer
argument_list|(
name|c
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// create the bus service
comment|// will lock in QDBusConnectionPrivate::connectRelay()
name|d
operator|->
name|setConnection
argument_list|(
name|c
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|d
operator|->
name|createBusService
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|&&
name|data
operator|->
name|suspendedDelivery
condition|)
name|d
operator|->
name|setDispatchEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|createServer
name|void
name|QDBusConnectionManager
operator|::
name|createServer
parameter_list|(
specifier|const
name|QString
modifier|&
name|address
parameter_list|,
name|void
modifier|*
name|server
parameter_list|)
block|{
name|QDBusErrorInternal
name|error
decl_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
operator|new
name|QDBusConnectionPrivate
decl_stmt|;
name|d
operator|->
name|setServer
argument_list|(
cast|static_cast
argument_list|<
name|QDBusServer
operator|*
argument_list|>
argument_list|(
name|server
argument_list|)
argument_list|,
name|q_dbus_server_listen
argument_list|(
name|address
operator|.
name|toUtf8
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|error
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QDBusConnection     \inmodule QtDBus     \since 4.2      \brief The QDBusConnection class represents a connection to the D-Bus bus daemon.      This class is the initial point in a D-Bus session. Using it, you     can get access to remote objects, interfaces; connect remote     signals to your object's slots; register objects, etc.      D-Bus connections are created using the connectToBus() function,     which opens a connection to the server daemon and does the initial     handshaking, associating that connection with a name. Further     attempts to connect using the same name will return the same     connection.      The connection is then torn down using the disconnectFromBus()     function.      Once disconnected, calling connectToBus() will not reestablish a     connection, you must create a new QDBusConnection instance.      As a convenience for the two most common connection types, the     sessionBus() and systemBus() functions return open connections to     the session server daemon and the system server daemon,     respectively. Those connections are opened when first used and are     closed when the QCoreApplication destructor is run.      D-Bus also supports peer-to-peer connections, without the need for     a bus server daemon. Using this facility, two applications can     talk to each other and exchange messages. This can be achieved by     passing an address to connectToBus() function, which was opened by     another D-Bus application using QDBusServer. */
end_comment
begin_comment
comment|/*!     \enum QDBusConnection::BusType     Specifies the type of the bus connection. The valid bus types are:      \value SessionBus           the session bus, associated with the running desktop session     \value SystemBus            the system bus, used to communicate with system-wide processes     \value ActivationBus        the activation bus, the "alias" for the bus that started the                                 service      On the Session Bus, one can find other applications by the same user that are sharing the same     desktop session (hence the name). On the System Bus, however, processes shared for the whole     system are usually found. */
end_comment
begin_comment
comment|/*!     \enum QDBusConnection::RegisterOption     Specifies the options for registering objects with the connection. The possible values are:      \value ExportAdaptors                       export the contents of adaptors found in this object      \value ExportScriptableSlots                export this object's scriptable slots     \value ExportScriptableSignals              export this object's scriptable signals     \value ExportScriptableProperties           export this object's scriptable properties     \value ExportScriptableInvokables           export this object's scriptable invokables     \value ExportScriptableContents             shorthand form for ExportScriptableSlots |                                                 ExportScriptableSignals |                                                 ExportScriptableProperties      \value ExportNonScriptableSlots             export this object's non-scriptable slots     \value ExportNonScriptableSignals           export this object's non-scriptable signals     \value ExportNonScriptableProperties        export this object's non-scriptable properties     \value ExportNonScriptableInvokables        export this object's non-scriptable invokables     \value ExportNonScriptableContents          shorthand form for ExportNonScriptableSlots |                                                 ExportNonScriptableSignals |                                                 ExportNonScriptableProperties      \value ExportAllSlots                       export all of this object's slots     \value ExportAllSignals                     export all of this object's signals     \value ExportAllProperties                  export all of this object's properties     \value ExportAllInvokables                  export all of this object's invokables     \value ExportAllContents                    export all of this object's contents     \value ExportChildObjects                   export this object's child objects      \sa registerObject(), QDBusAbstractAdaptor, {usingadaptors.html}{Using adaptors} */
end_comment
begin_comment
comment|/*!     \internal     \since 4.8     \enum QDBusConnection::VirtualObjectRegisterOption     Specifies the options for registering virtual objects with the connection. The possible values are:      \value SingleNode                           register a virtual object to handle one path only     \value SubPath                              register a virtual object so that it handles all sub paths      \sa registerVirtualObject(), QDBusVirtualObject */
end_comment
begin_comment
comment|/*!     \enum QDBusConnection::UnregisterMode     The mode for unregistering an object path:      \value UnregisterNode       unregister this node only: do not unregister child objects     \value UnregisterTree       unregister this node and all its sub-tree      Note, however, if this object was registered with the ExportChildObjects option, UnregisterNode     will unregister the child objects too. */
end_comment
begin_comment
comment|/*!     \since 4.8     \enum QDBusConnection::ConnectionCapability      This enum describes the available capabilities for a D-Bus connection.      \value UnixFileDescriptorPassing        enables passing of Unix file descriptors to other processes                                             (see QDBusUnixFileDescriptor)      \sa connectionCapabilities() */
end_comment
begin_comment
comment|/*!     Creates a QDBusConnection object attached to the connection with name \a name.      This does not open the connection. You have to call connectToBus() to open it. */
end_comment
begin_constructor
DECL|function|QDBusConnection
name|QDBusConnection
operator|::
name|QDBusConnection
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|_q_manager
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|d
operator|=
name|_q_manager
argument_list|()
operator|->
name|connection
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Creates a copy of the \a other connection. */
end_comment
begin_constructor
DECL|function|QDBusConnection
name|QDBusConnection
operator|::
name|QDBusConnection
parameter_list|(
specifier|const
name|QDBusConnection
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!   \internal    Creates a connection object with the given \a dd as private object. */
end_comment
begin_constructor
DECL|function|QDBusConnection
name|QDBusConnection
operator|::
name|QDBusConnection
parameter_list|(
name|QDBusConnectionPrivate
modifier|*
name|dd
parameter_list|)
block|{
name|d
operator|=
name|dd
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Disposes of this object. This does not close the connection: you     have to call disconnectFromBus() to do that. */
end_comment
begin_destructor
DECL|function|~QDBusConnection
name|QDBusConnection
operator|::
name|~
name|QDBusConnection
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|d
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Creates a copy of the connection \a other in this object. Note     that the connection this object referenced before the copy, is not     spontaneously disconnected.      \sa disconnectFromBus() */
end_comment
begin_function
DECL|function|operator =
name|QDBusConnection
modifier|&
name|QDBusConnection
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDBusConnection
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|.
name|d
condition|)
name|other
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|d
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Opens a connection of type \a type to one of the known busses and     associate with it the connection name \a name. Returns a     QDBusConnection object associated with that connection. */
end_comment
begin_function
DECL|function|connectToBus
name|QDBusConnection
name|QDBusConnection
operator|::
name|connectToBus
parameter_list|(
name|BusType
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qdbus_loadLibDBus
argument_list|()
condition|)
block|{
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
literal|0
decl_stmt|;
return|return
name|QDBusConnection
argument_list|(
name|d
argument_list|)
return|;
block|}
return|return
name|QDBusConnection
argument_list|(
name|_q_manager
argument_list|()
operator|->
name|connectToBus
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Opens a connection to a private bus on address \a address and associate with it the     connection name \a name. Returns a QDBusConnection object associated with that connection. */
end_comment
begin_function
DECL|function|connectToBus
name|QDBusConnection
name|QDBusConnection
operator|::
name|connectToBus
parameter_list|(
specifier|const
name|QString
modifier|&
name|address
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qdbus_loadLibDBus
argument_list|()
condition|)
block|{
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
literal|0
decl_stmt|;
return|return
name|QDBusConnection
argument_list|(
name|d
argument_list|)
return|;
block|}
return|return
name|QDBusConnection
argument_list|(
name|_q_manager
argument_list|()
operator|->
name|connectToBus
argument_list|(
name|address
argument_list|,
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Opens a peer-to-peer connection on address \a address and associate with it the     connection name \a name. Returns a QDBusConnection object associated with that connection. */
end_comment
begin_function
DECL|function|connectToPeer
name|QDBusConnection
name|QDBusConnection
operator|::
name|connectToPeer
parameter_list|(
specifier|const
name|QString
modifier|&
name|address
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qdbus_loadLibDBus
argument_list|()
condition|)
block|{
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
literal|0
decl_stmt|;
return|return
name|QDBusConnection
argument_list|(
name|d
argument_list|)
return|;
block|}
return|return
name|QDBusConnection
argument_list|(
name|_q_manager
argument_list|()
operator|->
name|connectToPeer
argument_list|(
name|address
argument_list|,
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Closes the bus connection of name \a name.      Note that if there are still QDBusConnection objects associated     with the same connection, the connection will not be closed until     all references are dropped. However, no further references can be     created using the QDBusConnection constructor. */
end_comment
begin_function
DECL|function|disconnectFromBus
name|void
name|QDBusConnection
operator|::
name|disconnectFromBus
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|_q_manager
argument_list|()
condition|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|_q_manager
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
name|_q_manager
argument_list|()
operator|->
name|connection
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|mode
operator|!=
name|QDBusConnectionPrivate
operator|::
name|ClientMode
condition|)
return|return;
name|_q_manager
argument_list|()
operator|->
name|removeConnection
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Closes the peer connection of name \a name.      Note that if there are still QDBusConnection objects associated     with the same connection, the connection will not be closed until     all references are dropped. However, no further references can be     created using the QDBusConnection constructor. */
end_comment
begin_function
DECL|function|disconnectFromPeer
name|void
name|QDBusConnection
operator|::
name|disconnectFromPeer
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|_q_manager
argument_list|()
condition|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|_q_manager
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
name|_q_manager
argument_list|()
operator|->
name|connection
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|mode
operator|!=
name|QDBusConnectionPrivate
operator|::
name|PeerMode
condition|)
return|return;
name|_q_manager
argument_list|()
operator|->
name|removeConnection
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Sends the \a message over this connection, without waiting for a     reply. This is suitable for errors, signals, and return values as     well as calls whose return values are not necessary.      Returns \c true if the message was queued successfully, false otherwise. */
end_comment
begin_function
DECL|function|send
name|bool
name|QDBusConnection
operator|::
name|send
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
condition|)
block|{
name|QDBusError
name|err
init|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|Disconnected
argument_list|,
name|QDBusUtil
operator|::
name|disconnectedErrorMessage
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|lastError
operator|=
name|err
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|send
argument_list|(
name|message
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sends the \a message over this connection and returns immediately.     When the reply is received, the method \a returnMethod is called in     the \a receiver object. If an error occurs, the method \a errorMethod     will be called instead.      If no reply is received within \a timeout milliseconds, an automatic     error will be delivered indicating the expiration of the call.     The default \a timeout is -1, which will be replaced with an     implementation-defined value that is suitable for inter-process     communications (generally, 25 seconds).      This function is suitable for method calls only. It is guaranteed     that the slot will be called exactly once with the reply, as long     as the parameter types match and no error occurs.      Returns \c true if the message was sent, or false if the message could     not be sent. */
end_comment
begin_function
DECL|function|callWithCallback
name|bool
name|QDBusConnection
operator|::
name|callWithCallback
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|returnMethod
parameter_list|,
specifier|const
name|char
modifier|*
name|errorMethod
parameter_list|,
name|int
name|timeout
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
condition|)
block|{
name|QDBusError
name|err
init|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|Disconnected
argument_list|,
name|QDBusUtil
operator|::
name|disconnectedErrorMessage
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|lastError
operator|=
name|err
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|sendWithReplyAsync
argument_list|(
name|message
argument_list|,
name|receiver
argument_list|,
name|returnMethod
argument_list|,
name|errorMethod
argument_list|,
name|timeout
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \deprecated     Sends the \a message over this connection and returns immediately.     When the reply is received, the method \a returnMethod is called in     the \a receiver object.      This function is suitable for method calls only. It is guaranteed     that the slot will be called exactly once with the reply, as long     as the parameter types match and no error occurs.      This function is dangerous because it cannot report errors, including     the expiration of the timeout.      Returns \c true if the message was sent, or false if the message could     not be sent. */
end_comment
begin_function
DECL|function|callWithCallback
name|bool
name|QDBusConnection
operator|::
name|callWithCallback
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|returnMethod
parameter_list|,
name|int
name|timeout
parameter_list|)
specifier|const
block|{
return|return
name|callWithCallback
argument_list|(
name|message
argument_list|,
name|receiver
argument_list|,
name|returnMethod
argument_list|,
literal|0
argument_list|,
name|timeout
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sends the \a message over this connection and blocks, waiting for     a reply, for at most \a timeout milliseconds. This function is     suitable for method calls only. It returns the reply message as     its return value, which will be either of type     QDBusMessage::ReplyMessage or QDBusMessage::ErrorMessage.      If no reply is received within \a timeout milliseconds, an automatic     error will be delivered indicating the expiration of the call.     The default \a timeout is -1, which will be replaced with an     implementation-defined value that is suitable for inter-process     communications (generally, 25 seconds).      See the QDBusInterface::call() function for a more friendly way     of placing calls.      \warning If \a mode is QDBus::BlockWithGui, this function will              reenter the Qt event loop in order to wait for the              reply. During the wait, it may deliver signals and other              method calls to your application. Therefore, it must be              prepared to handle a reentrancy whenever a call is              placed with call(). */
end_comment
begin_function
DECL|function|call
name|QDBusMessage
name|QDBusConnection
operator|::
name|call
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|,
name|QDBus
operator|::
name|CallMode
name|mode
parameter_list|,
name|int
name|timeout
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
condition|)
block|{
name|QDBusError
name|err
init|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|Disconnected
argument_list|,
name|QDBusUtil
operator|::
name|disconnectedErrorMessage
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|lastError
operator|=
name|err
expr_stmt|;
return|return
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
name|mode
operator|!=
name|QDBus
operator|::
name|NoBlock
condition|)
return|return
name|d
operator|->
name|sendWithReply
argument_list|(
name|message
argument_list|,
name|mode
argument_list|,
name|timeout
argument_list|)
return|;
name|d
operator|->
name|send
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|QDBusMessage
name|retval
decl_stmt|;
name|retval
operator|<<
name|QVariant
argument_list|()
expr_stmt|;
comment|// add one argument (to avoid .at(0) problems)
return|return
name|retval
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     Sends the \a message over this connection and returns     immediately. This function is suitable for method calls only. It     returns an object of type QDBusPendingCall which can be used to     track the status of the reply.      If no reply is received within \a timeout milliseconds, an automatic     error will be delivered indicating the expiration of the call. The     default \a timeout is -1, which will be replaced with an     implementation-defined value that is suitable for inter-process     communications (generally, 25 seconds). This timeout is also the     upper limit for waiting in QDBusPendingCall::waitForFinished().      See the QDBusInterface::asyncCall() function for a more friendly way     of placing calls. */
end_comment
begin_function
DECL|function|asyncCall
name|QDBusPendingCall
name|QDBusConnection
operator|::
name|asyncCall
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|,
name|int
name|timeout
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
condition|)
block|{
return|return
name|QDBusPendingCall
argument_list|(
literal|0
argument_list|)
return|;
comment|// null pointer -> disconnected
block|}
name|QDBusPendingCallPrivate
modifier|*
name|priv
init|=
name|d
operator|->
name|sendWithReplyAsync
argument_list|(
name|message
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
return|return
name|QDBusPendingCall
argument_list|(
name|priv
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Connects the signal specified by the \a service, \a path, \a interface and \a name parameters to     the slot \a slot in object \a receiver. The arguments \a service and \a path can be empty,     denoting a connection to any signal of the (\a interface, \a name) pair, from any remote     application.      Returns \c true if the connection was successful.      \warning The signal will only be delivered to the slot if the parameters match. This verification              can be done only when the signal is received, not at connection time. */
end_comment
begin_function
DECL|function|connect
name|bool
name|QDBusConnection
operator|::
name|connect
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
return|return
name|connect
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|QStringList
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Connects the signal to the slot \a slot in object \a     receiver. Unlike the previous connect() overload, this function     allows one to specify the parameter signature to be connected     using the \a signature variable. The function will then verify     that this signature can be delivered to the slot specified by \a     slot and return false otherwise.      Returns \c true if the connection was successful.      \note This function verifies that the signal signature matches the           slot's parameters, but it does not verify that the actual           signal exists with the given signature in the remote           service. */
end_comment
begin_function
DECL|function|connect
name|bool
name|QDBusConnection
operator|::
name|connect
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
return|return
name|connect
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|QStringList
argument_list|()
argument_list|,
name|signature
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.6      Connects the signal to the slot \a slot in object \a     receiver. Unlike the previous connect() overload, this function     allows one to specify the parameter signature to be connected     using the \a signature variable. The function will then verify     that this signature can be delivered to the slot specified by \a     slot and return false otherwise.      The \a argumentMatch parameter lists the string parameters to be matched,     in sequential order. Note that, to match an empty string, you need to     pass a QString that is empty but not null (i.e., QString("")). A null     QString skips matching at that position.      Returns \c true if the connection was successful.      \note This function verifies that the signal signature matches the           slot's parameters, but it does not verify that the actual           signal exists with the given signature in the remote           service. */
end_comment
begin_function
DECL|function|connect
name|bool
name|QDBusConnection
operator|::
name|connect
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|argumentMatch
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
if|if
condition|(
operator|!
name|receiver
operator|||
operator|!
name|slot
operator|||
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|interface
operator|.
name|isEmpty
argument_list|()
operator|&&
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|QDBusUtil
operator|::
name|isValidInterfaceName
argument_list|(
name|interface
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QDBusConnection::connect: interface name '%s' is not valid"
argument_list|,
name|interface
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|service
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|QDBusUtil
operator|::
name|isValidBusName
argument_list|(
name|service
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QDBusConnection::connect: service name '%s' is not valid"
argument_list|,
name|service
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|QDBusUtil
operator|::
name|isValidObjectPath
argument_list|(
name|path
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QDBusConnection::connect: object path '%s' is not valid"
argument_list|,
name|path
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|connectSignal
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|argumentMatch
argument_list|,
name|signature
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Disconnects the signal specified by the \a service, \a path, \a interface     and \a name parameters from the slot \a slot in object \a receiver. The     arguments must be the same as passed to the connect() function.      Returns \c true if the disconnection was successful. */
end_comment
begin_function
DECL|function|disconnect
name|bool
name|QDBusConnection
operator|::
name|disconnect
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
return|return
name|disconnect
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|QStringList
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Disconnects the signal specified by the \a service, \a path, \a     interface, \a name, and \a signature parameters from the slot \a slot in     object \a receiver. The arguments must be the same as passed to the     connect() function.      Returns \c true if the disconnection was successful. */
end_comment
begin_function
DECL|function|disconnect
name|bool
name|QDBusConnection
operator|::
name|disconnect
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
return|return
name|disconnect
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|QStringList
argument_list|()
argument_list|,
name|signature
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.6      Disconnects the signal specified by the \a service, \a path, \a     interface, \a name, \a argumentMatch, and \a signature parameters from     the slot \a slot in object \a receiver. The arguments must be the same as     passed to the connect() function.      Returns \c true if the disconnection was successful. */
end_comment
begin_function
DECL|function|disconnect
name|bool
name|QDBusConnection
operator|::
name|disconnect
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|argumentMatch
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
if|if
condition|(
operator|!
name|receiver
operator|||
operator|!
name|slot
operator|||
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|QDBusUtil
operator|::
name|isValidInterfaceName
argument_list|(
name|interface
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|interface
operator|.
name|isEmpty
argument_list|()
operator|&&
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|disconnectSignal
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|argumentMatch
argument_list|,
name|signature
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Registers the object \a object at path \a path and returns \c true if     the registration was successful. The \a options parameter     specifies how much of the object \a object will be exposed through     D-Bus.      This function does not replace existing objects: if there is already an object registered at     path \a path, this function will return false. Use unregisterObject() to unregister it first.      You cannot register an object as a child object of an object that     was registered with QDBusConnection::ExportChildObjects. */
end_comment
begin_function
DECL|function|registerObject
name|bool
name|QDBusConnection
operator|::
name|registerObject
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|,
name|RegisterOptions
name|options
parameter_list|)
block|{
return|return
name|registerObject
argument_list|(
name|path
argument_list|,
name|QString
argument_list|()
argument_list|,
name|object
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 5.5      Registers the object \a object at path \a path with interface name \a interface     and returns \c true if the registration was successful. The \a options parameter     specifies how much of the object \a object will be exposed through     D-Bus.      This function does not replace existing objects: if there is already an object registered at     path \a path, this function will return false. Use unregisterObject() to unregister it first.      You cannot register an object as a child object of an object that     was registered with QDBusConnection::ExportChildObjects. */
end_comment
begin_function
DECL|function|registerObject
name|bool
name|QDBusConnection
operator|::
name|registerObject
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|,
name|RegisterOptions
name|options
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
name|QDBusUtil
operator|::
name|isValidObjectPath
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"QDBusConnection::registerObject"
argument_list|,
literal|"Invalid object path given"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
operator|||
operator|!
name|object
operator|||
operator|!
name|options
operator|||
operator|!
name|QDBusUtil
operator|::
name|isValidObjectPath
argument_list|(
name|path
argument_list|)
condition|)
return|return
literal|false
return|;
name|QStringList
name|pathComponents
init|=
name|path
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pathComponents
operator|.
name|last
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|pathComponents
operator|.
name|removeLast
argument_list|()
expr_stmt|;
name|QDBusWriteLocker
name|locker
argument_list|(
name|RegisterObjectAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
comment|// lower-bound search for where this object should enter in the tree
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|node
init|=
operator|&
name|d
operator|->
name|rootNode
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|pathComponents
operator|.
name|count
argument_list|()
operator|==
name|i
condition|)
block|{
comment|// this node exists
comment|// consider it free if there's no object here and the user is not trying to
comment|// replace the object sub-tree
if|if
condition|(
name|node
operator|->
name|obj
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|options
operator|&
name|QDBusConnectionPrivate
operator|::
name|VirtualObject
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|SubPath
operator|&&
operator|!
name|node
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|ExportChildObjects
operator|&&
operator|!
name|node
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
return|return
literal|false
return|;
block|}
comment|// we can add the object here
name|node
operator|->
name|obj
operator|=
name|object
expr_stmt|;
name|node
operator|->
name|flags
operator|=
name|options
expr_stmt|;
name|node
operator|->
name|interfaceName
operator|=
name|interface
expr_stmt|;
name|d
operator|->
name|registerObject
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|//qDebug("REGISTERED FOR %s", path.toLocal8Bit().constData());
return|return
literal|true
return|;
block|}
comment|// if a virtual object occupies this path, return false
if|if
condition|(
name|node
operator|->
name|obj
operator|&&
operator|(
name|node
operator|->
name|flags
operator|&
name|QDBusConnectionPrivate
operator|::
name|VirtualObject
operator|)
operator|&&
operator|(
name|node
operator|->
name|flags
operator|&
name|QDBusConnection
operator|::
name|SubPath
operator|)
condition|)
block|{
comment|//qDebug("Cannot register object at %s because QDBusVirtualObject handles all sub-paths.",
comment|//       qPrintable(path));
return|return
literal|false
return|;
block|}
comment|// find the position where we'd insert the node
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|it
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|node
operator|->
name|children
operator|.
name|begin
argument_list|()
argument_list|,
name|node
operator|->
name|children
operator|.
name|end
argument_list|()
argument_list|,
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|node
operator|->
name|children
operator|.
name|end
argument_list|()
operator|&&
name|it
operator|->
name|name
operator|==
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|// match: this node exists
name|node
operator|=
name|it
expr_stmt|;
comment|// are we allowed to go deeper?
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|ExportChildObjects
condition|)
block|{
comment|// we're not
comment|//qDebug("Cannot register object at %s because %s exports its own child objects",
comment|//       qPrintable(path), qPrintable(pathComponents.at(i)));
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
comment|// add entry
name|node
operator|=
name|node
operator|->
name|children
operator|.
name|insert
argument_list|(
name|it
argument_list|,
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// iterate
operator|++
name|i
expr_stmt|;
block|}
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QDBusConnection::registerObject"
argument_list|,
literal|"The impossible happened"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 4.8     Registers a QDBusTreeNode for a path. It can handle a path including all child paths, thus     handling multiple DBus nodes.      To unregister a QDBusTreeNode use the unregisterObject() function with its path. */
end_comment
begin_function
DECL|function|registerVirtualObject
name|bool
name|QDBusConnection
operator|::
name|registerVirtualObject
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|QDBusVirtualObject
modifier|*
name|treeNode
parameter_list|,
name|VirtualObjectRegisterOption
name|options
parameter_list|)
block|{
name|int
name|opts
init|=
name|options
operator||
name|QDBusConnectionPrivate
operator|::
name|VirtualObject
decl_stmt|;
return|return
name|registerObject
argument_list|(
name|path
argument_list|,
operator|(
name|QObject
operator|*
operator|)
name|treeNode
argument_list|,
operator|(
name|RegisterOptions
operator|)
name|opts
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Unregisters an object that was registered with the registerObject() at the object path given by     \a path and, if \a mode is QDBusConnection::UnregisterTree, all of its sub-objects too.      Note that you cannot unregister objects that were not registered with registerObject(). */
end_comment
begin_function
DECL|function|unregisterObject
name|void
name|QDBusConnection
operator|::
name|unregisterObject
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|UnregisterMode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
operator|||
operator|!
name|QDBusUtil
operator|::
name|isValidObjectPath
argument_list|(
name|path
argument_list|)
condition|)
return|return;
name|QDBusWriteLocker
name|locker
argument_list|(
name|UnregisterObjectAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|d
operator|->
name|unregisterObject
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Return the object that was registered with the registerObject() at the object path given by     \a path. */
end_comment
begin_function
DECL|function|objectRegisteredAt
name|QObject
modifier|*
name|QDBusConnection
operator|::
name|objectRegisteredAt
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
specifier|const
block|{
name|Q_ASSERT_X
argument_list|(
name|QDBusUtil
operator|::
name|isValidObjectPath
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"QDBusConnection::registeredObject"
argument_list|,
literal|"Invalid object path given"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
operator|||
operator|!
name|QDBusUtil
operator|::
name|isValidObjectPath
argument_list|(
name|path
argument_list|)
condition|)
return|return
literal|0
return|;
name|QStringList
name|pathComponents
init|=
name|path
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pathComponents
operator|.
name|last
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|pathComponents
operator|.
name|removeLast
argument_list|()
expr_stmt|;
comment|// lower-bound search for where this object should enter in the tree
name|QDBusReadLocker
name|lock
argument_list|(
name|ObjectRegisteredAtAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
specifier|const
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|*
name|node
init|=
operator|&
name|d
operator|->
name|rootNode
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|pathComponents
operator|.
name|count
argument_list|()
operator|==
name|i
condition|)
return|return
name|node
operator|->
name|obj
return|;
if|if
condition|(
operator|(
name|node
operator|->
name|flags
operator|&
name|QDBusConnectionPrivate
operator|::
name|VirtualObject
operator|)
operator|&&
operator|(
name|node
operator|->
name|flags
operator|&
name|QDBusConnection
operator|::
name|SubPath
operator|)
condition|)
return|return
name|node
operator|->
name|obj
return|;
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|ConstIterator
name|it
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|node
operator|->
name|children
operator|.
name|constBegin
argument_list|()
argument_list|,
name|node
operator|->
name|children
operator|.
name|constEnd
argument_list|()
argument_list|,
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|node
operator|->
name|children
operator|.
name|constEnd
argument_list|()
operator|||
name|it
operator|->
name|name
operator|!=
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
break|break;
comment|// node not found
name|node
operator|=
name|it
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDBusConnectionInterface object that represents the     D-Bus server interface on this connection. */
end_comment
begin_function
DECL|function|interface
name|QDBusConnectionInterface
modifier|*
name|QDBusConnection
operator|::
name|interface
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|mode
operator|!=
name|QDBusConnectionPrivate
operator|::
name|ClientMode
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|busService
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 4.8      Returns the internal, implementation-defined pointer for this     connection. Currently, this returns a DBusConnection* pointer,     without changing the reference count. It is the responsibility of     the caller to call dbus_connection_ref if it wants to store the     pointer. */
end_comment
begin_function
DECL|function|internalPointer
name|void
modifier|*
name|QDBusConnection
operator|::
name|internalPointer
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|connection
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this QDBusConnection object is connected. */
end_comment
begin_function
DECL|function|isConnected
name|bool
name|QDBusConnection
operator|::
name|isConnected
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|&&
name|d
operator|->
name|connection
operator|&&
name|q_dbus_connection_get_is_connected
argument_list|(
name|d
operator|->
name|connection
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the last error that happened in this connection.      This function is provided for low-level code. If you're using     QDBusInterface::call(), error codes are reported by its return     value.      \sa QDBusInterface, QDBusMessage */
end_comment
begin_function
DECL|function|lastError
name|QDBusError
name|QDBusConnection
operator|::
name|lastError
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|lastError
else|:
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|Disconnected
argument_list|,
name|QDBusUtil
operator|::
name|disconnectedErrorMessage
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the unique connection name for this connection, if this QDBusConnection object is     connected, or an empty QString otherwise.      A Unique Connection Name is a string in the form ":x.xxx" (where x     are decimal digits) that is assigned by the D-Bus server daemon     upon connection. It uniquely identifies this client in the bus.      This function returns an empty QString for peer-to-peer connections. */
end_comment
begin_function
DECL|function|baseService
name|QString
name|QDBusConnection
operator|::
name|baseService
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|baseService
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the connection name for this connection, as given as the     name parameter to connectToBus().      The connection name can be used to uniquely identify actual     underlying connections to buses.  Copies made from a single     connection will always implicitly share the underlying connection,     and hence will have the same connection name.      Inversely, two connections having different connection names will     always either be connected to different buses, or have a different     unique name (as returned by baseService()) on that bus.      \sa connectToBus(), disconnectFromBus() */
end_comment
begin_function
DECL|function|name
name|QString
name|QDBusConnection
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|name
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns the capabilities of this connection as negotiated with the bus     server or peer. If this QDBusConnection is not connected, this function     returns no capabilities. */
end_comment
begin_function
DECL|function|connectionCapabilities
name|QDBusConnection
operator|::
name|ConnectionCapabilities
name|QDBusConnection
operator|::
name|connectionCapabilities
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|capabilities
else|:
name|ConnectionCapabilities
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Attempts to register the \a serviceName on the D-Bus server and     returns \c true if the registration succeeded. The registration will     fail if the name is already registered by another application.      \sa unregisterService(), QDBusConnectionInterface::registerService() */
end_comment
begin_function
DECL|function|registerService
name|bool
name|QDBusConnection
operator|::
name|registerService
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
if|if
condition|(
name|interface
argument_list|()
operator|&&
name|interface
argument_list|()
operator|->
name|registerService
argument_list|(
name|serviceName
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|registerService
argument_list|(
name|serviceName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Unregisters the service \a serviceName that was previously     registered with registerService() and returns \c true if it     succeeded.      \sa registerService(), QDBusConnectionInterface::unregisterService() */
end_comment
begin_function
DECL|function|unregisterService
name|bool
name|QDBusConnection
operator|::
name|unregisterService
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
if|if
condition|(
name|interface
argument_list|()
operator|->
name|unregisterService
argument_list|(
name|serviceName
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|unregisterService
argument_list|(
name|serviceName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDBusConnection QDBusConnection::sessionBus()      Returns a QDBusConnection object opened with the session bus. The object     reference returned by this function is valid until the application terminates,     at which point the connection will be closed and the object deleted. */
end_comment
begin_function
DECL|function|sessionBus
name|QDBusConnection
name|QDBusConnection
operator|::
name|sessionBus
parameter_list|()
block|{
return|return
name|QDBusConnection
argument_list|(
name|_q_manager
argument_list|()
operator|->
name|busConnection
argument_list|(
name|SessionBus
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDBusConnection QDBusConnection::systemBus()      Returns a QDBusConnection object opened with the system bus. The object reference returned     by this function is valid until the QCoreApplication's destructor is run, when the     connection will be closed and the object, deleted. */
end_comment
begin_function
DECL|function|systemBus
name|QDBusConnection
name|QDBusConnection
operator|::
name|systemBus
parameter_list|()
block|{
return|return
name|QDBusConnection
argument_list|(
name|_q_manager
argument_list|()
operator|->
name|busConnection
argument_list|(
name|SystemBus
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|5
argument_list|)
end_if
begin_comment
comment|/*!   \deprecated    Always returns a disconnected, invalid QDBusConnection object. For the old   functionality of determining the sender connection, please use QDBusContext.    \sa QDBusContext */
end_comment
begin_function
DECL|function|sender
name|QDBusConnection
name|QDBusConnection
operator|::
name|sender
parameter_list|()
block|{
return|return
name|QDBusConnection
argument_list|(
name|QString
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|createBusService
name|void
name|QDBusConnectionPrivate
operator|::
name|createBusService
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|mode
operator|==
name|ClientMode
argument_list|)
expr_stmt|;
name|QDBusConnection
name|connection
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|busService
operator|=
operator|new
name|QDBusConnectionInterface
argument_list|(
name|connection
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
comment|// busService has increased the refcounting to us
comment|// avoid cyclic refcounting
name|QObject
operator|::
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|callWithCallbackFailed
argument_list|(
name|QDBusError
argument_list|,
name|QDBusMessage
argument_list|)
argument_list|)
argument_list|,
name|busService
argument_list|,
name|SIGNAL
argument_list|(
name|callWithCallbackFailed
argument_list|(
name|QDBusError
argument_list|,
name|QDBusMessage
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     Returns the local machine ID as known to the D-Bus system. Each     node or host that runs D-Bus has a unique identifier that can be     used to distinguish it from other hosts if they are sharing     resources like the filesystem.      Note that the local machine ID is not guaranteed to be persistent     across boots of the system, so this identifier should not be     stored in persistent storage (like the filesystem). It is     guaranteed to remain constant only during the lifetime of this     boot session. */
end_comment
begin_function
DECL|function|localMachineId
name|QByteArray
name|QDBusConnection
operator|::
name|localMachineId
parameter_list|()
block|{
name|char
modifier|*
name|dbus_machine_id
init|=
name|q_dbus_get_local_machine_id
argument_list|()
decl_stmt|;
name|QByteArray
name|result
init|=
name|dbus_machine_id
decl_stmt|;
name|q_dbus_free
argument_list|(
name|dbus_machine_id
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \namespace QDBus     \inmodule QtDBus      \brief The QDBus namespace contains miscellaneous identifiers used     throughout the Qt D-Bus module. */
end_comment
begin_comment
comment|/*!     \enum QDBus::CallMode      This enum describes the various ways of placing a function call. The valid modes are:      \value NoBlock              Place the call but don't wait for the reply (the reply's contents                                 will be discarded).     \value Block                Don't use an event loop to wait for a reply, but instead block on                                 network operations while waiting. This means the                                 user-interface may not be updated until the function returns.     \value BlockWithGui         Use the Qt event loop to wait for a reply. This means that the                                 user-interface will stay responsive (processing input events),                                 but it also means other events may happen, like signal delivery                                 and other D-Bus method calls.     \value AutoDetect           Automatically detect if the called function has a reply.      When using BlockWithGui, applications must be prepared for reentrancy in any function. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"qdbusconnection.moc"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DBUS
end_comment
end_unit
