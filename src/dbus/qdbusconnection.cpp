begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtDBus module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdbusconnection.h"
end_include
begin_include
include|#
directive|include
file|"qdbusconnection_p.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|"qdbusconnectioninterface.h"
end_include
begin_include
include|#
directive|include
file|"qdbuserror.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmessage.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmessage_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusinterface_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusutil_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusconnectionmanager_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusthreaddebug_p.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DBUS
end_ifndef
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|Q_GLOBAL_STATIC
argument_list|(
name|QDBusConnectionManager
argument_list|,
name|_q_manager
argument_list|)
DECL|function|sender
name|QDBusConnectionPrivate
modifier|*
name|QDBusConnectionManager
operator|::
name|sender
argument_list|()
decl|const
argument_list|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|senderMutex
argument_list|)
argument_list|;     return
name|connection
argument_list|(
name|senderName
argument_list|)
argument_list|; }
DECL|function|setSender
name|void
name|QDBusConnectionManager
operator|::
name|setSender
argument_list|(
specifier|const
name|QDBusConnectionPrivate
operator|*
name|s
argument_list|)
argument_list|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|senderMutex
argument_list|)
argument_list|;
name|senderName
operator|=
operator|(
name|s
condition|?
name|s
operator|->
name|name
else|:
name|QString
argument_list|()
operator|)
argument_list|; }
DECL|function|connection
name|QDBusConnectionPrivate
modifier|*
name|QDBusConnectionManager
operator|::
name|connection
argument_list|(
specifier|const
name|QString
operator|&
name|name
argument_list|)
decl|const
argument_list|{     return
name|connectionHash
operator|.
name|value
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|; }
DECL|function|removeConnection
name|void
name|QDBusConnectionManager
operator|::
name|removeConnection
argument_list|(
specifier|const
name|QString
operator|&
name|name
argument_list|)
argument_list|{
name|QDBusConnectionPrivate
operator|*
name|d
operator|=
literal|0
argument_list|;
name|d
operator|=
name|connectionHash
operator|.
name|take
argument_list|(
name|name
argument_list|)
argument_list|;     if
operator|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
operator|)
name|d
operator|->
name|deleteYourself
argument_list|()
argument_list|;
comment|// Static objects may be keeping the connection open.
comment|// However, it is harmless to have outstanding references to a connection that is
comment|// closing as long as those references will be soon dropped without being used.
comment|// ### Output a warning if connections are being used after they have been removed.
argument_list|}
DECL|function|~QDBusConnectionManager
name|QDBusConnectionManager
operator|::
name|~
name|QDBusConnectionManager
argument_list|()
argument_list|{     for
operator|(
name|QHash
argument_list|<
name|QString
argument_list|,
name|QDBusConnectionPrivate
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
operator|=
name|connectionHash
operator|.
name|constBegin
argument_list|()
expr|;
name|it
operator|!=
name|connectionHash
operator|.
name|constEnd
argument_list|()
expr|;
operator|++
name|it
operator|)
block|{
name|QDBusConnectionPrivate
operator|*
name|d
operator|=
name|it
operator|.
name|value
argument_list|()
block|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|d
operator|->
name|deleteYourself
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|closeConnection
argument_list|()
expr_stmt|;
block|}
name|connectionHash
operator|.
name|clear
argument_list|()
argument_list|; }
DECL|function|instance
name|QDBusConnectionManager
modifier|*
name|QDBusConnectionManager
operator|::
name|instance
argument_list|()
argument_list|{     return
name|_q_manager
argument_list|()
argument_list|; }
name|Q_DBUS_EXPORT
name|void
name|qDBusBindToApplication
argument_list|()
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qDBusBindToApplication
name|void
name|qDBusBindToApplication
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|setConnection
name|void
name|QDBusConnectionManager
operator|::
name|setConnection
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|QDBusConnectionPrivate
modifier|*
name|c
parameter_list|)
block|{
name|connectionHash
index|[
name|name
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QDBusConnection     \inmodule QtDBus     \since 4.2      \brief The QDBusConnection class represents a connection to the D-Bus bus daemon.      This class is the initial point in a D-Bus session. Using it, you     can get access to remote objects, interfaces; connect remote     signals to your object's slots; register objects, etc.      D-Bus connections are created using the connectToBus() function,     which opens a connection to the server daemon and does the initial     handshaking, associating that connection with a name. Further     attempts to connect using the same name will return the same     connection.      The connection is then torn down using the disconnectFromBus()     function.      Once disconnected, calling connectToBus() will not reestablish a     connection, you must create a new QDBusConnection instance.      As a convenience for the two most common connection types, the     sessionBus() and systemBus() functions return open connections to     the session server daemon and the system server daemon,     respectively. Those connections are opened when first used and are     closed when the QCoreApplication destructor is run.      D-Bus also supports peer-to-peer connections, without the need for     a bus server daemon. Using this facility, two applications can     talk to each other and exchange messages. This can be achieved by     passing an address to connectToBus() function, which was opened by     another D-Bus application using QDBusServer. */
end_comment
begin_comment
comment|/*!     \enum QDBusConnection::BusType     Specifies the type of the bus connection. The valid bus types are:      \value SessionBus           the session bus, associated with the running desktop session     \value SystemBus            the system bus, used to communicate with system-wide processes     \value ActivationBus        the activation bus, the "alias" for the bus that started the                                 service      On the Session Bus, one can find other applications by the same user that are sharing the same     desktop session (hence the name). On the System Bus, however, processes shared for the whole     system are usually found. */
end_comment
begin_comment
comment|/*!     \enum QDBusConnection::RegisterOption     Specifies the options for registering objects with the connection. The possible values are:      \value ExportAdaptors                       export the contents of adaptors found in this object      \value ExportScriptableSlots                export this object's scriptable slots     \value ExportScriptableSignals              export this object's scriptable signals     \value ExportScriptableProperties           export this object's scriptable properties     \value ExportScriptableInvokables           export this object's scriptable invokables     \value ExportScriptableContents             shorthand form for ExportScriptableSlots |                                                 ExportScriptableSignals |                                                 ExportScriptableProperties      \value ExportNonScriptableSlots             export this object's non-scriptable slots     \value ExportNonScriptableSignals           export this object's non-scriptable signals     \value ExportNonScriptableProperties        export this object's non-scriptable properties     \value ExportNonScriptableInvokables        export this object's non-scriptable invokables     \value ExportNonScriptableContents          shorthand form for ExportNonScriptableSlots |                                                 ExportNonScriptableSignals |                                                 ExportNonScriptableProperties      \value ExportAllSlots                       export all of this object's slots     \value ExportAllSignals                     export all of this object's signals     \value ExportAllProperties                  export all of this object's properties     \value ExportAllInvokables                  export all of this object's invokables     \value ExportAllContents                    export all of this object's contents     \value ExportChildObjects                   export this object's child objects      \sa registerObject(), QDBusAbstractAdaptor, {usingadaptors.html}{Using adaptors} */
end_comment
begin_comment
comment|/*!     \internal     \since 4.8     \enum QDBusConnection::VirtualObjectRegisterOption     Specifies the options for registering virtual objects with the connection. The possible values are:      \value SingleNode                           register a virtual object to handle one path only     \value SubPath                              register a virtual object so that it handles all sub paths      \sa registerVirtualObject(), QDBusVirtualObject */
end_comment
begin_comment
comment|/*!     \enum QDBusConnection::UnregisterMode     The mode for unregistering an object path:      \value UnregisterNode       unregister this node only: do not unregister child objects     \value UnregisterTree       unregister this node and all its sub-tree      Note, however, if this object was registered with the ExportChildObjects option, UnregisterNode     will unregister the child objects too. */
end_comment
begin_comment
comment|/*!     \since 4.8     \enum QDBusConnection::ConnectionCapability      This enum describes the available capabilities for a D-Bus connection.      \value UnixFileDescriptorPassing        enables passing of Unix file descriptors to other processes                                             (see QDBusUnixFileDescriptor)      \sa connectionCapabilities() */
end_comment
begin_comment
comment|/*!     Creates a QDBusConnection object attached to the connection with name \a name.      This does not open the connection. You have to call connectToBus() to open it. */
end_comment
begin_constructor
DECL|function|QDBusConnection
name|QDBusConnection
operator|::
name|QDBusConnection
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|_q_manager
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|d
operator|=
name|_q_manager
argument_list|()
operator|->
name|connection
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Creates a copy of the \a other connection. */
end_comment
begin_constructor
DECL|function|QDBusConnection
name|QDBusConnection
operator|::
name|QDBusConnection
parameter_list|(
specifier|const
name|QDBusConnection
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!   \internal    Creates a connection object with the given \a dd as private object. */
end_comment
begin_constructor
DECL|function|QDBusConnection
name|QDBusConnection
operator|::
name|QDBusConnection
parameter_list|(
name|QDBusConnectionPrivate
modifier|*
name|dd
parameter_list|)
block|{
name|d
operator|=
name|dd
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Disposes of this object. This does not close the connection: you     have to call disconnectFromBus() to do that. */
end_comment
begin_destructor
DECL|function|~QDBusConnection
name|QDBusConnection
operator|::
name|~
name|QDBusConnection
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|d
operator|->
name|deleteYourself
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Creates a copy of the connection \a other in this object. Note     that the connection this object referenced before the copy, is not     spontaneously disconnected.      \sa disconnectFromBus() */
end_comment
begin_function
DECL|function|operator =
name|QDBusConnection
modifier|&
name|QDBusConnection
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDBusConnection
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|.
name|d
condition|)
name|other
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|d
operator|->
name|deleteYourself
argument_list|()
expr_stmt|;
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Opens a connection of type \a type to one of the known busses and     associate with it the connection name \a name. Returns a     QDBusConnection object associated with that connection. */
end_comment
begin_function
DECL|function|connectToBus
name|QDBusConnection
name|QDBusConnection
operator|::
name|connectToBus
parameter_list|(
name|BusType
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
comment|//    Q_ASSERT_X(QCoreApplication::instance(), "QDBusConnection::addConnection",
comment|//               "Cannot create connection without a Q[Core]Application instance");
if|if
condition|(
operator|!
name|qdbus_loadLibDBus
argument_list|()
condition|)
block|{
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
literal|0
decl_stmt|;
return|return
name|QDBusConnection
argument_list|(
name|d
argument_list|)
return|;
block|}
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|_q_manager
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
name|_q_manager
argument_list|()
operator|->
name|connection
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|||
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QDBusConnection
argument_list|(
name|d
argument_list|)
return|;
name|d
operator|=
operator|new
name|QDBusConnectionPrivate
expr_stmt|;
name|DBusConnection
modifier|*
name|c
init|=
literal|0
decl_stmt|;
name|QDBusErrorInternal
name|error
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SystemBus
case|:
name|c
operator|=
name|q_dbus_bus_get_private
argument_list|(
name|DBUS_BUS_SYSTEM
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|SessionBus
case|:
name|c
operator|=
name|q_dbus_bus_get_private
argument_list|(
name|DBUS_BUS_SESSION
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|ActivationBus
case|:
name|c
operator|=
name|q_dbus_bus_get_private
argument_list|(
name|DBUS_BUS_STARTER
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
name|d
operator|->
name|setConnection
argument_list|(
name|c
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|//setConnection does the error handling for us
name|_q_manager
argument_list|()
operator|->
name|setConnection
argument_list|(
name|name
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|QDBusConnection
name|retval
argument_list|(
name|d
argument_list|)
decl_stmt|;
comment|// create the bus service
comment|// will lock in QDBusConnectionPrivate::connectRelay()
name|d
operator|->
name|setBusService
argument_list|(
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_comment
comment|/*!     Opens a connection to a private bus on address \a address and associate with it the     connection name \a name. Returns a QDBusConnection object associated with that connection. */
end_comment
begin_function
DECL|function|connectToBus
name|QDBusConnection
name|QDBusConnection
operator|::
name|connectToBus
parameter_list|(
specifier|const
name|QString
modifier|&
name|address
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
comment|//    Q_ASSERT_X(QCoreApplication::instance(), "QDBusConnection::addConnection",
comment|//               "Cannot create connection without a Q[Core]Application instance");
if|if
condition|(
operator|!
name|qdbus_loadLibDBus
argument_list|()
condition|)
block|{
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
literal|0
decl_stmt|;
return|return
name|QDBusConnection
argument_list|(
name|d
argument_list|)
return|;
block|}
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|_q_manager
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
name|_q_manager
argument_list|()
operator|->
name|connection
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|||
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QDBusConnection
argument_list|(
name|d
argument_list|)
return|;
name|d
operator|=
operator|new
name|QDBusConnectionPrivate
expr_stmt|;
comment|// setConnection does the error handling for us
name|QDBusErrorInternal
name|error
decl_stmt|;
name|DBusConnection
modifier|*
name|c
init|=
name|q_dbus_connection_open_private
argument_list|(
name|address
operator|.
name|toUtf8
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
operator|!
name|q_dbus_bus_register
argument_list|(
name|c
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|q_dbus_connection_unref
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|d
operator|->
name|setConnection
argument_list|(
name|c
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|_q_manager
argument_list|()
operator|->
name|setConnection
argument_list|(
name|name
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|QDBusConnection
name|retval
argument_list|(
name|d
argument_list|)
decl_stmt|;
comment|// create the bus service
comment|// will lock in QDBusConnectionPrivate::connectRelay()
name|d
operator|->
name|setBusService
argument_list|(
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Opens a peer-to-peer connection on address \a address and associate with it the     connection name \a name. Returns a QDBusConnection object associated with that connection. */
end_comment
begin_function
DECL|function|connectToPeer
name|QDBusConnection
name|QDBusConnection
operator|::
name|connectToPeer
parameter_list|(
specifier|const
name|QString
modifier|&
name|address
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
comment|//    Q_ASSERT_X(QCoreApplication::instance(), "QDBusConnection::addConnection",
comment|//               "Cannot create connection without a Q[Core]Application instance");
if|if
condition|(
operator|!
name|qdbus_loadLibDBus
argument_list|()
condition|)
block|{
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
literal|0
decl_stmt|;
return|return
name|QDBusConnection
argument_list|(
name|d
argument_list|)
return|;
block|}
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|_q_manager
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
name|_q_manager
argument_list|()
operator|->
name|connection
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|||
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QDBusConnection
argument_list|(
name|d
argument_list|)
return|;
name|d
operator|=
operator|new
name|QDBusConnectionPrivate
expr_stmt|;
comment|// setPeer does the error handling for us
name|QDBusErrorInternal
name|error
decl_stmt|;
name|DBusConnection
modifier|*
name|c
init|=
name|q_dbus_connection_open_private
argument_list|(
name|address
operator|.
name|toUtf8
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|error
argument_list|)
decl_stmt|;
name|d
operator|->
name|setPeer
argument_list|(
name|c
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|_q_manager
argument_list|()
operator|->
name|setConnection
argument_list|(
name|name
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|QDBusConnection
name|retval
argument_list|(
name|d
argument_list|)
decl_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_comment
comment|/*!     Closes the bus connection of name \a name.      Note that if there are still QDBusConnection objects associated     with the same connection, the connection will not be closed until     all references are dropped. However, no further references can be     created using the QDBusConnection constructor. */
end_comment
begin_function
DECL|function|disconnectFromBus
name|void
name|QDBusConnection
operator|::
name|disconnectFromBus
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|_q_manager
argument_list|()
condition|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|_q_manager
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
name|_q_manager
argument_list|()
operator|->
name|connection
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|mode
operator|!=
name|QDBusConnectionPrivate
operator|::
name|ClientMode
condition|)
return|return;
name|_q_manager
argument_list|()
operator|->
name|removeConnection
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Closes the peer connection of name \a name.      Note that if there are still QDBusConnection objects associated     with the same connection, the connection will not be closed until     all references are dropped. However, no further references can be     created using the QDBusConnection constructor. */
end_comment
begin_function
DECL|function|disconnectFromPeer
name|void
name|QDBusConnection
operator|::
name|disconnectFromPeer
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|_q_manager
argument_list|()
condition|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|_q_manager
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
modifier|*
name|d
init|=
name|_q_manager
argument_list|()
operator|->
name|connection
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|mode
operator|!=
name|QDBusConnectionPrivate
operator|::
name|PeerMode
condition|)
return|return;
name|_q_manager
argument_list|()
operator|->
name|removeConnection
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Sends the \a message over this connection, without waiting for a     reply. This is suitable for errors, signals, and return values as     well as calls whose return values are not necessary.      Returns true if the message was queued successfully, false otherwise. */
end_comment
begin_function
DECL|function|send
name|bool
name|QDBusConnection
operator|::
name|send
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
condition|)
block|{
name|QDBusError
name|err
init|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|Disconnected
argument_list|,
name|QLatin1String
argument_list|(
literal|"Not connected to D-BUS server"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|lastError
operator|=
name|err
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|send
argument_list|(
name|message
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Sends the \a message over this connection and returns immediately.     When the reply is received, the method \a returnMethod is called in     the \a receiver object. If an error occurs, the method \a errorMethod     will be called instead.      If no reply is received within \a timeout milliseconds, an automatic     error will be delivered indicating the expiration of the call.     The default \a timeout is -1, which will be replaced with an     implementation-defined value that is suitable for inter-process     communications (generally, 25 seconds).      This function is suitable for method calls only. It is guaranteed     that the slot will be called exactly once with the reply, as long     as the parameter types match and no error occurs.      Returns true if the message was sent, or false if the message could     not be sent. */
end_comment
begin_function
DECL|function|callWithCallback
name|bool
name|QDBusConnection
operator|::
name|callWithCallback
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|returnMethod
parameter_list|,
specifier|const
name|char
modifier|*
name|errorMethod
parameter_list|,
name|int
name|timeout
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
condition|)
block|{
name|QDBusError
name|err
init|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|Disconnected
argument_list|,
name|QLatin1String
argument_list|(
literal|"Not connected to D-BUS server"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|lastError
operator|=
name|err
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|sendWithReplyAsync
argument_list|(
name|message
argument_list|,
name|receiver
argument_list|,
name|returnMethod
argument_list|,
name|errorMethod
argument_list|,
name|timeout
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \deprecated     Sends the \a message over this connection and returns immediately.     When the reply is received, the method \a returnMethod is called in     the \a receiver object.      This function is suitable for method calls only. It is guaranteed     that the slot will be called exactly once with the reply, as long     as the parameter types match and no error occurs.      This function is dangerous because it cannot report errors, including     the expiration of the timeout.      Returns true if the message was sent, or false if the message could     not be sent. */
end_comment
begin_function
DECL|function|callWithCallback
name|bool
name|QDBusConnection
operator|::
name|callWithCallback
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|returnMethod
parameter_list|,
name|int
name|timeout
parameter_list|)
specifier|const
block|{
return|return
name|callWithCallback
argument_list|(
name|message
argument_list|,
name|receiver
argument_list|,
name|returnMethod
argument_list|,
literal|0
argument_list|,
name|timeout
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sends the \a message over this connection and blocks, waiting for     a reply, for at most \a timeout milliseconds. This function is     suitable for method calls only. It returns the reply message as     its return value, which will be either of type     QDBusMessage::ReplyMessage or QDBusMessage::ErrorMessage.      If no reply is received within \a timeout milliseconds, an automatic     error will be delivered indicating the expiration of the call.     The default \a timeout is -1, which will be replaced with an     implementation-defined value that is suitable for inter-process     communications (generally, 25 seconds).      See the QDBusInterface::call() function for a more friendly way     of placing calls.      \warning If \a mode is QDBus::BlockWithGui, this function will              reenter the Qt event loop in order to wait for the              reply. During the wait, it may deliver signals and other              method calls to your application. Therefore, it must be              prepared to handle a reentrancy whenever a call is              placed with call(). */
end_comment
begin_function
DECL|function|call
name|QDBusMessage
name|QDBusConnection
operator|::
name|call
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|,
name|QDBus
operator|::
name|CallMode
name|mode
parameter_list|,
name|int
name|timeout
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
condition|)
block|{
name|QDBusError
name|err
init|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|Disconnected
argument_list|,
name|QLatin1String
argument_list|(
literal|"Not connected to D-Bus server"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|lastError
operator|=
name|err
expr_stmt|;
return|return
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
name|mode
operator|!=
name|QDBus
operator|::
name|NoBlock
condition|)
return|return
name|d
operator|->
name|sendWithReply
argument_list|(
name|message
argument_list|,
name|mode
argument_list|,
name|timeout
argument_list|)
return|;
name|d
operator|->
name|send
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|QDBusMessage
name|retval
decl_stmt|;
name|retval
operator|<<
name|QVariant
argument_list|()
expr_stmt|;
comment|// add one argument (to avoid .at(0) problems)
return|return
name|retval
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     Sends the \a message over this connection and returns     immediately. This function is suitable for method calls only. It     returns an object of type QDBusPendingCall which can be used to     track the status of the reply.      If no reply is received within \a timeout milliseconds, an automatic     error will be delivered indicating the expiration of the call. The     default \a timeout is -1, which will be replaced with an     implementation-defined value that is suitable for inter-process     communications (generally, 25 seconds). This timeout is also the     upper limit for waiting in QDBusPendingCall::waitForFinished().      See the QDBusInterface::asyncCall() function for a more friendly way     of placing calls. */
end_comment
begin_function
DECL|function|asyncCall
name|QDBusPendingCall
name|QDBusConnection
operator|::
name|asyncCall
parameter_list|(
specifier|const
name|QDBusMessage
modifier|&
name|message
parameter_list|,
name|int
name|timeout
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
condition|)
block|{
return|return
name|QDBusPendingCall
argument_list|(
literal|0
argument_list|)
return|;
comment|// null pointer -> disconnected
block|}
name|QDBusPendingCallPrivate
modifier|*
name|priv
init|=
name|d
operator|->
name|sendWithReplyAsync
argument_list|(
name|message
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
return|return
name|QDBusPendingCall
argument_list|(
name|priv
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Connects the signal specified by the \a service, \a path, \a interface and \a name parameters to     the slot \a slot in object \a receiver. The arguments \a service and \a path can be empty,     denoting a connection to any signal of the (\a interface, \a name) pair, from any remote     application.      Returns true if the connection was successful.      \warning The signal will only be delivered to the slot if the parameters match. This verification              can be done only when the signal is received, not at connection time. */
end_comment
begin_function
DECL|function|connect
name|bool
name|QDBusConnection
operator|::
name|connect
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
return|return
name|connect
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|QStringList
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Connects the signal to the slot \a slot in object \a     receiver. Unlike the previous connect() overload, this function     allows one to specify the parameter signature to be connected     using the \a signature variable. The function will then verify     that this signature can be delivered to the slot specified by \a     slot and return false otherwise.      Returns true if the connection was successful.      \note This function verifies that the signal signature matches the           slot's parameters, but it does not verify that the actual           signal exists with the given signature in the remote           service. */
end_comment
begin_function
DECL|function|connect
name|bool
name|QDBusConnection
operator|::
name|connect
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
return|return
name|connect
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|QStringList
argument_list|()
argument_list|,
name|signature
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.6      Connects the signal to the slot \a slot in object \a     receiver. Unlike the previous connect() overload, this function     allows one to specify the parameter signature to be connected     using the \a signature variable. The function will then verify     that this signature can be delivered to the slot specified by \a     slot and return false otherwise.      The \a argumentMatch parameter lists the string parameters to be matched,     in sequential order. Note that, to match an empty string, you need to     pass a QString that is empty but not null (i.e., QString("")). A null     QString skips matching at that position.      Returns true if the connection was successful.      \note This function verifies that the signal signature matches the           slot's parameters, but it does not verify that the actual           signal exists with the given signature in the remote           service. */
end_comment
begin_function
DECL|function|connect
name|bool
name|QDBusConnection
operator|::
name|connect
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|argumentMatch
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
if|if
condition|(
operator|!
name|receiver
operator|||
operator|!
name|slot
operator|||
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|interface
operator|.
name|isEmpty
argument_list|()
operator|&&
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|QDBusUtil
operator|::
name|isValidInterfaceName
argument_list|(
name|interface
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QDBusConnection::connect: interface name '%s' is not valid"
argument_list|,
name|interface
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|service
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|QDBusUtil
operator|::
name|isValidBusName
argument_list|(
name|service
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QDBusConnection::connect: service name '%s' is not valid"
argument_list|,
name|service
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|QDBusUtil
operator|::
name|isValidObjectPath
argument_list|(
name|path
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QDBusConnection::connect: object path '%s' is not valid"
argument_list|,
name|path
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
name|QDBusWriteLocker
name|locker
argument_list|(
name|ConnectAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|connectSignal
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|argumentMatch
argument_list|,
name|signature
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Disconnects the signal specified by the \a service, \a path, \a interface     and \a name parameters from the slot \a slot in object \a receiver. The     arguments must be the same as passed to the connect() function.      Returns true if the disconnection was successful. */
end_comment
begin_function
DECL|function|disconnect
name|bool
name|QDBusConnection
operator|::
name|disconnect
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
return|return
name|disconnect
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|QStringList
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Disconnects the signal specified by the \a service, \a path, \a     interface, \a name, and \a signature parameters from the slot \a slot in     object \a receiver. The arguments must be the same as passed to the     connect() function.      Returns true if the disconnection was successful. */
end_comment
begin_function
DECL|function|disconnect
name|bool
name|QDBusConnection
operator|::
name|disconnect
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
return|return
name|disconnect
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|QStringList
argument_list|()
argument_list|,
name|signature
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.6      Disconnects the signal specified by the \a service, \a path, \a     interface, \a name, \a argumentMatch, and \a signature parameters from     the slot \a slot in object \a receiver. The arguments must be the same as     passed to the connect() function.      Returns true if the disconnection was successful. */
end_comment
begin_function
DECL|function|disconnect
name|bool
name|QDBusConnection
operator|::
name|disconnect
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|argumentMatch
parameter_list|,
specifier|const
name|QString
modifier|&
name|signature
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
if|if
condition|(
operator|!
name|receiver
operator|||
operator|!
name|slot
operator|||
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|QDBusUtil
operator|::
name|isValidInterfaceName
argument_list|(
name|interface
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|interface
operator|.
name|isEmpty
argument_list|()
operator|&&
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QDBusWriteLocker
name|locker
argument_list|(
name|DisconnectAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|disconnectSignal
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|argumentMatch
argument_list|,
name|signature
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Registers the object \a object at path \a path and returns true if     the registration was successful. The \a options parameter     specifies how much of the object \a object will be exposed through     D-Bus.      This function does not replace existing objects: if there is already an object registered at     path \a path, this function will return false. Use unregisterObject() to unregister it first.      You cannot register an object as a child object of an object that     was registered with QDBusConnection::ExportChildObjects. */
end_comment
begin_function
DECL|function|registerObject
name|bool
name|QDBusConnection
operator|::
name|registerObject
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|,
name|RegisterOptions
name|options
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
name|QDBusUtil
operator|::
name|isValidObjectPath
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"QDBusConnection::registerObject"
argument_list|,
literal|"Invalid object path given"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
operator|||
operator|!
name|object
operator|||
operator|!
name|options
operator|||
operator|!
name|QDBusUtil
operator|::
name|isValidObjectPath
argument_list|(
name|path
argument_list|)
condition|)
return|return
literal|false
return|;
name|QStringList
name|pathComponents
init|=
name|path
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pathComponents
operator|.
name|last
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|pathComponents
operator|.
name|removeLast
argument_list|()
expr_stmt|;
name|QDBusWriteLocker
name|locker
argument_list|(
name|RegisterObjectAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
comment|// lower-bound search for where this object should enter in the tree
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|node
init|=
operator|&
name|d
operator|->
name|rootNode
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|pathComponents
operator|.
name|count
argument_list|()
operator|==
name|i
condition|)
block|{
comment|// this node exists
comment|// consider it free if there's no object here and the user is not trying to
comment|// replace the object sub-tree
if|if
condition|(
name|node
operator|->
name|obj
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|options
operator|&
name|QDBusConnectionPrivate
operator|::
name|VirtualObject
condition|)
block|{
comment|// technically the check for children needs to go even deeper
if|if
condition|(
name|options
operator|&
name|SubPath
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|&
name|child
decl|,
name|node
operator|->
name|children
control|)
block|{
if|if
condition|(
name|child
operator|.
name|obj
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|ExportChildObjects
operator|&&
operator|!
name|node
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
return|return
literal|false
return|;
block|}
comment|// we can add the object here
name|node
operator|->
name|obj
operator|=
name|object
expr_stmt|;
name|node
operator|->
name|flags
operator|=
name|options
expr_stmt|;
name|d
operator|->
name|registerObject
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|//qDebug("REGISTERED FOR %s", path.toLocal8Bit().constData());
return|return
literal|true
return|;
block|}
comment|// if a virtual object occupies this path, return false
if|if
condition|(
name|node
operator|->
name|obj
operator|&&
operator|(
name|node
operator|->
name|flags
operator|&
name|QDBusConnectionPrivate
operator|::
name|VirtualObject
operator|)
operator|&&
operator|(
name|node
operator|->
name|flags
operator|&
name|QDBusConnection
operator|::
name|SubPath
operator|)
condition|)
block|{
name|qDebug
argument_list|(
literal|"Cannot register object at %s because QDBusVirtualObject handles all sub-paths."
argument_list|,
name|qPrintable
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// find the position where we'd insert the node
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|it
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|node
operator|->
name|children
operator|.
name|begin
argument_list|()
argument_list|,
name|node
operator|->
name|children
operator|.
name|end
argument_list|()
argument_list|,
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|node
operator|->
name|children
operator|.
name|end
argument_list|()
operator|&&
name|it
operator|->
name|name
operator|==
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|// match: this node exists
name|node
operator|=
name|it
expr_stmt|;
comment|// are we allowed to go deeper?
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|ExportChildObjects
condition|)
block|{
comment|// we're not
name|qDebug
argument_list|(
literal|"Cannot register object at %s because %s exports its own child objects"
argument_list|,
name|qPrintable
argument_list|(
name|path
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
comment|// add entry
name|node
operator|=
name|node
operator|->
name|children
operator|.
name|insert
argument_list|(
name|it
argument_list|,
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// iterate
operator|++
name|i
expr_stmt|;
block|}
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QDBusConnection::registerObject"
argument_list|,
literal|"The impossible happened"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 4.8     Registers a QDBusTreeNode for a path. It can handle a path including all child paths, thus     handling multiple DBus nodes.      To unregister a QDBusTreeNode use the unregisterObject() function with its path. */
end_comment
begin_function
DECL|function|registerVirtualObject
name|bool
name|QDBusConnection
operator|::
name|registerVirtualObject
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|QDBusVirtualObject
modifier|*
name|treeNode
parameter_list|,
name|VirtualObjectRegisterOption
name|options
parameter_list|)
block|{
name|int
name|opts
init|=
name|options
operator||
name|QDBusConnectionPrivate
operator|::
name|VirtualObject
decl_stmt|;
return|return
name|registerObject
argument_list|(
name|path
argument_list|,
operator|(
name|QObject
operator|*
operator|)
name|treeNode
argument_list|,
operator|(
name|RegisterOptions
operator|)
name|opts
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Unregisters an object that was registered with the registerObject() at the object path given by     \a path and, if \a mode is QDBusConnection::UnregisterTree, all of its sub-objects too.      Note that you cannot unregister objects that were not registered with registerObject(). */
end_comment
begin_function
DECL|function|unregisterObject
name|void
name|QDBusConnection
operator|::
name|unregisterObject
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|UnregisterMode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
operator|||
operator|!
name|QDBusUtil
operator|::
name|isValidObjectPath
argument_list|(
name|path
argument_list|)
condition|)
return|return;
name|QStringList
name|pathComponents
init|=
name|path
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
name|QDBusWriteLocker
name|locker
argument_list|(
name|UnregisterObjectAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|*
name|node
init|=
operator|&
name|d
operator|->
name|rootNode
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
comment|// find the object
while|while
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|pathComponents
operator|.
name|count
argument_list|()
operator|==
name|i
operator|||
operator|!
name|path
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
argument_list|)
condition|)
block|{
comment|// found it
name|node
operator|->
name|obj
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|UnregisterTree
condition|)
block|{
comment|// clear the sub-tree as well
name|node
operator|->
name|children
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// can't disconnect the objects because we really don't know if they can
comment|// be found somewhere else in the path too
block|}
return|return;
block|}
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|Iterator
name|it
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|node
operator|->
name|children
operator|.
name|begin
argument_list|()
argument_list|,
name|node
operator|->
name|children
operator|.
name|end
argument_list|()
argument_list|,
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|node
operator|->
name|children
operator|.
name|end
argument_list|()
operator|||
name|it
operator|->
name|name
operator|!=
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
break|break;
comment|// node not found
name|node
operator|=
name|it
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Return the object that was registered with the registerObject() at the object path given by     \a path. */
end_comment
begin_function
DECL|function|objectRegisteredAt
name|QObject
modifier|*
name|QDBusConnection
operator|::
name|objectRegisteredAt
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
specifier|const
block|{
name|Q_ASSERT_X
argument_list|(
name|QDBusUtil
operator|::
name|isValidObjectPath
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"QDBusConnection::registeredObject"
argument_list|,
literal|"Invalid object path given"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|connection
operator|||
operator|!
name|QDBusUtil
operator|::
name|isValidObjectPath
argument_list|(
name|path
argument_list|)
condition|)
return|return
literal|0
return|;
name|QStringList
name|pathComponents
init|=
name|path
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pathComponents
operator|.
name|last
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|pathComponents
operator|.
name|removeLast
argument_list|()
expr_stmt|;
comment|// lower-bound search for where this object should enter in the tree
name|QDBusReadLocker
name|lock
argument_list|(
name|ObjectRegisteredAtAction
argument_list|,
name|d
argument_list|)
decl_stmt|;
specifier|const
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
modifier|*
name|node
init|=
operator|&
name|d
operator|->
name|rootNode
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|pathComponents
operator|.
name|count
argument_list|()
operator|==
name|i
condition|)
return|return
name|node
operator|->
name|obj
return|;
if|if
condition|(
operator|(
name|node
operator|->
name|flags
operator|&
name|QDBusConnectionPrivate
operator|::
name|VirtualObject
operator|)
operator|&&
operator|(
name|node
operator|->
name|flags
operator|&
name|QDBusConnection
operator|::
name|SubPath
operator|)
condition|)
return|return
name|node
operator|->
name|obj
return|;
name|QDBusConnectionPrivate
operator|::
name|ObjectTreeNode
operator|::
name|DataList
operator|::
name|ConstIterator
name|it
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|node
operator|->
name|children
operator|.
name|constBegin
argument_list|()
argument_list|,
name|node
operator|->
name|children
operator|.
name|constEnd
argument_list|()
argument_list|,
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|node
operator|->
name|children
operator|.
name|constEnd
argument_list|()
operator|||
name|it
operator|->
name|name
operator|!=
name|pathComponents
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
break|break;
comment|// node not found
name|node
operator|=
name|it
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDBusConnectionInterface object that represents the     D-Bus server interface on this connection. */
end_comment
begin_function
DECL|function|interface
name|QDBusConnectionInterface
modifier|*
name|QDBusConnection
operator|::
name|interface
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|busService
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 4.8      Returns the internal, implementation-defined pointer for this     connection. Currently, this returns a DBusConnection* pointer,     without changing the reference count. It is the responsibility of     the caller to call dbus_connection_ref if it wants to store the     pointer. */
end_comment
begin_function
DECL|function|internalPointer
name|void
modifier|*
name|QDBusConnection
operator|::
name|internalPointer
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|connection
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this QDBusConnection object is connected. */
end_comment
begin_function
DECL|function|isConnected
name|bool
name|QDBusConnection
operator|::
name|isConnected
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|&&
name|d
operator|->
name|connection
operator|&&
name|q_dbus_connection_get_is_connected
argument_list|(
name|d
operator|->
name|connection
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the last error that happened in this connection.      This function is provided for low-level code. If you're using     QDBusInterface::call(), error codes are reported by its return     value.      \sa QDBusInterface, QDBusMessage */
end_comment
begin_function
DECL|function|lastError
name|QDBusError
name|QDBusConnection
operator|::
name|lastError
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|lastError
else|:
name|QDBusError
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the unique connection name for this connection, if this QDBusConnection object is     connected, or an empty QString otherwise.      A Unique Connection Name is a string in the form ":x.xxx" (where x     are decimal digits) that is assigned by the D-Bus server daemon     upon connection. It uniquely identifies this client in the bus.      This function returns an empty QString for peer-to-peer connections. */
end_comment
begin_function
DECL|function|baseService
name|QString
name|QDBusConnection
operator|::
name|baseService
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|baseService
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the connection name for this connection, as given as the     name parameter to connectToBus().      The connection name can be used to uniquely identify actual     underlying connections to buses.  Copies made from a single     connection will always implicitly share the underlying connection,     and hence will have the same connection name.      Inversely, two connections having different connection names will     always either be connected to different buses, or have a different     unique name (as returned by baseService()) on that bus.      \sa connectToBus(), disconnectFromBus() */
end_comment
begin_function
DECL|function|name
name|QString
name|QDBusConnection
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|name
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns the capabilities of this connection as negotiated with the bus     server or peer. If this QDBusConnection is not connected, this function     returns no capabilities. */
end_comment
begin_function
DECL|function|connectionCapabilities
name|QDBusConnection
operator|::
name|ConnectionCapabilities
name|QDBusConnection
operator|::
name|connectionCapabilities
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|capabilities
else|:
name|ConnectionCapabilities
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Attempts to register the \a serviceName on the D-Bus server and     returns true if the registration succeeded. The registration will     fail if the name is already registered by another application.      \sa unregisterService(), QDBusConnectionInterface::registerService() */
end_comment
begin_function
DECL|function|registerService
name|bool
name|QDBusConnection
operator|::
name|registerService
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
if|if
condition|(
name|interface
argument_list|()
operator|&&
name|interface
argument_list|()
operator|->
name|registerService
argument_list|(
name|serviceName
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|registerService
argument_list|(
name|serviceName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Unregisters the service \a serviceName that was previously     registered with registerService() and returns true if it     succeeded.      \sa registerService(), QDBusConnectionInterface::unregisterService() */
end_comment
begin_function
DECL|function|unregisterService
name|bool
name|QDBusConnection
operator|::
name|unregisterService
parameter_list|(
specifier|const
name|QString
modifier|&
name|serviceName
parameter_list|)
block|{
if|if
condition|(
name|interface
argument_list|()
operator|->
name|unregisterService
argument_list|(
name|serviceName
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|unregisterService
argument_list|(
name|serviceName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|_q_sessionBusName
specifier|static
specifier|const
name|char
name|_q_sessionBusName
index|[]
init|=
literal|"qt_default_session_bus"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_q_systemBusName
specifier|static
specifier|const
name|char
name|_q_systemBusName
index|[]
init|=
literal|"qt_default_system_bus"
decl_stmt|;
end_decl_stmt
begin_class
DECL|class|QDBusDefaultConnection
class|class
name|QDBusDefaultConnection
super|:
specifier|public
name|QDBusConnection
block|{
DECL|member|ownName
specifier|const
name|char
modifier|*
name|ownName
decl_stmt|;
public|public:
DECL|function|QDBusDefaultConnection
specifier|inline
name|QDBusDefaultConnection
parameter_list|(
name|BusType
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
member_init_list|:
name|QDBusConnection
argument_list|(
name|connectToBus
argument_list|(
name|type
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
member_init_list|,
name|ownName
argument_list|(
name|name
argument_list|)
block|{
comment|// make sure this connection is running on the main thread
name|QCoreApplication
modifier|*
name|instance
init|=
name|QCoreApplication
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|instance
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDBusConnection: %s D-Bus connection created before QCoreApplication. Application may misbehave."
argument_list|,
name|type
operator|==
name|SessionBus
condition|?
literal|"session"
else|:
name|type
operator|==
name|SystemBus
condition|?
literal|"system"
else|:
literal|"generic"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QDBusConnectionPrivate
operator|::
name|d
argument_list|(
operator|*
name|this
argument_list|)
condition|)
block|{
name|QDBusConnectionPrivate
operator|::
name|d
argument_list|(
operator|*
name|this
argument_list|)
operator|->
name|moveToThread
argument_list|(
name|instance
operator|->
name|thread
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|~QDBusDefaultConnection
specifier|inline
name|~
name|QDBusDefaultConnection
parameter_list|()
block|{
name|disconnectFromBus
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|ownName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|QDBusDefaultConnection
argument_list|,
argument|_q_sessionBus
argument_list|,
argument|(QDBusConnection::SessionBus, _q_sessionBusName)
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|QDBusDefaultConnection
argument_list|,
argument|_q_systemBus
argument_list|,
argument|(QDBusConnection::SystemBus, _q_systemBusName)
argument_list|)
end_macro
begin_comment
comment|/*!     \fn QDBusConnection QDBusConnection::sessionBus()      Returns a QDBusConnection object opened with the session bus. The object     reference returned by this function is valid until the application terminates,     at which point the connection will be closed and the object deleted. */
end_comment
begin_function
DECL|function|sessionBus
name|QDBusConnection
name|QDBusConnection
operator|::
name|sessionBus
parameter_list|()
block|{
return|return
operator|*
name|_q_sessionBus
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDBusConnection QDBusConnection::systemBus()      Returns a QDBusConnection object opened with the system bus. The object reference returned     by this function is valid until the QCoreApplication's destructor is run, when the     connection will be closed and the object, deleted. */
end_comment
begin_function
DECL|function|systemBus
name|QDBusConnection
name|QDBusConnection
operator|::
name|systemBus
parameter_list|()
block|{
return|return
operator|*
name|_q_systemBus
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \nonreentrant    Returns the connection that sent the signal, if called in a slot activated   by QDBus; otherwise it returns 0.    \note Please avoid this function. This function is not thread-safe, so if   there's any other thread delivering a D-Bus call, this function may return   the wrong connection. In new code, please use QDBusContext::connection()   (see that class for a description on how to use it). */
end_comment
begin_function
DECL|function|sender
name|QDBusConnection
name|QDBusConnection
operator|::
name|sender
parameter_list|()
block|{
return|return
name|QDBusConnection
argument_list|(
name|_q_manager
argument_list|()
operator|->
name|sender
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|setSender
name|void
name|QDBusConnectionPrivate
operator|::
name|setSender
parameter_list|(
specifier|const
name|QDBusConnectionPrivate
modifier|*
name|s
parameter_list|)
block|{
name|_q_manager
argument_list|()
operator|->
name|setSender
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|setBusService
name|void
name|QDBusConnectionPrivate
operator|::
name|setBusService
parameter_list|(
specifier|const
name|QDBusConnection
modifier|&
name|connection
parameter_list|)
block|{
name|busService
operator|=
operator|new
name|QDBusConnectionInterface
argument_list|(
name|connection
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
comment|// busService has increased the refcounting to us
comment|// avoid cyclic refcounting
name|QObject
operator|::
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|callWithCallbackFailed
argument_list|(
name|QDBusError
argument_list|,
name|QDBusMessage
argument_list|)
argument_list|)
argument_list|,
name|busService
argument_list|,
name|SIGNAL
argument_list|(
name|callWithCallbackFailed
argument_list|(
name|QDBusError
argument_list|,
name|QDBusMessage
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     Returns the local machine ID as known to the D-Bus system. Each     node or host that runs D-Bus has a unique identifier that can be     used to distinguish it from other hosts if they are sharing     resources like the filesystem.      Note that the local machine ID is not guaranteed to be persistent     across boots of the system, so this identifier should not be     stored in persistent storage (like the filesystem). It is     guaranteed to remain constant only during the lifetime of this     boot session. */
end_comment
begin_function
DECL|function|localMachineId
name|QByteArray
name|QDBusConnection
operator|::
name|localMachineId
parameter_list|()
block|{
name|char
modifier|*
name|dbus_machine_id
init|=
name|q_dbus_get_local_machine_id
argument_list|()
decl_stmt|;
name|QByteArray
name|result
init|=
name|dbus_machine_id
decl_stmt|;
name|q_dbus_free
argument_list|(
name|dbus_machine_id
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \namespace QDBus     \inmodule QtDBus      \brief The QDBus namespace contains miscellaneous identifiers used     throughout the Qt D-Bus module. */
end_comment
begin_comment
comment|/*!     \enum QDBus::CallMode      This enum describes the various ways of placing a function call. The valid modes are:      \value NoBlock              Place the call but don't wait for the reply (the reply's contents                                 will be discarded).     \value Block                Don't use an event loop to wait for a reply, but instead block on                                 network operations while waiting. This means the                                 user-interface may not be updated until the function returns.     \value BlockWithGui         Use the Qt event loop to wait for a reply. This means that the                                 user-interface will stay responsive (processing input events),                                 but it also means other events may happen, like signal delivery                                 and other D-Bus method calls.     \value AutoDetect           Automatically detect if the called function has a reply.      When using BlockWithGui, applications must be prepared for reentrancy in any function. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DBUS
end_comment
end_unit
