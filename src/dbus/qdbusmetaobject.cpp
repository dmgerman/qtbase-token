begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtDBus module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdbusmetaobject_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qbytearray.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qhash.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qstring.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|"qdbusutil_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbuserror.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmetatype.h"
end_include
begin_include
include|#
directive|include
file|"qdbusargument.h"
end_include
begin_include
include|#
directive|include
file|"qdbusintrospection_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusabstractinterface_p.h"
end_include
begin_include
include|#
directive|include
file|<private/qmetaobject_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qmetaobjectbuilder_p.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DBUS
end_ifndef
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QDBusMetaObjectGenerator
class|class
name|QDBusMetaObjectGenerator
block|{
public|public:
name|QDBusMetaObjectGenerator
parameter_list|(
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QDBusIntrospection
operator|::
name|Interface
modifier|*
name|parsedData
parameter_list|)
constructor_decl|;
name|void
name|write
parameter_list|(
name|QDBusMetaObject
modifier|*
name|obj
parameter_list|)
function_decl|;
name|void
name|writeWithoutXml
parameter_list|(
name|QDBusMetaObject
modifier|*
name|obj
parameter_list|)
function_decl|;
private|private:
DECL|struct|Method
struct|struct
name|Method
block|{
DECL|member|parameterNames
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|parameterNames
decl_stmt|;
DECL|member|tag
name|QByteArray
name|tag
decl_stmt|;
DECL|member|name
name|QByteArray
name|name
decl_stmt|;
DECL|member|inputTypes
name|QVarLengthArray
argument_list|<
name|int
argument_list|,
literal|4
argument_list|>
name|inputTypes
decl_stmt|;
DECL|member|outputTypes
name|QVarLengthArray
argument_list|<
name|int
argument_list|,
literal|4
argument_list|>
name|outputTypes
decl_stmt|;
DECL|member|flags
name|int
name|flags
decl_stmt|;
block|}
struct|;
DECL|struct|Property
struct|struct
name|Property
block|{
DECL|member|typeName
name|QByteArray
name|typeName
decl_stmt|;
DECL|member|signature
name|QByteArray
name|signature
decl_stmt|;
DECL|member|type
name|int
name|type
decl_stmt|;
DECL|member|flags
name|int
name|flags
decl_stmt|;
block|}
struct|;
DECL|struct|Type
struct|struct
name|Type
block|{
DECL|member|id
name|int
name|id
decl_stmt|;
DECL|member|name
name|QByteArray
name|name
decl_stmt|;
block|}
struct|;
DECL|member|signals_
name|QMap
argument_list|<
name|QByteArray
argument_list|,
name|Method
argument_list|>
name|signals_
decl_stmt|;
DECL|member|methods
name|QMap
argument_list|<
name|QByteArray
argument_list|,
name|Method
argument_list|>
name|methods
decl_stmt|;
DECL|member|properties
name|QMap
argument_list|<
name|QByteArray
argument_list|,
name|Property
argument_list|>
name|properties
decl_stmt|;
DECL|member|data
specifier|const
name|QDBusIntrospection
operator|::
name|Interface
modifier|*
name|data
decl_stmt|;
DECL|member|interface
name|QString
name|interface
decl_stmt|;
name|Type
name|findType
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|signature
parameter_list|,
specifier|const
name|QDBusIntrospection
operator|::
name|Annotations
modifier|&
name|annotations
parameter_list|,
specifier|const
name|char
modifier|*
name|direction
init|=
literal|"Out"
parameter_list|,
name|int
name|id
init|=
operator|-
literal|1
parameter_list|)
function_decl|;
name|void
name|parseMethods
parameter_list|()
function_decl|;
name|void
name|parseSignals
parameter_list|()
function_decl|;
name|void
name|parseProperties
parameter_list|()
function_decl|;
specifier|static
name|int
name|aggregateParameterCount
parameter_list|(
specifier|const
name|QMap
argument_list|<
name|QByteArray
argument_list|,
name|Method
argument_list|>
modifier|&
name|map
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_decl_stmt
DECL|variable|intsPerProperty
specifier|static
specifier|const
name|int
name|intsPerProperty
init|=
literal|2
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|intsPerMethod
specifier|static
specifier|const
name|int
name|intsPerMethod
init|=
literal|2
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|QDBusMetaObjectPrivate
struct|struct
name|QDBusMetaObjectPrivate
super|:
specifier|public
name|QMetaObjectPrivate
block|{
DECL|member|propertyDBusData
name|int
name|propertyDBusData
decl_stmt|;
DECL|member|methodDBusData
name|int
name|methodDBusData
decl_stmt|;
block|}
struct|;
end_struct
begin_constructor
DECL|function|QDBusMetaObjectGenerator
name|QDBusMetaObjectGenerator
operator|::
name|QDBusMetaObjectGenerator
parameter_list|(
specifier|const
name|QString
modifier|&
name|interfaceName
parameter_list|,
specifier|const
name|QDBusIntrospection
operator|::
name|Interface
modifier|*
name|parsedData
parameter_list|)
member_init_list|:
name|data
argument_list|(
name|parsedData
argument_list|)
member_init_list|,
name|interface
argument_list|(
name|interfaceName
argument_list|)
block|{
if|if
condition|(
name|data
condition|)
block|{
name|parseProperties
argument_list|()
expr_stmt|;
name|parseSignals
argument_list|()
expr_stmt|;
comment|// call parseSignals first so that slots override signals
name|parseMethods
argument_list|()
expr_stmt|;
block|}
block|}
end_constructor
begin_decl_stmt
DECL|variable|qt_dbus_metaobject_skip_annotations
name|Q_DBUS_EXPORT
name|bool
name|qt_dbus_metaobject_skip_annotations
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_function
name|QDBusMetaObjectGenerator
operator|::
name|Type
DECL|function|findType
name|QDBusMetaObjectGenerator
operator|::
name|findType
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|signature
parameter_list|,
specifier|const
name|QDBusIntrospection
operator|::
name|Annotations
modifier|&
name|annotations
parameter_list|,
specifier|const
name|char
modifier|*
name|direction
parameter_list|,
name|int
name|id
parameter_list|)
block|{
struct|struct
name|QDBusRawTypeHandler
block|{
specifier|static
name|void
name|destroy
parameter_list|(
name|void
modifier|*
parameter_list|)
block|{
name|qFatal
argument_list|(
literal|"Cannot destroy placeholder type QDBusRawType"
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
modifier|*
name|create
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
block|{
name|qFatal
argument_list|(
literal|"Cannot create placeholder type QDBusRawType"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|void
name|destruct
parameter_list|(
name|void
modifier|*
parameter_list|)
block|{
name|qFatal
argument_list|(
literal|"Cannot destruct placeholder type QDBusRawType"
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
modifier|*
name|construct
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
block|{
name|qFatal
argument_list|(
literal|"Cannot construct placeholder type QDBusRawType"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
struct|;
name|Type
name|result
decl_stmt|;
name|result
operator|.
name|id
operator|=
name|QVariant
operator|::
name|Invalid
expr_stmt|;
name|int
name|type
init|=
name|QDBusMetaType
operator|::
name|signatureToType
argument_list|(
name|signature
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|QVariant
operator|::
name|Invalid
operator|&&
operator|!
name|qt_dbus_metaobject_skip_annotations
condition|)
block|{
comment|// it's not a type normally handled by our meta type system
comment|// it must contain an annotation
name|QString
name|annotationName
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"org.qtproject.QtDBus.QtTypeName"
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|>=
literal|0
condition|)
name|annotationName
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|".%1%2"
argument_list|)
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
name|direction
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|// extract from annotations:
name|QByteArray
name|typeName
init|=
name|annotations
operator|.
name|value
argument_list|(
name|annotationName
argument_list|)
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
comment|// verify that it's a valid one
if|if
condition|(
name|typeName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// try the old annotation from Qt 4
name|annotationName
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"com.trolltech.QtDBus.QtTypeName"
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|>=
literal|0
condition|)
name|annotationName
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|".%1%2"
argument_list|)
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
name|direction
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|typeName
operator|=
name|annotations
operator|.
name|value
argument_list|(
name|annotationName
argument_list|)
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|typeName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// type name found
name|type
operator|=
name|QMetaType
operator|::
name|type
argument_list|(
name|typeName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|QVariant
operator|::
name|Invalid
operator|||
name|signature
operator|!=
name|QDBusMetaType
operator|::
name|typeToSignature
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|// type is still unknown or doesn't match back to the signature that it
comment|// was expected to, so synthesize a fake type
name|typeName
operator|=
literal|"QDBusRawType<0x"
operator|+
name|signature
operator|.
name|toHex
argument_list|()
operator|+
literal|">*"
expr_stmt|;
name|type
operator|=
name|QMetaType
operator|::
name|registerType
argument_list|(
name|typeName
argument_list|,
name|QDBusRawTypeHandler
operator|::
name|destroy
argument_list|,
name|QDBusRawTypeHandler
operator|::
name|create
argument_list|,
name|QDBusRawTypeHandler
operator|::
name|destruct
argument_list|,
name|QDBusRawTypeHandler
operator|::
name|construct
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|QMetaType
operator|::
name|MovableType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|name
operator|=
name|typeName
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QVariant
operator|::
name|Invalid
condition|)
block|{
comment|// this case is used only by the qdbus command-line tool
comment|// invalid, let's create an impossible type that contains the signature
if|if
condition|(
name|signature
operator|==
literal|"av"
condition|)
block|{
name|result
operator|.
name|name
operator|=
literal|"QVariantList"
expr_stmt|;
name|type
operator|=
name|QVariant
operator|::
name|List
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|signature
operator|==
literal|"a{sv}"
condition|)
block|{
name|result
operator|.
name|name
operator|=
literal|"QVariantMap"
expr_stmt|;
name|type
operator|=
name|QVariant
operator|::
name|Map
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|name
operator|=
literal|"QDBusRawType::"
operator|+
name|signature
expr_stmt|;
name|type
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|.
name|name
operator|=
name|QMetaType
operator|::
name|typeName
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|id
operator|=
name|type
expr_stmt|;
return|return
name|result
return|;
comment|// success
block|}
end_function
begin_function
DECL|function|parseMethods
name|void
name|QDBusMetaObjectGenerator
operator|::
name|parseMethods
parameter_list|()
block|{
comment|//
comment|// TODO:
comment|//  Add cloned methods when the remote object has return types
comment|//
name|QDBusIntrospection
operator|::
name|Methods
operator|::
name|ConstIterator
name|method_it
init|=
name|data
operator|->
name|methods
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QDBusIntrospection
operator|::
name|Methods
operator|::
name|ConstIterator
name|method_end
init|=
name|data
operator|->
name|methods
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|method_it
operator|!=
name|method_end
condition|;
operator|++
name|method_it
control|)
block|{
specifier|const
name|QDBusIntrospection
operator|::
name|Method
modifier|&
name|m
init|=
operator|*
name|method_it
decl_stmt|;
name|Method
name|mm
decl_stmt|;
name|mm
operator|.
name|name
operator|=
name|m
operator|.
name|name
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|QByteArray
name|prototype
init|=
name|mm
operator|.
name|name
decl_stmt|;
name|prototype
operator|+=
literal|'('
expr_stmt|;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
comment|// build the input argument list
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m
operator|.
name|inputArgs
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QDBusIntrospection
operator|::
name|Argument
modifier|&
name|arg
init|=
name|m
operator|.
name|inputArgs
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Type
name|type
init|=
name|findType
argument_list|(
name|arg
operator|.
name|type
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|m
operator|.
name|annotations
argument_list|,
literal|"In"
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|id
operator|==
name|QVariant
operator|::
name|Invalid
condition|)
block|{
name|ok
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|mm
operator|.
name|inputTypes
operator|.
name|append
argument_list|(
name|type
operator|.
name|id
argument_list|)
expr_stmt|;
name|mm
operator|.
name|parameterNames
operator|.
name|append
argument_list|(
name|arg
operator|.
name|name
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
name|prototype
operator|.
name|append
argument_list|(
name|type
operator|.
name|name
argument_list|)
expr_stmt|;
name|prototype
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
comment|// build the output argument list:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m
operator|.
name|outputArgs
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QDBusIntrospection
operator|::
name|Argument
modifier|&
name|arg
init|=
name|m
operator|.
name|outputArgs
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Type
name|type
init|=
name|findType
argument_list|(
name|arg
operator|.
name|type
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|m
operator|.
name|annotations
argument_list|,
literal|"Out"
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|id
operator|==
name|QVariant
operator|::
name|Invalid
condition|)
block|{
name|ok
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|mm
operator|.
name|outputTypes
operator|.
name|append
argument_list|(
name|type
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|// non-const ref parameter
name|mm
operator|.
name|parameterNames
operator|.
name|append
argument_list|(
name|arg
operator|.
name|name
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
name|prototype
operator|.
name|append
argument_list|(
name|type
operator|.
name|name
argument_list|)
expr_stmt|;
name|prototype
operator|.
name|append
argument_list|(
literal|"&,"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
comment|// convert the last commas:
if|if
condition|(
operator|!
name|mm
operator|.
name|parameterNames
operator|.
name|isEmpty
argument_list|()
condition|)
name|prototype
index|[
name|prototype
operator|.
name|length
argument_list|()
operator|-
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
else|else
name|prototype
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
comment|// check the async tag
if|if
condition|(
name|m
operator|.
name|annotations
operator|.
name|value
argument_list|(
name|QLatin1String
argument_list|(
name|ANNOTATION_NO_WAIT
argument_list|)
argument_list|)
operator|==
name|QLatin1String
argument_list|(
literal|"true"
argument_list|)
condition|)
name|mm
operator|.
name|tag
operator|=
literal|"Q_NOREPLY"
expr_stmt|;
comment|// meta method flags
name|mm
operator|.
name|flags
operator|=
name|AccessPublic
operator||
name|MethodSlot
operator||
name|MethodScriptable
expr_stmt|;
comment|// add
name|methods
operator|.
name|insert
argument_list|(
name|QMetaObject
operator|::
name|normalizedSignature
argument_list|(
name|prototype
argument_list|)
argument_list|,
name|mm
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|parseSignals
name|void
name|QDBusMetaObjectGenerator
operator|::
name|parseSignals
parameter_list|()
block|{
name|QDBusIntrospection
operator|::
name|Signals
operator|::
name|ConstIterator
name|signal_it
init|=
name|data
operator|->
name|signals_
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QDBusIntrospection
operator|::
name|Signals
operator|::
name|ConstIterator
name|signal_end
init|=
name|data
operator|->
name|signals_
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|signal_it
operator|!=
name|signal_end
condition|;
operator|++
name|signal_it
control|)
block|{
specifier|const
name|QDBusIntrospection
operator|::
name|Signal
modifier|&
name|s
init|=
operator|*
name|signal_it
decl_stmt|;
name|Method
name|mm
decl_stmt|;
name|mm
operator|.
name|name
operator|=
name|s
operator|.
name|name
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|QByteArray
name|prototype
init|=
name|mm
operator|.
name|name
decl_stmt|;
name|prototype
operator|+=
literal|'('
expr_stmt|;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
comment|// build the output argument list
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|outputArgs
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QDBusIntrospection
operator|::
name|Argument
modifier|&
name|arg
init|=
name|s
operator|.
name|outputArgs
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Type
name|type
init|=
name|findType
argument_list|(
name|arg
operator|.
name|type
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|s
operator|.
name|annotations
argument_list|,
literal|"Out"
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|id
operator|==
name|QVariant
operator|::
name|Invalid
condition|)
block|{
name|ok
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|mm
operator|.
name|inputTypes
operator|.
name|append
argument_list|(
name|type
operator|.
name|id
argument_list|)
expr_stmt|;
name|mm
operator|.
name|parameterNames
operator|.
name|append
argument_list|(
name|arg
operator|.
name|name
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
name|prototype
operator|.
name|append
argument_list|(
name|type
operator|.
name|name
argument_list|)
expr_stmt|;
name|prototype
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
comment|// convert the last commas:
if|if
condition|(
operator|!
name|mm
operator|.
name|parameterNames
operator|.
name|isEmpty
argument_list|()
condition|)
name|prototype
index|[
name|prototype
operator|.
name|length
argument_list|()
operator|-
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
else|else
name|prototype
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
comment|// meta method flags
name|mm
operator|.
name|flags
operator|=
name|AccessProtected
operator||
name|MethodSignal
operator||
name|MethodScriptable
expr_stmt|;
comment|// add
name|signals_
operator|.
name|insert
argument_list|(
name|QMetaObject
operator|::
name|normalizedSignature
argument_list|(
name|prototype
argument_list|)
argument_list|,
name|mm
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|parseProperties
name|void
name|QDBusMetaObjectGenerator
operator|::
name|parseProperties
parameter_list|()
block|{
name|QDBusIntrospection
operator|::
name|Properties
operator|::
name|ConstIterator
name|prop_it
init|=
name|data
operator|->
name|properties
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QDBusIntrospection
operator|::
name|Properties
operator|::
name|ConstIterator
name|prop_end
init|=
name|data
operator|->
name|properties
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|prop_it
operator|!=
name|prop_end
condition|;
operator|++
name|prop_it
control|)
block|{
specifier|const
name|QDBusIntrospection
operator|::
name|Property
modifier|&
name|p
init|=
operator|*
name|prop_it
decl_stmt|;
name|Property
name|mp
decl_stmt|;
name|Type
name|type
init|=
name|findType
argument_list|(
name|p
operator|.
name|type
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|p
operator|.
name|annotations
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|id
operator|==
name|QVariant
operator|::
name|Invalid
condition|)
continue|continue;
name|QByteArray
name|name
init|=
name|p
operator|.
name|name
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
name|mp
operator|.
name|signature
operator|=
name|p
operator|.
name|type
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|mp
operator|.
name|type
operator|=
name|type
operator|.
name|id
expr_stmt|;
name|mp
operator|.
name|typeName
operator|=
name|type
operator|.
name|name
expr_stmt|;
comment|// build the flags:
name|mp
operator|.
name|flags
operator|=
name|StdCppSet
operator||
name|Scriptable
operator||
name|Stored
operator||
name|Designable
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|access
operator|!=
name|QDBusIntrospection
operator|::
name|Property
operator|::
name|Write
condition|)
name|mp
operator|.
name|flags
operator||=
name|Readable
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|access
operator|!=
name|QDBusIntrospection
operator|::
name|Property
operator|::
name|Read
condition|)
name|mp
operator|.
name|flags
operator||=
name|Writable
expr_stmt|;
comment|// add the property:
name|properties
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Returns the sum of all parameters (including return type) for the given
end_comment
begin_comment
comment|// \a map of methods. This is needed for calculating the size of the methods'
end_comment
begin_comment
comment|// parameter type/name meta-data.
end_comment
begin_function
DECL|function|aggregateParameterCount
name|int
name|QDBusMetaObjectGenerator
operator|::
name|aggregateParameterCount
parameter_list|(
specifier|const
name|QMap
argument_list|<
name|QByteArray
argument_list|,
name|Method
argument_list|>
modifier|&
name|map
parameter_list|)
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|QMap
argument_list|<
name|QByteArray
argument_list|,
name|Method
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|map
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|map
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|Method
modifier|&
name|m
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|sum
operator|+=
name|m
operator|.
name|inputTypes
operator|.
name|size
argument_list|()
operator|+
name|qMax
argument_list|(
literal|1
argument_list|,
name|m
operator|.
name|outputTypes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function
begin_function
DECL|function|write
name|void
name|QDBusMetaObjectGenerator
operator|::
name|write
parameter_list|(
name|QDBusMetaObject
modifier|*
name|obj
parameter_list|)
block|{
comment|// this code here is mostly copied from qaxbase.cpp
comment|// with a few modifications to make it cleaner
name|QString
name|className
init|=
name|interface
decl_stmt|;
name|className
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"::"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|className
operator|.
name|isEmpty
argument_list|()
condition|)
name|className
operator|=
name|QLatin1String
argument_list|(
literal|"QDBusInterface"
argument_list|)
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|int
argument_list|>
name|idata
decl_stmt|;
name|idata
operator|.
name|resize
argument_list|(
sizeof|sizeof
argument_list|(
name|QDBusMetaObjectPrivate
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|methodParametersDataSize
init|=
operator|(
operator|(
name|aggregateParameterCount
argument_list|(
name|signals_
argument_list|)
operator|+
name|aggregateParameterCount
argument_list|(
name|methods
argument_list|)
operator|)
operator|*
literal|2
operator|)
comment|// types and parameter names
operator|-
name|signals_
operator|.
name|count
argument_list|()
comment|// return "parameters" don't have names
operator|-
name|methods
operator|.
name|count
argument_list|()
decl_stmt|;
comment|// ditto
name|QDBusMetaObjectPrivate
modifier|*
name|header
init|=
cast|reinterpret_cast
argument_list|<
name|QDBusMetaObjectPrivate
operator|*
argument_list|>
argument_list|(
name|idata
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|Q_STATIC_ASSERT_X
argument_list|(
name|QMetaObjectPrivate
operator|::
name|OutputRevision
operator|==
literal|7
argument_list|,
literal|"QtDBus meta-object generator should generate the same version as moc"
argument_list|)
expr_stmt|;
name|header
operator|->
name|revision
operator|=
name|QMetaObjectPrivate
operator|::
name|OutputRevision
expr_stmt|;
name|header
operator|->
name|className
operator|=
literal|0
expr_stmt|;
name|header
operator|->
name|classInfoCount
operator|=
literal|0
expr_stmt|;
name|header
operator|->
name|classInfoData
operator|=
literal|0
expr_stmt|;
name|header
operator|->
name|methodCount
operator|=
name|signals_
operator|.
name|count
argument_list|()
operator|+
name|methods
operator|.
name|count
argument_list|()
expr_stmt|;
name|header
operator|->
name|methodData
operator|=
name|idata
operator|.
name|size
argument_list|()
expr_stmt|;
name|header
operator|->
name|propertyCount
operator|=
name|properties
operator|.
name|count
argument_list|()
expr_stmt|;
name|header
operator|->
name|propertyData
operator|=
name|header
operator|->
name|methodData
operator|+
name|header
operator|->
name|methodCount
operator|*
literal|5
operator|+
name|methodParametersDataSize
expr_stmt|;
name|header
operator|->
name|enumeratorCount
operator|=
literal|0
expr_stmt|;
name|header
operator|->
name|enumeratorData
operator|=
literal|0
expr_stmt|;
name|header
operator|->
name|constructorCount
operator|=
literal|0
expr_stmt|;
name|header
operator|->
name|constructorData
operator|=
literal|0
expr_stmt|;
name|header
operator|->
name|flags
operator|=
name|RequiresVariantMetaObject
expr_stmt|;
name|header
operator|->
name|signalCount
operator|=
name|signals_
operator|.
name|count
argument_list|()
expr_stmt|;
comment|// These are specific to QDBusMetaObject:
name|header
operator|->
name|propertyDBusData
operator|=
name|header
operator|->
name|propertyData
operator|+
name|header
operator|->
name|propertyCount
operator|*
literal|3
expr_stmt|;
name|header
operator|->
name|methodDBusData
operator|=
name|header
operator|->
name|propertyDBusData
operator|+
name|header
operator|->
name|propertyCount
operator|*
name|intsPerProperty
expr_stmt|;
name|int
name|data_size
init|=
name|idata
operator|.
name|size
argument_list|()
operator|+
operator|(
name|header
operator|->
name|methodCount
operator|*
operator|(
literal|5
operator|+
name|intsPerMethod
operator|)
operator|)
operator|+
name|methodParametersDataSize
operator|+
operator|(
name|header
operator|->
name|propertyCount
operator|*
operator|(
literal|3
operator|+
name|intsPerProperty
operator|)
operator|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|Method
modifier|&
name|mm
decl|,
name|signals_
control|)
name|data_size
operator|+=
literal|2
operator|+
name|mm
operator|.
name|inputTypes
operator|.
name|count
argument_list|()
operator|+
name|mm
operator|.
name|outputTypes
operator|.
name|count
argument_list|()
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|Method
modifier|&
name|mm
decl|,
name|methods
control|)
name|data_size
operator|+=
literal|2
operator|+
name|mm
operator|.
name|inputTypes
operator|.
name|count
argument_list|()
operator|+
name|mm
operator|.
name|outputTypes
operator|.
name|count
argument_list|()
expr_stmt|;
name|idata
operator|.
name|resize
argument_list|(
name|data_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|QMetaStringTable
name|strings
decl_stmt|;
name|strings
operator|.
name|enter
argument_list|(
name|className
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
name|header
operator|->
name|methodData
decl_stmt|;
name|int
name|parametersOffset
init|=
name|offset
operator|+
name|header
operator|->
name|methodCount
operator|*
literal|5
decl_stmt|;
name|int
name|signatureOffset
init|=
name|header
operator|->
name|methodDBusData
decl_stmt|;
name|int
name|typeidOffset
init|=
name|header
operator|->
name|methodDBusData
operator|+
name|header
operator|->
name|methodCount
operator|*
name|intsPerMethod
decl_stmt|;
name|idata
index|[
name|typeidOffset
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|// eod
comment|// add each method:
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
literal|2
condition|;
operator|++
name|x
control|)
block|{
comment|// Signals must be added before other methods, to match moc.
name|QMap
argument_list|<
name|QByteArray
argument_list|,
name|Method
argument_list|>
modifier|&
name|map
init|=
operator|(
name|x
operator|==
literal|0
operator|)
condition|?
name|signals_
else|:
name|methods
decl_stmt|;
for|for
control|(
name|QMap
argument_list|<
name|QByteArray
argument_list|,
name|Method
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|map
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|map
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|Method
modifier|&
name|mm
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|int
name|argc
init|=
name|mm
operator|.
name|inputTypes
operator|.
name|size
argument_list|()
operator|+
name|qMax
argument_list|(
literal|0
argument_list|,
name|mm
operator|.
name|outputTypes
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|idata
index|[
name|offset
operator|++
index|]
operator|=
name|strings
operator|.
name|enter
argument_list|(
name|mm
operator|.
name|name
argument_list|)
expr_stmt|;
name|idata
index|[
name|offset
operator|++
index|]
operator|=
name|argc
expr_stmt|;
name|idata
index|[
name|offset
operator|++
index|]
operator|=
name|parametersOffset
expr_stmt|;
name|idata
index|[
name|offset
operator|++
index|]
operator|=
name|strings
operator|.
name|enter
argument_list|(
name|mm
operator|.
name|tag
argument_list|)
expr_stmt|;
name|idata
index|[
name|offset
operator|++
index|]
operator|=
name|mm
operator|.
name|flags
expr_stmt|;
comment|// Parameter types
for|for
control|(
name|int
name|i
init|=
operator|-
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|int
name|type
decl_stmt|;
name|QByteArray
name|typeName
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|// Return type
if|if
condition|(
operator|!
name|mm
operator|.
name|outputTypes
operator|.
name|isEmpty
argument_list|()
condition|)
name|type
operator|=
name|mm
operator|.
name|outputTypes
operator|.
name|first
argument_list|()
expr_stmt|;
else|else
name|type
operator|=
name|QMetaType
operator|::
name|Void
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|mm
operator|.
name|inputTypes
operator|.
name|size
argument_list|()
condition|)
block|{
name|type
operator|=
name|mm
operator|.
name|inputTypes
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|mm
operator|.
name|outputTypes
operator|.
name|size
argument_list|()
operator|>
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|mm
operator|.
name|outputTypes
operator|.
name|at
argument_list|(
name|i
operator|-
name|mm
operator|.
name|inputTypes
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// Output parameters are references; type id not available
name|typeName
operator|=
name|QMetaType
operator|::
name|typeName
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|typeName
operator|.
name|append
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|type
operator|!=
name|QMetaType
operator|::
name|UnknownType
argument_list|)
expr_stmt|;
name|int
name|typeInfo
decl_stmt|;
if|if
condition|(
operator|!
name|typeName
operator|.
name|isEmpty
argument_list|()
condition|)
name|typeInfo
operator|=
name|IsUnresolvedType
operator||
name|strings
operator|.
name|enter
argument_list|(
name|typeName
argument_list|)
expr_stmt|;
else|else
name|typeInfo
operator|=
name|type
expr_stmt|;
name|idata
index|[
name|parametersOffset
operator|++
index|]
operator|=
name|typeInfo
expr_stmt|;
block|}
comment|// Parameter names
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|idata
index|[
name|parametersOffset
operator|++
index|]
operator|=
name|strings
operator|.
name|enter
argument_list|(
name|mm
operator|.
name|parameterNames
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|idata
index|[
name|signatureOffset
operator|++
index|]
operator|=
name|typeidOffset
expr_stmt|;
name|idata
index|[
name|typeidOffset
operator|++
index|]
operator|=
name|mm
operator|.
name|inputTypes
operator|.
name|count
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|idata
operator|.
name|data
argument_list|()
operator|+
name|typeidOffset
argument_list|,
name|mm
operator|.
name|inputTypes
operator|.
name|data
argument_list|()
argument_list|,
name|mm
operator|.
name|inputTypes
operator|.
name|count
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|typeidOffset
operator|+=
name|mm
operator|.
name|inputTypes
operator|.
name|count
argument_list|()
expr_stmt|;
name|idata
index|[
name|signatureOffset
operator|++
index|]
operator|=
name|typeidOffset
expr_stmt|;
name|idata
index|[
name|typeidOffset
operator|++
index|]
operator|=
name|mm
operator|.
name|outputTypes
operator|.
name|count
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|idata
operator|.
name|data
argument_list|()
operator|+
name|typeidOffset
argument_list|,
name|mm
operator|.
name|outputTypes
operator|.
name|data
argument_list|()
argument_list|,
name|mm
operator|.
name|outputTypes
operator|.
name|count
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|typeidOffset
operator|+=
name|mm
operator|.
name|outputTypes
operator|.
name|count
argument_list|()
expr_stmt|;
block|}
block|}
name|Q_ASSERT
argument_list|(
name|offset
operator|==
name|header
operator|->
name|methodData
operator|+
name|header
operator|->
name|methodCount
operator|*
literal|5
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|parametersOffset
operator|=
name|header
operator|->
name|propertyData
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|signatureOffset
operator|==
name|header
operator|->
name|methodDBusData
operator|+
name|header
operator|->
name|methodCount
operator|*
name|intsPerMethod
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|typeidOffset
operator|==
name|idata
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|methodParametersDataSize
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|offset
operator|==
name|header
operator|->
name|propertyData
argument_list|)
expr_stmt|;
comment|// add each property
name|signatureOffset
operator|=
name|header
operator|->
name|propertyDBusData
expr_stmt|;
for|for
control|(
name|QMap
argument_list|<
name|QByteArray
argument_list|,
name|Property
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|properties
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|properties
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|Property
modifier|&
name|mp
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
comment|// form is name, typeinfo, flags
name|idata
index|[
name|offset
operator|++
index|]
operator|=
name|strings
operator|.
name|enter
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
comment|// name
name|Q_ASSERT
argument_list|(
name|mp
operator|.
name|type
operator|!=
name|QMetaType
operator|::
name|UnknownType
argument_list|)
expr_stmt|;
name|idata
index|[
name|offset
operator|++
index|]
operator|=
name|mp
operator|.
name|type
expr_stmt|;
name|idata
index|[
name|offset
operator|++
index|]
operator|=
name|mp
operator|.
name|flags
expr_stmt|;
name|idata
index|[
name|signatureOffset
operator|++
index|]
operator|=
name|strings
operator|.
name|enter
argument_list|(
name|mp
operator|.
name|signature
argument_list|)
expr_stmt|;
name|idata
index|[
name|signatureOffset
operator|++
index|]
operator|=
name|mp
operator|.
name|type
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|offset
operator|==
name|header
operator|->
name|propertyDBusData
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|signatureOffset
operator|==
name|header
operator|->
name|methodDBusData
argument_list|)
expr_stmt|;
name|char
modifier|*
name|string_data
init|=
operator|new
name|char
index|[
name|strings
operator|.
name|blobSize
argument_list|()
index|]
decl_stmt|;
name|strings
operator|.
name|writeBlob
argument_list|(
name|string_data
argument_list|)
expr_stmt|;
name|uint
modifier|*
name|uint_data
init|=
operator|new
name|uint
index|[
name|idata
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|uint_data
argument_list|,
name|idata
operator|.
name|data
argument_list|()
argument_list|,
name|idata
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|// put the metaobject together
name|obj
operator|->
name|d
operator|.
name|data
operator|=
name|uint_data
expr_stmt|;
name|obj
operator|->
name|d
operator|.
name|relatedMetaObjects
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|d
operator|.
name|static_metacall
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|d
operator|.
name|extradata
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|d
operator|.
name|stringdata
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|QByteArrayData
operator|*
argument_list|>
argument_list|(
name|string_data
argument_list|)
expr_stmt|;
name|obj
operator|->
name|d
operator|.
name|superdata
operator|=
operator|&
name|QDBusAbstractInterface
operator|::
name|staticMetaObject
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
unit|void QDBusMetaObjectGenerator::writeWithoutXml(const QString&interface) {
comment|// no XML definition
end_comment
begin_comment
unit|QString tmp(interface);     tmp.replace(QLatin1Char('.'), QLatin1String("::"));     QByteArray name(tmp.toLatin1());      QDBusMetaObjectPrivate *header = new QDBusMetaObjectPrivate;     memset(header, 0, sizeof *header);     header->revision = 1;
comment|// leave the rest with 0
end_comment
begin_endif
unit|char *stringdata = new char[name.length() + 1];     stringdata[name.length()] = '\0';          d.data = reinterpret_cast<uint*>(header);     d.relatedMetaObjects = 0;     d.static_metacall = 0;     d.extradata = 0;     d.stringdata = stringdata;     d.superdata =&QDBusAbstractInterface::staticMetaObject;     cached = false; }
endif|#
directive|endif
end_endif
begin_comment
comment|/////////
end_comment
begin_comment
comment|// class QDBusMetaObject
end_comment
begin_function
DECL|function|createMetaObject
name|QDBusMetaObject
modifier|*
name|QDBusMetaObject
operator|::
name|createMetaObject
parameter_list|(
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
specifier|const
name|QString
modifier|&
name|xml
parameter_list|,
name|QHash
argument_list|<
name|QString
argument_list|,
name|QDBusMetaObject
modifier|*
argument_list|>
modifier|&
name|cache
parameter_list|,
name|QDBusError
modifier|&
name|error
parameter_list|)
block|{
name|error
operator|=
name|QDBusError
argument_list|()
expr_stmt|;
name|QDBusIntrospection
operator|::
name|Interfaces
name|parsed
init|=
name|QDBusIntrospection
operator|::
name|parseInterfaces
argument_list|(
name|xml
argument_list|)
decl_stmt|;
name|QDBusMetaObject
modifier|*
name|we
init|=
literal|0
decl_stmt|;
name|QDBusIntrospection
operator|::
name|Interfaces
operator|::
name|ConstIterator
name|it
init|=
name|parsed
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|QDBusIntrospection
operator|::
name|Interfaces
operator|::
name|ConstIterator
name|end
init|=
name|parsed
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
comment|// check if it's in the cache
name|bool
name|us
init|=
name|it
operator|.
name|key
argument_list|()
operator|==
name|interface
decl_stmt|;
name|QDBusMetaObject
modifier|*
name|obj
init|=
name|cache
operator|.
name|value
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
operator|&&
operator|(
name|us
operator|||
operator|!
name|interface
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"local."
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|// not in cache; create
name|obj
operator|=
operator|new
name|QDBusMetaObject
expr_stmt|;
name|QDBusMetaObjectGenerator
name|generator
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|generator
operator|.
name|write
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|obj
operator|->
name|cached
operator|=
operator|!
name|it
operator|.
name|key
argument_list|()
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"local."
argument_list|)
argument_list|)
operator|)
condition|)
comment|// cache it
name|cache
operator|.
name|insert
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|obj
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|us
condition|)
operator|delete
name|obj
expr_stmt|;
block|}
if|if
condition|(
name|us
condition|)
comment|// it's us
name|we
operator|=
name|obj
expr_stmt|;
block|}
if|if
condition|(
name|we
condition|)
return|return
name|we
return|;
comment|// still nothing?
if|if
condition|(
name|parsed
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// object didn't return introspection
name|we
operator|=
operator|new
name|QDBusMetaObject
expr_stmt|;
name|QDBusMetaObjectGenerator
name|generator
argument_list|(
name|interface
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|generator
operator|.
name|write
argument_list|(
name|we
argument_list|)
expr_stmt|;
name|we
operator|->
name|cached
operator|=
literal|false
expr_stmt|;
return|return
name|we
return|;
block|}
elseif|else
if|if
condition|(
name|interface
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// merge all interfaces
name|it
operator|=
name|parsed
operator|.
name|constBegin
argument_list|()
expr_stmt|;
name|QDBusIntrospection
operator|::
name|Interface
name|merged
init|=
operator|*
name|it
operator|.
name|value
argument_list|()
operator|.
name|constData
argument_list|()
decl_stmt|;
for|for
control|(
operator|++
name|it
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|merged
operator|.
name|annotations
operator|.
name|unite
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|annotations
argument_list|)
expr_stmt|;
name|merged
operator|.
name|methods
operator|.
name|unite
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|methods
argument_list|)
expr_stmt|;
name|merged
operator|.
name|signals_
operator|.
name|unite
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|signals_
argument_list|)
expr_stmt|;
name|merged
operator|.
name|properties
operator|.
name|unite
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|properties
argument_list|)
expr_stmt|;
block|}
name|merged
operator|.
name|name
operator|=
name|QLatin1String
argument_list|(
literal|"local.Merged"
argument_list|)
expr_stmt|;
name|merged
operator|.
name|introspection
operator|.
name|clear
argument_list|()
expr_stmt|;
name|we
operator|=
operator|new
name|QDBusMetaObject
expr_stmt|;
name|QDBusMetaObjectGenerator
name|generator
argument_list|(
name|merged
operator|.
name|name
argument_list|,
operator|&
name|merged
argument_list|)
decl_stmt|;
name|generator
operator|.
name|write
argument_list|(
name|we
argument_list|)
expr_stmt|;
name|we
operator|->
name|cached
operator|=
literal|false
expr_stmt|;
return|return
name|we
return|;
block|}
comment|// mark as an error
name|error
operator|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|UnknownInterface
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Interface '%1' was not found"
argument_list|)
operator|.
name|arg
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_constructor
DECL|function|QDBusMetaObject
name|QDBusMetaObject
operator|::
name|QDBusMetaObject
parameter_list|()
block|{ }
end_constructor
begin_function
DECL|function|priv
specifier|static
specifier|inline
specifier|const
name|QDBusMetaObjectPrivate
modifier|*
name|priv
parameter_list|(
specifier|const
name|uint
modifier|*
name|data
parameter_list|)
block|{
return|return
cast|reinterpret_cast
argument_list|<
specifier|const
name|QDBusMetaObjectPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|inputTypesForMethod
specifier|const
name|int
modifier|*
name|QDBusMetaObject
operator|::
name|inputTypesForMethod
parameter_list|(
name|int
name|id
parameter_list|)
specifier|const
block|{
comment|//id -= methodOffset();
if|if
condition|(
name|id
operator|>=
literal|0
operator|&&
name|id
operator|<
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodCount
condition|)
block|{
name|int
name|handle
init|=
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodDBusData
operator|+
name|id
operator|*
name|intsPerMethod
decl_stmt|;
return|return
cast|reinterpret_cast
argument_list|<
specifier|const
name|int
operator|*
argument_list|>
argument_list|(
name|d
operator|.
name|data
operator|+
name|d
operator|.
name|data
index|[
name|handle
index|]
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|outputTypesForMethod
specifier|const
name|int
modifier|*
name|QDBusMetaObject
operator|::
name|outputTypesForMethod
parameter_list|(
name|int
name|id
parameter_list|)
specifier|const
block|{
comment|//id -= methodOffset();
if|if
condition|(
name|id
operator|>=
literal|0
operator|&&
name|id
operator|<
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodCount
condition|)
block|{
name|int
name|handle
init|=
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodDBusData
operator|+
name|id
operator|*
name|intsPerMethod
decl_stmt|;
return|return
cast|reinterpret_cast
argument_list|<
specifier|const
name|int
operator|*
argument_list|>
argument_list|(
name|d
operator|.
name|data
operator|+
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|1
index|]
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|propertyMetaType
name|int
name|QDBusMetaObject
operator|::
name|propertyMetaType
parameter_list|(
name|int
name|id
parameter_list|)
specifier|const
block|{
comment|//id -= propertyOffset();
if|if
condition|(
name|id
operator|>=
literal|0
operator|&&
name|id
operator|<
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyCount
condition|)
block|{
name|int
name|handle
init|=
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyDBusData
operator|+
name|id
operator|*
name|intsPerProperty
decl_stmt|;
return|return
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|1
index|]
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DBUS
end_comment
end_unit
