begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtDBus module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdbusutil_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbus_symbols_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qstringlist.h>
end_include
begin_include
include|#
directive|include
file|"qdbusargument.h"
end_include
begin_include
include|#
directive|include
file|"qdbusunixfiledescriptor.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DBUS
end_ifndef
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|isValidCharacterNoDash
specifier|static
specifier|inline
name|bool
name|isValidCharacterNoDash
parameter_list|(
name|QChar
name|c
parameter_list|)
block|{
specifier|register
name|ushort
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
return|return
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|u
operator|==
literal|'_'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isValidCharacter
specifier|static
specifier|inline
name|bool
name|isValidCharacter
parameter_list|(
name|QChar
name|c
parameter_list|)
block|{
specifier|register
name|ushort
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
return|return
operator|(
name|u
operator|>=
literal|'a'
operator|&&
name|u
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'A'
operator|&&
name|u
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|u
operator|==
literal|'_'
operator|)
operator|||
operator|(
name|u
operator|==
literal|'-'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isValidNumber
specifier|static
specifier|inline
name|bool
name|isValidNumber
parameter_list|(
name|QChar
name|c
parameter_list|)
block|{
specifier|register
name|ushort
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
return|return
operator|(
name|u
operator|>=
literal|'0'
operator|&&
name|u
operator|<=
literal|'9'
operator|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_function_decl
specifier|static
name|bool
name|argToString
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|arg
parameter_list|,
name|QString
modifier|&
name|out
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|variantToString
specifier|static
name|bool
name|variantToString
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|arg
parameter_list|,
name|QString
modifier|&
name|out
parameter_list|)
block|{
name|int
name|argType
init|=
name|arg
operator|.
name|userType
argument_list|()
decl_stmt|;
if|if
condition|(
name|argType
operator|==
name|QVariant
operator|::
name|StringList
condition|)
block|{
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|QStringList
name|list
init|=
name|arg
operator|.
name|toStringList
argument_list|()
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|item
decl|,
name|list
control|)
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
operator|+
name|item
operator|+
name|QLatin1String
argument_list|(
literal|"\", "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argType
operator|==
name|QVariant
operator|::
name|ByteArray
condition|)
block|{
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|QByteArray
name|list
init|=
name|arg
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|out
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|+=
name|QLatin1String
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argType
operator|==
name|QVariant
operator|::
name|List
condition|)
block|{
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QVariant
argument_list|>
name|list
init|=
name|arg
operator|.
name|toList
argument_list|()
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QVariant
modifier|&
name|item
decl|,
name|list
control|)
block|{
if|if
condition|(
operator|!
name|variantToString
argument_list|(
name|item
argument_list|,
name|out
argument_list|)
condition|)
return|return
literal|false
return|;
name|out
operator|+=
name|QLatin1String
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
name|out
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argType
operator|==
name|QMetaType
operator|::
name|Char
operator|||
name|argType
operator|==
name|QMetaType
operator|::
name|Short
operator|||
name|argType
operator|==
name|QMetaType
operator|::
name|Int
operator|||
name|argType
operator|==
name|QMetaType
operator|::
name|Long
operator|||
name|argType
operator|==
name|QMetaType
operator|::
name|LongLong
condition|)
block|{
name|out
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|arg
operator|.
name|toLongLong
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argType
operator|==
name|QMetaType
operator|::
name|UChar
operator|||
name|argType
operator|==
name|QMetaType
operator|::
name|UShort
operator|||
name|argType
operator|==
name|QMetaType
operator|::
name|UInt
operator|||
name|argType
operator|==
name|QMetaType
operator|::
name|ULong
operator|||
name|argType
operator|==
name|QMetaType
operator|::
name|ULongLong
condition|)
block|{
name|out
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|arg
operator|.
name|toULongLong
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argType
operator|==
name|QMetaType
operator|::
name|Double
condition|)
block|{
name|out
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|arg
operator|.
name|toDouble
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argType
operator|==
name|QMetaType
operator|::
name|Bool
condition|)
block|{
name|out
operator|+=
name|QLatin1String
argument_list|(
name|arg
operator|.
name|toBool
argument_list|()
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argType
operator|==
name|qMetaTypeId
argument_list|<
name|QDBusArgument
argument_list|>
argument_list|()
condition|)
block|{
name|argToString
argument_list|(
name|qvariant_cast
argument_list|<
name|QDBusArgument
argument_list|>
argument_list|(
name|arg
argument_list|)
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argType
operator|==
name|qMetaTypeId
argument_list|<
name|QDBusObjectPath
argument_list|>
argument_list|()
condition|)
block|{
specifier|const
name|QString
name|path
init|=
name|qvariant_cast
argument_list|<
name|QDBusObjectPath
argument_list|>
argument_list|(
name|arg
argument_list|)
operator|.
name|path
argument_list|()
decl_stmt|;
name|out
operator|+=
name|QLatin1String
argument_list|(
literal|"[ObjectPath: "
argument_list|)
expr_stmt|;
name|out
operator|+=
name|path
expr_stmt|;
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argType
operator|==
name|qMetaTypeId
argument_list|<
name|QDBusSignature
argument_list|>
argument_list|()
condition|)
block|{
name|out
operator|+=
name|QLatin1String
argument_list|(
literal|"[Signature: "
argument_list|)
operator|+
name|qvariant_cast
argument_list|<
name|QDBusSignature
argument_list|>
argument_list|(
name|arg
argument_list|)
operator|.
name|signature
argument_list|()
expr_stmt|;
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argType
operator|==
name|qMetaTypeId
argument_list|<
name|QDBusUnixFileDescriptor
argument_list|>
argument_list|()
condition|)
block|{
name|out
operator|+=
name|QLatin1String
argument_list|(
literal|"[Unix FD: "
argument_list|)
expr_stmt|;
name|out
operator|+=
name|QLatin1String
argument_list|(
name|qvariant_cast
argument_list|<
name|QDBusUnixFileDescriptor
argument_list|>
argument_list|(
name|arg
argument_list|)
operator|.
name|isValid
argument_list|()
condition|?
literal|"valid"
else|:
literal|"not valid"
argument_list|)
expr_stmt|;
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argType
operator|==
name|qMetaTypeId
argument_list|<
name|QDBusVariant
argument_list|>
argument_list|()
condition|)
block|{
specifier|const
name|QVariant
name|v
init|=
name|qvariant_cast
argument_list|<
name|QDBusVariant
argument_list|>
argument_list|(
name|arg
argument_list|)
operator|.
name|variant
argument_list|()
decl_stmt|;
name|out
operator|+=
name|QLatin1String
argument_list|(
literal|"[Variant"
argument_list|)
expr_stmt|;
name|int
name|vUserType
init|=
name|v
operator|.
name|userType
argument_list|()
decl_stmt|;
if|if
condition|(
name|vUserType
operator|!=
name|qMetaTypeId
argument_list|<
name|QDBusVariant
argument_list|>
argument_list|()
operator|&&
name|vUserType
operator|!=
name|qMetaTypeId
argument_list|<
name|QDBusSignature
argument_list|>
argument_list|()
operator|&&
name|vUserType
operator|!=
name|qMetaTypeId
argument_list|<
name|QDBusObjectPath
argument_list|>
argument_list|()
operator|&&
name|vUserType
operator|!=
name|qMetaTypeId
argument_list|<
name|QDBusArgument
argument_list|>
argument_list|()
condition|)
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'('
argument_list|)
operator|+
name|QLatin1String
argument_list|(
name|v
operator|.
name|typeName
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|out
operator|+=
name|QLatin1String
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|variantToString
argument_list|(
name|v
argument_list|,
name|out
argument_list|)
condition|)
return|return
literal|false
return|;
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|.
name|canConvert
argument_list|(
name|QVariant
operator|::
name|String
argument_list|)
condition|)
block|{
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
operator|+
name|arg
operator|.
name|toString
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|out
operator|+=
name|QLatin1String
argument_list|(
name|arg
operator|.
name|typeName
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|argToString
name|bool
name|argToString
parameter_list|(
specifier|const
name|QDBusArgument
modifier|&
name|busArg
parameter_list|,
name|QString
modifier|&
name|out
parameter_list|)
block|{
name|QString
name|busSig
init|=
name|busArg
operator|.
name|currentSignature
argument_list|()
decl_stmt|;
name|bool
name|doIterate
init|=
literal|false
decl_stmt|;
name|QDBusArgument
operator|::
name|ElementType
name|elementType
init|=
name|busArg
operator|.
name|currentType
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementType
operator|!=
name|QDBusArgument
operator|::
name|BasicType
operator|&&
name|elementType
operator|!=
name|QDBusArgument
operator|::
name|VariantType
operator|&&
name|elementType
operator|!=
name|QDBusArgument
operator|::
name|MapEntryType
condition|)
name|out
operator|+=
name|QLatin1String
argument_list|(
literal|"[Argument: "
argument_list|)
operator|+
name|busSig
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|elementType
condition|)
block|{
case|case
name|QDBusArgument
operator|::
name|BasicType
case|:
case|case
name|QDBusArgument
operator|::
name|VariantType
case|:
if|if
condition|(
operator|!
name|variantToString
argument_list|(
name|busArg
operator|.
name|asVariant
argument_list|()
argument_list|,
name|out
argument_list|)
condition|)
return|return
literal|false
return|;
break|break;
case|case
name|QDBusArgument
operator|::
name|StructureType
case|:
name|busArg
operator|.
name|beginStructure
argument_list|()
expr_stmt|;
name|doIterate
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|QDBusArgument
operator|::
name|ArrayType
case|:
name|busArg
operator|.
name|beginArray
argument_list|()
expr_stmt|;
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|doIterate
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|QDBusArgument
operator|::
name|MapType
case|:
name|busArg
operator|.
name|beginMap
argument_list|()
expr_stmt|;
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|doIterate
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|QDBusArgument
operator|::
name|MapEntryType
case|:
name|busArg
operator|.
name|beginMapEntry
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|variantToString
argument_list|(
name|busArg
operator|.
name|asVariant
argument_list|()
argument_list|,
name|out
argument_list|)
condition|)
return|return
literal|false
return|;
name|out
operator|+=
name|QLatin1String
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argToString
argument_list|(
name|busArg
argument_list|,
name|out
argument_list|)
condition|)
return|return
literal|false
return|;
name|busArg
operator|.
name|endMapEntry
argument_list|()
expr_stmt|;
break|break;
case|case
name|QDBusArgument
operator|::
name|UnknownType
case|:
default|default:
name|out
operator|+=
name|QLatin1String
argument_list|(
literal|"<ERROR - Unknown Type>"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|doIterate
operator|&&
operator|!
name|busArg
operator|.
name|atEnd
argument_list|()
condition|)
block|{
while|while
condition|(
operator|!
name|busArg
operator|.
name|atEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|argToString
argument_list|(
name|busArg
argument_list|,
name|out
argument_list|)
condition|)
return|return
literal|false
return|;
name|out
operator|+=
name|QLatin1String
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|elementType
condition|)
block|{
case|case
name|QDBusArgument
operator|::
name|BasicType
case|:
case|case
name|QDBusArgument
operator|::
name|VariantType
case|:
case|case
name|QDBusArgument
operator|::
name|UnknownType
case|:
case|case
name|QDBusArgument
operator|::
name|MapEntryType
case|:
comment|// nothing to do
break|break;
case|case
name|QDBusArgument
operator|::
name|StructureType
case|:
name|busArg
operator|.
name|endStructure
argument_list|()
expr_stmt|;
break|break;
case|case
name|QDBusArgument
operator|::
name|ArrayType
case|:
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|busArg
operator|.
name|endArray
argument_list|()
expr_stmt|;
break|break;
case|case
name|QDBusArgument
operator|::
name|MapType
case|:
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|busArg
operator|.
name|endMap
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|elementType
operator|!=
name|QDBusArgument
operator|::
name|BasicType
operator|&&
name|elementType
operator|!=
name|QDBusArgument
operator|::
name|VariantType
operator|&&
name|elementType
operator|!=
name|QDBusArgument
operator|::
name|MapEntryType
condition|)
name|out
operator|+=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//------- D-Bus Types --------
end_comment
begin_decl_stmt
DECL|variable|oneLetterTypes
specifier|static
specifier|const
name|char
name|oneLetterTypes
index|[]
init|=
literal|"vsogybnqiuxtdh"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|basicTypes
specifier|static
specifier|const
name|char
name|basicTypes
index|[]
init|=
literal|"sogybnqiuxtdh"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fixedTypes
specifier|static
specifier|const
name|char
name|fixedTypes
index|[]
init|=
literal|"ybnqiuxtdh"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|isBasicType
specifier|static
name|bool
name|isBasicType
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|!=
name|DBUS_TYPE_INVALID
operator|&&
name|strchr
argument_list|(
name|basicTypes
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|isFixedType
specifier|static
name|bool
name|isFixedType
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|!=
name|DBUS_TYPE_INVALID
operator|&&
name|strchr
argument_list|(
name|fixedTypes
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function
begin_comment
comment|// Returns a pointer to one-past-end of this type if it's valid;
end_comment
begin_comment
comment|// returns NULL if it isn't valid.
end_comment
begin_function
DECL|function|validateSingleType
specifier|static
specifier|const
name|char
modifier|*
name|validateSingleType
parameter_list|(
specifier|const
name|char
modifier|*
name|signature
parameter_list|)
block|{
specifier|register
name|char
name|c
init|=
operator|*
name|signature
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|DBUS_TYPE_INVALID
condition|)
return|return
literal|0
return|;
comment|// is it one of the one-letter types?
if|if
condition|(
name|strchr
argument_list|(
name|oneLetterTypes
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|signature
operator|+
literal|1
return|;
comment|// is it an array?
if|if
condition|(
name|c
operator|==
name|DBUS_TYPE_ARRAY
condition|)
block|{
comment|// then it's valid if the next type is valid
comment|// or if it's a dict-entry
name|c
operator|=
operator|*
operator|++
name|signature
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|DBUS_DICT_ENTRY_BEGIN_CHAR
condition|)
block|{
comment|// beginning of a dictionary entry
comment|// a dictionary entry has a key which is of basic types
comment|// and a free value
name|c
operator|=
operator|*
operator|++
name|signature
expr_stmt|;
if|if
condition|(
operator|!
name|isBasicType
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
name|signature
operator|=
name|validateSingleType
argument_list|(
name|signature
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|signature
operator|&&
operator|*
name|signature
operator|==
name|DBUS_DICT_ENTRY_END_CHAR
condition|?
name|signature
operator|+
literal|1
else|:
literal|0
return|;
block|}
return|return
name|validateSingleType
argument_list|(
name|signature
argument_list|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|DBUS_STRUCT_BEGIN_CHAR
condition|)
block|{
comment|// beginning of a struct
operator|++
name|signature
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|signature
operator|=
name|validateSingleType
argument_list|(
name|signature
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|signature
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|signature
operator|==
name|DBUS_STRUCT_END_CHAR
condition|)
return|return
name|signature
operator|+
literal|1
return|;
block|}
block|}
comment|// invalid/unknown type
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \namespace QDBusUtil     \inmodule QtDBus     \internal      \brief The QDBusUtil namespace contains a few functions that are of general use when     dealing with D-Bus strings. */
end_comment
begin_namespace
DECL|namespace|QDBusUtil
namespace|namespace
name|QDBusUtil
block|{
comment|/*!         \internal         \since 4.5         Dumps the contents of a Qt D-Bus argument from \a arg into a string.     */
DECL|function|argumentToString
name|QString
name|argumentToString
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|arg
parameter_list|)
block|{
name|QString
name|out
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|variantToString
argument_list|(
name|arg
argument_list|,
name|out
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|out
return|;
block|}
comment|/*!         \internal         \fn bool QDBusUtil::isValidPartOfObjectPath(const QString&part)         See QDBusUtil::isValidObjectPath     */
DECL|function|isValidPartOfObjectPath
name|bool
name|isValidPartOfObjectPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|part
parameter_list|)
block|{
if|if
condition|(
name|part
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// can't be valid if it's empty
specifier|const
name|QChar
modifier|*
name|c
init|=
name|part
operator|.
name|unicode
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|part
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|isValidCharacterNoDash
argument_list|(
name|c
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
comment|/*!         \fn bool QDBusUtil::isValidInterfaceName(const QString&ifaceName)         Returns true if this is \a ifaceName is a valid interface name.          Valid interface names must:         \list           \li not be empty           \li not exceed 255 characters in length           \li be composed of dot-separated string components that contain only ASCII letters, digits              and the underscore ("_") character           \li contain at least two such components         \endlist     */
DECL|function|isValidInterfaceName
name|bool
name|isValidInterfaceName
parameter_list|(
specifier|const
name|QString
modifier|&
name|ifaceName
parameter_list|)
block|{
if|if
condition|(
name|ifaceName
operator|.
name|isEmpty
argument_list|()
operator|||
name|ifaceName
operator|.
name|length
argument_list|()
operator|>
name|DBUS_MAXIMUM_NAME_LENGTH
condition|)
return|return
literal|false
return|;
name|QStringList
name|parts
init|=
name|ifaceName
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|<
literal|2
condition|)
return|return
literal|false
return|;
comment|// at least two parts
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parts
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|isValidMemberName
argument_list|(
name|parts
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
comment|/*!         \fn bool QDBusUtil::isValidUniqueConnectionName(const QString&connName)         Returns true if \a connName is a valid unique connection name.          Unique connection names start with a colon (":") and are followed by a list of dot-separated         components composed of ASCII letters, digits, the hyphen or the underscore ("_") character.     */
DECL|function|isValidUniqueConnectionName
name|bool
name|isValidUniqueConnectionName
parameter_list|(
specifier|const
name|QString
modifier|&
name|connName
parameter_list|)
block|{
if|if
condition|(
name|connName
operator|.
name|isEmpty
argument_list|()
operator|||
name|connName
operator|.
name|length
argument_list|()
operator|>
name|DBUS_MAXIMUM_NAME_LENGTH
operator|||
operator|!
name|connName
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
name|QStringList
name|parts
init|=
name|connName
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|<
literal|1
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parts
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
modifier|&
name|part
init|=
name|parts
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
specifier|const
name|QChar
modifier|*
name|c
init|=
name|part
operator|.
name|unicode
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|part
operator|.
name|length
argument_list|()
condition|;
operator|++
name|j
control|)
if|if
condition|(
operator|!
name|isValidCharacter
argument_list|(
name|c
index|[
name|j
index|]
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/*!         \fn bool QDBusUtil::isValidBusName(const QString&busName)         Returns true if \a busName is a valid bus name.          A valid bus name is either a valid unique connection name or follows the rules:         \list           \li is not empty           \li does not exceed 255 characters in length           \li be composed of dot-separated string components that contain only ASCII letters, digits,              hyphens or underscores ("_"), but don't start with a digit           \li contains at least two such elements         \endlist          \sa isValidUniqueConnectionName()     */
DECL|function|isValidBusName
name|bool
name|isValidBusName
parameter_list|(
specifier|const
name|QString
modifier|&
name|busName
parameter_list|)
block|{
if|if
condition|(
name|busName
operator|.
name|isEmpty
argument_list|()
operator|||
name|busName
operator|.
name|length
argument_list|()
operator|>
name|DBUS_MAXIMUM_NAME_LENGTH
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|busName
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
return|return
name|isValidUniqueConnectionName
argument_list|(
name|busName
argument_list|)
return|;
name|QStringList
name|parts
init|=
name|busName
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|<
literal|1
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parts
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
modifier|&
name|part
init|=
name|parts
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
specifier|const
name|QChar
modifier|*
name|c
init|=
name|part
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|isValidNumber
argument_list|(
name|c
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|part
operator|.
name|length
argument_list|()
condition|;
operator|++
name|j
control|)
if|if
condition|(
operator|!
name|isValidCharacter
argument_list|(
name|c
index|[
name|j
index|]
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/*!         \fn bool QDBusUtil::isValidMemberName(const QString&memberName)         Returns true if \a memberName is a valid member name. A valid member name does not exceed         255 characters in length, is not empty, is composed only of ASCII letters, digits and         underscores, but does not start with a digit.     */
DECL|function|isValidMemberName
name|bool
name|isValidMemberName
parameter_list|(
specifier|const
name|QString
modifier|&
name|memberName
parameter_list|)
block|{
if|if
condition|(
name|memberName
operator|.
name|isEmpty
argument_list|()
operator|||
name|memberName
operator|.
name|length
argument_list|()
operator|>
name|DBUS_MAXIMUM_NAME_LENGTH
condition|)
return|return
literal|false
return|;
specifier|const
name|QChar
modifier|*
name|c
init|=
name|memberName
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|isValidNumber
argument_list|(
name|c
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|memberName
operator|.
name|length
argument_list|()
condition|;
operator|++
name|j
control|)
if|if
condition|(
operator|!
name|isValidCharacterNoDash
argument_list|(
name|c
index|[
name|j
index|]
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
comment|/*!         \fn bool QDBusUtil::isValidErrorName(const QString&errorName)         Returns true if \a errorName is a valid error name. Valid error names are valid interface         names and vice-versa, so this function is actually an alias for isValidInterfaceName.     */
DECL|function|isValidErrorName
name|bool
name|isValidErrorName
parameter_list|(
specifier|const
name|QString
modifier|&
name|errorName
parameter_list|)
block|{
return|return
name|isValidInterfaceName
argument_list|(
name|errorName
argument_list|)
return|;
block|}
comment|/*!         \fn bool QDBusUtil::isValidObjectPath(const QString&path)         Returns true if \a path is valid object path.          Valid object paths follow the rules:         \list           \li start with the slash character ("/")           \li do not end in a slash, unless the path is just the initial slash           \li do not contain any two slashes in sequence           \li contain slash-separated parts, each of which is composed of ASCII letters, digits and              underscores ("_")         \endlist     */
DECL|function|isValidObjectPath
name|bool
name|isValidObjectPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|==
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|path
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|||
name|path
operator|.
name|indexOf
argument_list|(
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|path
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
name|QStringList
name|parts
init|=
name|path
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|parts
operator|.
name|count
argument_list|()
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|parts
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
comment|// it starts with /, so we get an empty first part
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parts
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|isValidPartOfObjectPath
argument_list|(
name|parts
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
comment|/*!         \fn bool QDBusUtil::isValidBasicType(int type)         Returns true if \a c is a valid, basic D-Bus type.      */
DECL|function|isValidBasicType
name|bool
name|isValidBasicType
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|isBasicType
argument_list|(
name|c
argument_list|)
return|;
block|}
comment|/*!         \fn bool QDBusUtil::isValidFixedType(int type)         Returns true if \a c is a valid, fixed D-Bus type.      */
DECL|function|isValidFixedType
name|bool
name|isValidFixedType
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|isFixedType
argument_list|(
name|c
argument_list|)
return|;
block|}
comment|/*!         \fn bool QDBusUtil::isValidSignature(const QString&signature)         Returns true if \a signature is a valid D-Bus type signature for one or more types.         This function returns true if it can all of \a signature into valid, individual types and no         characters remain in \a signature.          \sa isValidSingleSignature()     */
DECL|function|isValidSignature
name|bool
name|isValidSignature
parameter_list|(
specifier|const
name|QString
modifier|&
name|signature
parameter_list|)
block|{
name|QByteArray
name|ba
init|=
name|signature
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
init|=
name|ba
operator|.
name|constData
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|data
operator|=
name|validateSingleType
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|*
name|data
operator|==
literal|'\0'
condition|)
return|return
literal|true
return|;
block|}
block|}
comment|/*!         \fn bool QDBusUtil::isValidSingleSignature(const QString&signature)         Returns true if \a signature is a valid D-Bus type signature for exactly one full type. This         function tries to convert the type signature into a D-Bus type and, if it succeeds and no         characters remain in the signature, it returns true.     */
DECL|function|isValidSingleSignature
name|bool
name|isValidSingleSignature
parameter_list|(
specifier|const
name|QString
modifier|&
name|signature
parameter_list|)
block|{
name|QByteArray
name|ba
init|=
name|signature
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
init|=
name|validateSingleType
argument_list|(
name|ba
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|data
operator|&&
operator|*
name|data
operator|==
literal|'\0'
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace QDBusUtil
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DBUS
end_comment
end_unit
