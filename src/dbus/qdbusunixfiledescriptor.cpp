begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtDBus module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdbusunixfiledescriptor.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_include
include|#
directive|include
file|<private/qcore_unix_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DBUS
end_ifndef
begin_comment
comment|/*!     \class QDBusUnixFileDescriptor     \inmodule QtDBus     \ingroup shared     \since 4.8      \brief The QDBusUnixFileDescriptor class holds one Unix file descriptor.      The QDBusUnixFileDescriptor class is used to hold one Unix file     descriptor for use with the Qt D-Bus module. This allows applications to     send and receive Unix file descriptors over the D-Bus connection, mapping     automatically to the D-Bus type 'h'.      Objects of type QDBusUnixFileDescriptors can be used also as parameters     in signals and slots that get exported to D-Bus by registering with     QDBusConnection::registerObject.      QDBusUnixFileDescriptor does not take ownership of the file descriptor.     Instead, it will use the Unix system call \c dup(2) to make a copy of the     file descriptor. This file descriptor belongs to the     QDBusUnixFileDescriptor object and should not be stored or closed by the     user. Instead, you should make your own copy if you need that.      \section2 Availability      Unix file descriptor passing is not available in all D-Bus connections.     This feature is present with D-Bus library and bus daemon version 1.4 and     upwards on Unix systems. Qt D-Bus automatically enables the feature if such     a version was found at compile-time and run-time.      To verify that your connection does support passing file descriptors,     check if the QDBusConnection::UnixFileDescriptorPassing capability is set     with QDBusConnection::connectionCapabilities(). If the flag is not     active, then you will not be able to make calls to methods that have     QDBusUnixFileDescriptor as arguments or even embed such a type in a     variant. You will also not receive calls containing that type.      Note also that remote applications may not have support for Unix file     descriptor passing. If you make a D-Bus to a remote application that     cannot receive such a type, you will receive an error reply. If you try     to send a signal containing a D-Bus file descriptor or return one from a     method call, the message will be silently dropped.      Even if the feature is not available, QDBusUnixFileDescriptor will     continue to operate, so code need not have compile-time checks for the     availability of this feature.      On non-Unix systems, QDBusUnixFileDescriptor will always report an     invalid state and QDBusUnixFileDescriptor::isSupported() will return     false.      \sa QDBusConnection::ConnectionCapabilities, QDBusConnection::connectionCapabilities() */
end_comment
begin_comment
comment|/*!     \typedef QDBusUnixFileDescriptor::Data     \internal */
end_comment
begin_comment
comment|/*!     \variable QDBusUnixFileDescriptor::d     \internal */
end_comment
begin_class
DECL|class|QDBusUnixFileDescriptorPrivate
class|class
name|QDBusUnixFileDescriptorPrivate
super|:
specifier|public
name|QSharedData
block|{
public|public:
DECL|function|QDBusUnixFileDescriptorPrivate
name|QDBusUnixFileDescriptorPrivate
parameter_list|()
member_init_list|:
name|fd
argument_list|(
operator|-
literal|1
argument_list|)
block|{ }
DECL|function|QDBusUnixFileDescriptorPrivate
name|QDBusUnixFileDescriptorPrivate
parameter_list|(
specifier|const
name|QDBusUnixFileDescriptorPrivate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|QSharedData
argument_list|(
name|other
argument_list|)
member_init_list|,
name|fd
argument_list|(
operator|-
literal|1
argument_list|)
block|{  }
name|~
name|QDBusUnixFileDescriptorPrivate
parameter_list|()
destructor_decl|;
DECL|member|fd
name|QAtomicInt
name|fd
decl_stmt|;
block|}
class|;
end_class
begin_destructor
template|template
parameter_list|<>
specifier|inline
DECL|function|~QExplicitlySharedDataPointer
name|QExplicitlySharedDataPointer
argument_list|<
name|QDBusUnixFileDescriptorPrivate
argument_list|>
operator|::
name|~
name|QExplicitlySharedDataPointer
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Constructs a QDBusUnixFileDescriptor without a wrapped file descriptor.     This is equivalent to constructing the object with an invalid file     descriptor (like -1).      \sa fileDescriptor(), isValid() */
end_comment
begin_constructor
DECL|function|QDBusUnixFileDescriptor
name|QDBusUnixFileDescriptor
operator|::
name|QDBusUnixFileDescriptor
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QDBusUnixFileDescriptor object by copying the \a     fileDescriptor parameter. The original file descriptor is not touched and     must be closed by the user.      Note that the value returned by fileDescriptor() will be different from     the \a fileDescriptor parameter passed.      If the \a fileDescriptor parameter is not valid, isValid() will return     false and fileDescriptor() will return -1.      \sa setFileDescriptor(), fileDescriptor() */
end_comment
begin_constructor
DECL|function|QDBusUnixFileDescriptor
name|QDBusUnixFileDescriptor
operator|::
name|QDBusUnixFileDescriptor
parameter_list|(
name|int
name|fileDescriptor
parameter_list|)
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
name|fileDescriptor
operator|!=
operator|-
literal|1
condition|)
name|setFileDescriptor
argument_list|(
name|fileDescriptor
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QDBusUnixFileDescriptor object by copying \a other. */
end_comment
begin_constructor
DECL|function|QDBusUnixFileDescriptor
name|QDBusUnixFileDescriptor
operator|::
name|QDBusUnixFileDescriptor
parameter_list|(
specifier|const
name|QDBusUnixFileDescriptor
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Copies the Unix file descriptor from the \a other QDBusUnixFileDescriptor     object. If the current object contained a file descriptor, it will be     properly disposed of before. */
end_comment
begin_function
DECL|function|operator =
name|QDBusUnixFileDescriptor
modifier|&
name|QDBusUnixFileDescriptor
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDBusUnixFileDescriptor
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|!=
operator|&
name|other
condition|)
name|d
operator|.
name|operator
name|=
parameter_list|(
name|other
operator|.
name|d
parameter_list|)
function_decl|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys this QDBusUnixFileDescriptor object and disposes of the Unix file descriptor that it contained. */
end_comment
begin_destructor
DECL|function|~QDBusUnixFileDescriptor
name|QDBusUnixFileDescriptor
operator|::
name|~
name|QDBusUnixFileDescriptor
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \fn void QDBusUnixFileDescriptor::swap(QDBusUnixFileDescriptor&other)     \since 5.0      Swaps this file descriptor instance with \a other. This function     is very fast and never fails. */
end_comment
begin_comment
comment|/*!     Returns \c true if this Unix file descriptor is valid. A valid Unix file     descriptor is not -1.      \sa fileDescriptor() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QDBusUnixFileDescriptor
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|fd
operator|.
name|load
argument_list|()
operator|!=
operator|-
literal|1
else|:
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the Unix file descriptor contained by this     QDBusUnixFileDescriptor object. An invalid file descriptor is represented     by the value -1.      Note that the file descriptor returned by this function is owned by the     QDBusUnixFileDescriptor object and must not be stored past the lifetime     of this object. It is ok to use it while this object is valid, but if one     wants to store it for longer use, the file descriptor should be cloned     using the Unix \c dup(2), \c dup2(2) or \c dup3(2) functions.      \sa isValid() */
end_comment
begin_function
DECL|function|fileDescriptor
name|int
name|QDBusUnixFileDescriptor
operator|::
name|fileDescriptor
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|fd
operator|.
name|load
argument_list|()
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|// actual implementation
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_comment
comment|// qdoc documentation is generated on Unix
end_comment
begin_comment
comment|/*!     Returns \c true if Unix file descriptors are supported on this platform. In     other words, this function returns \c true if this is a Unix platform.      Note that QDBusUnixFileDescriptor continues to operate even if this     function returns \c false. The only difference is that the     QDBusUnixFileDescriptor objects will always be in the isValid() == false     state and fileDescriptor() will always return -1. The class will not     consume any operating system resources. */
end_comment
begin_function
DECL|function|isSupported
name|bool
name|QDBusUnixFileDescriptor
operator|::
name|isSupported
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the file descriptor that this QDBusUnixFileDescriptor object holds     to a copy of \a fileDescriptor. The original file descriptor is not     touched and must be closed by the user.      Note that the value returned by fileDescriptor() will be different from     the \a fileDescriptor parameter passed.      If the \a fileDescriptor parameter is not valid, isValid() will return     false and fileDescriptor() will return -1.      \sa isValid(), fileDescriptor() */
end_comment
begin_function
DECL|function|setFileDescriptor
name|void
name|QDBusUnixFileDescriptor
operator|::
name|setFileDescriptor
parameter_list|(
name|int
name|fileDescriptor
parameter_list|)
block|{
if|if
condition|(
name|fileDescriptor
operator|!=
operator|-
literal|1
condition|)
name|giveFileDescriptor
argument_list|(
name|qt_safe_dup
argument_list|(
name|fileDescriptor
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Sets the Unix file descriptor to \a fileDescriptor without copying.      \sa setFileDescriptor() */
end_comment
begin_function
DECL|function|giveFileDescriptor
name|void
name|QDBusUnixFileDescriptor
operator|::
name|giveFileDescriptor
parameter_list|(
name|int
name|fileDescriptor
parameter_list|)
block|{
comment|// if we are the sole ref, d remains unchanged
comment|// if detaching happens, d->fd will be -1
if|if
condition|(
name|d
condition|)
name|d
operator|.
name|detach
argument_list|()
expr_stmt|;
else|else
name|d
operator|=
operator|new
name|QDBusUnixFileDescriptorPrivate
expr_stmt|;
specifier|const
name|int
name|fdl
init|=
name|d
operator|->
name|fd
operator|.
name|load
argument_list|()
decl_stmt|;
if|if
condition|(
name|fdl
operator|!=
operator|-
literal|1
condition|)
name|qt_safe_close
argument_list|(
name|fdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileDescriptor
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|fd
operator|.
name|store
argument_list|(
name|fileDescriptor
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Extracts the Unix file descriptor from the QDBusUnixFileDescriptor object     and transfers ownership.      Note: since QDBusUnixFileDescriptor is implicitly shared, this function     is inherently racy and should be avoided. */
end_comment
begin_function
DECL|function|takeFileDescriptor
name|int
name|QDBusUnixFileDescriptor
operator|::
name|takeFileDescriptor
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|d
operator|->
name|fd
operator|.
name|fetchAndStoreRelaxed
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_destructor
DECL|function|~QDBusUnixFileDescriptorPrivate
name|QDBusUnixFileDescriptorPrivate
operator|::
name|~
name|QDBusUnixFileDescriptorPrivate
parameter_list|()
block|{
specifier|const
name|int
name|fdl
init|=
name|fd
operator|.
name|load
argument_list|()
decl_stmt|;
if|if
condition|(
name|fdl
operator|!=
operator|-
literal|1
condition|)
name|qt_safe_close
argument_list|(
name|fdl
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|isSupported
name|bool
name|QDBusUnixFileDescriptor
operator|::
name|isSupported
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|setFileDescriptor
name|void
name|QDBusUnixFileDescriptor
operator|::
name|setFileDescriptor
parameter_list|(
name|int
parameter_list|)
block|{ }
end_function
begin_function
DECL|function|giveFileDescriptor
name|void
name|QDBusUnixFileDescriptor
operator|::
name|giveFileDescriptor
parameter_list|(
name|int
parameter_list|)
block|{ }
end_function
begin_function
DECL|function|takeFileDescriptor
name|int
name|QDBusUnixFileDescriptor
operator|::
name|takeFileDescriptor
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_destructor
DECL|function|~QDBusUnixFileDescriptorPrivate
name|QDBusUnixFileDescriptorPrivate
operator|::
name|~
name|QDBusUnixFileDescriptorPrivate
parameter_list|()
block|{ }
end_destructor
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DBUS
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
