begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtDBus module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdbusabstractinterface.h"
end_include
begin_include
include|#
directive|include
file|"qdbusabstractinterface_p.h"
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|"qdbusargument.h"
end_include
begin_include
include|#
directive|include
file|"qdbuspendingcall.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmessage_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmetaobject_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusmetatype_p.h"
end_include
begin_include
include|#
directive|include
file|"qdbusutil_p.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DBUS
end_ifndef
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|checkIfValid
specifier|static
name|QDBusError
name|checkIfValid
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|interface
parameter_list|,
name|bool
name|isDynamic
parameter_list|,
name|bool
name|isPeer
parameter_list|)
block|{
comment|// We should be throwing exceptions here... oh well
name|QDBusError
name|error
decl_stmt|;
comment|// dynamic interfaces (QDBusInterface) can have empty interfaces, but not service and object paths
comment|// non-dynamic is the opposite: service and object paths can be empty, but not the interface
if|if
condition|(
operator|!
name|isDynamic
condition|)
block|{
comment|// use assertion here because this should never happen, at all
name|Q_ASSERT_X
argument_list|(
operator|!
name|interface
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"QDBusAbstractInterface"
argument_list|,
literal|"Interface name cannot be empty"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|QDBusUtil
operator|::
name|checkBusName
argument_list|(
name|service
argument_list|,
operator|(
name|isDynamic
operator|&&
operator|!
name|isPeer
operator|)
condition|?
name|QDBusUtil
operator|::
name|EmptyNotAllowed
else|:
name|QDBusUtil
operator|::
name|EmptyAllowed
argument_list|,
operator|&
name|error
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|QDBusUtil
operator|::
name|checkObjectPath
argument_list|(
name|path
argument_list|,
name|isDynamic
condition|?
name|QDBusUtil
operator|::
name|EmptyNotAllowed
else|:
name|QDBusUtil
operator|::
name|EmptyAllowed
argument_list|,
operator|&
name|error
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|QDBusUtil
operator|::
name|checkInterfaceName
argument_list|(
name|interface
argument_list|,
name|QDBusUtil
operator|::
name|EmptyAllowed
argument_list|,
operator|&
name|error
argument_list|)
condition|)
return|return
name|error
return|;
comment|// no error
return|return
name|QDBusError
argument_list|()
return|;
block|}
end_function
begin_constructor
DECL|function|QDBusAbstractInterfacePrivate
name|QDBusAbstractInterfacePrivate
operator|::
name|QDBusAbstractInterfacePrivate
parameter_list|(
specifier|const
name|QString
modifier|&
name|serv
parameter_list|,
specifier|const
name|QString
modifier|&
name|p
parameter_list|,
specifier|const
name|QString
modifier|&
name|iface
parameter_list|,
specifier|const
name|QDBusConnection
modifier|&
name|con
parameter_list|,
name|bool
name|isDynamic
parameter_list|)
member_init_list|:
name|connection
argument_list|(
name|con
argument_list|)
member_init_list|,
name|service
argument_list|(
name|serv
argument_list|)
member_init_list|,
name|path
argument_list|(
name|p
argument_list|)
member_init_list|,
name|interface
argument_list|(
name|iface
argument_list|)
member_init_list|,
name|lastError
argument_list|(
name|checkIfValid
argument_list|(
name|serv
argument_list|,
name|p
argument_list|,
name|iface
argument_list|,
name|isDynamic
argument_list|,
operator|(
name|connectionPrivate
argument_list|()
operator|&&
name|connectionPrivate
argument_list|()
operator|->
name|mode
operator|==
name|QDBusConnectionPrivate
operator|::
name|PeerMode
operator|)
argument_list|)
argument_list|)
member_init_list|,
name|timeout
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|isValid
argument_list|(
operator|!
name|lastError
operator|.
name|isValid
argument_list|()
argument_list|)
block|{
if|if
condition|(
operator|!
name|isValid
condition|)
return|return;
if|if
condition|(
operator|!
name|connection
operator|.
name|isConnected
argument_list|()
condition|)
block|{
name|lastError
operator|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|Disconnected
argument_list|,
name|QLatin1String
argument_list|(
literal|"Not connected to D-Bus server"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|service
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|currentOwner
operator|=
name|connectionPrivate
argument_list|()
operator|->
name|getNameOwner
argument_list|(
name|service
argument_list|)
expr_stmt|;
comment|// verify the name owner
if|if
condition|(
name|currentOwner
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lastError
operator|=
name|connectionPrivate
argument_list|()
operator|->
name|lastError
expr_stmt|;
block|}
block|}
block|}
end_constructor
begin_function
DECL|function|canMakeCalls
name|bool
name|QDBusAbstractInterfacePrivate
operator|::
name|canMakeCalls
parameter_list|()
specifier|const
block|{
comment|// recheck only if we have a wildcard (i.e. empty) service or path
comment|// if any are empty, set the error message according to QDBusUtil
if|if
condition|(
name|service
operator|.
name|isEmpty
argument_list|()
operator|&&
name|connectionPrivate
argument_list|()
operator|->
name|mode
operator|!=
name|QDBusConnectionPrivate
operator|::
name|PeerMode
condition|)
return|return
name|QDBusUtil
operator|::
name|checkBusName
argument_list|(
name|service
argument_list|,
name|QDBusUtil
operator|::
name|EmptyNotAllowed
argument_list|,
operator|&
name|lastError
argument_list|)
return|;
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QDBusUtil
operator|::
name|checkObjectPath
argument_list|(
name|path
argument_list|,
name|QDBusUtil
operator|::
name|EmptyNotAllowed
argument_list|,
operator|&
name|lastError
argument_list|)
return|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|property
name|void
name|QDBusAbstractInterfacePrivate
operator|::
name|property
parameter_list|(
specifier|const
name|QMetaProperty
modifier|&
name|mp
parameter_list|,
name|QVariant
modifier|&
name|where
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
operator|||
operator|!
name|canMakeCalls
argument_list|()
condition|)
block|{
comment|// can't make calls
name|where
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// is this metatype registered?
specifier|const
name|char
modifier|*
name|expectedSignature
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|int
argument_list|(
name|mp
operator|.
name|type
argument_list|()
argument_list|)
operator|!=
name|QMetaType
operator|::
name|QVariant
condition|)
block|{
name|expectedSignature
operator|=
name|QDBusMetaType
operator|::
name|typeToSignature
argument_list|(
name|where
operator|.
name|userType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedSignature
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDBusAbstractInterface: type %s must be registered with Qt D-Bus before it can be "
literal|"used to read property %s.%s"
argument_list|,
name|mp
operator|.
name|typeName
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|interface
argument_list|)
argument_list|,
name|mp
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|lastError
operator|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|Failed
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Unregistered type %1 cannot be handled"
argument_list|)
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
name|mp
operator|.
name|typeName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|where
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|// try to read this property
name|QDBusMessage
name|msg
init|=
name|QDBusMessage
operator|::
name|createMethodCall
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|QLatin1String
argument_list|(
name|DBUS_INTERFACE_PROPERTIES
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"Get"
argument_list|)
argument_list|)
decl_stmt|;
name|QDBusMessagePrivate
operator|::
name|setParametersValidated
argument_list|(
name|msg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|msg
operator|<<
name|interface
operator|<<
name|QString
operator|::
name|fromUtf8
argument_list|(
name|mp
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|QDBusMessage
name|reply
init|=
name|connection
operator|.
name|call
argument_list|(
name|msg
argument_list|,
name|QDBus
operator|::
name|Block
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
operator|.
name|type
argument_list|()
operator|!=
name|QDBusMessage
operator|::
name|ReplyMessage
condition|)
block|{
name|lastError
operator|=
name|QDBusError
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|where
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reply
operator|.
name|signature
argument_list|()
operator|!=
name|QLatin1String
argument_list|(
literal|"v"
argument_list|)
condition|)
block|{
name|QString
name|errmsg
init|=
name|QLatin1String
argument_list|(
literal|"Invalid signature `%1' in return from call to "
name|DBUS_INTERFACE_PROPERTIES
argument_list|)
decl_stmt|;
name|lastError
operator|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|InvalidSignature
argument_list|,
name|errmsg
operator|.
name|arg
argument_list|(
name|reply
operator|.
name|signature
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|where
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
name|QByteArray
name|foundSignature
decl_stmt|;
specifier|const
name|char
modifier|*
name|foundType
init|=
literal|0
decl_stmt|;
name|QVariant
name|value
init|=
name|qvariant_cast
argument_list|<
name|QDBusVariant
argument_list|>
argument_list|(
name|reply
operator|.
name|arguments
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|variant
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|userType
argument_list|()
operator|==
name|where
operator|.
name|userType
argument_list|()
operator|||
name|mp
operator|.
name|userType
argument_list|()
operator|==
name|QMetaType
operator|::
name|QVariant
operator|||
operator|(
name|expectedSignature
index|[
literal|0
index|]
operator|==
literal|'v'
operator|&&
name|expectedSignature
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|// simple match
name|where
operator|=
name|value
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|value
operator|.
name|userType
argument_list|()
operator|==
name|qMetaTypeId
argument_list|<
name|QDBusArgument
argument_list|>
argument_list|()
condition|)
block|{
name|QDBusArgument
name|arg
init|=
name|qvariant_cast
argument_list|<
name|QDBusArgument
argument_list|>
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|foundType
operator|=
literal|"user type"
expr_stmt|;
name|foundSignature
operator|=
name|arg
operator|.
name|currentSignature
argument_list|()
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
if|if
condition|(
name|foundSignature
operator|==
name|expectedSignature
condition|)
block|{
comment|// signatures match, we can demarshall
name|QDBusMetaType
operator|::
name|demarshall
argument_list|(
name|arg
argument_list|,
name|where
operator|.
name|userType
argument_list|()
argument_list|,
name|where
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|foundType
operator|=
name|value
operator|.
name|typeName
argument_list|()
expr_stmt|;
name|foundSignature
operator|=
name|QDBusMetaType
operator|::
name|typeToSignature
argument_list|(
name|value
operator|.
name|userType
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// there was an error...
name|QString
name|errmsg
init|=
name|QLatin1String
argument_list|(
literal|"Unexpected `%1' (%2) when retrieving property `%3.%4' "
literal|"(expected type `%5' (%6))"
argument_list|)
decl_stmt|;
name|lastError
operator|=
name|QDBusError
argument_list|(
name|QDBusError
operator|::
name|InvalidSignature
argument_list|,
name|errmsg
operator|.
name|arg
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|foundType
argument_list|)
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
name|foundSignature
argument_list|)
argument_list|,
name|interface
argument_list|,
name|QString
operator|::
name|fromUtf8
argument_list|(
name|mp
operator|.
name|name
argument_list|()
argument_list|)
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
name|mp
operator|.
name|typeName
argument_list|()
argument_list|)
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
name|expectedSignature
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|where
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
end_function
begin_function
DECL|function|setProperty
name|bool
name|QDBusAbstractInterfacePrivate
operator|::
name|setProperty
parameter_list|(
specifier|const
name|QMetaProperty
modifier|&
name|mp
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isValid
operator|||
operator|!
name|canMakeCalls
argument_list|()
condition|)
comment|// can't make calls
return|return
literal|false
return|;
comment|// send the value
name|QDBusMessage
name|msg
init|=
name|QDBusMessage
operator|::
name|createMethodCall
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|QLatin1String
argument_list|(
name|DBUS_INTERFACE_PROPERTIES
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"Set"
argument_list|)
argument_list|)
decl_stmt|;
name|QDBusMessagePrivate
operator|::
name|setParametersValidated
argument_list|(
name|msg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|msg
operator|<<
name|interface
operator|<<
name|QString
operator|::
name|fromUtf8
argument_list|(
name|mp
operator|.
name|name
argument_list|()
argument_list|)
operator|<<
name|QVariant
operator|::
name|fromValue
argument_list|(
name|QDBusVariant
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|QDBusMessage
name|reply
init|=
name|connection
operator|.
name|call
argument_list|(
name|msg
argument_list|,
name|QDBus
operator|::
name|Block
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
operator|.
name|type
argument_list|()
operator|!=
name|QDBusMessage
operator|::
name|ReplyMessage
condition|)
block|{
name|lastError
operator|=
name|QDBusError
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|_q_serviceOwnerChanged
name|void
name|QDBusAbstractInterfacePrivate
operator|::
name|_q_serviceOwnerChanged
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|oldOwner
parameter_list|,
specifier|const
name|QString
modifier|&
name|newOwner
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|oldOwner
argument_list|)
expr_stmt|;
comment|//qDebug()<< "QDBusAbstractInterfacePrivate serviceOwnerChanged"<< name<< oldOwner<< newOwner;
if|if
condition|(
name|name
operator|==
name|service
condition|)
block|{
name|currentOwner
operator|=
name|newOwner
expr_stmt|;
block|}
block|}
end_function
begin_constructor
DECL|function|QDBusAbstractInterfaceBase
name|QDBusAbstractInterfaceBase
operator|::
name|QDBusAbstractInterfaceBase
parameter_list|(
name|QDBusAbstractInterfacePrivate
modifier|&
name|d
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|d
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|qt_metacall
name|int
name|QDBusAbstractInterfaceBase
operator|::
name|qt_metacall
parameter_list|(
name|QMetaObject
operator|::
name|Call
name|_c
parameter_list|,
name|int
name|_id
parameter_list|,
name|void
modifier|*
modifier|*
name|_a
parameter_list|)
block|{
name|int
name|saved_id
init|=
name|_id
decl_stmt|;
name|_id
operator|=
name|QObject
operator|::
name|qt_metacall
argument_list|(
name|_c
argument_list|,
name|_id
argument_list|,
name|_a
argument_list|)
expr_stmt|;
if|if
condition|(
name|_id
operator|<
literal|0
condition|)
return|return
name|_id
return|;
if|if
condition|(
name|_c
operator|==
name|QMetaObject
operator|::
name|ReadProperty
operator|||
name|_c
operator|==
name|QMetaObject
operator|::
name|WriteProperty
condition|)
block|{
name|QMetaProperty
name|mp
init|=
name|metaObject
argument_list|()
operator|->
name|property
argument_list|(
name|saved_id
argument_list|)
decl_stmt|;
name|int
modifier|&
name|status
init|=
operator|*
cast|reinterpret_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|_a
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|QVariant
modifier|&
name|variant
init|=
operator|*
cast|reinterpret_cast
argument_list|<
name|QVariant
operator|*
argument_list|>
argument_list|(
name|_a
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|_c
operator|==
name|QMetaObject
operator|::
name|WriteProperty
condition|)
block|{
name|status
operator|=
name|d_func
argument_list|()
operator|->
name|setProperty
argument_list|(
name|mp
argument_list|,
name|variant
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|d_func
argument_list|()
operator|->
name|property
argument_list|(
name|mp
argument_list|,
name|variant
argument_list|)
expr_stmt|;
name|status
operator|=
name|variant
operator|.
name|isValid
argument_list|()
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|_id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|_id
return|;
block|}
end_function
begin_comment
comment|/*!     \class QDBusAbstractInterface     \inmodule QtDBus     \since 4.2      \brief The QDBusAbstractInterface class is the base class for all D-Bus interfaces in the Qt D-Bus binding, allowing access to remote interfaces      Generated-code classes also derive from QDBusAbstractInterface,     all methods described here are also valid for generated-code     classes. In addition to those described here, generated-code     classes provide member functions for the remote methods, which     allow for compile-time checking of the correct parameters and     return values, as well as property type-matching and signal     parameter-matching.      \sa {qdbusxml2cpp.html}{The QDBus compiler}, QDBusInterface */
end_comment
begin_comment
comment|/*!     \internal     This is the constructor called from QDBusInterface::QDBusInterface. */
end_comment
begin_constructor
DECL|function|QDBusAbstractInterface
name|QDBusAbstractInterface
operator|::
name|QDBusAbstractInterface
parameter_list|(
name|QDBusAbstractInterfacePrivate
modifier|&
name|d
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QDBusAbstractInterfaceBase
argument_list|(
name|d
argument_list|,
name|parent
argument_list|)
block|{
comment|// keep track of the service owner
if|if
condition|(
name|d
operator|.
name|isValid
operator|&&
name|d
operator|.
name|connection
operator|.
name|isConnected
argument_list|()
operator|&&
operator|!
name|d
operator|.
name|service
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|d
operator|.
name|service
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
operator|&&
name|d
operator|.
name|connectionPrivate
argument_list|()
operator|->
name|mode
operator|!=
name|QDBusConnectionPrivate
operator|::
name|PeerMode
condition|)
name|d_func
argument_list|()
operator|->
name|connection
operator|.
name|connect
argument_list|(
name|QLatin1String
argument_list|(
name|DBUS_SERVICE_DBUS
argument_list|)
argument_list|,
comment|// service
name|QString
argument_list|()
argument_list|,
comment|// path
name|QLatin1String
argument_list|(
name|DBUS_INTERFACE_DBUS
argument_list|)
argument_list|,
comment|// interface
name|QLatin1String
argument_list|(
literal|"NameOwnerChanged"
argument_list|)
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|d
operator|.
name|service
argument_list|,
name|QString
argument_list|()
argument_list|,
comment|// signature
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_serviceOwnerChanged
argument_list|(
name|QString
argument_list|,
name|QString
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal     This is the constructor called from static classes derived from     QDBusAbstractInterface (i.e., those generated by dbusxml2cpp). */
end_comment
begin_constructor
DECL|function|QDBusAbstractInterface
name|QDBusAbstractInterface
operator|::
name|QDBusAbstractInterface
parameter_list|(
specifier|const
name|QString
modifier|&
name|service
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|interface
parameter_list|,
specifier|const
name|QDBusConnection
modifier|&
name|con
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QDBusAbstractInterfaceBase
argument_list|(
operator|*
operator|new
name|QDBusAbstractInterfacePrivate
argument_list|(
name|service
argument_list|,
name|path
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
name|interface
argument_list|)
argument_list|,
name|con
argument_list|,
literal|false
argument_list|)
argument_list|,
name|parent
argument_list|)
block|{
comment|// keep track of the service owner
if|if
condition|(
name|d_func
argument_list|()
operator|->
name|isValid
operator|&&
name|d_func
argument_list|()
operator|->
name|connection
operator|.
name|isConnected
argument_list|()
operator|&&
operator|!
name|service
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|service
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
operator|&&
name|d_func
argument_list|()
operator|->
name|connectionPrivate
argument_list|()
operator|->
name|mode
operator|!=
name|QDBusConnectionPrivate
operator|::
name|PeerMode
condition|)
name|d_func
argument_list|()
operator|->
name|connection
operator|.
name|connect
argument_list|(
name|QLatin1String
argument_list|(
name|DBUS_SERVICE_DBUS
argument_list|)
argument_list|,
comment|// service
name|QString
argument_list|()
argument_list|,
comment|// path
name|QLatin1String
argument_list|(
name|DBUS_INTERFACE_DBUS
argument_list|)
argument_list|,
comment|// interface
name|QLatin1String
argument_list|(
literal|"NameOwnerChanged"
argument_list|)
argument_list|,
name|QStringList
argument_list|()
operator|<<
name|service
argument_list|,
name|QString
argument_list|()
argument_list|,
comment|//signature
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_serviceOwnerChanged
argument_list|(
name|QString
argument_list|,
name|QString
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Releases this object's resources. */
end_comment
begin_destructor
DECL|function|~QDBusAbstractInterface
name|QDBusAbstractInterface
operator|::
name|~
name|QDBusAbstractInterface
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns true if this is a valid reference to a remote object. It returns false if     there was an error during the creation of this interface (for instance, if the remote     application does not exist).      Note: when dealing with remote objects, it is not always possible to determine if it     exists when creating a QDBusInterface. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QDBusAbstractInterface
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDBusAbstractInterface
argument_list|)
expr_stmt|;
comment|/* We don't retrieve the owner name for peer connections */
if|if
condition|(
name|d
operator|->
name|connectionPrivate
argument_list|()
operator|&&
name|d
operator|->
name|connectionPrivate
argument_list|()
operator|->
name|mode
operator|==
name|QDBusConnectionPrivate
operator|::
name|PeerMode
condition|)
block|{
return|return
name|d
operator|->
name|isValid
return|;
block|}
else|else
block|{
return|return
operator|!
name|d
operator|->
name|currentOwner
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the connection this interface is assocated with. */
end_comment
begin_function
DECL|function|connection
name|QDBusConnection
name|QDBusAbstractInterface
operator|::
name|connection
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|connection
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the service this interface is associated with. */
end_comment
begin_function
DECL|function|service
name|QString
name|QDBusAbstractInterface
operator|::
name|service
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|service
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the object path that this interface is associated with. */
end_comment
begin_function
DECL|function|path
name|QString
name|QDBusAbstractInterface
operator|::
name|path
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|path
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of this interface. */
end_comment
begin_function
DECL|function|interface
name|QString
name|QDBusAbstractInterface
operator|::
name|interface
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|interface
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the error the last operation produced, or an invalid error if the last operation did not     produce an error. */
end_comment
begin_function
DECL|function|lastError
name|QDBusError
name|QDBusAbstractInterface
operator|::
name|lastError
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|lastError
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the timeout in milliseconds for all future DBus calls to \a timeout.     -1 means the default DBus timeout (usually 25 seconds).      \since 4.8 */
end_comment
begin_function
DECL|function|setTimeout
name|void
name|QDBusAbstractInterface
operator|::
name|setTimeout
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current value of the timeout in milliseconds.     -1 means the default DBus timeout (usually 25 seconds).      \since 4.8 */
end_comment
begin_function
DECL|function|timeout
name|int
name|QDBusAbstractInterface
operator|::
name|timeout
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|timeout
return|;
block|}
end_function
begin_comment
comment|/*!     Places a call to the remote method specified by \a method on this interface, using \a args as     arguments. This function returns the message that was received as a reply, which can be a normal     QDBusMessage::ReplyMessage (indicating success) or QDBusMessage::ErrorMessage (if the call     failed). The \a mode parameter specifies how this call should be placed.      If the call succeeds, lastError() will be cleared; otherwise, it will contain the error this     call produced.      Normally, you should place calls using call().      \warning If you use \c UseEventLoop, your code must be prepared to deal with any reentrancy:              other method calls and signals may be delivered before this function returns, as well              as other Qt queued signals and events.      \threadsafe */
end_comment
begin_function
DECL|function|callWithArgumentList
name|QDBusMessage
name|QDBusAbstractInterface
operator|::
name|callWithArgumentList
parameter_list|(
name|QDBus
operator|::
name|CallMode
name|mode
parameter_list|,
specifier|const
name|QString
modifier|&
name|method
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|args
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDBusAbstractInterface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isValid
operator|||
operator|!
name|d
operator|->
name|canMakeCalls
argument_list|()
condition|)
return|return
name|QDBusMessage
operator|::
name|createError
argument_list|(
name|d
operator|->
name|lastError
argument_list|)
return|;
name|QString
name|m
init|=
name|method
decl_stmt|;
comment|// split out the signature from the method
name|int
name|pos
init|=
name|method
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
name|m
operator|.
name|truncate
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|QDBus
operator|::
name|AutoDetect
condition|)
block|{
comment|// determine if this a sync or async call
name|mode
operator|=
name|QDBus
operator|::
name|Block
expr_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|mo
init|=
name|metaObject
argument_list|()
decl_stmt|;
name|QByteArray
name|match
init|=
name|m
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|staticMetaObject
operator|.
name|methodCount
argument_list|()
init|;
name|i
operator|<
name|mo
operator|->
name|methodCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QMetaMethod
name|mm
init|=
name|mo
operator|->
name|method
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|mm
operator|.
name|name
argument_list|()
operator|==
name|match
condition|)
block|{
comment|// found a method with the same name as what we're looking for
comment|// hopefully, nobody is overloading asynchronous and synchronous methods with
comment|// the same name
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|tags
init|=
name|QByteArray
argument_list|(
name|mm
operator|.
name|tag
argument_list|()
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|tags
operator|.
name|contains
argument_list|(
literal|"Q_NOREPLY"
argument_list|)
condition|)
name|mode
operator|=
name|QDBus
operator|::
name|NoBlock
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|//    qDebug()<< "QDBusAbstractInterface"<< "Service"<< service()<< "Path:"<< path();
name|QDBusMessage
name|msg
init|=
name|QDBusMessage
operator|::
name|createMethodCall
argument_list|(
name|service
argument_list|()
argument_list|,
name|path
argument_list|()
argument_list|,
name|interface
argument_list|()
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|QDBusMessagePrivate
operator|::
name|setParametersValidated
argument_list|(
name|msg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setArguments
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|QDBusMessage
name|reply
init|=
name|d
operator|->
name|connection
operator|.
name|call
argument_list|(
name|msg
argument_list|,
name|mode
argument_list|,
name|d
operator|->
name|timeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|thread
argument_list|()
operator|==
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
name|d
operator|->
name|lastError
operator|=
name|QDBusError
argument_list|(
name|reply
argument_list|)
expr_stmt|;
comment|// will clear if reply isn't an error
comment|// ensure that there is at least one element
if|if
condition|(
name|reply
operator|.
name|arguments
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|reply
operator|<<
name|QVariant
argument_list|()
expr_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     Places a call to the remote method specified by \a method on this     interface, using \a args as arguments. This function returns a     QDBusPendingCall object that can be used to track the status of the     reply and access its contents once it has arrived.      Normally, you should place calls using asyncCall().      \threadsafe */
end_comment
begin_function
DECL|function|asyncCallWithArgumentList
name|QDBusPendingCall
name|QDBusAbstractInterface
operator|::
name|asyncCallWithArgumentList
parameter_list|(
specifier|const
name|QString
modifier|&
name|method
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|args
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDBusAbstractInterface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isValid
operator|||
operator|!
name|d
operator|->
name|canMakeCalls
argument_list|()
condition|)
return|return
name|QDBusPendingCall
operator|::
name|fromError
argument_list|(
name|d
operator|->
name|lastError
argument_list|)
return|;
name|QDBusMessage
name|msg
init|=
name|QDBusMessage
operator|::
name|createMethodCall
argument_list|(
name|service
argument_list|()
argument_list|,
name|path
argument_list|()
argument_list|,
name|interface
argument_list|()
argument_list|,
name|method
argument_list|)
decl_stmt|;
name|QDBusMessagePrivate
operator|::
name|setParametersValidated
argument_list|(
name|msg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setArguments
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|connection
operator|.
name|asyncCall
argument_list|(
name|msg
argument_list|,
name|d
operator|->
name|timeout
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Places a call to the remote method specified by \a method     on this interface, using \a args as arguments. This function     returns immediately after queueing the call. The reply from     the remote function is delivered to the \a returnMethod on     object \a receiver. If an error occurs, the \a errorMethod     on object \a receiver is called instead.      This function returns true if the queueing succeeds. It does     not indicate that the executed call succeeded. If it fails,     the \a errorMethod is called. If the queueing failed, this     function returns false and no slot will be called.      The \a returnMethod must have as its parameters the types returned     by the function call. Optionally, it may have a QDBusMessage     parameter as its last or only parameter.  The \a errorMethod must     have a QDBusError as its only parameter.      \since 4.3     \sa QDBusError, QDBusMessage  */
end_comment
begin_function
DECL|function|callWithCallback
name|bool
name|QDBusAbstractInterface
operator|::
name|callWithCallback
parameter_list|(
specifier|const
name|QString
modifier|&
name|method
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|args
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|returnMethod
parameter_list|,
specifier|const
name|char
modifier|*
name|errorMethod
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDBusAbstractInterface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isValid
operator|||
operator|!
name|d
operator|->
name|canMakeCalls
argument_list|()
condition|)
return|return
literal|false
return|;
name|QDBusMessage
name|msg
init|=
name|QDBusMessage
operator|::
name|createMethodCall
argument_list|(
name|service
argument_list|()
argument_list|,
name|path
argument_list|()
argument_list|,
name|interface
argument_list|()
argument_list|,
name|method
argument_list|)
decl_stmt|;
name|QDBusMessagePrivate
operator|::
name|setParametersValidated
argument_list|(
name|msg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setArguments
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|d
operator|->
name|lastError
operator|=
name|QDBusError
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|connection
operator|.
name|callWithCallback
argument_list|(
name|msg
argument_list|,
name|receiver
argument_list|,
name|returnMethod
argument_list|,
name|errorMethod
argument_list|,
name|d
operator|->
name|timeout
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      This function is deprecated. Please use the overloaded version.      Places a call to the remote method specified by \a method     on this interface, using \a args as arguments. This function     returns immediately after queueing the call. The reply from     the remote function or any errors emitted by it are delivered     to the \a slot slot on object \a receiver.      This function returns true if the queueing succeeded: it does     not indicate that the call succeeded. If it failed, the slot     will be called with an error message. lastError() will not be     set under those circumstances.      \sa QDBusError, QDBusMessage */
end_comment
begin_function
DECL|function|callWithCallback
name|bool
name|QDBusAbstractInterface
operator|::
name|callWithCallback
parameter_list|(
specifier|const
name|QString
modifier|&
name|method
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|args
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
return|return
name|callWithCallback
argument_list|(
name|method
argument_list|,
name|args
argument_list|,
name|receiver
argument_list|,
name|slot
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Catch signal connections. */
end_comment
begin_function
DECL|function|connectNotify
name|void
name|QDBusAbstractInterface
operator|::
name|connectNotify
parameter_list|(
specifier|const
name|QMetaMethod
modifier|&
name|signal
parameter_list|)
block|{
comment|// someone connecting to one of our signals
name|Q_D
argument_list|(
name|QDBusAbstractInterface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isValid
condition|)
return|return;
comment|// we end up recursing here, so optimize away
specifier|static
specifier|const
name|QMetaMethod
name|destroyedSignal
init|=
name|QMetaMethod
operator|::
name|fromSignal
argument_list|(
operator|&
name|QDBusAbstractInterface
operator|::
name|destroyed
argument_list|)
decl_stmt|;
if|if
condition|(
name|signal
operator|==
name|destroyedSignal
condition|)
return|return;
name|QDBusConnectionPrivate
modifier|*
name|conn
init|=
name|d
operator|->
name|connectionPrivate
argument_list|()
decl_stmt|;
if|if
condition|(
name|conn
condition|)
block|{
name|conn
operator|->
name|connectRelay
argument_list|(
name|d
operator|->
name|service
argument_list|,
name|d
operator|->
name|path
argument_list|,
name|d
operator|->
name|interface
argument_list|,
name|this
argument_list|,
name|signal
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     Catch signal disconnections. */
end_comment
begin_function
DECL|function|disconnectNotify
name|void
name|QDBusAbstractInterface
operator|::
name|disconnectNotify
parameter_list|(
specifier|const
name|QMetaMethod
modifier|&
name|signal
parameter_list|)
block|{
comment|// someone disconnecting from one of our signals
name|Q_D
argument_list|(
name|QDBusAbstractInterface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isValid
condition|)
return|return;
name|QDBusConnectionPrivate
modifier|*
name|conn
init|=
name|d
operator|->
name|connectionPrivate
argument_list|()
decl_stmt|;
if|if
condition|(
name|conn
operator|&&
name|signal
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|isSignalConnected
argument_list|(
name|signal
argument_list|)
condition|)
return|return
name|conn
operator|->
name|disconnectRelay
argument_list|(
name|d
operator|->
name|service
argument_list|,
name|d
operator|->
name|path
argument_list|,
name|d
operator|->
name|interface
argument_list|,
name|this
argument_list|,
name|signal
argument_list|)
return|;
if|if
condition|(
operator|!
name|conn
condition|)
return|return;
comment|// wildcard disconnecting, we need to figure out which of our signals are
comment|// no longer connected to anything
specifier|const
name|QMetaObject
modifier|*
name|mo
init|=
name|metaObject
argument_list|()
decl_stmt|;
name|int
name|midx
init|=
name|QObject
operator|::
name|staticMetaObject
operator|.
name|methodCount
argument_list|()
decl_stmt|;
specifier|const
name|int
name|end
init|=
name|mo
operator|->
name|methodCount
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|midx
operator|<
name|end
condition|;
operator|++
name|midx
control|)
block|{
name|QMetaMethod
name|mm
init|=
name|mo
operator|->
name|method
argument_list|(
name|midx
argument_list|)
decl_stmt|;
if|if
condition|(
name|mm
operator|.
name|methodType
argument_list|()
operator|==
name|QMetaMethod
operator|::
name|Signal
operator|&&
operator|!
name|isSignalConnected
argument_list|(
name|mm
argument_list|)
condition|)
name|conn
operator|->
name|disconnectRelay
argument_list|(
name|d
operator|->
name|service
argument_list|,
name|d
operator|->
name|path
argument_list|,
name|d
operator|->
name|interface
argument_list|,
name|this
argument_list|,
name|mm
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     Get the value of the property \a propname. */
end_comment
begin_function
DECL|function|internalPropGet
name|QVariant
name|QDBusAbstractInterface
operator|::
name|internalPropGet
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|)
specifier|const
block|{
comment|// assume this property exists and is readable
comment|// we're only called from generated code anyways
return|return
name|property
argument_list|(
name|propname
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Set the value of the property \a propname to \a value. */
end_comment
begin_function
DECL|function|internalPropSet
name|void
name|QDBusAbstractInterface
operator|::
name|internalPropSet
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|setProperty
argument_list|(
name|propname
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Calls the method \a method on this interface and passes the parameters to this function to the     method.      The parameters to \c call are passed on to the remote function via D-Bus as input     arguments. Output arguments are returned in the QDBusMessage reply. If the reply is an error     reply, lastError() will also be set to the contents of the error message.      This function can be used with up to 8 parameters, passed in arguments \a arg1, \a arg2,     \a arg3, \a arg4, \a arg5, \a arg6, \a arg7 and \a arg8. If you need more than 8     parameters or if you have a variable number of parameters to be passed, use     callWithArgumentList().      It can be used the following way:      \snippet code/src_qdbus_qdbusabstractinterface.cpp 0      This example illustrates function calling with 0, 1 and 2 parameters and illustrates different     parameter types passed in each (the first call to \c "ProcessWorkUnicode" will contain one     Unicode string, the second call to \c "ProcessWork" will contain one string and one byte array). */
end_comment
begin_function
DECL|function|call
name|QDBusMessage
name|QDBusAbstractInterface
operator|::
name|call
parameter_list|(
specifier|const
name|QString
modifier|&
name|method
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg1
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg2
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg3
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg4
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg5
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg6
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg7
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg8
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|QDBus
operator|::
name|AutoDetect
argument_list|,
name|method
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|,
name|arg6
argument_list|,
name|arg7
argument_list|,
name|arg8
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Calls the method \a method on this interface and passes the     parameters to this function to the method. If \a mode is \c     NoWaitForReply, then this function will return immediately after     placing the call, without waiting for a reply from the remote     method. Otherwise, \a mode indicates whether this function should     activate the Qt Event Loop while waiting for the reply to arrive.      This function can be used with up to 8 parameters, passed in arguments \a arg1, \a arg2,     \a arg3, \a arg4, \a arg5, \a arg6, \a arg7 and \a arg8. If you need more than 8     parameters or if you have a variable number of parameters to be passed, use     callWithArgumentList().      If this function reenters the Qt event loop in order to wait for the     reply, it will exclude user input. During the wait, it may deliver     signals and other method calls to your application. Therefore, it     must be prepared to handle a reentrancy whenever a call is placed     with call(). */
end_comment
begin_function
DECL|function|call
name|QDBusMessage
name|QDBusAbstractInterface
operator|::
name|call
parameter_list|(
name|QDBus
operator|::
name|CallMode
name|mode
parameter_list|,
specifier|const
name|QString
modifier|&
name|method
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg1
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg2
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg3
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg4
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg5
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg6
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg7
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg8
parameter_list|)
block|{
name|QList
argument_list|<
name|QVariant
argument_list|>
name|argList
decl_stmt|;
name|int
name|count
init|=
literal|0
operator|+
name|arg1
operator|.
name|isValid
argument_list|()
operator|+
name|arg2
operator|.
name|isValid
argument_list|()
operator|+
name|arg3
operator|.
name|isValid
argument_list|()
operator|+
name|arg4
operator|.
name|isValid
argument_list|()
operator|+
name|arg5
operator|.
name|isValid
argument_list|()
operator|+
name|arg6
operator|.
name|isValid
argument_list|()
operator|+
name|arg7
operator|.
name|isValid
argument_list|()
operator|+
name|arg8
operator|.
name|isValid
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|count
condition|)
block|{
case|case
literal|8
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg8
argument_list|)
expr_stmt|;
case|case
literal|7
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg7
argument_list|)
expr_stmt|;
case|case
literal|6
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg6
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg5
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg4
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
return|return
name|callWithArgumentList
argument_list|(
name|mode
argument_list|,
name|method
argument_list|,
name|argList
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     Calls the method \a method on this interface and passes the parameters to this function to the     method.      The parameters to \c call are passed on to the remote function via D-Bus as input     arguments. The returned QDBusPendingCall object can be used to find out information about     the reply.      This function can be used with up to 8 parameters, passed in arguments \a arg1, \a arg2,     \a arg3, \a arg4, \a arg5, \a arg6, \a arg7 and \a arg8. If you need more than 8     parameters or if you have a variable number of parameters to be passed, use     asyncCallWithArgumentList().      It can be used the following way:      \snippet code/src_qdbus_qdbusabstractinterface.cpp 1      This example illustrates function calling with 0, 1 and 2 parameters and illustrates different     parameter types passed in each (the first call to \c "ProcessWorkUnicode" will contain one     Unicode string, the second call to \c "ProcessWork" will contain one string and one byte array). */
end_comment
begin_function
DECL|function|asyncCall
name|QDBusPendingCall
name|QDBusAbstractInterface
operator|::
name|asyncCall
parameter_list|(
specifier|const
name|QString
modifier|&
name|method
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg1
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg2
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg3
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg4
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg5
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg6
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg7
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|arg8
parameter_list|)
block|{
name|QList
argument_list|<
name|QVariant
argument_list|>
name|argList
decl_stmt|;
name|int
name|count
init|=
literal|0
operator|+
name|arg1
operator|.
name|isValid
argument_list|()
operator|+
name|arg2
operator|.
name|isValid
argument_list|()
operator|+
name|arg3
operator|.
name|isValid
argument_list|()
operator|+
name|arg4
operator|.
name|isValid
argument_list|()
operator|+
name|arg5
operator|.
name|isValid
argument_list|()
operator|+
name|arg6
operator|.
name|isValid
argument_list|()
operator|+
name|arg7
operator|.
name|isValid
argument_list|()
operator|+
name|arg8
operator|.
name|isValid
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|count
condition|)
block|{
case|case
literal|8
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg8
argument_list|)
expr_stmt|;
case|case
literal|7
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg7
argument_list|)
expr_stmt|;
case|case
literal|6
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg6
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg5
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg4
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|argList
operator|.
name|prepend
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
return|return
name|asyncCallWithArgumentList
argument_list|(
name|method
argument_list|,
name|argList
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|internalConstCall
name|QDBusMessage
name|QDBusAbstractInterface
operator|::
name|internalConstCall
parameter_list|(
name|QDBus
operator|::
name|CallMode
name|mode
parameter_list|,
specifier|const
name|QString
modifier|&
name|method
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|args
parameter_list|)
specifier|const
block|{
comment|// ### move the code here, and make the other functions call this
return|return
cast|const_cast
argument_list|<
name|QDBusAbstractInterface
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|callWithArgumentList
argument_list|(
name|mode
argument_list|,
name|method
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DBUS
end_comment
begin_include
include|#
directive|include
file|"moc_qdbusabstractinterface.cpp"
end_include
end_unit
