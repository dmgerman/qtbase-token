begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qfontconfigdatabase_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/QList>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qfont_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/QElapsedTimer>
end_include
begin_include
include|#
directive|include
file|<QtGui/QPlatformScreen>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qfontengine_ft_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qfontengine_p.h>
end_include
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TABLES_H
end_include
begin_include
include|#
directive|include
file|<fontconfig/fontconfig.h>
end_include
begin_define
DECL|macro|SimplifiedChineseCsbBit
define|#
directive|define
name|SimplifiedChineseCsbBit
value|18
end_define
begin_define
DECL|macro|TraditionalChineseCsbBit
define|#
directive|define
name|TraditionalChineseCsbBit
value|20
end_define
begin_define
DECL|macro|JapaneseCsbBit
define|#
directive|define
name|JapaneseCsbBit
value|17
end_define
begin_define
DECL|macro|KoreanCsbBit
define|#
directive|define
name|KoreanCsbBit
value|21
end_define
begin_function
DECL|function|requiresOpenType
specifier|static
specifier|inline
name|bool
name|requiresOpenType
parameter_list|(
name|int
name|writingSystem
parameter_list|)
block|{
return|return
operator|(
operator|(
name|writingSystem
operator|>=
name|QFontDatabase
operator|::
name|Syriac
operator|&&
name|writingSystem
operator|<=
name|QFontDatabase
operator|::
name|Sinhala
operator|)
operator|||
name|writingSystem
operator|==
name|QFontDatabase
operator|::
name|Khmer
operator|||
name|writingSystem
operator|==
name|QFontDatabase
operator|::
name|Nko
operator|)
return|;
block|}
end_function
begin_function
DECL|function|scriptRequiresOpenType
specifier|static
specifier|inline
name|bool
name|scriptRequiresOpenType
parameter_list|(
name|int
name|script
parameter_list|)
block|{
return|return
operator|(
operator|(
name|script
operator|>=
name|QUnicodeTables
operator|::
name|Syriac
operator|&&
name|script
operator|<=
name|QUnicodeTables
operator|::
name|Sinhala
operator|)
operator|||
name|script
operator|==
name|QUnicodeTables
operator|::
name|Khmer
operator|||
name|script
operator|==
name|QUnicodeTables
operator|::
name|Nko
operator|)
return|;
block|}
end_function
begin_function
DECL|function|getFCWeight
specifier|static
name|int
name|getFCWeight
parameter_list|(
name|int
name|fc_weight
parameter_list|)
block|{
name|int
name|qtweight
init|=
name|QFont
operator|::
name|Black
decl_stmt|;
if|if
condition|(
name|fc_weight
operator|<=
operator|(
name|FC_WEIGHT_LIGHT
operator|+
name|FC_WEIGHT_MEDIUM
operator|)
operator|/
literal|2
condition|)
name|qtweight
operator|=
name|QFont
operator|::
name|Light
expr_stmt|;
elseif|else
if|if
condition|(
name|fc_weight
operator|<=
operator|(
name|FC_WEIGHT_MEDIUM
operator|+
name|FC_WEIGHT_DEMIBOLD
operator|)
operator|/
literal|2
condition|)
name|qtweight
operator|=
name|QFont
operator|::
name|Normal
expr_stmt|;
elseif|else
if|if
condition|(
name|fc_weight
operator|<=
operator|(
name|FC_WEIGHT_DEMIBOLD
operator|+
name|FC_WEIGHT_BOLD
operator|)
operator|/
literal|2
condition|)
name|qtweight
operator|=
name|QFont
operator|::
name|DemiBold
expr_stmt|;
elseif|else
if|if
condition|(
name|fc_weight
operator|<=
operator|(
name|FC_WEIGHT_BOLD
operator|+
name|FC_WEIGHT_BLACK
operator|)
operator|/
literal|2
condition|)
name|qtweight
operator|=
name|QFont
operator|::
name|Bold
expr_stmt|;
return|return
name|qtweight
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|specialLanguages
specifier|static
specifier|const
name|char
modifier|*
name|specialLanguages
index|[]
init|=
block|{
literal|"en"
block|,
comment|// Common
literal|"el"
block|,
comment|// Greek
literal|"ru"
block|,
comment|// Cyrillic
literal|"hy"
block|,
comment|// Armenian
literal|"he"
block|,
comment|// Hebrew
literal|"ar"
block|,
comment|// Arabic
literal|"syr"
block|,
comment|// Syriac
literal|"div"
block|,
comment|// Thaana
literal|"hi"
block|,
comment|// Devanagari
literal|"bn"
block|,
comment|// Bengali
literal|"pa"
block|,
comment|// Gurmukhi
literal|"gu"
block|,
comment|// Gujarati
literal|"or"
block|,
comment|// Oriya
literal|"ta"
block|,
comment|// Tamil
literal|"te"
block|,
comment|// Telugu
literal|"kn"
block|,
comment|// Kannada
literal|"ml"
block|,
comment|// Malayalam
literal|"si"
block|,
comment|// Sinhala
literal|"th"
block|,
comment|// Thai
literal|"lo"
block|,
comment|// Lao
literal|"bo"
block|,
comment|// Tibetan
literal|"my"
block|,
comment|// Myanmar
literal|"ka"
block|,
comment|// Georgian
literal|"ko"
block|,
comment|// Hangul
literal|""
block|,
comment|// Ogham
literal|""
block|,
comment|// Runic
literal|"km"
block|,
comment|// Khmer
literal|""
comment|// N'Ko
block|}
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enumerator|SpecialLanguageCount
enum|enum
block|{
name|SpecialLanguageCount
init|=
sizeof|sizeof
argument_list|(
name|specialLanguages
argument_list|)
operator|/
expr|sizeof
operator|(
specifier|const
name|char
operator|*
operator|)
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|specialChars
specifier|static
specifier|const
name|ushort
name|specialChars
index|[]
init|=
block|{
literal|0
block|,
comment|// English
literal|0
block|,
comment|// Greek
literal|0
block|,
comment|// Cyrillic
literal|0
block|,
comment|// Armenian
literal|0
block|,
comment|// Hebrew
literal|0
block|,
comment|// Arabic
literal|0
block|,
comment|// Syriac
literal|0
block|,
comment|// Thaana
literal|0
block|,
comment|// Devanagari
literal|0
block|,
comment|// Bengali
literal|0
block|,
comment|// Gurmukhi
literal|0
block|,
comment|// Gujarati
literal|0
block|,
comment|// Oriya
literal|0
block|,
comment|// Tamil
literal|0xc15
block|,
comment|// Telugu
literal|0xc95
block|,
comment|// Kannada
literal|0xd15
block|,
comment|// Malayalam
literal|0xd9a
block|,
comment|// Sinhala
literal|0
block|,
comment|// Thai
literal|0
block|,
comment|// Lao
literal|0
block|,
comment|// Tibetan
literal|0x1000
block|,
comment|// Myanmar
literal|0
block|,
comment|// Georgian
literal|0
block|,
comment|// Hangul
literal|0x1681
block|,
comment|// Ogham
literal|0x16a0
block|,
comment|// Runic
literal|0
block|,
comment|// Khmer
literal|0x7ca
comment|// N'Ko
block|}
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enumerator|SpecialCharCount
enum|enum
block|{
name|SpecialCharCount
init|=
sizeof|sizeof
argument_list|(
name|specialChars
argument_list|)
operator|/
expr|sizeof
operator|(
name|ushort
operator|)
block|}
enum|;
end_enum
begin_comment
comment|// this could become a list of all languages used for each writing
end_comment
begin_comment
comment|// system, instead of using the single most common language.
end_comment
begin_decl_stmt
DECL|variable|languageForWritingSystem
specifier|static
specifier|const
name|char
modifier|*
name|languageForWritingSystem
index|[]
init|=
block|{
literal|0
block|,
comment|// Any
literal|"en"
block|,
comment|// Latin
literal|"el"
block|,
comment|// Greek
literal|"ru"
block|,
comment|// Cyrillic
literal|"hy"
block|,
comment|// Armenian
literal|"he"
block|,
comment|// Hebrew
literal|"ar"
block|,
comment|// Arabic
literal|"syr"
block|,
comment|// Syriac
literal|"div"
block|,
comment|// Thaana
literal|"hi"
block|,
comment|// Devanagari
literal|"bn"
block|,
comment|// Bengali
literal|"pa"
block|,
comment|// Gurmukhi
literal|"gu"
block|,
comment|// Gujarati
literal|"or"
block|,
comment|// Oriya
literal|"ta"
block|,
comment|// Tamil
literal|"te"
block|,
comment|// Telugu
literal|"kn"
block|,
comment|// Kannada
literal|"ml"
block|,
comment|// Malayalam
literal|"si"
block|,
comment|// Sinhala
literal|"th"
block|,
comment|// Thai
literal|"lo"
block|,
comment|// Lao
literal|"bo"
block|,
comment|// Tibetan
literal|"my"
block|,
comment|// Myanmar
literal|"ka"
block|,
comment|// Georgian
literal|"km"
block|,
comment|// Khmer
literal|"zh-cn"
block|,
comment|// SimplifiedChinese
literal|"zh-tw"
block|,
comment|// TraditionalChinese
literal|"ja"
block|,
comment|// Japanese
literal|"ko"
block|,
comment|// Korean
literal|"vi"
block|,
comment|// Vietnamese
literal|0
block|,
comment|// Symbol
literal|0
block|,
comment|// Ogham
literal|0
block|,
comment|// Runic
literal|0
comment|// N'Ko
block|}
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enumerator|LanguageCount
enum|enum
block|{
name|LanguageCount
init|=
sizeof|sizeof
argument_list|(
name|languageForWritingSystem
argument_list|)
operator|/
expr|sizeof
operator|(
specifier|const
name|char
operator|*
operator|)
block|}
enum|;
end_enum
begin_comment
comment|// Unfortunately FontConfig doesn't know about some languages. We have to test these through the
end_comment
begin_comment
comment|// charset. The lists below contain the systems where we need to do this.
end_comment
begin_decl_stmt
DECL|variable|sampleCharForWritingSystem
specifier|static
specifier|const
name|ushort
name|sampleCharForWritingSystem
index|[]
init|=
block|{
literal|0
block|,
comment|// Any
literal|0
block|,
comment|// Latin
literal|0
block|,
comment|// Greek
literal|0
block|,
comment|// Cyrillic
literal|0
block|,
comment|// Armenian
literal|0
block|,
comment|// Hebrew
literal|0
block|,
comment|// Arabic
literal|0
block|,
comment|// Syriac
literal|0
block|,
comment|// Thaana
literal|0
block|,
comment|// Devanagari
literal|0
block|,
comment|// Bengali
literal|0
block|,
comment|// Gurmukhi
literal|0
block|,
comment|// Gujarati
literal|0
block|,
comment|// Oriya
literal|0
block|,
comment|// Tamil
literal|0xc15
block|,
comment|// Telugu
literal|0xc95
block|,
comment|// Kannada
literal|0xd15
block|,
comment|// Malayalam
literal|0xd9a
block|,
comment|// Sinhala
literal|0
block|,
comment|// Thai
literal|0
block|,
comment|// Lao
literal|0
block|,
comment|// Tibetan
literal|0x1000
block|,
comment|// Myanmar
literal|0
block|,
comment|// Georgian
literal|0
block|,
comment|// Khmer
literal|0
block|,
comment|// SimplifiedChinese
literal|0
block|,
comment|// TraditionalChinese
literal|0
block|,
comment|// Japanese
literal|0
block|,
comment|// Korean
literal|0
block|,
comment|// Vietnamese
literal|0
block|,
comment|// Symbol
literal|0x1681
block|,
comment|// Ogham
literal|0x16a0
block|,
comment|// Runic
literal|0x7ca
comment|// N'Ko
block|}
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enumerator|SampleCharCount
enum|enum
block|{
name|SampleCharCount
init|=
sizeof|sizeof
argument_list|(
name|sampleCharForWritingSystem
argument_list|)
operator|/
expr|sizeof
operator|(
name|ushort
operator|)
block|}
enum|;
end_enum
begin_comment
comment|// Newer FontConfig let's us sort out fonts that contain certain glyphs, but no
end_comment
begin_comment
comment|// open type tables for is directly. Do this so we don't pick some strange
end_comment
begin_comment
comment|// pseudo unicode font
end_comment
begin_decl_stmt
DECL|variable|openType
specifier|static
specifier|const
name|char
modifier|*
name|openType
index|[]
init|=
block|{
literal|0
block|,
comment|// Any
literal|0
block|,
comment|// Latin
literal|0
block|,
comment|// Greek
literal|0
block|,
comment|// Cyrillic
literal|0
block|,
comment|// Armenian
literal|0
block|,
comment|// Hebrew
literal|0
block|,
comment|// Arabic
literal|"syrc"
block|,
comment|// Syriac
literal|"thaa"
block|,
comment|// Thaana
literal|"deva"
block|,
comment|// Devanagari
literal|"beng"
block|,
comment|// Bengali
literal|"guru"
block|,
comment|// Gurmukhi
literal|"gurj"
block|,
comment|// Gujarati
literal|"orya"
block|,
comment|// Oriya
literal|"taml"
block|,
comment|// Tamil
literal|"telu"
block|,
comment|// Telugu
literal|"knda"
block|,
comment|// Kannada
literal|"mlym"
block|,
comment|// Malayalam
literal|"sinh"
block|,
comment|// Sinhala
literal|0
block|,
comment|// Thai
literal|0
block|,
comment|// Lao
literal|"tibt"
block|,
comment|// Tibetan
literal|"mymr"
block|,
comment|// Myanmar
literal|0
block|,
comment|// Georgian
literal|"khmr"
block|,
comment|// Khmer
literal|0
block|,
comment|// SimplifiedChinese
literal|0
block|,
comment|// TraditionalChinese
literal|0
block|,
comment|// Japanese
literal|0
block|,
comment|// Korean
literal|0
block|,
comment|// Vietnamese
literal|0
block|,
comment|// Symbol
literal|0
block|,
comment|// Ogham
literal|0
block|,
comment|// Runic
literal|"nko "
comment|// N'Ko
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|getFcFamilyForStyleHint
specifier|static
specifier|const
name|char
modifier|*
name|getFcFamilyForStyleHint
parameter_list|(
specifier|const
name|QFont
operator|::
name|StyleHint
name|style
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|stylehint
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|style
condition|)
block|{
case|case
name|QFont
operator|::
name|SansSerif
case|:
name|stylehint
operator|=
literal|"sans-serif"
expr_stmt|;
break|break;
case|case
name|QFont
operator|::
name|Serif
case|:
name|stylehint
operator|=
literal|"serif"
expr_stmt|;
break|break;
case|case
name|QFont
operator|::
name|TypeWriter
case|:
name|stylehint
operator|=
literal|"monospace"
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|stylehint
return|;
block|}
end_function
begin_function
DECL|function|populateFontDatabase
name|void
name|QFontconfigDatabase
operator|::
name|populateFontDatabase
parameter_list|()
block|{
name|FcFontSet
modifier|*
name|fonts
decl_stmt|;
name|QString
name|familyName
decl_stmt|;
name|FcChar8
modifier|*
name|value
init|=
literal|0
decl_stmt|;
name|int
name|weight_value
decl_stmt|;
name|int
name|slant_value
decl_stmt|;
name|int
name|spacing_value
decl_stmt|;
name|FcChar8
modifier|*
name|file_value
decl_stmt|;
name|int
name|indexValue
decl_stmt|;
name|FcChar8
modifier|*
name|foundry_value
decl_stmt|;
name|FcBool
name|scalable
decl_stmt|;
name|FcBool
name|antialias
decl_stmt|;
block|{
name|FcObjectSet
modifier|*
name|os
init|=
name|FcObjectSetCreate
argument_list|()
decl_stmt|;
name|FcPattern
modifier|*
name|pattern
init|=
name|FcPatternCreate
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|properties
index|[]
init|=
block|{
name|FC_FAMILY
block|,
name|FC_WEIGHT
block|,
name|FC_SLANT
block|,
name|FC_SPACING
block|,
name|FC_FILE
block|,
name|FC_INDEX
block|,
name|FC_LANG
block|,
name|FC_CHARSET
block|,
name|FC_FOUNDRY
block|,
name|FC_SCALABLE
block|,
name|FC_PIXEL_SIZE
block|,
name|FC_WEIGHT
block|,
name|FC_WIDTH
block|,
name|FC_HINT_STYLE
block|,
if|#
directive|if
name|FC_VERSION
operator|>=
literal|20297
name|FC_CAPABILITY
block|,
endif|#
directive|endif
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
init|=
name|properties
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|FcObjectSetAdd
argument_list|(
name|os
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|fonts
operator|=
name|FcFontList
argument_list|(
literal|0
argument_list|,
name|pattern
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|FcObjectSetDestroy
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|FcPatternDestroy
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fonts
operator|->
name|nfont
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FcPatternGetString
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_FAMILY
argument_list|,
literal|0
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
continue|continue;
comment|//         capitalize(value);
name|familyName
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|value
argument_list|)
expr_stmt|;
name|slant_value
operator|=
name|FC_SLANT_ROMAN
expr_stmt|;
name|weight_value
operator|=
name|FC_WEIGHT_MEDIUM
expr_stmt|;
name|spacing_value
operator|=
name|FC_PROPORTIONAL
expr_stmt|;
name|file_value
operator|=
literal|0
expr_stmt|;
name|indexValue
operator|=
literal|0
expr_stmt|;
name|scalable
operator|=
name|FcTrue
expr_stmt|;
if|if
condition|(
name|FcPatternGetInteger
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_SLANT
argument_list|,
literal|0
argument_list|,
operator|&
name|slant_value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|slant_value
operator|=
name|FC_SLANT_ROMAN
expr_stmt|;
if|if
condition|(
name|FcPatternGetInteger
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_WEIGHT
argument_list|,
literal|0
argument_list|,
operator|&
name|weight_value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|weight_value
operator|=
name|FC_WEIGHT_MEDIUM
expr_stmt|;
if|if
condition|(
name|FcPatternGetInteger
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_SPACING
argument_list|,
literal|0
argument_list|,
operator|&
name|spacing_value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|spacing_value
operator|=
name|FC_PROPORTIONAL
expr_stmt|;
if|if
condition|(
name|FcPatternGetString
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_FILE
argument_list|,
literal|0
argument_list|,
operator|&
name|file_value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|file_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FcPatternGetInteger
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_INDEX
argument_list|,
literal|0
argument_list|,
operator|&
name|indexValue
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|indexValue
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FcPatternGetBool
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_SCALABLE
argument_list|,
literal|0
argument_list|,
operator|&
name|scalable
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|scalable
operator|=
name|FcTrue
expr_stmt|;
if|if
condition|(
name|FcPatternGetString
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_FOUNDRY
argument_list|,
literal|0
argument_list|,
operator|&
name|foundry_value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|foundry_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FcPatternGetBool
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_ANTIALIAS
argument_list|,
literal|0
argument_list|,
operator|&
name|antialias
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|antialias
operator|=
literal|true
expr_stmt|;
name|QSupportedWritingSystems
name|writingSystems
decl_stmt|;
name|FcLangSet
modifier|*
name|langset
init|=
literal|0
decl_stmt|;
name|FcResult
name|res
init|=
name|FcPatternGetLangSet
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_LANG
argument_list|,
literal|0
argument_list|,
operator|&
name|langset
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|FcResultMatch
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|LanguageCount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|FcChar8
modifier|*
name|lang
init|=
operator|(
specifier|const
name|FcChar8
operator|*
operator|)
name|languageForWritingSystem
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|lang
condition|)
block|{
name|FcLangResult
name|langRes
init|=
name|FcLangSetHasLang
argument_list|(
name|langset
argument_list|,
name|lang
argument_list|)
decl_stmt|;
if|if
condition|(
name|langRes
operator|!=
name|FcLangDifferentLang
condition|)
name|writingSystems
operator|.
name|setSupported
argument_list|(
name|QFontDatabase
operator|::
name|WritingSystem
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// we set Other to supported for symbol fonts. It makes no
comment|// sense to merge these with other ones, as they are
comment|// special in a way.
name|writingSystems
operator|.
name|setSupported
argument_list|(
name|QFontDatabase
operator|::
name|Other
argument_list|)
expr_stmt|;
block|}
name|FcCharSet
modifier|*
name|cs
init|=
literal|0
decl_stmt|;
name|res
operator|=
name|FcPatternGetCharSet
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_CHARSET
argument_list|,
literal|0
argument_list|,
operator|&
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|FcResultMatch
condition|)
block|{
comment|// some languages are not supported by FontConfig, we rather check the
comment|// charset to detect these
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|SampleCharCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|sampleCharForWritingSystem
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|FcCharSetHasChar
argument_list|(
name|cs
argument_list|,
name|sampleCharForWritingSystem
index|[
name|i
index|]
argument_list|)
condition|)
name|writingSystems
operator|.
name|setSupported
argument_list|(
name|QFontDatabase
operator|::
name|WritingSystem
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|FC_VERSION
operator|>=
literal|20297
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|LanguageCount
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|writingSystems
operator|.
name|supported
argument_list|(
name|QFontDatabase
operator|::
name|WritingSystem
argument_list|(
name|j
argument_list|)
argument_list|)
operator|&&
name|requiresOpenType
argument_list|(
name|j
argument_list|)
operator|&&
name|openType
index|[
name|j
index|]
condition|)
block|{
name|FcChar8
modifier|*
name|cap
decl_stmt|;
name|res
operator|=
name|FcPatternGetString
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_CAPABILITY
argument_list|,
literal|0
argument_list|,
operator|&
name|cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|FcResultMatch
operator|||
operator|!
name|strstr
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cap
argument_list|,
name|openType
index|[
name|j
index|]
argument_list|)
condition|)
name|writingSystems
operator|.
name|setSupported
argument_list|(
name|QFontDatabase
operator|::
name|WritingSystem
argument_list|(
name|j
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|QFontEngineFT
operator|::
name|HintStyle
name|default_hint_style
decl_stmt|;
comment|// hinting
name|int
name|hint_style
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|FcPatternGetInteger
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_HINT_STYLE
argument_list|,
literal|0
argument_list|,
operator|&
name|hint_style
argument_list|)
operator|==
name|FcResultNoMatch
condition|)
name|hint_style
operator|=
name|QFontEngineFT
operator|::
name|HintFull
expr_stmt|;
switch|switch
condition|(
name|hint_style
condition|)
block|{
case|case
name|FC_HINT_NONE
case|:
name|default_hint_style
operator|=
name|QFontEngineFT
operator|::
name|HintNone
expr_stmt|;
break|break;
case|case
name|FC_HINT_SLIGHT
case|:
name|default_hint_style
operator|=
name|QFontEngineFT
operator|::
name|HintLight
expr_stmt|;
break|break;
case|case
name|FC_HINT_MEDIUM
case|:
name|default_hint_style
operator|=
name|QFontEngineFT
operator|::
name|HintMedium
expr_stmt|;
break|break;
default|default:
name|default_hint_style
operator|=
name|QFontEngineFT
operator|::
name|HintFull
expr_stmt|;
break|break;
block|}
name|FontFile
modifier|*
name|fontFile
init|=
operator|new
name|FontFile
decl_stmt|;
name|fontFile
operator|->
name|fileName
operator|=
name|QLatin1String
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|file_value
argument_list|)
expr_stmt|;
name|fontFile
operator|->
name|indexValue
operator|=
name|indexValue
expr_stmt|;
name|fontFile
operator|->
name|hintStyle
operator|=
name|default_hint_style
expr_stmt|;
name|QFont
operator|::
name|Style
name|style
init|=
operator|(
name|slant_value
operator|==
name|FC_SLANT_ITALIC
operator|)
condition|?
name|QFont
operator|::
name|StyleItalic
else|:
operator|(
operator|(
name|slant_value
operator|==
name|FC_SLANT_OBLIQUE
operator|)
condition|?
name|QFont
operator|::
name|StyleOblique
else|:
name|QFont
operator|::
name|StyleNormal
operator|)
decl_stmt|;
name|QFont
operator|::
name|Weight
name|weight
init|=
name|QFont
operator|::
name|Weight
argument_list|(
name|getFCWeight
argument_list|(
name|weight_value
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|pixel_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|scalable
condition|)
block|{
name|int
name|width
init|=
literal|100
decl_stmt|;
name|FcPatternGetInteger
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_WIDTH
argument_list|,
literal|0
argument_list|,
operator|&
name|width
argument_list|)
expr_stmt|;
name|FcPatternGetDouble
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_PIXEL_SIZE
argument_list|,
literal|0
argument_list|,
operator|&
name|pixel_size
argument_list|)
expr_stmt|;
block|}
name|QFont
operator|::
name|Stretch
name|stretch
init|=
name|QFont
operator|::
name|Unstretched
decl_stmt|;
name|QPlatformFontDatabase
operator|::
name|registerFont
argument_list|(
name|familyName
argument_list|,
name|QLatin1String
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|foundry_value
argument_list|)
argument_list|,
name|weight
argument_list|,
name|style
argument_list|,
name|stretch
argument_list|,
name|antialias
argument_list|,
name|scalable
argument_list|,
name|pixel_size
argument_list|,
name|writingSystems
argument_list|,
name|fontFile
argument_list|)
expr_stmt|;
comment|//        qDebug()<< familyName<< (const char *)foundry_value<< weight<< style<<&writingSystems<< scalable<< true<< pixel_size;
block|}
name|FcFontSetDestroy
argument_list|(
name|fonts
argument_list|)
expr_stmt|;
struct|struct
name|FcDefaultFont
block|{
specifier|const
name|char
modifier|*
name|qtname
decl_stmt|;
specifier|const
name|char
modifier|*
name|rawname
decl_stmt|;
name|bool
name|fixed
decl_stmt|;
block|}
struct|;
specifier|const
name|FcDefaultFont
name|defaults
index|[]
init|=
block|{
block|{
literal|"Serif"
block|,
literal|"serif"
block|,
literal|false
block|}
block|,
block|{
literal|"Sans Serif"
block|,
literal|"sans-serif"
block|,
literal|false
block|}
block|,
block|{
literal|"Monospace"
block|,
literal|"monospace"
block|,
literal|true
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|false
block|}
block|}
decl_stmt|;
specifier|const
name|FcDefaultFont
modifier|*
name|f
init|=
name|defaults
decl_stmt|;
comment|// aliases only make sense for 'common', not for any of the specials
name|QSupportedWritingSystems
name|ws
decl_stmt|;
name|ws
operator|.
name|setSupported
argument_list|(
name|QFontDatabase
operator|::
name|Latin
argument_list|)
expr_stmt|;
name|QString
name|familyQtName
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|f
operator|->
name|qtname
argument_list|)
decl_stmt|;
while|while
condition|(
name|f
operator|->
name|qtname
condition|)
block|{
name|registerFont
argument_list|(
name|familyQtName
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QFont
operator|::
name|Normal
argument_list|,
name|QFont
operator|::
name|StyleNormal
argument_list|,
name|QFont
operator|::
name|Unstretched
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
name|ws
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|registerFont
argument_list|(
name|familyQtName
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QFont
operator|::
name|Normal
argument_list|,
name|QFont
operator|::
name|StyleItalic
argument_list|,
name|QFont
operator|::
name|Unstretched
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
name|ws
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|registerFont
argument_list|(
name|familyQtName
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QFont
operator|::
name|Normal
argument_list|,
name|QFont
operator|::
name|StyleOblique
argument_list|,
name|QFont
operator|::
name|Unstretched
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
name|ws
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|f
expr_stmt|;
block|}
comment|//Lighthouse has very lazy population of the font db. We want it to be initialized when
comment|//QApplication is constructed, so that the population procedure can do something like this to
comment|//set the default font
comment|//    const FcDefaultFont *s = defaults;
comment|//    QFont font("Sans Serif");
comment|//    font.setPointSize(9);
comment|//    QApplication::setFont(font);
block|}
end_function
begin_function
DECL|function|fontEngine
name|QFontEngine
modifier|*
name|QFontconfigDatabase
operator|::
name|fontEngine
parameter_list|(
specifier|const
name|QFontDef
modifier|&
name|f
parameter_list|,
name|QUnicodeTables
operator|::
name|Script
name|script
parameter_list|,
name|void
modifier|*
name|usrPtr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|usrPtr
condition|)
return|return
literal|0
return|;
name|QFontDef
name|fontDef
init|=
name|f
decl_stmt|;
name|QFontEngineFT
modifier|*
name|engine
decl_stmt|;
name|FontFile
modifier|*
name|fontfile
init|=
cast|static_cast
argument_list|<
name|FontFile
operator|*
argument_list|>
argument_list|(
name|usrPtr
argument_list|)
decl_stmt|;
name|QFontEngine
operator|::
name|FaceId
name|fid
decl_stmt|;
name|fid
operator|.
name|filename
operator|=
name|fontfile
operator|->
name|fileName
operator|.
name|toLocal8Bit
argument_list|()
expr_stmt|;
name|fid
operator|.
name|index
operator|=
name|fontfile
operator|->
name|indexValue
expr_stmt|;
name|bool
name|antialias
init|=
operator|!
operator|(
name|fontDef
operator|.
name|styleStrategy
operator|&
name|QFont
operator|::
name|NoAntialias
operator|)
decl_stmt|;
name|QFontEngineFT
operator|::
name|GlyphFormat
name|format
init|=
name|antialias
condition|?
name|QFontEngineFT
operator|::
name|Format_A8
else|:
name|QFontEngineFT
operator|::
name|Format_Mono
decl_stmt|;
name|engine
operator|=
operator|new
name|QFontEngineFT
argument_list|(
name|fontDef
argument_list|)
expr_stmt|;
name|engine
operator|->
name|setDefaultHintStyle
argument_list|(
name|QFontEngineFT
operator|::
name|HintStyle
argument_list|(
name|fontfile
operator|->
name|hintStyle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|engine
operator|->
name|init
argument_list|(
name|fid
argument_list|,
name|antialias
argument_list|,
name|format
argument_list|)
condition|)
block|{
operator|delete
name|engine
expr_stmt|;
name|engine
operator|=
literal|0
expr_stmt|;
return|return
name|engine
return|;
block|}
if|if
condition|(
name|engine
operator|->
name|invalid
argument_list|()
condition|)
block|{
operator|delete
name|engine
expr_stmt|;
name|engine
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scriptRequiresOpenType
argument_list|(
name|script
argument_list|)
condition|)
block|{
name|HB_Face
name|hbFace
init|=
name|engine
operator|->
name|harfbuzzFace
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hbFace
operator|||
operator|!
name|hbFace
operator|->
name|supported_scripts
index|[
name|script
index|]
condition|)
block|{
operator|delete
name|engine
expr_stmt|;
name|engine
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|engine
return|;
block|}
end_function
begin_function
DECL|function|fallbacksForFamily
name|QStringList
name|QFontconfigDatabase
operator|::
name|fallbacksForFamily
parameter_list|(
specifier|const
name|QString
name|family
parameter_list|,
specifier|const
name|QFont
operator|::
name|Style
modifier|&
name|style
parameter_list|,
specifier|const
name|QFont
operator|::
name|StyleHint
modifier|&
name|styleHint
parameter_list|,
specifier|const
name|QUnicodeTables
operator|::
name|Script
modifier|&
name|script
parameter_list|)
specifier|const
block|{
name|QStringList
name|fallbackFamilies
decl_stmt|;
name|FcPattern
modifier|*
name|pattern
init|=
name|FcPatternCreate
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pattern
condition|)
return|return
name|fallbackFamilies
return|;
name|FcValue
name|value
decl_stmt|;
name|value
operator|.
name|type
operator|=
name|FcTypeString
expr_stmt|;
name|QByteArray
name|cs
init|=
name|family
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
name|value
operator|.
name|u
operator|.
name|s
operator|=
operator|(
specifier|const
name|FcChar8
operator|*
operator|)
name|cs
operator|.
name|data
argument_list|()
expr_stmt|;
name|FcPatternAdd
argument_list|(
name|pattern
argument_list|,
name|FC_FAMILY
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|int
name|slant_value
init|=
name|FC_SLANT_ROMAN
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|QFont
operator|::
name|StyleItalic
condition|)
name|slant_value
operator|=
name|FC_SLANT_ITALIC
expr_stmt|;
elseif|else
if|if
condition|(
name|style
operator|==
name|QFont
operator|::
name|StyleOblique
condition|)
name|slant_value
operator|=
name|FC_SLANT_OBLIQUE
expr_stmt|;
name|FcPatternAddInteger
argument_list|(
name|pattern
argument_list|,
name|FC_SLANT
argument_list|,
name|slant_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|script
operator|!=
name|QUnicodeTables
operator|::
name|Common
operator|&&
operator|*
name|specialLanguages
index|[
name|script
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|script
operator|<
name|QUnicodeTables
operator|::
name|ScriptCount
argument_list|)
expr_stmt|;
name|FcLangSet
modifier|*
name|ls
init|=
name|FcLangSetCreate
argument_list|()
decl_stmt|;
name|FcLangSetAdd
argument_list|(
name|ls
argument_list|,
operator|(
specifier|const
name|FcChar8
operator|*
operator|)
name|specialLanguages
index|[
name|script
index|]
argument_list|)
expr_stmt|;
name|FcPatternAddLangSet
argument_list|(
name|pattern
argument_list|,
name|FC_LANG
argument_list|,
name|ls
argument_list|)
expr_stmt|;
name|FcLangSetDestroy
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
specifier|const
name|char
modifier|*
name|stylehint
init|=
name|getFcFamilyForStyleHint
argument_list|(
name|styleHint
argument_list|)
decl_stmt|;
if|if
condition|(
name|stylehint
condition|)
block|{
name|value
operator|.
name|u
operator|.
name|s
operator|=
operator|(
specifier|const
name|FcChar8
operator|*
operator|)
name|stylehint
expr_stmt|;
name|FcPatternAddWeak
argument_list|(
name|pattern
argument_list|,
name|FC_FAMILY
argument_list|,
name|value
argument_list|,
name|FcTrue
argument_list|)
expr_stmt|;
block|}
name|FcConfigSubstitute
argument_list|(
literal|0
argument_list|,
name|pattern
argument_list|,
name|FcMatchPattern
argument_list|)
expr_stmt|;
name|FcDefaultSubstitute
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|FcResult
name|result
init|=
name|FcResultMatch
decl_stmt|;
name|FcFontSet
modifier|*
name|fontSet
init|=
name|FcFontSort
argument_list|(
literal|0
argument_list|,
name|pattern
argument_list|,
name|FcFalse
argument_list|,
literal|0
argument_list|,
operator|&
name|result
argument_list|)
decl_stmt|;
name|FcPatternDestroy
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontSet
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|FcResultMatch
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fontSet
operator|->
name|nfont
condition|;
name|i
operator|++
control|)
block|{
name|FcChar8
modifier|*
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|FcPatternGetString
argument_list|(
name|fontSet
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_FAMILY
argument_list|,
literal|0
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
continue|continue;
comment|//         capitalize(value);
name|QString
name|familyName
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fallbackFamilies
operator|.
name|contains
argument_list|(
name|familyName
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|&&
name|familyName
operator|.
name|compare
argument_list|(
name|family
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
block|{
name|fallbackFamilies
operator|<<
name|familyName
expr_stmt|;
block|}
block|}
block|}
name|FcFontSetDestroy
argument_list|(
name|fontSet
argument_list|)
expr_stmt|;
block|}
comment|//    qDebug()<< "fallbackFamilies for:"<< family<< style<< styleHint<< script<< fallbackFamilies;
return|return
name|fallbackFamilies
return|;
block|}
end_function
end_unit
