begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qfontconfigdatabase_p.h"
end_include
begin_include
include|#
directive|include
file|"qfontenginemultifontconfig_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/QList>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qfont_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/QElapsedTimer>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformnativeinterface.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformscreen.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformintegration.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformservices.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qfontengine_ft_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qfontengine_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qfontengine_qpa_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qguiapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qguiapplication.h>
end_include
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TABLES_H
end_include
begin_include
include|#
directive|include
file|<fontconfig/fontconfig.h>
end_include
begin_include
include|#
directive|include
include|FT_FREETYPE_H
end_include
begin_if
if|#
directive|if
name|FC_VERSION
operator|>=
literal|20402
end_if
begin_include
include|#
directive|include
file|<fontconfig/fcfreetype.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|SimplifiedChineseCsbBit
define|#
directive|define
name|SimplifiedChineseCsbBit
value|18
end_define
begin_define
DECL|macro|TraditionalChineseCsbBit
define|#
directive|define
name|TraditionalChineseCsbBit
value|20
end_define
begin_define
DECL|macro|JapaneseCsbBit
define|#
directive|define
name|JapaneseCsbBit
value|17
end_define
begin_define
DECL|macro|KoreanCsbBit
define|#
directive|define
name|KoreanCsbBit
value|21
end_define
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|requiresOpenType
specifier|static
specifier|inline
name|bool
name|requiresOpenType
parameter_list|(
name|int
name|writingSystem
parameter_list|)
block|{
return|return
operator|(
operator|(
name|writingSystem
operator|>=
name|QFontDatabase
operator|::
name|Syriac
operator|&&
name|writingSystem
operator|<=
name|QFontDatabase
operator|::
name|Sinhala
operator|)
operator|||
name|writingSystem
operator|==
name|QFontDatabase
operator|::
name|Khmer
operator|||
name|writingSystem
operator|==
name|QFontDatabase
operator|::
name|Nko
operator|)
return|;
block|}
end_function
begin_function
DECL|function|scriptRequiresOpenType
specifier|static
specifier|inline
name|bool
name|scriptRequiresOpenType
parameter_list|(
name|int
name|script
parameter_list|)
block|{
return|return
operator|(
operator|(
name|script
operator|>=
name|QChar
operator|::
name|Script_Syriac
operator|&&
name|script
operator|<=
name|QChar
operator|::
name|Script_Sinhala
operator|)
operator|||
name|script
operator|==
name|QChar
operator|::
name|Script_Khmer
operator|||
name|script
operator|==
name|QChar
operator|::
name|Script_Nko
operator|)
return|;
block|}
end_function
begin_function
DECL|function|getFCWeight
specifier|static
name|int
name|getFCWeight
parameter_list|(
name|int
name|fc_weight
parameter_list|)
block|{
name|int
name|qtweight
init|=
name|QFont
operator|::
name|Black
decl_stmt|;
if|if
condition|(
name|fc_weight
operator|<=
operator|(
name|FC_WEIGHT_LIGHT
operator|+
name|FC_WEIGHT_REGULAR
operator|)
operator|/
literal|2
condition|)
name|qtweight
operator|=
name|QFont
operator|::
name|Light
expr_stmt|;
elseif|else
if|if
condition|(
name|fc_weight
operator|<=
operator|(
name|FC_WEIGHT_REGULAR
operator|+
name|FC_WEIGHT_MEDIUM
operator|)
operator|/
literal|2
condition|)
name|qtweight
operator|=
name|QFont
operator|::
name|Normal
expr_stmt|;
elseif|else
if|if
condition|(
name|fc_weight
operator|<=
operator|(
name|FC_WEIGHT_MEDIUM
operator|+
name|FC_WEIGHT_BOLD
operator|)
operator|/
literal|2
condition|)
name|qtweight
operator|=
name|QFont
operator|::
name|DemiBold
expr_stmt|;
elseif|else
if|if
condition|(
name|fc_weight
operator|<=
operator|(
name|FC_WEIGHT_BOLD
operator|+
name|FC_WEIGHT_BLACK
operator|)
operator|/
literal|2
condition|)
name|qtweight
operator|=
name|QFont
operator|::
name|Bold
expr_stmt|;
return|return
name|qtweight
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|specialLanguages
specifier|static
specifier|const
name|char
modifier|*
name|specialLanguages
index|[]
init|=
block|{
literal|""
block|,
comment|// Unknown
literal|""
block|,
comment|// Inherited
literal|""
block|,
comment|// Common
literal|"en"
block|,
comment|// Latin
literal|"el"
block|,
comment|// Greek
literal|"ru"
block|,
comment|// Cyrillic
literal|"hy"
block|,
comment|// Armenian
literal|"he"
block|,
comment|// Hebrew
literal|"ar"
block|,
comment|// Arabic
literal|"syr"
block|,
comment|// Syriac
literal|"dv"
block|,
comment|// Thaana
literal|"hi"
block|,
comment|// Devanagari
literal|"bn"
block|,
comment|// Bengali
literal|"pa"
block|,
comment|// Gurmukhi
literal|"gu"
block|,
comment|// Gujarati
literal|"or"
block|,
comment|// Oriya
literal|"ta"
block|,
comment|// Tamil
literal|"te"
block|,
comment|// Telugu
literal|"kn"
block|,
comment|// Kannada
literal|"ml"
block|,
comment|// Malayalam
literal|"si"
block|,
comment|// Sinhala
literal|"th"
block|,
comment|// Thai
literal|"lo"
block|,
comment|// Lao
literal|"bo"
block|,
comment|// Tibetan
literal|"my"
block|,
comment|// Myanmar
literal|"ka"
block|,
comment|// Georgian
literal|"ko"
block|,
comment|// Hangul
literal|"am"
block|,
comment|// Ethiopic
literal|"chr"
block|,
comment|// Cherokee
literal|"cr"
block|,
comment|// CanadianAboriginal
literal|"sga"
block|,
comment|// Ogham
literal|"non"
block|,
comment|// Runic
literal|"km"
block|,
comment|// Khmer
literal|"mn"
block|,
comment|// Mongolian
literal|"ja"
block|,
comment|// Hiragana
literal|"ja"
block|,
comment|// Katakana
literal|"zh-TW"
block|,
comment|// Bopomofo
literal|""
block|,
comment|// Han
literal|"ii"
block|,
comment|// Yi
literal|"ett"
block|,
comment|// OldItalic
literal|"got"
block|,
comment|// Gothic
literal|"en"
block|,
comment|// Deseret
literal|"fil"
block|,
comment|// Tagalog
literal|"hnn"
block|,
comment|// Hanunoo
literal|"bku"
block|,
comment|// Buhid
literal|"tbw"
block|,
comment|// Tagbanwa
literal|"cop"
block|,
comment|// Coptic
literal|"lif"
block|,
comment|// Limbu
literal|"tdd"
block|,
comment|// TaiLe
literal|"grc"
block|,
comment|// LinearB
literal|"uga"
block|,
comment|// Ugaritic
literal|"en"
block|,
comment|// Shavian
literal|"so"
block|,
comment|// Osmanya
literal|"grc"
block|,
comment|// Cypriot
literal|""
block|,
comment|// Braille
literal|"bug"
block|,
comment|// Buginese
literal|"khb"
block|,
comment|// NewTaiLue
literal|"cu"
block|,
comment|// Glagolitic
literal|"shi"
block|,
comment|// Tifinagh
literal|"syl"
block|,
comment|// SylotiNagri
literal|"peo"
block|,
comment|// OldPersian
literal|"pra"
block|,
comment|// Kharoshthi
literal|"ban"
block|,
comment|// Balinese
literal|"akk"
block|,
comment|// Cuneiform
literal|"phn"
block|,
comment|// Phoenician
literal|"lzh"
block|,
comment|// PhagsPa
literal|"man"
block|,
comment|// Nko
literal|"su"
block|,
comment|// Sundanese
literal|"lep"
block|,
comment|// Lepcha
literal|"sat"
block|,
comment|// OlChiki
literal|"vai"
block|,
comment|// Vai
literal|"saz"
block|,
comment|// Saurashtra
literal|"eky"
block|,
comment|// KayahLi
literal|"rej"
block|,
comment|// Rejang
literal|"xlc"
block|,
comment|// Lycian
literal|"xcr"
block|,
comment|// Carian
literal|"xld"
block|,
comment|// Lydian
literal|"cjm"
block|,
comment|// Cham
literal|"nod"
block|,
comment|// TaiTham
literal|"blt"
block|,
comment|// TaiViet
literal|"ae"
block|,
comment|// Avestan
literal|"egy"
block|,
comment|// EgyptianHieroglyphs
literal|"smp"
block|,
comment|// Samaritan
literal|"lis"
block|,
comment|// Lisu
literal|"bax"
block|,
comment|// Bamum
literal|"jv"
block|,
comment|// Javanese
literal|"mni"
block|,
comment|// MeeteiMayek
literal|"arc"
block|,
comment|// ImperialAramaic
literal|"xsa"
block|,
comment|// OldSouthArabian
literal|"xpr"
block|,
comment|// InscriptionalParthian
literal|"pal"
block|,
comment|// InscriptionalPahlavi
literal|"otk"
block|,
comment|// OldTurkic
literal|"bh"
block|,
comment|// Kaithi
literal|"bbc"
block|,
comment|// Batak
literal|"pra"
block|,
comment|// Brahmi
literal|"myz"
block|,
comment|// Mandaic
literal|"ccp"
block|,
comment|// Chakma
literal|"xmr"
block|,
comment|// MeroiticCursive
literal|"xmr"
block|,
comment|// MeroiticHieroglyphs
literal|"hmd"
block|,
comment|// Miao
literal|"sa"
block|,
comment|// Sharada
literal|"srb"
block|,
comment|// SoraSompeng
literal|"doi"
comment|// Takri
block|}
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enumerator|SpecialLanguageCount
enum|enum
block|{
name|SpecialLanguageCount
init|=
sizeof|sizeof
argument_list|(
name|specialLanguages
argument_list|)
operator|/
expr|sizeof
operator|(
specifier|const
name|char
operator|*
operator|)
block|}
enum|;
end_enum
begin_comment
comment|// this could become a list of all languages used for each writing
end_comment
begin_comment
comment|// system, instead of using the single most common language.
end_comment
begin_decl_stmt
DECL|variable|languageForWritingSystem
specifier|static
specifier|const
name|char
modifier|*
name|languageForWritingSystem
index|[]
init|=
block|{
literal|0
block|,
comment|// Any
literal|"en"
block|,
comment|// Latin
literal|"el"
block|,
comment|// Greek
literal|"ru"
block|,
comment|// Cyrillic
literal|"hy"
block|,
comment|// Armenian
literal|"he"
block|,
comment|// Hebrew
literal|"ar"
block|,
comment|// Arabic
literal|"syr"
block|,
comment|// Syriac
literal|"div"
block|,
comment|// Thaana
literal|"hi"
block|,
comment|// Devanagari
literal|"bn"
block|,
comment|// Bengali
literal|"pa"
block|,
comment|// Gurmukhi
literal|"gu"
block|,
comment|// Gujarati
literal|"or"
block|,
comment|// Oriya
literal|"ta"
block|,
comment|// Tamil
literal|"te"
block|,
comment|// Telugu
literal|"kn"
block|,
comment|// Kannada
literal|"ml"
block|,
comment|// Malayalam
literal|"si"
block|,
comment|// Sinhala
literal|"th"
block|,
comment|// Thai
literal|"lo"
block|,
comment|// Lao
literal|"bo"
block|,
comment|// Tibetan
literal|"my"
block|,
comment|// Myanmar
literal|"ka"
block|,
comment|// Georgian
literal|"km"
block|,
comment|// Khmer
literal|"zh-cn"
block|,
comment|// SimplifiedChinese
literal|"zh-tw"
block|,
comment|// TraditionalChinese
literal|"ja"
block|,
comment|// Japanese
literal|"ko"
block|,
comment|// Korean
literal|"vi"
block|,
comment|// Vietnamese
literal|0
block|,
comment|// Symbol
literal|"sga"
block|,
comment|// Ogham
literal|"non"
block|,
comment|// Runic
literal|"man"
comment|// N'Ko
block|}
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enumerator|LanguageCount
enum|enum
block|{
name|LanguageCount
init|=
sizeof|sizeof
argument_list|(
name|languageForWritingSystem
argument_list|)
operator|/
expr|sizeof
operator|(
specifier|const
name|char
operator|*
operator|)
block|}
enum|;
end_enum
begin_comment
comment|// Unfortunately FontConfig doesn't know about some languages. We have to test these through the
end_comment
begin_comment
comment|// charset. The lists below contain the systems where we need to do this.
end_comment
begin_decl_stmt
DECL|variable|sampleCharForWritingSystem
specifier|static
specifier|const
name|ushort
name|sampleCharForWritingSystem
index|[]
init|=
block|{
literal|0
block|,
comment|// Any
literal|0
block|,
comment|// Latin
literal|0
block|,
comment|// Greek
literal|0
block|,
comment|// Cyrillic
literal|0
block|,
comment|// Armenian
literal|0
block|,
comment|// Hebrew
literal|0
block|,
comment|// Arabic
literal|0
block|,
comment|// Syriac
literal|0
block|,
comment|// Thaana
literal|0
block|,
comment|// Devanagari
literal|0
block|,
comment|// Bengali
literal|0
block|,
comment|// Gurmukhi
literal|0
block|,
comment|// Gujarati
literal|0
block|,
comment|// Oriya
literal|0
block|,
comment|// Tamil
literal|0xc15
block|,
comment|// Telugu
literal|0xc95
block|,
comment|// Kannada
literal|0xd15
block|,
comment|// Malayalam
literal|0xd9a
block|,
comment|// Sinhala
literal|0
block|,
comment|// Thai
literal|0
block|,
comment|// Lao
literal|0
block|,
comment|// Tibetan
literal|0x1000
block|,
comment|// Myanmar
literal|0
block|,
comment|// Georgian
literal|0
block|,
comment|// Khmer
literal|0
block|,
comment|// SimplifiedChinese
literal|0
block|,
comment|// TraditionalChinese
literal|0
block|,
comment|// Japanese
literal|0
block|,
comment|// Korean
literal|0
block|,
comment|// Vietnamese
literal|0
block|,
comment|// Symbol
literal|0x1681
block|,
comment|// Ogham
literal|0x16a0
block|,
comment|// Runic
literal|0x7ca
comment|// N'Ko
block|}
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enumerator|SampleCharCount
enum|enum
block|{
name|SampleCharCount
init|=
sizeof|sizeof
argument_list|(
name|sampleCharForWritingSystem
argument_list|)
operator|/
expr|sizeof
operator|(
name|ushort
operator|)
block|}
enum|;
end_enum
begin_comment
comment|// Newer FontConfig let's us sort out fonts that contain certain glyphs, but no
end_comment
begin_comment
comment|// open type tables for is directly. Do this so we don't pick some strange
end_comment
begin_comment
comment|// pseudo unicode font
end_comment
begin_decl_stmt
DECL|variable|openType
specifier|static
specifier|const
name|char
modifier|*
name|openType
index|[]
init|=
block|{
literal|0
block|,
comment|// Any
literal|0
block|,
comment|// Latin
literal|0
block|,
comment|// Greek
literal|0
block|,
comment|// Cyrillic
literal|0
block|,
comment|// Armenian
literal|0
block|,
comment|// Hebrew
literal|0
block|,
comment|// Arabic
literal|"syrc"
block|,
comment|// Syriac
literal|"thaa"
block|,
comment|// Thaana
literal|"deva"
block|,
comment|// Devanagari
literal|"beng"
block|,
comment|// Bengali
literal|"guru"
block|,
comment|// Gurmukhi
literal|"gurj"
block|,
comment|// Gujarati
literal|"orya"
block|,
comment|// Oriya
literal|"taml"
block|,
comment|// Tamil
literal|"telu"
block|,
comment|// Telugu
literal|"knda"
block|,
comment|// Kannada
literal|"mlym"
block|,
comment|// Malayalam
literal|"sinh"
block|,
comment|// Sinhala
literal|0
block|,
comment|// Thai
literal|0
block|,
comment|// Lao
literal|"tibt"
block|,
comment|// Tibetan
literal|"mymr"
block|,
comment|// Myanmar
literal|0
block|,
comment|// Georgian
literal|"khmr"
block|,
comment|// Khmer
literal|0
block|,
comment|// SimplifiedChinese
literal|0
block|,
comment|// TraditionalChinese
literal|0
block|,
comment|// Japanese
literal|0
block|,
comment|// Korean
literal|0
block|,
comment|// Vietnamese
literal|0
block|,
comment|// Symbol
literal|0
block|,
comment|// Ogham
literal|0
block|,
comment|// Runic
literal|"nko "
comment|// N'Ko
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|getFcFamilyForStyleHint
specifier|static
specifier|const
name|char
modifier|*
name|getFcFamilyForStyleHint
parameter_list|(
specifier|const
name|QFont
operator|::
name|StyleHint
name|style
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|stylehint
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|style
condition|)
block|{
case|case
name|QFont
operator|::
name|SansSerif
case|:
name|stylehint
operator|=
literal|"sans-serif"
expr_stmt|;
break|break;
case|case
name|QFont
operator|::
name|Serif
case|:
name|stylehint
operator|=
literal|"serif"
expr_stmt|;
break|break;
case|case
name|QFont
operator|::
name|TypeWriter
case|:
case|case
name|QFont
operator|::
name|Monospace
case|:
name|stylehint
operator|=
literal|"monospace"
expr_stmt|;
break|break;
case|case
name|QFont
operator|::
name|Cursive
case|:
name|stylehint
operator|=
literal|"cursive"
expr_stmt|;
break|break;
case|case
name|QFont
operator|::
name|Fantasy
case|:
name|stylehint
operator|=
literal|"fantasy"
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|stylehint
return|;
block|}
end_function
begin_function
DECL|function|isSymbolFont
specifier|static
name|bool
name|isSymbolFont
parameter_list|(
name|FontFile
modifier|*
name|fontFile
parameter_list|)
block|{
if|if
condition|(
name|fontFile
operator|==
literal|0
operator|||
name|fontFile
operator|->
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QFontEngine
operator|::
name|FaceId
name|id
decl_stmt|;
name|id
operator|.
name|filename
operator|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|fontFile
operator|->
name|fileName
argument_list|)
expr_stmt|;
name|id
operator|.
name|index
operator|=
name|fontFile
operator|->
name|indexValue
expr_stmt|;
name|QFreetypeFace
modifier|*
name|f
init|=
name|QFreetypeFace
operator|::
name|getFace
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"isSymbolFont: Couldn't open face %s/%d"
argument_list|,
name|id
operator|.
name|filename
operator|.
name|data
argument_list|()
argument_list|,
name|id
operator|.
name|index
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|bool
name|hasSymbolMap
init|=
name|f
operator|->
name|symbol_map
decl_stmt|;
name|f
operator|->
name|release
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return
name|hasSymbolMap
return|;
block|}
end_function
begin_function_decl
name|Q_GUI_EXPORT
name|void
name|qt_registerAliasToFontFamily
parameter_list|(
specifier|const
name|QString
modifier|&
name|familyName
parameter_list|,
specifier|const
name|QString
modifier|&
name|alias
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|populateFontDatabase
name|void
name|QFontconfigDatabase
operator|::
name|populateFontDatabase
parameter_list|()
block|{
name|FcFontSet
modifier|*
name|fonts
decl_stmt|;
name|QString
name|familyName
decl_stmt|;
name|FcChar8
modifier|*
name|value
init|=
literal|0
decl_stmt|;
name|int
name|weight_value
decl_stmt|;
name|int
name|slant_value
decl_stmt|;
name|int
name|spacing_value
decl_stmt|;
name|FcChar8
modifier|*
name|file_value
decl_stmt|;
name|int
name|indexValue
decl_stmt|;
name|FcChar8
modifier|*
name|foundry_value
decl_stmt|;
name|FcChar8
modifier|*
name|style_value
decl_stmt|;
name|FcBool
name|scalable
decl_stmt|;
name|FcBool
name|antialias
decl_stmt|;
block|{
name|FcObjectSet
modifier|*
name|os
init|=
name|FcObjectSetCreate
argument_list|()
decl_stmt|;
name|FcPattern
modifier|*
name|pattern
init|=
name|FcPatternCreate
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|properties
index|[]
init|=
block|{
name|FC_FAMILY
block|,
name|FC_STYLE
block|,
name|FC_WEIGHT
block|,
name|FC_SLANT
block|,
name|FC_SPACING
block|,
name|FC_FILE
block|,
name|FC_INDEX
block|,
name|FC_LANG
block|,
name|FC_CHARSET
block|,
name|FC_FOUNDRY
block|,
name|FC_SCALABLE
block|,
name|FC_PIXEL_SIZE
block|,
name|FC_WEIGHT
block|,
name|FC_WIDTH
block|,
if|#
directive|if
name|FC_VERSION
operator|>=
literal|20297
name|FC_CAPABILITY
block|,
endif|#
directive|endif
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
init|=
name|properties
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|FcObjectSetAdd
argument_list|(
name|os
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|fonts
operator|=
name|FcFontList
argument_list|(
literal|0
argument_list|,
name|pattern
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|FcObjectSetDestroy
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|FcPatternDestroy
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fonts
operator|->
name|nfont
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FcPatternGetString
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_FAMILY
argument_list|,
literal|0
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
continue|continue;
comment|//         capitalize(value);
name|familyName
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|value
argument_list|)
expr_stmt|;
name|slant_value
operator|=
name|FC_SLANT_ROMAN
expr_stmt|;
name|weight_value
operator|=
name|FC_WEIGHT_REGULAR
expr_stmt|;
name|spacing_value
operator|=
name|FC_PROPORTIONAL
expr_stmt|;
name|file_value
operator|=
literal|0
expr_stmt|;
name|indexValue
operator|=
literal|0
expr_stmt|;
name|scalable
operator|=
name|FcTrue
expr_stmt|;
if|if
condition|(
name|FcPatternGetInteger
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_SLANT
argument_list|,
literal|0
argument_list|,
operator|&
name|slant_value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|slant_value
operator|=
name|FC_SLANT_ROMAN
expr_stmt|;
if|if
condition|(
name|FcPatternGetInteger
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_WEIGHT
argument_list|,
literal|0
argument_list|,
operator|&
name|weight_value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|weight_value
operator|=
name|FC_WEIGHT_REGULAR
expr_stmt|;
if|if
condition|(
name|FcPatternGetInteger
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_SPACING
argument_list|,
literal|0
argument_list|,
operator|&
name|spacing_value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|spacing_value
operator|=
name|FC_PROPORTIONAL
expr_stmt|;
if|if
condition|(
name|FcPatternGetString
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_FILE
argument_list|,
literal|0
argument_list|,
operator|&
name|file_value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|file_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FcPatternGetInteger
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_INDEX
argument_list|,
literal|0
argument_list|,
operator|&
name|indexValue
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|indexValue
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FcPatternGetBool
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_SCALABLE
argument_list|,
literal|0
argument_list|,
operator|&
name|scalable
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|scalable
operator|=
name|FcTrue
expr_stmt|;
if|if
condition|(
name|FcPatternGetString
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_FOUNDRY
argument_list|,
literal|0
argument_list|,
operator|&
name|foundry_value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|foundry_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FcPatternGetString
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_STYLE
argument_list|,
literal|0
argument_list|,
operator|&
name|style_value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|style_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FcPatternGetBool
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_ANTIALIAS
argument_list|,
literal|0
argument_list|,
operator|&
name|antialias
argument_list|)
operator|!=
name|FcResultMatch
condition|)
name|antialias
operator|=
literal|true
expr_stmt|;
name|QSupportedWritingSystems
name|writingSystems
decl_stmt|;
name|FcLangSet
modifier|*
name|langset
init|=
literal|0
decl_stmt|;
name|FcResult
name|res
init|=
name|FcPatternGetLangSet
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_LANG
argument_list|,
literal|0
argument_list|,
operator|&
name|langset
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|FcResultMatch
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|LanguageCount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|FcChar8
modifier|*
name|lang
init|=
operator|(
specifier|const
name|FcChar8
operator|*
operator|)
name|languageForWritingSystem
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|lang
condition|)
block|{
name|FcLangResult
name|langRes
init|=
name|FcLangSetHasLang
argument_list|(
name|langset
argument_list|,
name|lang
argument_list|)
decl_stmt|;
if|if
condition|(
name|langRes
operator|!=
name|FcLangDifferentLang
condition|)
name|writingSystems
operator|.
name|setSupported
argument_list|(
name|QFontDatabase
operator|::
name|WritingSystem
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// we set Other to supported for symbol fonts. It makes no
comment|// sense to merge these with other ones, as they are
comment|// special in a way.
name|writingSystems
operator|.
name|setSupported
argument_list|(
name|QFontDatabase
operator|::
name|Other
argument_list|)
expr_stmt|;
block|}
name|FcCharSet
modifier|*
name|cs
init|=
literal|0
decl_stmt|;
name|res
operator|=
name|FcPatternGetCharSet
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_CHARSET
argument_list|,
literal|0
argument_list|,
operator|&
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|FcResultMatch
condition|)
block|{
comment|// some languages are not supported by FontConfig, we rather check the
comment|// charset to detect these
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|SampleCharCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|sampleCharForWritingSystem
index|[
name|i
index|]
operator|||
name|writingSystems
operator|.
name|supported
argument_list|(
name|QFontDatabase
operator|::
name|WritingSystem
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|FcCharSetHasChar
argument_list|(
name|cs
argument_list|,
name|sampleCharForWritingSystem
index|[
name|i
index|]
argument_list|)
condition|)
name|writingSystems
operator|.
name|setSupported
argument_list|(
name|QFontDatabase
operator|::
name|WritingSystem
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|FC_VERSION
operator|>=
literal|20297
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|LanguageCount
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|writingSystems
operator|.
name|supported
argument_list|(
name|QFontDatabase
operator|::
name|WritingSystem
argument_list|(
name|j
argument_list|)
argument_list|)
operator|&&
name|requiresOpenType
argument_list|(
name|j
argument_list|)
operator|&&
name|openType
index|[
name|j
index|]
condition|)
block|{
name|FcChar8
modifier|*
name|cap
decl_stmt|;
name|res
operator|=
name|FcPatternGetString
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_CAPABILITY
argument_list|,
literal|0
argument_list|,
operator|&
name|cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|FcResultMatch
operator|||
operator|!
name|strstr
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cap
argument_list|,
name|openType
index|[
name|j
index|]
argument_list|)
condition|)
name|writingSystems
operator|.
name|setSupported
argument_list|(
name|QFontDatabase
operator|::
name|WritingSystem
argument_list|(
name|j
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|FontFile
modifier|*
name|fontFile
init|=
operator|new
name|FontFile
decl_stmt|;
name|fontFile
operator|->
name|fileName
operator|=
name|QLatin1String
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|file_value
argument_list|)
expr_stmt|;
name|fontFile
operator|->
name|indexValue
operator|=
name|indexValue
expr_stmt|;
if|if
condition|(
operator|!
name|writingSystems
operator|.
name|supported
argument_list|(
name|QFontDatabase
operator|::
name|Symbol
argument_list|)
condition|)
block|{
comment|// Symbol encoding used to encode various crap in the 32..255 character
comment|// code range, which belongs to Latin character code range.
comment|// Symbol fonts usually don't have any other code ranges support.
name|bool
name|mightBeSymbolFont
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|2
init|;
name|j
operator|<
name|QFontDatabase
operator|::
name|WritingSystemsCount
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|writingSystems
operator|.
name|supported
argument_list|(
name|QFontDatabase
operator|::
name|WritingSystem
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
block|{
name|mightBeSymbolFont
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|mightBeSymbolFont
operator|&&
name|isSymbolFont
argument_list|(
name|fontFile
argument_list|)
condition|)
block|{
name|writingSystems
operator|.
name|setSupported
argument_list|(
name|QFontDatabase
operator|::
name|Latin
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|writingSystems
operator|.
name|setSupported
argument_list|(
name|QFontDatabase
operator|::
name|Symbol
argument_list|)
expr_stmt|;
block|}
block|}
name|QFont
operator|::
name|Style
name|style
init|=
operator|(
name|slant_value
operator|==
name|FC_SLANT_ITALIC
operator|)
condition|?
name|QFont
operator|::
name|StyleItalic
else|:
operator|(
operator|(
name|slant_value
operator|==
name|FC_SLANT_OBLIQUE
operator|)
condition|?
name|QFont
operator|::
name|StyleOblique
else|:
name|QFont
operator|::
name|StyleNormal
operator|)
decl_stmt|;
name|QFont
operator|::
name|Weight
name|weight
init|=
name|QFont
operator|::
name|Weight
argument_list|(
name|getFCWeight
argument_list|(
name|weight_value
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|pixel_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|scalable
condition|)
block|{
name|int
name|width
init|=
literal|100
decl_stmt|;
name|FcPatternGetInteger
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_WIDTH
argument_list|,
literal|0
argument_list|,
operator|&
name|width
argument_list|)
expr_stmt|;
name|FcPatternGetDouble
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_PIXEL_SIZE
argument_list|,
literal|0
argument_list|,
operator|&
name|pixel_size
argument_list|)
expr_stmt|;
block|}
name|bool
name|fixedPitch
init|=
name|spacing_value
operator|>=
name|FC_MONO
decl_stmt|;
name|QFont
operator|::
name|Stretch
name|stretch
init|=
name|QFont
operator|::
name|Unstretched
decl_stmt|;
name|QString
name|styleName
init|=
name|style_value
condition|?
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|style_value
argument_list|)
else|:
name|QString
argument_list|()
decl_stmt|;
name|QPlatformFontDatabase
operator|::
name|registerFont
argument_list|(
name|familyName
argument_list|,
name|styleName
argument_list|,
name|QLatin1String
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|foundry_value
argument_list|)
argument_list|,
name|weight
argument_list|,
name|style
argument_list|,
name|stretch
argument_list|,
name|antialias
argument_list|,
name|scalable
argument_list|,
name|pixel_size
argument_list|,
name|fixedPitch
argument_list|,
name|writingSystems
argument_list|,
name|fontFile
argument_list|)
expr_stmt|;
comment|//        qDebug()<< familyName<< (const char *)foundry_value<< weight<< style<<&writingSystems<< scalable<< true<< pixel_size;
for|for
control|(
name|int
name|k
init|=
literal|1
init|;
name|FcPatternGetString
argument_list|(
name|fonts
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_FAMILY
argument_list|,
name|k
argument_list|,
operator|&
name|value
argument_list|)
operator|==
name|FcResultMatch
condition|;
operator|++
name|k
control|)
name|qt_registerAliasToFontFamily
argument_list|(
name|familyName
argument_list|,
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FcFontSetDestroy
argument_list|(
name|fonts
argument_list|)
expr_stmt|;
struct|struct
name|FcDefaultFont
block|{
specifier|const
name|char
modifier|*
name|qtname
decl_stmt|;
specifier|const
name|char
modifier|*
name|rawname
decl_stmt|;
name|bool
name|fixed
decl_stmt|;
block|}
struct|;
specifier|const
name|FcDefaultFont
name|defaults
index|[]
init|=
block|{
block|{
literal|"Serif"
block|,
literal|"serif"
block|,
literal|false
block|}
block|,
block|{
literal|"Sans Serif"
block|,
literal|"sans-serif"
block|,
literal|false
block|}
block|,
block|{
literal|"Monospace"
block|,
literal|"monospace"
block|,
literal|true
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|false
block|}
block|}
decl_stmt|;
specifier|const
name|FcDefaultFont
modifier|*
name|f
init|=
name|defaults
decl_stmt|;
comment|// aliases only make sense for 'common', not for any of the specials
name|QSupportedWritingSystems
name|ws
decl_stmt|;
name|ws
operator|.
name|setSupported
argument_list|(
name|QFontDatabase
operator|::
name|Latin
argument_list|)
expr_stmt|;
while|while
condition|(
name|f
operator|->
name|qtname
condition|)
block|{
name|QString
name|familyQtName
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|f
operator|->
name|qtname
argument_list|)
decl_stmt|;
name|registerFont
argument_list|(
name|familyQtName
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QFont
operator|::
name|Normal
argument_list|,
name|QFont
operator|::
name|StyleNormal
argument_list|,
name|QFont
operator|::
name|Unstretched
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
name|f
operator|->
name|fixed
argument_list|,
name|ws
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|registerFont
argument_list|(
name|familyQtName
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QFont
operator|::
name|Normal
argument_list|,
name|QFont
operator|::
name|StyleItalic
argument_list|,
name|QFont
operator|::
name|Unstretched
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
name|f
operator|->
name|fixed
argument_list|,
name|ws
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|registerFont
argument_list|(
name|familyQtName
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QFont
operator|::
name|Normal
argument_list|,
name|QFont
operator|::
name|StyleOblique
argument_list|,
name|QFont
operator|::
name|Unstretched
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
name|f
operator|->
name|fixed
argument_list|,
name|ws
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|f
expr_stmt|;
block|}
comment|//Lighthouse has very lazy population of the font db. We want it to be initialized when
comment|//QApplication is constructed, so that the population procedure can do something like this to
comment|//set the default font
comment|//    const FcDefaultFont *s = defaults;
comment|//    QFont font("Sans Serif");
comment|//    font.setPointSize(9);
comment|//    QApplication::setFont(font);
block|}
end_function
begin_function
DECL|function|fontEngineMulti
name|QFontEngineMulti
modifier|*
name|QFontconfigDatabase
operator|::
name|fontEngineMulti
parameter_list|(
name|QFontEngine
modifier|*
name|fontEngine
parameter_list|,
name|QChar
operator|::
name|Script
name|script
parameter_list|)
block|{
return|return
operator|new
name|QFontEngineMultiFontConfig
argument_list|(
name|fontEngine
argument_list|,
name|script
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fontEngine
name|QFontEngine
modifier|*
name|QFontconfigDatabase
operator|::
name|fontEngine
parameter_list|(
specifier|const
name|QFontDef
modifier|&
name|f
parameter_list|,
name|QChar
operator|::
name|Script
name|script
parameter_list|,
name|void
modifier|*
name|usrPtr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|usrPtr
condition|)
return|return
literal|0
return|;
name|QFontDef
name|fontDef
init|=
name|f
decl_stmt|;
name|QFontEngineFT
modifier|*
name|engine
decl_stmt|;
name|FontFile
modifier|*
name|fontfile
init|=
cast|static_cast
argument_list|<
name|FontFile
operator|*
argument_list|>
argument_list|(
name|usrPtr
argument_list|)
decl_stmt|;
name|QFontEngine
operator|::
name|FaceId
name|fid
decl_stmt|;
name|fid
operator|.
name|filename
operator|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|fontfile
operator|->
name|fileName
argument_list|)
expr_stmt|;
name|fid
operator|.
name|index
operator|=
name|fontfile
operator|->
name|indexValue
expr_stmt|;
name|bool
name|antialias
init|=
operator|!
operator|(
name|fontDef
operator|.
name|styleStrategy
operator|&
name|QFont
operator|::
name|NoAntialias
operator|)
decl_stmt|;
name|engine
operator|=
operator|new
name|QFontEngineFT
argument_list|(
name|fontDef
argument_list|)
expr_stmt|;
name|QFontEngineFT
operator|::
name|GlyphFormat
name|format
decl_stmt|;
comment|// try and get the pattern
name|FcPattern
modifier|*
name|pattern
init|=
name|FcPatternCreate
argument_list|()
decl_stmt|;
name|FcValue
name|value
decl_stmt|;
name|value
operator|.
name|type
operator|=
name|FcTypeString
expr_stmt|;
name|QByteArray
name|cs
init|=
name|fontDef
operator|.
name|family
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
name|value
operator|.
name|u
operator|.
name|s
operator|=
operator|(
specifier|const
name|FcChar8
operator|*
operator|)
name|cs
operator|.
name|data
argument_list|()
expr_stmt|;
name|FcPatternAdd
argument_list|(
name|pattern
argument_list|,
name|FC_FAMILY
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|value
operator|.
name|u
operator|.
name|s
operator|=
operator|(
specifier|const
name|FcChar8
operator|*
operator|)
name|fid
operator|.
name|filename
operator|.
name|data
argument_list|()
expr_stmt|;
name|FcPatternAdd
argument_list|(
name|pattern
argument_list|,
name|FC_FILE
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|value
operator|.
name|type
operator|=
name|FcTypeInteger
expr_stmt|;
name|value
operator|.
name|u
operator|.
name|i
operator|=
name|fid
operator|.
name|index
expr_stmt|;
name|FcPatternAdd
argument_list|(
name|pattern
argument_list|,
name|FC_INDEX
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|FcResult
name|result
decl_stmt|;
name|FcPattern
modifier|*
name|match
init|=
name|FcFontMatch
argument_list|(
literal|0
argument_list|,
name|pattern
argument_list|,
operator|&
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
condition|)
block|{
name|QFontEngineFT
operator|::
name|HintStyle
name|default_hint_style
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|hintingPreference
operator|!=
name|QFont
operator|::
name|PreferDefaultHinting
condition|)
block|{
switch|switch
condition|(
name|f
operator|.
name|hintingPreference
condition|)
block|{
case|case
name|QFont
operator|::
name|PreferNoHinting
case|:
name|default_hint_style
operator|=
name|QFontEngineFT
operator|::
name|HintNone
expr_stmt|;
break|break;
case|case
name|QFont
operator|::
name|PreferVerticalHinting
case|:
name|default_hint_style
operator|=
name|QFontEngineFT
operator|::
name|HintLight
expr_stmt|;
break|break;
case|case
name|QFont
operator|::
name|PreferFullHinting
case|:
default|default:
name|default_hint_style
operator|=
name|QFontEngineFT
operator|::
name|HintFull
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|int
name|hint_style
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|FcPatternGetInteger
argument_list|(
name|match
argument_list|,
name|FC_HINT_STYLE
argument_list|,
literal|0
argument_list|,
operator|&
name|hint_style
argument_list|)
operator|==
name|FcResultNoMatch
condition|)
name|hint_style
operator|=
name|QFontEngineFT
operator|::
name|HintFull
expr_stmt|;
switch|switch
condition|(
name|hint_style
condition|)
block|{
case|case
name|FC_HINT_NONE
case|:
name|default_hint_style
operator|=
name|QFontEngineFT
operator|::
name|HintNone
expr_stmt|;
break|break;
case|case
name|FC_HINT_SLIGHT
case|:
name|default_hint_style
operator|=
name|QFontEngineFT
operator|::
name|HintLight
expr_stmt|;
break|break;
case|case
name|FC_HINT_MEDIUM
case|:
name|default_hint_style
operator|=
name|QFontEngineFT
operator|::
name|HintMedium
expr_stmt|;
break|break;
default|default:
name|default_hint_style
operator|=
name|QFontEngineFT
operator|::
name|HintFull
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|.
name|hintingPreference
operator|==
name|QFont
operator|::
name|PreferDefaultHinting
condition|)
block|{
name|QByteArray
name|desktopEnvironment
init|=
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|services
argument_list|()
operator|->
name|desktopEnvironment
argument_list|()
decl_stmt|;
if|if
condition|(
name|desktopEnvironment
operator|==
literal|"GNOME"
operator|||
name|desktopEnvironment
operator|==
literal|"UNITY"
condition|)
block|{
name|void
modifier|*
name|hintStyleResource
init|=
name|QGuiApplication
operator|::
name|platformNativeInterface
argument_list|()
operator|->
name|nativeResourceForScreen
argument_list|(
literal|"hintstyle"
argument_list|,
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|hintStyle
init|=
name|int
argument_list|(
cast|reinterpret_cast
argument_list|<
name|qintptr
argument_list|>
argument_list|(
name|hintStyleResource
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|hintStyle
operator|>
literal|0
condition|)
name|default_hint_style
operator|=
name|QFontEngine
operator|::
name|HintStyle
argument_list|(
name|hintStyle
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|engine
operator|->
name|setDefaultHintStyle
argument_list|(
name|default_hint_style
argument_list|)
expr_stmt|;
if|if
condition|(
name|antialias
condition|)
block|{
name|QFontEngineFT
operator|::
name|SubpixelAntialiasingType
name|subpixelType
init|=
name|QFontEngineFT
operator|::
name|Subpixel_None
decl_stmt|;
name|int
name|subpixel
init|=
name|FC_RGBA_NONE
decl_stmt|;
name|FcPatternGetInteger
argument_list|(
name|match
argument_list|,
name|FC_RGBA
argument_list|,
literal|0
argument_list|,
operator|&
name|subpixel
argument_list|)
expr_stmt|;
if|if
condition|(
name|subpixel
operator|==
name|FC_RGBA_UNKNOWN
condition|)
name|subpixel
operator|=
name|FC_RGBA_NONE
expr_stmt|;
switch|switch
condition|(
name|subpixel
condition|)
block|{
case|case
name|FC_RGBA_NONE
case|:
name|subpixelType
operator|=
name|QFontEngineFT
operator|::
name|Subpixel_None
expr_stmt|;
break|break;
case|case
name|FC_RGBA_RGB
case|:
name|subpixelType
operator|=
name|QFontEngineFT
operator|::
name|Subpixel_RGB
expr_stmt|;
break|break;
case|case
name|FC_RGBA_BGR
case|:
name|subpixelType
operator|=
name|QFontEngineFT
operator|::
name|Subpixel_BGR
expr_stmt|;
break|break;
case|case
name|FC_RGBA_VRGB
case|:
name|subpixelType
operator|=
name|QFontEngineFT
operator|::
name|Subpixel_VRGB
expr_stmt|;
break|break;
case|case
name|FC_RGBA_VBGR
case|:
name|subpixelType
operator|=
name|QFontEngineFT
operator|::
name|Subpixel_VBGR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|format
operator|=
name|subpixelType
operator|==
name|QFontEngineFT
operator|::
name|Subpixel_None
condition|?
name|QFontEngineFT
operator|::
name|Format_A8
else|:
name|QFontEngineFT
operator|::
name|Format_A32
expr_stmt|;
name|engine
operator|->
name|subpixelType
operator|=
name|subpixelType
expr_stmt|;
block|}
else|else
name|format
operator|=
name|QFontEngineFT
operator|::
name|Format_Mono
expr_stmt|;
name|FcPatternDestroy
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
else|else
name|format
operator|=
name|antialias
condition|?
name|QFontEngineFT
operator|::
name|Format_A8
else|:
name|QFontEngineFT
operator|::
name|Format_Mono
expr_stmt|;
name|FcPatternDestroy
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|engine
operator|->
name|init
argument_list|(
name|fid
argument_list|,
name|antialias
argument_list|,
name|format
argument_list|)
condition|)
block|{
operator|delete
name|engine
expr_stmt|;
name|engine
operator|=
literal|0
expr_stmt|;
return|return
name|engine
return|;
block|}
if|if
condition|(
name|engine
operator|->
name|invalid
argument_list|()
condition|)
block|{
operator|delete
name|engine
expr_stmt|;
name|engine
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scriptRequiresOpenType
argument_list|(
name|script
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|engine
operator|->
name|supportsScript
argument_list|(
name|script
argument_list|)
condition|)
block|{
operator|delete
name|engine
expr_stmt|;
name|engine
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|engine
return|;
block|}
end_function
begin_function
DECL|function|fallbacksForFamily
name|QStringList
name|QFontconfigDatabase
operator|::
name|fallbacksForFamily
parameter_list|(
specifier|const
name|QString
modifier|&
name|family
parameter_list|,
name|QFont
operator|::
name|Style
name|style
parameter_list|,
name|QFont
operator|::
name|StyleHint
name|styleHint
parameter_list|,
name|QChar
operator|::
name|Script
name|script
parameter_list|)
specifier|const
block|{
name|QStringList
name|fallbackFamilies
decl_stmt|;
name|FcPattern
modifier|*
name|pattern
init|=
name|FcPatternCreate
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pattern
condition|)
return|return
name|fallbackFamilies
return|;
name|FcValue
name|value
decl_stmt|;
name|value
operator|.
name|type
operator|=
name|FcTypeString
expr_stmt|;
name|QByteArray
name|cs
init|=
name|family
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
name|value
operator|.
name|u
operator|.
name|s
operator|=
operator|(
specifier|const
name|FcChar8
operator|*
operator|)
name|cs
operator|.
name|data
argument_list|()
expr_stmt|;
name|FcPatternAdd
argument_list|(
name|pattern
argument_list|,
name|FC_FAMILY
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|int
name|slant_value
init|=
name|FC_SLANT_ROMAN
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|QFont
operator|::
name|StyleItalic
condition|)
name|slant_value
operator|=
name|FC_SLANT_ITALIC
expr_stmt|;
elseif|else
if|if
condition|(
name|style
operator|==
name|QFont
operator|::
name|StyleOblique
condition|)
name|slant_value
operator|=
name|FC_SLANT_OBLIQUE
expr_stmt|;
name|FcPatternAddInteger
argument_list|(
name|pattern
argument_list|,
name|FC_SLANT
argument_list|,
name|slant_value
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|uint
argument_list|(
name|script
argument_list|)
operator|<
name|SpecialLanguageCount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|specialLanguages
index|[
name|script
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|FcLangSet
modifier|*
name|ls
init|=
name|FcLangSetCreate
argument_list|()
decl_stmt|;
name|FcLangSetAdd
argument_list|(
name|ls
argument_list|,
operator|(
specifier|const
name|FcChar8
operator|*
operator|)
name|specialLanguages
index|[
name|script
index|]
argument_list|)
expr_stmt|;
name|FcPatternAddLangSet
argument_list|(
name|pattern
argument_list|,
name|FC_LANG
argument_list|,
name|ls
argument_list|)
expr_stmt|;
name|FcLangSetDestroy
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|family
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If script is Common or Han, then it may include languages like CJK,
comment|// we should attach system default language set to the pattern
comment|// to obtain correct font fallback list (i.e. if LANG=zh_CN
comment|// then we normally want to use a Chinese font for CJK text;
comment|// while a Japanese font should be used for that if LANG=ja)
name|FcPattern
modifier|*
name|dummy
init|=
name|FcPatternCreate
argument_list|()
decl_stmt|;
name|FcDefaultSubstitute
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|FcChar8
modifier|*
name|lang
init|=
literal|0
decl_stmt|;
name|FcResult
name|res
init|=
name|FcPatternGetString
argument_list|(
name|dummy
argument_list|,
name|FC_LANG
argument_list|,
literal|0
argument_list|,
operator|&
name|lang
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|FcResultMatch
condition|)
name|FcPatternAddString
argument_list|(
name|pattern
argument_list|,
name|FC_LANG
argument_list|,
name|lang
argument_list|)
expr_stmt|;
name|FcPatternDestroy
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
block|}
specifier|const
name|char
modifier|*
name|stylehint
init|=
name|getFcFamilyForStyleHint
argument_list|(
name|styleHint
argument_list|)
decl_stmt|;
if|if
condition|(
name|stylehint
condition|)
block|{
name|value
operator|.
name|u
operator|.
name|s
operator|=
operator|(
specifier|const
name|FcChar8
operator|*
operator|)
name|stylehint
expr_stmt|;
name|FcPatternAddWeak
argument_list|(
name|pattern
argument_list|,
name|FC_FAMILY
argument_list|,
name|value
argument_list|,
name|FcTrue
argument_list|)
expr_stmt|;
block|}
name|FcConfigSubstitute
argument_list|(
literal|0
argument_list|,
name|pattern
argument_list|,
name|FcMatchPattern
argument_list|)
expr_stmt|;
name|FcDefaultSubstitute
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|FcResult
name|result
init|=
name|FcResultMatch
decl_stmt|;
name|FcFontSet
modifier|*
name|fontSet
init|=
name|FcFontSort
argument_list|(
literal|0
argument_list|,
name|pattern
argument_list|,
name|FcFalse
argument_list|,
literal|0
argument_list|,
operator|&
name|result
argument_list|)
decl_stmt|;
name|FcPatternDestroy
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontSet
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fontSet
operator|->
name|nfont
condition|;
name|i
operator|++
control|)
block|{
name|FcChar8
modifier|*
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|FcPatternGetString
argument_list|(
name|fontSet
operator|->
name|fonts
index|[
name|i
index|]
argument_list|,
name|FC_FAMILY
argument_list|,
literal|0
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
name|FcResultMatch
condition|)
continue|continue;
comment|//         capitalize(value);
name|QString
name|familyName
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fallbackFamilies
operator|.
name|contains
argument_list|(
name|familyName
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|&&
name|familyName
operator|.
name|compare
argument_list|(
name|family
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
block|{
name|fallbackFamilies
operator|<<
name|familyName
expr_stmt|;
block|}
block|}
name|FcFontSetDestroy
argument_list|(
name|fontSet
argument_list|)
expr_stmt|;
block|}
comment|//    qDebug()<< "fallbackFamilies for:"<< family<< style<< styleHint<< script<< fallbackFamilies;
return|return
name|fallbackFamilies
return|;
block|}
end_function
begin_function
DECL|function|queryFont
specifier|static
name|FcPattern
modifier|*
name|queryFont
parameter_list|(
specifier|const
name|FcChar8
modifier|*
name|file
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|int
name|id
parameter_list|,
name|FcBlanks
modifier|*
name|blanks
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
if|#
directive|if
name|FC_VERSION
operator|<
literal|20402
name|Q_UNUSED
argument_list|(
argument|data
argument_list|)
return|return
name|FcFreeTypeQuery
argument_list|(
name|file
argument_list|,
name|id
argument_list|,
name|blanks
argument_list|,
name|count
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|data
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|FcFreeTypeQuery
argument_list|(
name|file
argument_list|,
name|id
argument_list|,
name|blanks
argument_list|,
name|count
argument_list|)
return|;
name|FT_Library
name|lib
init|=
name|qt_getFreetype
argument_list|()
decl_stmt|;
name|FcPattern
modifier|*
name|pattern
init|=
literal|0
decl_stmt|;
name|FT_Face
name|face
decl_stmt|;
if|if
condition|(
operator|!
name|FT_New_Memory_Face
argument_list|(
name|lib
argument_list|,
operator|(
specifier|const
name|FT_Byte
operator|*
operator|)
name|data
operator|.
name|constData
argument_list|()
argument_list|,
name|data
operator|.
name|size
argument_list|()
argument_list|,
name|id
argument_list|,
operator|&
name|face
argument_list|)
condition|)
block|{
operator|*
name|count
operator|=
name|face
operator|->
name|num_faces
expr_stmt|;
name|pattern
operator|=
name|FcFreeTypeQueryFace
argument_list|(
name|face
argument_list|,
name|file
argument_list|,
name|id
argument_list|,
name|blanks
argument_list|)
expr_stmt|;
name|FT_Done_Face
argument_list|(
name|face
argument_list|)
expr_stmt|;
block|}
return|return
name|pattern
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|addApplicationFont
name|QStringList
name|QFontconfigDatabase
operator|::
name|addApplicationFont
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|fontData
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QStringList
name|families
decl_stmt|;
name|FcFontSet
modifier|*
name|set
init|=
name|FcConfigGetFonts
argument_list|(
literal|0
argument_list|,
name|FcSetApplication
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|FcConfigAppFontAddFile
argument_list|(
literal|0
argument_list|,
operator|(
specifier|const
name|FcChar8
operator|*
operator|)
literal|":/non-existent"
argument_list|)
expr_stmt|;
name|set
operator|=
name|FcConfigGetFonts
argument_list|(
literal|0
argument_list|,
name|FcSetApplication
argument_list|)
expr_stmt|;
comment|// try again
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|families
return|;
block|}
name|int
name|id
init|=
literal|0
decl_stmt|;
name|FcBlanks
modifier|*
name|blanks
init|=
name|FcConfigGetBlanks
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|FcPattern
modifier|*
name|pattern
init|=
literal|0
decl_stmt|;
do|do
block|{
name|pattern
operator|=
name|queryFont
argument_list|(
operator|(
specifier|const
name|FcChar8
operator|*
operator|)
name|QFile
operator|::
name|encodeName
argument_list|(
name|fileName
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|fontData
argument_list|,
name|id
argument_list|,
name|blanks
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pattern
condition|)
return|return
name|families
return|;
name|FcPatternDel
argument_list|(
name|pattern
argument_list|,
name|FC_FILE
argument_list|)
expr_stmt|;
name|QByteArray
name|cs
init|=
name|fileName
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
name|FcPatternAddString
argument_list|(
name|pattern
argument_list|,
name|FC_FILE
argument_list|,
operator|(
specifier|const
name|FcChar8
operator|*
operator|)
name|cs
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|FcChar8
modifier|*
name|fam
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|FcPatternGetString
argument_list|(
name|pattern
argument_list|,
name|FC_FAMILY
argument_list|,
literal|0
argument_list|,
operator|&
name|fam
argument_list|)
operator|==
name|FcResultMatch
condition|)
block|{
name|QString
name|family
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|fam
argument_list|)
argument_list|)
decl_stmt|;
name|families
operator|<<
name|family
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|FcFontSetAdd
argument_list|(
name|set
argument_list|,
name|pattern
argument_list|)
condition|)
return|return
name|families
return|;
operator|++
name|id
expr_stmt|;
block|}
do|while
condition|(
name|pattern
operator|&&
name|id
operator|<
name|count
condition|)
do|;
return|return
name|families
return|;
block|}
end_function
begin_function
DECL|function|resolveFontFamilyAlias
name|QString
name|QFontconfigDatabase
operator|::
name|resolveFontFamilyAlias
parameter_list|(
specifier|const
name|QString
modifier|&
name|family
parameter_list|)
specifier|const
block|{
name|FcPattern
modifier|*
name|pattern
init|=
name|FcPatternCreate
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pattern
condition|)
return|return
name|family
return|;
if|if
condition|(
operator|!
name|family
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QByteArray
name|cs
init|=
name|family
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
name|FcPatternAddString
argument_list|(
name|pattern
argument_list|,
name|FC_FAMILY
argument_list|,
operator|(
specifier|const
name|FcChar8
operator|*
operator|)
name|cs
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FcConfigSubstitute
argument_list|(
literal|0
argument_list|,
name|pattern
argument_list|,
name|FcMatchPattern
argument_list|)
expr_stmt|;
name|FcDefaultSubstitute
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|FcChar8
modifier|*
name|familyAfterSubstitution
init|=
literal|0
decl_stmt|;
name|FcPatternGetString
argument_list|(
name|pattern
argument_list|,
name|FC_FAMILY
argument_list|,
literal|0
argument_list|,
operator|&
name|familyAfterSubstitution
argument_list|)
expr_stmt|;
name|QString
name|resolved
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|familyAfterSubstitution
argument_list|)
decl_stmt|;
name|FcPatternDestroy
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
return|return
name|resolved
return|;
block|}
end_function
begin_function
DECL|function|defaultFont
name|QFont
name|QFontconfigDatabase
operator|::
name|defaultFont
parameter_list|()
specifier|const
block|{
comment|// Hack to get system default language until FcGetDefaultLangs()
comment|// is exported (https://bugs.freedesktop.org/show_bug.cgi?id=32853)
comment|// or https://bugs.freedesktop.org/show_bug.cgi?id=35482 is fixed
name|FcPattern
modifier|*
name|dummy
init|=
name|FcPatternCreate
argument_list|()
decl_stmt|;
name|FcDefaultSubstitute
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|FcChar8
modifier|*
name|lang
init|=
literal|0
decl_stmt|;
name|FcResult
name|res
init|=
name|FcPatternGetString
argument_list|(
name|dummy
argument_list|,
name|FC_LANG
argument_list|,
literal|0
argument_list|,
operator|&
name|lang
argument_list|)
decl_stmt|;
name|FcPattern
modifier|*
name|pattern
init|=
name|FcPatternCreate
argument_list|()
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|FcResultMatch
condition|)
block|{
comment|// Make defaultFont pattern matching locale language aware, because
comment|// certain FC_LANG based custom rules may happen in FcConfigSubstitute()
name|FcPatternAddString
argument_list|(
name|pattern
argument_list|,
name|FC_LANG
argument_list|,
name|lang
argument_list|)
expr_stmt|;
block|}
name|FcConfigSubstitute
argument_list|(
literal|0
argument_list|,
name|pattern
argument_list|,
name|FcMatchPattern
argument_list|)
expr_stmt|;
name|FcDefaultSubstitute
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|FcChar8
modifier|*
name|familyAfterSubstitution
init|=
literal|0
decl_stmt|;
name|FcPatternGetString
argument_list|(
name|pattern
argument_list|,
name|FC_FAMILY
argument_list|,
literal|0
argument_list|,
operator|&
name|familyAfterSubstitution
argument_list|)
expr_stmt|;
name|QString
name|resolved
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|familyAfterSubstitution
argument_list|)
decl_stmt|;
name|FcPatternDestroy
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|FcPatternDestroy
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
return|return
name|QFont
argument_list|(
name|resolved
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
