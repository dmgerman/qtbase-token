begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Intel Corporation. ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qurlquery.h"
end_include
begin_include
include|#
directive|include
file|"qurl_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qstringlist.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!   \class QUrlQuery   \inmodule QtCore   \since 5.0    \brief The QUrlQuery class provides a way to manipulate a key-value pairs in   a URL's query.    \reentrant   \ingroup io   \ingroup network   \ingroup shared    It is used to parse the query strings found in URLs like the following:    \image qurl-querystring.png    Query strings like the above are used to transmit options in the URL and are   usually decoded into multiple key-value pairs. The one above would contain   two entries in its list, with keys "type" and "color". QUrlQuery can also be   used to create a query string suitable for use in QUrl::setQuery() from the   individual components of the query.    The most common way of parsing a query string is to initialize it in the   constructor by passing it the query string. Otherwise, the setQuery() method   can be used to set the query to be parsed. That method can also be used to   parse a query with non-standard delimiters, after having set them using the   setQueryDelimiters() function.    The encoded query string can be obtained again using query(). This will take   all the internally-stored items and encode the string using the delimiters.    \section1 Encoding    All of the getter methods in QUrlQuery support an optional parameter of type   QUrl::ComponentFormattingOptions, including query(), which dictate how to   encode the data in question. Regardless of the mode, the returned value must   still be considered a percent-encoded string, as there are certain values   which cannot be expressed in decoded form (like control characters, byte   sequences not decodable to UTF-8). For that reason, the percent character is   always represented by the string "%25".    \section2 Handling of spaces and plus ("+")    Web browsers usually encode spaces found in HTML FORM elements to a plus sign   ("+") and plus signs to its percent-encoded form (%2B). However, the Internet   specifications governing URLs do not consider spaces and the plus character   equivalent.    For that reason, QUrlQuery never encodes the space character to "+" and will   never decode "+" to a space character. Instead, space characters will be   rendered "%20" in encoded form.    To support encoding like that of HTML forms, QUrlQuery also never decodes the   "%2B" sequence to a plus sign nor encode a plus sign. In fact, any "%2B" or   "+" sequences found in the keys, values, or query string are left exactly   like written (except for the uppercasing of "%2b" to "%2B").    \section1 Non-standard delimiters    By default, QUrlQuery uses an equal sign ("=") to separate a key from its   value, and an ampersand ("&") to separate key-value pairs from each other. It   is possible to change the delimiters that QUrlQuery uses for parsing and for   reconstructing the query by calling setQueryDelimiters().    Non-standard delimiters should be chosen from among what RFC 3986 calls   "sub-delimiters". They are:    \code     sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"                   / "*" / "+" / "," / ";" / "="   \endcode    Use of other characters is not supported and may result in unexpected   behaviour. QUrlQuery does not verify that you passed a valid delimiter.    \sa QUrl */
end_comment
begin_typedef
DECL|typedef|Map
typedef|typedef
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
name|Map
typedef|;
end_typedef
begin_class
DECL|class|QUrlQueryPrivate
class|class
name|QUrlQueryPrivate
super|:
specifier|public
name|QSharedData
block|{
public|public:
DECL|function|QUrlQueryPrivate
name|QUrlQueryPrivate
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
init|=
name|QString
argument_list|()
parameter_list|)
member_init_list|:
name|valueDelimiter
argument_list|(
name|QUrlQuery
operator|::
name|defaultQueryValueDelimiter
argument_list|()
argument_list|)
member_init_list|,
name|pairDelimiter
argument_list|(
name|QUrlQuery
operator|::
name|defaultQueryPairDelimiter
argument_list|()
argument_list|)
block|{
if|if
condition|(
operator|!
name|query
operator|.
name|isEmpty
argument_list|()
condition|)
name|setQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
name|QString
name|recodeFromUser
parameter_list|(
specifier|const
name|QString
modifier|&
name|input
parameter_list|)
specifier|const
function_decl|;
name|QString
name|recodeToUser
parameter_list|(
specifier|const
name|QString
modifier|&
name|input
parameter_list|,
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
parameter_list|)
specifier|const
function_decl|;
name|void
name|setQuery
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|)
function_decl|;
DECL|function|addQueryItem
name|void
name|addQueryItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|itemList
operator|.
name|append
argument_list|(
name|qMakePair
argument_list|(
name|recodeFromUser
argument_list|(
name|key
argument_list|)
argument_list|,
name|recodeFromUser
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|findRecodedKey
name|int
name|findRecodedKey
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
name|int
name|from
init|=
literal|0
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
name|from
init|;
name|i
operator|<
name|itemList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|itemList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|first
operator|==
name|key
condition|)
return|return
name|i
return|;
return|return
name|itemList
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|findKey
name|Map
operator|::
name|const_iterator
name|findKey
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
return|return
name|itemList
operator|.
name|constBegin
argument_list|()
operator|+
name|findRecodedKey
argument_list|(
name|recodeFromUser
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|function|findKey
name|Map
operator|::
name|iterator
name|findKey
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
return|return
name|itemList
operator|.
name|begin
argument_list|()
operator|+
name|findRecodedKey
argument_list|(
name|recodeFromUser
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
comment|// use QMap so we end up sorting the items by key
DECL|member|itemList
name|Map
name|itemList
decl_stmt|;
DECL|member|valueDelimiter
name|QChar
name|valueDelimiter
decl_stmt|;
DECL|member|pairDelimiter
name|QChar
name|pairDelimiter
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|detach
template|template
parameter_list|<>
name|void
name|QSharedDataPointer
argument_list|<
name|QUrlQueryPrivate
argument_list|>
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
condition|)
return|return;
name|QUrlQueryPrivate
modifier|*
name|x
init|=
operator|(
name|d
condition|?
operator|new
name|QUrlQueryPrivate
argument_list|(
operator|*
name|d
argument_list|)
else|:
operator|new
name|QUrlQueryPrivate
operator|)
decl_stmt|;
name|x
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|x
expr_stmt|;
block|}
end_function
begin_comment
comment|// Here's how we do the encoding in QUrlQuery
end_comment
begin_comment
comment|// The RFC says these are the delimiters:
end_comment
begin_comment
comment|//    gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
end_comment
begin_comment
comment|//    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
end_comment
begin_comment
comment|//                  / "*" / "+" / "," / ";" / "="
end_comment
begin_comment
comment|// And the definition of query is:
end_comment
begin_comment
comment|//    query         = *( pchar / "/" / "?" )
end_comment
begin_comment
comment|//    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The strict definition of query says that it can have unencoded any
end_comment
begin_comment
comment|// unreserved, sub-delim, ":", "@", "/" and "?". Or, by exclusion, excluded
end_comment
begin_comment
comment|// delimiters are "#", "[" and "]" -- if those are present, they must be
end_comment
begin_comment
comment|// percent-encoded. The fact that "[" and "]" should be encoded is probably a
end_comment
begin_comment
comment|// mistake in the spec, so we ignore it and leave the decoded.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The internal storage in the Map is equivalent to PrettyDecoded. That means
end_comment
begin_comment
comment|// the getter methods, when called with the default encoding value, will not
end_comment
begin_comment
comment|// have to recode anything (except for toString()).
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The "+" sub-delimiter is always left untouched. We never encode "+" to "%2B"
end_comment
begin_comment
comment|// nor do we decode "%2B" to "+", no matter what the user asks.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The rest of the delimiters are kept in their decoded forms and that's
end_comment
begin_comment
comment|// considered non-ambiguous. That includes the pair and value delimiters
end_comment
begin_comment
comment|// themselves.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// But when recreating the query string, in toString(), we must take care of
end_comment
begin_comment
comment|// the special delimiters: the pair and value delimiters, as well as the "#"
end_comment
begin_comment
comment|// character if unambiguous decoding is requested.
end_comment
begin_define
DECL|macro|decode
define|#
directive|define
name|decode
parameter_list|(
name|x
parameter_list|)
value|ushort(x)
end_define
begin_define
DECL|macro|leave
define|#
directive|define
name|leave
parameter_list|(
name|x
parameter_list|)
value|ushort(0x100 | (x))
end_define
begin_define
DECL|macro|encode
define|#
directive|define
name|encode
parameter_list|(
name|x
parameter_list|)
value|ushort(0x200 | (x))
end_define
begin_decl_stmt
DECL|variable|prettyDecodedActions
specifier|static
specifier|const
name|ushort
name|prettyDecodedActions
index|[]
init|=
block|{
name|leave
argument_list|(
literal|'+'
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|recodeFromUser
specifier|inline
name|QString
name|QUrlQueryPrivate
operator|::
name|recodeFromUser
parameter_list|(
specifier|const
name|QString
modifier|&
name|input
parameter_list|)
specifier|const
block|{
comment|// note: duplicated in setQuery()
name|QString
name|output
decl_stmt|;
if|if
condition|(
name|qt_urlRecode
argument_list|(
name|output
argument_list|,
name|input
operator|.
name|constData
argument_list|()
argument_list|,
name|input
operator|.
name|constData
argument_list|()
operator|+
name|input
operator|.
name|length
argument_list|()
argument_list|,
name|QUrl
operator|::
name|DecodeReserved
argument_list|,
name|prettyDecodedActions
argument_list|)
condition|)
return|return
name|output
return|;
return|return
name|input
return|;
block|}
end_function
begin_function
DECL|function|idempotentRecodeToUser
specifier|inline
name|bool
name|idempotentRecodeToUser
parameter_list|(
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
parameter_list|)
block|{
return|return
name|encoding
operator|==
name|QUrl
operator|::
name|PrettyDecoded
return|;
block|}
end_function
begin_function
DECL|function|recodeToUser
specifier|inline
name|QString
name|QUrlQueryPrivate
operator|::
name|recodeToUser
parameter_list|(
specifier|const
name|QString
modifier|&
name|input
parameter_list|,
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
parameter_list|)
specifier|const
block|{
comment|// our internal formats are stored in "PrettyDecoded" form
comment|// and there are no ambiguous characters
if|if
condition|(
name|idempotentRecodeToUser
argument_list|(
name|encoding
argument_list|)
condition|)
return|return
name|input
return|;
if|if
condition|(
operator|!
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeDelimiters
operator|)
condition|)
block|{
name|QString
name|output
decl_stmt|;
if|if
condition|(
name|qt_urlRecode
argument_list|(
name|output
argument_list|,
name|input
operator|.
name|constData
argument_list|()
argument_list|,
name|input
operator|.
name|constData
argument_list|()
operator|+
name|input
operator|.
name|length
argument_list|()
argument_list|,
name|encoding
argument_list|,
name|prettyDecodedActions
argument_list|)
condition|)
return|return
name|output
return|;
return|return
name|input
return|;
block|}
comment|// re-encode the "#" character and the query delimiter pair
name|ushort
name|actions
index|[]
init|=
block|{
name|encode
argument_list|(
name|pairDelimiter
operator|.
name|unicode
argument_list|()
argument_list|)
block|,
name|encode
argument_list|(
name|valueDelimiter
operator|.
name|unicode
argument_list|()
argument_list|)
block|,
name|encode
argument_list|(
literal|'#'
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|QString
name|output
decl_stmt|;
if|if
condition|(
name|qt_urlRecode
argument_list|(
name|output
argument_list|,
name|input
operator|.
name|constData
argument_list|()
argument_list|,
name|input
operator|.
name|constData
argument_list|()
operator|+
name|input
operator|.
name|length
argument_list|()
argument_list|,
name|encoding
argument_list|,
name|actions
argument_list|)
condition|)
return|return
name|output
return|;
return|return
name|input
return|;
block|}
end_function
begin_function
DECL|function|setQuery
name|void
name|QUrlQueryPrivate
operator|::
name|setQuery
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|)
block|{
name|itemList
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|const
name|QChar
modifier|*
name|pos
init|=
name|query
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
specifier|const
name|end
init|=
name|pos
operator|+
name|query
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|pos
operator|!=
name|end
condition|)
block|{
specifier|const
name|QChar
modifier|*
name|begin
init|=
name|pos
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|delimiter
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pos
operator|!=
name|end
condition|)
block|{
comment|// scan for the component parts of this pair
if|if
condition|(
operator|!
name|delimiter
operator|&&
name|pos
operator|->
name|unicode
argument_list|()
operator|==
name|valueDelimiter
condition|)
name|delimiter
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|->
name|unicode
argument_list|()
operator|==
name|pairDelimiter
condition|)
break|break;
operator|++
name|pos
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|delimiter
condition|)
name|delimiter
operator|=
name|pos
expr_stmt|;
comment|// pos is the end of this pair (the end of the string or the pair delimiter)
comment|// delimiter points to the value delimiter or to the end of this pair
name|QString
name|key
decl_stmt|;
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|key
argument_list|,
name|begin
argument_list|,
name|delimiter
argument_list|,
name|QUrl
operator|::
name|DecodeReserved
argument_list|,
name|prettyDecodedActions
argument_list|)
condition|)
name|key
operator|=
name|QString
argument_list|(
name|begin
argument_list|,
name|delimiter
operator|-
name|begin
argument_list|)
expr_stmt|;
if|if
condition|(
name|delimiter
operator|==
name|pos
condition|)
block|{
comment|// the value delimiter wasn't found, store a null value
name|itemList
operator|.
name|append
argument_list|(
name|qMakePair
argument_list|(
name|key
argument_list|,
name|QString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delimiter
operator|+
literal|1
operator|==
name|pos
condition|)
block|{
comment|// if the delimiter was found but the value is empty, store empty-but-not-null
name|itemList
operator|.
name|append
argument_list|(
name|qMakePair
argument_list|(
name|key
argument_list|,
name|QString
argument_list|(
literal|0
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|value
argument_list|,
name|delimiter
operator|+
literal|1
argument_list|,
name|pos
argument_list|,
name|QUrl
operator|::
name|DecodeReserved
argument_list|,
name|prettyDecodedActions
argument_list|)
condition|)
name|value
operator|=
name|QString
argument_list|(
name|delimiter
operator|+
literal|1
argument_list|,
name|pos
operator|-
name|delimiter
operator|-
literal|1
argument_list|)
expr_stmt|;
name|itemList
operator|.
name|append
argument_list|(
name|qMakePair
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|!=
name|end
condition|)
operator|++
name|pos
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// allow QUrlQueryPrivate to detach from null
end_comment
begin_function
template|template
parameter_list|<>
specifier|inline
name|QUrlQueryPrivate
modifier|*
DECL|function|clone
name|QSharedDataPointer
argument_list|<
name|QUrlQueryPrivate
argument_list|>
operator|::
name|clone
parameter_list|()
block|{
return|return
name|d
condition|?
operator|new
name|QUrlQueryPrivate
argument_list|(
operator|*
name|d
argument_list|)
else|:
operator|new
name|QUrlQueryPrivate
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs an empty QUrlQuery object. A query can be set afterwards by     calling setQuery() or items can be added by using addQueryItem().      \sa setQuery(), addQueryItem() */
end_comment
begin_constructor
DECL|function|QUrlQuery
name|QUrlQuery
operator|::
name|QUrlQuery
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QUrlQuery object and parses the \a queryString query string,     using the default query delimiters. To parse a query string using other     delimiters, you should first set them using setQueryDelimiters() and then     set the query with setQuery(). */
end_comment
begin_constructor
DECL|function|QUrlQuery
name|QUrlQuery
operator|::
name|QUrlQuery
parameter_list|(
specifier|const
name|QString
modifier|&
name|queryString
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|queryString
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
operator|new
name|QUrlQueryPrivate
argument_list|(
name|queryString
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QUrlQuery object and parses the query string found in the \a     url URL, using the default query delimiters. To parse a query string using     other delimiters, you should first set them using setQueryDelimiters() and     then set the query with setQuery().      \sa QUrl::query() */
end_comment
begin_constructor
DECL|function|QUrlQuery
name|QUrlQuery
operator|::
name|QUrlQuery
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{
comment|// use internals to avoid unnecessary recoding
comment|// ### FIXME: actually do it
if|if
condition|(
name|url
operator|.
name|hasQuery
argument_list|()
condition|)
name|d
operator|=
operator|new
name|QUrlQueryPrivate
argument_list|(
name|url
operator|.
name|query
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Copies the contents of the \a other QUrlQuery object, including the query     delimiters. */
end_comment
begin_constructor
DECL|function|QUrlQuery
name|QUrlQuery
operator|::
name|QUrlQuery
parameter_list|(
specifier|const
name|QUrlQuery
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Copies the contents of the \a other QUrlQuery object, including the query     delimiters. */
end_comment
begin_function
DECL|function|operator =
name|QUrlQuery
modifier|&
name|QUrlQuery
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QUrlQuery
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QUrlQuery::swap(QUrlQuery&other)      Swaps this URL query instance with \a other. This function is very     fast and never fails. */
end_comment
begin_comment
comment|/*!     Destroys this QUrlQuery object. */
end_comment
begin_destructor
DECL|function|~QUrlQuery
name|QUrlQuery
operator|::
name|~
name|QUrlQuery
parameter_list|()
block|{
comment|// d auto-deletes
block|}
end_destructor
begin_comment
comment|/*!     Returns true if this object and the \a other object contain the same     contents, in the same order, and use the same query delimiters. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QUrlQuery
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QUrlQuery
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|==
name|other
operator|.
name|d
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|d
operator|&&
name|other
operator|.
name|d
condition|)
return|return
name|d
operator|->
name|valueDelimiter
operator|==
name|other
operator|.
name|d
operator|->
name|valueDelimiter
operator|&&
name|d
operator|->
name|pairDelimiter
operator|==
name|other
operator|.
name|d
operator|->
name|pairDelimiter
operator|&&
name|d
operator|->
name|itemList
operator|==
name|other
operator|.
name|d
operator|->
name|itemList
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this QUrlQUery object contains no key-value pairs, such as     after being default-constructed or after parsing an empty query string.      \sa setQuery(), clear() */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QUrlQuery
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|itemList
operator|.
name|isEmpty
argument_list|()
else|:
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|isDetached
name|bool
name|QUrlQuery
operator|::
name|isDetached
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|&&
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Clears this QUrlQuery object by removing all of the key-value pairs     currently stored. If the query delimiters have been changed, this function     will leave them with their changed values.      \sa isEmpty(), setQueryDelimiters() */
end_comment
begin_function
DECL|function|clear
name|void
name|QUrlQuery
operator|::
name|clear
parameter_list|()
block|{
if|if
condition|(
name|d
operator|.
name|constData
argument_list|()
condition|)
name|d
operator|->
name|itemList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Parses the query string in \a queryString and sets the internal items to     the values found there. If any delimiters have been specified with     setQueryDelimiters(), this function will use them instead of the default     delimiters to parse the string. */
end_comment
begin_function
DECL|function|setQuery
name|void
name|QUrlQuery
operator|::
name|setQuery
parameter_list|(
specifier|const
name|QString
modifier|&
name|queryString
parameter_list|)
block|{
name|d
operator|->
name|setQuery
argument_list|(
name|queryString
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|recodeAndAppend
specifier|static
name|void
name|recodeAndAppend
parameter_list|(
name|QString
modifier|&
name|to
parameter_list|,
specifier|const
name|QString
modifier|&
name|input
parameter_list|,
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
parameter_list|,
specifier|const
name|ushort
modifier|*
name|tableModifications
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|to
argument_list|,
name|input
operator|.
name|constData
argument_list|()
argument_list|,
name|input
operator|.
name|constData
argument_list|()
operator|+
name|input
operator|.
name|length
argument_list|()
argument_list|,
name|encoding
argument_list|,
name|tableModifications
argument_list|)
condition|)
name|to
operator|+=
name|input
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the reconstructed query string, formed from the key-value pairs     currently stored in this QUrlQuery object and separated by the query     delimiters chosen for this object. The keys and values are encoded using     the options given by the \a encoding parameter.      For this function, the only ambiguous delimiter is the hash ("#"), as in     URLs it is used to separate the query string from the fragment that may     follow.      The order of the key-value pairs in the returned string is exactly the same     as in the original query.      \sa setQuery(), QUrl::setQuery(), QUrl::fragment(), {encoding}{Encoding} */
end_comment
begin_function
DECL|function|query
name|QString
name|QUrlQuery
operator|::
name|query
parameter_list|(
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// unlike the component encoding, for the whole query we need to modify a little:
comment|//  - the "#" character is ambiguous, so we decode it only in DecodeAllDelimiters mode
comment|//  - the query delimiter pair must always be encoded
comment|//  - the non-delimiters vary on DecodeUnambiguousDelimiters
comment|// so:
comment|//  - full encoding: encode the non-delimiters, the pair, "#", "[" and "]"
comment|//  - pretty decode: decode the non-delimiters, "[" and "]"; encode the pair and "#"
comment|//  - decode all: decode the non-delimiters, "[", "]", "#"; encode the pair
comment|// start with what's always encoded
name|ushort
name|tableActions
index|[]
init|=
block|{
name|leave
argument_list|(
literal|'+'
argument_list|)
block|,
comment|// 0
name|encode
argument_list|(
name|d
operator|->
name|pairDelimiter
operator|.
name|unicode
argument_list|()
argument_list|)
block|,
comment|// 1
name|encode
argument_list|(
name|d
operator|->
name|valueDelimiter
operator|.
name|unicode
argument_list|()
argument_list|)
block|,
comment|// 2
name|decode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 3
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeDelimiters
condition|)
block|{
name|tableActions
index|[
literal|3
index|]
operator|=
name|encode
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
block|}
name|QString
name|result
decl_stmt|;
name|Map
operator|::
name|const_iterator
name|it
init|=
name|d
operator|->
name|itemList
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|Map
operator|::
name|const_iterator
name|end
init|=
name|d
operator|->
name|itemList
operator|.
name|constEnd
argument_list|()
decl_stmt|;
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|size
operator|+=
name|it
operator|->
name|first
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|+
name|it
operator|->
name|second
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|size
operator|+
name|size
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|it
operator|=
name|d
operator|->
name|itemList
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|!
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|+=
name|QChar
argument_list|(
name|d
operator|->
name|pairDelimiter
argument_list|)
expr_stmt|;
name|recodeAndAppend
argument_list|(
name|result
argument_list|,
name|it
operator|->
name|first
argument_list|,
name|encoding
argument_list|,
name|tableActions
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|it
operator|->
name|second
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|result
operator|+=
name|QChar
argument_list|(
name|d
operator|->
name|valueDelimiter
argument_list|)
expr_stmt|;
name|recodeAndAppend
argument_list|(
name|result
argument_list|,
name|it
operator|->
name|second
argument_list|,
name|encoding
argument_list|,
name|tableActions
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the characters used for delimiting between keys and values,     and between key-value pairs in the URL's query string. The default     value delimiter is '=' and the default pair delimiter is '&'.      \image qurl-querystring.png      \a valueDelimiter will be used for separating keys from values,     and \a pairDelimiter will be used to separate key-value pairs.     Any occurrences of these delimiting characters in the encoded     representation of the keys and values of the query string are     percent encoded when returned in query().      If \a valueDelimiter is set to '(' and \a pairDelimiter is ')',     the above query string would instead be represented like this:      \snippet code/src_corelib_io_qurl.cpp 4      \note Non-standard delimiters should be chosen from among what RFC 3986 calls     "sub-delimiters". They are:      \code       sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"                     / "*" / "+" / "," / ";" / "="     \endcode      Use of other characters is not supported and may result in unexpected     behaviour. This method does not verify that you passed a valid delimiter.      \sa queryValueDelimiter(), queryPairDelimiter() */
end_comment
begin_function
DECL|function|setQueryDelimiters
name|void
name|QUrlQuery
operator|::
name|setQueryDelimiters
parameter_list|(
name|QChar
name|valueDelimiter
parameter_list|,
name|QChar
name|pairDelimiter
parameter_list|)
block|{
name|d
operator|->
name|valueDelimiter
operator|=
name|valueDelimiter
operator|.
name|unicode
argument_list|()
expr_stmt|;
name|d
operator|->
name|pairDelimiter
operator|=
name|pairDelimiter
operator|.
name|unicode
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the character used to delimit between keys and values when     reconstructing the query string in query() or when parsing in setQuery().      \sa setQueryDelimiters(), queryPairDelimiter() */
end_comment
begin_function
DECL|function|queryValueDelimiter
name|QChar
name|QUrlQuery
operator|::
name|queryValueDelimiter
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|valueDelimiter
else|:
name|defaultQueryValueDelimiter
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the character used to delimit between keys-value pairs when     reconstructing the query string in query() or when parsing in setQuery().      \sa setQueryDelimiters(), queryValueDelimiter() */
end_comment
begin_function
DECL|function|queryPairDelimiter
name|QChar
name|QUrlQuery
operator|::
name|queryPairDelimiter
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|pairDelimiter
else|:
name|defaultQueryPairDelimiter
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the items in this QUrlQuery object to \a query. The order of the     elements in \a query is preserved.      \note This method does not treat spaces (ASCII 0x20) and plus ("+") signs     as the same, like HTML forms do. If you need spaces to be represented as     plus signs, use actual plus signs.      \sa queryItems(), isEmpty() */
end_comment
begin_function
DECL|function|setQueryItems
name|void
name|QUrlQuery
operator|::
name|setQueryItems
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
modifier|&
name|query
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QUrlQueryPrivate
modifier|*
name|dd
init|=
name|d
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|query
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|query
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|dd
operator|->
name|addQueryItem
argument_list|(
name|it
operator|->
name|first
argument_list|,
name|it
operator|->
name|second
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the query string of the URL, as a map of keys and values, using the     options specified in \a encoding to encode the items. The order of the     elements is the same as the one found in the query string or set with     setQueryItems().      \sa setQueryItems(), {encoding}{Encoding} */
end_comment
begin_function
DECL|function|queryItems
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
name|QUrlQuery
operator|::
name|queryItems
parameter_list|(
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
argument_list|()
return|;
if|if
condition|(
name|idempotentRecodeToUser
argument_list|(
name|encoding
argument_list|)
condition|)
return|return
name|d
operator|->
name|itemList
return|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
name|result
decl_stmt|;
name|Map
operator|::
name|const_iterator
name|it
init|=
name|d
operator|->
name|itemList
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|Map
operator|::
name|const_iterator
name|end
init|=
name|d
operator|->
name|itemList
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|result
operator|<<
name|qMakePair
argument_list|(
name|d
operator|->
name|recodeToUser
argument_list|(
name|it
operator|->
name|first
argument_list|,
name|encoding
argument_list|)
argument_list|,
name|d
operator|->
name|recodeToUser
argument_list|(
name|it
operator|->
name|second
argument_list|,
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if there is a query string pair whose key is equal     to \a key from the URL.      \sa addQueryItem(), queryItemValue() */
end_comment
begin_function
DECL|function|hasQueryItem
name|bool
name|QUrlQuery
operator|::
name|hasQueryItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|findKey
argument_list|(
name|key
argument_list|)
operator|!=
name|d
operator|->
name|itemList
operator|.
name|constEnd
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Appends the pair \a key = \a value to the end of the query string of the     URL. This method does not overwrite existing items that might exist with     the same key.      \note This method does not treat spaces (ASCII 0x20) and plus ("+") signs     as the same, like HTML forms do. If you need spaces to be represented as     plus signs, use actual plus signs.      \sa hasQueryItem(), queryItemValue() */
end_comment
begin_function
DECL|function|addQueryItem
name|void
name|QUrlQuery
operator|::
name|addQueryItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|d
operator|->
name|addQueryItem
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the query value associated with key \a key from the URL, using the     options specified in \a encoding to encode the return value. If the key \a     key is not found, this function returns an empty string. If you need to     distinguish between an empty value and a non-existent key, you should check     for the key's presence first using hasQueryItem().      If the key \a key is multiply defined, this function will return the first     one found, in the order they were present in the query string or added     using addQueryItem().      \sa addQueryItem(), allQueryItemValues(), {encoding}{Encoding} */
end_comment
begin_function
DECL|function|queryItemValue
name|QString
name|QUrlQuery
operator|::
name|queryItemValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
parameter_list|)
specifier|const
block|{
name|QString
name|result
decl_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|Map
operator|::
name|const_iterator
name|it
init|=
name|d
operator|->
name|findKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|d
operator|->
name|itemList
operator|.
name|constEnd
argument_list|()
condition|)
name|result
operator|=
name|d
operator|->
name|recodeToUser
argument_list|(
name|it
operator|->
name|second
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the a list of query string values whose key is equal to \a key from     the URL, using the options specified in \a encoding to encode the return     value. If the key \a key is not found, this function returns an empty list.      \sa queryItemValue(), addQueryItem() */
end_comment
begin_function
DECL|function|allQueryItemValues
name|QStringList
name|QUrlQuery
operator|::
name|allQueryItemValues
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
parameter_list|)
specifier|const
block|{
name|QStringList
name|result
decl_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|QString
name|encodedKey
init|=
name|d
operator|->
name|recodeFromUser
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|int
name|idx
init|=
name|d
operator|->
name|findRecodedKey
argument_list|(
name|encodedKey
argument_list|)
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|d
operator|->
name|itemList
operator|.
name|size
argument_list|()
condition|)
block|{
name|result
operator|<<
name|d
operator|->
name|recodeToUser
argument_list|(
name|d
operator|->
name|itemList
operator|.
name|at
argument_list|(
name|idx
argument_list|)
operator|.
name|second
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|idx
operator|=
name|d
operator|->
name|findRecodedKey
argument_list|(
name|encodedKey
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the query string pair whose key is equal to \a key from the URL. If     there are multiple items with a key equal to \a key, it removes the first     item in the order they were present in the query string or added with     addQueryItem().      \sa removeAllQueryItems() */
end_comment
begin_function
DECL|function|removeQueryItem
name|void
name|QUrlQuery
operator|::
name|removeQueryItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
if|if
condition|(
name|d
condition|)
block|{
name|Map
operator|::
name|iterator
name|it
init|=
name|d
operator|->
name|findKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|d
operator|->
name|itemList
operator|.
name|end
argument_list|()
condition|)
name|d
operator|->
name|itemList
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Removes all the query string pairs whose key is equal to \a key     from the URL.      \sa removeQueryItem() */
end_comment
begin_function
DECL|function|removeAllQueryItems
name|void
name|QUrlQuery
operator|::
name|removeAllQueryItems
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
if|if
condition|(
name|d
operator|.
name|constData
argument_list|()
condition|)
block|{
name|QString
name|encodedKey
init|=
name|d
operator|->
name|recodeFromUser
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Map
operator|::
name|iterator
name|it
init|=
name|d
operator|->
name|itemList
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|itemList
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|first
operator|==
name|encodedKey
condition|)
name|it
operator|=
name|d
operator|->
name|itemList
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
else|else
operator|++
name|it
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QChar QUrlQuery::defaultQueryValueDelimiter()     Returns the default character for separating keys from values in the query,     an equal sign ("=").      \sa setQueryDelimiters(), queryValueDelimiter(), defaultQueryPairDelimiter() */
end_comment
begin_comment
comment|/*!     \fn QChar QUrlQuery::defaultQueryPairDelimiter()     Returns the default character for separating keys-value pairs from each     other, an ampersand ("&").      \sa setQueryDelimiters(), queryPairDelimiter(), defaultQueryValueDelimiter() */
end_comment
begin_comment
comment|/*!     \typedef QUrlQuery::DataPtr     \internal */
end_comment
begin_comment
comment|/*!     \fn DataPtr&QUrlQuery::data_ptr()     \internal */
end_comment
begin_comment
comment|/*!     \fn QString QUrlQuery::toString(QUrl::ComponentFormattingOptions encoding = QUrl::PrettyDecoded) const      Returns this QUrlQuery as a QString. \a encoding can be used to specify the URL string encoding of the return value. */
end_comment
begin_comment
comment|/*!     \fn bool QUrlQuery::operator!=(const QUrlQuery&other) const      Returns true if \a other is not equal to this QUrlQuery. Otherwise, returns false.      \sa operator==() */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
