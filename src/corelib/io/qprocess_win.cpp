begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qprocess.h"
end_include
begin_include
include|#
directive|include
file|"qprocess_p.h"
end_include
begin_include
include|#
directive|include
file|"qwindowspipewriter_p.h"
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qtimer.h>
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|<qmutex.h>
end_include
begin_include
include|#
directive|include
file|<qwaitcondition.h>
end_include
begin_include
include|#
directive|include
file|<private/qwineventnotifier_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"private/qfsfileengine_p.h"
end_include
begin_comment
comment|// for longFileName
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PROCESS
end_ifndef
begin_function
name|QT_BEGIN_NAMESPACE
comment|//#define QPROCESS_DEBUG
DECL|macro|NOTIFYTIMEOUT
define|#
directive|define
name|NOTIFYTIMEOUT
value|100
DECL|function|qt_create_pipe
specifier|static
name|void
name|qt_create_pipe
parameter_list|(
name|Q_PIPE
modifier|*
name|pipe
parameter_list|,
name|bool
name|in
parameter_list|)
block|{
comment|// Open the pipes.  Make non-inheritable copies of input write and output
comment|// read handles to avoid non-closable handles (this is done by the
comment|// DuplicateHandle() call).
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|SECURITY_ATTRIBUTES
name|secAtt
init|=
block|{
sizeof|sizeof
argument_list|(
name|SECURITY_ATTRIBUTES
argument_list|)
block|,
name|NULL
block|,
name|TRUE
block|}
decl_stmt|;
name|HANDLE
name|tmpHandle
decl_stmt|;
if|if
condition|(
name|in
condition|)
block|{
comment|// stdin
if|if
condition|(
operator|!
name|CreatePipe
argument_list|(
operator|&
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|tmpHandle
argument_list|,
operator|&
name|secAtt
argument_list|,
literal|1024
operator|*
literal|1024
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|tmpHandle
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|pipe
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
comment|// stdout or stderr
if|if
condition|(
operator|!
name|CreatePipe
argument_list|(
operator|&
name|tmpHandle
argument_list|,
operator|&
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|secAtt
argument_list|,
literal|1024
operator|*
literal|1024
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|tmpHandle
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|pipe
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
condition|)
return|return;
block|}
name|CloseHandle
argument_list|(
name|tmpHandle
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|in
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*     Create the pipes to a QProcessPrivate::Channel.      This function must be called in order: stdin, stdout, stderr */
end_comment
begin_function
DECL|function|createChannel
name|bool
name|QProcessPrivate
operator|::
name|createChannel
parameter_list|(
name|Channel
modifier|&
name|channel
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|channel
operator|==
operator|&
name|stderrChannel
operator|&&
name|processChannelMode
operator|==
name|QProcess
operator|::
name|MergedChannels
condition|)
block|{
return|return
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
return|;
block|}
if|if
condition|(
name|channel
operator|.
name|type
operator|==
name|Channel
operator|::
name|Normal
condition|)
block|{
comment|// we're piping this channel to our own process
name|qt_create_pipe
argument_list|(
name|channel
operator|.
name|pipe
argument_list|,
operator|&
name|channel
operator|==
operator|&
name|stdinChannel
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|channel
operator|.
name|type
operator|==
name|Channel
operator|::
name|Redirect
condition|)
block|{
comment|// we're redirecting the channel to/from a file
name|SECURITY_ATTRIBUTES
name|secAtt
init|=
block|{
sizeof|sizeof
argument_list|(
name|SECURITY_ATTRIBUTES
argument_list|)
block|,
name|NULL
block|,
name|TRUE
block|}
decl_stmt|;
if|if
condition|(
operator|&
name|channel
operator|==
operator|&
name|stdinChannel
condition|)
block|{
comment|// try to open in read-only mode
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
name|CreateFile
argument_list|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|QFSFileEnginePrivate
operator|::
name|longFileName
argument_list|(
name|channel
operator|.
name|file
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|,
name|GENERIC_READ
argument_list|,
name|FILE_SHARE_READ
operator||
name|FILE_SHARE_WRITE
argument_list|,
operator|&
name|secAtt
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
return|return
literal|true
return|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Could not open input redirection for reading"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// open in write mode
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
name|CreateFile
argument_list|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|QFSFileEnginePrivate
operator|::
name|longFileName
argument_list|(
name|channel
operator|.
name|file
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|,
name|GENERIC_WRITE
argument_list|,
name|FILE_SHARE_READ
operator||
name|FILE_SHARE_WRITE
argument_list|,
operator|&
name|secAtt
argument_list|,
name|channel
operator|.
name|append
condition|?
name|OPEN_ALWAYS
else|:
name|CREATE_ALWAYS
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
if|if
condition|(
name|channel
operator|.
name|append
condition|)
block|{
name|SetFilePointer
argument_list|(
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FILE_END
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Could not open output redirection for writing"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// could not open file
name|processError
operator|=
name|QProcess
operator|::
name|FailedToStart
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
name|cleanup
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|Q_ASSERT_X
argument_list|(
name|channel
operator|.
name|process
argument_list|,
literal|"QProcess::start"
argument_list|,
literal|"Internal error"
argument_list|)
expr_stmt|;
name|Channel
modifier|*
name|source
decl_stmt|;
name|Channel
modifier|*
name|sink
decl_stmt|;
if|if
condition|(
name|channel
operator|.
name|type
operator|==
name|Channel
operator|::
name|PipeSource
condition|)
block|{
comment|// we are the source
name|source
operator|=
operator|&
name|channel
expr_stmt|;
name|sink
operator|=
operator|&
name|channel
operator|.
name|process
operator|->
name|stdinChannel
expr_stmt|;
if|if
condition|(
name|source
operator|->
name|pipe
index|[
literal|1
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
comment|// already constructed by the sink
comment|// make it inheritable
name|HANDLE
name|tmpHandle
init|=
name|source
operator|->
name|pipe
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|tmpHandle
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|source
operator|->
name|pipe
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
condition|)
return|return
literal|false
return|;
name|CloseHandle
argument_list|(
name|tmpHandle
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|Q_ASSERT
argument_list|(
name|source
operator|==
operator|&
name|stdoutChannel
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|sink
operator|->
name|process
operator|==
name|this
operator|&&
name|sink
operator|->
name|type
operator|==
name|Channel
operator|::
name|PipeSink
argument_list|)
expr_stmt|;
name|qt_create_pipe
argument_list|(
name|source
operator|->
name|pipe
argument_list|,
comment|/* in = */
literal|false
argument_list|)
expr_stmt|;
comment|// source is stdout
name|sink
operator|->
name|pipe
index|[
literal|0
index|]
operator|=
name|source
operator|->
name|pipe
index|[
literal|0
index|]
expr_stmt|;
name|source
operator|->
name|pipe
index|[
literal|0
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// we are the sink;
name|source
operator|=
operator|&
name|channel
operator|.
name|process
operator|->
name|stdoutChannel
expr_stmt|;
name|sink
operator|=
operator|&
name|channel
expr_stmt|;
if|if
condition|(
name|sink
operator|->
name|pipe
index|[
literal|0
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
comment|// already constructed by the source
comment|// make it inheritable
name|HANDLE
name|tmpHandle
init|=
name|sink
operator|->
name|pipe
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|tmpHandle
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|sink
operator|->
name|pipe
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
condition|)
return|return
literal|false
return|;
name|CloseHandle
argument_list|(
name|tmpHandle
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|Q_ASSERT
argument_list|(
name|sink
operator|==
operator|&
name|stdinChannel
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|source
operator|->
name|process
operator|==
name|this
operator|&&
name|source
operator|->
name|type
operator|==
name|Channel
operator|::
name|PipeSource
argument_list|)
expr_stmt|;
name|qt_create_pipe
argument_list|(
name|sink
operator|->
name|pipe
argument_list|,
comment|/* in = */
literal|true
argument_list|)
expr_stmt|;
comment|// sink is stdin
name|source
operator|->
name|pipe
index|[
literal|1
index|]
operator|=
name|sink
operator|->
name|pipe
index|[
literal|1
index|]
expr_stmt|;
name|sink
operator|->
name|pipe
index|[
literal|1
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|destroyPipe
name|void
name|QProcessPrivate
operator|::
name|destroyPipe
parameter_list|(
name|Q_PIPE
name|pipe
index|[
literal|2
index|]
parameter_list|)
block|{
if|if
condition|(
name|pipe
index|[
literal|0
index|]
operator|==
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|&&
name|pipe
index|[
literal|1
index|]
operator|==
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|&&
name|pipeWriter
condition|)
block|{
operator|delete
name|pipeWriter
expr_stmt|;
name|pipeWriter
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pipe
index|[
literal|0
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
name|CloseHandle
argument_list|(
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pipe
index|[
literal|0
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
block|}
if|if
condition|(
name|pipe
index|[
literal|1
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
name|CloseHandle
argument_list|(
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pipe
index|[
literal|1
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|qt_create_commandline
specifier|static
name|QString
name|qt_create_commandline
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|)
block|{
name|QString
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|program
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|programName
init|=
name|program
decl_stmt|;
if|if
condition|(
operator|!
name|programName
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
argument_list|)
operator|&&
operator|!
name|programName
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
argument_list|)
operator|&&
name|programName
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
condition|)
name|programName
operator|=
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
operator|+
name|programName
operator|+
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|programName
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
comment|// add the prgram as the first arg ... it works better
name|args
operator|=
name|programName
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|tmp
init|=
name|arguments
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// in the case of \" already being in the string the \ must also be escaped
name|tmp
operator|.
name|replace
argument_list|(
name|QLatin1String
argument_list|(
literal|"\\\""
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"\\\\\""
argument_list|)
argument_list|)
expr_stmt|;
comment|// escape a single " because the arguments will be parsed
name|tmp
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"\\\""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|isEmpty
argument_list|()
operator|||
name|tmp
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
operator|||
name|tmp
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\t'
argument_list|)
argument_list|)
condition|)
block|{
comment|// The argument must not end with a \ since this would be interpreted
comment|// as escaping the quote -- rather put the \ behind the quote: e.g.
comment|// rather use "foo"\ than "foo\"
name|QString
name|endQuote
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|tmp
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|tmp
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
condition|)
block|{
operator|--
name|i
expr_stmt|;
name|endQuote
operator|+=
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|args
operator|+=
name|QLatin1String
argument_list|(
literal|" \""
argument_list|)
operator|+
name|tmp
operator|.
name|left
argument_list|(
name|i
argument_list|)
operator|+
name|endQuote
expr_stmt|;
block|}
else|else
block|{
name|args
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|tmp
expr_stmt|;
block|}
block|}
return|return
name|args
return|;
block|}
end_function
begin_function
DECL|function|qt_create_environment
specifier|static
name|QByteArray
name|qt_create_environment
parameter_list|(
specifier|const
name|QProcessEnvironmentPrivate
operator|::
name|Hash
modifier|&
name|environment
parameter_list|)
block|{
name|QByteArray
name|envlist
decl_stmt|;
if|if
condition|(
operator|!
name|environment
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QProcessEnvironmentPrivate
operator|::
name|Hash
name|copy
init|=
name|environment
decl_stmt|;
comment|// add PATH if necessary (for DLL loading)
name|QProcessEnvironmentPrivate
operator|::
name|Key
name|pathKey
argument_list|(
name|QLatin1String
argument_list|(
literal|"PATH"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|copy
operator|.
name|contains
argument_list|(
name|pathKey
argument_list|)
condition|)
block|{
name|QByteArray
name|path
init|=
name|qgetenv
argument_list|(
literal|"PATH"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
name|copy
operator|.
name|insert
argument_list|(
name|pathKey
argument_list|,
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// add systemroot if needed
name|QProcessEnvironmentPrivate
operator|::
name|Key
name|rootKey
argument_list|(
name|QLatin1String
argument_list|(
literal|"SystemRoot"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|copy
operator|.
name|contains
argument_list|(
name|rootKey
argument_list|)
condition|)
block|{
name|QByteArray
name|systemRoot
init|=
name|qgetenv
argument_list|(
literal|"SystemRoot"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|systemRoot
operator|.
name|isEmpty
argument_list|()
condition|)
name|copy
operator|.
name|insert
argument_list|(
name|rootKey
argument_list|,
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|systemRoot
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|QProcessEnvironmentPrivate
operator|::
name|Hash
operator|::
name|ConstIterator
name|it
init|=
name|copy
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|copy
operator|.
name|constEnd
argument_list|()
decl_stmt|;
specifier|static
specifier|const
name|wchar_t
name|equal
init|=
literal|L'
expr|='
decl_stmt|;
specifier|static
specifier|const
name|wchar_t
name|nul
init|=
literal|L'
expr|\0'
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|uint
name|tmpSize
init|=
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
operator|*
operator|(
name|it
operator|.
name|key
argument_list|()
operator|.
name|length
argument_list|()
operator|+
name|it
operator|.
name|value
argument_list|()
operator|.
name|length
argument_list|()
operator|+
literal|2
operator|)
decl_stmt|;
comment|// ignore empty strings
if|if
condition|(
name|tmpSize
operator|==
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
operator|*
literal|2
condition|)
continue|continue;
name|envlist
operator|.
name|resize
argument_list|(
name|envlist
operator|.
name|size
argument_list|()
operator|+
name|tmpSize
argument_list|)
expr_stmt|;
name|tmpSize
operator|=
name|it
operator|.
name|key
argument_list|()
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|envlist
operator|.
name|data
argument_list|()
operator|+
name|pos
argument_list|,
name|it
operator|.
name|key
argument_list|()
operator|.
name|utf16
argument_list|()
argument_list|,
name|tmpSize
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|tmpSize
expr_stmt|;
name|memcpy
argument_list|(
name|envlist
operator|.
name|data
argument_list|()
operator|+
name|pos
argument_list|,
operator|&
name|equal
argument_list|,
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|+=
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
expr_stmt|;
name|tmpSize
operator|=
name|it
operator|.
name|value
argument_list|()
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|envlist
operator|.
name|data
argument_list|()
operator|+
name|pos
argument_list|,
name|it
operator|.
name|value
argument_list|()
operator|.
name|utf16
argument_list|()
argument_list|,
name|tmpSize
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|tmpSize
expr_stmt|;
name|memcpy
argument_list|(
name|envlist
operator|.
name|data
argument_list|()
operator|+
name|pos
argument_list|,
operator|&
name|nul
argument_list|,
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|+=
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
expr_stmt|;
block|}
comment|// add the 2 terminating 0 (actually 4, just to be on the safe side)
name|envlist
operator|.
name|resize
argument_list|(
name|envlist
operator|.
name|size
argument_list|()
operator|+
literal|4
argument_list|)
expr_stmt|;
name|envlist
index|[
name|pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|envlist
index|[
name|pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|envlist
index|[
name|pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|envlist
index|[
name|pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|envlist
return|;
block|}
end_function
begin_function
DECL|function|startProcess
name|void
name|QProcessPrivate
operator|::
name|startProcess
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|bool
name|success
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|pid
condition|)
block|{
name|CloseHandle
argument_list|(
name|pid
operator|->
name|hThread
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|)
expr_stmt|;
operator|delete
name|pid
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
block|}
name|pid
operator|=
operator|new
name|PROCESS_INFORMATION
expr_stmt|;
name|memset
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|PROCESS_INFORMATION
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|Starting
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|createChannel
argument_list|(
name|stdinChannel
argument_list|)
operator|||
operator|!
name|createChannel
argument_list|(
name|stdoutChannel
argument_list|)
operator|||
operator|!
name|createChannel
argument_list|(
name|stderrChannel
argument_list|)
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|QString
name|args
init|=
name|qt_create_commandline
argument_list|(
name|QString
argument_list|()
argument_list|,
name|arguments
argument_list|)
decl_stmt|;
else|#
directive|else
name|QString
name|args
init|=
name|qt_create_commandline
argument_list|(
name|program
argument_list|,
name|arguments
argument_list|)
decl_stmt|;
name|QByteArray
name|envlist
decl_stmt|;
if|if
condition|(
name|environment
operator|.
name|d
operator|.
name|constData
argument_list|()
condition|)
name|envlist
operator|=
name|qt_create_environment
argument_list|(
name|environment
operator|.
name|d
operator|.
name|constData
argument_list|()
operator|->
name|hash
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|nativeArguments
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|args
operator|.
name|isEmpty
argument_list|()
condition|)
name|args
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|args
operator|+=
name|nativeArguments
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"Creating process"
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"   program : [%s]"
argument_list|,
name|program
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"   args : %s"
argument_list|,
name|args
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"   pass environment : %s"
argument_list|,
name|environment
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"no"
else|:
literal|"yes"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|QString
name|fullPathProgram
init|=
name|program
decl_stmt|;
if|if
condition|(
operator|!
name|QDir
operator|::
name|isAbsolutePath
argument_list|(
name|fullPathProgram
argument_list|)
condition|)
name|fullPathProgram
operator|=
name|QFileInfo
argument_list|(
name|fullPathProgram
argument_list|)
operator|.
name|absoluteFilePath
argument_list|()
expr_stmt|;
name|fullPathProgram
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
name|CreateProcess
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|fullPathProgram
operator|.
name|utf16
argument_list|()
argument_list|,
operator|(
name|wchar_t
operator|*
operator|)
name|args
operator|.
name|utf16
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pid
argument_list|)
expr_stmt|;
else|#
directive|else
name|DWORD
name|dwCreationFlags
init|=
name|CREATE_NO_WINDOW
decl_stmt|;
name|dwCreationFlags
operator||=
name|CREATE_UNICODE_ENVIRONMENT
expr_stmt|;
name|STARTUPINFOW
name|startupInfo
init|=
block|{
sizeof|sizeof
argument_list|(
name|STARTUPINFO
argument_list|)
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|STARTF_USESTDHANDLES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
block|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
block|,
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
block|}
decl_stmt|;
name|success
operator|=
name|CreateProcess
argument_list|(
literal|0
argument_list|,
operator|(
name|wchar_t
operator|*
operator|)
name|args
operator|.
name|utf16
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|dwCreationFlags
argument_list|,
name|environment
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|envlist
operator|.
name|data
argument_list|()
argument_list|,
name|workingDirectory
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
operator|(
name|wchar_t
operator|*
operator|)
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|workingDirectory
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|,
operator|&
name|startupInfo
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Capture the error string before we do CloseHandle below
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process failed to start: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|qt_error_string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
name|CloseHandle
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
block|}
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
name|CloseHandle
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
block|}
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
name|CloseHandle
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Q_OS_WINCE
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|processError
operator|=
name|QProcess
operator|::
name|FailedToStart
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
name|q
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|NotRunning
argument_list|)
expr_stmt|;
return|return;
block|}
name|q
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|Running
argument_list|)
expr_stmt|;
comment|// User can call kill()/terminate() from the stateChanged() slot
comment|// so check before proceeding
if|if
condition|(
operator|!
name|pid
condition|)
return|return;
if|if
condition|(
name|threadData
operator|->
name|eventDispatcher
condition|)
block|{
name|processFinishedNotifier
operator|=
operator|new
name|QWinEventNotifier
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|processFinishedNotifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|HANDLE
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_processDied
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|processFinishedNotifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|notifier
operator|=
operator|new
name|QTimer
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|notifier
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_notified
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|notifier
operator|->
name|start
argument_list|(
name|NOTIFYTIMEOUT
argument_list|)
expr_stmt|;
block|}
comment|// give the process a chance to start ...
name|Sleep
argument_list|(
name|SLEEPMIN
operator|*
literal|2
argument_list|)
expr_stmt|;
name|_q_startupNotification
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|processStarted
name|bool
name|QProcessPrivate
operator|::
name|processStarted
parameter_list|()
block|{
return|return
name|processState
operator|==
name|QProcess
operator|::
name|Running
return|;
block|}
end_function
begin_function
DECL|function|bytesAvailableFromStdout
name|qint64
name|QProcessPrivate
operator|::
name|bytesAvailableFromStdout
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|==
name|INVALID_Q_PIPE
condition|)
return|return
literal|0
return|;
name|DWORD
name|bytesAvail
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|PeekNamedPipe
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|bytesAvail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::bytesAvailableFromStdout() == %d"
argument_list|,
name|bytesAvail
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|processChannelMode
operator|==
name|QProcess
operator|::
name|ForwardedChannels
operator|&&
name|bytesAvail
operator|>
literal|0
condition|)
block|{
name|QByteArray
name|buf
argument_list|(
name|bytesAvail
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|DWORD
name|bytesRead
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ReadFile
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|buf
operator|.
name|data
argument_list|()
argument_list|,
name|buf
operator|.
name|size
argument_list|()
argument_list|,
operator|&
name|bytesRead
argument_list|,
literal|0
argument_list|)
operator|&&
name|bytesRead
operator|>
literal|0
condition|)
block|{
name|HANDLE
name|hStdout
init|=
name|GetStdHandle
argument_list|(
name|STD_OUTPUT_HANDLE
argument_list|)
decl_stmt|;
if|if
condition|(
name|hStdout
condition|)
block|{
name|DWORD
name|bytesWritten
init|=
literal|0
decl_stmt|;
name|WriteFile
argument_list|(
name|hStdout
argument_list|,
name|buf
operator|.
name|data
argument_list|()
argument_list|,
name|bytesRead
argument_list|,
operator|&
name|bytesWritten
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|bytesAvail
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|bytesAvail
return|;
block|}
end_function
begin_function
DECL|function|bytesAvailableFromStderr
name|qint64
name|QProcessPrivate
operator|::
name|bytesAvailableFromStderr
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|==
name|INVALID_Q_PIPE
condition|)
return|return
literal|0
return|;
name|DWORD
name|bytesAvail
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|PeekNamedPipe
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|bytesAvail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::bytesAvailableFromStderr() == %d"
argument_list|,
name|bytesAvail
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|processChannelMode
operator|==
name|QProcess
operator|::
name|ForwardedChannels
operator|&&
name|bytesAvail
operator|>
literal|0
condition|)
block|{
name|QByteArray
name|buf
argument_list|(
name|bytesAvail
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|DWORD
name|bytesRead
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ReadFile
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|buf
operator|.
name|data
argument_list|()
argument_list|,
name|buf
operator|.
name|size
argument_list|()
argument_list|,
operator|&
name|bytesRead
argument_list|,
literal|0
argument_list|)
operator|&&
name|bytesRead
operator|>
literal|0
condition|)
block|{
name|HANDLE
name|hStderr
init|=
name|GetStdHandle
argument_list|(
name|STD_ERROR_HANDLE
argument_list|)
decl_stmt|;
if|if
condition|(
name|hStderr
condition|)
block|{
name|DWORD
name|bytesWritten
init|=
literal|0
decl_stmt|;
name|WriteFile
argument_list|(
name|hStderr
argument_list|,
name|buf
operator|.
name|data
argument_list|()
argument_list|,
name|bytesRead
argument_list|,
operator|&
name|bytesWritten
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|bytesAvail
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|bytesAvail
return|;
block|}
end_function
begin_function
DECL|function|readFromStdout
name|qint64
name|QProcessPrivate
operator|::
name|readFromStdout
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|DWORD
name|read
init|=
name|qMin
argument_list|(
name|maxlen
argument_list|,
name|bytesAvailableFromStdout
argument_list|()
argument_list|)
decl_stmt|;
name|DWORD
name|bytesRead
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|read
operator|>
literal|0
operator|&&
operator|!
name|ReadFile
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|data
argument_list|,
name|read
argument_list|,
operator|&
name|bytesRead
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|bytesRead
return|;
block|}
end_function
begin_function
DECL|function|readFromStderr
name|qint64
name|QProcessPrivate
operator|::
name|readFromStderr
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|DWORD
name|read
init|=
name|qMin
argument_list|(
name|maxlen
argument_list|,
name|bytesAvailableFromStderr
argument_list|()
argument_list|)
decl_stmt|;
name|DWORD
name|bytesRead
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|read
operator|>
literal|0
operator|&&
operator|!
name|ReadFile
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|data
argument_list|,
name|read
argument_list|,
operator|&
name|bytesRead
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|bytesRead
return|;
block|}
end_function
begin_function
DECL|function|qt_terminateApp
specifier|static
name|BOOL
name|QT_WIN_CALLBACK
name|qt_terminateApp
parameter_list|(
name|HWND
name|hwnd
parameter_list|,
name|LPARAM
name|procId
parameter_list|)
block|{
name|DWORD
name|currentProcId
init|=
literal|0
decl_stmt|;
name|GetWindowThreadProcessId
argument_list|(
name|hwnd
argument_list|,
operator|&
name|currentProcId
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentProcId
operator|==
operator|(
name|DWORD
operator|)
name|procId
condition|)
name|PostMessage
argument_list|(
name|hwnd
argument_list|,
name|WM_CLOSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function
begin_function
DECL|function|terminateProcess
name|void
name|QProcessPrivate
operator|::
name|terminateProcess
parameter_list|()
block|{
if|if
condition|(
name|pid
condition|)
block|{
name|EnumWindows
argument_list|(
name|qt_terminateApp
argument_list|,
operator|(
name|LPARAM
operator|)
name|pid
operator|->
name|dwProcessId
argument_list|)
expr_stmt|;
name|PostThreadMessage
argument_list|(
name|pid
operator|->
name|dwThreadId
argument_list|,
name|WM_CLOSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|killProcess
name|void
name|QProcessPrivate
operator|::
name|killProcess
parameter_list|()
block|{
if|if
condition|(
name|pid
condition|)
name|TerminateProcess
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|,
literal|0xf291
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|waitForStarted
name|bool
name|QProcessPrivate
operator|::
name|waitForStarted
parameter_list|(
name|int
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|processStarted
argument_list|()
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|processError
operator|==
name|QProcess
operator|::
name|FailedToStart
condition|)
return|return
literal|false
return|;
name|processError
operator|=
name|QProcess
operator|::
name|Timedout
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|waitForReadyRead
name|bool
name|QProcessPrivate
operator|::
name|waitForReadyRead
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|processError
operator|=
name|QProcess
operator|::
name|ReadError
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Error reading from process"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
return|return
literal|false
return|;
endif|#
directive|endif
name|QIncrementalSleepTimer
name|timer
argument_list|(
name|msecs
argument_list|)
decl_stmt|;
forever|forever
block|{
if|if
condition|(
operator|!
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|_q_canWrite
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|pipeWriter
operator|&&
name|pipeWriter
operator|->
name|waitForWrite
argument_list|(
literal|0
argument_list|)
condition|)
name|timer
operator|.
name|resetIncrements
argument_list|()
expr_stmt|;
name|bool
name|readyReadEmitted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|bytesAvailableFromStdout
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|readyReadEmitted
operator|=
name|_q_canReadStandardOutput
argument_list|()
condition|?
literal|true
else|:
name|readyReadEmitted
expr_stmt|;
name|timer
operator|.
name|resetIncrements
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bytesAvailableFromStderr
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|readyReadEmitted
operator|=
name|_q_canReadStandardError
argument_list|()
condition|?
literal|true
else|:
name|readyReadEmitted
expr_stmt|;
name|timer
operator|.
name|resetIncrements
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|readyReadEmitted
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|pid
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|WaitForSingleObject
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|,
literal|0
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
block|{
comment|// find the return value if there is noew data to read
name|_q_processDied
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|Sleep
argument_list|(
name|timer
operator|.
name|nextSleepTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer
operator|.
name|hasTimedOut
argument_list|()
condition|)
break|break;
block|}
name|processError
operator|=
name|QProcess
operator|::
name|Timedout
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|waitForBytesWritten
name|bool
name|QProcessPrivate
operator|::
name|waitForBytesWritten
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|processError
operator|=
name|QProcess
operator|::
name|ReadError
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Error reading from process"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
return|return
literal|false
return|;
endif|#
directive|endif
name|QIncrementalSleepTimer
name|timer
argument_list|(
name|msecs
argument_list|)
decl_stmt|;
forever|forever
block|{
comment|// Check if we have any data pending: the pipe writer has
comment|// bytes waiting to written, or it has written data since the
comment|// last time we called pipeWriter->waitForWrite().
name|bool
name|pendingDataInPipe
init|=
name|pipeWriter
operator|&&
operator|(
name|pipeWriter
operator|->
name|bytesToWrite
argument_list|()
operator|||
name|pipeWriter
operator|->
name|hadWritten
argument_list|()
operator|)
decl_stmt|;
comment|// If we don't have pending data, and our write buffer is
comment|// empty, we fail.
if|if
condition|(
operator|!
name|pendingDataInPipe
operator|&&
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// If we don't have pending data and we do have data in our
comment|// write buffer, try to flush that data over to the pipe
comment|// writer.  Fail on error.
if|if
condition|(
operator|!
name|pendingDataInPipe
condition|)
block|{
if|if
condition|(
operator|!
name|_q_canWrite
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
comment|// Wait for the pipe writer to acknowledge that it has
comment|// written. This will succeed if either the pipe writer has
comment|// already written the data, or if it manages to write data
comment|// within the given timeout. If the write buffer was non-empty
comment|// and the pipeWriter is now dead, that means _q_canWrite()
comment|// destroyed the writer after it successfully wrote the last
comment|// batch.
if|if
condition|(
operator|!
name|pipeWriter
operator|||
name|pipeWriter
operator|->
name|waitForWrite
argument_list|(
literal|0
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// If we wouldn't write anything, check if we can read stdout.
if|if
condition|(
name|bytesAvailableFromStdout
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|_q_canReadStandardOutput
argument_list|()
expr_stmt|;
name|timer
operator|.
name|resetIncrements
argument_list|()
expr_stmt|;
block|}
comment|// Check if we can read stderr.
if|if
condition|(
name|bytesAvailableFromStderr
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|_q_canReadStandardError
argument_list|()
expr_stmt|;
name|timer
operator|.
name|resetIncrements
argument_list|()
expr_stmt|;
block|}
comment|// Check if the process died while reading.
if|if
condition|(
operator|!
name|pid
condition|)
return|return
literal|false
return|;
comment|// Wait for the process to signal any change in its state,
comment|// such as incoming data, or if the process died.
if|if
condition|(
name|WaitForSingleObject
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|,
literal|0
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
block|{
name|_q_processDied
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Only wait for as long as we've been asked.
if|if
condition|(
name|timer
operator|.
name|hasTimedOut
argument_list|()
condition|)
break|break;
block|}
name|processError
operator|=
name|QProcess
operator|::
name|Timedout
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|waitForFinished
name|bool
name|QProcessPrivate
operator|::
name|waitForFinished
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::waitForFinished(%d)"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QIncrementalSleepTimer
name|timer
argument_list|(
name|msecs
argument_list|)
decl_stmt|;
forever|forever
block|{
if|if
condition|(
operator|!
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|_q_canWrite
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|pipeWriter
operator|&&
name|pipeWriter
operator|->
name|waitForWrite
argument_list|(
literal|0
argument_list|)
condition|)
name|timer
operator|.
name|resetIncrements
argument_list|()
expr_stmt|;
if|if
condition|(
name|bytesAvailableFromStdout
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|_q_canReadStandardOutput
argument_list|()
expr_stmt|;
name|timer
operator|.
name|resetIncrements
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bytesAvailableFromStderr
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|_q_canReadStandardError
argument_list|()
expr_stmt|;
name|timer
operator|.
name|resetIncrements
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pid
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|WaitForSingleObject
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|,
name|timer
operator|.
name|nextSleepTime
argument_list|()
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
block|{
name|_q_processDied
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|timer
operator|.
name|hasTimedOut
argument_list|()
condition|)
break|break;
block|}
name|processError
operator|=
name|QProcess
operator|::
name|Timedout
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|findExitCode
name|void
name|QProcessPrivate
operator|::
name|findExitCode
parameter_list|()
block|{
name|DWORD
name|theExitCode
decl_stmt|;
if|if
condition|(
name|GetExitCodeProcess
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|,
operator|&
name|theExitCode
argument_list|)
condition|)
block|{
name|exitCode
operator|=
name|theExitCode
expr_stmt|;
comment|//### for now we assume a crash if exit code is less than -1 or the magic number
name|crashed
operator|=
operator|(
name|exitCode
operator|==
literal|0xf291
operator|||
operator|(
name|int
operator|)
name|exitCode
operator|<
literal|0
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|flushPipeWriter
name|void
name|QProcessPrivate
operator|::
name|flushPipeWriter
parameter_list|()
block|{
if|if
condition|(
name|pipeWriter
operator|&&
name|pipeWriter
operator|->
name|bytesToWrite
argument_list|()
operator|>
literal|0
condition|)
block|{
name|pipeWriter
operator|->
name|waitForWrite
argument_list|(
name|ULONG_MAX
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|pipeWriterBytesToWrite
name|qint64
name|QProcessPrivate
operator|::
name|pipeWriterBytesToWrite
parameter_list|()
specifier|const
block|{
return|return
name|pipeWriter
condition|?
name|pipeWriter
operator|->
name|bytesToWrite
argument_list|()
else|:
name|qint64
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|writeToStdin
name|qint64
name|QProcessPrivate
operator|::
name|writeToStdin
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|processError
operator|=
name|QProcess
operator|::
name|WriteError
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Error writing to process"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pipeWriter
condition|)
block|{
name|pipeWriter
operator|=
operator|new
name|QWindowsPipeWriter
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|pipeWriter
operator|->
name|start
argument_list|()
expr_stmt|;
block|}
return|return
name|pipeWriter
operator|->
name|write
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|waitForWrite
name|bool
name|QProcessPrivate
operator|::
name|waitForWrite
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pipeWriter
operator|||
name|pipeWriter
operator|->
name|waitForWrite
argument_list|(
name|msecs
argument_list|)
condition|)
return|return
literal|true
return|;
name|processError
operator|=
name|QProcess
operator|::
name|Timedout
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|_q_notified
name|void
name|QProcessPrivate
operator|::
name|_q_notified
parameter_list|()
block|{
name|notifier
operator|->
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|!
name|pipeWriter
operator|||
name|pipeWriter
operator|->
name|waitForWrite
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
name|_q_canWrite
argument_list|()
expr_stmt|;
if|if
condition|(
name|bytesAvailableFromStdout
argument_list|()
condition|)
name|_q_canReadStandardOutput
argument_list|()
expr_stmt|;
if|if
condition|(
name|bytesAvailableFromStderr
argument_list|()
condition|)
name|_q_canReadStandardError
argument_list|()
expr_stmt|;
if|if
condition|(
name|processState
operator|!=
name|QProcess
operator|::
name|NotRunning
condition|)
name|notifier
operator|->
name|start
argument_list|(
name|NOTIFYTIMEOUT
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|startDetached
name|bool
name|QProcessPrivate
operator|::
name|startDetached
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|,
specifier|const
name|QString
modifier|&
name|workingDir
parameter_list|,
name|qint64
modifier|*
name|pid
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|Q_UNUSED
argument_list|(
name|workingDir
argument_list|)
expr_stmt|;
name|QString
name|args
init|=
name|qt_create_commandline
argument_list|(
name|QString
argument_list|()
argument_list|,
name|arguments
argument_list|)
decl_stmt|;
else|#
directive|else
name|QString
name|args
init|=
name|qt_create_commandline
argument_list|(
name|program
argument_list|,
name|arguments
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|bool
name|success
init|=
literal|false
decl_stmt|;
name|PROCESS_INFORMATION
name|pinfo
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|QString
name|fullPathProgram
init|=
name|program
decl_stmt|;
if|if
condition|(
operator|!
name|QDir
operator|::
name|isAbsolutePath
argument_list|(
name|fullPathProgram
argument_list|)
condition|)
name|fullPathProgram
operator|.
name|prepend
argument_list|(
name|QDir
operator|::
name|currentPath
argument_list|()
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fullPathProgram
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
name|CreateProcess
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|fullPathProgram
operator|.
name|utf16
argument_list|()
argument_list|,
operator|(
name|wchar_t
operator|*
operator|)
name|args
operator|.
name|utf16
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|CREATE_NEW_CONSOLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|pinfo
argument_list|)
expr_stmt|;
else|#
directive|else
name|STARTUPINFOW
name|startupInfo
init|=
block|{
sizeof|sizeof
argument_list|(
name|STARTUPINFO
argument_list|)
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|success
operator|=
name|CreateProcess
argument_list|(
literal|0
argument_list|,
operator|(
name|wchar_t
operator|*
operator|)
name|args
operator|.
name|utf16
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|CREATE_UNICODE_ENVIRONMENT
operator||
name|CREATE_NEW_CONSOLE
argument_list|,
literal|0
argument_list|,
name|workingDir
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
operator|(
name|wchar_t
operator|*
operator|)
name|workingDir
operator|.
name|utf16
argument_list|()
argument_list|,
operator|&
name|startupInfo
argument_list|,
operator|&
name|pinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Q_OS_WINCE
if|if
condition|(
name|success
condition|)
block|{
name|CloseHandle
argument_list|(
name|pinfo
operator|.
name|hThread
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|pinfo
operator|.
name|hProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
condition|)
operator|*
name|pid
operator|=
name|pinfo
operator|.
name|dwProcessId
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PROCESS
end_comment
end_unit
