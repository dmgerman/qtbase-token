begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia. For licensing terms and ** conditions see http://qt.digia.com/licensing. For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights. These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qprocess.h"
end_include
begin_include
include|#
directive|include
file|"qprocess_p.h"
end_include
begin_include
include|#
directive|include
file|"qwindowspipereader_p.h"
end_include
begin_include
include|#
directive|include
file|"qwindowspipewriter_p.h"
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qelapsedtimer.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qregexp.h>
end_include
begin_include
include|#
directive|include
file|<qtimer.h>
end_include
begin_include
include|#
directive|include
file|<qwineventnotifier.h>
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"private/qfsfileengine_p.h"
end_include
begin_comment
comment|// for longFileName
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PIPE_REJECT_REMOTE_CLIENTS
end_ifndef
begin_define
DECL|macro|PIPE_REJECT_REMOTE_CLIENTS
define|#
directive|define
name|PIPE_REJECT_REMOTE_CLIENTS
value|0x08
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PROCESS
end_ifndef
begin_function
name|QT_BEGIN_NAMESPACE
comment|//#define QPROCESS_DEBUG
DECL|macro|NOTIFYTIMEOUT
define|#
directive|define
name|NOTIFYTIMEOUT
value|100
DECL|function|qt_create_pipe
specifier|static
name|void
name|qt_create_pipe
parameter_list|(
name|Q_PIPE
modifier|*
name|pipe
parameter_list|,
name|bool
name|isInputPipe
parameter_list|)
block|{
comment|// Anomymous pipes do not support asynchronous I/O. Thus we
comment|// create named pipes for redirecting stdout, stderr and stdin.
comment|// The write handle must be non-inheritable for input pipes.
comment|// The read handle must be non-inheritable for output pipes.
name|SECURITY_ATTRIBUTES
name|secAtt
init|=
block|{
sizeof|sizeof
argument_list|(
name|SECURITY_ATTRIBUTES
argument_list|)
block|,
literal|0
block|,
literal|false
block|}
decl_stmt|;
name|HANDLE
name|hServer
decl_stmt|;
name|wchar_t
name|pipeName
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|int
name|attempts
init|=
literal|1000
decl_stmt|;
forever|forever
block|{
comment|// ### The user must make sure to call qsrand() to make the pipe names less predictable.
comment|// ### Replace the call to qrand() with a secure version, once we have it in Qt.
name|_snwprintf
argument_list|(
name|pipeName
argument_list|,
sizeof|sizeof
argument_list|(
name|pipeName
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pipeName
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|L"\\\\.\\pipe\\qt-%X"
argument_list|,
name|qrand
argument_list|()
argument_list|)
expr_stmt|;
name|DWORD
name|dwOpenMode
init|=
name|FILE_FLAG_OVERLAPPED
decl_stmt|;
name|DWORD
name|dwOutputBufferSize
init|=
literal|0
decl_stmt|;
name|DWORD
name|dwInputBufferSize
init|=
literal|0
decl_stmt|;
specifier|const
name|DWORD
name|dwPipeBufferSize
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
if|if
condition|(
name|isInputPipe
condition|)
block|{
name|dwOpenMode
operator||=
name|PIPE_ACCESS_OUTBOUND
expr_stmt|;
name|dwOutputBufferSize
operator|=
name|dwPipeBufferSize
expr_stmt|;
block|}
else|else
block|{
name|dwOpenMode
operator||=
name|PIPE_ACCESS_INBOUND
expr_stmt|;
name|dwInputBufferSize
operator|=
name|dwPipeBufferSize
expr_stmt|;
block|}
name|DWORD
name|dwPipeFlags
init|=
name|PIPE_TYPE_BYTE
operator||
name|PIPE_WAIT
decl_stmt|;
if|if
condition|(
name|QSysInfo
operator|::
name|windowsVersion
argument_list|()
operator|>=
name|QSysInfo
operator|::
name|WV_VISTA
condition|)
name|dwPipeFlags
operator||=
name|PIPE_REJECT_REMOTE_CLIENTS
expr_stmt|;
name|hServer
operator|=
name|CreateNamedPipe
argument_list|(
name|pipeName
argument_list|,
name|dwOpenMode
argument_list|,
name|dwPipeFlags
argument_list|,
literal|1
argument_list|,
comment|// only one pipe instance
name|dwOutputBufferSize
argument_list|,
name|dwInputBufferSize
argument_list|,
literal|0
argument_list|,
operator|&
name|secAtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|hServer
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
break|break;
name|DWORD
name|dwError
init|=
name|GetLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|dwError
operator|!=
name|ERROR_PIPE_BUSY
operator|||
operator|!
operator|--
name|attempts
condition|)
block|{
name|qErrnoWarning
argument_list|(
name|dwError
argument_list|,
literal|"QProcess: CreateNamedPipe failed."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|secAtt
operator|.
name|bInheritHandle
operator|=
name|TRUE
expr_stmt|;
specifier|const
name|HANDLE
name|hClient
init|=
name|CreateFile
argument_list|(
name|pipeName
argument_list|,
operator|(
name|isInputPipe
condition|?
operator|(
name|GENERIC_READ
operator||
name|FILE_WRITE_ATTRIBUTES
operator|)
else|:
name|GENERIC_WRITE
operator|)
argument_list|,
literal|0
argument_list|,
operator|&
name|secAtt
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_OVERLAPPED
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|hClient
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|qErrnoWarning
argument_list|(
literal|"QProcess: CreateFile failed."
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|hServer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Wait until connection is in place.
name|ConnectNamedPipe
argument_list|(
name|hServer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInputPipe
condition|)
block|{
name|pipe
index|[
literal|0
index|]
operator|=
name|hClient
expr_stmt|;
name|pipe
index|[
literal|1
index|]
operator|=
name|hServer
expr_stmt|;
block|}
else|else
block|{
name|pipe
index|[
literal|0
index|]
operator|=
name|hServer
expr_stmt|;
name|pipe
index|[
literal|1
index|]
operator|=
name|hClient
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|duplicateStdWriteChannel
specifier|static
name|void
name|duplicateStdWriteChannel
parameter_list|(
name|Q_PIPE
modifier|*
name|pipe
parameter_list|,
name|DWORD
name|nStdHandle
parameter_list|)
block|{
name|pipe
index|[
literal|0
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
name|HANDLE
name|hStdWriteChannel
init|=
name|GetStdHandle
argument_list|(
name|nStdHandle
argument_list|)
decl_stmt|;
name|HANDLE
name|hCurrentProcess
init|=
name|GetCurrentProcess
argument_list|()
decl_stmt|;
name|DuplicateHandle
argument_list|(
name|hCurrentProcess
argument_list|,
name|hStdWriteChannel
argument_list|,
name|hCurrentProcess
argument_list|,
operator|&
name|pipe
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     Create the pipes to a QProcessPrivate::Channel.      This function must be called in order: stdin, stdout, stderr */
end_comment
begin_function
DECL|function|openChannel
name|bool
name|QProcessPrivate
operator|::
name|openChannel
parameter_list|(
name|Channel
modifier|&
name|channel
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|channel
operator|==
operator|&
name|stderrChannel
operator|&&
name|processChannelMode
operator|==
name|QProcess
operator|::
name|MergedChannels
condition|)
block|{
return|return
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
return|;
block|}
if|if
condition|(
name|channel
operator|.
name|type
operator|==
name|Channel
operator|::
name|Normal
condition|)
block|{
comment|// we're piping this channel to our own process
if|if
condition|(
operator|&
name|channel
operator|==
operator|&
name|stdinChannel
condition|)
block|{
if|if
condition|(
name|inputChannelMode
operator|!=
name|QProcess
operator|::
name|ForwardedInputChannel
condition|)
block|{
name|qt_create_pipe
argument_list|(
name|channel
operator|.
name|pipe
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
name|HANDLE
name|hStdReadChannel
init|=
name|GetStdHandle
argument_list|(
name|STD_INPUT_HANDLE
argument_list|)
decl_stmt|;
name|HANDLE
name|hCurrentProcess
init|=
name|GetCurrentProcess
argument_list|()
decl_stmt|;
name|DuplicateHandle
argument_list|(
name|hCurrentProcess
argument_list|,
name|hStdReadChannel
argument_list|,
name|hCurrentProcess
argument_list|,
operator|&
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|&
name|channel
operator|==
operator|&
name|stdoutChannel
condition|)
block|{
if|if
condition|(
name|processChannelMode
operator|!=
name|QProcess
operator|::
name|ForwardedChannels
operator|&&
name|processChannelMode
operator|!=
name|QProcess
operator|::
name|ForwardedOutputChannel
condition|)
block|{
if|if
condition|(
operator|!
name|stdoutChannel
operator|.
name|reader
condition|)
block|{
name|stdoutChannel
operator|.
name|reader
operator|=
operator|new
name|QWindowsPipeReader
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|connect
argument_list|(
name|stdoutChannel
operator|.
name|reader
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|_q_canReadStandardOutput
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|duplicateStdWriteChannel
argument_list|(
name|channel
operator|.
name|pipe
argument_list|,
name|STD_OUTPUT_HANDLE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* if (&channel ==&stderrChannel) */
block|{
if|if
condition|(
name|processChannelMode
operator|!=
name|QProcess
operator|::
name|ForwardedChannels
operator|&&
name|processChannelMode
operator|!=
name|QProcess
operator|::
name|ForwardedErrorChannel
condition|)
block|{
if|if
condition|(
operator|!
name|stderrChannel
operator|.
name|reader
condition|)
block|{
name|stderrChannel
operator|.
name|reader
operator|=
operator|new
name|QWindowsPipeReader
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|connect
argument_list|(
name|stderrChannel
operator|.
name|reader
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|_q_canReadStandardError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|duplicateStdWriteChannel
argument_list|(
name|channel
operator|.
name|pipe
argument_list|,
name|STD_ERROR_HANDLE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|channel
operator|.
name|reader
condition|)
block|{
name|qt_create_pipe
argument_list|(
name|channel
operator|.
name|pipe
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|channel
operator|.
name|reader
operator|->
name|setHandle
argument_list|(
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|channel
operator|.
name|reader
operator|->
name|startAsyncRead
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|channel
operator|.
name|type
operator|==
name|Channel
operator|::
name|Redirect
condition|)
block|{
comment|// we're redirecting the channel to/from a file
name|SECURITY_ATTRIBUTES
name|secAtt
init|=
block|{
sizeof|sizeof
argument_list|(
name|SECURITY_ATTRIBUTES
argument_list|)
block|,
name|NULL
block|,
name|TRUE
block|}
decl_stmt|;
if|if
condition|(
operator|&
name|channel
operator|==
operator|&
name|stdinChannel
condition|)
block|{
comment|// try to open in read-only mode
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
name|CreateFile
argument_list|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|QFSFileEnginePrivate
operator|::
name|longFileName
argument_list|(
name|channel
operator|.
name|file
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|,
name|GENERIC_READ
argument_list|,
name|FILE_SHARE_READ
operator||
name|FILE_SHARE_WRITE
argument_list|,
operator|&
name|secAtt
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
return|return
literal|true
return|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Could not open input redirection for reading"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// open in write mode
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
name|CreateFile
argument_list|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|QFSFileEnginePrivate
operator|::
name|longFileName
argument_list|(
name|channel
operator|.
name|file
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|,
name|GENERIC_WRITE
argument_list|,
name|FILE_SHARE_READ
operator||
name|FILE_SHARE_WRITE
argument_list|,
operator|&
name|secAtt
argument_list|,
name|channel
operator|.
name|append
condition|?
name|OPEN_ALWAYS
else|:
name|CREATE_ALWAYS
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
if|if
condition|(
name|channel
operator|.
name|append
condition|)
block|{
name|SetFilePointer
argument_list|(
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FILE_END
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Could not open output redirection for writing"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// could not open file
name|processError
operator|=
name|QProcess
operator|::
name|FailedToStart
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
name|cleanup
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|Q_ASSERT_X
argument_list|(
name|channel
operator|.
name|process
argument_list|,
literal|"QProcess::start"
argument_list|,
literal|"Internal error"
argument_list|)
expr_stmt|;
name|Channel
modifier|*
name|source
decl_stmt|;
name|Channel
modifier|*
name|sink
decl_stmt|;
if|if
condition|(
name|channel
operator|.
name|type
operator|==
name|Channel
operator|::
name|PipeSource
condition|)
block|{
comment|// we are the source
name|source
operator|=
operator|&
name|channel
expr_stmt|;
name|sink
operator|=
operator|&
name|channel
operator|.
name|process
operator|->
name|stdinChannel
expr_stmt|;
if|if
condition|(
name|source
operator|->
name|pipe
index|[
literal|1
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
comment|// already constructed by the sink
comment|// make it inheritable
name|HANDLE
name|tmpHandle
init|=
name|source
operator|->
name|pipe
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|tmpHandle
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|source
operator|->
name|pipe
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
condition|)
return|return
literal|false
return|;
name|CloseHandle
argument_list|(
name|tmpHandle
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|Q_ASSERT
argument_list|(
name|source
operator|==
operator|&
name|stdoutChannel
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|sink
operator|->
name|process
operator|==
name|this
operator|&&
name|sink
operator|->
name|type
operator|==
name|Channel
operator|::
name|PipeSink
argument_list|)
expr_stmt|;
name|qt_create_pipe
argument_list|(
name|source
operator|->
name|pipe
argument_list|,
comment|/* in = */
literal|false
argument_list|)
expr_stmt|;
comment|// source is stdout
name|sink
operator|->
name|pipe
index|[
literal|0
index|]
operator|=
name|source
operator|->
name|pipe
index|[
literal|0
index|]
expr_stmt|;
name|source
operator|->
name|pipe
index|[
literal|0
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// we are the sink;
name|source
operator|=
operator|&
name|channel
operator|.
name|process
operator|->
name|stdoutChannel
expr_stmt|;
name|sink
operator|=
operator|&
name|channel
expr_stmt|;
if|if
condition|(
name|sink
operator|->
name|pipe
index|[
literal|0
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
comment|// already constructed by the source
comment|// make it inheritable
name|HANDLE
name|tmpHandle
init|=
name|sink
operator|->
name|pipe
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|tmpHandle
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|sink
operator|->
name|pipe
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
condition|)
return|return
literal|false
return|;
name|CloseHandle
argument_list|(
name|tmpHandle
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|Q_ASSERT
argument_list|(
name|sink
operator|==
operator|&
name|stdinChannel
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|source
operator|->
name|process
operator|==
name|this
operator|&&
name|source
operator|->
name|type
operator|==
name|Channel
operator|::
name|PipeSource
argument_list|)
expr_stmt|;
name|qt_create_pipe
argument_list|(
name|sink
operator|->
name|pipe
argument_list|,
comment|/* in = */
literal|true
argument_list|)
expr_stmt|;
comment|// sink is stdin
name|source
operator|->
name|pipe
index|[
literal|1
index|]
operator|=
name|sink
operator|->
name|pipe
index|[
literal|1
index|]
expr_stmt|;
name|sink
operator|->
name|pipe
index|[
literal|1
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|destroyPipe
name|void
name|QProcessPrivate
operator|::
name|destroyPipe
parameter_list|(
name|Q_PIPE
name|pipe
index|[
literal|2
index|]
parameter_list|)
block|{
if|if
condition|(
name|pipe
index|[
literal|0
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
name|CloseHandle
argument_list|(
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pipe
index|[
literal|0
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
block|}
if|if
condition|(
name|pipe
index|[
literal|1
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
name|CloseHandle
argument_list|(
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pipe
index|[
literal|1
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|closeChannel
name|void
name|QProcessPrivate
operator|::
name|closeChannel
parameter_list|(
name|Channel
modifier|*
name|channel
parameter_list|)
block|{
if|if
condition|(
name|channel
operator|==
operator|&
name|stdinChannel
condition|)
block|{
operator|delete
name|stdinChannel
operator|.
name|writer
expr_stmt|;
name|stdinChannel
operator|.
name|writer
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|channel
operator|->
name|reader
condition|)
block|{
name|channel
operator|->
name|reader
operator|->
name|stop
argument_list|()
expr_stmt|;
name|channel
operator|->
name|reader
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
name|channel
operator|->
name|reader
operator|=
literal|0
expr_stmt|;
block|}
name|destroyPipe
argument_list|(
name|channel
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_create_commandline
specifier|static
name|QString
name|qt_create_commandline
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|)
block|{
name|QString
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|program
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|programName
init|=
name|program
decl_stmt|;
if|if
condition|(
operator|!
name|programName
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
argument_list|)
operator|&&
operator|!
name|programName
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
argument_list|)
operator|&&
name|programName
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
condition|)
name|programName
operator|=
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
operator|+
name|programName
operator|+
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|programName
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
comment|// add the prgram as the first arg ... it works better
name|args
operator|=
name|programName
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|tmp
init|=
name|arguments
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Quotes are escaped and their preceding backslashes are doubled.
name|tmp
operator|.
name|replace
argument_list|(
name|QRegExp
argument_list|(
name|QLatin1String
argument_list|(
literal|"(\\\\*)\""
argument_list|)
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"\\1\\1\\\""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|isEmpty
argument_list|()
operator|||
name|tmp
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
operator|||
name|tmp
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\t'
argument_list|)
argument_list|)
condition|)
block|{
comment|// The argument must not end with a \ since this would be interpreted
comment|// as escaping the quote -- rather put the \ behind the quote: e.g.
comment|// rather use "foo"\ than "foo\"
name|int
name|i
init|=
name|tmp
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|tmp
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
condition|)
operator|--
name|i
expr_stmt|;
name|tmp
operator|.
name|insert
argument_list|(
name|i
argument_list|,
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|args
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|tmp
expr_stmt|;
block|}
return|return
name|args
return|;
block|}
end_function
begin_function
DECL|function|systemEnvironment
name|QProcessEnvironment
name|QProcessEnvironment
operator|::
name|systemEnvironment
parameter_list|()
block|{
name|QProcessEnvironment
name|env
decl_stmt|;
comment|// Calls to setenv() affect the low-level environment as well.
comment|// This is not the case the other way round.
if|if
condition|(
name|wchar_t
modifier|*
name|envStrings
init|=
name|GetEnvironmentStringsW
argument_list|()
condition|)
block|{
for|for
control|(
specifier|const
name|wchar_t
modifier|*
name|entry
init|=
name|envStrings
init|;
operator|*
name|entry
condition|;
control|)
block|{
specifier|const
name|int
name|entryLen
init|=
name|int
argument_list|(
name|wcslen
argument_list|(
name|entry
argument_list|)
argument_list|)
decl_stmt|;
comment|// + 1 to permit magic cmd variable names starting with =
if|if
condition|(
specifier|const
name|wchar_t
modifier|*
name|equal
init|=
name|wcschr
argument_list|(
name|entry
operator|+
literal|1
argument_list|,
literal|L'
expr|='
argument_list|)
condition|)
block|{
name|int
name|nameLen
init|=
name|equal
operator|-
name|entry
decl_stmt|;
name|QString
name|name
init|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|entry
argument_list|,
name|nameLen
argument_list|)
decl_stmt|;
name|QString
name|value
init|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|equal
operator|+
literal|1
argument_list|,
name|entryLen
operator|-
name|nameLen
operator|-
literal|1
argument_list|)
decl_stmt|;
name|env
operator|.
name|d
operator|->
name|hash
operator|.
name|insert
argument_list|(
name|QProcessEnvironmentPrivate
operator|::
name|Key
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|entry
operator|+=
name|entryLen
operator|+
literal|1
expr_stmt|;
block|}
name|FreeEnvironmentStringsW
argument_list|(
name|envStrings
argument_list|)
expr_stmt|;
block|}
return|return
name|env
return|;
block|}
end_function
begin_function
DECL|function|qt_create_environment
specifier|static
name|QByteArray
name|qt_create_environment
parameter_list|(
specifier|const
name|QProcessEnvironmentPrivate
operator|::
name|Hash
modifier|&
name|environment
parameter_list|)
block|{
name|QByteArray
name|envlist
decl_stmt|;
if|if
condition|(
operator|!
name|environment
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QProcessEnvironmentPrivate
operator|::
name|Hash
name|copy
init|=
name|environment
decl_stmt|;
comment|// add PATH if necessary (for DLL loading)
name|QProcessEnvironmentPrivate
operator|::
name|Key
name|pathKey
argument_list|(
name|QLatin1String
argument_list|(
literal|"PATH"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|copy
operator|.
name|contains
argument_list|(
name|pathKey
argument_list|)
condition|)
block|{
name|QByteArray
name|path
init|=
name|qgetenv
argument_list|(
literal|"PATH"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
name|copy
operator|.
name|insert
argument_list|(
name|pathKey
argument_list|,
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// add systemroot if needed
name|QProcessEnvironmentPrivate
operator|::
name|Key
name|rootKey
argument_list|(
name|QLatin1String
argument_list|(
literal|"SystemRoot"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|copy
operator|.
name|contains
argument_list|(
name|rootKey
argument_list|)
condition|)
block|{
name|QByteArray
name|systemRoot
init|=
name|qgetenv
argument_list|(
literal|"SystemRoot"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|systemRoot
operator|.
name|isEmpty
argument_list|()
condition|)
name|copy
operator|.
name|insert
argument_list|(
name|rootKey
argument_list|,
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|systemRoot
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|QProcessEnvironmentPrivate
operator|::
name|Hash
operator|::
name|ConstIterator
name|it
init|=
name|copy
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|copy
operator|.
name|constEnd
argument_list|()
decl_stmt|;
specifier|static
specifier|const
name|wchar_t
name|equal
init|=
literal|L'
expr|='
decl_stmt|;
specifier|static
specifier|const
name|wchar_t
name|nul
init|=
literal|L'
expr|\0'
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|uint
name|tmpSize
init|=
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
operator|*
operator|(
name|it
operator|.
name|key
argument_list|()
operator|.
name|length
argument_list|()
operator|+
name|it
operator|.
name|value
argument_list|()
operator|.
name|length
argument_list|()
operator|+
literal|2
operator|)
decl_stmt|;
comment|// ignore empty strings
if|if
condition|(
name|tmpSize
operator|==
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
operator|*
literal|2
condition|)
continue|continue;
name|envlist
operator|.
name|resize
argument_list|(
name|envlist
operator|.
name|size
argument_list|()
operator|+
name|tmpSize
argument_list|)
expr_stmt|;
name|tmpSize
operator|=
name|it
operator|.
name|key
argument_list|()
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|envlist
operator|.
name|data
argument_list|()
operator|+
name|pos
argument_list|,
name|it
operator|.
name|key
argument_list|()
operator|.
name|utf16
argument_list|()
argument_list|,
name|tmpSize
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|tmpSize
expr_stmt|;
name|memcpy
argument_list|(
name|envlist
operator|.
name|data
argument_list|()
operator|+
name|pos
argument_list|,
operator|&
name|equal
argument_list|,
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|+=
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
expr_stmt|;
name|tmpSize
operator|=
name|it
operator|.
name|value
argument_list|()
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|envlist
operator|.
name|data
argument_list|()
operator|+
name|pos
argument_list|,
name|it
operator|.
name|value
argument_list|()
operator|.
name|utf16
argument_list|()
argument_list|,
name|tmpSize
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|tmpSize
expr_stmt|;
name|memcpy
argument_list|(
name|envlist
operator|.
name|data
argument_list|()
operator|+
name|pos
argument_list|,
operator|&
name|nul
argument_list|,
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|+=
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
expr_stmt|;
block|}
comment|// add the 2 terminating 0 (actually 4, just to be on the safe side)
name|envlist
operator|.
name|resize
argument_list|(
name|envlist
operator|.
name|size
argument_list|()
operator|+
literal|4
argument_list|)
expr_stmt|;
name|envlist
index|[
name|pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|envlist
index|[
name|pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|envlist
index|[
name|pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|envlist
index|[
name|pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|envlist
return|;
block|}
end_function
begin_function
DECL|function|startProcess
name|void
name|QProcessPrivate
operator|::
name|startProcess
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|bool
name|success
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|pid
condition|)
block|{
name|CloseHandle
argument_list|(
name|pid
operator|->
name|hThread
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|)
expr_stmt|;
operator|delete
name|pid
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
block|}
name|pid
operator|=
operator|new
name|PROCESS_INFORMATION
expr_stmt|;
name|memset
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|PROCESS_INFORMATION
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|Starting
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|openChannel
argument_list|(
name|stdinChannel
argument_list|)
operator|||
operator|!
name|openChannel
argument_list|(
name|stdoutChannel
argument_list|)
operator|||
operator|!
name|openChannel
argument_list|(
name|stderrChannel
argument_list|)
condition|)
return|return;
name|QString
name|args
init|=
name|qt_create_commandline
argument_list|(
name|program
argument_list|,
name|arguments
argument_list|)
decl_stmt|;
name|QByteArray
name|envlist
decl_stmt|;
if|if
condition|(
name|environment
operator|.
name|d
operator|.
name|constData
argument_list|()
condition|)
name|envlist
operator|=
name|qt_create_environment
argument_list|(
name|environment
operator|.
name|d
operator|.
name|constData
argument_list|()
operator|->
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nativeArguments
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|args
operator|.
name|isEmpty
argument_list|()
condition|)
name|args
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|args
operator|+=
name|nativeArguments
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"Creating process"
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"   program : [%s]"
argument_list|,
name|program
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"   args : %s"
argument_list|,
name|args
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"   pass environment : %s"
argument_list|,
name|environment
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"no"
else|:
literal|"yes"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// We cannot unconditionally set the CREATE_NO_WINDOW flag, because this
comment|// will render the stdout/stderr handles connected to a console useless
comment|// (this typically affects ForwardedChannels mode).
comment|// However, we also do not want console tools launched from a GUI app to
comment|// create new console windows (behavior consistent with UNIX).
name|DWORD
name|dwCreationFlags
init|=
operator|(
name|GetConsoleWindow
argument_list|()
condition|?
literal|0
else|:
name|CREATE_NO_WINDOW
operator|)
decl_stmt|;
name|dwCreationFlags
operator||=
name|CREATE_UNICODE_ENVIRONMENT
expr_stmt|;
name|STARTUPINFOW
name|startupInfo
init|=
block|{
sizeof|sizeof
argument_list|(
name|STARTUPINFO
argument_list|)
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|STARTF_USESTDHANDLES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
block|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
block|,
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
block|}
decl_stmt|;
name|success
operator|=
name|CreateProcess
argument_list|(
literal|0
argument_list|,
operator|(
name|wchar_t
operator|*
operator|)
name|args
operator|.
name|utf16
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|dwCreationFlags
argument_list|,
name|environment
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|envlist
operator|.
name|data
argument_list|()
argument_list|,
name|workingDirectory
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
operator|(
name|wchar_t
operator|*
operator|)
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|workingDirectory
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|,
operator|&
name|startupInfo
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Capture the error string before we do CloseHandle below
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process failed to start: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|qt_error_string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
name|CloseHandle
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
block|}
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
name|CloseHandle
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
block|}
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
name|CloseHandle
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|processError
operator|=
name|QProcess
operator|::
name|FailedToStart
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
name|q
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|NotRunning
argument_list|)
expr_stmt|;
return|return;
block|}
name|q
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|Running
argument_list|)
expr_stmt|;
comment|// User can call kill()/terminate() from the stateChanged() slot
comment|// so check before proceeding
if|if
condition|(
operator|!
name|pid
condition|)
return|return;
if|if
condition|(
name|threadData
operator|->
name|hasEventDispatcher
argument_list|()
condition|)
block|{
name|processFinishedNotifier
operator|=
operator|new
name|QWinEventNotifier
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|processFinishedNotifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|HANDLE
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_processDied
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|processFinishedNotifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|notifier
operator|=
operator|new
name|QTimer
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|notifier
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_notified
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|notifier
operator|->
name|start
argument_list|(
name|NOTIFYTIMEOUT
argument_list|)
expr_stmt|;
block|}
name|_q_startupNotification
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|processStarted
name|bool
name|QProcessPrivate
operator|::
name|processStarted
parameter_list|()
block|{
return|return
name|processState
operator|==
name|QProcess
operator|::
name|Running
return|;
block|}
end_function
begin_function
DECL|function|bytesAvailableInChannel
name|qint64
name|QProcessPrivate
operator|::
name|bytesAvailableInChannel
parameter_list|(
specifier|const
name|Channel
modifier|*
name|channel
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|channel
operator|->
name|pipe
index|[
literal|0
index|]
operator|!=
name|INVALID_Q_PIPE
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|channel
operator|->
name|reader
argument_list|)
expr_stmt|;
name|DWORD
name|bytesAvail
init|=
name|channel
operator|->
name|reader
operator|->
name|bytesAvailable
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::bytesAvailableInChannel(%d) == %d"
argument_list|,
name|channel
operator|-
operator|&
name|stdinChannel
argument_list|,
name|bytesAvail
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|bytesAvail
return|;
block|}
end_function
begin_function
DECL|function|readFromChannel
name|qint64
name|QProcessPrivate
operator|::
name|readFromChannel
parameter_list|(
specifier|const
name|Channel
modifier|*
name|channel
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|channel
operator|->
name|pipe
index|[
literal|0
index|]
operator|!=
name|INVALID_Q_PIPE
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|channel
operator|->
name|reader
argument_list|)
expr_stmt|;
return|return
name|channel
operator|->
name|reader
operator|->
name|read
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qt_terminateApp
specifier|static
name|BOOL
name|QT_WIN_CALLBACK
name|qt_terminateApp
parameter_list|(
name|HWND
name|hwnd
parameter_list|,
name|LPARAM
name|procId
parameter_list|)
block|{
name|DWORD
name|currentProcId
init|=
literal|0
decl_stmt|;
name|GetWindowThreadProcessId
argument_list|(
name|hwnd
argument_list|,
operator|&
name|currentProcId
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentProcId
operator|==
operator|(
name|DWORD
operator|)
name|procId
condition|)
name|PostMessage
argument_list|(
name|hwnd
argument_list|,
name|WM_CLOSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function
begin_function
DECL|function|terminateProcess
name|void
name|QProcessPrivate
operator|::
name|terminateProcess
parameter_list|()
block|{
if|if
condition|(
name|pid
condition|)
block|{
name|EnumWindows
argument_list|(
name|qt_terminateApp
argument_list|,
operator|(
name|LPARAM
operator|)
name|pid
operator|->
name|dwProcessId
argument_list|)
expr_stmt|;
name|PostThreadMessage
argument_list|(
name|pid
operator|->
name|dwThreadId
argument_list|,
name|WM_CLOSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|killProcess
name|void
name|QProcessPrivate
operator|::
name|killProcess
parameter_list|()
block|{
if|if
condition|(
name|pid
condition|)
name|TerminateProcess
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|,
literal|0xf291
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|waitForStarted
name|bool
name|QProcessPrivate
operator|::
name|waitForStarted
parameter_list|(
name|int
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|processStarted
argument_list|()
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|processError
operator|==
name|QProcess
operator|::
name|FailedToStart
condition|)
return|return
literal|false
return|;
name|processError
operator|=
name|QProcess
operator|::
name|Timedout
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|drainOutputPipes
name|bool
name|QProcessPrivate
operator|::
name|drainOutputPipes
parameter_list|()
block|{
if|if
condition|(
operator|!
name|stdoutChannel
operator|.
name|reader
operator|&&
operator|!
name|stderrChannel
operator|.
name|reader
condition|)
return|return
literal|false
return|;
name|bool
name|someReadyReadEmitted
init|=
literal|false
decl_stmt|;
forever|forever
block|{
name|bool
name|readyReadEmitted
init|=
literal|false
decl_stmt|;
name|bool
name|readOperationActive
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|reader
condition|)
block|{
name|readyReadEmitted
operator||=
name|stdoutChannel
operator|.
name|reader
operator|->
name|waitForReadyRead
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|readOperationActive
operator|=
name|stdoutChannel
operator|.
name|reader
operator|&&
name|stdoutChannel
operator|.
name|reader
operator|->
name|isReadOperationActive
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|stderrChannel
operator|.
name|reader
condition|)
block|{
name|readyReadEmitted
operator||=
name|stderrChannel
operator|.
name|reader
operator|->
name|waitForReadyRead
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|readOperationActive
operator||=
name|stderrChannel
operator|.
name|reader
operator|&&
name|stderrChannel
operator|.
name|reader
operator|->
name|isReadOperationActive
argument_list|()
expr_stmt|;
block|}
name|someReadyReadEmitted
operator||=
name|readyReadEmitted
expr_stmt|;
if|if
condition|(
operator|!
name|readOperationActive
operator|||
operator|!
name|readyReadEmitted
condition|)
break|break;
name|Sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
name|someReadyReadEmitted
return|;
block|}
end_function
begin_function
DECL|function|waitForReadyRead
name|bool
name|QProcessPrivate
operator|::
name|waitForReadyRead
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|QIncrementalSleepTimer
name|timer
argument_list|(
name|msecs
argument_list|)
decl_stmt|;
forever|forever
block|{
if|if
condition|(
operator|!
name|stdinChannel
operator|.
name|buffer
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|_q_canWrite
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|stdinChannel
operator|.
name|writer
operator|&&
name|stdinChannel
operator|.
name|writer
operator|->
name|waitForWrite
argument_list|(
literal|0
argument_list|)
condition|)
name|timer
operator|.
name|resetIncrements
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|stdoutChannel
operator|.
name|reader
operator|&&
name|stdoutChannel
operator|.
name|reader
operator|->
name|waitForReadyRead
argument_list|(
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|stderrChannel
operator|.
name|reader
operator|&&
name|stderrChannel
operator|.
name|reader
operator|->
name|waitForReadyRead
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|pid
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|WaitForSingleObject
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|,
literal|0
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
block|{
name|bool
name|readyReadEmitted
init|=
name|drainOutputPipes
argument_list|()
decl_stmt|;
name|_q_processDied
argument_list|()
expr_stmt|;
return|return
name|readyReadEmitted
return|;
block|}
name|Sleep
argument_list|(
name|timer
operator|.
name|nextSleepTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer
operator|.
name|hasTimedOut
argument_list|()
condition|)
break|break;
block|}
name|processError
operator|=
name|QProcess
operator|::
name|Timedout
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|waitForBytesWritten
name|bool
name|QProcessPrivate
operator|::
name|waitForBytesWritten
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|QIncrementalSleepTimer
name|timer
argument_list|(
name|msecs
argument_list|)
decl_stmt|;
forever|forever
block|{
comment|// Check if we have any data pending: the pipe writer has
comment|// bytes waiting to written, or it has written data since the
comment|// last time we called stdinChannel.writer->waitForWrite().
name|bool
name|pendingDataInPipe
init|=
name|stdinChannel
operator|.
name|writer
operator|&&
operator|(
name|stdinChannel
operator|.
name|writer
operator|->
name|bytesToWrite
argument_list|()
operator|||
name|stdinChannel
operator|.
name|writer
operator|->
name|hadWritten
argument_list|()
operator|)
decl_stmt|;
comment|// If we don't have pending data, and our write buffer is
comment|// empty, we fail.
if|if
condition|(
operator|!
name|pendingDataInPipe
operator|&&
name|stdinChannel
operator|.
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// If we don't have pending data and we do have data in our
comment|// write buffer, try to flush that data over to the pipe
comment|// writer.  Fail on error.
if|if
condition|(
operator|!
name|pendingDataInPipe
condition|)
block|{
if|if
condition|(
operator|!
name|_q_canWrite
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
comment|// Wait for the pipe writer to acknowledge that it has
comment|// written. This will succeed if either the pipe writer has
comment|// already written the data, or if it manages to write data
comment|// within the given timeout. If the write buffer was non-empty
comment|// and the stdinChannel.writer is now dead, that means _q_canWrite()
comment|// destroyed the writer after it successfully wrote the last
comment|// batch.
if|if
condition|(
operator|!
name|stdinChannel
operator|.
name|writer
operator|||
name|stdinChannel
operator|.
name|writer
operator|->
name|waitForWrite
argument_list|(
literal|0
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// If we wouldn't write anything, check if we can read stdout.
if|if
condition|(
name|bytesAvailableInChannel
argument_list|(
operator|&
name|stdoutChannel
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tryReadFromChannel
argument_list|(
operator|&
name|stdoutChannel
argument_list|)
expr_stmt|;
name|timer
operator|.
name|resetIncrements
argument_list|()
expr_stmt|;
block|}
comment|// Check if we can read stderr.
if|if
condition|(
name|bytesAvailableInChannel
argument_list|(
operator|&
name|stderrChannel
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tryReadFromChannel
argument_list|(
operator|&
name|stderrChannel
argument_list|)
expr_stmt|;
name|timer
operator|.
name|resetIncrements
argument_list|()
expr_stmt|;
block|}
comment|// Check if the process died while reading.
if|if
condition|(
operator|!
name|pid
condition|)
return|return
literal|false
return|;
comment|// Wait for the process to signal any change in its state,
comment|// such as incoming data, or if the process died.
if|if
condition|(
name|WaitForSingleObject
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|,
literal|0
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
block|{
name|_q_processDied
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Only wait for as long as we've been asked.
if|if
condition|(
name|timer
operator|.
name|hasTimedOut
argument_list|()
condition|)
break|break;
block|}
name|processError
operator|=
name|QProcess
operator|::
name|Timedout
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|waitForFinished
name|bool
name|QProcessPrivate
operator|::
name|waitForFinished
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::waitForFinished(%d)"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QIncrementalSleepTimer
name|timer
argument_list|(
name|msecs
argument_list|)
decl_stmt|;
forever|forever
block|{
if|if
condition|(
operator|!
name|stdinChannel
operator|.
name|buffer
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|_q_canWrite
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|stdinChannel
operator|.
name|writer
operator|&&
name|stdinChannel
operator|.
name|writer
operator|->
name|waitForWrite
argument_list|(
literal|0
argument_list|)
condition|)
name|timer
operator|.
name|resetIncrements
argument_list|()
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|reader
operator|&&
name|stdoutChannel
operator|.
name|reader
operator|->
name|waitForReadyRead
argument_list|(
literal|0
argument_list|)
condition|)
name|timer
operator|.
name|resetIncrements
argument_list|()
expr_stmt|;
if|if
condition|(
name|stderrChannel
operator|.
name|reader
operator|&&
name|stderrChannel
operator|.
name|reader
operator|->
name|waitForReadyRead
argument_list|(
literal|0
argument_list|)
condition|)
name|timer
operator|.
name|resetIncrements
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pid
condition|)
block|{
name|drainOutputPipes
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|WaitForSingleObject
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|,
name|timer
operator|.
name|nextSleepTime
argument_list|()
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
block|{
name|drainOutputPipes
argument_list|()
expr_stmt|;
name|_q_processDied
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|timer
operator|.
name|hasTimedOut
argument_list|()
condition|)
break|break;
block|}
name|processError
operator|=
name|QProcess
operator|::
name|Timedout
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|findExitCode
name|void
name|QProcessPrivate
operator|::
name|findExitCode
parameter_list|()
block|{
name|DWORD
name|theExitCode
decl_stmt|;
if|if
condition|(
name|GetExitCodeProcess
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|,
operator|&
name|theExitCode
argument_list|)
condition|)
block|{
name|exitCode
operator|=
name|theExitCode
expr_stmt|;
name|crashed
operator|=
operator|(
name|exitCode
operator|==
literal|0xf291
comment|// our magic number, see killProcess
operator|||
operator|(
name|theExitCode
operator|>=
literal|0x80000000
operator|&&
name|theExitCode
operator|<
literal|0xD0000000
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|flushPipeWriter
name|void
name|QProcessPrivate
operator|::
name|flushPipeWriter
parameter_list|()
block|{
if|if
condition|(
name|stdinChannel
operator|.
name|writer
operator|&&
name|stdinChannel
operator|.
name|writer
operator|->
name|bytesToWrite
argument_list|()
operator|>
literal|0
condition|)
name|stdinChannel
operator|.
name|writer
operator|->
name|waitForWrite
argument_list|(
name|ULONG_MAX
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pipeWriterBytesToWrite
name|qint64
name|QProcessPrivate
operator|::
name|pipeWriterBytesToWrite
parameter_list|()
specifier|const
block|{
return|return
name|stdinChannel
operator|.
name|writer
condition|?
name|stdinChannel
operator|.
name|writer
operator|->
name|bytesToWrite
argument_list|()
else|:
name|qint64
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|writeToStdin
name|qint64
name|QProcessPrivate
operator|::
name|writeToStdin
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stdinChannel
operator|.
name|writer
condition|)
block|{
name|stdinChannel
operator|.
name|writer
operator|=
operator|new
name|QWindowsPipeWriter
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|stdinChannel
operator|.
name|writer
operator|->
name|start
argument_list|()
expr_stmt|;
block|}
return|return
name|stdinChannel
operator|.
name|writer
operator|->
name|write
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|waitForWrite
name|bool
name|QProcessPrivate
operator|::
name|waitForWrite
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stdinChannel
operator|.
name|writer
operator|||
name|stdinChannel
operator|.
name|writer
operator|->
name|waitForWrite
argument_list|(
name|msecs
argument_list|)
condition|)
return|return
literal|true
return|;
name|processError
operator|=
name|QProcess
operator|::
name|Timedout
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|_q_notified
name|void
name|QProcessPrivate
operator|::
name|_q_notified
parameter_list|()
block|{
name|notifier
operator|->
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|stdinChannel
operator|.
name|buffer
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|!
name|stdinChannel
operator|.
name|writer
operator|||
name|stdinChannel
operator|.
name|writer
operator|->
name|waitForWrite
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
name|_q_canWrite
argument_list|()
expr_stmt|;
if|if
condition|(
name|processState
operator|!=
name|QProcess
operator|::
name|NotRunning
condition|)
name|notifier
operator|->
name|start
argument_list|(
name|NOTIFYTIMEOUT
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|startDetached
name|bool
name|QProcessPrivate
operator|::
name|startDetached
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|,
specifier|const
name|QString
modifier|&
name|workingDir
parameter_list|,
name|qint64
modifier|*
name|pid
parameter_list|)
block|{
name|QString
name|args
init|=
name|qt_create_commandline
argument_list|(
name|program
argument_list|,
name|arguments
argument_list|)
decl_stmt|;
name|bool
name|success
init|=
literal|false
decl_stmt|;
name|PROCESS_INFORMATION
name|pinfo
decl_stmt|;
name|STARTUPINFOW
name|startupInfo
init|=
block|{
sizeof|sizeof
argument_list|(
name|STARTUPINFO
argument_list|)
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
operator|(
name|ulong
operator|)
name|CW_USEDEFAULT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|success
operator|=
name|CreateProcess
argument_list|(
literal|0
argument_list|,
operator|(
name|wchar_t
operator|*
operator|)
name|args
operator|.
name|utf16
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|CREATE_UNICODE_ENVIRONMENT
operator||
name|CREATE_NEW_CONSOLE
argument_list|,
literal|0
argument_list|,
name|workingDir
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
operator|(
name|wchar_t
operator|*
operator|)
name|workingDir
operator|.
name|utf16
argument_list|()
argument_list|,
operator|&
name|startupInfo
argument_list|,
operator|&
name|pinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|CloseHandle
argument_list|(
name|pinfo
operator|.
name|hThread
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|pinfo
operator|.
name|hProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
condition|)
operator|*
name|pid
operator|=
name|pinfo
operator|.
name|dwProcessId
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PROCESS
end_comment
end_unit
