begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qfsfileengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qfsfileengine_iterator_p.h"
end_include
begin_include
include|#
directive|include
file|"qfilesystemengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qdiriterator.h"
end_include
begin_include
include|#
directive|include
file|"qset.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_FSFILEENGINE
end_ifndef
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
end_if
begin_include
include|#
directive|include
file|"private/qcore_unix_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
end_if
begin_include
include|#
directive|include
file|<private/qcore_mac_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_ifndef
ifndef|#
directive|ifndef
name|S_ISREG
end_ifndef
begin_define
DECL|macro|S_ISREG
define|#
directive|define
name|S_ISREG
parameter_list|(
name|x
parameter_list|)
value|(((x)& S_IFMT) == S_IFREG)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|S_ISCHR
end_ifndef
begin_define
DECL|macro|S_ISCHR
define|#
directive|define
name|S_ISCHR
parameter_list|(
name|x
parameter_list|)
value|(((x)& S_IFMT) == S_IFCHR)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|S_ISFIFO
end_ifndef
begin_define
DECL|macro|S_ISFIFO
define|#
directive|define
name|S_ISFIFO
parameter_list|(
name|x
parameter_list|)
value|false
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|S_ISSOCK
end_ifndef
begin_define
DECL|macro|S_ISSOCK
define|#
directive|define
name|S_ISSOCK
parameter_list|(
name|x
parameter_list|)
value|false
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|INVALID_FILE_ATTRIBUTES
end_ifndef
begin_define
DECL|macro|INVALID_FILE_ATTRIBUTES
define|#
directive|define
name|INVALID_FILE_ATTRIBUTES
value|(DWORD (-1))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*! \class QFSFileEngine     \inmodule QtCore     \brief The QFSFileEngine class implements Qt's default file engine.     \since 4.1     \internal      This class is part of the file engine framework in Qt. If you only want to     access files or directories, use QFile, QFileInfo or QDir instead.      QFSFileEngine is the default file engine for accessing regular files. It     is provided for convenience; by subclassing this class, you can alter its     behavior slightly, without having to write a complete QAbstractFileEngine     subclass. To install your custom file engine, you must also subclass     QAbstractFileEngineHandler and create an instance of your handler.      It can also be useful to create a QFSFileEngine object directly if you     need to use the local file system inside QAbstractFileEngine::create(), in     order to avoid recursion (as higher-level classes tend to call     QAbstractFileEngine::create()). */
end_comment
begin_comment
comment|//**************** QFSFileEnginePrivate
end_comment
begin_constructor
DECL|function|QFSFileEnginePrivate
name|QFSFileEnginePrivate
operator|::
name|QFSFileEnginePrivate
parameter_list|()
member_init_list|:
name|QAbstractFileEnginePrivate
argument_list|()
block|{
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|init
name|void
name|QFSFileEnginePrivate
operator|::
name|init
parameter_list|()
block|{
name|is_sequential
operator|=
literal|0
expr_stmt|;
name|tried_stat
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|need_lstat
operator|=
literal|1
expr_stmt|;
name|is_link
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|openMode
operator|=
name|QIODevice
operator|::
name|NotOpen
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|fh
operator|=
literal|0
expr_stmt|;
name|lastIOCommand
operator|=
name|IOFlushCommand
expr_stmt|;
name|lastFlushFailed
operator|=
literal|false
expr_stmt|;
name|closeFileHandle
operator|=
literal|false
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|fileAttrib
operator|=
name|INVALID_FILE_ATTRIBUTES
expr_stmt|;
name|fileHandle
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|mapHandle
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_WINCE
name|cachedFd
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Constructs a QFSFileEngine for the file name \a file. */
end_comment
begin_constructor
DECL|function|QFSFileEngine
name|QFSFileEngine
operator|::
name|QFSFileEngine
parameter_list|(
specifier|const
name|QString
modifier|&
name|file
parameter_list|)
member_init_list|:
name|QAbstractFileEngine
argument_list|(
operator|*
operator|new
name|QFSFileEnginePrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileEntry
operator|=
name|QFileSystemEntry
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QFSFileEngine. */
end_comment
begin_constructor
DECL|function|QFSFileEngine
name|QFSFileEngine
operator|::
name|QFSFileEngine
parameter_list|()
member_init_list|:
name|QAbstractFileEngine
argument_list|(
operator|*
operator|new
name|QFSFileEnginePrivate
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QFSFileEngine
name|QFSFileEngine
operator|::
name|QFSFileEngine
parameter_list|(
name|QFSFileEnginePrivate
modifier|&
name|dd
parameter_list|)
member_init_list|:
name|QAbstractFileEngine
argument_list|(
name|dd
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destructs the QFSFileEngine. */
end_comment
begin_destructor
DECL|function|~QFSFileEngine
name|QFSFileEngine
operator|::
name|~
name|QFSFileEngine
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|closeFileHandle
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|fh
condition|)
block|{
name|int
name|ret
decl_stmt|;
do|do
block|{
name|ret
operator|=
name|fclose
argument_list|(
name|d
operator|->
name|fh
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|EOF
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|ret
decl_stmt|;
do|do
block|{
name|ret
operator|=
name|QT_CLOSE
argument_list|(
name|d
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
block|}
block|}
name|QList
argument_list|<
name|uchar
modifier|*
argument_list|>
name|keys
init|=
name|d
operator|->
name|maps
operator|.
name|keys
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|unmap
argument_list|(
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|setFileName
name|void
name|QFSFileEngine
operator|::
name|setFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|file
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
name|d
operator|->
name|fileEntry
operator|=
name|QFileSystemEntry
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|open
name|bool
name|QFSFileEngine
operator|::
name|open
parameter_list|(
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEntry
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFSFileEngine::open: No file name specified"
argument_list|)
expr_stmt|;
name|setError
argument_list|(
name|QFile
operator|::
name|OpenError
argument_list|,
name|QLatin1String
argument_list|(
literal|"No file name specified"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Append implies WriteOnly.
if|if
condition|(
name|openMode
operator|&
name|QFile
operator|::
name|Append
condition|)
name|openMode
operator||=
name|QFile
operator|::
name|WriteOnly
expr_stmt|;
comment|// WriteOnly implies Truncate if neither ReadOnly nor Append are sent.
if|if
condition|(
operator|(
name|openMode
operator|&
name|QFile
operator|::
name|WriteOnly
operator|)
operator|&&
operator|!
operator|(
name|openMode
operator|&
operator|(
name|QFile
operator|::
name|ReadOnly
operator||
name|QFile
operator|::
name|Append
operator|)
operator|)
condition|)
name|openMode
operator||=
name|QFile
operator|::
name|Truncate
expr_stmt|;
name|d
operator|->
name|openMode
operator|=
name|openMode
expr_stmt|;
name|d
operator|->
name|lastFlushFailed
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|tried_stat
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|fh
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|d
operator|->
name|nativeOpen
argument_list|(
name|openMode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Opens the file handle \a fh in \a openMode mode. Returns true on     success; otherwise returns false. */
end_comment
begin_function
DECL|function|open
name|bool
name|QFSFileEngine
operator|::
name|open
parameter_list|(
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|,
name|FILE
modifier|*
name|fh
parameter_list|)
block|{
return|return
name|open
argument_list|(
name|openMode
argument_list|,
name|fh
argument_list|,
name|QFile
operator|::
name|DontCloseHandle
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|open
name|bool
name|QFSFileEngine
operator|::
name|open
parameter_list|(
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|,
name|FILE
modifier|*
name|fh
parameter_list|,
name|QFile
operator|::
name|FileHandleFlags
name|handleFlags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
comment|// Append implies WriteOnly.
if|if
condition|(
name|openMode
operator|&
name|QFile
operator|::
name|Append
condition|)
name|openMode
operator||=
name|QFile
operator|::
name|WriteOnly
expr_stmt|;
comment|// WriteOnly implies Truncate if neither ReadOnly nor Append are sent.
if|if
condition|(
operator|(
name|openMode
operator|&
name|QFile
operator|::
name|WriteOnly
operator|)
operator|&&
operator|!
operator|(
name|openMode
operator|&
operator|(
name|QFile
operator|::
name|ReadOnly
operator||
name|QFile
operator|::
name|Append
operator|)
operator|)
condition|)
name|openMode
operator||=
name|QFile
operator|::
name|Truncate
expr_stmt|;
name|d
operator|->
name|openMode
operator|=
name|openMode
expr_stmt|;
name|d
operator|->
name|lastFlushFailed
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|closeFileHandle
operator|=
operator|(
name|handleFlags
operator|&
name|QFile
operator|::
name|AutoCloseHandle
operator|)
expr_stmt|;
name|d
operator|->
name|fileEntry
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|tried_stat
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|d
operator|->
name|openFh
argument_list|(
name|openMode
argument_list|,
name|fh
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Opens the file handle \a fh using the open mode \a flags. */
end_comment
begin_function
DECL|function|openFh
name|bool
name|QFSFileEnginePrivate
operator|::
name|openFh
parameter_list|(
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|,
name|FILE
modifier|*
name|fh
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
name|this
operator|->
name|fh
operator|=
name|fh
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|// Seek to the end when in Append mode.
if|if
condition|(
name|openMode
operator|&
name|QIODevice
operator|::
name|Append
condition|)
block|{
name|int
name|ret
decl_stmt|;
do|do
block|{
name|ret
operator|=
name|QT_FSEEK
argument_list|(
name|fh
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|errno
operator|==
name|EMFILE
condition|?
name|QFile
operator|::
name|ResourceError
else|:
name|QFile
operator|::
name|OpenError
argument_list|,
name|qt_error_string
argument_list|(
name|int
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|->
name|openMode
operator|=
name|QIODevice
operator|::
name|NotOpen
expr_stmt|;
name|this
operator|->
name|fh
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Opens the file descriptor \a fd in \a openMode mode. Returns true     on success; otherwise returns false. */
end_comment
begin_function
DECL|function|open
name|bool
name|QFSFileEngine
operator|::
name|open
parameter_list|(
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
return|return
name|open
argument_list|(
name|openMode
argument_list|,
name|fd
argument_list|,
name|QFile
operator|::
name|DontCloseHandle
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|open
name|bool
name|QFSFileEngine
operator|::
name|open
parameter_list|(
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|,
name|int
name|fd
parameter_list|,
name|QFile
operator|::
name|FileHandleFlags
name|handleFlags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
comment|// Append implies WriteOnly.
if|if
condition|(
name|openMode
operator|&
name|QFile
operator|::
name|Append
condition|)
name|openMode
operator||=
name|QFile
operator|::
name|WriteOnly
expr_stmt|;
comment|// WriteOnly implies Truncate if neither ReadOnly nor Append are sent.
if|if
condition|(
operator|(
name|openMode
operator|&
name|QFile
operator|::
name|WriteOnly
operator|)
operator|&&
operator|!
operator|(
name|openMode
operator|&
operator|(
name|QFile
operator|::
name|ReadOnly
operator||
name|QFile
operator|::
name|Append
operator|)
operator|)
condition|)
name|openMode
operator||=
name|QFile
operator|::
name|Truncate
expr_stmt|;
name|d
operator|->
name|openMode
operator|=
name|openMode
expr_stmt|;
name|d
operator|->
name|lastFlushFailed
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|closeFileHandle
operator|=
operator|(
name|handleFlags
operator|&
name|QFile
operator|::
name|AutoCloseHandle
operator|)
expr_stmt|;
name|d
operator|->
name|fileEntry
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|fh
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|tried_stat
operator|=
literal|0
expr_stmt|;
return|return
name|d
operator|->
name|openFd
argument_list|(
name|openMode
argument_list|,
name|fd
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Opens the file descriptor \a fd to the file engine, using the open mode \a     flags. */
end_comment
begin_function
DECL|function|openFd
name|bool
name|QFSFileEnginePrivate
operator|::
name|openFd
parameter_list|(
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
name|this
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|fh
operator|=
literal|0
expr_stmt|;
comment|// Seek to the end when in Append mode.
if|if
condition|(
name|openMode
operator|&
name|QFile
operator|::
name|Append
condition|)
block|{
name|int
name|ret
decl_stmt|;
do|do
block|{
name|ret
operator|=
name|QT_LSEEK
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|errno
operator|==
name|EMFILE
condition|?
name|QFile
operator|::
name|ResourceError
else|:
name|QFile
operator|::
name|OpenError
argument_list|,
name|qt_error_string
argument_list|(
name|int
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|->
name|openMode
operator|=
name|QIODevice
operator|::
name|NotOpen
expr_stmt|;
name|this
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|close
name|bool
name|QFSFileEngine
operator|::
name|close
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|openMode
operator|=
name|QIODevice
operator|::
name|NotOpen
expr_stmt|;
return|return
name|d
operator|->
name|nativeClose
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|closeFdFh
name|bool
name|QFSFileEnginePrivate
operator|::
name|closeFdFh
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
operator|&&
operator|!
name|fh
condition|)
return|return
literal|false
return|;
comment|// Flush the file if it's buffered, and if the last flush didn't fail.
name|bool
name|flushed
init|=
operator|!
name|fh
operator|||
operator|(
operator|!
name|lastFlushFailed
operator|&&
name|q
operator|->
name|flush
argument_list|()
operator|)
decl_stmt|;
name|bool
name|closed
init|=
literal|true
decl_stmt|;
name|tried_stat
operator|=
literal|0
expr_stmt|;
comment|// Close the file if we created the handle.
if|if
condition|(
name|closeFileHandle
condition|)
block|{
name|int
name|ret
decl_stmt|;
do|do
block|{
if|if
condition|(
name|fh
condition|)
block|{
comment|// Close buffered file.
name|ret
operator|=
name|fclose
argument_list|(
name|fh
argument_list|)
operator|!=
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Close unbuffered file.
name|ret
operator|=
name|QT_CLOSE
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
comment|// We must reset these guys regardless; calling close again after a
comment|// failed close causes crashes on some systems.
name|fh
operator|=
literal|0
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|closed
operator|=
operator|(
name|ret
operator|==
literal|0
operator|)
expr_stmt|;
block|}
comment|// Report errors.
if|if
condition|(
operator|!
name|flushed
operator|||
operator|!
name|closed
condition|)
block|{
if|if
condition|(
name|flushed
condition|)
block|{
comment|// If not flushed, we want the flush error to fall through.
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|UnspecifiedError
argument_list|,
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|flush
name|bool
name|QFSFileEngine
operator|::
name|flush
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|openMode
operator|&
name|QIODevice
operator|::
name|WriteOnly
operator|)
operator|==
literal|0
condition|)
block|{
comment|// Nothing in the write buffers, so flush succeeds in doing
comment|// nothing.
return|return
literal|true
return|;
block|}
return|return
name|d
operator|->
name|nativeFlush
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|flushFh
name|bool
name|QFSFileEnginePrivate
operator|::
name|flushFh
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
comment|// Never try to flush again if the last flush failed. Otherwise you can
comment|// get crashes on some systems (AIX).
if|if
condition|(
name|lastFlushFailed
condition|)
return|return
literal|false
return|;
name|int
name|ret
init|=
name|fflush
argument_list|(
name|fh
argument_list|)
decl_stmt|;
name|lastFlushFailed
operator|=
operator|(
name|ret
operator|!=
literal|0
operator|)
expr_stmt|;
name|lastIOCommand
operator|=
name|QFSFileEnginePrivate
operator|::
name|IOFlushCommand
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|errno
operator|==
name|ENOSPC
condition|?
name|QFile
operator|::
name|ResourceError
else|:
name|QFile
operator|::
name|WriteError
argument_list|,
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|size
name|qint64
name|QFSFileEngine
operator|::
name|size
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFSFileEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeSize
argument_list|()
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_WIN
end_ifndef
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|sizeFdFh
name|qint64
name|QFSFileEnginePrivate
operator|::
name|sizeFdFh
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QFSFileEngine
argument_list|)
expr_stmt|;
cast|const_cast
argument_list|<
name|QFSFileEngine
operator|*
argument_list|>
argument_list|(
name|q
argument_list|)
operator|->
name|flush
argument_list|()
expr_stmt|;
name|tried_stat
operator|=
literal|0
expr_stmt|;
name|metaData
operator|.
name|clearFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|SizeAttribute
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|doStat
argument_list|(
name|QFileSystemMetaData
operator|::
name|SizeAttribute
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|metaData
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|pos
name|qint64
name|QFSFileEngine
operator|::
name|pos
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFSFileEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativePos
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|posFdFh
name|qint64
name|QFSFileEnginePrivate
operator|::
name|posFdFh
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|fh
condition|)
return|return
name|qint64
argument_list|(
name|QT_FTELL
argument_list|(
name|fh
argument_list|)
argument_list|)
return|;
return|return
name|QT_LSEEK
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|seek
name|bool
name|QFSFileEngine
operator|::
name|seek
parameter_list|(
name|qint64
name|pos
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeSeek
argument_list|(
name|pos
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|seekFdFh
name|bool
name|QFSFileEnginePrivate
operator|::
name|seekFdFh
parameter_list|(
name|qint64
name|pos
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
comment|// On Windows' stdlib implementation, the results of calling fread and
comment|// fwrite are undefined if not called either in sequence, or if preceded
comment|// with a call to fflush().
if|if
condition|(
name|lastIOCommand
operator|!=
name|QFSFileEnginePrivate
operator|::
name|IOFlushCommand
operator|&&
operator|!
name|q
operator|->
name|flush
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|!=
name|qint64
argument_list|(
name|QT_OFF_T
argument_list|(
name|pos
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|fh
condition|)
block|{
comment|// Buffered stdlib mode.
name|int
name|ret
decl_stmt|;
do|do
block|{
name|ret
operator|=
name|QT_FSEEK
argument_list|(
name|fh
argument_list|,
name|QT_OFF_T
argument_list|(
name|pos
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|ReadError
argument_list|,
name|qt_error_string
argument_list|(
name|int
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
comment|// Unbuffered stdio mode.
if|if
condition|(
name|QT_LSEEK
argument_list|(
name|fd
argument_list|,
name|QT_OFF_T
argument_list|(
name|pos
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QFile::at: Cannot set file position"
operator|<<
name|pos
expr_stmt|;
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|PositionError
argument_list|,
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|handle
name|int
name|QFSFileEngine
operator|::
name|handle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFSFileEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeHandle
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|read
name|qint64
name|QFSFileEngine
operator|::
name|read
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
comment|// On Windows' stdlib implementation, the results of calling fread and
comment|// fwrite are undefined if not called either in sequence, or if preceded
comment|// with a call to fflush().
if|if
condition|(
name|d
operator|->
name|lastIOCommand
operator|!=
name|QFSFileEnginePrivate
operator|::
name|IOReadCommand
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
name|d
operator|->
name|lastIOCommand
operator|=
name|QFSFileEnginePrivate
operator|::
name|IOReadCommand
expr_stmt|;
block|}
return|return
name|d
operator|->
name|nativeRead
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|readFdFh
name|qint64
name|QFSFileEnginePrivate
operator|::
name|readFdFh
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|!=
name|qint64
argument_list|(
name|size_t
argument_list|(
name|len
argument_list|)
argument_list|)
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|ReadError
argument_list|,
name|qt_error_string
argument_list|(
name|EINVAL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|qint64
name|readBytes
init|=
literal|0
decl_stmt|;
name|bool
name|eof
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|fh
condition|)
block|{
comment|// Buffered stdlib mode.
name|size_t
name|result
decl_stmt|;
name|bool
name|retry
init|=
literal|true
decl_stmt|;
do|do
block|{
name|result
operator|=
name|fread
argument_list|(
name|data
operator|+
name|readBytes
argument_list|,
literal|1
argument_list|,
name|size_t
argument_list|(
name|len
operator|-
name|readBytes
argument_list|)
argument_list|,
name|fh
argument_list|)
expr_stmt|;
name|eof
operator|=
name|feof
argument_list|(
name|fh
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
operator|&&
name|eof
operator|&&
name|result
operator|==
literal|0
condition|)
block|{
comment|// On Mac OS, this is needed, e.g., if a file was written to
comment|// through another stream since our last read. See test
comment|// tst_QFile::appendAndRead
name|QT_FSEEK
argument_list|(
name|fh
argument_list|,
name|QT_FTELL
argument_list|(
name|fh
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|// re-sync stream.
name|retry
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
name|readBytes
operator|+=
name|result
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|eof
operator|&&
operator|(
name|result
operator|==
literal|0
condition|?
name|errno
operator|==
name|EINTR
else|:
name|readBytes
operator|<
name|len
operator|)
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Unbuffered stdio mode.
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|int
name|result
decl_stmt|;
else|#
directive|else
name|ssize_t
name|result
decl_stmt|;
endif|#
directive|endif
do|do
block|{
name|result
operator|=
name|QT_READ
argument_list|(
name|fd
argument_list|,
name|data
operator|+
name|readBytes
argument_list|,
name|size_t
argument_list|(
name|len
operator|-
name|readBytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|result
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
operator|)
operator|||
operator|(
name|result
operator|>
literal|0
operator|&&
operator|(
name|readBytes
operator|+=
name|result
operator|)
operator|<
name|len
operator|)
condition|)
do|;
name|eof
operator|=
operator|!
operator|(
name|result
operator|==
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|eof
operator|&&
name|readBytes
operator|==
literal|0
condition|)
block|{
name|readBytes
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|ReadError
argument_list|,
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|readBytes
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|readLine
name|qint64
name|QFSFileEngine
operator|::
name|readLine
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
comment|// On Windows' stdlib implementation, the results of calling fread and
comment|// fwrite are undefined if not called either in sequence, or if preceded
comment|// with a call to fflush().
if|if
condition|(
name|d
operator|->
name|lastIOCommand
operator|!=
name|QFSFileEnginePrivate
operator|::
name|IOReadCommand
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
name|d
operator|->
name|lastIOCommand
operator|=
name|QFSFileEnginePrivate
operator|::
name|IOReadCommand
expr_stmt|;
block|}
return|return
name|d
operator|->
name|nativeReadLine
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|readLineFdFh
name|qint64
name|QFSFileEnginePrivate
operator|::
name|readLineFdFh
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fh
condition|)
return|return
name|q
operator|->
name|QAbstractFileEngine
operator|::
name|readLine
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
return|;
name|QT_OFF_T
name|oldPos
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|bool
name|seq
init|=
name|q
operator|->
name|isSequential
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|seq
condition|)
endif|#
directive|endif
name|oldPos
operator|=
name|QT_FTELL
argument_list|(
name|fh
argument_list|)
expr_stmt|;
comment|// QIODevice::readLine() passes maxlen - 1 to QFile::readLineData()
comment|// because it has made space for the '\0' at the end of data.  But fgets
comment|// does the same, so we'd get two '\0' at the end - passing maxlen + 1
comment|// solves this.
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|data
argument_list|,
name|int
argument_list|(
name|maxlen
operator|+
literal|1
argument_list|)
argument_list|,
name|fh
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|feof
argument_list|(
name|fh
argument_list|)
condition|)
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|ReadError
argument_list|,
name|qt_error_string
argument_list|(
name|int
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|// error
block|}
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
name|seq
condition|)
return|return
name|qstrlen
argument_list|(
name|data
argument_list|)
return|;
endif|#
directive|endif
name|qint64
name|lineLength
init|=
name|QT_FTELL
argument_list|(
name|fh
argument_list|)
operator|-
name|oldPos
decl_stmt|;
return|return
name|lineLength
operator|>
literal|0
condition|?
name|lineLength
else|:
name|qstrlen
argument_list|(
name|data
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|write
name|qint64
name|QFSFileEngine
operator|::
name|write
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
comment|// On Windows' stdlib implementation, the results of calling fread and
comment|// fwrite are undefined if not called either in sequence, or if preceded
comment|// with a call to fflush().
if|if
condition|(
name|d
operator|->
name|lastIOCommand
operator|!=
name|QFSFileEnginePrivate
operator|::
name|IOWriteCommand
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
name|d
operator|->
name|lastIOCommand
operator|=
name|QFSFileEnginePrivate
operator|::
name|IOWriteCommand
expr_stmt|;
block|}
return|return
name|d
operator|->
name|nativeWrite
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|writeFdFh
name|qint64
name|QFSFileEnginePrivate
operator|::
name|writeFdFh
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|!=
name|qint64
argument_list|(
name|size_t
argument_list|(
name|len
argument_list|)
argument_list|)
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|WriteError
argument_list|,
name|qt_error_string
argument_list|(
name|EINVAL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|qint64
name|writtenBytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fh
condition|)
block|{
comment|// Buffered stdlib mode.
name|size_t
name|result
decl_stmt|;
do|do
block|{
name|result
operator|=
name|fwrite
argument_list|(
name|data
operator|+
name|writtenBytes
argument_list|,
literal|1
argument_list|,
name|size_t
argument_list|(
name|len
operator|-
name|writtenBytes
argument_list|)
argument_list|,
name|fh
argument_list|)
expr_stmt|;
name|writtenBytes
operator|+=
name|result
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|==
literal|0
condition|?
name|errno
operator|==
name|EINTR
else|:
name|writtenBytes
operator|<
name|len
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Unbuffered stdio mode.
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|int
name|result
decl_stmt|;
else|#
directive|else
name|ssize_t
name|result
decl_stmt|;
endif|#
directive|endif
do|do
block|{
name|result
operator|=
name|QT_WRITE
argument_list|(
name|fd
argument_list|,
name|data
operator|+
name|writtenBytes
argument_list|,
name|size_t
argument_list|(
name|len
operator|-
name|writtenBytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|result
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
operator|)
operator|||
operator|(
name|result
operator|>
literal|0
operator|&&
operator|(
name|writtenBytes
operator|+=
name|result
operator|)
operator|<
name|len
operator|)
condition|)
do|;
block|}
if|if
condition|(
name|len
operator|&&
name|writtenBytes
operator|==
literal|0
condition|)
block|{
name|writtenBytes
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|setError
argument_list|(
name|errno
operator|==
name|ENOSPC
condition|?
name|QFile
operator|::
name|ResourceError
else|:
name|QFile
operator|::
name|WriteError
argument_list|,
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|writtenBytes
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_FILESYSTEMITERATOR
end_ifndef
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|beginEntryList
name|QAbstractFileEngine
operator|::
name|Iterator
modifier|*
name|QFSFileEngine
operator|::
name|beginEntryList
parameter_list|(
name|QDir
operator|::
name|Filters
name|filters
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|filterNames
parameter_list|)
block|{
return|return
operator|new
name|QFSFileEngineIterator
argument_list|(
name|filters
argument_list|,
name|filterNames
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|endEntryList
name|QAbstractFileEngine
operator|::
name|Iterator
modifier|*
name|QFSFileEngine
operator|::
name|endEntryList
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_FILESYSTEMITERATOR
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|entryList
name|QStringList
name|QFSFileEngine
operator|::
name|entryList
parameter_list|(
name|QDir
operator|::
name|Filters
name|filters
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|filterNames
parameter_list|)
specifier|const
block|{
return|return
name|QAbstractFileEngine
operator|::
name|entryList
argument_list|(
name|filters
argument_list|,
name|filterNames
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|isSequential
name|bool
name|QFSFileEngine
operator|::
name|isSequential
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|is_sequential
operator|==
literal|0
condition|)
name|d
operator|->
name|is_sequential
operator|=
name|d
operator|->
name|nativeIsSequential
argument_list|()
condition|?
literal|1
else|:
literal|2
expr_stmt|;
return|return
name|d
operator|->
name|is_sequential
operator|==
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_function
DECL|function|isSequentialFdFh
name|bool
name|QFSFileEnginePrivate
operator|::
name|isSequentialFdFh
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|doStat
argument_list|(
name|QFileSystemMetaData
operator|::
name|SequentialType
argument_list|)
condition|)
return|return
name|metaData
operator|.
name|isSequential
argument_list|()
return|;
return|return
literal|true
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|extension
name|bool
name|QFSFileEngine
operator|::
name|extension
parameter_list|(
name|Extension
name|extension
parameter_list|,
specifier|const
name|ExtensionOption
modifier|*
name|option
parameter_list|,
name|ExtensionReturn
modifier|*
name|output
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|extension
operator|==
name|AtEndExtension
operator|&&
name|d
operator|->
name|fh
operator|&&
name|isSequential
argument_list|()
condition|)
return|return
name|feof
argument_list|(
name|d
operator|->
name|fh
argument_list|)
return|;
if|if
condition|(
name|extension
operator|==
name|MapExtension
condition|)
block|{
specifier|const
name|MapExtensionOption
modifier|*
name|options
init|=
operator|(
name|MapExtensionOption
operator|*
operator|)
operator|(
name|option
operator|)
decl_stmt|;
name|MapExtensionReturn
modifier|*
name|returnValue
init|=
cast|static_cast
argument_list|<
name|MapExtensionReturn
operator|*
argument_list|>
argument_list|(
name|output
argument_list|)
decl_stmt|;
name|returnValue
operator|->
name|address
operator|=
name|d
operator|->
name|map
argument_list|(
name|options
operator|->
name|offset
argument_list|,
name|options
operator|->
name|size
argument_list|,
name|options
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|returnValue
operator|->
name|address
operator|!=
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|extension
operator|==
name|UnMapExtension
condition|)
block|{
name|UnMapExtensionOption
modifier|*
name|options
init|=
operator|(
name|UnMapExtensionOption
operator|*
operator|)
name|option
decl_stmt|;
return|return
name|d
operator|->
name|unmap
argument_list|(
name|options
operator|->
name|address
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|supportsExtension
name|bool
name|QFSFileEngine
operator|::
name|supportsExtension
parameter_list|(
name|Extension
name|extension
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|extension
operator|==
name|AtEndExtension
operator|&&
name|d
operator|->
name|fh
operator|&&
name|isSequential
argument_list|()
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|extension
operator|==
name|FastReadLineExtension
operator|&&
name|d
operator|->
name|fh
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|extension
operator|==
name|FastReadLineExtension
operator|&&
name|d
operator|->
name|fd
operator|!=
operator|-
literal|1
operator|&&
name|isSequential
argument_list|()
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|extension
operator|==
name|UnMapExtension
operator|||
name|extension
operator|==
name|MapExtension
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QFSFileEngine::caseSensitive() const   Returns true for Windows, false for Unix. */
end_comment
begin_comment
comment|/*! \fn bool QFSFileEngine::copy(const QString&copyName)    For windows, copy the file to file \a copyName.    Not implemented for Unix. */
end_comment
begin_comment
comment|/*! \fn QString QFSFileEngine::currentPath(const QString&fileName)   For Unix, returns the current working directory for the file   engine.    For Windows, returns the canonicalized form of the current path used   by the file engine for the drive specified by \a fileName.  On   Windows, each drive has its own current directory, so a different   path is returned for file names that include different drive names   (e.g. A: or C:).    \sa setCurrentPath() */
end_comment
begin_comment
comment|/*! \fn QFileInfoList QFSFileEngine::drives()   For Windows, returns the list of drives in the file system as a list   of QFileInfo objects. On unix, Mac OS X and Windows CE, only the   root path is returned.  On Windows, this function returns all drives   (A:\, C:\, D:\, etc.).    For Unix, the list contains just the root path "/". */
end_comment
begin_comment
comment|/*! \fn QString QFSFileEngine::fileName(FileName file) const   \reimp */
end_comment
begin_comment
comment|/*! \fn QDateTime QFSFileEngine::fileTime(FileTime time) const   \reimp */
end_comment
begin_comment
comment|/*! \fn QString QFSFileEngine::homePath()   Returns the home path of the current user.    \sa rootPath() */
end_comment
begin_comment
comment|/*! \fn bool QFSFileEngine::isRelativePath() const   \reimp */
end_comment
begin_comment
comment|/*! \fn bool QFSFileEngine::link(const QString&newName)    Creates a link from the file currently specified by fileName() to   \a newName. What a link is depends on the underlying filesystem   (be it a shortcut on Windows or a symbolic link on Unix). Returns   true if successful; otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool QFSFileEngine::mkdir(const QString&name, bool createParentDirectories) const   \reimp */
end_comment
begin_comment
comment|/*! \fn uint QFSFileEngine::ownerId(FileOwner own) const   In Unix, if stat() is successful, the \c uid is returned if   \a own is the owner. Otherwise the \c gid is returned. If stat()   is unsuccessful, -2 is reuturned.    For Windows, -2 is always returned. */
end_comment
begin_comment
comment|/*! \fn QString QFSFileEngine::owner(FileOwner own) const   \reimp */
end_comment
begin_comment
comment|/*! \fn bool QFSFileEngine::remove()   \reimp */
end_comment
begin_comment
comment|/*! \fn bool QFSFileEngine::rename(const QString&newName)   \reimp */
end_comment
begin_comment
comment|/*! \fn bool QFSFileEngine::renameOverwrite(const QString&newName)   \reimp */
end_comment
begin_comment
comment|/*! \fn bool QFSFileEngine::rmdir(const QString&name, bool recurseParentDirectories) const   \reimp */
end_comment
begin_comment
comment|/*! \fn QString QFSFileEngine::rootPath()   Returns the root path.    \sa homePath() */
end_comment
begin_comment
comment|/*! \fn bool QFSFileEngine::setCurrentPath(const QString&path)   Sets the current path (e.g., for QDir), to \a path. Returns true if the   new path exists; otherwise this function does nothing, and returns false.    \sa currentPath() */
end_comment
begin_comment
comment|/*! \fn bool QFSFileEngine::setPermissions(uint perms)   \reimp */
end_comment
begin_comment
comment|/*! \fn bool QFSFileEngine::setSize(qint64 size)   \reimp */
end_comment
begin_comment
comment|/*! \fn QString QFSFileEngine::tempPath()   Returns the temporary path (i.e., a path in which it is safe   to store temporary files). */
end_comment
begin_comment
comment|/*! \fn QAbstractFileEngine::FileFlags QFSFileEnginePrivate::getPermissions(QAbstractFileEngine::FileFlags type) const     \internal */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_FSFILEENGINE
end_comment
end_unit
