begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"private/qabstractfileengine_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qfsfileengine_p.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QT_BUILD_CORE_LIB
end_ifdef
begin_include
include|#
directive|include
file|"private/qresource_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qreadwritelock.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_comment
comment|// built-in handlers
end_comment
begin_include
include|#
directive|include
file|"qdiriterator.h"
end_include
begin_include
include|#
directive|include
file|"qstringbuilder.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/private/qfilesystementry_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/private/qfilesystemmetadata_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/private/qfilesystemengine_p.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QAbstractFileEngineHandler     \inmodule QtCore     \reentrant     \internal      \brief The QAbstractFileEngineHandler class provides a way to register     custom file engines with your application.      \ingroup io     \since 4.1      QAbstractFileEngineHandler is a factory for creating QAbstractFileEngine     objects (file engines), which are used internally by QFile, QFileInfo, and     QDir when working with files and directories.      When you open a file, Qt chooses a suitable file engine by passing the     file name from QFile or QDir through an internal list of registered file     engine handlers. The first handler to recognize the file name is used to     create the engine. Qt provides internal file engines for working with     regular files and resources, but you can also register your own     QAbstractFileEngine subclasses.      To install an application-specific file engine, you subclass     QAbstractFileEngineHandler and reimplement create(). When you instantiate     the handler (e.g. by creating an instance on the stack or on the heap), it     will automatically register with Qt. (The latest registered handler takes     precedence over existing handlers.)      For example:      \snippet code/src_corelib_io_qabstractfileengine.cpp 0      When the handler is destroyed, it is automatically removed from Qt.      The most common approach to registering a handler is to create an instance     as part of the start-up phase of your application. It is also possible to     limit the scope of the file engine handler to a particular area of     interest (e.g. a special file dialog that needs a custom file engine). By     creating the handler inside a local scope, you can precisely control the     area in which your engine will be applied without disturbing file     operations in other parts of your application.      \sa QAbstractFileEngine, QAbstractFileEngine::create() */
DECL|variable|qt_file_engine_handlers_in_use
specifier|static
name|bool
name|qt_file_engine_handlers_in_use
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*     All application-wide handlers are stored in this list. The mutex must be     acquired to ensure thread safety.  */
end_comment
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|QReadWriteLock
argument_list|,
argument|fileEngineHandlerMutex
argument_list|,
argument|(QReadWriteLock::Recursive)
argument_list|)
end_macro
begin_decl_stmt
DECL|variable|qt_abstractfileenginehandlerlist_shutDown
specifier|static
name|bool
name|qt_abstractfileenginehandlerlist_shutDown
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_class
DECL|class|QAbstractFileEngineHandlerList
class|class
name|QAbstractFileEngineHandlerList
super|:
specifier|public
name|QList
argument_list|<
name|QAbstractFileEngineHandler
modifier|*
argument_list|>
block|{
public|public:
DECL|function|~QAbstractFileEngineHandlerList
name|~
name|QAbstractFileEngineHandlerList
parameter_list|()
block|{
name|QWriteLocker
name|locker
argument_list|(
name|fileEngineHandlerMutex
argument_list|()
argument_list|)
decl_stmt|;
name|qt_abstractfileenginehandlerlist_shutDown
operator|=
literal|true
expr_stmt|;
block|}
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QAbstractFileEngineHandlerList
argument_list|,
argument|fileEngineHandlers
argument_list|)
end_macro
begin_comment
comment|/*!     Constructs a file handler and registers it with Qt. Once created this     handler's create() function will be called (along with all the other     handlers) for any paths used. The most recently created handler that     recognizes the given path (i.e. that returns a QAbstractFileEngine) is     used for the new path.      \sa create()  */
end_comment
begin_constructor
DECL|function|QAbstractFileEngineHandler
name|QAbstractFileEngineHandler
operator|::
name|QAbstractFileEngineHandler
parameter_list|()
block|{
name|QWriteLocker
name|locker
argument_list|(
name|fileEngineHandlerMutex
argument_list|()
argument_list|)
decl_stmt|;
name|qt_file_engine_handlers_in_use
operator|=
literal|true
expr_stmt|;
name|fileEngineHandlers
argument_list|()
operator|->
name|prepend
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the file handler. This will automatically unregister the handler     from Qt.  */
end_comment
begin_destructor
DECL|function|~QAbstractFileEngineHandler
name|QAbstractFileEngineHandler
operator|::
name|~
name|QAbstractFileEngineHandler
parameter_list|()
block|{
name|QWriteLocker
name|locker
argument_list|(
name|fileEngineHandlerMutex
argument_list|()
argument_list|)
decl_stmt|;
comment|// Remove this handler from the handler list only if the list is valid.
if|if
condition|(
operator|!
name|qt_abstractfileenginehandlerlist_shutDown
condition|)
block|{
name|QAbstractFileEngineHandlerList
modifier|*
name|handlers
init|=
name|fileEngineHandlers
argument_list|()
decl_stmt|;
name|handlers
operator|->
name|removeOne
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|handlers
operator|->
name|isEmpty
argument_list|()
condition|)
name|qt_file_engine_handlers_in_use
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_destructor
begin_comment
comment|/*    \internal     Handles calls to custom file engine handlers. */
end_comment
begin_function
DECL|function|qt_custom_file_engine_handler_create
name|QAbstractFileEngine
modifier|*
name|qt_custom_file_engine_handler_create
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|QAbstractFileEngine
modifier|*
name|engine
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|qt_file_engine_handlers_in_use
condition|)
block|{
name|QReadLocker
name|locker
argument_list|(
name|fileEngineHandlerMutex
argument_list|()
argument_list|)
decl_stmt|;
comment|// check for registered handlers that can load the file
name|QAbstractFileEngineHandlerList
modifier|*
name|handlers
init|=
name|fileEngineHandlers
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|handlers
operator|->
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|engine
operator|=
name|handlers
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|create
argument_list|(
name|path
argument_list|)
operator|)
condition|)
break|break;
block|}
block|}
return|return
name|engine
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QAbstractFileEngine *QAbstractFileEngineHandler::create(const QString&fileName) const      Creates a file engine for file \a fileName. Returns 0 if this     file handler cannot handle \a fileName.      Example:      \snippet code/src_corelib_io_qabstractfileengine.cpp 1      \sa QAbstractFileEngine::create() */
end_comment
begin_comment
comment|/*!     Creates and returns a QAbstractFileEngine suitable for processing \a     fileName.      You should not need to call this function; use QFile, QFileInfo or     QDir directly instead.      If you reimplemnt this function, it should only return file     engines that knows how to handle \a fileName; otherwise, it should     return 0.      \sa QAbstractFileEngineHandler */
end_comment
begin_function
DECL|function|create
name|QAbstractFileEngine
modifier|*
name|QAbstractFileEngine
operator|::
name|create
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QFileSystemEntry
name|entry
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QFileSystemMetaData
name|metaData
decl_stmt|;
name|QAbstractFileEngine
modifier|*
name|engine
init|=
name|QFileSystemEngine
operator|::
name|resolveEntryAndCreateLegacyEngine
argument_list|(
name|entry
argument_list|,
name|metaData
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_FSFILEENGINE
if|if
condition|(
operator|!
name|engine
condition|)
comment|// fall back to regular file engine
return|return
operator|new
name|QFSFileEngine
argument_list|(
name|entry
operator|.
name|filePath
argument_list|()
argument_list|)
return|;
endif|#
directive|endif
return|return
name|engine
return|;
block|}
end_function
begin_comment
comment|/*!     \class QAbstractFileEngine     \inmodule QtCore     \reentrant     \internal      \brief The QAbstractFileEngine class provides an abstraction for accessing     the filesystem.      \ingroup io     \since 4.1      The QDir, QFile, and QFileInfo classes all make use of a     QAbstractFileEngine internally. If you create your own QAbstractFileEngine     subclass (and register it with Qt by creating a QAbstractFileEngineHandler     subclass), your file engine will be used when the path is one that your     file engine handles.      A QAbstractFileEngine refers to one file or one directory. If the referent     is a file, the setFileName(), rename(), and remove() functions are     applicable. If the referent is a directory the mkdir(), rmdir(), and     entryList() functions are applicable. In all cases the caseSensitive(),     isRelativePath(), fileFlags(), ownerId(), owner(), and fileTime()     functions are applicable.      A QAbstractFileEngine subclass can be created to do synchronous network I/O     based file system operations, local file system operations, or to operate     as a resource system to access file based resources.     \sa QAbstractFileEngineHandler */
end_comment
begin_comment
comment|/*!     \enum QAbstractFileEngine::FileName      These values are used to request a file name in a particular     format.      \value DefaultName The same filename that was passed to the     QAbstractFileEngine.     \value BaseName The name of the file excluding the path.     \value PathName The path to the file excluding the base name.     \value AbsoluteName The absolute path to the file (including     the base name).     \value AbsolutePathName The absolute path to the file (excluding     the base name).     \value LinkName The full file name of the file that this file is a     link to. (This will be empty if this file is not a link.)     \value CanonicalName Often very similar to LinkName. Will return the true path to the file.     \value CanonicalPathName Same as CanonicalName, excluding the base name.     \value BundleName Returns the name of the bundle implies BundleType is set.      \omitvalue NFileNames      \sa fileName(), setFileName() */
end_comment
begin_comment
comment|/*!     \enum QAbstractFileEngine::FileFlag      The permissions and types of a file, suitable for OR'ing together.      \value ReadOwnerPerm The owner of the file has permission to read     it.     \value WriteOwnerPerm The owner of the file has permission to     write to it.     \value ExeOwnerPerm The owner of the file has permission to     execute it.     \value ReadUserPerm The current user has permission to read the     file.     \value WriteUserPerm The current user has permission to write to     the file.     \value ExeUserPerm The current user has permission to execute the     file.     \value ReadGroupPerm Members of the current user's group have     permission to read the file.     \value WriteGroupPerm Members of the current user's group have     permission to write to the file.     \value ExeGroupPerm Members of the current user's group have     permission to execute the file.     \value ReadOtherPerm All users have permission to read the file.     \value WriteOtherPerm All users have permission to write to the     file.     \value ExeOtherPerm All users have permission to execute the file.      \value LinkType The file is a link to another file (or link) in     the file system (i.e. not a file or directory).     \value FileType The file is a regular file to the file system     (i.e. not a link or directory)     \value BundleType The file is a Mac OS X bundle implies DirectoryType     \value DirectoryType The file is a directory in the file system     (i.e. not a link or file).      \value HiddenFlag The file is hidden.     \value ExistsFlag The file actually exists in the file system.     \value RootFlag  The file or the file pointed to is the root of the filesystem.     \value LocalDiskFlag The file resides on the local disk and can be passed to standard file functions.     \value Refresh Passing this flag will force the file engine to refresh all flags.      \omitvalue PermsMask     \omitvalue TypesMask     \omitvalue FlagsMask     \omitvalue FileInfoAll      \sa fileFlags(), setFileName() */
end_comment
begin_comment
comment|/*!     \enum QAbstractFileEngine::FileTime      These are used by the fileTime() function.      \value CreationTime When the file was created.     \value ModificationTime When the file was most recently modified.     \value AccessTime When the file was most recently accessed (e.g.     read or written to).      \sa setFileName() */
end_comment
begin_comment
comment|/*!     \enum QAbstractFileEngine::FileOwner      \value OwnerUser The user who owns the file.     \value OwnerGroup The group who owns the file.      \sa owner(), ownerId(), setFileName() */
end_comment
begin_comment
comment|/*!    Constructs a new QAbstractFileEngine that does not refer to any file or directory.     \sa setFileName()  */
end_comment
begin_constructor
DECL|function|QAbstractFileEngine
name|QAbstractFileEngine
operator|::
name|QAbstractFileEngine
parameter_list|()
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QAbstractFileEnginePrivate
argument_list|)
block|{
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!    \internal     Constructs a QAbstractFileEngine.  */
end_comment
begin_constructor
DECL|function|QAbstractFileEngine
name|QAbstractFileEngine
operator|::
name|QAbstractFileEngine
parameter_list|(
name|QAbstractFileEnginePrivate
modifier|&
name|dd
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|&
name|dd
argument_list|)
block|{
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the QAbstractFileEngine.  */
end_comment
begin_destructor
DECL|function|~QAbstractFileEngine
name|QAbstractFileEngine
operator|::
name|~
name|QAbstractFileEngine
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \fn bool QAbstractFileEngine::open(QIODevice::OpenMode mode)      Opens the file in the specified \a mode. Returns true if the file     was successfully opened; otherwise returns false.      The \a mode is an OR combination of QIODevice::OpenMode and     QIODevice::HandlingMode values. */
end_comment
begin_function
DECL|function|open
name|bool
name|QAbstractFileEngine
operator|::
name|open
parameter_list|(
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|openMode
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Closes the file, returning true if successful; otherwise returns false.      The default implementation always returns false. */
end_comment
begin_function
DECL|function|close
name|bool
name|QAbstractFileEngine
operator|::
name|close
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Flushes the open file, returning true if successful; otherwise returns     false.      The default implementation always returns false. */
end_comment
begin_function
DECL|function|flush
name|bool
name|QAbstractFileEngine
operator|::
name|flush
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the size of the file. */
end_comment
begin_function
DECL|function|size
name|qint64
name|QAbstractFileEngine
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current file position.      This is the position of the data read/write head of the file. */
end_comment
begin_function
DECL|function|pos
name|qint64
name|QAbstractFileEngine
operator|::
name|pos
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QAbstractFileEngine::seek(qint64 offset)      Sets the file position to the given \a offset. Returns true if     the position was successfully set; otherwise returns false.      The offset is from the beginning of the file, unless the     file is sequential.      \sa isSequential() */
end_comment
begin_function
DECL|function|seek
name|bool
name|QAbstractFileEngine
operator|::
name|seek
parameter_list|(
name|qint64
name|pos
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the file is a sequential access device; returns     false if the file is a direct access device.      Operations involving size() and seek(int) are not valid on     sequential devices. */
end_comment
begin_function
DECL|function|isSequential
name|bool
name|QAbstractFileEngine
operator|::
name|isSequential
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Requests that the file is deleted from the file system. If the     operation succeeds return true; otherwise return false.      This virtual function must be reimplemented by all subclasses.      \sa setFileName(), rmdir()  */
end_comment
begin_function
DECL|function|remove
name|bool
name|QAbstractFileEngine
operator|::
name|remove
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Copies the contents of this file to a file with the name \a newName.     Returns true on success; otherwise, false is returned. */
end_comment
begin_function
DECL|function|copy
name|bool
name|QAbstractFileEngine
operator|::
name|copy
parameter_list|(
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|newName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Requests that the file be renamed to \a newName in the file     system. If the operation succeeds return true; otherwise return     false.      This virtual function must be reimplemented by all subclasses.      \sa setFileName()  */
end_comment
begin_function
DECL|function|rename
name|bool
name|QAbstractFileEngine
operator|::
name|rename
parameter_list|(
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|newName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.1      Requests that the file be renamed to \a newName in the file     system. If the new name already exists, it must be overwritten.     If the operation succeeds, returns true; otherwise returns     false.      This virtual function must be reimplemented by all subclasses.      \sa setFileName()  */
end_comment
begin_function
DECL|function|renameOverwrite
name|bool
name|QAbstractFileEngine
operator|::
name|renameOverwrite
parameter_list|(
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|newName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a link from the file currently specified by fileName() to     \a newName. What a link is depends on the underlying filesystem     (be it a shortcut on Windows or a symbolic link on Unix). Returns     true if successful; otherwise returns false. */
end_comment
begin_function
DECL|function|link
name|bool
name|QAbstractFileEngine
operator|::
name|link
parameter_list|(
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|newName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Requests that the directory \a dirName be created. If     \a createParentDirectories is true, then any sub-directories in \a dirName     that don't exist must be created. If \a createParentDirectories is false then     any sub-directories in \a dirName must already exist for the function to     succeed. If the operation succeeds return true; otherwise return     false.      This virtual function must be reimplemented by all subclasses.      \sa setFileName(), rmdir(), isRelativePath()  */
end_comment
begin_function
DECL|function|mkdir
name|bool
name|QAbstractFileEngine
operator|::
name|mkdir
parameter_list|(
specifier|const
name|QString
modifier|&
name|dirName
parameter_list|,
name|bool
name|createParentDirectories
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|dirName
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|createParentDirectories
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Requests that the directory \a dirName is deleted from the file     system. When \a recurseParentDirectories is true, then any empty     parent-directories in \a dirName must also be deleted. If     \a recurseParentDirectories is false, only the \a dirName leaf-node     should be deleted. In most file systems a directory cannot be deleted     using this function if it is non-empty. If the operation succeeds     return true; otherwise return false.      This virtual function must be reimplemented by all subclasses.      \sa setFileName(), remove(), mkdir(), isRelativePath()  */
end_comment
begin_function
DECL|function|rmdir
name|bool
name|QAbstractFileEngine
operator|::
name|rmdir
parameter_list|(
specifier|const
name|QString
modifier|&
name|dirName
parameter_list|,
name|bool
name|recurseParentDirectories
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|dirName
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|recurseParentDirectories
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Requests that the file be set to size \a size. If \a size is larger     than the current file then it is filled with 0's, if smaller it is     simply truncated. If the operations succceeds return true; otherwise     return false;      This virtual function must be reimplemented by all subclasses.      \sa size() */
end_comment
begin_function
DECL|function|setSize
name|bool
name|QAbstractFileEngine
operator|::
name|setSize
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Should return true if the underlying file system is case-sensitive;     otherwise return false.      This virtual function must be reimplemented by all subclasses.  */
end_comment
begin_function
DECL|function|caseSensitive
name|bool
name|QAbstractFileEngine
operator|::
name|caseSensitive
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Return true if the file referred to by this file engine has a     relative path; otherwise return false.      This virtual function must be reimplemented by all subclasses.      \sa setFileName()  */
end_comment
begin_function
DECL|function|isRelativePath
name|bool
name|QAbstractFileEngine
operator|::
name|isRelativePath
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Requests that a list of all the files matching the \a filters     list based on the \a filterNames in the file engine's directory     are returned.      Should return an empty list if the file engine refers to a file     rather than a directory, or if the directory is unreadable or does     not exist or if nothing matches the specifications.      This virtual function must be reimplemented by all subclasses.      \sa setFileName()  */
end_comment
begin_function
DECL|function|entryList
name|QStringList
name|QAbstractFileEngine
operator|::
name|entryList
parameter_list|(
name|QDir
operator|::
name|Filters
name|filters
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|filterNames
parameter_list|)
specifier|const
block|{
name|QStringList
name|ret
decl_stmt|;
name|QDirIterator
name|it
argument_list|(
name|fileName
argument_list|()
argument_list|,
name|filterNames
argument_list|,
name|filters
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|ret
operator|<<
name|it
operator|.
name|fileName
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     This function should return the set of OR'd flags that are true     for the file engine's file, and that are in the \a type's OR'd     members.      In your reimplementation you can use the \a type argument as an     optimization hint and only return the OR'd set of members that are     true and that match those in \a type; in other words you can     ignore any members not mentioned in \a type, thus avoiding some     potentially expensive lookups or system calls.      This virtual function must be reimplemented by all subclasses.      \sa setFileName() */
end_comment
begin_function
DECL|function|fileFlags
name|QAbstractFileEngine
operator|::
name|FileFlags
name|QAbstractFileEngine
operator|::
name|fileFlags
parameter_list|(
name|FileFlags
name|type
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Requests that the file's permissions be set to \a perms. The argument     perms will be set to the OR-ed together combination of     QAbstractFileEngine::FileInfo, with only the QAbstractFileEngine::PermsMask being     honored. If the operations succceeds return true; otherwise return     false;      This virtual function must be reimplemented by all subclasses.      \sa size() */
end_comment
begin_function
DECL|function|setPermissions
name|bool
name|QAbstractFileEngine
operator|::
name|setPermissions
parameter_list|(
name|uint
name|perms
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|perms
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Return  the file engine's current file name in the format     specified by \a file.      If you don't handle some \c FileName possibilities, return the     file name set in setFileName() when an unhandled format is     requested.      This virtual function must be reimplemented by all subclasses.      \sa setFileName(), FileName  */
end_comment
begin_function
DECL|function|fileName
name|QString
name|QAbstractFileEngine
operator|::
name|fileName
parameter_list|(
name|FileName
name|file
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     If \a owner is \c OwnerUser return the ID of the user who owns     the file. If \a owner is \c OwnerGroup return the ID of the group     that own the file. If you can't determine the owner return -2.      This virtual function must be reimplemented by all subclasses.      \sa owner(), setFileName(), FileOwner  */
end_comment
begin_function
DECL|function|ownerId
name|uint
name|QAbstractFileEngine
operator|::
name|ownerId
parameter_list|(
name|FileOwner
name|owner
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|owner
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     If \a owner is \c OwnerUser return the name of the user who owns     the file. If \a owner is \c OwnerGroup return the name of the group     that own the file. If you can't determine the owner return     QString().      This virtual function must be reimplemented by all subclasses.      \sa ownerId(), setFileName(), FileOwner  */
end_comment
begin_function
DECL|function|owner
name|QString
name|QAbstractFileEngine
operator|::
name|owner
parameter_list|(
name|FileOwner
name|owner
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|owner
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     If \a time is \c CreationTime, return when the file was created.     If \a time is \c ModificationTime, return when the file was most     recently modified. If \a time is \c AccessTime, return when the     file was most recently accessed (e.g. read or written).     If the time cannot be determined return QDateTime() (an invalid     date time).      This virtual function must be reimplemented by all subclasses.      \sa setFileName(), QDateTime, QDateTime::isValid(), FileTime  */
end_comment
begin_function
DECL|function|fileTime
name|QDateTime
name|QAbstractFileEngine
operator|::
name|fileTime
parameter_list|(
name|FileTime
name|time
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|time
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the file engine's file name to \a file. This file name is the     file that the rest of the virtual functions will operate on.      This virtual function must be reimplemented by all subclasses.      \sa rename()  */
end_comment
begin_function
DECL|function|setFileName
name|void
name|QAbstractFileEngine
operator|::
name|setFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|file
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the native file handle for this file engine. This handle must be     used with care; its value and type are platform specific, and using it     will most likely lead to non-portable code. */
end_comment
begin_function
DECL|function|handle
name|int
name|QAbstractFileEngine
operator|::
name|handle
parameter_list|()
specifier|const
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns true if the current position is at the end of the file; otherwise,     returns false.      This function bases its behavior on calling extension() with     AtEndExtension. If the engine does not support this extension, false is     returned.      \sa extension(), supportsExtension(), QFile::atEnd() */
end_comment
begin_function
DECL|function|atEnd
name|bool
name|QAbstractFileEngine
operator|::
name|atEnd
parameter_list|()
specifier|const
block|{
return|return
cast|const_cast
argument_list|<
name|QAbstractFileEngine
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|extension
argument_list|(
name|AtEndExtension
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Maps \a size bytes of the file into memory starting at \a offset.     Returns a pointer to the memory if successful; otherwise returns false     if, for example, an error occurs.      This function bases its behavior on calling extension() with     MapExtensionOption. If the engine does not support this extension, 0 is     returned.      \a flags is currently not used, but could be used in the future.      \sa unmap(), supportsExtension()  */
end_comment
begin_function
DECL|function|map
name|uchar
modifier|*
name|QAbstractFileEngine
operator|::
name|map
parameter_list|(
name|qint64
name|offset
parameter_list|,
name|qint64
name|size
parameter_list|,
name|QFile
operator|::
name|MemoryMapFlags
name|flags
parameter_list|)
block|{
name|MapExtensionOption
name|option
decl_stmt|;
name|option
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|option
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|option
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|MapExtensionReturn
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|extension
argument_list|(
name|MapExtension
argument_list|,
operator|&
name|option
argument_list|,
operator|&
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|r
operator|.
name|address
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Unmaps the memory \a address.  Returns true if the unmap succeeds; otherwise     returns false.      This function bases its behavior on calling extension() with     UnMapExtensionOption. If the engine does not support this extension, false is     returned.      \sa map(), supportsExtension()  */
end_comment
begin_function
DECL|function|unmap
name|bool
name|QAbstractFileEngine
operator|::
name|unmap
parameter_list|(
name|uchar
modifier|*
name|address
parameter_list|)
block|{
name|UnMapExtensionOption
name|options
decl_stmt|;
name|options
operator|.
name|address
operator|=
name|address
expr_stmt|;
return|return
name|extension
argument_list|(
name|UnMapExtension
argument_list|,
operator|&
name|options
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3     \class QAbstractFileEngineIterator     \inmodule QtCore     \brief The QAbstractFileEngineIterator class provides an iterator     interface for custom file engines.     \internal      If all you want is to iterate over entries in a directory, see     QDirIterator instead. This class is only for custom file engine authors.      QAbstractFileEngineIterator is a unidirectional single-use virtual     iterator that plugs into QDirIterator, providing transparent proxy     iteration for custom file engines.      You can subclass QAbstractFileEngineIterator to provide an iterator when     writing your own file engine. To plug the iterator into your file system,     you simply return an instance of this subclass from a reimplementation of     QAbstractFileEngine::beginEntryList().      Example:      \snippet code/src_corelib_io_qabstractfileengine.cpp 2      QAbstractFileEngineIterator is associated with a path, name filters, and     entry filters. The path is the directory that the iterator lists entries     in. The name filters and entry filters are provided for file engines that     can optimize directory listing at the iterator level (e.g., network file     systems that need to minimize network traffic), but they can also be     ignored by the iterator subclass; QAbstractFileEngineIterator already     provides the required filtering logics in the matchesFilters() function.     You can call dirName() to get the directory name, nameFilters() to get a     stringlist of name filters, and filters() to get the entry filters.      The pure virtual function hasNext() returns true if the current directory     has at least one more entry (i.e., the directory name is valid and     accessible, and we have not reached the end of the entry list), and false     otherwise. Reimplement next() to seek to the next entry.      The pure virtual function currentFileName() returns the name of the     current entry without advancing the iterator. The currentFilePath()     function is provided for convenience; it returns the full path of the     current entry.      Here is an example of how to implement an iterator that returns each of     three fixed entries in sequence.      \snippet code/src_corelib_io_qabstractfileengine.cpp 3      Note: QAbstractFileEngineIterator does not deal with QDir::IteratorFlags;     it simply returns entries for a single directory.      \sa QDirIterator */
end_comment
begin_comment
comment|/*!     \enum QAbstractFileEngineIterator::EntryInfoType     \internal      This enum describes the different types of information that can be     requested through the QAbstractFileEngineIterator::entryInfo() function. */
end_comment
begin_comment
comment|/*!     \typedef QAbstractFileEngine::Iterator     \since 4.3     \relates QAbstractFileEngine      Synonym for QAbstractFileEngineIterator. */
end_comment
begin_class
DECL|class|QAbstractFileEngineIteratorPrivate
class|class
name|QAbstractFileEngineIteratorPrivate
block|{
public|public:
DECL|member|path
name|QString
name|path
decl_stmt|;
DECL|member|filters
name|QDir
operator|::
name|Filters
name|filters
decl_stmt|;
DECL|member|nameFilters
name|QStringList
name|nameFilters
decl_stmt|;
DECL|member|fileInfo
name|QFileInfo
name|fileInfo
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a QAbstractFileEngineIterator, using the entry filters \a     filters, and wildcard name filters \a nameFilters. */
end_comment
begin_constructor
DECL|function|QAbstractFileEngineIterator
name|QAbstractFileEngineIterator
operator|::
name|QAbstractFileEngineIterator
parameter_list|(
name|QDir
operator|::
name|Filters
name|filters
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|nameFilters
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QAbstractFileEngineIteratorPrivate
argument_list|)
block|{
name|d
operator|->
name|nameFilters
operator|=
name|nameFilters
expr_stmt|;
name|d
operator|->
name|filters
operator|=
name|filters
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the QAbstractFileEngineIterator.      \sa QDirIterator */
end_comment
begin_destructor
DECL|function|~QAbstractFileEngineIterator
name|QAbstractFileEngineIterator
operator|::
name|~
name|QAbstractFileEngineIterator
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the path for this iterator. QDirIterator is responsible for     assigning this path; it cannot change during the iterator's lifetime.      \sa nameFilters(), filters() */
end_comment
begin_function
DECL|function|path
name|QString
name|QAbstractFileEngineIterator
operator|::
name|path
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|path
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Sets the iterator path to \a path. This function is called from within     QDirIterator. */
end_comment
begin_function
DECL|function|setPath
name|void
name|QAbstractFileEngineIterator
operator|::
name|setPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|d
operator|->
name|path
operator|=
name|path
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the name filters for this iterator.      \sa QDir::nameFilters(), filters(), path() */
end_comment
begin_function
DECL|function|nameFilters
name|QStringList
name|QAbstractFileEngineIterator
operator|::
name|nameFilters
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|nameFilters
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the entry filters for this iterator.      \sa QDir::filter(), nameFilters(), path() */
end_comment
begin_function
DECL|function|filters
name|QDir
operator|::
name|Filters
name|QAbstractFileEngineIterator
operator|::
name|filters
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|filters
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QAbstractFileEngineIterator::currentFileName() const = 0      This pure virtual function returns the name of the current directory     entry, excluding the path.      \sa currentFilePath() */
end_comment
begin_comment
comment|/*!     Returns the path to the current directory entry. It's the same as     prepending path() to the return value of currentFileName().      \sa currentFileName() */
end_comment
begin_function
DECL|function|currentFilePath
name|QString
name|QAbstractFileEngineIterator
operator|::
name|currentFilePath
parameter_list|()
specifier|const
block|{
name|QString
name|name
init|=
name|currentFileName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QString
name|tmp
init|=
name|path
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|tmp
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|tmp
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|.
name|prepend
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|name
return|;
block|}
end_function
begin_comment
comment|/*!     The virtual function returns a QFileInfo for the current directory     entry. This function is provided for convenience. It can also be slightly     faster than creating a QFileInfo object yourself, as the object returned     by this function might contain cached information that QFileInfo otherwise     would have to access through the file engine.      \sa currentFileName() */
end_comment
begin_function
DECL|function|currentFileInfo
name|QFileInfo
name|QAbstractFileEngineIterator
operator|::
name|currentFileInfo
parameter_list|()
specifier|const
block|{
name|QString
name|path
init|=
name|currentFilePath
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|fileInfo
operator|.
name|filePath
argument_list|()
operator|!=
name|path
condition|)
name|d
operator|->
name|fileInfo
operator|.
name|setFile
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|// return a shallow copy
return|return
name|d
operator|->
name|fileInfo
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the entry info \a type for this iterator's current directory entry     as a QVariant. If \a type is undefined for this entry, a null QVariant is     returned.      \sa QAbstractFileEngine::beginEntryList(), QDir::beginEntryList() */
end_comment
begin_function
DECL|function|entryInfo
name|QVariant
name|QAbstractFileEngineIterator
operator|::
name|entryInfo
parameter_list|(
name|EntryInfoType
name|type
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|type
argument_list|)
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn virtual QString QAbstractFileEngineIterator::next() = 0      This pure virtual function advances the iterator to the next directory     entry, and returns the file path to the current entry.      This function can optionally make use of nameFilters() and filters() to     optimize its performance.      Reimplement this function in a subclass to advance the iterator.      \sa QDirIterator::next() */
end_comment
begin_comment
comment|/*!     \fn virtual bool QAbstractFileEngineIterator::hasNext() const = 0      This pure virtual function returns true if there is at least one more     entry in the current directory (i.e., the iterator path is valid and     accessible, and the iterator has not reached the end of the entry list).      \sa QDirIterator::hasNext() */
end_comment
begin_comment
comment|/*!     Returns an instance of a QAbstractFileEngineIterator using \a filters for     entry filtering and \a filterNames for name filtering. This function is     called by QDirIterator to initiate directory iteration.      QDirIterator takes ownership of the returned instance, and deletes it when     it's done.      \sa QDirIterator */
end_comment
begin_function
DECL|function|beginEntryList
name|QAbstractFileEngine
operator|::
name|Iterator
modifier|*
name|QAbstractFileEngine
operator|::
name|beginEntryList
parameter_list|(
name|QDir
operator|::
name|Filters
name|filters
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|filterNames
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|filters
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|filterNames
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|endEntryList
name|QAbstractFileEngine
operator|::
name|Iterator
modifier|*
name|QAbstractFileEngine
operator|::
name|endEntryList
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Reads a number of characters from the file into \a data. At most     \a maxlen characters will be read.      Returns -1 if a fatal error occurs, or 0 if there are no bytes to     read. */
end_comment
begin_function
DECL|function|read
name|qint64
name|QAbstractFileEngine
operator|::
name|read
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|maxlen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Writes \a len bytes from \a data to the file. Returns the number     of characters written on success; otherwise returns -1. */
end_comment
begin_function
DECL|function|write
name|qint64
name|QAbstractFileEngine
operator|::
name|write
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     This function reads one line, terminated by a '\\n' character, from the     file info \a data. At most \a maxlen characters will be read. The     end-of-line character is included. */
end_comment
begin_function
DECL|function|readLine
name|qint64
name|QAbstractFileEngine
operator|::
name|readLine
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|qint64
name|readSoFar
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|readSoFar
operator|<
name|maxlen
condition|)
block|{
name|char
name|c
decl_stmt|;
name|qint64
name|readResult
init|=
name|read
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|readResult
operator|<=
literal|0
condition|)
return|return
operator|(
name|readSoFar
operator|>
literal|0
operator|)
condition|?
name|readSoFar
else|:
operator|-
literal|1
return|;
operator|++
name|readSoFar
expr_stmt|;
operator|*
name|data
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|readSoFar
return|;
block|}
return|return
name|readSoFar
return|;
block|}
end_function
begin_comment
comment|/*!    \enum QAbstractFileEngine::Extension    \since 4.3     This enum describes the types of extensions that the file engine can    support. Before using these extensions, you must verify that the extension    is supported (i.e., call supportsExtension()).     \value AtEndExtension Whether the current file position is at the end of    the file or not. This extension allows file engines that implement local    buffering to report end-of-file status without having to check the size of    the file. It is also useful for sequential files, where the size of the    file cannot be used to determine whether or not you have reached the end.    This extension returns true if the file is at the end; otherwise it returns    false. The input and output arguments to extension() are ignored.     \value FastReadLineExtension Whether the file engine provides a    fast implementation for readLine() or not. If readLine() remains    unimplemented in the file engine, QAbstractFileEngine will provide    an implementation based on calling read() repeatedly. If    supportsExtension() returns false for this extension, however,    QIODevice can provide a faster implementation by making use of its    internal buffer. For engines that already provide a fast readLine()    implementation, returning false for this extension can avoid    unnnecessary double-buffering in QIODevice.     \value MapExtension Whether the file engine provides the ability to map    a file to memory.     \value UnMapExtension Whether the file engine provides the ability to    unmap memory that was previously mapped. */
end_comment
begin_comment
comment|/*!    \class QAbstractFileEngine::ExtensionOption    \inmodule QtCore    \since 4.3    \brief provides an extended input argument to QAbstractFileEngine's    extension support.     \sa QAbstractFileEngine::extension() */
end_comment
begin_comment
comment|/*!    \class QAbstractFileEngine::ExtensionReturn    \inmodule QtCore    \since 4.3    \brief provides an extended output argument to QAbstractFileEngine's    extension support.     \sa QAbstractFileEngine::extension() */
end_comment
begin_comment
comment|/*!     \since 4.3      This virtual function can be reimplemented in a QAbstractFileEngine     subclass to provide support for extensions. The \a option argument is     provided as input to the extension, and this function can store output     results in \a output.      The behavior of this function is determined by \a extension; see the     Extension documentation for details.      You can call supportsExtension() to check if an extension is supported by     the file engine.      By default, no extensions are supported, and this function returns false.      \sa supportsExtension(), Extension */
end_comment
begin_function
DECL|function|extension
name|bool
name|QAbstractFileEngine
operator|::
name|extension
parameter_list|(
name|Extension
name|extension
parameter_list|,
specifier|const
name|ExtensionOption
modifier|*
name|option
parameter_list|,
name|ExtensionReturn
modifier|*
name|output
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|output
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      This virtual function returns true if the file engine supports \a     extension; otherwise, false is returned. By default, no extensions are     supported.      \sa extension() */
end_comment
begin_function
DECL|function|supportsExtension
name|bool
name|QAbstractFileEngine
operator|::
name|supportsExtension
parameter_list|(
name|Extension
name|extension
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the QFile::FileError that resulted from the last failed   operation. If QFile::UnspecifiedError is returned, QFile will   use its own idea of the error status.    \sa QFile::FileError, errorString()  */
end_comment
begin_function
DECL|function|error
name|QFile
operator|::
name|FileError
name|QAbstractFileEngine
operator|::
name|error
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractFileEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fileError
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the human-readable message appropriate to the current error   reported by error(). If no suitable string is available, an   empty string is returned.    \sa error()  */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QAbstractFileEngine
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractFileEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|errorString
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the error type to \a error, and the error string to \a errorString.     Call this function to set the error values returned by the higher-level     classes.      \sa QFile::error(), QIODevice::errorString(), QIODevice::setErrorString() */
end_comment
begin_function
DECL|function|setError
name|void
name|QAbstractFileEngine
operator|::
name|setError
parameter_list|(
name|QFile
operator|::
name|FileError
name|error
parameter_list|,
specifier|const
name|QString
modifier|&
name|errorString
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractFileEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileError
operator|=
name|error
expr_stmt|;
name|d
operator|->
name|errorString
operator|=
name|errorString
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
