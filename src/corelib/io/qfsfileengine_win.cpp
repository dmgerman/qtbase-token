begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"private/qabstractfileengine_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qfsfileengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qfilesystemengine_p.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qdir.h"
end_include
begin_include
include|#
directive|include
file|"private/qmutexpool_p.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qt_windows.h"
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<direct.h>
end_include
begin_include
include|#
directive|include
file|<winioctl.h>
end_include
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|<types.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<objbase.h>
end_include
begin_include
include|#
directive|include
file|<shlobj.h>
end_include
begin_include
include|#
directive|include
file|<initguid.h>
end_include
begin_include
include|#
directive|include
file|<accctrl.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_define
DECL|macro|SECURITY_WIN32
define|#
directive|define
name|SECURITY_WIN32
end_define
begin_include
include|#
directive|include
file|<security.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|PATH_MAX
end_ifndef
begin_define
DECL|macro|PATH_MAX
define|#
directive|define
name|PATH_MAX
value|FILENAME_MAX
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
DECL|function|isUncPath
specifier|static
specifier|inline
name|bool
name|isUncPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
comment|// Starts with \\, but not \\.
return|return
operator|(
name|path
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"\\\\"
argument_list|)
argument_list|)
operator|&&
name|path
operator|.
name|size
argument_list|()
operator|>
literal|2
operator|&&
name|path
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|longFileName
name|QString
name|QFSFileEnginePrivate
operator|::
name|longFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"\\\\.\\"
argument_list|)
argument_list|)
condition|)
return|return
name|path
return|;
name|QString
name|absPath
init|=
name|QFileSystemEngine
operator|::
name|nativeAbsoluteFilePath
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|QString
name|prefix
init|=
name|QLatin1String
argument_list|(
literal|"\\\\?\\"
argument_list|)
decl_stmt|;
if|if
condition|(
name|isUncPath
argument_list|(
name|absPath
argument_list|)
condition|)
block|{
name|prefix
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"UNC\\"
argument_list|)
argument_list|)
expr_stmt|;
comment|// "\\\\?\\UNC\\"
name|absPath
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|prefix
operator|+
name|absPath
return|;
else|#
directive|else
return|return
name|absPath
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*     \internal */
end_comment
begin_function
DECL|function|nativeOpen
name|bool
name|QFSFileEnginePrivate
operator|::
name|nativeOpen
parameter_list|(
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
comment|// All files are opened in share mode (both read and write).
name|DWORD
name|shareMode
init|=
name|FILE_SHARE_READ
operator||
name|FILE_SHARE_WRITE
decl_stmt|;
name|int
name|accessRights
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|openMode
operator|&
name|QIODevice
operator|::
name|ReadOnly
condition|)
name|accessRights
operator||=
name|GENERIC_READ
expr_stmt|;
if|if
condition|(
name|openMode
operator|&
name|QIODevice
operator|::
name|WriteOnly
condition|)
name|accessRights
operator||=
name|GENERIC_WRITE
expr_stmt|;
name|SECURITY_ATTRIBUTES
name|securityAtts
init|=
block|{
sizeof|sizeof
argument_list|(
name|SECURITY_ATTRIBUTES
argument_list|)
block|,
name|NULL
block|,
name|FALSE
block|}
decl_stmt|;
comment|// WriteOnly can create files, ReadOnly cannot.
name|DWORD
name|creationDisp
init|=
operator|(
name|openMode
operator|&
name|QIODevice
operator|::
name|WriteOnly
operator|)
condition|?
name|OPEN_ALWAYS
else|:
name|OPEN_EXISTING
decl_stmt|;
comment|// Create the file handle.
name|fileHandle
operator|=
name|CreateFile
argument_list|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|fileEntry
operator|.
name|nativeFilePath
argument_list|()
operator|.
name|utf16
argument_list|()
argument_list|,
name|accessRights
argument_list|,
name|shareMode
argument_list|,
operator|&
name|securityAtts
argument_list|,
name|creationDisp
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|// Bail out on error.
if|if
condition|(
name|fileHandle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|OpenError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Truncate the file after successfully opening it if Truncate is passed.
if|if
condition|(
name|openMode
operator|&
name|QIODevice
operator|::
name|Truncate
condition|)
name|q
operator|->
name|setSize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*     \internal */
end_comment
begin_function
DECL|function|nativeClose
name|bool
name|QFSFileEnginePrivate
operator|::
name|nativeClose
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|fh
operator|||
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// stdlib / stdio mode.
return|return
name|closeFdFh
argument_list|()
return|;
block|}
comment|// Windows native mode.
name|bool
name|ok
init|=
literal|true
decl_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_WINCE
if|if
condition|(
name|cachedFd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|::
name|_close
argument_list|(
name|cachedFd
argument_list|)
operator|&&
operator|!
operator|::
name|CloseHandle
argument_list|(
name|fileHandle
argument_list|)
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|UnspecifiedError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|false
expr_stmt|;
block|}
comment|// System handle is closed with associated file descriptor.
name|fileHandle
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|cachedFd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|ok
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|fileHandle
operator|==
name|INVALID_HANDLE_VALUE
operator|||
operator|!
operator|::
name|CloseHandle
argument_list|(
name|fileHandle
argument_list|)
operator|)
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|UnspecifiedError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|false
expr_stmt|;
block|}
name|fileHandle
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function
begin_comment
comment|/*     \internal */
end_comment
begin_function
DECL|function|nativeFlush
name|bool
name|QFSFileEnginePrivate
operator|::
name|nativeFlush
parameter_list|()
block|{
if|if
condition|(
name|fh
condition|)
block|{
comment|// Buffered stdlib mode.
return|return
name|flushFh
argument_list|()
return|;
block|}
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Unbuffered stdio mode; always succeeds (no buffer).
return|return
literal|true
return|;
block|}
comment|// Windows native mode; flushing is unnecessary.
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*     \internal     \since 5.1 */
end_comment
begin_function
DECL|function|nativeSyncToDisk
name|bool
name|QFSFileEnginePrivate
operator|::
name|nativeSyncToDisk
parameter_list|()
block|{
if|if
condition|(
name|fh
operator|||
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// stdlib / stdio mode. No API available.
return|return
literal|false
return|;
block|}
return|return
name|FlushFileBuffers
argument_list|(
name|fileHandle
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*     \internal */
end_comment
begin_function
DECL|function|nativeSize
name|qint64
name|QFSFileEnginePrivate
operator|::
name|nativeSize
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QFSFileEngine
argument_list|)
expr_stmt|;
name|QFSFileEngine
modifier|*
name|thatQ
init|=
cast|const_cast
argument_list|<
name|QFSFileEngine
operator|*
argument_list|>
argument_list|(
name|q
argument_list|)
decl_stmt|;
comment|// ### Don't flush; for buffered files, we should get away with ftell.
name|thatQ
operator|->
name|flush
argument_list|()
expr_stmt|;
comment|// Always retrive the current information
name|metaData
operator|.
name|clearFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|SizeAttribute
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
comment|// Buffered stdlib mode.
if|if
condition|(
name|fh
condition|)
block|{
name|QT_OFF_T
name|oldPos
init|=
name|QT_FTELL
argument_list|(
name|fh
argument_list|)
decl_stmt|;
name|QT_FSEEK
argument_list|(
name|fh
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|qint64
name|fileSize
init|=
operator|(
name|qint64
operator|)
name|QT_FTELL
argument_list|(
name|fh
argument_list|)
decl_stmt|;
name|QT_FSEEK
argument_list|(
name|fh
argument_list|,
name|oldPos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileSize
operator|==
operator|-
literal|1
condition|)
block|{
name|fileSize
operator|=
literal|0
expr_stmt|;
name|thatQ
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|UnspecifiedError
argument_list|,
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|fileSize
return|;
block|}
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|thatQ
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|UnspecifiedError
argument_list|,
name|QLatin1String
argument_list|(
literal|"Not implemented!"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|bool
name|filled
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|fileHandle
operator|!=
name|INVALID_HANDLE_VALUE
operator|&&
name|openMode
operator|!=
name|QIODevice
operator|::
name|NotOpen
condition|)
name|filled
operator|=
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|fileHandle
argument_list|,
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|SizeAttribute
argument_list|)
expr_stmt|;
else|else
name|filled
operator|=
name|doStat
argument_list|(
name|QFileSystemMetaData
operator|::
name|SizeAttribute
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filled
condition|)
block|{
name|thatQ
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|UnspecifiedError
argument_list|,
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|metaData
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*     \internal */
end_comment
begin_function
DECL|function|nativePos
name|qint64
name|QFSFileEnginePrivate
operator|::
name|nativePos
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QFSFileEngine
argument_list|)
expr_stmt|;
name|QFSFileEngine
modifier|*
name|thatQ
init|=
cast|const_cast
argument_list|<
name|QFSFileEngine
operator|*
argument_list|>
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|fh
operator|||
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// stdlib / stido mode.
return|return
name|posFdFh
argument_list|()
return|;
block|}
comment|// Windows native mode.
if|if
condition|(
name|fileHandle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
return|return
literal|0
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|LARGE_INTEGER
name|currentFilePos
decl_stmt|;
name|LARGE_INTEGER
name|offset
decl_stmt|;
name|offset
operator|.
name|QuadPart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|::
name|SetFilePointerEx
argument_list|(
name|fileHandle
argument_list|,
name|offset
argument_list|,
operator|&
name|currentFilePos
argument_list|,
name|FILE_CURRENT
argument_list|)
condition|)
block|{
name|thatQ
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|UnspecifiedError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|qint64
argument_list|(
name|currentFilePos
operator|.
name|QuadPart
argument_list|)
return|;
else|#
directive|else
name|LARGE_INTEGER
name|filepos
decl_stmt|;
name|filepos
operator|.
name|HighPart
operator|=
literal|0
expr_stmt|;
name|DWORD
name|newFilePointer
init|=
name|SetFilePointer
argument_list|(
name|fileHandle
argument_list|,
literal|0
argument_list|,
operator|&
name|filepos
operator|.
name|HighPart
argument_list|,
name|FILE_CURRENT
argument_list|)
decl_stmt|;
if|if
condition|(
name|newFilePointer
operator|==
literal|0xFFFFFFFF
operator|&&
name|GetLastError
argument_list|()
operator|!=
name|NO_ERROR
condition|)
block|{
name|thatQ
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|UnspecifiedError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|filepos
operator|.
name|LowPart
operator|=
name|newFilePointer
expr_stmt|;
return|return
name|filepos
operator|.
name|QuadPart
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*     \internal */
end_comment
begin_function
DECL|function|nativeSeek
name|bool
name|QFSFileEnginePrivate
operator|::
name|nativeSeek
parameter_list|(
name|qint64
name|pos
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|fh
operator|||
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// stdlib / stdio mode.
return|return
name|seekFdFh
argument_list|(
name|pos
argument_list|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|LARGE_INTEGER
name|currentFilePos
decl_stmt|;
name|LARGE_INTEGER
name|offset
decl_stmt|;
name|offset
operator|.
name|QuadPart
operator|=
name|pos
expr_stmt|;
if|if
condition|(
operator|!
operator|::
name|SetFilePointerEx
argument_list|(
name|fileHandle
argument_list|,
name|offset
argument_list|,
operator|&
name|currentFilePos
argument_list|,
name|FILE_BEGIN
argument_list|)
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|UnspecifiedError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
else|#
directive|else
name|DWORD
name|newFilePointer
decl_stmt|;
name|LARGE_INTEGER
modifier|*
name|li
init|=
cast|reinterpret_cast
argument_list|<
name|LARGE_INTEGER
operator|*
argument_list|>
argument_list|(
operator|&
name|pos
argument_list|)
decl_stmt|;
name|newFilePointer
operator|=
name|SetFilePointer
argument_list|(
name|fileHandle
argument_list|,
name|li
operator|->
name|LowPart
argument_list|,
operator|&
name|li
operator|->
name|HighPart
argument_list|,
name|FILE_BEGIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|newFilePointer
operator|==
literal|0xFFFFFFFF
operator|&&
name|GetLastError
argument_list|()
operator|!=
name|NO_ERROR
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|PositionError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*     \internal */
end_comment
begin_function
DECL|function|nativeRead
name|qint64
name|QFSFileEnginePrivate
operator|::
name|nativeRead
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|fh
operator|||
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// stdio / stdlib mode.
if|if
condition|(
name|fh
operator|&&
name|nativeIsSequential
argument_list|()
operator|&&
name|feof
argument_list|(
name|fh
argument_list|)
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|ReadError
argument_list|,
name|qt_error_string
argument_list|(
name|int
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|readFdFh
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
return|;
block|}
comment|// Windows native mode.
if|if
condition|(
name|fileHandle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
return|return
operator|-
literal|1
return|;
name|DWORD
name|bytesToRead
init|=
name|DWORD
argument_list|(
name|maxlen
argument_list|)
decl_stmt|;
comment|//<- lossy
comment|// Reading on Windows fails with ERROR_NO_SYSTEM_RESOURCES when
comment|// the chunks are too large, so we limit the block size to 32MB.
specifier|static
specifier|const
name|DWORD
name|maxBlockSize
init|=
literal|32
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
name|qint64
name|totalRead
init|=
literal|0
decl_stmt|;
do|do
block|{
name|DWORD
name|blockSize
init|=
name|qMin
argument_list|<
name|DWORD
argument_list|>
argument_list|(
name|bytesToRead
argument_list|,
name|maxBlockSize
argument_list|)
decl_stmt|;
name|DWORD
name|bytesRead
decl_stmt|;
if|if
condition|(
operator|!
name|ReadFile
argument_list|(
name|fileHandle
argument_list|,
name|data
operator|+
name|totalRead
argument_list|,
name|blockSize
argument_list|,
operator|&
name|bytesRead
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|totalRead
operator|==
literal|0
condition|)
block|{
comment|// Note: only return failure if the first ReadFile fails.
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|ReadError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
block|}
if|if
condition|(
name|bytesRead
operator|==
literal|0
condition|)
break|break;
name|totalRead
operator|+=
name|bytesRead
expr_stmt|;
name|bytesToRead
operator|-=
name|bytesRead
expr_stmt|;
block|}
do|while
condition|(
name|totalRead
operator|<
name|maxlen
condition|)
do|;
return|return
name|qint64
argument_list|(
name|totalRead
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*     \internal */
end_comment
begin_function
DECL|function|nativeReadLine
name|qint64
name|QFSFileEnginePrivate
operator|::
name|nativeReadLine
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|fh
operator|||
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// stdio / stdlib mode.
return|return
name|readLineFdFh
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
return|;
block|}
comment|// Windows native mode.
if|if
condition|(
name|fileHandle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
return|return
operator|-
literal|1
return|;
comment|// ### No equivalent in Win32?
return|return
name|q
operator|->
name|QAbstractFileEngine
operator|::
name|readLine
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*     \internal */
end_comment
begin_function
DECL|function|nativeWrite
name|qint64
name|QFSFileEnginePrivate
operator|::
name|nativeWrite
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|fh
operator|||
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// stdio / stdlib mode.
return|return
name|writeFdFh
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
comment|// Windows native mode.
if|if
condition|(
name|fileHandle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
return|return
operator|-
literal|1
return|;
name|qint64
name|bytesToWrite
init|=
name|DWORD
argument_list|(
name|len
argument_list|)
decl_stmt|;
comment|//<- lossy
comment|// Writing on Windows fails with ERROR_NO_SYSTEM_RESOURCES when
comment|// the chunks are too large, so we limit the block size to 32MB.
specifier|static
specifier|const
name|DWORD
name|maxBlockSize
init|=
literal|32
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
name|qint64
name|totalWritten
init|=
literal|0
decl_stmt|;
do|do
block|{
name|DWORD
name|blockSize
init|=
name|qMin
argument_list|<
name|DWORD
argument_list|>
argument_list|(
name|bytesToWrite
argument_list|,
name|maxBlockSize
argument_list|)
decl_stmt|;
name|DWORD
name|bytesWritten
decl_stmt|;
if|if
condition|(
operator|!
name|WriteFile
argument_list|(
name|fileHandle
argument_list|,
name|data
operator|+
name|totalWritten
argument_list|,
name|blockSize
argument_list|,
operator|&
name|bytesWritten
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|totalWritten
operator|==
literal|0
condition|)
block|{
comment|// Note: Only return error if the first WriteFile failed.
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|WriteError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
block|}
if|if
condition|(
name|bytesWritten
operator|==
literal|0
condition|)
break|break;
name|totalWritten
operator|+=
name|bytesWritten
expr_stmt|;
name|bytesToWrite
operator|-=
name|bytesWritten
expr_stmt|;
block|}
do|while
condition|(
name|totalWritten
operator|<
name|len
condition|)
do|;
return|return
name|qint64
argument_list|(
name|totalWritten
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*     \internal */
end_comment
begin_function
DECL|function|nativeHandle
name|int
name|QFSFileEnginePrivate
operator|::
name|nativeHandle
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|fh
operator|||
name|fd
operator|!=
operator|-
literal|1
condition|)
return|return
name|fh
condition|?
name|QT_FILENO
argument_list|(
name|fh
argument_list|)
else|:
name|fd
return|;
ifndef|#
directive|ifndef
name|Q_OS_WINCE
if|if
condition|(
name|cachedFd
operator|!=
operator|-
literal|1
condition|)
return|return
name|cachedFd
return|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|openMode
operator|&
name|QIODevice
operator|::
name|Append
condition|)
name|flags
operator||=
name|_O_APPEND
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|openMode
operator|&
name|QIODevice
operator|::
name|WriteOnly
operator|)
condition|)
name|flags
operator||=
name|_O_RDONLY
expr_stmt|;
name|cachedFd
operator|=
name|_open_osfhandle
argument_list|(
operator|(
name|intptr_t
operator|)
name|fileHandle
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|cachedFd
return|;
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*     \internal */
end_comment
begin_function
DECL|function|nativeIsSequential
name|bool
name|QFSFileEnginePrivate
operator|::
name|nativeIsSequential
parameter_list|()
specifier|const
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|HANDLE
name|handle
init|=
name|fileHandle
decl_stmt|;
if|if
condition|(
name|fh
operator|||
name|fd
operator|!=
operator|-
literal|1
condition|)
name|handle
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fh
condition|?
name|QT_FILENO
argument_list|(
name|fh
argument_list|)
else|:
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
return|return
literal|false
return|;
name|DWORD
name|fileType
init|=
name|GetFileType
argument_list|(
name|handle
argument_list|)
decl_stmt|;
return|return
operator|(
name|fileType
operator|==
name|FILE_TYPE_CHAR
operator|)
operator|||
operator|(
name|fileType
operator|==
name|FILE_TYPE_PIPE
operator|)
return|;
else|#
directive|else
return|return
literal|false
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|remove
name|bool
name|QFSFileEngine
operator|::
name|remove
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
name|QSystemError
name|error
decl_stmt|;
name|bool
name|ret
init|=
name|QFileSystemEngine
operator|::
name|removeFile
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|setError
argument_list|(
name|QFile
operator|::
name|RemoveError
argument_list|,
name|error
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|copy
name|bool
name|QFSFileEngine
operator|::
name|copy
parameter_list|(
specifier|const
name|QString
modifier|&
name|copyName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
name|QSystemError
name|error
decl_stmt|;
name|bool
name|ret
init|=
name|QFileSystemEngine
operator|::
name|copyFile
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|QFileSystemEntry
argument_list|(
name|copyName
argument_list|)
argument_list|,
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|setError
argument_list|(
name|QFile
operator|::
name|CopyError
argument_list|,
name|error
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|rename
name|bool
name|QFSFileEngine
operator|::
name|rename
parameter_list|(
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
name|QSystemError
name|error
decl_stmt|;
name|bool
name|ret
init|=
name|QFileSystemEngine
operator|::
name|renameFile
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|QFileSystemEntry
argument_list|(
name|newName
argument_list|)
argument_list|,
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|error
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|renameOverwrite
name|bool
name|QFSFileEngine
operator|::
name|renameOverwrite
parameter_list|(
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
name|bool
name|ret
init|=
operator|::
name|MoveFileEx
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|d
operator|->
name|fileEntry
operator|.
name|nativeFilePath
argument_list|()
operator|.
name|utf16
argument_list|()
argument_list|,
operator|(
name|wchar_t
operator|*
operator|)
name|QFileSystemEntry
argument_list|(
name|newName
argument_list|)
operator|.
name|nativeFilePath
argument_list|()
operator|.
name|utf16
argument_list|()
argument_list|,
name|MOVEFILE_REPLACE_EXISTING
operator||
name|MOVEFILE_COPY_ALLOWED
argument_list|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|QSystemError
argument_list|(
operator|::
name|GetLastError
argument_list|()
argument_list|,
name|QSystemError
operator|::
name|NativeError
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|mkdir
name|bool
name|QFSFileEngine
operator|::
name|mkdir
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|createParentDirectories
parameter_list|)
specifier|const
block|{
return|return
name|QFileSystemEngine
operator|::
name|createDirectory
argument_list|(
name|QFileSystemEntry
argument_list|(
name|name
argument_list|)
argument_list|,
name|createParentDirectories
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|rmdir
name|bool
name|QFSFileEngine
operator|::
name|rmdir
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|bool
name|recurseParentDirectories
parameter_list|)
specifier|const
block|{
return|return
name|QFileSystemEngine
operator|::
name|removeDirectory
argument_list|(
name|QFileSystemEntry
argument_list|(
name|name
argument_list|)
argument_list|,
name|recurseParentDirectories
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|caseSensitive
name|bool
name|QFSFileEngine
operator|::
name|caseSensitive
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|setCurrentPath
name|bool
name|QFSFileEngine
operator|::
name|setCurrentPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
return|return
name|QFileSystemEngine
operator|::
name|setCurrentPath
argument_list|(
name|QFileSystemEntry
argument_list|(
name|path
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|currentPath
name|QString
name|QFSFileEngine
operator|::
name|currentPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|QString
name|ret
decl_stmt|;
comment|//if filename is a drive: then get the pwd of that drive
if|if
condition|(
name|fileName
operator|.
name|length
argument_list|()
operator|>=
literal|2
operator|&&
name|fileName
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|isLetter
argument_list|()
operator|&&
name|fileName
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
condition|)
block|{
name|int
name|drv
init|=
name|fileName
operator|.
name|toUpper
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|-
literal|'A'
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|_getdrive
argument_list|()
operator|!=
name|drv
condition|)
block|{
name|wchar_t
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
operator|::
name|_wgetdcwd
argument_list|(
name|drv
argument_list|,
name|buf
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|ret
operator|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//just the pwd
name|ret
operator|=
name|QFileSystemEngine
operator|::
name|currentPath
argument_list|()
operator|.
name|filePath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|.
name|length
argument_list|()
operator|>=
literal|2
operator|&&
name|ret
index|[
literal|1
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
condition|)
name|ret
index|[
literal|0
index|]
operator|=
name|ret
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toUpper
argument_list|()
expr_stmt|;
comment|// Force uppercase drive letters.
return|return
name|ret
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
return|return
name|QFileSystemEngine
operator|::
name|currentPath
argument_list|()
operator|.
name|filePath
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|homePath
name|QString
name|QFSFileEngine
operator|::
name|homePath
parameter_list|()
block|{
return|return
name|QFileSystemEngine
operator|::
name|homePath
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|rootPath
name|QString
name|QFSFileEngine
operator|::
name|rootPath
parameter_list|()
block|{
return|return
name|QFileSystemEngine
operator|::
name|rootPath
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|tempPath
name|QString
name|QFSFileEngine
operator|::
name|tempPath
parameter_list|()
block|{
return|return
name|QFileSystemEngine
operator|::
name|tempPath
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|drives
name|QFileInfoList
name|QFSFileEngine
operator|::
name|drives
parameter_list|()
block|{
name|QFileInfoList
name|ret
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
name|quint32
name|driveBits
init|=
operator|(
name|quint32
operator|)
name|GetLogicalDrives
argument_list|()
operator|&
literal|0x3ffffff
decl_stmt|;
endif|#
directive|endif
name|char
name|driveName
index|[]
init|=
literal|"A:/"
decl_stmt|;
while|while
condition|(
name|driveBits
condition|)
block|{
if|if
condition|(
name|driveBits
operator|&
literal|1
condition|)
name|ret
operator|.
name|append
argument_list|(
name|QFileInfo
argument_list|(
name|QLatin1String
argument_list|(
name|driveName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|driveName
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|driveBits
operator|=
name|driveBits
operator|>>
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
else|#
directive|else
name|ret
operator|.
name|append
argument_list|(
name|QFileInfo
argument_list|(
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|doStat
name|bool
name|QFSFileEnginePrivate
operator|::
name|doStat
parameter_list|(
name|QFileSystemMetaData
operator|::
name|MetaDataFlags
name|flags
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|tried_stat
operator|||
operator|!
name|metaData
operator|.
name|hasFlags
argument_list|(
name|flags
argument_list|)
condition|)
block|{
name|tried_stat
operator|=
literal|true
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|int
name|localFd
init|=
name|fd
decl_stmt|;
if|if
condition|(
name|fh
operator|&&
name|fileEntry
operator|.
name|isEmpty
argument_list|()
condition|)
name|localFd
operator|=
name|QT_FILENO
argument_list|(
name|fh
argument_list|)
expr_stmt|;
if|if
condition|(
name|localFd
operator|!=
operator|-
literal|1
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|localFd
argument_list|,
name|metaData
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|metaData
operator|.
name|missingFlags
argument_list|(
name|flags
argument_list|)
operator|&&
operator|!
name|fileEntry
operator|.
name|isEmpty
argument_list|()
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|fileEntry
argument_list|,
name|metaData
argument_list|,
name|metaData
operator|.
name|missingFlags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|metaData
operator|.
name|exists
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|link
name|bool
name|QFSFileEngine
operator|::
name|link
parameter_list|(
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_LIBRARY
argument_list|)
name|bool
name|ret
init|=
literal|false
decl_stmt|;
name|QString
name|linkName
init|=
name|newName
decl_stmt|;
comment|//### assume that they add .lnk
name|IShellLink
modifier|*
name|psl
decl_stmt|;
name|bool
name|neededCoInit
init|=
literal|false
decl_stmt|;
name|HRESULT
name|hres
init|=
name|CoCreateInstance
argument_list|(
name|CLSID_ShellLink
argument_list|,
name|NULL
argument_list|,
name|CLSCTX_INPROC_SERVER
argument_list|,
name|IID_IShellLink
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|psl
argument_list|)
decl_stmt|;
if|if
condition|(
name|hres
operator|==
name|CO_E_NOTINITIALIZED
condition|)
block|{
comment|// COM was not initialized
name|neededCoInit
operator|=
literal|true
expr_stmt|;
name|CoInitialize
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|hres
operator|=
name|CoCreateInstance
argument_list|(
name|CLSID_ShellLink
argument_list|,
name|NULL
argument_list|,
name|CLSCTX_INPROC_SERVER
argument_list|,
name|IID_IShellLink
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|psl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|hres
argument_list|)
condition|)
block|{
name|hres
operator|=
name|psl
operator|->
name|SetPath
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|fileName
argument_list|(
name|AbsoluteName
argument_list|)
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|hres
argument_list|)
condition|)
block|{
name|hres
operator|=
name|psl
operator|->
name|SetWorkingDirectory
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|fileName
argument_list|(
name|AbsolutePathName
argument_list|)
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|hres
argument_list|)
condition|)
block|{
name|IPersistFile
modifier|*
name|ppf
decl_stmt|;
name|hres
operator|=
name|psl
operator|->
name|QueryInterface
argument_list|(
name|IID_IPersistFile
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ppf
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|hres
argument_list|)
condition|)
block|{
name|hres
operator|=
name|ppf
operator|->
name|Save
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|linkName
operator|.
name|utf16
argument_list|()
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|hres
argument_list|)
condition|)
name|ret
operator|=
literal|true
expr_stmt|;
name|ppf
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|psl
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ret
condition|)
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|neededCoInit
condition|)
name|CoUninitialize
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|newName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
endif|#
directive|endif
comment|// QT_NO_LIBRARY
else|#
directive|else
name|QString
name|linkName
init|=
name|newName
decl_stmt|;
name|linkName
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkName
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|".lnk"
argument_list|)
argument_list|)
condition|)
name|linkName
operator|+=
name|QLatin1String
argument_list|(
literal|".lnk"
argument_list|)
expr_stmt|;
name|QString
name|orgName
init|=
name|fileName
argument_list|(
name|AbsoluteName
argument_list|)
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
decl_stmt|;
comment|// Need to append on our own
name|orgName
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
name|orgName
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|ret
init|=
name|SUCCEEDED
argument_list|(
name|SHCreateShortcut
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|linkName
operator|.
name|utf16
argument_list|()
argument_list|,
operator|(
name|wchar_t
operator|*
operator|)
name|orgName
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
endif|#
directive|endif
comment|// Q_OS_WINCE
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|fileFlags
name|QAbstractFileEngine
operator|::
name|FileFlags
name|QFSFileEngine
operator|::
name|fileFlags
parameter_list|(
name|QAbstractFileEngine
operator|::
name|FileFlags
name|type
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|Refresh
condition|)
name|d
operator|->
name|metaData
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QAbstractFileEngine
operator|::
name|FileFlags
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|&
name|FlagsMask
condition|)
name|ret
operator||=
name|LocalDiskFlag
expr_stmt|;
name|bool
name|exists
decl_stmt|;
block|{
name|QFileSystemMetaData
operator|::
name|MetaDataFlags
name|queryFlags
init|=
literal|0
decl_stmt|;
name|queryFlags
operator||=
name|QFileSystemMetaData
operator|::
name|MetaDataFlags
argument_list|(
name|uint
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&
name|QFileSystemMetaData
operator|::
name|Permissions
expr_stmt|;
comment|// AliasType and BundleType are 0x0
if|if
condition|(
name|type
operator|&
name|TypesMask
condition|)
name|queryFlags
operator||=
name|QFileSystemMetaData
operator|::
name|AliasType
operator||
name|QFileSystemMetaData
operator|::
name|LinkType
operator||
name|QFileSystemMetaData
operator|::
name|FileType
operator||
name|QFileSystemMetaData
operator|::
name|DirectoryType
operator||
name|QFileSystemMetaData
operator|::
name|BundleType
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|FlagsMask
condition|)
name|queryFlags
operator||=
name|QFileSystemMetaData
operator|::
name|HiddenAttribute
operator||
name|QFileSystemMetaData
operator|::
name|ExistsAttribute
expr_stmt|;
name|queryFlags
operator||=
name|QFileSystemMetaData
operator|::
name|LinkType
expr_stmt|;
name|exists
operator|=
name|d
operator|->
name|doStat
argument_list|(
name|queryFlags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exists
operator|&&
operator|(
name|type
operator|&
name|PermsMask
operator|)
condition|)
name|ret
operator||=
name|FileFlags
argument_list|(
name|uint
argument_list|(
name|d
operator|->
name|metaData
operator|.
name|permissions
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|TypesMask
condition|)
block|{
if|if
condition|(
operator|(
name|type
operator|&
name|LinkType
operator|)
operator|&&
name|d
operator|->
name|metaData
operator|.
name|isLegacyLink
argument_list|()
condition|)
name|ret
operator||=
name|LinkType
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|metaData
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|ret
operator||=
name|DirectoryType
expr_stmt|;
block|}
else|else
block|{
name|ret
operator||=
name|FileType
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|&
name|FlagsMask
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|metaData
operator|.
name|exists
argument_list|()
condition|)
block|{
name|ret
operator||=
name|ExistsFlag
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEntry
operator|.
name|isRoot
argument_list|()
condition|)
name|ret
operator||=
name|RootFlag
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|metaData
operator|.
name|isHidden
argument_list|()
condition|)
name|ret
operator||=
name|HiddenFlag
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|fileName
name|QString
name|QFSFileEngine
operator|::
name|fileName
parameter_list|(
name|FileName
name|file
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|BaseName
condition|)
block|{
return|return
name|d
operator|->
name|fileEntry
operator|.
name|fileName
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|file
operator|==
name|PathName
condition|)
block|{
return|return
name|d
operator|->
name|fileEntry
operator|.
name|path
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|file
operator|==
name|AbsoluteName
operator|||
name|file
operator|==
name|AbsolutePathName
condition|)
block|{
name|QString
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|isRelativePath
argument_list|()
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|if
condition|(
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|||
comment|// It's a absolute path to the current drive, so \a.txt -> Z:\a.txt
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
operator|||
comment|// It's a drive letter that needs to get a working dir appended
operator|(
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|2
operator|&&
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|)
operator|||
comment|// It's a drive-relative path, so Z:a.txt -> Z:\currentpath\a.txt
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"/../"
argument_list|)
argument_list|)
operator|||
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"/./"
argument_list|)
argument_list|)
operator|||
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"/.."
argument_list|)
argument_list|)
operator|||
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"/."
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|QDir
operator|::
name|fromNativeSeparators
argument_list|(
name|QFileSystemEngine
operator|::
name|nativeAbsoluteFilePath
argument_list|(
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|ret
operator|=
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|QDir
operator|::
name|currentPath
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// The path should be absolute at this point.
comment|// From the docs :
comment|// Absolute paths begin with the directory separator "/"
comment|// (optionally preceded by a drive specification under Windows).
if|if
condition|(
name|ret
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|ret
operator|.
name|length
argument_list|()
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ret
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|isLetter
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|ret
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
expr_stmt|;
comment|// Force uppercase drive letters.
name|ret
index|[
literal|0
index|]
operator|=
name|ret
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toUpper
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|==
name|AbsolutePathName
condition|)
block|{
name|int
name|slash
init|=
name|ret
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|slash
operator|<
literal|0
condition|)
return|return
name|ret
return|;
elseif|else
if|if
condition|(
name|ret
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|&&
name|slash
operator|==
literal|2
condition|)
return|return
name|ret
operator|.
name|left
argument_list|(
literal|3
argument_list|)
return|;
comment|// include the slash
else|else
return|return
name|ret
operator|.
name|left
argument_list|(
name|slash
operator|>
literal|0
condition|?
name|slash
else|:
literal|1
argument_list|)
return|;
block|}
return|return
name|ret
return|;
block|}
elseif|else
if|if
condition|(
name|file
operator|==
name|CanonicalName
operator|||
name|file
operator|==
name|CanonicalPathName
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fileFlags
argument_list|(
name|ExistsFlag
argument_list|)
operator|&
name|ExistsFlag
operator|)
condition|)
return|return
name|QString
argument_list|()
return|;
name|QFileSystemEntry
name|entry
argument_list|(
name|QFileSystemEngine
operator|::
name|canonicalName
argument_list|(
name|QFileSystemEntry
argument_list|(
name|fileName
argument_list|(
name|AbsoluteName
argument_list|)
argument_list|)
argument_list|,
name|d
operator|->
name|metaData
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|CanonicalPathName
condition|)
return|return
name|entry
operator|.
name|path
argument_list|()
return|;
return|return
name|entry
operator|.
name|filePath
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|file
operator|==
name|LinkName
condition|)
block|{
return|return
name|QFileSystemEngine
operator|::
name|getLinkTarget
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|)
operator|.
name|filePath
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|file
operator|==
name|BundleName
condition|)
block|{
return|return
name|QString
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|isRelativePath
name|bool
name|QFSFileEngine
operator|::
name|isRelativePath
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFSFileEngine
argument_list|)
expr_stmt|;
comment|// drive, e.g. "a:", or UNC root, e.q. "//"
return|return
name|d
operator|->
name|fileEntry
operator|.
name|isRelative
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|ownerId
name|uint
name|QFSFileEngine
operator|::
name|ownerId
parameter_list|(
name|FileOwner
comment|/*own*/
parameter_list|)
specifier|const
block|{
specifier|static
specifier|const
name|uint
name|nobodyID
init|=
operator|(
name|uint
operator|)
operator|-
literal|2
decl_stmt|;
return|return
name|nobodyID
return|;
block|}
end_function
begin_function
DECL|function|owner
name|QString
name|QFSFileEngine
operator|::
name|owner
parameter_list|(
name|FileOwner
name|own
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFSFileEngine
argument_list|)
expr_stmt|;
return|return
name|QFileSystemEngine
operator|::
name|owner
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|own
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setPermissions
name|bool
name|QFSFileEngine
operator|::
name|setPermissions
parameter_list|(
name|uint
name|perms
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
name|QSystemError
name|error
decl_stmt|;
name|bool
name|ret
init|=
name|QFileSystemEngine
operator|::
name|setPermissions
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|QFile
operator|::
name|Permissions
argument_list|(
name|perms
argument_list|)
argument_list|,
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|setError
argument_list|(
name|QFile
operator|::
name|PermissionsError
argument_list|,
name|error
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|setSize
name|bool
name|QFSFileEngine
operator|::
name|setSize
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileHandle
operator|!=
name|INVALID_HANDLE_VALUE
operator|||
name|d
operator|->
name|fd
operator|!=
operator|-
literal|1
operator|||
name|d
operator|->
name|fh
condition|)
block|{
comment|// resize open file
name|HANDLE
name|fh
init|=
name|d
operator|->
name|fileHandle
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|if
condition|(
name|fh
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|fh
condition|)
name|fh
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|QT_FILENO
argument_list|(
name|d
operator|->
name|fh
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fh
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|d
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fh
operator|==
name|INVALID_HANDLE_VALUE
condition|)
return|return
literal|false
return|;
name|qint64
name|currentPos
init|=
name|pos
argument_list|()
decl_stmt|;
if|if
condition|(
name|seek
argument_list|(
name|size
argument_list|)
operator|&&
name|SetEndOfFile
argument_list|(
name|fh
argument_list|)
condition|)
block|{
name|seek
argument_list|(
name|qMin
argument_list|(
name|currentPos
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|seek
argument_list|(
name|currentPos
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|fileEntry
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// resize file on disk
name|QFile
name|file
argument_list|(
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadWrite
argument_list|)
condition|)
block|{
name|bool
name|ret
init|=
name|file
operator|.
name|resize
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|setError
argument_list|(
name|QFile
operator|::
name|ResizeError
argument_list|,
name|file
operator|.
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|fileTime
name|QDateTime
name|QFSFileEngine
operator|::
name|fileTime
parameter_list|(
name|FileTime
name|time
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|doStat
argument_list|(
name|QFileSystemMetaData
operator|::
name|Times
argument_list|)
condition|)
return|return
name|d
operator|->
name|metaData
operator|.
name|fileTime
argument_list|(
name|time
argument_list|)
return|;
return|return
name|QDateTime
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|map
name|uchar
modifier|*
name|QFSFileEnginePrivate
operator|::
name|map
parameter_list|(
name|qint64
name|offset
parameter_list|,
name|qint64
name|size
parameter_list|,
name|QFile
operator|::
name|MemoryMapFlags
name|flags
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|openMode
operator|==
name|QFile
operator|::
name|NotOpen
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|PermissionsError
argument_list|,
name|qt_error_string
argument_list|(
name|ERROR_ACCESS_DENIED
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|offset
operator|==
literal|0
operator|&&
name|size
operator|==
literal|0
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|UnspecifiedError
argument_list|,
name|qt_error_string
argument_list|(
name|ERROR_INVALID_PARAMETER
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mapHandle
operator|==
name|NULL
condition|)
block|{
comment|// get handle to the file
name|HANDLE
name|handle
init|=
name|fileHandle
decl_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_WINCE
if|if
condition|(
name|handle
operator|==
name|INVALID_HANDLE_VALUE
operator|&&
name|fh
condition|)
name|handle
operator|=
operator|(
name|HANDLE
operator|)
operator|::
name|_get_osfhandle
argument_list|(
name|QT_FILENO
argument_list|(
name|fh
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_USE_DEPRECATED_MAP_API
name|nativeClose
argument_list|()
expr_stmt|;
comment|// handle automatically closed by kernel with mapHandle (below).
name|handle
operator|=
operator|::
name|CreateFileForMapping
argument_list|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|fileEntry
operator|.
name|nativeFilePath
argument_list|()
operator|.
name|utf16
argument_list|()
argument_list|,
name|GENERIC_READ
operator||
operator|(
name|openMode
operator|&
name|QIODevice
operator|::
name|WriteOnly
condition|?
name|GENERIC_WRITE
else|:
literal|0
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|// Since this is a special case, we check if the return value was NULL and if so
comment|// we change it to INVALID_HANDLE_VALUE to follow the logic inside this function.
if|if
condition|(
literal|0
operator|==
name|handle
condition|)
name|handle
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|handle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|PermissionsError
argument_list|,
name|qt_error_string
argument_list|(
name|ERROR_ACCESS_DENIED
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// first create the file mapping handle
name|DWORD
name|protection
init|=
operator|(
name|openMode
operator|&
name|QIODevice
operator|::
name|WriteOnly
operator|)
condition|?
name|PAGE_READWRITE
else|:
name|PAGE_READONLY
decl_stmt|;
name|mapHandle
operator|=
operator|::
name|CreateFileMapping
argument_list|(
name|handle
argument_list|,
literal|0
argument_list|,
name|protection
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapHandle
operator|==
name|NULL
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|PermissionsError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_USE_DEPRECATED_MAP_API
operator|::
name|CloseHandle
argument_list|(
name|handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
block|}
comment|// setup args to map
name|DWORD
name|access
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|openMode
operator|&
name|QIODevice
operator|::
name|ReadOnly
condition|)
name|access
operator|=
name|FILE_MAP_READ
expr_stmt|;
if|if
condition|(
name|openMode
operator|&
name|QIODevice
operator|::
name|WriteOnly
condition|)
name|access
operator|=
name|FILE_MAP_WRITE
expr_stmt|;
name|DWORD
name|offsetHi
init|=
name|offset
operator|>>
literal|32
decl_stmt|;
name|DWORD
name|offsetLo
init|=
name|offset
operator|&
name|Q_UINT64_C
argument_list|(
literal|0xffffffff
argument_list|)
decl_stmt|;
name|SYSTEM_INFO
name|sysinfo
decl_stmt|;
operator|::
name|GetSystemInfo
argument_list|(
operator|&
name|sysinfo
argument_list|)
expr_stmt|;
name|DWORD
name|mask
init|=
name|sysinfo
operator|.
name|dwAllocationGranularity
operator|-
literal|1
decl_stmt|;
name|DWORD
name|extra
init|=
name|offset
operator|&
name|mask
decl_stmt|;
if|if
condition|(
name|extra
condition|)
name|offsetLo
operator|&=
operator|~
name|mask
expr_stmt|;
comment|// attempt to create the map
name|LPVOID
name|mapAddress
init|=
operator|::
name|MapViewOfFile
argument_list|(
name|mapHandle
argument_list|,
name|access
argument_list|,
name|offsetHi
argument_list|,
name|offsetLo
argument_list|,
name|size
operator|+
name|extra
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapAddress
condition|)
block|{
name|uchar
modifier|*
name|address
init|=
name|extra
operator|+
cast|static_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|mapAddress
argument_list|)
decl_stmt|;
name|maps
index|[
name|address
index|]
operator|=
name|extra
expr_stmt|;
return|return
name|address
return|;
block|}
switch|switch
condition|(
name|GetLastError
argument_list|()
condition|)
block|{
case|case
name|ERROR_ACCESS_DENIED
case|:
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|PermissionsError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERROR_INVALID_PARAMETER
case|:
comment|// size are out of bounds
default|default:
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|UnspecifiedError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|::
name|CloseHandle
argument_list|(
name|mapHandle
argument_list|)
expr_stmt|;
name|mapHandle
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unmap
name|bool
name|QFSFileEnginePrivate
operator|::
name|unmap
parameter_list|(
name|uchar
modifier|*
name|ptr
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|maps
operator|.
name|contains
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|PermissionsError
argument_list|,
name|qt_error_string
argument_list|(
name|ERROR_ACCESS_DENIED
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|uchar
modifier|*
name|start
init|=
name|ptr
operator|-
name|maps
index|[
name|ptr
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|UnmapViewOfFile
argument_list|(
name|start
argument_list|)
condition|)
block|{
name|q
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|PermissionsError
argument_list|,
name|qt_error_string
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|maps
operator|.
name|remove
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|maps
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|::
name|CloseHandle
argument_list|(
name|mapHandle
argument_list|)
expr_stmt|;
name|mapHandle
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
