begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qdir.h"
end_include
begin_include
include|#
directive|include
file|"qdir_p.h"
end_include
begin_include
include|#
directive|include
file|"qabstractfileengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qfsfileengine_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qdiriterator.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qregexp.h"
end_include
begin_include
include|#
directive|include
file|"qvector.h"
end_include
begin_include
include|#
directive|include
file|"qalgorithms.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qfilesystementry_p.h"
end_include
begin_include
include|#
directive|include
file|"qfilesystemmetadata_p.h"
end_include
begin_include
include|#
directive|include
file|"qfilesystemengine_p.h"
end_include
begin_include
include|#
directive|include
file|<qstringbuilder.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QT_BUILD_CORE_LIB
end_ifdef
begin_include
include|#
directive|include
file|"qresource.h"
end_include
begin_include
include|#
directive|include
file|"private/qcoreglobaldata_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
DECL|function|driveSpec
specifier|static
name|QString
name|driveSpec
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
return|return
name|QString
argument_list|()
return|;
name|char
name|c
init|=
name|path
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
argument_list|<
literal|'a'
operator|&&
name|c
argument_list|>
literal|'z'
operator|&&
name|c
argument_list|<
literal|'A'
operator|&&
name|c
argument_list|>
literal|'Z'
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|path
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|!=
literal|':'
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|path
operator|.
name|mid
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//************* QDirPrivate
end_comment
begin_constructor
DECL|function|QDirPrivate
name|QDirPrivate
operator|::
name|QDirPrivate
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|nameFilters_
parameter_list|,
name|QDir
operator|::
name|SortFlags
name|sort_
parameter_list|,
name|QDir
operator|::
name|Filters
name|filters_
parameter_list|)
member_init_list|:
name|QSharedData
argument_list|()
member_init_list|,
name|nameFilters
argument_list|(
name|nameFilters_
argument_list|)
member_init_list|,
name|sort
argument_list|(
name|sort_
argument_list|)
member_init_list|,
name|filters
argument_list|(
name|filters_
argument_list|)
member_init_list|,
name|fileListsInitialized
argument_list|(
literal|false
argument_list|)
block|{
name|setPath
argument_list|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|?
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"."
argument_list|)
else|:
name|path
argument_list|)
expr_stmt|;
name|bool
name|empty
init|=
name|nameFilters
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|empty
condition|)
block|{
name|empty
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nameFilters
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|nameFilters
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|empty
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|empty
condition|)
name|nameFilters
operator|=
name|QStringList
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QDirPrivate
name|QDirPrivate
operator|::
name|QDirPrivate
parameter_list|(
specifier|const
name|QDirPrivate
modifier|&
name|copy
parameter_list|)
member_init_list|:
name|QSharedData
argument_list|(
name|copy
argument_list|)
member_init_list|,
name|nameFilters
argument_list|(
name|copy
operator|.
name|nameFilters
argument_list|)
member_init_list|,
name|sort
argument_list|(
name|copy
operator|.
name|sort
argument_list|)
member_init_list|,
name|filters
argument_list|(
name|copy
operator|.
name|filters
argument_list|)
member_init_list|,
name|fileListsInitialized
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|dirEntry
argument_list|(
name|copy
operator|.
name|dirEntry
argument_list|)
member_init_list|,
name|metaData
argument_list|(
name|copy
operator|.
name|metaData
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|exists
name|bool
name|QDirPrivate
operator|::
name|exists
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|fileEngine
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|dirEntry
argument_list|,
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|ExistsAttribute
operator||
name|QFileSystemMetaData
operator|::
name|DirectoryType
argument_list|)
expr_stmt|;
comment|// always stat
return|return
name|metaData
operator|.
name|exists
argument_list|()
operator|&&
name|metaData
operator|.
name|isDirectory
argument_list|()
return|;
block|}
specifier|const
name|QAbstractFileEngine
operator|::
name|FileFlags
name|info
init|=
name|fileEngine
operator|->
name|fileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|DirectoryType
operator||
name|QAbstractFileEngine
operator|::
name|ExistsFlag
operator||
name|QAbstractFileEngine
operator|::
name|Refresh
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|info
operator|&
name|QAbstractFileEngine
operator|::
name|DirectoryType
operator|)
condition|)
return|return
literal|false
return|;
return|return
name|info
operator|&
name|QAbstractFileEngine
operator|::
name|ExistsFlag
return|;
block|}
end_function
begin_comment
comment|// static
end_comment
begin_function
DECL|function|getFilterSepChar
specifier|inline
name|QChar
name|QDirPrivate
operator|::
name|getFilterSepChar
parameter_list|(
specifier|const
name|QString
modifier|&
name|nameFilter
parameter_list|)
block|{
name|QChar
name|sep
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|nameFilter
operator|.
name|indexOf
argument_list|(
name|sep
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
operator|&&
name|nameFilter
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sep
operator|=
name|QChar
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sep
return|;
block|}
end_function
begin_comment
comment|// static
end_comment
begin_function
DECL|function|splitFilters
specifier|inline
name|QStringList
name|QDirPrivate
operator|::
name|splitFilters
parameter_list|(
specifier|const
name|QString
modifier|&
name|nameFilter
parameter_list|,
name|QChar
name|sep
parameter_list|)
block|{
if|if
condition|(
name|sep
operator|==
literal|0
condition|)
name|sep
operator|=
name|getFilterSepChar
argument_list|(
name|nameFilter
argument_list|)
expr_stmt|;
name|QStringList
name|ret
init|=
name|nameFilter
operator|.
name|split
argument_list|(
name|sep
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ret
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|ret
index|[
name|i
index|]
operator|=
name|ret
index|[
name|i
index|]
operator|.
name|trimmed
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|setPath
specifier|inline
name|void
name|QDirPrivate
operator|::
name|setPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|QString
name|p
init|=
name|QDir
operator|::
name|fromNativeSeparators
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|&&
name|p
operator|.
name|length
argument_list|()
operator|>
literal|1
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|p
operator|.
name|length
argument_list|()
operator|==
literal|3
operator|&&
name|p
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|unicode
argument_list|()
operator|==
literal|':'
operator|&&
name|p
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|isLetter
argument_list|()
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|p
operator|.
name|truncate
argument_list|(
name|p
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|dirEntry
operator|=
name|QFileSystemEntry
argument_list|(
name|p
argument_list|,
name|QFileSystemEntry
operator|::
name|FromInternalPath
argument_list|()
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|clear
argument_list|()
expr_stmt|;
name|initFileEngine
argument_list|()
expr_stmt|;
name|clearFileLists
argument_list|()
expr_stmt|;
name|absoluteDirEntry
operator|=
name|QFileSystemEntry
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clearFileLists
specifier|inline
name|void
name|QDirPrivate
operator|::
name|clearFileLists
parameter_list|()
block|{
name|fileListsInitialized
operator|=
literal|false
expr_stmt|;
name|files
operator|.
name|clear
argument_list|()
expr_stmt|;
name|fileInfos
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resolveAbsoluteEntry
specifier|inline
name|void
name|QDirPrivate
operator|::
name|resolveAbsoluteEntry
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|absoluteDirEntry
operator|.
name|isEmpty
argument_list|()
operator|||
name|dirEntry
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QString
name|absoluteName
decl_stmt|;
if|if
condition|(
name|fileEngine
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|dirEntry
operator|.
name|isRelative
argument_list|()
operator|&&
name|dirEntry
operator|.
name|isClean
argument_list|()
condition|)
block|{
name|absoluteDirEntry
operator|=
name|dirEntry
expr_stmt|;
return|return;
block|}
name|absoluteName
operator|=
name|QFileSystemEngine
operator|::
name|absoluteName
argument_list|(
name|dirEntry
argument_list|)
operator|.
name|filePath
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|absoluteName
operator|=
name|fileEngine
operator|->
name|fileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|AbsoluteName
argument_list|)
expr_stmt|;
block|}
name|absoluteDirEntry
operator|=
name|QFileSystemEntry
argument_list|(
name|QDir
operator|::
name|cleanPath
argument_list|(
name|absoluteName
argument_list|)
argument_list|,
name|QFileSystemEntry
operator|::
name|FromInternalPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* For sorting */
end_comment
begin_struct
DECL|struct|QDirSortItem
struct|struct
name|QDirSortItem
block|{
DECL|member|filename_cache
specifier|mutable
name|QString
name|filename_cache
decl_stmt|;
DECL|member|suffix_cache
specifier|mutable
name|QString
name|suffix_cache
decl_stmt|;
DECL|member|item
name|QFileInfo
name|item
decl_stmt|;
block|}
struct|;
end_struct
begin_class
DECL|class|QDirSortItemComparator
class|class
name|QDirSortItemComparator
block|{
DECL|member|qt_cmp_si_sort_flags
name|int
name|qt_cmp_si_sort_flags
decl_stmt|;
public|public:
DECL|function|QDirSortItemComparator
name|QDirSortItemComparator
parameter_list|(
name|int
name|flags
parameter_list|)
member_init_list|:
name|qt_cmp_si_sort_flags
argument_list|(
name|flags
argument_list|)
block|{}
name|bool
name|operator
name|()
parameter_list|(
specifier|const
name|QDirSortItem
modifier|&
parameter_list|,
specifier|const
name|QDirSortItem
modifier|&
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_function
DECL|function|operator ()
name|bool
name|QDirSortItemComparator
operator|::
name|operator
name|()
parameter_list|(
specifier|const
name|QDirSortItem
modifier|&
name|n1
parameter_list|,
specifier|const
name|QDirSortItem
modifier|&
name|n2
parameter_list|)
block|{
specifier|const
name|QDirSortItem
modifier|*
name|f1
init|=
operator|&
name|n1
decl_stmt|;
specifier|const
name|QDirSortItem
modifier|*
name|f2
init|=
operator|&
name|n2
decl_stmt|;
if|if
condition|(
operator|(
name|qt_cmp_si_sort_flags
operator|&
name|QDir
operator|::
name|DirsFirst
operator|)
operator|&&
operator|(
name|f1
operator|->
name|item
operator|.
name|isDir
argument_list|()
operator|!=
name|f2
operator|->
name|item
operator|.
name|isDir
argument_list|()
operator|)
condition|)
return|return
name|f1
operator|->
name|item
operator|.
name|isDir
argument_list|()
return|;
if|if
condition|(
operator|(
name|qt_cmp_si_sort_flags
operator|&
name|QDir
operator|::
name|DirsLast
operator|)
operator|&&
operator|(
name|f1
operator|->
name|item
operator|.
name|isDir
argument_list|()
operator|!=
name|f2
operator|->
name|item
operator|.
name|isDir
argument_list|()
operator|)
condition|)
return|return
operator|!
name|f1
operator|->
name|item
operator|.
name|isDir
argument_list|()
return|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|int
name|sortBy
init|=
operator|(
name|qt_cmp_si_sort_flags
operator|&
name|QDir
operator|::
name|SortByMask
operator|)
operator||
operator|(
name|qt_cmp_si_sort_flags
operator|&
name|QDir
operator|::
name|Type
operator|)
decl_stmt|;
switch|switch
condition|(
name|sortBy
condition|)
block|{
case|case
name|QDir
operator|::
name|Time
case|:
block|{
name|QDateTime
name|firstModified
init|=
name|f1
operator|->
name|item
operator|.
name|lastModified
argument_list|()
decl_stmt|;
name|QDateTime
name|secondModified
init|=
name|f2
operator|->
name|item
operator|.
name|lastModified
argument_list|()
decl_stmt|;
comment|// QDateTime by default will do all sorts of conversions on these to
comment|// find timezones, which is incredibly expensive. As we aren't
comment|// presenting these to the user, we don't care (at all) about the
comment|// local timezone, so force them to UTC to avoid that conversion.
name|firstModified
operator|.
name|setTimeSpec
argument_list|(
name|Qt
operator|::
name|UTC
argument_list|)
expr_stmt|;
name|secondModified
operator|.
name|setTimeSpec
argument_list|(
name|Qt
operator|::
name|UTC
argument_list|)
expr_stmt|;
name|r
operator|=
name|firstModified
operator|.
name|secsTo
argument_list|(
name|secondModified
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QDir
operator|::
name|Size
case|:
name|r
operator|=
name|int
argument_list|(
name|qBound
argument_list|<
name|qint64
argument_list|>
argument_list|(
operator|-
literal|1
argument_list|,
name|f2
operator|->
name|item
operator|.
name|size
argument_list|()
operator|-
name|f1
operator|->
name|item
operator|.
name|size
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDir
operator|::
name|Type
case|:
block|{
name|bool
name|ic
init|=
name|qt_cmp_si_sort_flags
operator|&
name|QDir
operator|::
name|IgnoreCase
decl_stmt|;
if|if
condition|(
name|f1
operator|->
name|suffix_cache
operator|.
name|isNull
argument_list|()
condition|)
name|f1
operator|->
name|suffix_cache
operator|=
name|ic
condition|?
name|f1
operator|->
name|item
operator|.
name|suffix
argument_list|()
operator|.
name|toLower
argument_list|()
else|:
name|f1
operator|->
name|item
operator|.
name|suffix
argument_list|()
expr_stmt|;
if|if
condition|(
name|f2
operator|->
name|suffix_cache
operator|.
name|isNull
argument_list|()
condition|)
name|f2
operator|->
name|suffix_cache
operator|=
name|ic
condition|?
name|f2
operator|->
name|item
operator|.
name|suffix
argument_list|()
operator|.
name|toLower
argument_list|()
else|:
name|f2
operator|->
name|item
operator|.
name|suffix
argument_list|()
expr_stmt|;
name|r
operator|=
name|qt_cmp_si_sort_flags
operator|&
name|QDir
operator|::
name|LocaleAware
condition|?
name|f1
operator|->
name|suffix_cache
operator|.
name|localeAwareCompare
argument_list|(
name|f2
operator|->
name|suffix_cache
argument_list|)
else|:
name|f1
operator|->
name|suffix_cache
operator|.
name|compare
argument_list|(
name|f2
operator|->
name|suffix_cache
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|sortBy
operator|!=
name|QDir
operator|::
name|Unsorted
condition|)
block|{
comment|// Still not sorted - sort by name
name|bool
name|ic
init|=
name|qt_cmp_si_sort_flags
operator|&
name|QDir
operator|::
name|IgnoreCase
decl_stmt|;
if|if
condition|(
name|f1
operator|->
name|filename_cache
operator|.
name|isNull
argument_list|()
condition|)
name|f1
operator|->
name|filename_cache
operator|=
name|ic
condition|?
name|f1
operator|->
name|item
operator|.
name|fileName
argument_list|()
operator|.
name|toLower
argument_list|()
else|:
name|f1
operator|->
name|item
operator|.
name|fileName
argument_list|()
expr_stmt|;
if|if
condition|(
name|f2
operator|->
name|filename_cache
operator|.
name|isNull
argument_list|()
condition|)
name|f2
operator|->
name|filename_cache
operator|=
name|ic
condition|?
name|f2
operator|->
name|item
operator|.
name|fileName
argument_list|()
operator|.
name|toLower
argument_list|()
else|:
name|f2
operator|->
name|item
operator|.
name|fileName
argument_list|()
expr_stmt|;
name|r
operator|=
name|qt_cmp_si_sort_flags
operator|&
name|QDir
operator|::
name|LocaleAware
condition|?
name|f1
operator|->
name|filename_cache
operator|.
name|localeAwareCompare
argument_list|(
name|f2
operator|->
name|filename_cache
argument_list|)
else|:
name|f1
operator|->
name|filename_cache
operator|.
name|compare
argument_list|(
name|f2
operator|->
name|filename_cache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
comment|// Enforce an order - the order the items appear in the array
name|r
operator|=
operator|(
operator|&
name|n1
operator|)
operator|-
operator|(
operator|&
name|n2
operator|)
expr_stmt|;
if|if
condition|(
name|qt_cmp_si_sort_flags
operator|&
name|QDir
operator|::
name|Reversed
condition|)
return|return
name|r
operator|>
literal|0
return|;
return|return
name|r
operator|<
literal|0
return|;
block|}
end_function
begin_function
DECL|function|sortFileList
specifier|inline
name|void
name|QDirPrivate
operator|::
name|sortFileList
parameter_list|(
name|QDir
operator|::
name|SortFlags
name|sort
parameter_list|,
name|QFileInfoList
modifier|&
name|l
parameter_list|,
name|QStringList
modifier|*
name|names
parameter_list|,
name|QFileInfoList
modifier|*
name|infos
parameter_list|)
block|{
comment|// names and infos are always empty lists or 0 here
name|int
name|n
init|=
name|l
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|1
operator|||
operator|(
name|sort
operator|&
name|QDir
operator|::
name|SortByMask
operator|)
operator|==
name|QDir
operator|::
name|Unsorted
condition|)
block|{
if|if
condition|(
name|infos
condition|)
operator|*
name|infos
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|names
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|names
operator|->
name|append
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|QScopedArrayPointer
argument_list|<
name|QDirSortItem
argument_list|>
name|si
argument_list|(
operator|new
name|QDirSortItem
index|[
name|n
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|si
index|[
name|i
index|]
operator|.
name|item
operator|=
name|l
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|qSort
argument_list|(
name|si
operator|.
name|data
argument_list|()
argument_list|,
name|si
operator|.
name|data
argument_list|()
operator|+
name|n
argument_list|,
name|QDirSortItemComparator
argument_list|(
name|sort
argument_list|)
argument_list|)
expr_stmt|;
comment|// put them back in the list(s)
if|if
condition|(
name|infos
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|infos
operator|->
name|append
argument_list|(
name|si
index|[
name|i
index|]
operator|.
name|item
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|names
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|names
operator|->
name|append
argument_list|(
name|si
index|[
name|i
index|]
operator|.
name|item
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|initFileLists
specifier|inline
name|void
name|QDirPrivate
operator|::
name|initFileLists
parameter_list|(
specifier|const
name|QDir
modifier|&
name|dir
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|fileListsInitialized
condition|)
block|{
name|QFileInfoList
name|l
decl_stmt|;
name|QDirIterator
name|it
argument_list|(
name|dir
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|l
operator|.
name|append
argument_list|(
name|it
operator|.
name|fileInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sortFileList
argument_list|(
name|sort
argument_list|,
name|l
argument_list|,
operator|&
name|files
argument_list|,
operator|&
name|fileInfos
argument_list|)
expr_stmt|;
name|fileListsInitialized
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|initFileEngine
specifier|inline
name|void
name|QDirPrivate
operator|::
name|initFileEngine
parameter_list|()
block|{
name|fileEngine
operator|.
name|reset
argument_list|(
name|QFileSystemEngine
operator|::
name|resolveEntryAndCreateLegacyEngine
argument_list|(
name|dirEntry
argument_list|,
name|metaData
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QDir     \inmodule QtCore     \brief The QDir class provides access to directory structures and their contents.      \ingroup io     \ingroup shared     \reentrant       A QDir is used to manipulate path names, access information     regarding paths and files, and manipulate the underlying file     system. It can also be used to access Qt's \l{resource system}.      Qt uses "/" as a universal directory separator in the same way     that "/" is used as a path separator in URLs. If you always use     "/" as a directory separator, Qt will translate your paths to     conform to the underlying operating system.      A QDir can point to a file using either a relative or an absolute     path. Absolute paths begin with the directory separator     (optionally preceded by a drive specification under Windows).     Relative file names begin with a directory name or a file name and     specify a path relative to the current directory.      Examples of absolute paths:      \snippet code/src_corelib_io_qdir.cpp 0      On Windows, the second example above will be translated to     \c{C:\Documents and Settings} when used to access files.      Examples of relative paths:      \snippet code/src_corelib_io_qdir.cpp 1      You can use the isRelative() or isAbsolute() functions to check if     a QDir is using a relative or an absolute file path. Call     makeAbsolute() to convert a relative QDir to an absolute one.      \section1 Navigation and Directory Operations      A directory's path can be obtained with the path() function, and     a new path set with the setPath() function. The absolute path to     a directory is found by calling absolutePath().      The name of a directory is found using the dirName() function. This     typically returns the last element in the absolute path that specifies     the location of the directory. However, it can also return "." if     the QDir represents the current directory.      \snippet code/src_corelib_io_qdir.cpp 2      The path for a directory can also be changed with the cd() and cdUp()     functions, both of which operate like familiar shell commands.     When cd() is called with the name of an existing directory, the QDir     object changes directory so that it represents that directory instead.     The cdUp() function changes the directory of the QDir object so that     it refers to its parent directory; i.e. cd("..") is equivalent to     cdUp().      Directories can be created with mkdir(), renamed with rename(), and     removed with rmdir().      You can test for the presence of a directory with a given name by     using exists(), and the properties of a directory can be tested with     isReadable(), isAbsolute(), isRelative(), and isRoot().      The refresh() function re-reads the directory's data from disk.      \section1 Files and Directory Contents      Directories contain a number of entries, representing files,     directories, and symbolic links. The number of entries in a     directory is returned by count().     A string list of the names of all the entries in a directory can be     obtained with entryList(). If you need information about each     entry, use entryInfoList() to obtain a list of QFileInfo objects.      Paths to files and directories within a directory can be     constructed using filePath() and absoluteFilePath().     The filePath() function returns a path to the specified file     or directory relative to the path of the QDir object;     absoluteFilePath() returns an absolute path to the specified     file or directory. Neither of these functions checks for the     existence of files or directory; they only construct paths.      \snippet code/src_corelib_io_qdir.cpp 3      Files can be removed by using the remove() function. Directories     cannot be removed in the same way as files; use rmdir() to remove     them instead.      It is possible to reduce the number of entries returned by     entryList() and entryInfoList() by applying filters to a QDir object.     You can apply a name filter to specify a pattern with wildcards that     file names need to match, an attribute filter that selects properties     of entries and can distinguish between files and directories, and a     sort order.      Name filters are lists of strings that are passed to setNameFilters().     Attribute filters consist of a bitwise OR combination of Filters, and     these are specified when calling setFilter().     The sort order is specified using setSorting() with a bitwise OR     combination of SortFlags.      You can test to see if a filename matches a filter using the match()     function.      Filter and sort order flags may also be specified when calling     entryList() and entryInfoList() in order to override previously defined     behavior.      \section1 The Current Directory and Other Special Paths      Access to some common directories is provided with a number of static     functions that return QDir objects. There are also corresponding functions     for these that return strings:      \table     \header \li QDir      \li QString         \li Return Value     \row    \li current() \li currentPath()   \li The application's working directory     \row    \li home()    \li homePath()      \li The user's home directory     \row    \li root()    \li rootPath()      \li The root directory     \row    \li temp()    \li tempPath()      \li The system's temporary directory     \endtable      The setCurrent() static function can also be used to set the application's     working directory.      If you want to find the directory containing the application's executable,     see \l{QCoreApplication::applicationDirPath()}.      The drives() static function provides a list of root directories for each     device that contains a filing system. On Unix systems this returns a list     containing a single root directory "/"; on Windows the list will usually     contain \c{C:/}, and possibly other drive letters such as \c{D:/}, depending     on the configuration of the user's system.      \section1 Path Manipulation and Strings      Paths containing "." elements that reference the current directory at that     point in the path, ".." elements that reference the parent directory, and     symbolic links can be reduced to a canonical form using the canonicalPath()     function.      Paths can also be simplified by using cleanPath() to remove redundant "/"     and ".." elements.      It is sometimes necessary to be able to show a path in the native     representation for the user's platform. The static toNativeSeparators()     function returns a copy of the specified path in which each directory     separator is replaced by the appropriate separator for the underlying     operating system.      \section1 Examples      Check if a directory exists:      \snippet code/src_corelib_io_qdir.cpp 4      (We could also use the static convenience function     QFile::exists().)      Traversing directories and reading a file:      \snippet code/src_corelib_io_qdir.cpp 5      A program that lists all the files in the current directory     (excluding symbolic links), sorted by size, smallest first:      \snippet qdir-listfiles/main.cpp 0      \sa QFileInfo, QFile, QFileDialog, QCoreApplication::applicationDirPath(), {Find Files Example} */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QDir
name|QDir
operator|::
name|QDir
parameter_list|(
name|QDirPrivate
modifier|&
name|p
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|&
name|p
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QDir pointing to the given directory \a path. If path     is empty the program's working directory, ("."), is used.      \sa currentPath() */
end_comment
begin_constructor
DECL|function|QDir
name|QDir
operator|::
name|QDir
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QDirPrivate
argument_list|(
name|path
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QDir with path \a path, that filters its entries by     name using \a nameFilter and by attributes using \a filters. It     also sorts the names using \a sort.      The default \a nameFilter is an empty string, which excludes     nothing; the default \a filters is \l AllEntries, which also means     exclude nothing. The default \a sort is \l Name | \l IgnoreCase,     i.e. sort by name case-insensitively.      If \a path is an empty string, QDir uses "." (the current     directory). If \a nameFilter is an empty string, QDir uses the     name filter "*" (all files).      Note that \a path need not exist.      \sa exists(), setPath(), setNameFilters(), setFilter(), setSorting() */
end_comment
begin_constructor
DECL|function|QDir
name|QDir
operator|::
name|QDir
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|nameFilter
parameter_list|,
name|SortFlags
name|sort
parameter_list|,
name|Filters
name|filters
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QDirPrivate
argument_list|(
name|path
argument_list|,
name|QDir
operator|::
name|nameFiltersFromString
argument_list|(
name|nameFilter
argument_list|)
argument_list|,
name|sort
argument_list|,
name|filters
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QDir object that is a copy of the QDir object for     directory \a dir.      \sa operator=() */
end_comment
begin_constructor
DECL|function|QDir
name|QDir
operator|::
name|QDir
parameter_list|(
specifier|const
name|QDir
modifier|&
name|dir
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
name|dir
operator|.
name|d_ptr
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QDir object frees up its resources. This has no     effect on the underlying directory in the file system. */
end_comment
begin_destructor
DECL|function|~QDir
name|QDir
operator|::
name|~
name|QDir
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Sets the path of the directory to \a path. The path is cleaned of     redundant ".", ".." and of multiple separators. No check is made     to see whether a directory with this path actually exists; but you     can check for yourself using exists().      The path can be either absolute or relative. Absolute paths begin     with the directory separator "/" (optionally preceded by a drive     specification under Windows). Relative file names begin with a     directory name or a file name and specify a path relative to the     current directory. An example of an absolute path is the string     "/tmp/quartz", a relative path might look like "src/fatlib".      \sa path(), absolutePath(), exists(), cleanPath(), dirName(),       absoluteFilePath(), isRelative(), makeAbsolute() */
end_comment
begin_function
DECL|function|setPath
name|void
name|QDir
operator|::
name|setPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|d_ptr
operator|->
name|setPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the path. This may contain symbolic links, but never     contains redundant ".", ".." or multiple separators.      The returned path can be either absolute or relative (see     setPath()).      \sa setPath(), absolutePath(), exists(), cleanPath(), dirName(),     absoluteFilePath(), toNativeSeparators(), makeAbsolute() */
end_comment
begin_function
DECL|function|path
name|QString
name|QDir
operator|::
name|path
parameter_list|()
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
return|return
name|d
operator|->
name|dirEntry
operator|.
name|filePath
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the absolute path (a path that starts with "/" or with a     drive specification), which may contain symbolic links, but never     contains redundant ".", ".." or multiple separators.      \sa setPath(), canonicalPath(), exists(), cleanPath(),     dirName(), absoluteFilePath() */
end_comment
begin_function
DECL|function|absolutePath
name|QString
name|QDir
operator|::
name|absolutePath
parameter_list|()
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
name|d
operator|->
name|resolveAbsoluteEntry
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|absoluteDirEntry
operator|.
name|filePath
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the canonical path, i.e. a path without symbolic links or     redundant "." or ".." elements.      On systems that do not have symbolic links this function will     always return the same string that absolutePath() returns. If the     canonical path does not exist (normally due to dangling symbolic     links) canonicalPath() returns an empty string.      Example:      \snippet code/src_corelib_io_qdir.cpp 6      \sa path(), absolutePath(), exists(), cleanPath(), dirName(),         absoluteFilePath() */
end_comment
begin_function
DECL|function|canonicalPath
name|QString
name|QDir
operator|::
name|canonicalPath
parameter_list|()
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QFileSystemEntry
name|answer
init|=
name|QFileSystemEngine
operator|::
name|canonicalName
argument_list|(
name|d
operator|->
name|dirEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|)
decl_stmt|;
return|return
name|answer
operator|.
name|filePath
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|fileEngine
operator|->
name|fileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|CanonicalName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the directory; this is \e not the same as the     path, e.g. a directory with the name "mail", might have the path     "/var/spool/mail". If the directory has no name (e.g. it is the     root directory) an empty string is returned.      No check is made to ensure that a directory with this name     actually exists; but see exists().      \sa path(), filePath(), absolutePath(), absoluteFilePath() */
end_comment
begin_function
DECL|function|dirName
name|QString
name|QDir
operator|::
name|dirName
parameter_list|()
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
return|return
name|d
operator|->
name|dirEntry
operator|.
name|fileName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the path name of a file in the directory. Does \e not     check if the file actually exists in the directory; but see     exists(). If the QDir is relative the returned path name will also     be relative. Redundant multiple separators or "." and ".."     directories in \a fileName are not removed (see cleanPath()).      \sa dirName(), absoluteFilePath(), isRelative(), canonicalPath() */
end_comment
begin_function
DECL|function|filePath
name|QString
name|QDir
operator|::
name|filePath
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
name|isAbsolutePath
argument_list|(
name|fileName
argument_list|)
condition|)
return|return
name|QString
argument_list|(
name|fileName
argument_list|)
return|;
name|QString
name|ret
init|=
name|d
operator|->
name|dirEntry
operator|.
name|filePath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|ret
operator|.
name|isEmpty
argument_list|()
operator|&&
name|ret
index|[
operator|(
name|int
operator|)
name|ret
operator|.
name|length
argument_list|()
operator|-
literal|1
index|]
operator|!=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|&&
name|fileName
index|[
literal|0
index|]
operator|!=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
name|ret
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|fileName
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the absolute path name of a file in the directory. Does \e     not check if the file actually exists in the directory; but see     exists(). Redundant multiple separators or "." and ".."     directories in \a fileName are not removed (see cleanPath()).      \sa relativeFilePath(), filePath(), canonicalPath() */
end_comment
begin_function
DECL|function|absoluteFilePath
name|QString
name|QDir
operator|::
name|absoluteFilePath
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
name|isAbsolutePath
argument_list|(
name|fileName
argument_list|)
condition|)
return|return
name|fileName
return|;
name|d
operator|->
name|resolveAbsoluteEntry
argument_list|()
expr_stmt|;
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|d
operator|->
name|absoluteDirEntry
operator|.
name|filePath
argument_list|()
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|absoluteDirEntry
operator|.
name|isRoot
argument_list|()
condition|)
return|return
name|d
operator|->
name|absoluteDirEntry
operator|.
name|filePath
argument_list|()
operator|%
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|%
name|fileName
return|;
return|return
name|d
operator|->
name|absoluteDirEntry
operator|.
name|filePath
argument_list|()
operator|%
name|fileName
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the path to \a fileName relative to the directory.      \snippet code/src_corelib_io_qdir.cpp 7      \sa absoluteFilePath(), filePath(), canonicalPath() */
end_comment
begin_function
DECL|function|relativeFilePath
name|QString
name|QDir
operator|::
name|relativeFilePath
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
specifier|const
block|{
name|QString
name|dir
init|=
name|cleanPath
argument_list|(
name|absolutePath
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|file
init|=
name|cleanPath
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|isRelativePath
argument_list|(
name|file
argument_list|)
operator|||
name|isRelativePath
argument_list|(
name|dir
argument_list|)
condition|)
return|return
name|file
return|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|QString
name|dirDrive
init|=
name|driveSpec
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|QString
name|fileDrive
init|=
name|driveSpec
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|bool
name|fileDriveMissing
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|fileDrive
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fileDrive
operator|=
name|dirDrive
expr_stmt|;
name|fileDriveMissing
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|fileDrive
operator|.
name|toLower
argument_list|()
operator|!=
name|dirDrive
operator|.
name|toLower
argument_list|()
operator|||
operator|(
name|file
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
argument_list|)
operator|&&
operator|!
name|dir
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|file
return|;
name|dir
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|dirDrive
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fileDriveMissing
condition|)
name|file
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|fileDrive
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QString
name|result
decl_stmt|;
name|QStringList
name|dirElts
init|=
name|dir
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
name|QStringList
name|fileElts
init|=
name|file
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|dirElts
operator|.
name|size
argument_list|()
operator|&&
name|i
operator|<
name|fileElts
operator|.
name|size
argument_list|()
operator|&&
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|dirElts
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLower
argument_list|()
operator|==
name|fileElts
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLower
argument_list|()
condition|)
else|#
directive|else
name|dirElts
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|fileElts
operator|.
name|at
argument_list|(
name|i
argument_list|)
block|)
endif|#
directive|endif
function|++
name|i
function|;
end_function
begin_for
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|dirElts
operator|.
name|size
argument_list|()
operator|-
name|i
condition|;
operator|++
name|j
control|)
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"../"
argument_list|)
expr_stmt|;
end_for
begin_for
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|fileElts
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|result
operator|+=
name|fileElts
operator|.
name|at
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|fileElts
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
end_for
begin_return
return|return
name|result
return|;
end_return
begin_comment
unit|}
comment|/*!     \since 4.2      Returns \a pathName with the '/' separators converted to     separators that are appropriate for the underlying operating     system.      On Windows, toNativeSeparators("c:/winnt/system32") returns     "c:\\winnt\\system32".      The returned string may be the same as the argument on some     operating systems, for example on Unix.      \sa fromNativeSeparators(), separator() */
end_comment
begin_macro
unit|QString
DECL|function|toNativeSeparators
name|QDir
end_macro
begin_expr_stmt
DECL|function|toNativeSeparators
operator|::
name|toNativeSeparators
operator|(
specifier|const
name|QString
operator|&
name|pathName
operator|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|int
name|i
operator|=
name|pathName
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
block|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|n
parameter_list|(
name|pathName
parameter_list|)
function_decl|;
name|QChar
modifier|*
specifier|const
name|data
init|=
name|n
operator|.
name|data
argument_list|()
decl_stmt|;
name|data
index|[
name|i
operator|++
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|n
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
name|data
index|[
name|i
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
end_expr_stmt
begin_return
return|return
name|n
return|;
end_return
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_expr_stmt
unit|return
name|pathName
expr_stmt|;
end_expr_stmt
begin_comment
unit|}
comment|/*!     \since 4.2      Returns \a pathName using '/' as file separator. On Windows,     for instance, fromNativeSeparators("\c{c:\\winnt\\system32}") returns     "c:/winnt/system32".      The returned string may be the same as the argument on some     operating systems, for example on Unix.      \sa toNativeSeparators(), separator() */
end_comment
begin_macro
unit|QString
DECL|function|fromNativeSeparators
name|QDir
end_macro
begin_expr_stmt
DECL|function|fromNativeSeparators
operator|::
name|fromNativeSeparators
operator|(
specifier|const
name|QString
operator|&
name|pathName
operator|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|int
name|i
operator|=
name|pathName
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
block|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|n
parameter_list|(
name|pathName
parameter_list|)
function_decl|;
name|QChar
modifier|*
specifier|const
name|data
init|=
name|n
operator|.
name|data
argument_list|()
decl_stmt|;
name|data
index|[
name|i
operator|++
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|n
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
condition|)
name|data
index|[
name|i
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
end_expr_stmt
begin_return
return|return
name|n
return|;
end_return
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_expr_stmt
unit|return
name|pathName
expr_stmt|;
end_expr_stmt
begin_comment
unit|}
comment|/*!     Changes the QDir's directory to \a dirName.      Returns true if the new directory exists and is readable;     otherwise returns false. Note that the logical cd() operation is     not performed if the new directory does not exist.      Calling cd("..") is equivalent to calling cdUp().      \sa cdUp(), isReadable(), exists(), path() */
end_comment
begin_macro
unit|bool
DECL|function|cd
name|QDir
end_macro
begin_expr_stmt
DECL|function|cd
operator|::
name|cd
operator|(
specifier|const
name|QString
operator|&
name|dirName
operator|)
block|{
comment|// Don't detach just yet.
specifier|const
name|QDirPrivate
operator|*
specifier|const
name|d
operator|=
name|d_ptr
operator|.
name|constData
argument_list|()
block|;
if|if
condition|(
name|dirName
operator|.
name|isEmpty
argument_list|()
operator|||
name|dirName
operator|==
name|QLatin1String
argument_list|(
literal|"."
argument_list|)
condition|)
return|return
literal|true
return|;
name|QString
name|newPath
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|isAbsolutePath
argument_list|(
name|dirName
argument_list|)
condition|)
block|{
name|newPath
operator|=
name|cleanPath
argument_list|(
name|dirName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isRoot
argument_list|()
condition|)
name|newPath
operator|=
name|d
operator|->
name|dirEntry
operator|.
name|filePath
argument_list|()
expr_stmt|;
else|else
name|newPath
operator|=
name|d
operator|->
name|dirEntry
operator|.
name|filePath
argument_list|()
operator|%
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|newPath
operator|+=
name|dirName
expr_stmt|;
if|if
condition|(
name|dirName
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|>=
literal|0
operator|||
name|dirName
operator|==
name|QLatin1String
argument_list|(
literal|".."
argument_list|)
operator|||
name|d
operator|->
name|dirEntry
operator|.
name|filePath
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|newPath
operator|=
name|cleanPath
argument_list|(
name|newPath
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
comment|//After cleanPath() if path is "/.." or starts with "/../" it means trying to cd above root.
if|if
condition|(
name|newPath
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"/../"
argument_list|)
argument_list|)
operator|||
name|newPath
operator|==
name|QLatin1String
argument_list|(
literal|"/.."
argument_list|)
condition|)
else|#
directive|else
comment|/*               cleanPath() already took care of replacing '\' with '/'.               We can't use startsWith here because the letter of the drive is unknown.               After cleanPath() if path is "[A-Z]:/.." or starts with "[A-Z]:/../" it means trying to cd above root.              */
if|if
condition|(
name|newPath
operator|.
name|midRef
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
operator|==
name|QLatin1String
argument_list|(
literal|":/.."
argument_list|)
operator|&&
operator|(
name|newPath
operator|.
name|length
argument_list|()
operator|==
literal|5
operator|||
name|newPath
operator|.
name|at
argument_list|(
literal|5
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|)
condition|)
endif|#
directive|endif
return|return
literal|false
return|;
comment|/*               If newPath starts with .., we convert it to absolute to               avoid infinite looping on                    QDir dir(".");                   while (dir.cdUp())                       ;             */
if|if
condition|(
name|newPath
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|".."
argument_list|)
argument_list|)
condition|)
block|{
name|newPath
operator|=
name|QFileInfo
argument_list|(
name|newPath
argument_list|)
operator|.
name|absoluteFilePath
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_if
begin_decl_stmt
name|QScopedPointer
argument_list|<
name|QDirPrivate
argument_list|>
name|dir
argument_list|(
operator|new
name|QDirPrivate
argument_list|(
operator|*
name|d_ptr
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|dir
operator|->
name|setPath
argument_list|(
name|newPath
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
operator|!
name|dir
operator|->
name|exists
argument_list|()
condition|)
return|return
literal|false
return|;
end_if
begin_expr_stmt
name|d_ptr
operator|=
name|dir
operator|.
name|take
argument_list|()
expr_stmt|;
end_expr_stmt
begin_return
return|return
literal|true
return|;
end_return
begin_comment
unit|}
comment|/*!     Changes directory by moving one directory up from the QDir's     current directory.      Returns true if the new directory exists and is readable;     otherwise returns false. Note that the logical cdUp() operation is     not performed if the new directory does not exist.      \sa cd(), isReadable(), exists(), path() */
end_comment
begin_macro
unit|bool
DECL|function|cdUp
name|QDir
end_macro
begin_expr_stmt
DECL|function|cdUp
operator|::
name|cdUp
operator|(
operator|)
block|{
return|return
name|cd
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|".."
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_comment
comment|/*!     Returns the string list set by setNameFilters() */
end_comment
begin_function
DECL|function|nameFilters
name|QStringList
name|QDir
operator|::
name|nameFilters
parameter_list|()
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
return|return
name|d
operator|->
name|nameFilters
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the name filters used by entryList() and entryInfoList() to the     list of filters specified by \a nameFilters.      Each name filter is a wildcard (globbing) filter that understands     \c{*} and \c{?} wildcards. (See \l{QRegExp wildcard matching}.)      For example, the following code sets three name filters on a QDir     to ensure that only files with extensions typically used for C++     source files are listed:      \snippet qdir-namefilters/main.cpp 0      \sa nameFilters(), setFilter() */
end_comment
begin_function
DECL|function|setNameFilters
name|void
name|QDir
operator|::
name|setNameFilters
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|nameFilters
parameter_list|)
block|{
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|data
argument_list|()
decl_stmt|;
name|d
operator|->
name|initFileEngine
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearFileLists
argument_list|()
expr_stmt|;
name|d
operator|->
name|nameFilters
operator|=
name|nameFilters
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use QDir::addSearchPath() with a prefix instead.      Adds \a path to the search paths searched in to find resources     that are not specified with an absolute path. The default search     path is to search only in the root (\c{:/}).      \sa {The Qt Resource System} */
end_comment
begin_function
DECL|function|addResourceSearchPath
name|void
name|QDir
operator|::
name|addResourceSearchPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_BUILD_CORE_LIB
name|QResource
operator|::
name|addSearchPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|path
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_BUILD_CORE_LIB
end_ifdef
begin_comment
comment|/*!     \since 4.3      Sets or replaces Qt's search paths for file names with the prefix \a prefix     to \a searchPaths.      To specify a prefix for a file name, prepend the prefix followed by a single     colon (e.g., "images:undo.png", "xmldocs:books.xml"). \a prefix can only     contain letters or numbers (e.g., it cannot contain a colon, nor a slash).      Qt uses this search path to locate files with a known prefix. The search     path entries are tested in order, starting with the first entry.      \snippet code/src_corelib_io_qdir.cpp 8      File name prefix must be at least 2 characters long to avoid conflicts with     Windows drive letters.      Search paths may contain paths to \l{The Qt Resource System}. */
end_comment
begin_function
DECL|function|setSearchPaths
name|void
name|QDir
operator|::
name|setSearchPaths
parameter_list|(
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|searchPaths
parameter_list|)
block|{
if|if
condition|(
name|prefix
operator|.
name|length
argument_list|()
operator|<
literal|2
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDir::setSearchPaths: Prefix must be longer than 1 character"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|prefix
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|prefix
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isLetterOrNumber
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDir::setSearchPaths: Prefix can only contain letters or numbers"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|QWriteLocker
name|lock
argument_list|(
operator|&
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
operator|->
name|dirSearchPathsLock
argument_list|)
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|QStringList
argument_list|>
modifier|&
name|paths
init|=
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
operator|->
name|dirSearchPaths
decl_stmt|;
if|if
condition|(
name|searchPaths
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|paths
operator|.
name|remove
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|paths
operator|.
name|insert
argument_list|(
name|prefix
argument_list|,
name|searchPaths
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Adds \a path to the search path for \a prefix.      \sa setSearchPaths() */
end_comment
begin_function
DECL|function|addSearchPath
name|void
name|QDir
operator|::
name|addSearchPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QWriteLocker
name|lock
argument_list|(
operator|&
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
operator|->
name|dirSearchPathsLock
argument_list|)
decl_stmt|;
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
operator|->
name|dirSearchPaths
index|[
name|prefix
index|]
operator|+=
name|path
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns the search paths for \a prefix.      \sa setSearchPaths(), addSearchPath() */
end_comment
begin_function
DECL|function|searchPaths
name|QStringList
name|QDir
operator|::
name|searchPaths
parameter_list|(
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|)
block|{
name|QReadLocker
name|lock
argument_list|(
operator|&
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
operator|->
name|dirSearchPathsLock
argument_list|)
decl_stmt|;
return|return
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
operator|->
name|dirSearchPaths
operator|.
name|value
argument_list|(
name|prefix
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BUILD_CORE_LIB
end_comment
begin_comment
comment|/*!     Returns the value set by setFilter() */
end_comment
begin_function
DECL|function|filter
name|QDir
operator|::
name|Filters
name|QDir
operator|::
name|filter
parameter_list|()
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
return|return
name|d
operator|->
name|filters
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QDir::Filter      This enum describes the filtering options available to QDir; e.g.     for entryList() and entryInfoList(). The filter value is specified     by combining values from the following list using the bitwise OR     operator:      \value Dirs    List directories that match the filters.     \value AllDirs  List all directories; i.e. don't apply the filters                     to directory names.     \value Files   List files.     \value Drives  List disk drives (ignored under Unix).     \value NoSymLinks  Do not list symbolic links (ignored by operating                        systems that don't support symbolic links).     \value NoDotAndDotDot Do not list the special entries "." and "..".     \value NoDot       Do not list the special entry ".".     \value NoDotDot    Do not list the special entry "..".     \value AllEntries  List directories, files, drives and symlinks (this does not list                 broken symlinks unless you specify System).     \value Readable    List files for which the application has read                        access. The Readable value needs to be combined                        with Dirs or Files.     \value Writable    List files for which the application has write                        access. The Writable value needs to be combined                        with Dirs or Files.     \value Executable  List files for which the application has                        execute access. The Executable value needs to be                        combined with Dirs or Files.     \value Modified  Only list files that have been modified (ignored                      on Unix).     \value Hidden  List hidden files (on Unix, files starting with a ".").     \value System  List system files (on Unix, FIFOs, sockets and                    device files are included; on Windows, \c {.lnk}                    files are included)     \value CaseSensitive  The filter should be case sensitive.      \omitvalue TypeMask     \omitvalue AccessMask     \omitvalue PermissionMask     \omitvalue NoFilter      Functions that use Filter enum values to filter lists of files     and directories will include symbolic links to files and directories     unless you set the NoSymLinks value.      A default constructed QDir will not filter out files based on     their permissions, so entryList() and entryInfoList() will return     all files that are readable, writable, executable, or any     combination of the three.  This makes the default easy to write,     and at the same time useful.      For example, setting the \c Readable, \c Writable, and \c Files     flags allows all files to be listed for which the application has read     access, write access or both. If the \c Dirs and \c Drives flags are     also included in this combination then all drives, directories, all     files that the application can read, write, or execute, and symlinks     to such files/directories can be listed.      To retrieve the permissons for a directory, use the     entryInfoList() function to get the associated QFileInfo objects     and then use the QFileInfo::permissons() to obtain the permissions     and ownership for each file. */
end_comment
begin_comment
comment|/*!     Sets the filter used by entryList() and entryInfoList() to \a     filters. The filter is used to specify the kind of files that     should be returned by entryList() and entryInfoList(). See     \l{QDir::Filter}.      \sa filter(), setNameFilters() */
end_comment
begin_function
DECL|function|setFilter
name|void
name|QDir
operator|::
name|setFilter
parameter_list|(
name|Filters
name|filters
parameter_list|)
block|{
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|data
argument_list|()
decl_stmt|;
name|d
operator|->
name|initFileEngine
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearFileLists
argument_list|()
expr_stmt|;
name|d
operator|->
name|filters
operator|=
name|filters
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the value set by setSorting()      \sa setSorting(), SortFlag */
end_comment
begin_function
DECL|function|sorting
name|QDir
operator|::
name|SortFlags
name|QDir
operator|::
name|sorting
parameter_list|()
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
return|return
name|d
operator|->
name|sort
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QDir::SortFlag      This enum describes the sort options available to QDir, e.g. for     entryList() and entryInfoList(). The sort value is specified by     OR-ing together values from the following list:      \value Name  Sort by name.     \value Time  Sort by time (modification time).     \value Size  Sort by file size.     \value Type  Sort by file type (extension).     \value Unsorted  Do not sort.     \value NoSort Not sorted by default.      \value DirsFirst  Put the directories first, then the files.     \value DirsLast Put the files first, then the directories.     \value Reversed  Reverse the sort order.     \value IgnoreCase  Sort case-insensitively.     \value LocaleAware Sort items appropriately using the current locale settings.      \omitvalue SortByMask      You can only specify one of the first four.      If you specify both DirsFirst and Reversed, directories are     still put first, but in reverse order; the files will be listed     after the directories, again in reverse order. */
end_comment
begin_comment
comment|/*!     Sets the sort order used by entryList() and entryInfoList().      The \a sort is specified by OR-ing values from the enum     \l{QDir::SortFlag}.      \sa sorting(), SortFlag */
end_comment
begin_function
DECL|function|setSorting
name|void
name|QDir
operator|::
name|setSorting
parameter_list|(
name|SortFlags
name|sort
parameter_list|)
block|{
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|data
argument_list|()
decl_stmt|;
name|d
operator|->
name|initFileEngine
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearFileLists
argument_list|()
expr_stmt|;
name|d
operator|->
name|sort
operator|=
name|sort
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the total number of directories and files in the directory.      Equivalent to entryList().count().      \sa operator[](), entryList() */
end_comment
begin_function
DECL|function|count
name|uint
name|QDir
operator|::
name|count
parameter_list|()
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
name|d
operator|->
name|initFileLists
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|files
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the file name at position \a pos in the list of file     names. Equivalent to entryList().at(index).     \a pos must be a valid index position in the list (i.e., 0<= pos< count()).      \sa count(), entryList() */
end_comment
begin_function
DECL|function|operator []
name|QString
name|QDir
operator|::
name|operator
name|[]
parameter_list|(
name|int
name|pos
parameter_list|)
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
name|d
operator|->
name|initFileLists
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|files
index|[
name|pos
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns a list of the names of all the files and directories in     the directory, ordered according to the name and attribute filters     previously set with setNameFilters() and setFilter(), and sorted according     to the flags set with setSorting().      The attribute filter and sorting specifications can be overridden using the     \a filters and \a sort arguments.      Returns an empty list if the directory is unreadable, does not     exist, or if nothing matches the specification.      \note To list symlinks that point to non existing files, \l System must be      passed to the filter.      \sa entryInfoList(), setNameFilters(), setSorting(), setFilter() */
end_comment
begin_function
DECL|function|entryList
name|QStringList
name|QDir
operator|::
name|entryList
parameter_list|(
name|Filters
name|filters
parameter_list|,
name|SortFlags
name|sort
parameter_list|)
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
return|return
name|entryList
argument_list|(
name|d
operator|->
name|nameFilters
argument_list|,
name|filters
argument_list|,
name|sort
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns a list of QFileInfo objects for all the files and directories in     the directory, ordered according to the name and attribute filters     previously set with setNameFilters() and setFilter(), and sorted according     to the flags set with setSorting().      The attribute filter and sorting specifications can be overridden using the     \a filters and \a sort arguments.      Returns an empty list if the directory is unreadable, does not     exist, or if nothing matches the specification.      \sa entryList(), setNameFilters(), setSorting(), setFilter(), isReadable(), exists() */
end_comment
begin_function
DECL|function|entryInfoList
name|QFileInfoList
name|QDir
operator|::
name|entryInfoList
parameter_list|(
name|Filters
name|filters
parameter_list|,
name|SortFlags
name|sort
parameter_list|)
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
return|return
name|entryInfoList
argument_list|(
name|d
operator|->
name|nameFilters
argument_list|,
name|filters
argument_list|,
name|sort
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of the names of all the files and     directories in the directory, ordered according to the name     and attribute filters previously set with setNameFilters()     and setFilter(), and sorted according to the flags set with     setSorting().      The name filter, file attribute filter, and sorting specification     can be overridden using the \a nameFilters, \a filters, and \a sort     arguments.      Returns an empty list if the directory is unreadable, does not     exist, or if nothing matches the specification.      \sa entryInfoList(), setNameFilters(), setSorting(), setFilter() */
end_comment
begin_function
DECL|function|entryList
name|QStringList
name|QDir
operator|::
name|entryList
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|nameFilters
parameter_list|,
name|Filters
name|filters
parameter_list|,
name|SortFlags
name|sort
parameter_list|)
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
name|filters
operator|==
name|NoFilter
condition|)
name|filters
operator|=
name|d
operator|->
name|filters
expr_stmt|;
if|if
condition|(
name|sort
operator|==
name|NoSort
condition|)
name|sort
operator|=
name|d
operator|->
name|sort
expr_stmt|;
if|if
condition|(
name|filters
operator|==
name|d
operator|->
name|filters
operator|&&
name|sort
operator|==
name|d
operator|->
name|sort
operator|&&
name|nameFilters
operator|==
name|d
operator|->
name|nameFilters
condition|)
block|{
name|d
operator|->
name|initFileLists
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|files
return|;
block|}
name|QFileInfoList
name|l
decl_stmt|;
name|QDirIterator
name|it
argument_list|(
name|d
operator|->
name|dirEntry
operator|.
name|filePath
argument_list|()
argument_list|,
name|nameFilters
argument_list|,
name|filters
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|l
operator|.
name|append
argument_list|(
name|it
operator|.
name|fileInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QStringList
name|ret
decl_stmt|;
name|d
operator|->
name|sortFileList
argument_list|(
name|sort
argument_list|,
name|l
argument_list|,
operator|&
name|ret
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of QFileInfo objects for all the files and     directories in the directory, ordered according to the name     and attribute filters previously set with setNameFilters()     and setFilter(), and sorted according to the flags set with     setSorting().      The name filter, file attribute filter, and sorting specification     can be overridden using the \a nameFilters, \a filters, and \a sort     arguments.      Returns an empty list if the directory is unreadable, does not     exist, or if nothing matches the specification.      \sa entryList(), setNameFilters(), setSorting(), setFilter(), isReadable(), exists() */
end_comment
begin_function
DECL|function|entryInfoList
name|QFileInfoList
name|QDir
operator|::
name|entryInfoList
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|nameFilters
parameter_list|,
name|Filters
name|filters
parameter_list|,
name|SortFlags
name|sort
parameter_list|)
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
name|filters
operator|==
name|NoFilter
condition|)
name|filters
operator|=
name|d
operator|->
name|filters
expr_stmt|;
if|if
condition|(
name|sort
operator|==
name|NoSort
condition|)
name|sort
operator|=
name|d
operator|->
name|sort
expr_stmt|;
if|if
condition|(
name|filters
operator|==
name|d
operator|->
name|filters
operator|&&
name|sort
operator|==
name|d
operator|->
name|sort
operator|&&
name|nameFilters
operator|==
name|d
operator|->
name|nameFilters
condition|)
block|{
name|d
operator|->
name|initFileLists
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fileInfos
return|;
block|}
name|QFileInfoList
name|l
decl_stmt|;
name|QDirIterator
name|it
argument_list|(
name|d
operator|->
name|dirEntry
operator|.
name|filePath
argument_list|()
argument_list|,
name|nameFilters
argument_list|,
name|filters
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|l
operator|.
name|append
argument_list|(
name|it
operator|.
name|fileInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QFileInfoList
name|ret
decl_stmt|;
name|d
operator|->
name|sortFileList
argument_list|(
name|sort
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a sub-directory called \a dirName.      Returns true on success; otherwise returns false.      If the directory already exists when this function is called, it will return false.      \sa rmdir() */
end_comment
begin_function
DECL|function|mkdir
name|bool
name|QDir
operator|::
name|mkdir
parameter_list|(
specifier|const
name|QString
modifier|&
name|dirName
parameter_list|)
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDir::mkdir: Empty or null file name(s)"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QString
name|fn
init|=
name|filePath
argument_list|(
name|dirName
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QFileSystemEngine
operator|::
name|createDirectory
argument_list|(
name|QFileSystemEntry
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
return|return
name|d
operator|->
name|fileEngine
operator|->
name|mkdir
argument_list|(
name|fn
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the directory specified by \a dirName.      The directory must be empty for rmdir() to succeed.      Returns true if successful; otherwise returns false.      \sa mkdir() */
end_comment
begin_function
DECL|function|rmdir
name|bool
name|QDir
operator|::
name|rmdir
parameter_list|(
specifier|const
name|QString
modifier|&
name|dirName
parameter_list|)
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDir::rmdir: Empty or null file name(s)"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QString
name|fn
init|=
name|filePath
argument_list|(
name|dirName
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QFileSystemEngine
operator|::
name|removeDirectory
argument_list|(
name|QFileSystemEntry
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
return|return
name|d
operator|->
name|fileEngine
operator|->
name|rmdir
argument_list|(
name|fn
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates the directory path \a dirPath.      The function will create all parent directories necessary to     create the directory.      Returns true if successful; otherwise returns false.      If the path already exists when this function is called, it will return true.      \sa rmpath() */
end_comment
begin_function
DECL|function|mkpath
name|bool
name|QDir
operator|::
name|mkpath
parameter_list|(
specifier|const
name|QString
modifier|&
name|dirPath
parameter_list|)
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDir::mkpath: Empty or null file name(s)"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QString
name|fn
init|=
name|filePath
argument_list|(
name|dirPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QFileSystemEngine
operator|::
name|createDirectory
argument_list|(
name|QFileSystemEntry
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
return|return
name|d
operator|->
name|fileEngine
operator|->
name|mkdir
argument_list|(
name|fn
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the directory path \a dirPath.      The function will remove all parent directories in \a dirPath,     provided that they are empty. This is the opposite of     mkpath(dirPath).      Returns true if successful; otherwise returns false.      \sa mkpath() */
end_comment
begin_function
DECL|function|rmpath
name|bool
name|QDir
operator|::
name|rmpath
parameter_list|(
specifier|const
name|QString
modifier|&
name|dirPath
parameter_list|)
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDir::rmpath: Empty or null file name(s)"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QString
name|fn
init|=
name|filePath
argument_list|(
name|dirPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QFileSystemEngine
operator|::
name|removeDirectory
argument_list|(
name|QFileSystemEntry
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
return|return
name|d
operator|->
name|fileEngine
operator|->
name|rmdir
argument_list|(
name|fn
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     Removes the directory, including all its contents.      Returns true if successful, otherwise false.      If a file or directory cannot be removed, removeRecursively() keeps going     and attempts to delete as many files and sub-directories as possible,     then returns false.      If the directory was already removed, the method returns true     (expected result already reached).      Note: this function is meant for removing a small application-internal     directory (such as a temporary directory), but not user-visible     directories. For user-visible operations, it is rather recommended     to report errors more precisely to the user, to offer solutions     in case of errors, to show progress during the deletion since it     could take several minutes, etc. */
end_comment
begin_function
DECL|function|removeRecursively
name|bool
name|QDir
operator|::
name|removeRecursively
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|exists
argument_list|()
condition|)
return|return
literal|true
return|;
name|bool
name|success
init|=
literal|true
decl_stmt|;
specifier|const
name|QString
name|dirPath
init|=
name|path
argument_list|()
decl_stmt|;
comment|// not empty -- we must empty it first
name|QDirIterator
name|di
argument_list|(
name|dirPath
argument_list|,
name|QDir
operator|::
name|AllEntries
operator||
name|QDir
operator|::
name|Hidden
operator||
name|QDir
operator|::
name|System
operator||
name|QDir
operator|::
name|NoDotAndDotDot
argument_list|)
decl_stmt|;
while|while
condition|(
name|di
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|di
operator|.
name|next
argument_list|()
expr_stmt|;
specifier|const
name|QFileInfo
modifier|&
name|fi
init|=
name|di
operator|.
name|fileInfo
argument_list|()
decl_stmt|;
name|bool
name|ok
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|isDir
argument_list|()
operator|&&
operator|!
name|fi
operator|.
name|isSymLink
argument_list|()
condition|)
name|ok
operator|=
name|QDir
argument_list|(
name|di
operator|.
name|filePath
argument_list|()
argument_list|)
operator|.
name|removeRecursively
argument_list|()
expr_stmt|;
comment|// recursive
else|else
name|ok
operator|=
name|QFile
operator|::
name|remove
argument_list|(
name|di
operator|.
name|filePath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|success
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|rmdir
argument_list|(
name|absolutePath
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the directory is readable \e and we can open files     by name; otherwise returns false.      \warning A false value from this function is not a guarantee that     files in the directory are not accessible.      \sa QFileInfo::isReadable() */
end_comment
begin_function
DECL|function|isReadable
name|bool
name|QDir
operator|::
name|isReadable
parameter_list|()
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|UserReadPermission
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|dirEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|UserReadPermission
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|metaData
operator|.
name|permissions
argument_list|()
operator|&
name|QFile
operator|::
name|ReadUser
operator|)
operator|!=
literal|0
return|;
block|}
specifier|const
name|QAbstractFileEngine
operator|::
name|FileFlags
name|info
init|=
name|d
operator|->
name|fileEngine
operator|->
name|fileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|DirectoryType
operator||
name|QAbstractFileEngine
operator|::
name|PermsMask
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|info
operator|&
name|QAbstractFileEngine
operator|::
name|DirectoryType
operator|)
condition|)
return|return
literal|false
return|;
return|return
name|info
operator|&
name|QAbstractFileEngine
operator|::
name|ReadUserPerm
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns true if the directory exists; otherwise returns false.     (If a file with the same name is found this function will return false).      The overload of this function that accepts an argument is used to test     for the presence of files and directories within a directory.      \sa QFileInfo::exists(), QFile::exists() */
end_comment
begin_function
DECL|function|exists
name|bool
name|QDir
operator|::
name|exists
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|exists
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the directory is the root directory; otherwise     returns false.      Note: If the directory is a symbolic link to the root directory     this function returns false. If you want to test for this use     canonicalPath(), e.g.      \snippet code/src_corelib_io_qdir.cpp 9      \sa root(), rootPath() */
end_comment
begin_function
DECL|function|isRoot
name|bool
name|QDir
operator|::
name|isRoot
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|fileEngine
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|d_ptr
operator|->
name|dirEntry
operator|.
name|isRoot
argument_list|()
return|;
return|return
name|d_ptr
operator|->
name|fileEngine
operator|->
name|fileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|FlagsMask
argument_list|)
operator|&
name|QAbstractFileEngine
operator|::
name|RootFlag
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QDir::isAbsolute() const      Returns true if the directory's path is absolute; otherwise     returns false. See isAbsolutePath().      \sa isRelative(), makeAbsolute(), cleanPath() */
end_comment
begin_comment
comment|/*!    \fn bool QDir::isAbsolutePath(const QString&)      Returns true if \a path is absolute; returns false if it is     relative.      \sa isAbsolute(), isRelativePath(), makeAbsolute(), cleanPath() */
end_comment
begin_comment
comment|/*!     Returns true if the directory path is relative; otherwise returns     false. (Under Unix a path is relative if it does not start with a     "/").      \sa makeAbsolute(), isAbsolute(), isAbsolutePath(), cleanPath() */
end_comment
begin_function
DECL|function|isRelative
name|bool
name|QDir
operator|::
name|isRelative
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|fileEngine
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|d_ptr
operator|->
name|dirEntry
operator|.
name|isRelative
argument_list|()
return|;
return|return
name|d_ptr
operator|->
name|fileEngine
operator|->
name|isRelativePath
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Converts the directory path to an absolute path. If it is already     absolute nothing happens. Returns true if the conversion     succeeded; otherwise returns false.      \sa isAbsolute(), isAbsolutePath(), isRelative(), cleanPath() */
end_comment
begin_function
DECL|function|makeAbsolute
name|bool
name|QDir
operator|::
name|makeAbsolute
parameter_list|()
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
name|QScopedPointer
argument_list|<
name|QDirPrivate
argument_list|>
name|dir
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|fileEngine
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QString
name|absolutePath
init|=
name|d
operator|->
name|fileEngine
operator|->
name|fileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|AbsoluteName
argument_list|)
decl_stmt|;
if|if
condition|(
name|QDir
operator|::
name|isRelativePath
argument_list|(
name|absolutePath
argument_list|)
condition|)
return|return
literal|false
return|;
name|dir
operator|.
name|reset
argument_list|(
operator|new
name|QDirPrivate
argument_list|(
operator|*
name|d_ptr
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|setPath
argument_list|(
name|absolutePath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// native FS
name|d
operator|->
name|resolveAbsoluteEntry
argument_list|()
expr_stmt|;
name|dir
operator|.
name|reset
argument_list|(
operator|new
name|QDirPrivate
argument_list|(
operator|*
name|d_ptr
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|setPath
argument_list|(
name|d
operator|->
name|absoluteDirEntry
operator|.
name|filePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|d_ptr
operator|=
name|dir
operator|.
name|take
argument_list|()
expr_stmt|;
comment|// actually detach
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if directory \a dir and this directory have the same     path and their sort and filter settings are the same; otherwise     returns false.      Example:      \snippet code/src_corelib_io_qdir.cpp 10 */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QDir
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QDir
modifier|&
name|dir
parameter_list|)
specifier|const
block|{
specifier|const
name|QDirPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|QDirPrivate
modifier|*
name|other
init|=
name|dir
operator|.
name|d_ptr
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|==
name|other
condition|)
return|return
literal|true
return|;
name|Qt
operator|::
name|CaseSensitivity
name|sensitive
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|.
name|isNull
argument_list|()
operator|||
name|other
operator|->
name|fileEngine
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|.
name|data
argument_list|()
operator|!=
name|other
operator|->
name|fileEngine
operator|.
name|data
argument_list|()
condition|)
comment|// one is native, the other is a custom file-engine
return|return
literal|false
return|;
name|sensitive
operator|=
name|QFileSystemEngine
operator|::
name|isCaseSensitive
argument_list|()
condition|?
name|Qt
operator|::
name|CaseSensitive
else|:
name|Qt
operator|::
name|CaseInsensitive
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|->
name|caseSensitive
argument_list|()
operator|!=
name|other
operator|->
name|fileEngine
operator|->
name|caseSensitive
argument_list|()
condition|)
return|return
literal|false
return|;
name|sensitive
operator|=
name|d
operator|->
name|fileEngine
operator|->
name|caseSensitive
argument_list|()
condition|?
name|Qt
operator|::
name|CaseSensitive
else|:
name|Qt
operator|::
name|CaseInsensitive
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|filters
operator|==
name|other
operator|->
name|filters
operator|&&
name|d
operator|->
name|sort
operator|==
name|other
operator|->
name|sort
operator|&&
name|d
operator|->
name|nameFilters
operator|==
name|other
operator|->
name|nameFilters
condition|)
block|{
comment|// Assume directories are the same if path is the same
if|if
condition|(
name|d
operator|->
name|dirEntry
operator|.
name|filePath
argument_list|()
operator|==
name|other
operator|->
name|dirEntry
operator|.
name|filePath
argument_list|()
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|dir
operator|.
name|exists
argument_list|()
condition|)
return|return
literal|false
return|;
comment|//can't be equal if only one exists
comment|// Both exist, fallback to expensive canonical path computation
return|return
name|canonicalPath
argument_list|()
operator|.
name|compare
argument_list|(
name|dir
operator|.
name|canonicalPath
argument_list|()
argument_list|,
name|sensitive
argument_list|)
operator|==
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|dir
operator|.
name|exists
argument_list|()
condition|)
return|return
literal|false
return|;
comment|//can't be equal if only one exists
comment|// Neither exists, compare absolute paths rather than canonical (which would be empty strings)
name|d
operator|->
name|resolveAbsoluteEntry
argument_list|()
expr_stmt|;
name|other
operator|->
name|resolveAbsoluteEntry
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|absoluteDirEntry
operator|.
name|filePath
argument_list|()
operator|.
name|compare
argument_list|(
name|other
operator|->
name|absoluteDirEntry
operator|.
name|filePath
argument_list|()
argument_list|,
name|sensitive
argument_list|)
operator|==
literal|0
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Makes a copy of the \a dir object and assigns it to this QDir     object. */
end_comment
begin_function
DECL|function|operator =
name|QDir
modifier|&
name|QDir
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDir
modifier|&
name|dir
parameter_list|)
block|{
name|d_ptr
operator|=
name|dir
operator|.
name|d_ptr
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \obsolete      Sets the directory path to the given \a path.      Use setPath() instead. */
end_comment
begin_function
DECL|function|operator =
name|QDir
modifier|&
name|QDir
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|d_ptr
operator|->
name|setPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QDir::swap(QDir&other)     \since 5.0      Swaps this QDir instance with \a other. This function is very fast     and never fails. */
end_comment
begin_comment
comment|/*!     \fn bool QDir::operator!=(const QDir&dir) const      Returns true if directory \a dir and this directory have different     paths or different sort or filter settings; otherwise returns     false.      Example:      \snippet code/src_corelib_io_qdir.cpp 11 */
end_comment
begin_comment
comment|/*!     Removes the file, \a fileName.      Returns true if the file is removed successfully; otherwise     returns false. */
end_comment
begin_function
DECL|function|remove
name|bool
name|QDir
operator|::
name|remove
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDir::remove: Empty or null file name"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|QFile
operator|::
name|remove
argument_list|(
name|filePath
argument_list|(
name|fileName
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Renames a file or directory from \a oldName to \a newName, and returns     true if successful; otherwise returns false.      On most file systems, rename() fails only if \a oldName does not     exist, or if a file with the new name already exists.     However, there are also other reasons why rename() can     fail. For example, on at least one file system rename() fails if     \a newName points to an open file.      If \a oldName is a file (not a directory) that can't be renamed     right away, Qt will try to copy \a oldName to \a newName and remove     \a oldName.      \sa QFile::rename() */
end_comment
begin_function
DECL|function|rename
name|bool
name|QDir
operator|::
name|rename
parameter_list|(
specifier|const
name|QString
modifier|&
name|oldName
parameter_list|,
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
if|if
condition|(
name|oldName
operator|.
name|isEmpty
argument_list|()
operator|||
name|newName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDir::rename: Empty or null file name(s)"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QFile
name|file
argument_list|(
name|filePath
argument_list|(
name|oldName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|file
operator|.
name|rename
argument_list|(
name|filePath
argument_list|(
name|newName
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the file called \a name exists; otherwise returns     false.      Unless \a name contains an absolute file path, the file name is assumed     to be relative to the directory itself, so this function is typically used     to check for the presence of files within a directory.      \sa QFileInfo::exists(), QFile::exists() */
end_comment
begin_function
DECL|function|exists
name|bool
name|QDir
operator|::
name|exists
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDir::exists: Empty or null file name"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|QFile
operator|::
name|exists
argument_list|(
name|filePath
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of the root directories on this system.      On Windows this returns a list of QFileInfo objects containing "C:/",     "D:/", etc. On other operating systems, it returns a list containing     just one root directory (i.e. "/").      \sa root(), rootPath() */
end_comment
begin_function
DECL|function|drives
name|QFileInfoList
name|QDir
operator|::
name|drives
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_NO_FSFILEENGINE
return|return
name|QFileInfoList
argument_list|()
return|;
else|#
directive|else
return|return
name|QFSFileEngine
operator|::
name|drives
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Returns the native directory separator: "/" under Unix (including     Mac OS X) and "\\" under Windows.      You do not need to use this function to build file paths. If you     always use "/", Qt will translate your paths to conform to the     underlying operating system. If you want to display paths to the     user using their operating system's separator use     toNativeSeparators(). */
end_comment
begin_function
DECL|function|separator
name|QChar
name|QDir
operator|::
name|separator
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
return|return
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
return|;
else|#
directive|else
return|return
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Sets the application's current working directory to \a path.     Returns true if the directory was successfully changed; otherwise     returns false.      \sa current(), currentPath(), home(), root(), temp() */
end_comment
begin_function
DECL|function|setCurrent
name|bool
name|QDir
operator|::
name|setCurrent
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
return|return
name|QFileSystemEngine
operator|::
name|setCurrentPath
argument_list|(
name|QFileSystemEntry
argument_list|(
name|path
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDir QDir::current()      Returns the application's current directory.      The directory is constructed using the absolute path of the current directory,     ensuring that its path() will be the same as its absolutePath().      \sa currentPath(), setCurrent(), home(), root(), temp() */
end_comment
begin_comment
comment|/*!     Returns the absolute path of the application's current directory.      \sa current(), setCurrent(), homePath(), rootPath(), tempPath() */
end_comment
begin_function
DECL|function|currentPath
name|QString
name|QDir
operator|::
name|currentPath
parameter_list|()
block|{
return|return
name|QFileSystemEngine
operator|::
name|currentPath
argument_list|()
operator|.
name|filePath
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDir QDir::home()      Returns the user's home directory.      The directory is constructed using the absolute path of the home directory,     ensuring that its path() will be the same as its absolutePath().      See homePath() for details.      \sa drives(), current(), root(), temp() */
end_comment
begin_comment
comment|/*!     Returns the absolute path of the user's home directory.      Under Windows this function will return the directory of the     current user's profile. Typically, this is:      \snippet code/src_corelib_io_qdir.cpp 12      Use the toNativeSeparators() function to convert the separators to     the ones that are appropriate for the underlying operating system.      If the directory of the current user's profile does not exist or     cannot be retrieved, the following alternatives will be checked (in     the given order) until an existing and available path is found:      \list 1     \li The path specified by the \c USERPROFILE environment variable.     \li The path formed by concatenating the \c HOMEDRIVE and \c HOMEPATH     environment variables.     \li The path specified by the \c HOME environment variable.     \li The path returned by the rootPath() function (which uses the \c SystemDrive     environment variable)     \li  The \c{C:/} directory.     \endlist      Under non-Windows operating systems the \c HOME environment     variable is used if it exists, otherwise the path returned by the     rootPath().      \sa home(), currentPath(), rootPath(), tempPath() */
end_comment
begin_function
DECL|function|homePath
name|QString
name|QDir
operator|::
name|homePath
parameter_list|()
block|{
return|return
name|QFileSystemEngine
operator|::
name|homePath
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDir QDir::temp()      Returns the system's temporary directory.      The directory is constructed using the absolute path of the temporary directory,     ensuring that its path() will be the same as its absolutePath().      See tempPath() for details.      \sa drives(), current(), home(), root() */
end_comment
begin_comment
comment|/*!     Returns the absolute path of the system's temporary directory.      On Unix/Linux systems this is the path in the \c TMPDIR environment     variable or \c{/tmp} if \c TMPDIR is not defined. On Windows this is     usually the path in the \c TEMP or \c TMP environment     variable. Whether a directory separator is added to the end or     not, depends on the operating system.      \sa temp(), currentPath(), homePath(), rootPath() */
end_comment
begin_function
DECL|function|tempPath
name|QString
name|QDir
operator|::
name|tempPath
parameter_list|()
block|{
return|return
name|QFileSystemEngine
operator|::
name|tempPath
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDir QDir::root()      Returns the root directory.      The directory is constructed using the absolute path of the root directory,     ensuring that its path() will be the same as its absolutePath().      See rootPath() for details.      \sa drives(), current(), home(), temp() */
end_comment
begin_comment
comment|/*!     Returns the absolute path of the root directory.      For Unix operating systems this returns "/". For Windows file     systems this normally returns "c:/".      \sa root(), drives(), currentPath(), homePath(), tempPath() */
end_comment
begin_function
DECL|function|rootPath
name|QString
name|QDir
operator|::
name|rootPath
parameter_list|()
block|{
return|return
name|QFileSystemEngine
operator|::
name|rootPath
argument_list|()
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_comment
comment|/*!     \overload      Returns true if the \a fileName matches any of the wildcard (glob)     patterns in the list of \a filters; otherwise returns false. The     matching is case insensitive.      \sa {QRegExp wildcard matching}, QRegExp::exactMatch(), entryList(), entryInfoList() */
end_comment
begin_function
DECL|function|match
name|bool
name|QDir
operator|::
name|match
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|filters
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
for|for
control|(
name|QStringList
operator|::
name|ConstIterator
name|sit
init|=
name|filters
operator|.
name|constBegin
argument_list|()
init|;
name|sit
operator|!=
name|filters
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|sit
control|)
block|{
name|QRegExp
name|rx
argument_list|(
operator|*
name|sit
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|,
name|QRegExp
operator|::
name|Wildcard
argument_list|)
decl_stmt|;
if|if
condition|(
name|rx
operator|.
name|exactMatch
argument_list|(
name|fileName
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the \a fileName matches the wildcard (glob)     pattern \a filter; otherwise returns false. The \a filter may     contain multiple patterns separated by spaces or semicolons.     The matching is case insensitive.      \sa {QRegExp wildcard matching}, QRegExp::exactMatch(), entryList(), entryInfoList() */
end_comment
begin_function
DECL|function|match
name|bool
name|QDir
operator|::
name|match
parameter_list|(
specifier|const
name|QString
modifier|&
name|filter
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
return|return
name|match
argument_list|(
name|nameFiltersFromString
argument_list|(
name|filter
argument_list|)
argument_list|,
name|fileName
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_REGEXP
end_comment
begin_comment
comment|/*!     Returns \a path with directory separators normalized (converted to "/") and     redundant ones removed, and "."s and ".."s resolved (as far as possible).      Symbolic links are kept. This function does not return the     canonical path, but rather the simplest version of the input.     For example, "./local" becomes "local", "local/../bin" becomes     "bin" and "/local/usr/../bin" becomes "/local/bin".      \sa absolutePath(), canonicalPath() */
end_comment
begin_function
DECL|function|cleanPath
name|QString
name|QDir
operator|::
name|cleanPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|path
return|;
name|QString
name|name
init|=
name|path
decl_stmt|;
name|QChar
name|dir_separator
init|=
name|separator
argument_list|()
decl_stmt|;
if|if
condition|(
name|dir_separator
operator|!=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
name|name
operator|.
name|replace
argument_list|(
name|dir_separator
argument_list|,
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|,
name|levels
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|len
init|=
name|name
operator|.
name|length
argument_list|()
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|QChar
argument_list|>
name|outVector
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|QChar
modifier|*
name|out
init|=
name|outVector
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|p
init|=
name|name
operator|.
name|unicode
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|last
init|=
operator|-
literal|1
init|,
name|iwrite
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
while|while
condition|(
name|i
operator|+
literal|1
operator|<
name|len
operator|&&
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
comment|//allow unc paths
if|if
condition|(
operator|!
name|i
condition|)
break|break;
endif|#
directive|endif
name|i
operator|++
expr_stmt|;
block|}
name|bool
name|eaten
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|len
operator|&&
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
condition|)
block|{
name|int
name|dotcount
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|2
operator|<
name|len
operator|&&
name|p
index|[
name|i
operator|+
literal|2
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
condition|)
name|dotcount
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|len
operator|-
name|dotcount
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|dotcount
operator|==
literal|1
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|levels
condition|)
block|{
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i2
init|=
name|iwrite
operator|-
literal|1
init|;
name|i2
operator|>=
literal|0
condition|;
name|i2
operator|--
control|)
block|{
if|if
condition|(
name|out
index|[
name|i2
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
name|last
operator|=
name|i2
expr_stmt|;
break|break;
block|}
block|}
block|}
name|used
operator|-=
name|iwrite
operator|-
name|last
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|p
index|[
name|i
operator|+
name|dotcount
operator|+
literal|1
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
if|if
condition|(
name|dotcount
operator|==
literal|2
operator|&&
name|levels
condition|)
block|{
if|if
condition|(
name|last
operator|==
operator|-
literal|1
operator|||
name|iwrite
operator|-
name|last
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i2
init|=
operator|(
name|last
operator|==
operator|-
literal|1
operator|)
condition|?
operator|(
name|iwrite
operator|-
literal|1
operator|)
else|:
operator|(
name|last
operator|-
literal|1
operator|)
init|;
name|i2
operator|>=
literal|0
condition|;
name|i2
operator|--
control|)
block|{
if|if
condition|(
name|out
index|[
name|i2
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
name|eaten
operator|=
literal|true
expr_stmt|;
name|last
operator|=
name|i2
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|eaten
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|eaten
condition|)
block|{
name|levels
operator|--
expr_stmt|;
name|used
operator|-=
name|iwrite
operator|-
name|last
expr_stmt|;
name|iwrite
operator|=
name|last
expr_stmt|;
name|last
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dotcount
operator|==
literal|2
operator|&&
name|i
operator|>
literal|0
operator|&&
name|p
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
condition|)
block|{
name|eaten
operator|=
literal|true
expr_stmt|;
name|used
operator|-=
name|iwrite
operator|-
name|qMax
argument_list|(
literal|0
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|iwrite
operator|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|last
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dotcount
operator|==
literal|1
condition|)
block|{
name|eaten
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|eaten
condition|)
name|i
operator|+=
name|dotcount
expr_stmt|;
block|}
else|else
block|{
name|levels
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|last
operator|!=
operator|-
literal|1
operator|&&
name|iwrite
operator|-
name|last
operator|==
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|eaten
operator|=
operator|(
name|iwrite
operator|>
literal|2
operator|)
expr_stmt|;
else|#
directive|else
name|eaten
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
name|last
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last
operator|!=
operator|-
literal|1
operator|&&
name|i
operator|==
name|len
operator|-
literal|1
condition|)
block|{
name|eaten
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|levels
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|eaten
condition|)
name|last
operator|=
name|i
operator|-
operator|(
name|i
operator|-
name|iwrite
operator|)
expr_stmt|;
else|else
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|i
operator|&&
name|p
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
condition|)
block|{
name|int
name|dotcount
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|len
operator|>=
literal|1
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
condition|)
name|dotcount
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|dotcount
operator|&&
name|p
index|[
name|dotcount
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
if|if
condition|(
name|dotcount
operator|==
literal|1
condition|)
block|{
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|+
literal|1
operator|<
name|len
operator|-
literal|1
operator|&&
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|out
index|[
name|iwrite
operator|++
index|]
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
name|used
operator|++
expr_stmt|;
block|}
name|QString
name|ret
init|=
operator|(
name|used
operator|==
name|len
condition|?
name|name
else|:
name|QString
argument_list|(
name|out
argument_list|,
name|used
argument_list|)
operator|)
decl_stmt|;
comment|// Strip away last slash except for root directories
if|if
condition|(
name|ret
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|ret
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
if|if
condition|(
operator|!
operator|(
name|ret
operator|.
name|length
argument_list|()
operator|==
literal|3
operator|&&
name|ret
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|)
condition|)
endif|#
directive|endif
name|ret
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if \a path is relative; returns false if it is     absolute.      \sa isRelative(), isAbsolutePath(), makeAbsolute() */
end_comment
begin_function
DECL|function|isRelativePath
name|bool
name|QDir
operator|::
name|isRelativePath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
return|return
name|QFileInfo
argument_list|(
name|path
argument_list|)
operator|.
name|isRelative
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Refreshes the directory information. */
end_comment
begin_function
DECL|function|refresh
name|void
name|QDir
operator|::
name|refresh
parameter_list|()
specifier|const
block|{
name|QDirPrivate
modifier|*
name|d
init|=
cast|const_cast
argument_list|<
name|QDir
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
decl_stmt|;
name|d
operator|->
name|metaData
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|initFileEngine
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearFileLists
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|d_func
name|QDirPrivate
modifier|*
name|QDir
operator|::
name|d_func
parameter_list|()
block|{
return|return
name|d_ptr
operator|.
name|data
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns a list of name filters from the given \a nameFilter. (If     there is more than one filter, each pair of filters is separated     by a space or by a semicolon.) */
end_comment
begin_function
DECL|function|nameFiltersFromString
name|QStringList
name|QDir
operator|::
name|nameFiltersFromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|nameFilter
parameter_list|)
block|{
return|return
name|QDirPrivate
operator|::
name|splitFilters
argument_list|(
name|nameFilter
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \macro void Q_INIT_RESOURCE(name)     \relates QDir      Initializes the resources specified by the \c .qrc file with the     specified base \a name. Normally, Qt resources are loaded     automatically at startup. The Q_INIT_RESOURCE() macro is     necessary on some platforms for resources stored in a static     library.      For example, if your application's resources are listed in a file     called \c myapp.qrc, you can ensure that the resources are     initialized at startup by adding this line to your \c main()     function:      \snippet code/src_corelib_io_qdir.cpp 13      If the file name contains characters that cannot be part of a valid C++ function name     (such as '-'), they have to be replaced by the underscore character ('_').      Note: This macro cannot be used in a namespace. It should be called from     main(). If that is not possible, the following workaround can be used     to init the resource \c myapp from the function \c{MyNamespace::myFunction}:      \snippet code/src_corelib_io_qdir.cpp 14      \sa Q_CLEANUP_RESOURCE(), {The Qt Resource System} */
end_comment
begin_comment
comment|/*!     \since 4.1     \macro void Q_CLEANUP_RESOURCE(name)     \relates QDir      Unloads the resources specified by the \c .qrc file with the base     name \a name.      Normally, Qt resources are unloaded automatically when the     application terminates, but if the resources are located in a     plugin that is being unloaded, call Q_CLEANUP_RESOURCE() to force     removal of your resources.      Note: This macro cannot be used in a namespace. Please see the     Q_INIT_RESOURCE documentation for a workaround.      Example:      \snippet code/src_corelib_io_qdir.cpp 15      \sa Q_INIT_RESOURCE(), {The Qt Resource System} */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
name|QDir
operator|::
name|Filters
name|filters
parameter_list|)
block|{
name|QStringList
name|flags
decl_stmt|;
if|if
condition|(
name|filters
operator|==
name|QDir
operator|::
name|NoFilter
condition|)
block|{
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"NoFilter"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|filters
operator|&
name|QDir
operator|::
name|Dirs
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"Dirs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filters
operator|&
name|QDir
operator|::
name|AllDirs
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"AllDirs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filters
operator|&
name|QDir
operator|::
name|Files
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"Files"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filters
operator|&
name|QDir
operator|::
name|Drives
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"Drives"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filters
operator|&
name|QDir
operator|::
name|NoSymLinks
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"NoSymLinks"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filters
operator|&
name|QDir
operator|::
name|NoDot
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"NoDot"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filters
operator|&
name|QDir
operator|::
name|NoDotDot
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"NoDotDot"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|filters
operator|&
name|QDir
operator|::
name|AllEntries
operator|)
operator|==
name|QDir
operator|::
name|AllEntries
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"AllEntries"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filters
operator|&
name|QDir
operator|::
name|Readable
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"Readable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filters
operator|&
name|QDir
operator|::
name|Writable
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"Writable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filters
operator|&
name|QDir
operator|::
name|Executable
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"Executable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filters
operator|&
name|QDir
operator|::
name|Modified
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"Modified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filters
operator|&
name|QDir
operator|::
name|Hidden
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"Hidden"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filters
operator|&
name|QDir
operator|::
name|System
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"System"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filters
operator|&
name|QDir
operator|::
name|CaseSensitive
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"CaseSensitive"
argument_list|)
expr_stmt|;
block|}
name|debug
operator|<<
literal|"QDir::Filters("
operator|<<
name|qPrintable
argument_list|(
name|flags
operator|.
name|join
argument_list|(
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
argument_list|)
argument_list|)
operator|<<
literal|')'
expr_stmt|;
return|return
name|debug
return|;
block|}
end_function
begin_function
DECL|function|operator <<
specifier|static
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
name|QDir
operator|::
name|SortFlags
name|sorting
parameter_list|)
block|{
if|if
condition|(
name|sorting
operator|==
name|QDir
operator|::
name|NoSort
condition|)
block|{
name|debug
operator|<<
literal|"QDir::SortFlags(NoSort)"
expr_stmt|;
block|}
else|else
block|{
name|QString
name|type
decl_stmt|;
if|if
condition|(
operator|(
name|sorting
operator|&
literal|3
operator|)
operator|==
name|QDir
operator|::
name|Name
condition|)
name|type
operator|=
name|QLatin1String
argument_list|(
literal|"Name"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sorting
operator|&
literal|3
operator|)
operator|==
name|QDir
operator|::
name|Time
condition|)
name|type
operator|=
name|QLatin1String
argument_list|(
literal|"Time"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sorting
operator|&
literal|3
operator|)
operator|==
name|QDir
operator|::
name|Size
condition|)
name|type
operator|=
name|QLatin1String
argument_list|(
literal|"Size"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sorting
operator|&
literal|3
operator|)
operator|==
name|QDir
operator|::
name|Unsorted
condition|)
name|type
operator|=
name|QLatin1String
argument_list|(
literal|"Unsorted"
argument_list|)
expr_stmt|;
name|QStringList
name|flags
decl_stmt|;
if|if
condition|(
name|sorting
operator|&
name|QDir
operator|::
name|DirsFirst
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"DirsFirst"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorting
operator|&
name|QDir
operator|::
name|DirsLast
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"DirsLast"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorting
operator|&
name|QDir
operator|::
name|IgnoreCase
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"IgnoreCase"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorting
operator|&
name|QDir
operator|::
name|LocaleAware
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"LocaleAware"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorting
operator|&
name|QDir
operator|::
name|Type
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"Type"
argument_list|)
expr_stmt|;
name|debug
operator|<<
literal|"QDir::SortFlags("
operator|<<
name|qPrintable
argument_list|(
name|type
argument_list|)
operator|<<
literal|'|'
operator|<<
name|qPrintable
argument_list|(
name|flags
operator|.
name|join
argument_list|(
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
argument_list|)
argument_list|)
operator|<<
literal|')'
expr_stmt|;
block|}
return|return
name|debug
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
specifier|const
name|QDir
modifier|&
name|dir
parameter_list|)
block|{
name|debug
operator|.
name|maybeSpace
argument_list|()
operator|<<
literal|"QDir("
operator|<<
name|dir
operator|.
name|path
argument_list|()
operator|<<
literal|", nameFilters = {"
operator|<<
name|qPrintable
argument_list|(
name|dir
operator|.
name|nameFilters
argument_list|()
operator|.
name|join
argument_list|(
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
argument_list|)
argument_list|)
operator|<<
literal|"}, "
operator|<<
name|dir
operator|.
name|sorting
argument_list|()
operator|<<
literal|','
operator|<<
name|dir
operator|.
name|filter
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|debug
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DEBUG_STREAM
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
