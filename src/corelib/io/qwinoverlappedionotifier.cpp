begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qwinoverlappedionotifier_p.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qmutex.h>
end_include
begin_include
include|#
directive|include
file|<qpointer.h>
end_include
begin_include
include|#
directive|include
file|<qset.h>
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QWinOverlappedIoNotifier     \inmodule QtCore     \brief The QWinOverlappedIoNotifier class provides support for overlapped I/O notifications on Windows.     \since 5.0     \internal      The QWinOverlappedIoNotifier class makes it possible to use efficient     overlapped (asynchronous) I/O notifications on Windows by using an     I/O completion port.      Once you have obtained a file handle, you can use setHandle() to get     notifications for I/O operations. Whenever an I/O operation completes,     the notified() signal is emitted which will pass the number of transferred     bytes, the operation's error code and a pointer to the operation's     OVERLAPPED object to the receiver.      Every handle that supports overlapped I/O can be used by     QWinOverlappedIoNotifier. That includes file handles, TCP sockets     and named pipes.      Note that you must not use ReadFileEx() and WriteFileEx() together     with QWinOverlappedIoNotifier. They are not supported as they use a     different I/O notification mechanism.      The hEvent member in the OVERLAPPED structure passed to ReadFile()     or WriteFile() is ignored and can be used for other purposes.      \warning This class is only available on Windows. */
end_comment
begin_class
DECL|class|QWinIoCompletionPort
class|class
name|QWinIoCompletionPort
super|:
specifier|protected
name|QThread
block|{
public|public:
DECL|function|QWinIoCompletionPort
name|QWinIoCompletionPort
parameter_list|()
member_init_list|:
name|hPort
argument_list|(
name|INVALID_HANDLE_VALUE
argument_list|)
block|{
name|setObjectName
argument_list|(
name|QLatin1String
argument_list|(
literal|"I/O completion port thread"
argument_list|)
argument_list|)
expr_stmt|;
name|HANDLE
name|hIOCP
init|=
name|CreateIoCompletionPort
argument_list|(
name|INVALID_HANDLE_VALUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hIOCP
condition|)
block|{
name|qErrnoWarning
argument_list|(
literal|"CreateIoCompletionPort failed."
argument_list|)
expr_stmt|;
return|return;
block|}
name|hPort
operator|=
name|hIOCP
expr_stmt|;
block|}
DECL|function|~QWinIoCompletionPort
name|~
name|QWinIoCompletionPort
parameter_list|()
block|{
name|PostQueuedCompletionStatus
argument_list|(
name|hPort
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|QThread
operator|::
name|wait
argument_list|()
expr_stmt|;
name|CloseHandle
argument_list|(
name|hPort
argument_list|)
expr_stmt|;
block|}
DECL|function|registerNotifier
name|void
name|registerNotifier
parameter_list|(
name|QWinOverlappedIoNotifier
modifier|*
name|notifier
parameter_list|)
block|{
name|HANDLE
name|hIOCP
init|=
name|CreateIoCompletionPort
argument_list|(
name|notifier
operator|->
name|hHandle
argument_list|,
name|hPort
argument_list|,
cast|reinterpret_cast
argument_list|<
name|ULONG_PTR
argument_list|>
argument_list|(
name|notifier
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hIOCP
condition|)
block|{
name|qErrnoWarning
argument_list|(
literal|"Can't associate file handle %x with I/O completion port."
argument_list|,
name|notifier
operator|->
name|hHandle
argument_list|)
expr_stmt|;
return|return;
block|}
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|notifiers
operator|+=
name|notifier
expr_stmt|;
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|QThread
operator|::
name|isRunning
argument_list|()
condition|)
name|QThread
operator|::
name|start
argument_list|()
expr_stmt|;
block|}
DECL|function|unregisterNotifier
name|void
name|unregisterNotifier
parameter_list|(
name|QWinOverlappedIoNotifier
modifier|*
name|notifier
parameter_list|)
block|{
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|notifiers
operator|.
name|remove
argument_list|(
name|notifier
argument_list|)
expr_stmt|;
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
protected|protected:
DECL|function|run
name|void
name|run
parameter_list|()
block|{
name|DWORD
name|dwBytesRead
decl_stmt|;
name|ULONG_PTR
name|pulCompletionKey
decl_stmt|;
name|OVERLAPPED
modifier|*
name|overlapped
decl_stmt|;
forever|forever
block|{
name|BOOL
name|success
init|=
name|GetQueuedCompletionStatus
argument_list|(
name|hPort
argument_list|,
operator|&
name|dwBytesRead
argument_list|,
operator|&
name|pulCompletionKey
argument_list|,
operator|&
name|overlapped
argument_list|,
name|INFINITE
argument_list|)
decl_stmt|;
name|DWORD
name|errorCode
init|=
name|success
condition|?
name|ERROR_SUCCESS
else|:
name|GetLastError
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|success
operator|&&
operator|!
name|overlapped
condition|)
block|{
name|qErrnoWarning
argument_list|(
name|errorCode
argument_list|,
literal|"GetQueuedCompletionStatus failed."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|success
operator|&&
operator|!
operator|(
name|dwBytesRead
operator|||
name|pulCompletionKey
operator|||
name|overlapped
operator|)
condition|)
block|{
comment|// We've posted null values via PostQueuedCompletionStatus to end this thread.
return|return;
block|}
name|QWinOverlappedIoNotifier
modifier|*
name|notifier
init|=
cast|reinterpret_cast
argument_list|<
name|QWinOverlappedIoNotifier
operator|*
argument_list|>
argument_list|(
name|pulCompletionKey
argument_list|)
decl_stmt|;
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|notifiers
operator|.
name|contains
argument_list|(
name|notifier
argument_list|)
condition|)
name|notifier
operator|->
name|notify
argument_list|(
name|dwBytesRead
argument_list|,
name|errorCode
argument_list|,
name|overlapped
argument_list|)
expr_stmt|;
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
private|private:
DECL|member|hPort
name|HANDLE
name|hPort
decl_stmt|;
DECL|member|notifiers
name|QSet
argument_list|<
name|QWinOverlappedIoNotifier
modifier|*
argument_list|>
name|notifiers
decl_stmt|;
DECL|member|mutex
name|QMutex
name|mutex
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|member|iocp
name|QWinIoCompletionPort
modifier|*
name|QWinOverlappedIoNotifier
operator|::
name|iocp
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|iocpInstanceLock
name|HANDLE
name|QWinOverlappedIoNotifier
operator|::
name|iocpInstanceLock
init|=
name|CreateMutex
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|iocpInstanceRefCount
name|unsigned
name|int
name|QWinOverlappedIoNotifier
operator|::
name|iocpInstanceRefCount
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QWinOverlappedIoNotifier
name|QWinOverlappedIoNotifier
operator|::
name|QWinOverlappedIoNotifier
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|hHandle
argument_list|(
name|INVALID_HANDLE_VALUE
argument_list|)
block|{
name|WaitForSingleObject
argument_list|(
name|iocpInstanceLock
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iocp
condition|)
name|iocp
operator|=
operator|new
name|QWinIoCompletionPort
expr_stmt|;
name|iocpInstanceRefCount
operator|++
expr_stmt|;
name|ReleaseMutex
argument_list|(
name|iocpInstanceLock
argument_list|)
expr_stmt|;
name|hSemaphore
operator|=
name|CreateSemaphore
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hResultsMutex
operator|=
name|CreateMutex
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
operator|&
name|QWinOverlappedIoNotifier
operator|::
name|_q_notify
argument_list|,
name|this
argument_list|,
operator|&
name|QWinOverlappedIoNotifier
operator|::
name|_q_notified
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QWinOverlappedIoNotifier
name|QWinOverlappedIoNotifier
operator|::
name|~
name|QWinOverlappedIoNotifier
parameter_list|()
block|{
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|hResultsMutex
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|hSemaphore
argument_list|)
expr_stmt|;
name|WaitForSingleObject
argument_list|(
name|iocpInstanceLock
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|iocpInstanceRefCount
condition|)
block|{
operator|delete
name|iocp
expr_stmt|;
name|iocp
operator|=
literal|0
expr_stmt|;
block|}
name|ReleaseMutex
argument_list|(
name|iocpInstanceLock
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|setHandle
name|void
name|QWinOverlappedIoNotifier
operator|::
name|setHandle
parameter_list|(
name|HANDLE
name|h
parameter_list|)
block|{
name|hHandle
operator|=
name|h
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setEnabled
name|void
name|QWinOverlappedIoNotifier
operator|::
name|setEnabled
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|enabled
condition|)
name|iocp
operator|->
name|registerNotifier
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|else
name|iocp
operator|->
name|unregisterNotifier
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  * Wait synchronously for the notified signal.  *  * The function returns true if the notified signal was emitted for  * the I/O operation that corresponds to the OVERLAPPED object.  */
end_comment
begin_function
DECL|function|waitForNotified
name|bool
name|QWinOverlappedIoNotifier
operator|::
name|waitForNotified
parameter_list|(
name|int
name|msecs
parameter_list|,
name|OVERLAPPED
modifier|*
name|overlapped
parameter_list|)
block|{
forever|forever
block|{
name|DWORD
name|result
init|=
name|WaitForSingleObject
argument_list|(
name|hSemaphore
argument_list|,
name|msecs
operator|==
operator|-
literal|1
condition|?
name|INFINITE
else|:
name|DWORD
argument_list|(
name|msecs
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|WAIT_OBJECT_0
condition|)
block|{
name|ReleaseSemaphore
argument_list|(
name|hSemaphore
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|_q_notified
argument_list|()
operator|==
name|overlapped
condition|)
return|return
literal|true
return|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|WAIT_TIMEOUT
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|qErrnoWarning
argument_list|(
literal|"QWinOverlappedIoNotifier::waitForNotified: WaitForSingleObject failed."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   * Note: This function runs in the I/O completion port thread.   */
end_comment
begin_function
DECL|function|notify
name|void
name|QWinOverlappedIoNotifier
operator|::
name|notify
parameter_list|(
name|DWORD
name|numberOfBytes
parameter_list|,
name|DWORD
name|errorCode
parameter_list|,
name|OVERLAPPED
modifier|*
name|overlapped
parameter_list|)
block|{
name|WaitForSingleObject
argument_list|(
name|hResultsMutex
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
name|results
operator|.
name|enqueue
argument_list|(
name|IOResult
argument_list|(
name|numberOfBytes
argument_list|,
name|errorCode
argument_list|,
name|overlapped
argument_list|)
argument_list|)
expr_stmt|;
name|ReleaseMutex
argument_list|(
name|hResultsMutex
argument_list|)
expr_stmt|;
name|ReleaseSemaphore
argument_list|(
name|hSemaphore
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
emit|emit
name|_q_notify
argument_list|()
emit|;
block|}
end_function
begin_function
DECL|function|_q_notified
name|OVERLAPPED
modifier|*
name|QWinOverlappedIoNotifier
operator|::
name|_q_notified
parameter_list|()
block|{
if|if
condition|(
name|WaitForSingleObject
argument_list|(
name|hSemaphore
argument_list|,
literal|0
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
block|{
name|WaitForSingleObject
argument_list|(
name|hResultsMutex
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
name|IOResult
name|ioresult
init|=
name|results
operator|.
name|dequeue
argument_list|()
decl_stmt|;
name|ReleaseMutex
argument_list|(
name|hResultsMutex
argument_list|)
expr_stmt|;
emit|emit
name|notified
argument_list|(
name|ioresult
operator|.
name|numberOfBytes
argument_list|,
name|ioresult
operator|.
name|errorCode
argument_list|,
name|ioresult
operator|.
name|overlapped
argument_list|)
emit|;
return|return
name|ioresult
operator|.
name|overlapped
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
