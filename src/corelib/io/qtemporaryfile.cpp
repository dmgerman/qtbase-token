begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtemporaryfile.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEMPORARYFILE
end_ifndef
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"private/qtemporaryfile_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qfile_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qsystemerror_p.h"
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_include
include|#
directive|include
file|"private/qcore_unix_p.h"
end_include
begin_comment
comment|// overrides QT_OPEN
end_comment
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_typedef
DECL|typedef|Char
typedef|typedef
name|ushort
name|Char
typedef|;
end_typedef
begin_function
DECL|function|Latin1Char
specifier|static
specifier|inline
name|Char
name|Latin1Char
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
name|ushort
argument_list|(
name|uchar
argument_list|(
name|ch
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_typedef
DECL|typedef|NativeFileHandle
typedef|typedef
name|HANDLE
name|NativeFileHandle
typedef|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_comment
comment|// POSIX
end_comment
begin_typedef
typedef|typedef
name|char
name|Char
typedef|;
end_typedef
begin_typedef
typedef|typedef
name|char
name|Latin1Char
typedef|;
end_typedef
begin_typedef
typedef|typedef
name|int
name|NativeFileHandle
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Copyright (c) 1987, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment
begin_comment
comment|/*!     \internal      Generates a unique file path and returns a native handle to the open file.     \a path is used as a template when generating unique paths, \a pos     identifies the position of the first character that will be replaced in the     template and \a length the number of characters that may be substituted.      Returns an open handle to the newly created file if successful, an invalid     handle otherwise. In both cases, the string in \a path will be changed and     contain the generated path name. */
end_comment
begin_function
DECL|function|createFileFromTemplate
specifier|static
name|bool
name|createFileFromTemplate
parameter_list|(
name|NativeFileHandle
modifier|&
name|file
parameter_list|,
name|QFileSystemEntry
operator|::
name|NativePath
modifier|&
name|path
parameter_list|,
name|size_t
name|pos
parameter_list|,
name|size_t
name|length
parameter_list|,
name|QSystemError
modifier|&
name|error
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|length
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|pos
operator|<
name|size_t
argument_list|(
name|path
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|length
operator|<=
name|size_t
argument_list|(
name|path
operator|.
name|length
argument_list|()
argument_list|)
operator|-
name|pos
argument_list|)
expr_stmt|;
name|Char
modifier|*
specifier|const
name|placeholderStart
init|=
operator|(
name|Char
operator|*
operator|)
name|path
operator|.
name|data
argument_list|()
operator|+
name|pos
decl_stmt|;
name|Char
modifier|*
specifier|const
name|placeholderEnd
init|=
name|placeholderStart
operator|+
name|length
decl_stmt|;
comment|// Initialize placeholder with random chars + PID.
block|{
name|Char
modifier|*
name|rIter
init|=
name|placeholderEnd
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
name|quint64
name|pid
init|=
name|quint64
argument_list|(
name|QCoreApplication
operator|::
name|applicationPid
argument_list|()
argument_list|)
decl_stmt|;
do|do
block|{
operator|*
operator|--
name|rIter
operator|=
name|Latin1Char
argument_list|(
operator|(
name|pid
operator|%
literal|10
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|pid
operator|/=
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|rIter
operator|!=
name|placeholderStart
operator|&&
name|pid
operator|!=
literal|0
condition|)
do|;
endif|#
directive|endif
while|while
condition|(
name|rIter
operator|!=
name|placeholderStart
condition|)
block|{
name|char
name|ch
init|=
name|char
argument_list|(
operator|(
name|qrand
argument_list|()
operator|&
literal|0xffff
operator|)
operator|%
operator|(
literal|26
operator|+
literal|26
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|<
literal|26
condition|)
operator|*
operator|--
name|rIter
operator|=
name|Latin1Char
argument_list|(
name|ch
operator|+
literal|'A'
argument_list|)
expr_stmt|;
else|else
operator|*
operator|--
name|rIter
operator|=
name|Latin1Char
argument_list|(
name|ch
operator|-
literal|26
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// Atomically create file and obtain handle
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|file
operator|=
name|CreateFile
argument_list|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|path
operator|.
name|constData
argument_list|()
argument_list|,
name|GENERIC_READ
operator||
name|GENERIC_WRITE
argument_list|,
name|FILE_SHARE_READ
operator||
name|FILE_SHARE_WRITE
argument_list|,
name|NULL
argument_list|,
name|CREATE_NEW
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
return|return
literal|true
return|;
name|DWORD
name|err
init|=
name|GetLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|ERROR_FILE_EXISTS
condition|)
block|{
name|error
operator|=
name|QSystemError
argument_list|(
name|err
argument_list|,
name|QSystemError
operator|::
name|NativeError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|#
directive|else
comment|// POSIX
name|file
operator|=
name|QT_OPEN
argument_list|(
name|path
operator|.
name|constData
argument_list|()
argument_list|,
name|QT_OPEN_CREAT
operator||
name|O_EXCL
operator||
name|QT_OPEN_RDWR
operator||
name|QT_OPEN_LARGEFILE
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
operator|-
literal|1
condition|)
return|return
literal|true
return|;
name|int
name|err
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|EEXIST
condition|)
block|{
name|error
operator|=
name|QSystemError
argument_list|(
name|err
argument_list|,
name|QSystemError
operator|::
name|NativeError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
endif|#
directive|endif
comment|/* tricky little algorwwithm for backward compatibility */
for|for
control|(
name|Char
modifier|*
name|iter
init|=
name|placeholderStart
init|;
condition|;
control|)
block|{
comment|// Character progression: [0-9] => 'a' ... 'z' => 'A' .. 'Z'
comment|// String progression: "ZZaiC" => "aabiC"
switch|switch
condition|(
name|char
argument_list|(
operator|*
name|iter
argument_list|)
condition|)
block|{
case|case
literal|'Z'
case|:
comment|// Rollover, advance next character
operator|*
name|iter
operator|=
name|Latin1Char
argument_list|(
literal|'a'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|iter
operator|==
name|placeholderEnd
condition|)
block|{
comment|// Out of alternatives. Return file exists error, previously set.
name|error
operator|=
name|QSystemError
argument_list|(
name|err
argument_list|,
name|QSystemError
operator|::
name|NativeError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
continue|continue;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
operator|*
name|iter
operator|=
name|Latin1Char
argument_list|(
literal|'a'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|// increment 'z' to 'A'
operator|*
name|iter
operator|=
name|Latin1Char
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|++
operator|*
name|iter
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//************* QTemporaryFileEngine
end_comment
begin_destructor
DECL|function|~QTemporaryFileEngine
name|QTemporaryFileEngine
operator|::
name|~
name|QTemporaryFileEngine
parameter_list|()
block|{
name|QFSFileEngine
operator|::
name|close
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|isReallyOpen
name|bool
name|QTemporaryFileEngine
operator|::
name|isReallyOpen
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
literal|0
operator|==
name|d
operator|->
name|fh
operator|)
operator|&&
operator|(
operator|-
literal|1
operator|==
name|d
operator|->
name|fd
operator|)
if|#
directive|if
name|defined
name|Q_OS_WIN
operator|&&
operator|(
name|INVALID_HANDLE_VALUE
operator|==
name|d
operator|->
name|fileHandle
operator|)
endif|#
directive|endif
operator|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|setFileName
name|void
name|QTemporaryFileEngine
operator|::
name|setFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|file
parameter_list|)
block|{
comment|// Really close the file, so we don't leak
name|QFSFileEngine
operator|::
name|close
argument_list|()
expr_stmt|;
name|QFSFileEngine
operator|::
name|setFileName
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setFileTemplate
name|void
name|QTemporaryFileEngine
operator|::
name|setFileTemplate
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileTemplate
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|filePathIsTemplate
condition|)
name|d
operator|->
name|fileEntry
operator|=
name|QFileSystemEntry
argument_list|(
name|fileTemplate
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|open
name|bool
name|QTemporaryFileEngine
operator|::
name|open
parameter_list|(
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|isReallyOpen
argument_list|()
argument_list|)
expr_stmt|;
name|openMode
operator||=
name|QIODevice
operator|::
name|ReadWrite
expr_stmt|;
if|if
condition|(
operator|!
name|filePathIsTemplate
condition|)
return|return
name|QFSFileEngine
operator|::
name|open
argument_list|(
name|openMode
argument_list|)
return|;
name|QString
name|qfilename
init|=
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
decl_stmt|;
comment|// Ensure there is a placeholder mask
name|uint
name|phPos
init|=
name|qfilename
operator|.
name|length
argument_list|()
decl_stmt|;
name|uint
name|phLength
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|phPos
operator|!=
literal|0
condition|)
block|{
operator|--
name|phPos
expr_stmt|;
if|if
condition|(
name|qfilename
index|[
name|phPos
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'X'
argument_list|)
condition|)
block|{
operator|++
name|phLength
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|phLength
operator|>=
literal|6
operator|||
name|qfilename
index|[
name|phPos
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
operator|++
name|phPos
expr_stmt|;
break|break;
block|}
comment|// start over
name|phLength
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|phLength
operator|<
literal|6
condition|)
name|qfilename
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|".XXXXXX"
argument_list|)
argument_list|)
expr_stmt|;
comment|// "Nativify" :-)
name|QFileSystemEntry
operator|::
name|NativePath
name|filename
init|=
name|QFileSystemEngine
operator|::
name|absoluteName
argument_list|(
name|QFileSystemEntry
argument_list|(
name|qfilename
argument_list|,
name|QFileSystemEntry
operator|::
name|FromInternalPath
argument_list|()
argument_list|)
argument_list|)
operator|.
name|nativeFilePath
argument_list|()
decl_stmt|;
comment|// Find mask in native path
name|phPos
operator|=
name|filename
operator|.
name|length
argument_list|()
expr_stmt|;
name|phLength
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|phPos
operator|!=
literal|0
condition|)
block|{
operator|--
name|phPos
expr_stmt|;
if|if
condition|(
name|filename
index|[
name|phPos
index|]
operator|==
name|Latin1Char
argument_list|(
literal|'X'
argument_list|)
condition|)
block|{
operator|++
name|phLength
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|phLength
operator|>=
literal|6
condition|)
block|{
operator|++
name|phPos
expr_stmt|;
break|break;
block|}
comment|// start over
name|phLength
operator|=
literal|0
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|phLength
operator|>=
literal|6
argument_list|)
expr_stmt|;
name|QSystemError
name|error
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|NativeFileHandle
modifier|&
name|file
init|=
name|d
operator|->
name|fileHandle
decl_stmt|;
else|#
directive|else
comment|// POSIX
name|NativeFileHandle
modifier|&
name|file
init|=
name|d
operator|->
name|fd
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|createFileFromTemplate
argument_list|(
name|file
argument_list|,
name|filename
argument_list|,
name|phPos
argument_list|,
name|phLength
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|setError
argument_list|(
name|QFile
operator|::
name|OpenError
argument_list|,
name|error
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|fileEntry
operator|=
name|QFileSystemEntry
argument_list|(
name|filename
argument_list|,
name|QFileSystemEntry
operator|::
name|FromNativePath
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|d
operator|->
name|closeFileHandle
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
name|filePathIsTemplate
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|openMode
operator|=
name|openMode
expr_stmt|;
name|d
operator|->
name|lastFlushFailed
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|tried_stat
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|remove
name|bool
name|QTemporaryFileEngine
operator|::
name|remove
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFSFileEngine
argument_list|)
expr_stmt|;
comment|// Since the QTemporaryFileEngine::close() does not really close the file,
comment|// we must explicitly call QFSFileEngine::close() before we remove it.
name|QFSFileEngine
operator|::
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|QFSFileEngine
operator|::
name|remove
argument_list|()
condition|)
block|{
name|d
operator|->
name|fileEntry
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// If a QTemporaryFile is constructed using a template file path, the path
comment|// is generated in QTemporaryFileEngine::open() and then filePathIsTemplate
comment|// is set to false. If remove() and then open() are called on the same
comment|// QTemporaryFile, the path is not regenerated. Here we ensure that if the
comment|// file path was generated, it will be generated again in the scenario above.
name|filePathIsTemplate
operator|=
name|filePathWasTemplate
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|rename
name|bool
name|QTemporaryFileEngine
operator|::
name|rename
parameter_list|(
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
name|QFSFileEngine
operator|::
name|close
argument_list|()
expr_stmt|;
return|return
name|QFSFileEngine
operator|::
name|rename
argument_list|(
name|newName
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|renameOverwrite
name|bool
name|QTemporaryFileEngine
operator|::
name|renameOverwrite
parameter_list|(
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
name|QFSFileEngine
operator|::
name|close
argument_list|()
expr_stmt|;
return|return
name|QFSFileEngine
operator|::
name|renameOverwrite
argument_list|(
name|newName
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|close
name|bool
name|QTemporaryFileEngine
operator|::
name|close
parameter_list|()
block|{
comment|// Don't close the file, just seek to the front.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setError
argument_list|(
name|QFile
operator|::
name|UnspecifiedError
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//************* QTemporaryFilePrivate
end_comment
begin_constructor
DECL|function|QTemporaryFilePrivate
name|QTemporaryFilePrivate
operator|::
name|QTemporaryFilePrivate
parameter_list|()
member_init_list|:
name|autoRemove
argument_list|(
literal|true
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QTemporaryFilePrivate
name|QTemporaryFilePrivate
operator|::
name|~
name|QTemporaryFilePrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|engine
name|QAbstractFileEngine
modifier|*
name|QTemporaryFilePrivate
operator|::
name|engine
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|fileEngine
condition|)
block|{
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
name|fileEngine
operator|=
operator|new
name|QTemporaryFileEngine
argument_list|(
name|templateName
argument_list|)
expr_stmt|;
else|else
name|fileEngine
operator|=
operator|new
name|QTemporaryFileEngine
argument_list|(
name|fileName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|fileEngine
return|;
block|}
end_function
begin_function
DECL|function|defaultTemplateName
name|QString
name|QTemporaryFilePrivate
operator|::
name|defaultTemplateName
parameter_list|()
block|{
name|QString
name|baseName
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
name|baseName
operator|=
name|QCoreApplication
operator|::
name|applicationName
argument_list|()
expr_stmt|;
if|if
condition|(
name|baseName
operator|.
name|isEmpty
argument_list|()
condition|)
endif|#
directive|endif
name|baseName
operator|=
name|QLatin1String
argument_list|(
literal|"qt_temp"
argument_list|)
expr_stmt|;
return|return
name|QDir
operator|::
name|tempPath
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|baseName
operator|+
name|QLatin1String
argument_list|(
literal|".XXXXXX"
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//************* QTemporaryFile
end_comment
begin_comment
comment|/*!     \class QTemporaryFile     \inmodule QtCore     \reentrant     \brief The QTemporaryFile class is an I/O device that operates on temporary files.      \ingroup io       QTemporaryFile is used to create unique temporary files safely.     The file itself is created by calling open(). The name of the     temporary file is guaranteed to be unique (i.e., you are     guaranteed to not overwrite an existing file), and the file will     subsequently be removed upon destruction of the QTemporaryFile     object. This is an important technique that avoids data     corruption for applications that store data in temporary files.     The file name is either auto-generated, or created based on a     template, which is passed to QTemporaryFile's constructor.      Example:      \snippet code/src_corelib_io_qtemporaryfile.cpp 0      Reopening a QTemporaryFile after calling close() is safe. For as long as     the QTemporaryFile object itself is not destroyed, the unique temporary     file will exist and be kept open internally by QTemporaryFile.      The file name of the temporary file can be found by calling fileName().     Note that this is only defined after the file is first opened; the function     returns an empty string before this.      A temporary file will have some static part of the name and some     part that is calculated to be unique. The default filename will be     determined from QCoreApplication::applicationName() (otherwise \c qt_temp) and will     be placed into the temporary path as returned by QDir::tempPath().     If you specify your own filename, a relative file path will not be placed in the     temporary directory by default, but be relative to the current working directory.      Specified filenames can contain the following template \c XXXXXX     (six upper case "X" characters), which will be replaced by the     auto-generated portion of the filename. Note that the template is     case sensitive. If the template is not present in the filename,     QTemporaryFile appends the generated part to the filename given.      \sa QDir::tempPath(), QFile */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
end_ifdef
begin_constructor
DECL|function|QTemporaryFile
name|QTemporaryFile
operator|::
name|QTemporaryFile
parameter_list|()
member_init_list|:
name|QFile
argument_list|(
operator|*
operator|new
name|QTemporaryFilePrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTemporaryFile
argument_list|)
expr_stmt|;
name|d
operator|->
name|templateName
operator|=
name|QTemporaryFilePrivate
operator|::
name|defaultTemplateName
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QTemporaryFile
name|QTemporaryFile
operator|::
name|QTemporaryFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|templateName
parameter_list|)
member_init_list|:
name|QFile
argument_list|(
operator|*
operator|new
name|QTemporaryFilePrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTemporaryFile
argument_list|)
expr_stmt|;
name|d
operator|->
name|templateName
operator|=
name|templateName
expr_stmt|;
block|}
end_constructor
begin_else
else|#
directive|else
end_else
begin_comment
comment|/*!     Constructs a QTemporaryFile using as file template     the application name returned by QCoreApplication::applicationName()     (otherwise \c qt_temp) followed by ".XXXXXX".     The file is stored in the system's temporary directory, QDir::tempPath().      \sa setFileTemplate(), QDir::tempPath() */
end_comment
begin_constructor
DECL|function|QTemporaryFile
name|QTemporaryFile
operator|::
name|QTemporaryFile
parameter_list|()
member_init_list|:
name|QFile
argument_list|(
operator|*
operator|new
name|QTemporaryFilePrivate
argument_list|,
literal|0
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTemporaryFile
argument_list|)
expr_stmt|;
name|d
operator|->
name|templateName
operator|=
name|QTemporaryFilePrivate
operator|::
name|defaultTemplateName
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QTemporaryFile with a template filename of \a     templateName. Upon opening the temporary file this will be used to create     a unique filename.      If the \a templateName does not contain XXXXXX it will automatically be     appended and used as the dynamic portion of the filename.      If \a templateName is a relative path, the path will be relative to the     current working directory. You can use QDir::tempPath() to construct \a     templateName if you want use the system's temporary directory.      \sa open(), fileTemplate() */
end_comment
begin_constructor
DECL|function|QTemporaryFile
name|QTemporaryFile
operator|::
name|QTemporaryFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|templateName
parameter_list|)
member_init_list|:
name|QFile
argument_list|(
operator|*
operator|new
name|QTemporaryFilePrivate
argument_list|,
literal|0
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTemporaryFile
argument_list|)
expr_stmt|;
name|d
operator|->
name|templateName
operator|=
name|templateName
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QTemporaryFile (with the given \a parent)     using as file template the application name returned by QCoreApplication::applicationName()     (otherwise \c qt_temp) followed by ".XXXXXX".     The file is stored in the system's temporary directory, QDir::tempPath().      \sa setFileTemplate() */
end_comment
begin_constructor
DECL|function|QTemporaryFile
name|QTemporaryFile
operator|::
name|QTemporaryFile
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QFile
argument_list|(
operator|*
operator|new
name|QTemporaryFilePrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTemporaryFile
argument_list|)
expr_stmt|;
name|d
operator|->
name|templateName
operator|=
name|QTemporaryFilePrivate
operator|::
name|defaultTemplateName
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QTemporaryFile with a template filename of \a     templateName and the specified \a parent.     Upon opening the temporary file this will be used to     create a unique filename.      If the \a templateName does not contain XXXXXX it will automatically be     appended and used as the dynamic portion of the filename.      If \a templateName is a relative path, the path will be relative to the     current working directory. You can use QDir::tempPath() to construct \a     templateName if you want use the system's temporary directory.      \sa open(), fileTemplate() */
end_comment
begin_constructor
DECL|function|QTemporaryFile
name|QTemporaryFile
operator|::
name|QTemporaryFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|templateName
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QFile
argument_list|(
operator|*
operator|new
name|QTemporaryFilePrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTemporaryFile
argument_list|)
expr_stmt|;
name|d
operator|->
name|templateName
operator|=
name|templateName
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Destroys the temporary file object, the file is automatically     closed if necessary and if in auto remove mode it will     automatically delete the file.      \sa autoRemove() */
end_comment
begin_destructor
DECL|function|~QTemporaryFile
name|QTemporaryFile
operator|::
name|~
name|QTemporaryFile
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTemporaryFile
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|fileName
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|autoRemove
condition|)
name|remove
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   \fn bool QTemporaryFile::open()    A QTemporaryFile will always be opened in QIODevice::ReadWrite mode,   this allows easy access to the data in the file. This function will   return true upon success and will set the fileName() to the unique   filename used.    \sa fileName() */
end_comment
begin_comment
comment|/*!    Returns true if the QTemporaryFile is in auto remove    mode. Auto-remove mode will automatically delete the filename from    disk upon destruction. This makes it very easy to create your    QTemporaryFile object on the stack, fill it with data, read from    it, and finally on function return it will automatically clean up    after itself.     Auto-remove is on by default.     \sa setAutoRemove(), remove() */
end_comment
begin_function
DECL|function|autoRemove
name|bool
name|QTemporaryFile
operator|::
name|autoRemove
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTemporaryFile
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autoRemove
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the QTemporaryFile into auto-remove mode if \a b is true.      Auto-remove is on by default.      \sa autoRemove(), remove() */
end_comment
begin_function
DECL|function|setAutoRemove
name|void
name|QTemporaryFile
operator|::
name|setAutoRemove
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTemporaryFile
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoRemove
operator|=
name|b
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!    Returns the complete unique filename backing the QTemporaryFile    object. This string is null before the QTemporaryFile is opened,    afterwards it will contain the fileTemplate() plus    additional characters to make it unique.     \sa fileTemplate() */
end_comment
begin_function
DECL|function|fileName
name|QString
name|QTemporaryFile
operator|::
name|fileName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTemporaryFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|d
operator|->
name|engine
argument_list|()
operator|->
name|fileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|DefaultName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the set file template. The default file template will be   called qcoreappname.XXXXXX and be placed in QDir::tempPath().    \sa setFileTemplate() */
end_comment
begin_function
DECL|function|fileTemplate
name|QString
name|QTemporaryFile
operator|::
name|fileTemplate
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTemporaryFile
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|templateName
return|;
block|}
end_function
begin_comment
comment|/*!    Sets the static portion of the file name to \a name. If the file    template ends in XXXXXX that will automatically be replaced with    the unique part of the filename, otherwise a filename will be    determined automatically based on the static portion specified.      If \a name contains a relative file path, the path will be relative to the     current working directory. You can use QDir::tempPath() to construct \a     name if you want use the system's temporary directory.     \sa fileTemplate() */
end_comment
begin_function
DECL|function|setFileTemplate
name|void
name|QTemporaryFile
operator|::
name|setFileTemplate
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTemporaryFile
argument_list|)
expr_stmt|;
name|d
operator|->
name|templateName
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEngine
condition|)
cast|static_cast
argument_list|<
name|QTemporaryFileEngine
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|fileEngine
argument_list|)
operator|->
name|setFileTemplate
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \fn QTemporaryFile *QTemporaryFile::createLocalFile(const QString&fileName)   \overload   \obsolete    Use QTemporaryFile::createNativeFile(const QString&fileName) instead. */
end_comment
begin_comment
comment|/*!   \fn QTemporaryFile *QTemporaryFile::createLocalFile(QFile&file)   \obsolete    Use QTemporaryFile::createNativeFile(QFile&file) instead. */
end_comment
begin_comment
comment|/*!   \fn QTemporaryFile *QTemporaryFile::createNativeFile(const QString&fileName)   \overload    Works on the given \a fileName rather than an existing QFile   object. */
end_comment
begin_comment
comment|/*!   If \a file is not already a native file then a QTemporaryFile is created   in the tempPath() and \a file is copied into the temporary file, then a   pointer to the temporary file is returned. If \a file is already a native   file, a QTemporaryFile is not created, no copy is made and 0 is returned.    For example:    QFile f(":/resources/file.txt");   QTemporaryFile::createNativeFile(f); // Returns a pointer to a temporary file    QFile f("/users/qt/file.txt");   QTemporaryFile::createNativeFile(f); // Returns 0    \sa QFileInfo::isNativePath() */
end_comment
begin_function
DECL|function|createNativeFile
name|QTemporaryFile
modifier|*
name|QTemporaryFile
operator|::
name|createNativeFile
parameter_list|(
name|QFile
modifier|&
name|file
parameter_list|)
block|{
if|if
condition|(
name|QAbstractFileEngine
modifier|*
name|engine
init|=
name|file
operator|.
name|d_func
argument_list|()
operator|->
name|engine
argument_list|()
condition|)
block|{
if|if
condition|(
name|engine
operator|->
name|fileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|FlagsMask
argument_list|)
operator|&
name|QAbstractFileEngine
operator|::
name|LocalDiskFlag
condition|)
return|return
literal|0
return|;
comment|//native already
comment|//cache
name|bool
name|wasOpen
init|=
name|file
operator|.
name|isOpen
argument_list|()
decl_stmt|;
name|qint64
name|old_off
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|wasOpen
condition|)
name|old_off
operator|=
name|file
operator|.
name|pos
argument_list|()
expr_stmt|;
else|else
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
comment|//dump data
name|QTemporaryFile
modifier|*
name|ret
init|=
operator|new
name|QTemporaryFile
decl_stmt|;
name|ret
operator|->
name|open
argument_list|()
expr_stmt|;
name|file
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|qint64
name|len
init|=
name|file
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
condition|)
break|break;
name|ret
operator|->
name|write
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|ret
operator|->
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|//restore
if|if
condition|(
name|wasOpen
condition|)
name|file
operator|.
name|seek
argument_list|(
name|old_off
argument_list|)
expr_stmt|;
else|else
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
comment|//done
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!    \reimp      Creates a unique file name for the temporary file, and opens it.  You can     get the unique name later by calling fileName(). The file is guaranteed to     have been created by this function (i.e., it has never existed before). */
end_comment
begin_function
DECL|function|open
name|bool
name|QTemporaryFile
operator|::
name|open
parameter_list|(
name|OpenMode
name|flags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTemporaryFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
cast|static_cast
argument_list|<
name|QTemporaryFileEngine
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|engine
argument_list|()
argument_list|)
operator|->
name|isReallyOpen
argument_list|()
condition|)
block|{
name|setOpenMode
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|QFile
operator|::
name|open
argument_list|(
name|flags
argument_list|)
condition|)
block|{
name|d
operator|->
name|fileName
operator|=
name|d
operator|->
name|fileEngine
operator|->
name|fileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|DefaultName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEMPORARYFILE
end_comment
end_unit
