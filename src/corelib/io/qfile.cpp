begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qfsfileengine.h"
end_include
begin_include
include|#
directive|include
file|"qtemporaryfile.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qfileinfo.h"
end_include
begin_include
include|#
directive|include
file|"private/qiodevice_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qfile_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qsystemerror_p.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
end_ifdef
begin_define
DECL|macro|tr
define|#
directive|define
name|tr
parameter_list|(
name|X
parameter_list|)
value|QString::fromLatin1(X)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|QFILE_WRITEBUFFER_SIZE
specifier|static
specifier|const
name|int
name|QFILE_WRITEBUFFER_SIZE
init|=
literal|16384
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|locale_encode
specifier|static
name|QByteArray
name|locale_encode
parameter_list|(
specifier|const
name|QString
modifier|&
name|f
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
comment|// Mac always expects UTF-8... and decomposed...
return|return
name|f
operator|.
name|normalized
argument_list|(
name|QString
operator|::
name|NormalizationForm_D
argument_list|)
operator|.
name|toUtf8
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
return|return
name|f
operator|.
name|toUtf8
argument_list|()
return|;
else|#
directive|else
return|return
name|f
operator|.
name|toLocal8Bit
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|locale_decode
specifier|static
name|QString
name|locale_decode
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|f
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
comment|// Mac always gives us UTF-8 and decomposed, we want that composed...
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
name|f
argument_list|)
operator|.
name|normalized
argument_list|(
name|QString
operator|::
name|NormalizationForm_C
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
name|f
argument_list|)
return|;
else|#
directive|else
return|return
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|f
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|//************* QFilePrivate
end_comment
begin_decl_stmt
DECL|member|encoder
name|QFile
operator|::
name|EncoderFn
name|QFilePrivate
operator|::
name|encoder
init|=
name|locale_encode
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|decoder
name|QFile
operator|::
name|DecoderFn
name|QFilePrivate
operator|::
name|decoder
init|=
name|locale_decode
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QFilePrivate
name|QFilePrivate
operator|::
name|QFilePrivate
parameter_list|()
member_init_list|:
name|fileEngine
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lastWasWrite
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|writeBuffer
argument_list|(
name|QFILE_WRITEBUFFER_SIZE
argument_list|)
member_init_list|,
name|error
argument_list|(
name|QFile
operator|::
name|NoError
argument_list|)
member_init_list|,
name|cachedSize
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QFilePrivate
name|QFilePrivate
operator|::
name|~
name|QFilePrivate
parameter_list|()
block|{
operator|delete
name|fileEngine
expr_stmt|;
name|fileEngine
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_function
name|bool
DECL|function|openExternalFile
name|QFilePrivate
operator|::
name|openExternalFile
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|fd
parameter_list|,
name|QFile
operator|::
name|FileHandleFlags
name|handleFlags
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_FSFILEENGINE
name|Q_UNUSED
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
else|#
directive|else
operator|delete
name|fileEngine
expr_stmt|;
name|fileEngine
operator|=
literal|0
expr_stmt|;
name|QFSFileEngine
modifier|*
name|fe
init|=
operator|new
name|QFSFileEngine
decl_stmt|;
name|fileEngine
operator|=
name|fe
expr_stmt|;
return|return
name|fe
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|OpenMode
argument_list|(
name|flags
argument_list|)
argument_list|,
name|fd
argument_list|,
name|handleFlags
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_function
name|bool
DECL|function|openExternalFile
name|QFilePrivate
operator|::
name|openExternalFile
parameter_list|(
name|int
name|flags
parameter_list|,
name|FILE
modifier|*
name|fh
parameter_list|,
name|QFile
operator|::
name|FileHandleFlags
name|handleFlags
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_FSFILEENGINE
name|Q_UNUSED
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|fh
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
else|#
directive|else
operator|delete
name|fileEngine
expr_stmt|;
name|fileEngine
operator|=
literal|0
expr_stmt|;
name|QFSFileEngine
modifier|*
name|fe
init|=
operator|new
name|QFSFileEngine
decl_stmt|;
name|fileEngine
operator|=
name|fe
expr_stmt|;
return|return
name|fe
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|OpenMode
argument_list|(
name|flags
argument_list|)
argument_list|,
name|fh
argument_list|,
name|handleFlags
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
end_ifdef
begin_function
DECL|function|openExternalFile
name|bool
name|QFilePrivate
operator|::
name|openExternalFile
parameter_list|(
name|int
name|flags
parameter_list|,
specifier|const
name|RFile
modifier|&
name|f
parameter_list|,
name|QFile
operator|::
name|FileHandleFlags
name|handleFlags
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_FSFILEENGINE
name|Q_UNUSED
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|fh
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
else|#
directive|else
operator|delete
name|fileEngine
expr_stmt|;
name|fileEngine
operator|=
literal|0
expr_stmt|;
name|QFSFileEngine
modifier|*
name|fe
init|=
operator|new
name|QFSFileEngine
decl_stmt|;
name|fileEngine
operator|=
name|fe
expr_stmt|;
return|return
name|fe
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|OpenMode
argument_list|(
name|flags
argument_list|)
argument_list|,
name|f
argument_list|,
name|handleFlags
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|ensureFlushed
specifier|inline
name|bool
name|QFilePrivate
operator|::
name|ensureFlushed
parameter_list|()
specifier|const
block|{
comment|// This function ensures that the write buffer has been flushed (const
comment|// because certain const functions need to call it.
if|if
condition|(
name|lastWasWrite
condition|)
block|{
cast|const_cast
argument_list|<
name|QFilePrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|lastWasWrite
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
cast|const_cast
argument_list|<
name|QFile
operator|*
argument_list|>
argument_list|(
name|q_func
argument_list|()
argument_list|)
operator|->
name|flush
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
name|void
DECL|function|setError
name|QFilePrivate
operator|::
name|setError
parameter_list|(
name|QFile
operator|::
name|FileError
name|err
parameter_list|)
block|{
name|error
operator|=
name|err
expr_stmt|;
name|errorString
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|setError
name|QFilePrivate
operator|::
name|setError
parameter_list|(
name|QFile
operator|::
name|FileError
name|err
parameter_list|,
specifier|const
name|QString
modifier|&
name|errStr
parameter_list|)
block|{
name|error
operator|=
name|err
expr_stmt|;
name|errorString
operator|=
name|errStr
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|setError
name|QFilePrivate
operator|::
name|setError
parameter_list|(
name|QFile
operator|::
name|FileError
name|err
parameter_list|,
name|int
name|errNum
parameter_list|)
block|{
name|error
operator|=
name|err
expr_stmt|;
name|errorString
operator|=
name|qt_error_string
argument_list|(
name|errNum
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//************* QFile
end_comment
begin_comment
comment|/*!     \class QFile     \brief The QFile class provides an interface for reading from and writing to files.      \ingroup io      \reentrant      QFile is an I/O device for reading and writing text and binary     files and \l{The Qt Resource System}{resources}. A QFile may be     used by itself or, more conveniently, with a QTextStream or     QDataStream.      The file name is usually passed in the constructor, but it can be     set at any time using setFileName(). QFile expects the file     separator to be '/' regardless of operating system. The use of     other separators (e.g., '\\') is not supported.      You can check for a file's existence using exists(), and remove a     file using remove(). (More advanced file system related operations     are provided by QFileInfo and QDir.)      The file is opened with open(), closed with close(), and flushed     with flush(). Data is usually read and written using QDataStream     or QTextStream, but you can also call the QIODevice-inherited     functions read(), readLine(), readAll(), write(). QFile also     inherits getChar(), putChar(), and ungetChar(), which work one     character at a time.      The size of the file is returned by size(). You can get the     current file position using pos(), or move to a new file position     using seek(). If you've reached the end of the file, atEnd()     returns true.      \section1 Reading Files Directly      The following example reads a text file line by line:      \snippet doc/src/snippets/file/file.cpp 0      The QIODevice::Text flag passed to open() tells Qt to convert     Windows-style line terminators ("\\r\\n") into C++-style     terminators ("\\n"). By default, QFile assumes binary, i.e. it     doesn't perform any conversion on the bytes stored in the file.      \section1 Using Streams to Read Files      The next example uses QTextStream to read a text file     line by line:      \snippet doc/src/snippets/file/file.cpp 1      QTextStream takes care of converting the 8-bit data stored on     disk into a 16-bit Unicode QString. By default, it assumes that     the user system's local 8-bit encoding is used (e.g., ISO 8859-1     for most of Europe; see QTextCodec::codecForLocale() for     details). This can be changed using setCodec().      To write text, we can use operator<<(), which is overloaded to     take a QTextStream on the left and various data types (including     QString) on the right:      \snippet doc/src/snippets/file/file.cpp 2      QDataStream is similar, in that you can use operator<<() to write     data and operator>>() to read it back. See the class     documentation for details.      When you use QFile, QFileInfo, and QDir to access the file system     with Qt, you can use Unicode file names. On Unix, these file     names are converted to an 8-bit encoding. If you want to use     standard C++ APIs (\c<cstdio> or \c<iostream>) or     platform-specific APIs to access files instead of QFile, you can     use the encodeName() and decodeName() functions to convert     between Unicode file names and 8-bit file names.      On Unix, there are some special system files (e.g. in \c /proc) for which     size() will always return 0, yet you may still be able to read more data     from such a file; the data is generated in direct response to you calling     read(). In this case, however, you cannot use atEnd() to determine if     there is more data to read (since atEnd() will return true for a file that     claims to have size 0). Instead, you should either call readAll(), or call     read() or readLine() repeatedly until no more data can be read. The next     example uses QTextStream to read \c /proc/modules line by line:      \snippet doc/src/snippets/file/file.cpp 3      \section1 Signals      Unlike other QIODevice implementations, such as QTcpSocket, QFile does not     emit the aboutToClose(), bytesWritten(), or readyRead() signals. This     implementation detail means that QFile is not suitable for reading and     writing certain types of files, such as device files on Unix platforms.      \section1 Platform Specific Issues      File permissions are handled differently on Linux/Mac OS X and     Windows.  In a non \l{QIODevice::isWritable()}{writable}     directory on Linux, files cannot be created. This is not always     the case on Windows, where, for instance, the 'My Documents'     directory usually is not writable, but it is still possible to     create files in it.      \sa QTextStream, QDataStream, QFileInfo, QDir, {The Qt Resource System} */
end_comment
begin_comment
comment|/*!     \enum QFile::FileError      This enum describes the errors that may be returned by the error()     function.      \value NoError          No error occurred.     \value ReadError        An error occurred when reading from the file.     \value WriteError       An error occurred when writing to the file.     \value FatalError       A fatal error occurred.     \value ResourceError     \value OpenError        The file could not be opened.     \value AbortError       The operation was aborted.     \value TimeOutError     A timeout occurred.     \value UnspecifiedError An unspecified error occurred.     \value RemoveError      The file could not be removed.     \value RenameError      The file could not be renamed.     \value PositionError    The position in the file could not be changed.     \value ResizeError      The file could not be resized.     \value PermissionsError The file could not be accessed.     \value CopyError        The file could not be copied.      \omitvalue ConnectError */
end_comment
begin_comment
comment|/*!     \enum QFile::Permission      This enum is used by the permission() function to report the     permissions and ownership of a file. The values may be OR-ed     together to test multiple permissions and ownership values.      \value ReadOwner The file is readable by the owner of the file.     \value WriteOwner The file is writable by the owner of the file.     \value ExeOwner The file is executable by the owner of the file.     \value ReadUser The file is readable by the user.     \value WriteUser The file is writable by the user.     \value ExeUser The file is executable by the user.     \value ReadGroup The file is readable by the group.     \value WriteGroup The file is writable by the group.     \value ExeGroup The file is executable by the group.     \value ReadOther The file is readable by anyone.     \value WriteOther The file is writable by anyone.     \value ExeOther The file is executable by anyone.      \warning Because of differences in the platforms supported by Qt,     the semantics of ReadUser, WriteUser and ExeUser are     platform-dependent: On Unix, the rights of the owner of the file     are returned and on Windows the rights of the current user are     returned. This behavior might change in a future Qt version.      Note that Qt does not by default check for permissions on NTFS     file systems, as this may decrease the performance of file     handling considerably. It is possible to force permission checking     on NTFS by including the following code in your source:      \snippet doc/src/snippets/ntfsp.cpp 0      Permission checking is then turned on and off by incrementing and     decrementing \c qt_ntfs_permission_lookup by 1.      \snippet doc/src/snippets/ntfsp.cpp 1 */
end_comment
begin_comment
comment|/*!     \enum QFile::FileHandleFlag      This enum is used when opening a file to specify additional     options which only apply to files and not to a generic     QIODevice.      \value AutoCloseHandle The file handle passed into open() should be     closed by close(), the default behavior is that close just flushes     the file and the application is responsible for closing the file handle.     When opening a file by name, this flag is ignored as Qt always owns the     file handle and must close it.     \value DontCloseHandle If not explicitly closed, the underlying file     handle is left open when the QFile object is destroyed.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
end_ifdef
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|()
member_init_list|:
name|QIODevice
argument_list|(
operator|*
operator|new
name|QFilePrivate
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
operator|*
operator|new
name|QFilePrivate
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|fileName
operator|=
name|name
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|(
name|QFilePrivate
modifier|&
name|dd
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
name|dd
argument_list|)
block|{ }
end_constructor
begin_else
else|#
directive|else
end_else
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|()
member_init_list|:
name|QIODevice
argument_list|(
operator|*
operator|new
name|QFilePrivate
argument_list|,
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a new file object with the given \a parent. */
end_comment
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
operator|*
operator|new
name|QFilePrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a new file object to represent the file with the given \a name. */
end_comment
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
operator|*
operator|new
name|QFilePrivate
argument_list|,
literal|0
argument_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileName
operator|=
name|name
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a new file object with the given \a parent to represent the     file with the specified \a name. */
end_comment
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
operator|*
operator|new
name|QFilePrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileName
operator|=
name|name
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|(
name|QFilePrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Destroys the file object, closing it if necessary. */
end_comment
begin_destructor
DECL|function|~QFile
name|QFile
operator|::
name|~
name|QFile
parameter_list|()
block|{
name|close
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns the name set by setFileName() or to the QFile     constructors.      \sa setFileName(), QFileInfo::fileName() */
end_comment
begin_function
DECL|function|fileName
name|QString
name|QFile
operator|::
name|fileName
parameter_list|()
specifier|const
block|{
return|return
name|fileEngine
argument_list|()
operator|->
name|fileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|DefaultName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the \a name of the file. The name can have no path, a     relative path, or an absolute path.      Do not call this function if the file has already been opened.      If the file name has no path or a relative path, the path used     will be the application's current directory path     \e{at the time of the open()} call.      Example:     \snippet doc/src/snippets/code/src_corelib_io_qfile.cpp 0      Note that the directory separator "/" works for all operating     systems supported by Qt.      \sa fileName(), QFileInfo, QDir */
end_comment
begin_function
name|void
DECL|function|setFileName
name|QFile
operator|::
name|setFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::setFileName: File (%s) is already opened"
argument_list|,
name|qPrintable
argument_list|(
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|fileEngine
condition|)
block|{
comment|//get a new file engine later
operator|delete
name|d
operator|->
name|fileEngine
expr_stmt|;
name|d
operator|->
name|fileEngine
operator|=
literal|0
expr_stmt|;
block|}
name|d
operator|->
name|fileName
operator|=
name|name
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QFile::decodeName(const char *localFileName)      \overload      Returns the Unicode version of the given \a localFileName. See     encodeName() for details. */
end_comment
begin_comment
comment|/*!     By default, this function converts \a fileName to the local 8-bit     encoding determined by the user's locale. This is sufficient for     file names that the user chooses. File names hard-coded into the     application should only use 7-bit ASCII filename characters.      \sa decodeName() setEncodingFunction() */
end_comment
begin_function
name|QByteArray
DECL|function|encodeName
name|QFile
operator|::
name|encodeName
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
return|return
call|(
modifier|*
name|QFilePrivate
operator|::
name|encoder
call|)
argument_list|(
name|fileName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \typedef QFile::EncoderFn      This is a typedef for a pointer to a function with the following     signature:      \snippet doc/src/snippets/code/src_corelib_io_qfile.cpp 1      \sa setEncodingFunction(), encodeName() */
end_comment
begin_comment
comment|/*!     This does the reverse of QFile::encodeName() using \a localFileName.      \sa setDecodingFunction(), encodeName() */
end_comment
begin_function
name|QString
DECL|function|decodeName
name|QFile
operator|::
name|decodeName
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|localFileName
parameter_list|)
block|{
return|return
call|(
modifier|*
name|QFilePrivate
operator|::
name|decoder
call|)
argument_list|(
name|localFileName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QFile::setEncodingFunction(EncoderFn function)      \nonreentrant      Sets the \a function for encoding Unicode file names. The     default encodes in the locale-specific 8-bit encoding.      \sa encodeName(), setDecodingFunction() */
end_comment
begin_function
name|void
DECL|function|setEncodingFunction
name|QFile
operator|::
name|setEncodingFunction
parameter_list|(
name|EncoderFn
name|f
parameter_list|)
block|{
if|if
condition|(
operator|!
name|f
condition|)
name|f
operator|=
name|locale_encode
expr_stmt|;
name|QFilePrivate
operator|::
name|encoder
operator|=
name|f
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \typedef QFile::DecoderFn      This is a typedef for a pointer to a function with the following     signature:      \snippet doc/src/snippets/code/src_corelib_io_qfile.cpp 2      \sa setDecodingFunction() */
end_comment
begin_comment
comment|/*!     \fn void QFile::setDecodingFunction(DecoderFn function)      \nonreentrant      Sets the \a function for decoding 8-bit file names. The     default uses the locale-specific 8-bit encoding.      \sa setEncodingFunction(), decodeName() */
end_comment
begin_function
name|void
DECL|function|setDecodingFunction
name|QFile
operator|::
name|setDecodingFunction
parameter_list|(
name|DecoderFn
name|f
parameter_list|)
block|{
if|if
condition|(
operator|!
name|f
condition|)
name|f
operator|=
name|locale_decode
expr_stmt|;
name|QFilePrivate
operator|::
name|decoder
operator|=
name|f
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns true if the file specified by fileName() exists; otherwise     returns false.      \sa fileName(), setFileName() */
end_comment
begin_function
name|bool
DECL|function|exists
name|QFile
operator|::
name|exists
parameter_list|()
specifier|const
block|{
comment|// 0x1000000 = QAbstractFileEngine::Refresh, forcing an update
return|return
operator|(
name|fileEngine
argument_list|()
operator|->
name|fileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|FlagsMask
operator||
name|QAbstractFileEngine
operator|::
name|FileFlag
argument_list|(
literal|0x1000000
argument_list|)
argument_list|)
operator|&
name|QAbstractFileEngine
operator|::
name|ExistsFlag
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the file specified by \a fileName exists; otherwise     returns false. */
end_comment
begin_function
name|bool
DECL|function|exists
name|QFile
operator|::
name|exists
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
return|return
name|QFileInfo
argument_list|(
name|fileName
argument_list|)
operator|.
name|exists
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QFile::symLinkTarget() const     \since 4.2     \overload      Returns the absolute path of the file or directory a symlink (or shortcut     on Windows) points to, or a an empty string if the object isn't a symbolic     link.      This name may not represent an existing file; it is only a string.     QFile::exists() returns true if the symlink points to an existing file.      \sa fileName() setFileName() */
end_comment
begin_comment
comment|/*!     \obsolete      Use symLinkTarget() instead. */
end_comment
begin_function
name|QString
DECL|function|readLink
name|QFile
operator|::
name|readLink
parameter_list|()
specifier|const
block|{
return|return
name|fileEngine
argument_list|()
operator|->
name|fileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|LinkName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn static QString QFile::symLinkTarget(const QString&fileName)     \since 4.2      Returns the absolute path of the file or directory referred to by the     symlink (or shortcut on Windows) specified by \a fileName, or returns an     empty string if the \a fileName does not correspond to a symbolic link.      This name may not represent an existing file; it is only a string.     QFile::exists() returns true if the symlink points to an existing file. */
end_comment
begin_comment
comment|/*!     \obsolete      Use symLinkTarget() instead. */
end_comment
begin_function
name|QString
DECL|function|readLink
name|QFile
operator|::
name|readLink
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
return|return
name|QFileInfo
argument_list|(
name|fileName
argument_list|)
operator|.
name|readLink
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the file specified by fileName(). Returns true if successful;     otherwise returns false.      The file is closed before it is removed.      \sa setFileName() */
end_comment
begin_function
name|bool
DECL|function|remove
name|QFile
operator|::
name|remove
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::remove: Empty or null file name"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|unsetError
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
argument_list|()
operator|==
name|QFile
operator|::
name|NoError
condition|)
block|{
if|if
condition|(
name|fileEngine
argument_list|()
operator|->
name|remove
argument_list|()
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RemoveError
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Removes the file specified by the \a fileName given.      Returns true if successful; otherwise returns false.      \sa remove() */
end_comment
begin_function
name|bool
DECL|function|remove
name|QFile
operator|::
name|remove
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
return|return
name|QFile
argument_list|(
name|fileName
argument_list|)
operator|.
name|remove
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Renames the file currently specified by fileName() to \a newName.     Returns true if successful; otherwise returns false.      If a file with the name \a newName already exists, rename() returns false     (i.e., QFile will not overwrite it).      The file is closed before it is renamed.      \sa setFileName() */
end_comment
begin_function
name|bool
DECL|function|rename
name|QFile
operator|::
name|rename
parameter_list|(
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::rename: Empty or null file name"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|QFile
argument_list|(
name|newName
argument_list|)
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// ### Race condition. If a file is moved in after this, it /will/ be
comment|// overwritten. On Unix, the proper solution is to use hardlinks:
comment|// return ::link(old, new)&& ::remove(old);
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|tr
argument_list|(
literal|"Destination file exists"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|unsetError
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
argument_list|()
operator|==
name|QFile
operator|::
name|NoError
condition|)
block|{
if|if
condition|(
name|fileEngine
argument_list|()
operator|->
name|rename
argument_list|(
name|newName
argument_list|)
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
comment|// engine was able to handle the new name so we just reset it
name|d
operator|->
name|fileEngine
operator|->
name|setFileName
argument_list|(
name|newName
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileName
operator|=
name|newName
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|isSequential
argument_list|()
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|tr
argument_list|(
literal|"Will not rename sequential file using block copy"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QFile
name|out
argument_list|(
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
operator||
name|QIODevice
operator|::
name|Truncate
argument_list|)
condition|)
block|{
name|bool
name|error
init|=
literal|false
decl_stmt|;
name|char
name|block
index|[
literal|4096
index|]
decl_stmt|;
name|qint64
name|bytes
decl_stmt|;
while|while
condition|(
operator|(
name|bytes
operator|=
name|read
argument_list|(
name|block
argument_list|,
sizeof|sizeof
argument_list|(
name|block
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bytes
operator|!=
name|out
operator|.
name|write
argument_list|(
name|block
argument_list|,
name|bytes
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|out
operator|.
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bytes
operator|==
operator|-
literal|1
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
operator|!
name|remove
argument_list|()
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|tr
argument_list|(
literal|"Cannot remove source file"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|out
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|fileEngine
operator|->
name|setFileName
argument_list|(
name|newName
argument_list|)
expr_stmt|;
name|setPermissions
argument_list|(
name|permissions
argument_list|()
argument_list|)
expr_stmt|;
name|unsetError
argument_list|()
expr_stmt|;
name|setFileName
argument_list|(
name|newName
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|()
expr_stmt|;
return|return
operator|!
name|error
return|;
block|}
name|close
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|out
operator|.
name|isOpen
argument_list|()
condition|?
name|errorString
argument_list|()
else|:
name|out
operator|.
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Renames the file \a oldName to \a newName. Returns true if     successful; otherwise returns false.      If a file with the name \a newName already exists, rename() returns false     (i.e., QFile will not overwrite it).      \sa rename() */
end_comment
begin_function
name|bool
DECL|function|rename
name|QFile
operator|::
name|rename
parameter_list|(
specifier|const
name|QString
modifier|&
name|oldName
parameter_list|,
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
return|return
name|QFile
argument_list|(
name|oldName
argument_list|)
operator|.
name|rename
argument_list|(
name|newName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!      Creates a link named \a linkName that points to the file currently specified by     fileName().  What a link is depends on the underlying filesystem (be it a     shortcut on Windows or a symbolic link on Unix). Returns true if successful;     otherwise returns false.      This function will not overwrite an already existing entity in the file system;     in this case, \c link() will return false and set \l{QFile::}{error()} to     return \l{QFile::}{RenameError}.      \note To create a valid link on Windows, \a linkName must have a \c{.lnk} file extension.      \note On Symbian, no link is created and false is returned if fileName()     currently specifies a directory.      \sa setFileName() */
end_comment
begin_function
name|bool
DECL|function|link
name|QFile
operator|::
name|link
parameter_list|(
specifier|const
name|QString
modifier|&
name|linkName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::link: Empty or null file name"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QFileInfo
name|fi
argument_list|(
name|linkName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileEngine
argument_list|()
operator|->
name|link
argument_list|(
name|fi
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Creates a link named \a linkName that points to the file \a fileName. What a link is     depends on the underlying filesystem (be it a shortcut on Windows     or a symbolic link on Unix). Returns true if successful; otherwise     returns false.      \sa link() */
end_comment
begin_function
name|bool
DECL|function|link
name|QFile
operator|::
name|link
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|linkName
parameter_list|)
block|{
return|return
name|QFile
argument_list|(
name|fileName
argument_list|)
operator|.
name|link
argument_list|(
name|linkName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Copies the file currently specified by fileName() to a file called     \a newName.  Returns true if successful; otherwise returns false.      Note that if a file with the name \a newName already exists,     copy() returns false (i.e. QFile will not overwrite it).      The source file is closed before it is copied.      \sa setFileName() */
end_comment
begin_function
name|bool
DECL|function|copy
name|QFile
operator|::
name|copy
parameter_list|(
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::copy: Empty or null file name"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|QFile
argument_list|(
name|newName
argument_list|)
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// ### Race condition. If a file is moved in after this, it /will/ be
comment|// overwritten. On Unix, the proper solution is to use hardlinks:
comment|// return ::link(old, new)&& ::remove(old); See also rename().
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|CopyError
argument_list|,
name|tr
argument_list|(
literal|"Destination file exists"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|unsetError
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
argument_list|()
operator|==
name|QFile
operator|::
name|NoError
condition|)
block|{
if|if
condition|(
name|fileEngine
argument_list|()
operator|->
name|copy
argument_list|(
name|newName
argument_list|)
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|bool
name|error
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|error
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|CopyError
argument_list|,
name|tr
argument_list|(
literal|"Cannot open %1 for input"
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|fileTemplate
init|=
name|QLatin1String
argument_list|(
literal|"%1/qt_temp.XXXXXX"
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_NO_TEMPORARYFILE
name|QFile
name|out
argument_list|(
name|fileTemplate
operator|.
name|arg
argument_list|(
name|QFileInfo
argument_list|(
name|newName
argument_list|)
operator|.
name|path
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|out
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadWrite
argument_list|)
condition|)
name|error
operator|=
literal|true
expr_stmt|;
else|#
directive|else
name|QTemporaryFile
name|out
argument_list|(
name|fileTemplate
operator|.
name|arg
argument_list|(
name|QFileInfo
argument_list|(
name|newName
argument_list|)
operator|.
name|path
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|out
operator|.
name|open
argument_list|()
condition|)
block|{
name|out
operator|.
name|setFileTemplate
argument_list|(
name|fileTemplate
operator|.
name|arg
argument_list|(
name|QDir
operator|::
name|tempPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
operator|.
name|open
argument_list|()
condition|)
name|error
operator|=
literal|true
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|CopyError
argument_list|,
name|tr
argument_list|(
literal|"Cannot open for output"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|block
index|[
literal|4096
index|]
decl_stmt|;
name|qint64
name|totalRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|atEnd
argument_list|()
condition|)
block|{
name|qint64
name|in
init|=
name|read
argument_list|(
name|block
argument_list|,
sizeof|sizeof
argument_list|(
name|block
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|in
operator|<=
literal|0
condition|)
break|break;
name|totalRead
operator|+=
name|in
expr_stmt|;
if|if
condition|(
name|in
operator|!=
name|out
operator|.
name|write
argument_list|(
name|block
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|CopyError
argument_list|,
name|tr
argument_list|(
literal|"Failure to write block"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|totalRead
operator|!=
name|size
argument_list|()
condition|)
block|{
comment|// Unable to read from the source. The error string is
comment|// already set from read().
name|error
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
operator|!
name|out
operator|.
name|rename
argument_list|(
name|newName
argument_list|)
condition|)
block|{
name|error
operator|=
literal|true
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|CopyError
argument_list|,
name|tr
argument_list|(
literal|"Cannot create %1 for output"
argument_list|)
operator|.
name|arg
argument_list|(
name|newName
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_NO_TEMPORARYFILE
if|if
condition|(
name|error
condition|)
name|out
operator|.
name|remove
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|error
condition|)
name|out
operator|.
name|setAutoRemove
argument_list|(
literal|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|QFile
operator|::
name|setPermissions
argument_list|(
name|newName
argument_list|,
name|permissions
argument_list|()
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
name|unsetError
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Copies the file \a fileName to \a newName. Returns true if successful;     otherwise returns false.      If a file with the name \a newName already exists, copy() returns false     (i.e., QFile will not overwrite it).      \sa rename() */
end_comment
begin_function
name|bool
DECL|function|copy
name|QFile
operator|::
name|copy
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
return|return
name|QFile
argument_list|(
name|fileName
argument_list|)
operator|.
name|copy
argument_list|(
name|newName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the file can only be manipulated sequentially;     otherwise returns false.      Most files support random-access, but some special files may not.      \sa QIODevice::isSequential() */
end_comment
begin_function
DECL|function|isSequential
name|bool
name|QFile
operator|::
name|isSequential
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFile
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fileEngine
operator|&&
name|d
operator|->
name|fileEngine
operator|->
name|isSequential
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Opens the file using OpenMode \a mode, returning true if successful;     otherwise false.      The \a mode must be QIODevice::ReadOnly, QIODevice::WriteOnly, or     QIODevice::ReadWrite. It may also have additional flags, such as     QIODevice::Text and QIODevice::Unbuffered.      \note In \l{QIODevice::}{WriteOnly} or \l{QIODevice::}{ReadWrite}     mode, if the relevant file does not already exist, this function     will try to create a new file before opening it.      \sa QIODevice::OpenMode, setFileName() */
end_comment
begin_function
DECL|function|open
name|bool
name|QFile
operator|::
name|open
parameter_list|(
name|OpenMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::open: File (%s) already open"
argument_list|,
name|qPrintable
argument_list|(
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mode
operator|&
name|Append
condition|)
name|mode
operator||=
name|WriteOnly
expr_stmt|;
name|unsetError
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
operator|(
name|ReadOnly
operator||
name|WriteOnly
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QIODevice::open: File access not specified"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
comment|// For symbian, the unbuffered flag is used to control write-behind cache behaviour
if|if
condition|(
name|fileEngine
argument_list|()
operator|->
name|open
argument_list|(
name|mode
argument_list|)
condition|)
else|#
directive|else
comment|// QIODevice provides the buffering, so there's no need to request it from the file engine.
if|if
condition|(
name|fileEngine
argument_list|()
operator|->
name|open
argument_list|(
name|mode
operator||
name|QIODevice
operator|::
name|Unbuffered
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|QIODevice
operator|::
name|open
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|Append
condition|)
name|seek
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|QFile
operator|::
name|FileError
name|err
init|=
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|QFile
operator|::
name|UnspecifiedError
condition|)
name|err
operator|=
name|QFile
operator|::
name|OpenError
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Opens the existing file handle \a fh in the given \a mode.     Returns true if successful; otherwise returns false.      Example:     \snippet doc/src/snippets/code/src_corelib_io_qfile.cpp 3      When a QFile is opened using this function, close() does not actually     close the file, but only flushes it.      \bold{Warning:}     \list 1         \o If \a fh does not refer to a regular file, e.g., it is \c stdin,            \c stdout, or \c stderr, you may not be able to seek(). size()            returns \c 0 in those cases. See QIODevice::isSequential() for            more information.         \o Since this function opens the file without specifying the file name,            you cannot use this QFile with a QFileInfo.     \endlist      \note For Windows CE you may not be able to call resize().      \sa close(), {qmake Variable Reference#CONFIG}{qmake Variable Reference}      \bold{Note for the Windows Platform}      \a fh must be opened in binary mode (i.e., the mode string must contain     'b', as in "rb" or "wb") when accessing files and other random-access     devices. Qt will translate the end-of-line characters if you pass     QIODevice::Text to \a mode. Sequential devices, such as stdin and stdout,     are unaffected by this limitation.      You need to enable support for console applications in order to use the     stdin, stdout and stderr streams at the console. To do this, add the     following declaration to your application's project file:      \snippet doc/src/snippets/code/src_corelib_io_qfile.cpp 4 */
end_comment
begin_comment
comment|// ### Qt5: merge this into new overload with a default parameter
end_comment
begin_function
DECL|function|open
name|bool
name|QFile
operator|::
name|open
parameter_list|(
name|FILE
modifier|*
name|fh
parameter_list|,
name|OpenMode
name|mode
parameter_list|)
block|{
return|return
name|open
argument_list|(
name|fh
argument_list|,
name|mode
argument_list|,
name|DontCloseHandle
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Opens the existing file handle \a fh in the given \a mode.     Returns true if successful; otherwise returns false.      Example:     \snippet doc/src/snippets/code/src_corelib_io_qfile.cpp 3      When a QFile is opened using this function, behaviour of close() is     controlled by the AutoCloseHandle flag.     If AutoCloseHandle is specified, and this function succeeds,     then calling close() closes the adopted handle.     Otherwise, close() does not actually close the file, but only flushes it.      \bold{Warning:}     \list 1         \o If \a fh does not refer to a regular file, e.g., it is \c stdin,            \c stdout, or \c stderr, you may not be able to seek(). size()            returns \c 0 in those cases. See QIODevice::isSequential() for            more information.         \o Since this function opens the file without specifying the file name,            you cannot use this QFile with a QFileInfo.     \endlist      \note For Windows CE you may not be able to call resize().      \sa close(), {qmake Variable Reference#CONFIG}{qmake Variable Reference}      \bold{Note for the Windows Platform}      \a fh must be opened in binary mode (i.e., the mode string must contain     'b', as in "rb" or "wb") when accessing files and other random-access     devices. Qt will translate the end-of-line characters if you pass     QIODevice::Text to \a mode. Sequential devices, such as stdin and stdout,     are unaffected by this limitation.      You need to enable support for console applications in order to use the     stdin, stdout and stderr streams at the console. To do this, add the     following declaration to your application's project file:      \snippet doc/src/snippets/code/src_corelib_io_qfile.cpp 4 */
end_comment
begin_function
DECL|function|open
name|bool
name|QFile
operator|::
name|open
parameter_list|(
name|FILE
modifier|*
name|fh
parameter_list|,
name|OpenMode
name|mode
parameter_list|,
name|FileHandleFlags
name|handleFlags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::open: File (%s) already open"
argument_list|,
name|qPrintable
argument_list|(
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mode
operator|&
name|Append
condition|)
name|mode
operator||=
name|WriteOnly
expr_stmt|;
name|unsetError
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
operator|(
name|ReadOnly
operator||
name|WriteOnly
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::open: File access not specified"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|openExternalFile
argument_list|(
name|mode
argument_list|,
name|fh
argument_list|,
name|handleFlags
argument_list|)
condition|)
block|{
name|QIODevice
operator|::
name|open
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|Append
condition|)
block|{
name|seek
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qint64
name|pos
init|=
operator|(
name|qint64
operator|)
name|QT_FTELL
argument_list|(
name|fh
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Opens the existing file descriptor \a fd in the given \a mode.     Returns true if successful; otherwise returns false.      When a QFile is opened using this function, close() does not     actually close the file.      The QFile that is opened using this function is automatically set     to be in raw mode; this means that the file input/output functions     are slow. If you run into performance issues, you should try to     use one of the other open functions.      \warning If \a fd is not a regular file, e.g, it is 0 (\c stdin),     1 (\c stdout), or 2 (\c stderr), you may not be able to seek(). In     those cases, size() returns \c 0.  See QIODevice::isSequential()     for more information.      \warning For Windows CE you may not be able to call seek(), setSize(),     fileTime(). size() returns \c 0.      \warning Since this function opens the file without specifying the file name,              you cannot use this QFile with a QFileInfo.      \sa close() */
end_comment
begin_comment
comment|// ### Qt5: merge this into new overload with a default parameter
end_comment
begin_function
DECL|function|open
name|bool
name|QFile
operator|::
name|open
parameter_list|(
name|int
name|fd
parameter_list|,
name|OpenMode
name|mode
parameter_list|)
block|{
return|return
name|open
argument_list|(
name|fd
argument_list|,
name|mode
argument_list|,
name|DontCloseHandle
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Opens the existing file descriptor \a fd in the given \a mode.     Returns true if successful; otherwise returns false.      When a QFile is opened using this function, behaviour of close() is     controlled by the AutoCloseHandle flag.     If AutoCloseHandle is specified, and this function succeeds,     then calling close() closes the adopted handle.     Otherwise, close() does not actually close the file, but only flushes it.      The QFile that is opened using this function is automatically set     to be in raw mode; this means that the file input/output functions     are slow. If you run into performance issues, you should try to     use one of the other open functions.      \warning If \a fd is not a regular file, e.g, it is 0 (\c stdin),     1 (\c stdout), or 2 (\c stderr), you may not be able to seek(). In     those cases, size() returns \c 0.  See QIODevice::isSequential()     for more information.      \warning For Windows CE you may not be able to call seek(), setSize(),     fileTime(). size() returns \c 0.      \warning Since this function opens the file without specifying the file name,              you cannot use this QFile with a QFileInfo.      \sa close() */
end_comment
begin_function
DECL|function|open
name|bool
name|QFile
operator|::
name|open
parameter_list|(
name|int
name|fd
parameter_list|,
name|OpenMode
name|mode
parameter_list|,
name|FileHandleFlags
name|handleFlags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::open: File (%s) already open"
argument_list|,
name|qPrintable
argument_list|(
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mode
operator|&
name|Append
condition|)
name|mode
operator||=
name|WriteOnly
expr_stmt|;
name|unsetError
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
operator|(
name|ReadOnly
operator||
name|WriteOnly
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::open: File access not specified"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|openExternalFile
argument_list|(
name|mode
argument_list|,
name|fd
argument_list|,
name|handleFlags
argument_list|)
condition|)
block|{
name|QIODevice
operator|::
name|open
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|Append
condition|)
block|{
name|seek
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qint64
name|pos
init|=
operator|(
name|qint64
operator|)
name|QT_LSEEK
argument_list|(
name|fd
argument_list|,
name|QT_OFF_T
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
end_ifdef
begin_comment
comment|/*!     \overload      Opens the existing file object \a f in the given \a mode.     Returns true if successful; otherwise returns false.      When a QFile is opened using this function, behaviour of close() is     controlled by the AutoCloseHandle flag.     If AutoCloseHandle is specified, and this function succeeds,     then calling close() closes the adopted handle.     Otherwise, close() does not actually close the file, but only flushes it.      \warning If the file handle is adopted from another process,              you may not be able to use this QFile with a QFileInfo.      \sa close() */
end_comment
begin_function
DECL|function|open
name|bool
name|QFile
operator|::
name|open
parameter_list|(
specifier|const
name|RFile
modifier|&
name|f
parameter_list|,
name|OpenMode
name|mode
parameter_list|,
name|FileHandleFlags
name|handleFlags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::open: File (%s) already open"
argument_list|,
name|qPrintable
argument_list|(
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mode
operator|&
name|Append
condition|)
name|mode
operator||=
name|WriteOnly
expr_stmt|;
name|unsetError
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
operator|(
name|ReadOnly
operator||
name|WriteOnly
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::open: File access not specified"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|openExternalFile
argument_list|(
name|mode
argument_list|,
name|f
argument_list|,
name|handleFlags
argument_list|)
condition|)
block|{
name|bool
name|ok
init|=
name|QIODevice
operator|::
name|open
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|Append
condition|)
block|{
name|ok
operator|=
name|seek
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qint64
name|pos
init|=
literal|0
decl_stmt|;
name|TInt
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|SYMBIAN_ENABLE_64_BIT_FILE_SERVER_API
name|err
operator|=
cast|static_cast
argument_list|<
specifier|const
name|RFile64
operator|&
argument_list|>
argument_list|(
name|f
argument_list|)
operator|.
name|Seek
argument_list|(
name|ESeekCurrent
argument_list|,
name|pos
argument_list|)
expr_stmt|;
else|#
directive|else
name|TInt
name|pos32
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|f
operator|.
name|Seek
argument_list|(
name|ESeekCurrent
argument_list|,
name|pos32
argument_list|)
expr_stmt|;
name|pos
operator|=
name|pos32
expr_stmt|;
endif|#
directive|endif
name|ok
operator|=
name|ok
operator|&&
operator|(
name|err
operator|==
name|KErrNone
operator|)
expr_stmt|;
name|ok
operator|=
name|ok
operator|&&
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ok
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   Returns the file handle of the file.    This is a small positive integer, suitable for use with C library   functions such as fdopen() and fcntl(). On systems that use file   descriptors for sockets (i.e. Unix systems, but not Windows) the handle   can be used with QSocketNotifier as well.    If the file is not open, or there is an error, handle() returns -1.    This function is not supported on Windows CE.    \sa QSocketNotifier */
end_comment
begin_function
name|int
DECL|function|handle
name|QFile
operator|::
name|handle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isOpen
argument_list|()
operator|||
operator|!
name|d
operator|->
name|fileEngine
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|d
operator|->
name|fileEngine
operator|->
name|handle
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QFile::MemoryMapFlags     \since 4.4      This enum describes special options that may be used by the map()     function.      \value NoOptions        No options. */
end_comment
begin_comment
comment|/*!     \since 4.4     Maps \a size bytes of the file into memory starting at \a offset.  A file     should be open for a map to succeed but the file does not need to stay     open after the memory has been mapped.  When the QFile is destroyed     or a new file is opened with this object, any maps that have not been     unmapped will automatically be unmapped.      Any mapping options can be passed through \a flags.      Returns a pointer to the memory or 0 if there is an error.      \note On Windows CE 5.0 the file will be closed before mapping occurs.      \sa unmap(), QAbstractFileEngine::supportsExtension()  */
end_comment
begin_function
DECL|function|map
name|uchar
modifier|*
name|QFile
operator|::
name|map
parameter_list|(
name|qint64
name|offset
parameter_list|,
name|qint64
name|size
parameter_list|,
name|MemoryMapFlags
name|flags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileEngine
argument_list|()
operator|&&
name|d
operator|->
name|fileEngine
operator|->
name|supportsExtension
argument_list|(
name|QAbstractFileEngine
operator|::
name|MapExtension
argument_list|)
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
name|uchar
modifier|*
name|address
init|=
name|d
operator|->
name|fileEngine
operator|->
name|map
argument_list|(
name|offset
argument_list|,
name|size
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
operator|==
literal|0
condition|)
name|d
operator|->
name|setError
argument_list|(
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|address
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Unmaps the memory \a address.      Returns true if the unmap succeeds; false otherwise.      \sa map(), QAbstractFileEngine::supportsExtension()  */
end_comment
begin_function
DECL|function|unmap
name|bool
name|QFile
operator|::
name|unmap
parameter_list|(
name|uchar
modifier|*
name|address
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileEngine
argument_list|()
operator|&&
name|d
operator|->
name|fileEngine
operator|->
name|supportsExtension
argument_list|(
name|QAbstractFileEngine
operator|::
name|UnMapExtension
argument_list|)
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
name|bool
name|success
init|=
name|d
operator|->
name|fileEngine
operator|->
name|unmap
argument_list|(
name|address
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
name|d
operator|->
name|setError
argument_list|(
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
name|d
operator|->
name|setError
argument_list|(
name|PermissionsError
argument_list|,
name|tr
argument_list|(
literal|"No file engine available or engine does not support UnMapExtension"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the file size (in bytes) \a sz. Returns true if the file if the     resize succeeds; false otherwise. If \a sz is larger than the file     currently is the new bytes will be set to 0, if \a sz is smaller the     file is simply truncated.      \sa size(), setFileName() */
end_comment
begin_function
name|bool
DECL|function|resize
name|QFile
operator|::
name|resize
parameter_list|(
name|qint64
name|sz
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ensureFlushed
argument_list|()
condition|)
return|return
literal|false
return|;
name|fileEngine
argument_list|()
expr_stmt|;
if|if
condition|(
name|isOpen
argument_list|()
operator|&&
name|d
operator|->
name|fileEngine
operator|->
name|pos
argument_list|()
operator|>
name|sz
condition|)
name|seek
argument_list|(
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|->
name|setSize
argument_list|(
name|sz
argument_list|)
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
name|d
operator|->
name|cachedSize
operator|=
name|sz
expr_stmt|;
return|return
literal|true
return|;
block|}
name|d
operator|->
name|cachedSize
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|ResizeError
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets \a fileName to size (in bytes) \a sz. Returns true if the file if     the resize succeeds; false otherwise. If \a sz is larger than \a     fileName currently is the new bytes will be set to 0, if \a sz is     smaller the file is simply truncated.      \sa resize() */
end_comment
begin_function
name|bool
DECL|function|resize
name|QFile
operator|::
name|resize
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|qint64
name|sz
parameter_list|)
block|{
return|return
name|QFile
argument_list|(
name|fileName
argument_list|)
operator|.
name|resize
argument_list|(
name|sz
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the complete OR-ed together combination of     QFile::Permission for the file.      \sa setPermissions(), setFileName() */
end_comment
begin_function
name|QFile
operator|::
name|Permissions
DECL|function|permissions
name|QFile
operator|::
name|permissions
parameter_list|()
specifier|const
block|{
name|QAbstractFileEngine
operator|::
name|FileFlags
name|perms
init|=
name|fileEngine
argument_list|()
operator|->
name|fileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|PermsMask
argument_list|)
operator|&
name|QAbstractFileEngine
operator|::
name|PermsMask
decl_stmt|;
return|return
name|QFile
operator|::
name|Permissions
argument_list|(
operator|(
name|int
operator|)
name|perms
argument_list|)
return|;
comment|//ewww
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the complete OR-ed together combination of     QFile::Permission for \a fileName. */
end_comment
begin_function
name|QFile
operator|::
name|Permissions
DECL|function|permissions
name|QFile
operator|::
name|permissions
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
return|return
name|QFile
argument_list|(
name|fileName
argument_list|)
operator|.
name|permissions
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the permissions for the file to the \a permissions specified.     Returns true if successful, or false if the permissions cannot be     modified.      \sa permissions(), setFileName() */
end_comment
begin_function
name|bool
DECL|function|setPermissions
name|QFile
operator|::
name|setPermissions
parameter_list|(
name|Permissions
name|permissions
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileEngine
argument_list|()
operator|->
name|setPermissions
argument_list|(
name|permissions
argument_list|)
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|PermissionsError
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the permissions for \a fileName file to \a permissions. */
end_comment
begin_function
name|bool
DECL|function|setPermissions
name|QFile
operator|::
name|setPermissions
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|Permissions
name|permissions
parameter_list|)
block|{
return|return
name|QFile
argument_list|(
name|fileName
argument_list|)
operator|.
name|setPermissions
argument_list|(
name|permissions
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|_qfile_writeData
specifier|static
specifier|inline
name|qint64
name|_qfile_writeData
parameter_list|(
name|QAbstractFileEngine
modifier|*
name|engine
parameter_list|,
name|QRingBuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|qint64
name|ret
init|=
name|engine
operator|->
name|write
argument_list|(
name|buffer
operator|->
name|readPointer
argument_list|()
argument_list|,
name|buffer
operator|->
name|nextDataBlockSize
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
name|buffer
operator|->
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     Flushes any buffered data to the file. Returns true if successful;     otherwise returns false. */
end_comment
begin_function
name|bool
DECL|function|flush
name|QFile
operator|::
name|flush
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|fileEngine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::flush: No file engine. Is IODevice open?"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qint64
name|size
init|=
name|d
operator|->
name|writeBuffer
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|_qfile_writeData
argument_list|(
name|d
operator|->
name|fileEngine
argument_list|,
operator|&
name|d
operator|->
name|writeBuffer
argument_list|)
operator|!=
name|size
condition|)
block|{
name|QFile
operator|::
name|FileError
name|err
init|=
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|QFile
operator|::
name|UnspecifiedError
condition|)
name|err
operator|=
name|QFile
operator|::
name|WriteError
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|fileEngine
operator|->
name|flush
argument_list|()
condition|)
block|{
name|QFile
operator|::
name|FileError
name|err
init|=
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|QFile
operator|::
name|UnspecifiedError
condition|)
name|err
operator|=
name|QFile
operator|::
name|WriteError
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Calls QFile::flush() and closes the file. Errors from flush are ignored.    \sa QIODevice::close() */
end_comment
begin_function
name|void
DECL|function|close
name|QFile
operator|::
name|close
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isOpen
argument_list|()
condition|)
return|return;
name|bool
name|flushed
init|=
name|flush
argument_list|()
decl_stmt|;
name|QIODevice
operator|::
name|close
argument_list|()
expr_stmt|;
comment|// reset write buffer
name|d
operator|->
name|lastWasWrite
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|writeBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// keep earlier error from flush
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|->
name|close
argument_list|()
operator|&&
name|flushed
condition|)
name|unsetError
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|flushed
condition|)
name|d
operator|->
name|setError
argument_list|(
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the size of the file.    For regular empty files on Unix (e.g. those in \c /proc), this function   returns 0; the contents of such a file are generated on demand in response   to you calling read(). */
end_comment
begin_function
DECL|function|size
name|qint64
name|QFile
operator|::
name|size
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ensureFlushed
argument_list|()
condition|)
return|return
literal|0
return|;
name|d
operator|->
name|cachedSize
operator|=
name|fileEngine
argument_list|()
operator|->
name|size
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|cachedSize
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|pos
name|qint64
name|QFile
operator|::
name|pos
parameter_list|()
specifier|const
block|{
return|return
name|QIODevice
operator|::
name|pos
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if the end of the file has been reached; otherwise returns   false.    For regular empty files on Unix (e.g. those in \c /proc), this function   returns true, since the file system reports that the size of such a file is   0. Therefore, you should not depend on atEnd() when reading data from such a   file, but rather call read() until no more data can be read. */
end_comment
begin_function
DECL|function|atEnd
name|bool
name|QFile
operator|::
name|atEnd
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFile
argument_list|)
expr_stmt|;
comment|// If there's buffered data left, we're not at the end.
if|if
condition|(
operator|!
name|d
operator|->
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|isOpen
argument_list|()
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|ensureFlushed
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// If the file engine knows best, say what it says.
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|->
name|supportsExtension
argument_list|(
name|QAbstractFileEngine
operator|::
name|AtEndExtension
argument_list|)
condition|)
block|{
comment|// Check if the file engine supports AtEndExtension, and if it does,
comment|// check if the file engine claims to be at the end.
return|return
name|d
operator|->
name|fileEngine
operator|->
name|atEnd
argument_list|()
return|;
block|}
comment|// if it looks like we are at the end, or if size is not cached,
comment|// fall through to bytesAvailable() to make sure.
if|if
condition|(
name|pos
argument_list|()
operator|<
name|d
operator|->
name|cachedSize
condition|)
return|return
literal|false
return|;
comment|// Fall back to checking how much is available (will stat files).
return|return
name|bytesAvailable
argument_list|()
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QFile::seek(qint64 pos)      For random-access devices, this function sets the current position     to \a pos, returning true on success, or false if an error occurred.     For sequential devices, the default behavior is to do nothing and     return false.      Seeking beyond the end of a file:     If the position is beyond the end of a file, then seek() shall not     immediately extend the file. If a write is performed at this position,     then the file shall be extended. The content of the file between the     previous end of file and the newly written data is UNDEFINED and     varies between platforms and file systems. */
end_comment
begin_function
DECL|function|seek
name|bool
name|QFile
operator|::
name|seek
parameter_list|(
name|qint64
name|off
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::seek: IODevice is not open"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|ensureFlushed
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|fileEngine
operator|->
name|seek
argument_list|(
name|off
argument_list|)
operator|||
operator|!
name|QIODevice
operator|::
name|seek
argument_list|(
name|off
argument_list|)
condition|)
block|{
name|QFile
operator|::
name|FileError
name|err
init|=
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|QFile
operator|::
name|UnspecifiedError
condition|)
name|err
operator|=
name|QFile
operator|::
name|PositionError
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|unsetError
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|readLineData
name|qint64
name|QFile
operator|::
name|readLineData
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ensureFlushed
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|qint64
name|read
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|->
name|supportsExtension
argument_list|(
name|QAbstractFileEngine
operator|::
name|FastReadLineExtension
argument_list|)
condition|)
block|{
name|read
operator|=
name|d
operator|->
name|fileEngine
operator|->
name|readLine
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Fall back to QIODevice's readLine implementation if the engine
comment|// cannot do it faster.
name|read
operator|=
name|QIODevice
operator|::
name|readLineData
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
operator|<
name|maxlen
condition|)
block|{
comment|// failed to read all requested, may be at the end of file, stop caching size so that it's rechecked
name|d
operator|->
name|cachedSize
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|read
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|readData
name|qint64
name|QFile
operator|::
name|readData
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
name|unsetError
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ensureFlushed
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|qint64
name|read
init|=
name|d
operator|->
name|fileEngine
operator|->
name|read
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|read
operator|<
literal|0
condition|)
block|{
name|QFile
operator|::
name|FileError
name|err
init|=
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|QFile
operator|::
name|UnspecifiedError
condition|)
name|err
operator|=
name|QFile
operator|::
name|ReadError
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
operator|<
name|len
condition|)
block|{
comment|// failed to read all requested, may be at the end of file, stop caching size so that it's rechecked
name|d
operator|->
name|cachedSize
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|read
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|putCharHelper
name|bool
name|QFilePrivate
operator|::
name|putCharHelper
parameter_list|(
name|char
name|c
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
return|return
name|QIODevicePrivate
operator|::
name|putCharHelper
argument_list|(
name|c
argument_list|)
return|;
else|#
directive|else
comment|// Cutoff for code that doesn't only touch the buffer.
name|int
name|writeBufferSize
init|=
name|writeBuffer
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|openMode
operator|&
name|QIODevice
operator|::
name|Unbuffered
operator|)
operator|||
name|writeBufferSize
operator|+
literal|1
operator|>=
name|QFILE_WRITEBUFFER_SIZE
ifdef|#
directive|ifdef
name|Q_OS_WIN
operator|||
operator|(
operator|(
name|openMode
operator|&
name|QIODevice
operator|::
name|Text
operator|)
operator|&&
name|c
operator|==
literal|'\n'
operator|&&
name|writeBufferSize
operator|+
literal|2
operator|>=
name|QFILE_WRITEBUFFER_SIZE
operator|)
endif|#
directive|endif
condition|)
block|{
return|return
name|QIODevicePrivate
operator|::
name|putCharHelper
argument_list|(
name|c
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|openMode
operator|&
name|QIODevice
operator|::
name|WriteOnly
operator|)
condition|)
block|{
if|if
condition|(
name|openMode
operator|==
name|QIODevice
operator|::
name|NotOpen
condition|)
name|qWarning
argument_list|(
literal|"QIODevice::putChar: Closed device"
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QIODevice::putChar: ReadOnly device"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Make sure the device is positioned correctly.
specifier|const
name|bool
name|sequential
init|=
name|isSequential
argument_list|()
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
name|devicePos
operator|&&
operator|!
name|sequential
operator|&&
operator|!
name|q_func
argument_list|()
operator|->
name|seek
argument_list|(
name|pos
argument_list|)
condition|)
return|return
literal|false
return|;
name|lastWasWrite
operator|=
literal|true
expr_stmt|;
name|int
name|len
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
operator|(
name|openMode
operator|&
name|QIODevice
operator|::
name|Text
operator|)
operator|&&
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|len
expr_stmt|;
operator|*
name|writeBuffer
operator|.
name|reserve
argument_list|(
literal|1
argument_list|)
operator|=
literal|'\r'
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Write to buffer.
operator|*
name|writeBuffer
operator|.
name|reserve
argument_list|(
literal|1
argument_list|)
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|sequential
condition|)
block|{
name|pos
operator|+=
name|len
expr_stmt|;
name|devicePos
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|buffer
operator|.
name|skip
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
name|qint64
DECL|function|writeData
name|QFile
operator|::
name|writeData
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
name|unsetError
argument_list|()
expr_stmt|;
name|d
operator|->
name|lastWasWrite
operator|=
literal|true
expr_stmt|;
name|bool
name|buffered
init|=
operator|!
operator|(
name|d
operator|->
name|openMode
operator|&
name|Unbuffered
operator|)
decl_stmt|;
comment|// Flush buffered data if this read will overflow.
if|if
condition|(
name|buffered
operator|&&
operator|(
name|d
operator|->
name|writeBuffer
operator|.
name|size
argument_list|()
operator|+
name|len
operator|)
operator|>
name|QFILE_WRITEBUFFER_SIZE
condition|)
block|{
if|if
condition|(
operator|!
name|flush
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|// Write directly to the engine if the block size is larger than
comment|// the write buffer size.
if|if
condition|(
operator|!
name|buffered
operator|||
name|len
operator|>
name|QFILE_WRITEBUFFER_SIZE
condition|)
block|{
name|qint64
name|ret
init|=
name|d
operator|->
name|fileEngine
operator|->
name|write
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|QFile
operator|::
name|FileError
name|err
init|=
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|QFile
operator|::
name|UnspecifiedError
condition|)
name|err
operator|=
name|QFile
operator|::
name|WriteError
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|// Write to the buffer.
name|char
modifier|*
name|writePointer
init|=
name|d
operator|->
name|writeBuffer
operator|.
name|reserve
argument_list|(
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
operator|*
name|writePointer
operator|=
operator|*
name|data
expr_stmt|;
else|else
operator|::
name|memcpy
argument_list|(
name|writePointer
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Returns the QIOEngine for this QFile object. */
end_comment
begin_function
DECL|function|fileEngine
name|QAbstractFileEngine
modifier|*
name|QFile
operator|::
name|fileEngine
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|fileEngine
condition|)
name|d
operator|->
name|fileEngine
operator|=
name|QAbstractFileEngine
operator|::
name|create
argument_list|(
name|d
operator|->
name|fileName
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fileEngine
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the file error status.      The I/O device status returns an error code. For example, if open()     returns false, or a read/write operation returns -1, this function can     be called to find out the reason why the operation failed.      \sa unsetError() */
end_comment
begin_function
name|QFile
operator|::
name|FileError
DECL|function|error
name|QFile
operator|::
name|error
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFile
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|error
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the file's error to QFile::NoError.      \sa error() */
end_comment
begin_function
name|void
DECL|function|unsetError
name|QFile
operator|::
name|unsetError
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|NoError
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
