begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qfsfileengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qtemporaryfile.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qfileinfo.h"
end_include
begin_include
include|#
directive|include
file|"private/qiodevice_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qfile_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qfilesystemengine_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qsystemerror_p.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
end_ifdef
begin_define
DECL|macro|tr
define|#
directive|define
name|tr
parameter_list|(
name|X
parameter_list|)
value|QString::fromLatin1(X)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
comment|//************* QFilePrivate
DECL|function|QFilePrivate
name|QFilePrivate
operator|::
name|QFilePrivate
parameter_list|()
block|{ }
end_function
begin_destructor
DECL|function|~QFilePrivate
name|QFilePrivate
operator|::
name|~
name|QFilePrivate
parameter_list|()
block|{ }
end_destructor
begin_function
name|bool
DECL|function|openExternalFile
name|QFilePrivate
operator|::
name|openExternalFile
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|fd
parameter_list|,
name|QFile
operator|::
name|FileHandleFlags
name|handleFlags
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_FSFILEENGINE
name|Q_UNUSED
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
else|#
directive|else
operator|delete
name|fileEngine
expr_stmt|;
name|fileEngine
operator|=
literal|0
expr_stmt|;
name|QFSFileEngine
modifier|*
name|fe
init|=
operator|new
name|QFSFileEngine
decl_stmt|;
name|fileEngine
operator|=
name|fe
expr_stmt|;
return|return
name|fe
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|OpenMode
argument_list|(
name|flags
argument_list|)
argument_list|,
name|fd
argument_list|,
name|handleFlags
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_function
name|bool
DECL|function|openExternalFile
name|QFilePrivate
operator|::
name|openExternalFile
parameter_list|(
name|int
name|flags
parameter_list|,
name|FILE
modifier|*
name|fh
parameter_list|,
name|QFile
operator|::
name|FileHandleFlags
name|handleFlags
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_FSFILEENGINE
name|Q_UNUSED
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|fh
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
else|#
directive|else
operator|delete
name|fileEngine
expr_stmt|;
name|fileEngine
operator|=
literal|0
expr_stmt|;
name|QFSFileEngine
modifier|*
name|fe
init|=
operator|new
name|QFSFileEngine
decl_stmt|;
name|fileEngine
operator|=
name|fe
expr_stmt|;
return|return
name|fe
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|OpenMode
argument_list|(
name|flags
argument_list|)
argument_list|,
name|fh
argument_list|,
name|handleFlags
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|engine
name|QAbstractFileEngine
modifier|*
name|QFilePrivate
operator|::
name|engine
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|fileEngine
condition|)
name|fileEngine
operator|=
name|QAbstractFileEngine
operator|::
name|create
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
return|return
name|fileEngine
return|;
block|}
end_function
begin_comment
comment|//************* QFile
end_comment
begin_comment
comment|/*!     \class QFile     \inmodule QtCore     \brief The QFile class provides an interface for reading from and writing to files.      \ingroup io      \reentrant      QFile is an I/O device for reading and writing text and binary     files and \l{The Qt Resource System}{resources}. A QFile may be     used by itself or, more conveniently, with a QTextStream or     QDataStream.      The file name is usually passed in the constructor, but it can be     set at any time using setFileName(). QFile expects the file     separator to be '/' regardless of operating system. The use of     other separators (e.g., '\\') is not supported.      You can check for a file's existence using exists(), and remove a     file using remove(). (More advanced file system related operations     are provided by QFileInfo and QDir.)      The file is opened with open(), closed with close(), and flushed     with flush(). Data is usually read and written using QDataStream     or QTextStream, but you can also call the QIODevice-inherited     functions read(), readLine(), readAll(), write(). QFile also     inherits getChar(), putChar(), and ungetChar(), which work one     character at a time.      The size of the file is returned by size(). You can get the     current file position using pos(), or move to a new file position     using seek(). If you've reached the end of the file, atEnd()     returns \c true.      \section1 Reading Files Directly      The following example reads a text file line by line:      \snippet file/file.cpp 0      The QIODevice::Text flag passed to open() tells Qt to convert     Windows-style line terminators ("\\r\\n") into C++-style     terminators ("\\n"). By default, QFile assumes binary, i.e. it     doesn't perform any conversion on the bytes stored in the file.      \section1 Using Streams to Read Files      The next example uses QTextStream to read a text file     line by line:      \snippet file/file.cpp 1      QTextStream takes care of converting the 8-bit data stored on     disk into a 16-bit Unicode QString. By default, it assumes that     the user system's local 8-bit encoding is used (e.g., UTF-8     on most unix based operating systems; see QTextCodec::codecForLocale() for     details). This can be changed using \l QTextStream::setCodec().      To write text, we can use operator<<(), which is overloaded to     take a QTextStream on the left and various data types (including     QString) on the right:      \snippet file/file.cpp 2      QDataStream is similar, in that you can use operator<<() to write     data and operator>>() to read it back. See the class     documentation for details.      When you use QFile, QFileInfo, and QDir to access the file system     with Qt, you can use Unicode file names. On Unix, these file     names are converted to an 8-bit encoding. If you want to use     standard C++ APIs (\c<cstdio> or \c<iostream>) or     platform-specific APIs to access files instead of QFile, you can     use the encodeName() and decodeName() functions to convert     between Unicode file names and 8-bit file names.      On Unix, there are some special system files (e.g. in \c /proc) for which     size() will always return 0, yet you may still be able to read more data     from such a file; the data is generated in direct response to you calling     read(). In this case, however, you cannot use atEnd() to determine if     there is more data to read (since atEnd() will return true for a file that     claims to have size 0). Instead, you should either call readAll(), or call     read() or readLine() repeatedly until no more data can be read. The next     example uses QTextStream to read \c /proc/modules line by line:      \snippet file/file.cpp 3      \section1 Signals      Unlike other QIODevice implementations, such as QTcpSocket, QFile does not     emit the aboutToClose(), bytesWritten(), or readyRead() signals. This     implementation detail means that QFile is not suitable for reading and     writing certain types of files, such as device files on Unix platforms.      \section1 Platform Specific Issues      File permissions are handled differently on Unix-like systems and     Windows.  In a non \l{QIODevice::isWritable()}{writable}     directory on Unix-like systems, files cannot be created. This is not always     the case on Windows, where, for instance, the 'My Documents'     directory usually is not writable, but it is still possible to     create files in it.      Qt's understanding of file permissions is limited, which affects especially     the \l QFile::setPermissions() function. On Windows, Qt will set only the     legacy read-only flag, and that only when none of the Write* flags are     passed. Qt does not manipulate access control lists (ACLs), which makes this     function mostly useless for NTFS volumes. It may still be of use for USB     sticks that use VFAT file systems. POSIX ACLs are not manipulated, either.      \sa QTextStream, QDataStream, QFileInfo, QDir, {The Qt Resource System} */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
end_ifdef
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|()
member_init_list|:
name|QFileDevice
argument_list|(
operator|*
operator|new
name|QFilePrivate
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|QFileDevice
argument_list|(
operator|*
operator|new
name|QFilePrivate
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|fileName
operator|=
name|name
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|(
name|QFilePrivate
modifier|&
name|dd
parameter_list|)
member_init_list|:
name|QFileDevice
argument_list|(
name|dd
argument_list|)
block|{ }
end_constructor
begin_else
else|#
directive|else
end_else
begin_comment
comment|/*!     Constructs a QFile object. */
end_comment
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|()
member_init_list|:
name|QFileDevice
argument_list|(
operator|*
operator|new
name|QFilePrivate
argument_list|,
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a new file object with the given \a parent. */
end_comment
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QFileDevice
argument_list|(
operator|*
operator|new
name|QFilePrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a new file object to represent the file with the given \a name. */
end_comment
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
member_init_list|:
name|QFileDevice
argument_list|(
operator|*
operator|new
name|QFilePrivate
argument_list|,
literal|0
argument_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileName
operator|=
name|name
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a new file object with the given \a parent to represent the     file with the specified \a name. */
end_comment
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QFileDevice
argument_list|(
operator|*
operator|new
name|QFilePrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileName
operator|=
name|name
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QFile
name|QFile
operator|::
name|QFile
parameter_list|(
name|QFilePrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QFileDevice
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Destroys the file object, closing it if necessary. */
end_comment
begin_destructor
DECL|function|~QFile
name|QFile
operator|::
name|~
name|QFile
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the name set by setFileName() or to the QFile     constructors.      \sa setFileName(), QFileInfo::fileName() */
end_comment
begin_function
DECL|function|fileName
name|QString
name|QFile
operator|::
name|fileName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFile
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|engine
argument_list|()
operator|->
name|fileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|DefaultName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the \a name of the file. The name can have no path, a     relative path, or an absolute path.      Do not call this function if the file has already been opened.      If the file name has no path or a relative path, the path used     will be the application's current directory path     \e{at the time of the open()} call.      Example:     \snippet code/src_corelib_io_qfile.cpp 0      Note that the directory separator "/" works for all operating     systems supported by Qt.      \sa fileName(), QFileInfo, QDir */
end_comment
begin_function
name|void
DECL|function|setFileName
name|QFile
operator|::
name|setFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::setFileName: File (%s) is already opened"
argument_list|,
name|qPrintable
argument_list|(
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|fileEngine
condition|)
block|{
comment|//get a new file engine later
operator|delete
name|d
operator|->
name|fileEngine
expr_stmt|;
name|d
operator|->
name|fileEngine
operator|=
literal|0
expr_stmt|;
block|}
name|d
operator|->
name|fileName
operator|=
name|name
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QFile::decodeName(const char *localFileName)      \overload      Returns the Unicode version of the given \a localFileName. See     encodeName() for details. */
end_comment
begin_comment
comment|/*!     \fn QByteArray QFile::encodeName(const QString&fileName)      Converts \a fileName to the local 8-bit     encoding determined by the user's locale. This is sufficient for     file names that the user chooses. File names hard-coded into the     application should only use 7-bit ASCII filename characters.      \sa decodeName() */
end_comment
begin_comment
comment|/*!     \typedef QFile::EncoderFn     \obsolete      This is a typedef for a pointer to a function with the following     signature:      \snippet code/src_corelib_io_qfile.cpp 1      \sa setEncodingFunction(), encodeName() */
end_comment
begin_comment
comment|/*!     \fn QString QFile::decodeName(const QByteArray&localFileName)      This does the reverse of QFile::encodeName() using \a localFileName.      \sa encodeName() */
end_comment
begin_comment
comment|/*!     \fn void QFile::setEncodingFunction(EncoderFn function)     \obsolete      This function does nothing. It is provided for compatibility with Qt 4 code     that attempted to set a different encoding function for file names. That     feature is flawed and no longer supported in Qt 5.      \sa encodeName(), setDecodingFunction() */
end_comment
begin_comment
comment|/*!     \typedef QFile::DecoderFn      This is a typedef for a pointer to a function with the following     signature:      \snippet code/src_corelib_io_qfile.cpp 2      \sa setDecodingFunction() */
end_comment
begin_comment
comment|/*!     \fn void QFile::setDecodingFunction(DecoderFn function)     \obsolete      This function does nothing. It is provided for compatibility with Qt 4 code     that attempted to set a different decoding function for file names. That     feature is flawed and no longer supported in Qt 5.      \sa setEncodingFunction(), decodeName() */
end_comment
begin_comment
comment|/*!     \overload      Returns \c true if the file specified by fileName() exists; otherwise     returns \c false.      \sa fileName(), setFileName() */
end_comment
begin_function
name|bool
DECL|function|exists
name|QFile
operator|::
name|exists
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFile
argument_list|)
expr_stmt|;
comment|// 0x1000000 = QAbstractFileEngine::Refresh, forcing an update
return|return
operator|(
name|d
operator|->
name|engine
argument_list|()
operator|->
name|fileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|FlagsMask
operator||
name|QAbstractFileEngine
operator|::
name|FileFlag
argument_list|(
literal|0x1000000
argument_list|)
argument_list|)
operator|&
name|QAbstractFileEngine
operator|::
name|ExistsFlag
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the file specified by \a fileName exists; otherwise     returns \c false.      \note If \a fileName is a symlink that points to a non-existing     file, false is returned. */
end_comment
begin_function
name|bool
DECL|function|exists
name|QFile
operator|::
name|exists
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
return|return
name|QFileInfo
operator|::
name|exists
argument_list|(
name|fileName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QFile::symLinkTarget() const     \since 4.2     \overload      Returns the absolute path of the file or directory a symlink (or shortcut     on Windows) points to, or a an empty string if the object isn't a symbolic     link.      This name may not represent an existing file; it is only a string.     QFile::exists() returns \c true if the symlink points to an existing file.      \sa fileName(), setFileName() */
end_comment
begin_comment
comment|/*!     \obsolete      Use symLinkTarget() instead. */
end_comment
begin_function
name|QString
DECL|function|readLink
name|QFile
operator|::
name|readLink
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFile
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|engine
argument_list|()
operator|->
name|fileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|LinkName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn static QString QFile::symLinkTarget(const QString&fileName)     \since 4.2      Returns the absolute path of the file or directory referred to by the     symlink (or shortcut on Windows) specified by \a fileName, or returns an     empty string if the \a fileName does not correspond to a symbolic link.      This name may not represent an existing file; it is only a string.     QFile::exists() returns \c true if the symlink points to an existing file. */
end_comment
begin_comment
comment|/*!     \obsolete      Use symLinkTarget() instead. */
end_comment
begin_function
name|QString
DECL|function|readLink
name|QFile
operator|::
name|readLink
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
return|return
name|QFileInfo
argument_list|(
name|fileName
argument_list|)
operator|.
name|readLink
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the file specified by fileName(). Returns \c true if successful;     otherwise returns \c false.      The file is closed before it is removed.      \sa setFileName() */
end_comment
begin_function
name|bool
DECL|function|remove
name|QFile
operator|::
name|remove
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::remove: Empty or null file name"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|unsetError
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
argument_list|()
operator|==
name|QFile
operator|::
name|NoError
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|engine
argument_list|()
operator|->
name|remove
argument_list|()
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RemoveError
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Removes the file specified by the \a fileName given.      Returns \c true if successful; otherwise returns \c false.      \sa remove() */
end_comment
begin_function
name|bool
DECL|function|remove
name|QFile
operator|::
name|remove
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
return|return
name|QFile
argument_list|(
name|fileName
argument_list|)
operator|.
name|remove
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Renames the file currently specified by fileName() to \a newName.     Returns \c true if successful; otherwise returns \c false.      If a file with the name \a newName already exists, rename() returns \c false     (i.e., QFile will not overwrite it).      The file is closed before it is renamed.      If the rename operation fails, Qt will attempt to copy this file's     contents to \a newName, and then remove this file, keeping only     \a newName. If that copy operation fails or this file can't be removed,     the destination file \a newName is removed to restore the old state.      \sa setFileName() */
end_comment
begin_function
name|bool
DECL|function|rename
name|QFile
operator|::
name|rename
parameter_list|(
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::rename: Empty or null file name"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|fileName
operator|==
name|newName
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|tr
argument_list|(
literal|"Destination file is the same file."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|exists
argument_list|()
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|tr
argument_list|(
literal|"Source file does not exist."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// If the file exists and it is a case-changing rename ("foo" -> "Foo"),
comment|// compare Ids to make sure it really is a different file.
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|newName
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|fileName
operator|.
name|compare
argument_list|(
name|newName
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|||
name|QFileSystemEngine
operator|::
name|id
argument_list|(
name|QFileSystemEntry
argument_list|(
name|d
operator|->
name|fileName
argument_list|)
argument_list|)
operator|!=
name|QFileSystemEngine
operator|::
name|id
argument_list|(
name|QFileSystemEntry
argument_list|(
name|newName
argument_list|)
argument_list|)
condition|)
block|{
comment|// ### Race condition. If a file is moved in after this, it /will/ be
comment|// overwritten. On Unix, the proper solution is to use hardlinks:
comment|// return ::link(old, new)&& ::remove(old);
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|tr
argument_list|(
literal|"Destination file exists"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_TEMPORARYFILE
comment|// This #ifndef disables the workaround it encloses. Therefore, this configuration is not recommended.
ifdef|#
directive|ifdef
name|Q_OS_LINUX
comment|// rename() on Linux simply does nothing when renaming "foo" to "Foo" on a case-insensitive
comment|// FS, such as FAT32. Move the file away and rename in 2 steps to work around.
name|QTemporaryFile
name|tempFile
argument_list|(
name|d
operator|->
name|fileName
operator|+
name|QStringLiteral
argument_list|(
literal|".XXXXXX"
argument_list|)
argument_list|)
decl_stmt|;
name|tempFile
operator|.
name|setAutoRemove
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tempFile
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadWrite
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|tempFile
operator|.
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|tempFile
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|engine
argument_list|()
operator|->
name|rename
argument_list|(
name|tempFile
operator|.
name|fileName
argument_list|()
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|tr
argument_list|(
literal|"Error while renaming."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|tempFile
operator|.
name|rename
argument_list|(
name|newName
argument_list|)
condition|)
block|{
name|d
operator|->
name|fileEngine
operator|->
name|setFileName
argument_list|(
name|newName
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileName
operator|=
name|newName
expr_stmt|;
return|return
literal|true
return|;
block|}
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|tempFile
operator|.
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
comment|// We need to restore the original file.
if|if
condition|(
operator|!
name|tempFile
operator|.
name|rename
argument_list|(
name|d
operator|->
name|fileName
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|errorString
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
operator|+
name|tr
argument_list|(
literal|"Unable to restore from %1: %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|tempFile
operator|.
name|fileName
argument_list|()
argument_list|)
argument_list|,
name|tempFile
operator|.
name|errorString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
endif|#
directive|endif
comment|// Q_OS_LINUX
endif|#
directive|endif
comment|// QT_NO_TEMPORARYFILE
block|}
name|unsetError
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
argument_list|()
operator|==
name|QFile
operator|::
name|NoError
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|engine
argument_list|()
operator|->
name|rename
argument_list|(
name|newName
argument_list|)
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
comment|// engine was able to handle the new name so we just reset it
name|d
operator|->
name|fileEngine
operator|->
name|setFileName
argument_list|(
name|newName
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileName
operator|=
name|newName
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|isSequential
argument_list|()
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|tr
argument_list|(
literal|"Will not rename sequential file using block copy"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QFile
name|out
argument_list|(
name|newName
argument_list|)
decl_stmt|;
if|if
condition|(
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
if|if
condition|(
name|out
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
operator||
name|QIODevice
operator|::
name|Truncate
argument_list|)
condition|)
block|{
name|bool
name|error
init|=
literal|false
decl_stmt|;
name|char
name|block
index|[
literal|4096
index|]
decl_stmt|;
name|qint64
name|bytes
decl_stmt|;
while|while
condition|(
operator|(
name|bytes
operator|=
name|read
argument_list|(
name|block
argument_list|,
sizeof|sizeof
argument_list|(
name|block
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bytes
operator|!=
name|out
operator|.
name|write
argument_list|(
name|block
argument_list|,
name|bytes
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|out
operator|.
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bytes
operator|==
operator|-
literal|1
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
operator|!
name|remove
argument_list|()
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|tr
argument_list|(
literal|"Cannot remove source file"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|out
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|fileEngine
operator|->
name|setFileName
argument_list|(
name|newName
argument_list|)
expr_stmt|;
name|setPermissions
argument_list|(
name|permissions
argument_list|()
argument_list|)
expr_stmt|;
name|unsetError
argument_list|()
expr_stmt|;
name|setFileName
argument_list|(
name|newName
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|()
expr_stmt|;
return|return
operator|!
name|error
return|;
block|}
name|close
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|out
operator|.
name|isOpen
argument_list|()
condition|?
name|errorString
argument_list|()
else|:
name|out
operator|.
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Renames the file \a oldName to \a newName. Returns \c true if     successful; otherwise returns \c false.      If a file with the name \a newName already exists, rename() returns \c false     (i.e., QFile will not overwrite it).      \sa rename() */
end_comment
begin_function
name|bool
DECL|function|rename
name|QFile
operator|::
name|rename
parameter_list|(
specifier|const
name|QString
modifier|&
name|oldName
parameter_list|,
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
return|return
name|QFile
argument_list|(
name|oldName
argument_list|)
operator|.
name|rename
argument_list|(
name|newName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!      Creates a link named \a linkName that points to the file currently specified by     fileName().  What a link is depends on the underlying filesystem (be it a     shortcut on Windows or a symbolic link on Unix). Returns \c true if successful;     otherwise returns \c false.      This function will not overwrite an already existing entity in the file system;     in this case, \c link() will return false and set \l{QFile::}{error()} to     return \l{QFile::}{RenameError}.      \note To create a valid link on Windows, \a linkName must have a \c{.lnk} file extension.      \sa setFileName() */
end_comment
begin_function
name|bool
DECL|function|link
name|QFile
operator|::
name|link
parameter_list|(
specifier|const
name|QString
modifier|&
name|linkName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::link: Empty or null file name"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QFileInfo
name|fi
argument_list|(
name|linkName
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|engine
argument_list|()
operator|->
name|link
argument_list|(
name|fi
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|RenameError
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Creates a link named \a linkName that points to the file \a fileName. What a link is     depends on the underlying filesystem (be it a shortcut on Windows     or a symbolic link on Unix). Returns \c true if successful; otherwise     returns \c false.      \sa link() */
end_comment
begin_function
name|bool
DECL|function|link
name|QFile
operator|::
name|link
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|linkName
parameter_list|)
block|{
return|return
name|QFile
argument_list|(
name|fileName
argument_list|)
operator|.
name|link
argument_list|(
name|linkName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Copies the file currently specified by fileName() to a file called     \a newName.  Returns \c true if successful; otherwise returns \c false.      Note that if a file with the name \a newName already exists,     copy() returns \c false (i.e. QFile will not overwrite it).      The source file is closed before it is copied.      \sa setFileName() */
end_comment
begin_function
name|bool
DECL|function|copy
name|QFile
operator|::
name|copy
parameter_list|(
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::copy: Empty or null file name"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|newName
argument_list|)
condition|)
block|{
comment|// ### Race condition. If a file is moved in after this, it /will/ be
comment|// overwritten. On Unix, the proper solution is to use hardlinks:
comment|// return ::link(old, new)&& ::remove(old); See also rename().
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|CopyError
argument_list|,
name|tr
argument_list|(
literal|"Destination file exists"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|unsetError
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
argument_list|()
operator|==
name|QFile
operator|::
name|NoError
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|engine
argument_list|()
operator|->
name|copy
argument_list|(
name|newName
argument_list|)
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|bool
name|error
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|error
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|CopyError
argument_list|,
name|tr
argument_list|(
literal|"Cannot open %1 for input"
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|fileTemplate
init|=
name|QLatin1String
argument_list|(
literal|"%1/qt_temp.XXXXXX"
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_NO_TEMPORARYFILE
name|QFile
name|out
argument_list|(
name|fileTemplate
operator|.
name|arg
argument_list|(
name|QFileInfo
argument_list|(
name|newName
argument_list|)
operator|.
name|path
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|out
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadWrite
argument_list|)
condition|)
name|error
operator|=
literal|true
expr_stmt|;
else|#
directive|else
name|QTemporaryFile
name|out
argument_list|(
name|fileTemplate
operator|.
name|arg
argument_list|(
name|QFileInfo
argument_list|(
name|newName
argument_list|)
operator|.
name|path
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|out
operator|.
name|open
argument_list|()
condition|)
block|{
name|out
operator|.
name|setFileTemplate
argument_list|(
name|fileTemplate
operator|.
name|arg
argument_list|(
name|QDir
operator|::
name|tempPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
operator|.
name|open
argument_list|()
condition|)
name|error
operator|=
literal|true
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|CopyError
argument_list|,
name|tr
argument_list|(
literal|"Cannot open for output"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|block
index|[
literal|4096
index|]
decl_stmt|;
name|qint64
name|totalRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|atEnd
argument_list|()
condition|)
block|{
name|qint64
name|in
init|=
name|read
argument_list|(
name|block
argument_list|,
sizeof|sizeof
argument_list|(
name|block
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|in
operator|<=
literal|0
condition|)
break|break;
name|totalRead
operator|+=
name|in
expr_stmt|;
if|if
condition|(
name|in
operator|!=
name|out
operator|.
name|write
argument_list|(
name|block
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|CopyError
argument_list|,
name|tr
argument_list|(
literal|"Failure to write block"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|totalRead
operator|!=
name|size
argument_list|()
condition|)
block|{
comment|// Unable to read from the source. The error string is
comment|// already set from read().
name|error
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
operator|!
name|out
operator|.
name|rename
argument_list|(
name|newName
argument_list|)
condition|)
block|{
name|error
operator|=
literal|true
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|CopyError
argument_list|,
name|tr
argument_list|(
literal|"Cannot create %1 for output"
argument_list|)
operator|.
name|arg
argument_list|(
name|newName
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_NO_TEMPORARYFILE
if|if
condition|(
name|error
condition|)
name|out
operator|.
name|remove
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|error
condition|)
name|out
operator|.
name|setAutoRemove
argument_list|(
literal|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|QFile
operator|::
name|setPermissions
argument_list|(
name|newName
argument_list|,
name|permissions
argument_list|()
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
name|unsetError
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Copies the file \a fileName to \a newName. Returns \c true if successful;     otherwise returns \c false.      If a file with the name \a newName already exists, copy() returns \c false     (i.e., QFile will not overwrite it).      \sa rename() */
end_comment
begin_function
name|bool
DECL|function|copy
name|QFile
operator|::
name|copy
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|newName
parameter_list|)
block|{
return|return
name|QFile
argument_list|(
name|fileName
argument_list|)
operator|.
name|copy
argument_list|(
name|newName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Opens the file using OpenMode \a mode, returning true if successful;     otherwise false.      The \a mode must be QIODevice::ReadOnly, QIODevice::WriteOnly, or     QIODevice::ReadWrite. It may also have additional flags, such as     QIODevice::Text and QIODevice::Unbuffered.      \note In \l{QIODevice::}{WriteOnly} or \l{QIODevice::}{ReadWrite}     mode, if the relevant file does not already exist, this function     will try to create a new file before opening it.      \sa QIODevice::OpenMode, setFileName() */
end_comment
begin_function
DECL|function|open
name|bool
name|QFile
operator|::
name|open
parameter_list|(
name|OpenMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::open: File (%s) already open"
argument_list|,
name|qPrintable
argument_list|(
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mode
operator|&
name|Append
condition|)
name|mode
operator||=
name|WriteOnly
expr_stmt|;
name|unsetError
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
operator|(
name|ReadOnly
operator||
name|WriteOnly
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QIODevice::open: File access not specified"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// QIODevice provides the buffering, so there's no need to request it from the file engine.
if|if
condition|(
name|d
operator|->
name|engine
argument_list|()
operator|->
name|open
argument_list|(
name|mode
operator||
name|QIODevice
operator|::
name|Unbuffered
argument_list|)
condition|)
block|{
name|QIODevice
operator|::
name|open
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|Append
condition|)
name|seek
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|QFile
operator|::
name|FileError
name|err
init|=
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|QFile
operator|::
name|UnspecifiedError
condition|)
name|err
operator|=
name|QFile
operator|::
name|OpenError
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Opens the existing file handle \a fh in the given \a mode.     \a handleFlags may be used to specify additional options.     Returns \c true if successful; otherwise returns \c false.      Example:     \snippet code/src_corelib_io_qfile.cpp 3      When a QFile is opened using this function, behaviour of close() is     controlled by the AutoCloseHandle flag.     If AutoCloseHandle is specified, and this function succeeds,     then calling close() closes the adopted handle.     Otherwise, close() does not actually close the file, but only flushes it.      \b{Warning:}     \list 1         \li If \a fh does not refer to a regular file, e.g., it is \c stdin,            \c stdout, or \c stderr, you may not be able to seek(). size()            returns \c 0 in those cases. See QIODevice::isSequential() for            more information.         \li Since this function opens the file without specifying the file name,            you cannot use this QFile with a QFileInfo.     \endlist      \note For Windows CE you may not be able to call resize().      \sa close()      \b{Note for the Windows Platform}      \a fh must be opened in binary mode (i.e., the mode string must contain     'b', as in "rb" or "wb") when accessing files and other random-access     devices. Qt will translate the end-of-line characters if you pass     QIODevice::Text to \a mode. Sequential devices, such as stdin and stdout,     are unaffected by this limitation.      You need to enable support for console applications in order to use the     stdin, stdout and stderr streams at the console. To do this, add the     following declaration to your application's project file:      \snippet code/src_corelib_io_qfile.cpp 4 */
end_comment
begin_function
DECL|function|open
name|bool
name|QFile
operator|::
name|open
parameter_list|(
name|FILE
modifier|*
name|fh
parameter_list|,
name|OpenMode
name|mode
parameter_list|,
name|FileHandleFlags
name|handleFlags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::open: File (%s) already open"
argument_list|,
name|qPrintable
argument_list|(
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mode
operator|&
name|Append
condition|)
name|mode
operator||=
name|WriteOnly
expr_stmt|;
name|unsetError
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
operator|(
name|ReadOnly
operator||
name|WriteOnly
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::open: File access not specified"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|openExternalFile
argument_list|(
name|mode
argument_list|,
name|fh
argument_list|,
name|handleFlags
argument_list|)
condition|)
block|{
name|QIODevice
operator|::
name|open
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|Append
operator|)
operator|&&
operator|!
name|isSequential
argument_list|()
condition|)
block|{
name|qint64
name|pos
init|=
operator|(
name|qint64
operator|)
name|QT_FTELL
argument_list|(
name|fh
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Skip redundant checks in QFileDevice::seek().
name|QIODevice
operator|::
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Opens the existing file descriptor \a fd in the given \a mode.     \a handleFlags may be used to specify additional options.     Returns \c true if successful; otherwise returns \c false.      When a QFile is opened using this function, behaviour of close() is     controlled by the AutoCloseHandle flag.     If AutoCloseHandle is specified, and this function succeeds,     then calling close() closes the adopted handle.     Otherwise, close() does not actually close the file, but only flushes it.      The QFile that is opened using this function is automatically set     to be in raw mode; this means that the file input/output functions     are slow. If you run into performance issues, you should try to     use one of the other open functions.      \warning If \a fd is not a regular file, e.g, it is 0 (\c stdin),     1 (\c stdout), or 2 (\c stderr), you may not be able to seek(). In     those cases, size() returns \c 0.  See QIODevice::isSequential()     for more information.      \warning For Windows CE you may not be able to call seek(), and size()              returns \c 0.      \warning Since this function opens the file without specifying the file name,              you cannot use this QFile with a QFileInfo.      \sa close() */
end_comment
begin_function
DECL|function|open
name|bool
name|QFile
operator|::
name|open
parameter_list|(
name|int
name|fd
parameter_list|,
name|OpenMode
name|mode
parameter_list|,
name|FileHandleFlags
name|handleFlags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::open: File (%s) already open"
argument_list|,
name|qPrintable
argument_list|(
name|fileName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mode
operator|&
name|Append
condition|)
name|mode
operator||=
name|WriteOnly
expr_stmt|;
name|unsetError
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
operator|(
name|ReadOnly
operator||
name|WriteOnly
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFile::open: File access not specified"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|openExternalFile
argument_list|(
name|mode
argument_list|,
name|fd
argument_list|,
name|handleFlags
argument_list|)
condition|)
block|{
name|QIODevice
operator|::
name|open
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|Append
operator|)
operator|&&
operator|!
name|isSequential
argument_list|()
condition|)
block|{
name|qint64
name|pos
init|=
operator|(
name|qint64
operator|)
name|QT_LSEEK
argument_list|(
name|fd
argument_list|,
name|QT_OFF_T
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Skip redundant checks in QFileDevice::seek().
name|QIODevice
operator|::
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|resize
name|bool
name|QFile
operator|::
name|resize
parameter_list|(
name|qint64
name|sz
parameter_list|)
block|{
return|return
name|QFileDevice
operator|::
name|resize
argument_list|(
name|sz
argument_list|)
return|;
comment|// for now
block|}
end_function
begin_comment
comment|/*!     \overload      Sets \a fileName to size (in bytes) \a sz. Returns \c true if the file if     the resize succeeds; false otherwise. If \a sz is larger than \a     fileName currently is the new bytes will be set to 0, if \a sz is     smaller the file is simply truncated.      \sa resize() */
end_comment
begin_function
name|bool
DECL|function|resize
name|QFile
operator|::
name|resize
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|qint64
name|sz
parameter_list|)
block|{
return|return
name|QFile
argument_list|(
name|fileName
argument_list|)
operator|.
name|resize
argument_list|(
name|sz
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|permissions
name|QFile
operator|::
name|Permissions
name|QFile
operator|::
name|permissions
parameter_list|()
specifier|const
block|{
return|return
name|QFileDevice
operator|::
name|permissions
argument_list|()
return|;
comment|// for now
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the complete OR-ed together combination of     QFile::Permission for \a fileName. */
end_comment
begin_function
name|QFile
operator|::
name|Permissions
DECL|function|permissions
name|QFile
operator|::
name|permissions
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
return|return
name|QFile
argument_list|(
name|fileName
argument_list|)
operator|.
name|permissions
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the permissions for the file to the \a permissions specified.     Returns \c true if successful, or \c false if the permissions cannot be     modified.      \warning This function does not manipulate ACLs, which may limit its     effectiveness.      \sa permissions(), setFileName() */
end_comment
begin_function
DECL|function|setPermissions
name|bool
name|QFile
operator|::
name|setPermissions
parameter_list|(
name|Permissions
name|permissions
parameter_list|)
block|{
return|return
name|QFileDevice
operator|::
name|setPermissions
argument_list|(
name|permissions
argument_list|)
return|;
comment|// for now
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the permissions for \a fileName file to \a permissions. */
end_comment
begin_function
name|bool
DECL|function|setPermissions
name|QFile
operator|::
name|setPermissions
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|Permissions
name|permissions
parameter_list|)
block|{
return|return
name|QFile
argument_list|(
name|fileName
argument_list|)
operator|.
name|setPermissions
argument_list|(
name|permissions
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|size
name|qint64
name|QFile
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
name|QFileDevice
operator|::
name|size
argument_list|()
return|;
comment|// for now
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
