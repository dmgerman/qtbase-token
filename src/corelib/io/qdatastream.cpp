begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream_p.h"
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DATASTREAM
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qbuffer.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|"qendian.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QDataStream     \inmodule QtCore     \reentrant     \brief The QDataStream class provides serialization of binary data     to a QIODevice.      \ingroup io       A data stream is a binary stream of encoded information which is     100% independent of the host computer's operating system, CPU or     byte order. For example, a data stream that is written by a PC     under Windows can be read by a Sun SPARC running Solaris.      You can also use a data stream to read/write \l{raw}{raw     unencoded binary data}. If you want a "parsing" input stream, see     QTextStream.      The QDataStream class implements the serialization of C++'s basic     data types, like \c char, \c short, \c int, \c{char *}, etc.     Serialization of more complex data is accomplished by breaking up     the data into primitive units.      A data stream cooperates closely with a QIODevice. A QIODevice     represents an input/output medium one can read data from and write     data to. The QFile class is an example of an I/O device.      Example (write binary data to a stream):      \snippet code/src_corelib_io_qdatastream.cpp 0      Example (read binary data from a stream):      \snippet code/src_corelib_io_qdatastream.cpp 1      Each item written to the stream is written in a predefined binary     format that varies depending on the item's type. Supported Qt     types include QBrush, QColor, QDateTime, QFont, QPixmap, QString,     QVariant and many others. For the complete list of all Qt types     supporting data streaming see \l{Serializing Qt Data Types}.      For integers it is best to always cast to a Qt integer type for     writing, and to read back into the same Qt integer type. This     ensures that you get integers of the size you want and insulates     you from compiler and platform differences.      To take one example, a \c{char *} string is written as a 32-bit     integer equal to the length of the string including the '\\0' byte,     followed by all the characters of the string including the     '\\0' byte. When reading a \c{char *} string, 4 bytes are read to     create the 32-bit length value, then that many characters for the     \c {char *} string including the '\\0' terminator are read.      The initial I/O device is usually set in the constructor, but can be     changed with setDevice(). If you've reached the end of the data     (or if there is no I/O device set) atEnd() will return true.      \section1 Versioning      QDataStream's binary format has evolved since Qt 1.0, and is     likely to continue evolving to reflect changes done in Qt. When     inputting or outputting complex types, it's very important to     make sure that the same version of the stream (version()) is used     for reading and writing. If you need both forward and backward     compatibility, you can hardcode the version number in the     application:      \snippet code/src_corelib_io_qdatastream.cpp 2      If you are producing a new binary data format, such as a file     format for documents created by your application, you could use a     QDataStream to write the data in a portable format. Typically, you     would write a brief header containing a magic string and a version     number to give yourself room for future expansion. For example:      \snippet code/src_corelib_io_qdatastream.cpp 3      Then read it in with:      \snippet code/src_corelib_io_qdatastream.cpp 4      You can select which byte order to use when serializing data. The     default setting is big endian (MSB first). Changing it to little     endian breaks the portability (unless the reader also changes to     little endian). We recommend keeping this setting unless you have     special requirements.      \target raw     \section1 Reading and writing raw binary data      You may wish to read/write your own raw binary data to/from the     data stream directly. Data may be read from the stream into a     preallocated \c{char *} using readRawData(). Similarly data can be     written to the stream using writeRawData(). Note that any     encoding/decoding of the data must be done by you.      A similar pair of functions is readBytes() and writeBytes(). These     differ from their \e raw counterparts as follows: readBytes()     reads a quint32 which is taken to be the length of the data to be     read, then that number of bytes is read into the preallocated     \c{char *}; writeBytes() writes a quint32 containing the length of the     data, followed by the data. Note that any encoding/decoding of     the data (apart from the length quint32) must be done by you.      \section1 Reading and writing Qt collection classes      The Qt container classes can also be serialized to a QDataStream.     These include QList, QLinkedList, QVector, QSet, QHash, and QMap.     The stream operators are declared as non-members of the classes.      \target Serializing Qt Classes     \section1 Reading and writing other Qt classes.      In addition to the overloaded stream operators documented here,     any Qt classes that you might want to serialize to a QDataStream     will have appropriate stream operators declared as non-member of     the class:      \code     QDataStream&operator<<(QDataStream&, const QXxx&);     QDataStream&operator>>(QDataStream&, QXxx&);     \endcode      For example, here are the stream operators declared as non-members     of the QImage class:      \code     QDataStream& operator<< (QDataStream& stream, const QImage& image);     QDataStream& operator>> (QDataStream& stream, QImage& image);     \endcode      To see if your favorite Qt class has similar stream operators     defined, check the \b {Related Non-Members} section of the     class's documentation page.      \sa QTextStream, QVariant */
comment|/*!     \enum QDataStream::ByteOrder      The byte order used for reading/writing the data.      \value BigEndian Most significant byte first (the default)     \value LittleEndian Least significant byte first */
comment|/*!   \enum QDataStream::FloatingPointPrecision    The precision of floating point numbers used for reading/writing the data. This will only have   an effect if the version of the data stream is Qt_4_6 or higher.    \warning The floating point precision must be set to the same value on the object that writes   and the object that reads the data stream.    \value SinglePrecision All floating point numbers in the data stream have 32-bit precision.   \value DoublePrecision All floating point numbers in the data stream have 64-bit precision.    \sa setFloatingPointPrecision(), floatingPointPrecision() */
comment|/*!     \enum QDataStream::Status      This enum describes the current status of the data stream.      \value Ok               The data stream is operating normally.     \value ReadPastEnd      The data stream has read past the end of the                             data in the underlying device.     \value ReadCorruptData  The data stream has read corrupt data.     \value WriteFailed      The data stream cannot write to the underlying device. */
comment|/*****************************************************************************   QDataStream member functions  *****************************************************************************/
DECL|macro|CHECK_STREAM_PRECOND
undef|#
directive|undef
name|CHECK_STREAM_PRECOND
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
DECL|macro|CHECK_STREAM_PRECOND
define|#
directive|define
name|CHECK_STREAM_PRECOND
parameter_list|(
name|retVal
parameter_list|)
define|\
value|if (!dev) { \         qWarning("QDataStream: No device"); \         return retVal; \     }
else|#
directive|else
define|#
directive|define
name|CHECK_STREAM_PRECOND
parameter_list|(
name|retVal
parameter_list|)
define|\
value|if (!dev) { \         return retVal; \     }
endif|#
directive|endif
DECL|macro|CHECK_STREAM_WRITE_PRECOND
define|#
directive|define
name|CHECK_STREAM_WRITE_PRECOND
parameter_list|(
name|retVal
parameter_list|)
define|\
value|CHECK_STREAM_PRECOND(retVal) \     if (q_status != Ok) \         return retVal;
name|enum
type|{
DECL|enumerator|DefaultStreamVersion
name|DefaultStreamVersion
init|=
name|QDataStream
operator|::
name|Qt_5_1
end_decl_stmt
begin_comment
unit|};
comment|/*!     Constructs a data stream that has no I/O device.      \sa setDevice() */
end_comment
begin_constructor
DECL|function|QDataStream
name|QDataStream
operator|::
name|QDataStream
parameter_list|()
block|{
name|dev
operator|=
literal|0
expr_stmt|;
name|owndev
operator|=
literal|false
expr_stmt|;
name|byteorder
operator|=
name|BigEndian
expr_stmt|;
name|ver
operator|=
name|DefaultStreamVersion
expr_stmt|;
name|noswap
operator|=
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
expr_stmt|;
name|q_status
operator|=
name|Ok
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a data stream that uses the I/O device \a d.      \warning If you use QSocket or QSocketDevice as the I/O device \a d     for reading data, you must make sure that enough data is available     on the socket for the operation to successfully proceed;     QDataStream does not have any means to handle or recover from     short-reads.      \sa setDevice(), device() */
end_comment
begin_constructor
DECL|function|QDataStream
name|QDataStream
operator|::
name|QDataStream
parameter_list|(
name|QIODevice
modifier|*
name|d
parameter_list|)
block|{
name|dev
operator|=
name|d
expr_stmt|;
comment|// set device
name|owndev
operator|=
literal|false
expr_stmt|;
name|byteorder
operator|=
name|BigEndian
expr_stmt|;
comment|// default byte order
name|ver
operator|=
name|DefaultStreamVersion
expr_stmt|;
name|noswap
operator|=
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
expr_stmt|;
name|q_status
operator|=
name|Ok
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QDataStream::QDataStream(QByteArray *a, QIODevice::OpenMode mode)      Constructs a data stream that operates on a byte array, \a a. The     \a mode describes how the device is to be used.      Alternatively, you can use QDataStream(const QByteArray&) if you     just want to read from a byte array.      Since QByteArray is not a QIODevice subclass, internally a QBuffer     is created to wrap the byte array. */
end_comment
begin_constructor
DECL|function|QDataStream
name|QDataStream
operator|::
name|QDataStream
parameter_list|(
name|QByteArray
modifier|*
name|a
parameter_list|,
name|QIODevice
operator|::
name|OpenMode
name|flags
parameter_list|)
block|{
name|QBuffer
modifier|*
name|buf
init|=
operator|new
name|QBuffer
argument_list|(
name|a
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|buf
operator|->
name|blockSignals
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf
operator|->
name|open
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|dev
operator|=
name|buf
expr_stmt|;
name|owndev
operator|=
literal|true
expr_stmt|;
name|byteorder
operator|=
name|BigEndian
expr_stmt|;
name|ver
operator|=
name|DefaultStreamVersion
expr_stmt|;
name|noswap
operator|=
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
expr_stmt|;
name|q_status
operator|=
name|Ok
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a read-only data stream that operates on byte array \a a.     Use QDataStream(QByteArray*, int) if you want to write to a byte     array.      Since QByteArray is not a QIODevice subclass, internally a QBuffer     is created to wrap the byte array. */
end_comment
begin_constructor
DECL|function|QDataStream
name|QDataStream
operator|::
name|QDataStream
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|a
parameter_list|)
block|{
name|QBuffer
modifier|*
name|buf
init|=
operator|new
name|QBuffer
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|buf
operator|->
name|blockSignals
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf
operator|->
name|setData
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|buf
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
name|dev
operator|=
name|buf
expr_stmt|;
name|owndev
operator|=
literal|true
expr_stmt|;
name|byteorder
operator|=
name|BigEndian
expr_stmt|;
name|ver
operator|=
name|DefaultStreamVersion
expr_stmt|;
name|noswap
operator|=
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
expr_stmt|;
name|q_status
operator|=
name|Ok
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the data stream.      The destructor will not affect the current I/O device, unless it is     an internal I/O device (e.g. a QBuffer) processing a QByteArray     passed in the \e constructor, in which case the internal I/O device     is destroyed. */
end_comment
begin_destructor
DECL|function|~QDataStream
name|QDataStream
operator|::
name|~
name|QDataStream
parameter_list|()
block|{
if|if
condition|(
name|owndev
condition|)
operator|delete
name|dev
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn QIODevice *QDataStream::device() const      Returns the I/O device currently set, or 0 if no     device is currently set.      \sa setDevice() */
end_comment
begin_comment
comment|/*!     void QDataStream::setDevice(QIODevice *d)      Sets the I/O device to \a d, which can be 0     to unset to current I/O device.      \sa device() */
end_comment
begin_function
DECL|function|setDevice
name|void
name|QDataStream
operator|::
name|setDevice
parameter_list|(
name|QIODevice
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|owndev
condition|)
block|{
operator|delete
name|dev
expr_stmt|;
name|owndev
operator|=
literal|false
expr_stmt|;
block|}
name|dev
operator|=
name|d
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete     Unsets the I/O device.     Use setDevice(0) instead. */
end_comment
begin_function
DECL|function|unsetDevice
name|void
name|QDataStream
operator|::
name|unsetDevice
parameter_list|()
block|{
name|setDevice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QDataStream::atEnd() const      Returns true if the I/O device has reached the end position (end of     the stream or file) or if there is no I/O device set; otherwise     returns false.      \sa QIODevice::atEnd() */
end_comment
begin_function
DECL|function|atEnd
name|bool
name|QDataStream
operator|::
name|atEnd
parameter_list|()
specifier|const
block|{
return|return
name|dev
condition|?
name|dev
operator|->
name|atEnd
argument_list|()
else|:
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the floating point precision of the data stream.      \since 4.6      \sa FloatingPointPrecision, setFloatingPointPrecision() */
end_comment
begin_function
DECL|function|floatingPointPrecision
name|QDataStream
operator|::
name|FloatingPointPrecision
name|QDataStream
operator|::
name|floatingPointPrecision
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|==
literal|0
condition|?
name|QDataStream
operator|::
name|DoublePrecision
else|:
name|d
operator|->
name|floatingPointPrecision
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the floating point precision of the data stream to \a precision. If the floating point precision is     DoublePrecision and the version of the data stream is Qt_4_6 or higher, all floating point     numbers will be written and read with 64-bit precision. If the floating point precision is     SinglePrecision and the version is Qt_4_6 or higher, all floating point numbers will be written     and read with 32-bit precision.      For versions prior to Qt_4_6, the precision of floating point numbers in the data stream depends     on the stream operator called.      The default is DoublePrecision.      \warning This property must be set to the same value on the object that writes and the object     that reads the data stream.      \since 4.6 */
end_comment
begin_function
DECL|function|setFloatingPointPrecision
name|void
name|QDataStream
operator|::
name|setFloatingPointPrecision
parameter_list|(
name|QDataStream
operator|::
name|FloatingPointPrecision
name|precision
parameter_list|)
block|{
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|d
operator|.
name|reset
argument_list|(
operator|new
name|QDataStreamPrivate
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|floatingPointPrecision
operator|=
name|precision
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the status of the data stream.      \sa Status, setStatus(), resetStatus() */
end_comment
begin_function
DECL|function|status
name|QDataStream
operator|::
name|Status
name|QDataStream
operator|::
name|status
parameter_list|()
specifier|const
block|{
return|return
name|q_status
return|;
block|}
end_function
begin_comment
comment|/*!     Resets the status of the data stream.      \sa Status, status(), setStatus() */
end_comment
begin_function
DECL|function|resetStatus
name|void
name|QDataStream
operator|::
name|resetStatus
parameter_list|()
block|{
name|q_status
operator|=
name|Ok
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the status of the data stream to the \a status given.      Subsequent calls to setStatus() are ignored until resetStatus()     is called.      \sa Status, status(), resetStatus() */
end_comment
begin_function
DECL|function|setStatus
name|void
name|QDataStream
operator|::
name|setStatus
parameter_list|(
name|Status
name|status
parameter_list|)
block|{
if|if
condition|(
name|q_status
operator|==
name|Ok
condition|)
name|q_status
operator|=
name|status
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn int QDataStream::byteOrder() const      Returns the current byte order setting -- either BigEndian or     LittleEndian.      \sa setByteOrder() */
end_comment
begin_comment
comment|/*!     Sets the serialization byte order to \a bo.      The \a bo parameter can be QDataStream::BigEndian or     QDataStream::LittleEndian.      The default setting is big endian. We recommend leaving this     setting unless you have special requirements.      \sa byteOrder() */
end_comment
begin_function
DECL|function|setByteOrder
name|void
name|QDataStream
operator|::
name|setByteOrder
parameter_list|(
name|ByteOrder
name|bo
parameter_list|)
block|{
name|byteorder
operator|=
name|bo
expr_stmt|;
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
name|noswap
operator|=
operator|(
name|byteorder
operator|==
name|BigEndian
operator|)
expr_stmt|;
else|else
name|noswap
operator|=
operator|(
name|byteorder
operator|==
name|LittleEndian
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \enum QDataStream::Version      This enum provides symbolic synonyms for the data serialization     format version numbers.      \value Qt_1_0 Version 1 (Qt 1.x)     \value Qt_2_0 Version 2 (Qt 2.0)     \value Qt_2_1 Version 3 (Qt 2.1, 2.2, 2.3)     \value Qt_3_0 Version 4 (Qt 3.0)     \value Qt_3_1 Version 5 (Qt 3.1, 3.2)     \value Qt_3_3 Version 6 (Qt 3.3)     \value Qt_4_0 Version 7 (Qt 4.0, Qt 4.1)     \value Qt_4_1 Version 7 (Qt 4.0, Qt 4.1)     \value Qt_4_2 Version 8 (Qt 4.2)     \value Qt_4_3 Version 9 (Qt 4.3)     \value Qt_4_4 Version 10 (Qt 4.4)     \value Qt_4_5 Version 11 (Qt 4.5)     \value Qt_4_6 Version 12 (Qt 4.6, Qt 4.7, Qt 4.8)     \value Qt_4_7 Same as Qt_4_6.     \value Qt_4_8 Same as Qt_4_6.     \value Qt_4_9 Same as Qt_4_6.     \value Qt_5_0 Version 13 (Qt 5.0)     \value Qt_5_1 Version 14 (Qt 5.1)      \sa setVersion(), version() */
end_comment
begin_comment
comment|/*!     \fn int QDataStream::version() const      Returns the version number of the data serialization format.      \sa setVersion(), Version */
end_comment
begin_comment
comment|/*!     \fn void QDataStream::setVersion(int v)      Sets the version number of the data serialization format to \a v.      You don't \e have to set a version if you are using the current     version of Qt, but for your own custom binary formats we     recommend that you do; see \l{Versioning} in the Detailed     Description.      To accommodate new functionality, the datastream serialization     format of some Qt classes has changed in some versions of Qt. If     you want to read data that was created by an earlier version of     Qt, or write data that can be read by a program that was compiled     with an earlier version of Qt, use this function to modify the     serialization format used by QDataStream.      \table     \header \li Qt Version       \li QDataStream Version     \row \li Qt 5.1                  \li 14     \row \li Qt 5.0                  \li 13     \row \li Qt 4.6                  \li 12     \row \li Qt 4.5                  \li 11     \row \li Qt 4.4                  \li 10     \row \li Qt 4.3                  \li 9     \row \li Qt 4.2                  \li 8     \row \li Qt 4.0, 4.1            \li 7     \row \li Qt 3.3                  \li 6     \row \li Qt 3.1, 3.2             \li 5     \row \li Qt 3.0                  \li 4     \row \li Qt 2.1, 2.2, 2.3      \li 3     \row \li Qt 2.0                  \li 2     \row \li Qt 1.x                  \li 1     \endtable      The \l Version enum provides symbolic constants for the different     versions of Qt. For example:      \snippet code/src_corelib_io_qdatastream.cpp 5      \sa version(), Version */
end_comment
begin_comment
comment|/*****************************************************************************   QDataStream read functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \fn QDataStream&QDataStream::operator>>(quint8&i)     \overload      Reads an unsigned byte from the stream into \a i, and returns a     reference to the stream. */
end_comment
begin_comment
comment|/*!     Reads a signed byte from the stream into \a i, and returns a     reference to the stream. */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|>>
parameter_list|(
name|qint8
modifier|&
name|i
parameter_list|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|CHECK_STREAM_PRECOND
argument_list|(
argument|*this
argument_list|)
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|getChar
argument_list|(
operator|&
name|c
argument_list|)
condition|)
name|setStatus
argument_list|(
name|ReadPastEnd
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|qint8
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&QDataStream::operator>>(quint16&i)     \overload      Reads an unsigned 16-bit integer from the stream into \a i, and     returns a reference to the stream. */
end_comment
begin_comment
comment|/*!     \overload      Reads a signed 16-bit integer from the stream into \a i, and     returns a reference to the stream. */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|>>
parameter_list|(
name|qint16
modifier|&
name|i
parameter_list|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|CHECK_STREAM_PRECOND
argument_list|(
argument|*this
argument_list|)
if|if
condition|(
name|dev
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
literal|2
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|setStatus
argument_list|(
name|ReadPastEnd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|noswap
condition|)
block|{
name|i
operator|=
name|qbswap
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&QDataStream::operator>>(quint32&i)     \overload      Reads an unsigned 32-bit integer from the stream into \a i, and     returns a reference to the stream. */
end_comment
begin_comment
comment|/*!     \overload      Reads a signed 32-bit integer from the stream into \a i, and     returns a reference to the stream. */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|>>
parameter_list|(
name|qint32
modifier|&
name|i
parameter_list|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|CHECK_STREAM_PRECOND
argument_list|(
argument|*this
argument_list|)
if|if
condition|(
name|dev
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
literal|4
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|setStatus
argument_list|(
name|ReadPastEnd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|noswap
condition|)
block|{
name|i
operator|=
name|qbswap
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&QDataStream::operator>>(quint64&i)     \overload      Reads an unsigned 64-bit integer from the stream, into \a i, and     returns a reference to the stream. */
end_comment
begin_comment
comment|/*!     \overload      Reads a signed 64-bit integer from the stream into \a i, and     returns a reference to the stream. */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|>>
parameter_list|(
name|qint64
modifier|&
name|i
parameter_list|)
block|{
name|i
operator|=
name|qint64
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STREAM_PRECOND
argument_list|(
argument|*this
argument_list|)
if|if
condition|(
name|version
argument_list|()
operator|<
literal|6
condition|)
block|{
name|quint32
name|i1
decl_stmt|,
name|i2
decl_stmt|;
operator|*
name|this
operator|>>
name|i2
operator|>>
name|i1
expr_stmt|;
name|i
operator|=
operator|(
operator|(
name|quint64
operator|)
name|i1
operator|<<
literal|32
operator|)
operator|+
name|i2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dev
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
literal|8
argument_list|)
operator|!=
literal|8
condition|)
block|{
name|i
operator|=
name|qint64
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setStatus
argument_list|(
name|ReadPastEnd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|noswap
condition|)
block|{
name|i
operator|=
name|qbswap
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Reads a boolean value from the stream into \a i. Returns a     reference to the stream. */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|>>
parameter_list|(
name|bool
modifier|&
name|i
parameter_list|)
block|{
name|qint8
name|v
decl_stmt|;
operator|*
name|this
operator|>>
name|v
expr_stmt|;
name|i
operator|=
operator|!
operator|!
name|v
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Reads a floating point number from the stream into \a f,     using the standard IEEE 754 format. Returns a reference to the     stream.      \sa setFloatingPointPrecision() */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|>>
parameter_list|(
name|float
modifier|&
name|f
parameter_list|)
block|{
if|if
condition|(
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_6
operator|&&
name|floatingPointPrecision
argument_list|()
operator|==
name|QDataStream
operator|::
name|DoublePrecision
condition|)
block|{
name|double
name|d
decl_stmt|;
operator|*
name|this
operator|>>
name|d
expr_stmt|;
name|f
operator|=
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|f
operator|=
literal|0.0f
expr_stmt|;
name|CHECK_STREAM_PRECOND
argument_list|(
argument|*this
argument_list|)
if|if
condition|(
name|dev
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|f
argument_list|,
literal|4
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|f
operator|=
literal|0.0f
expr_stmt|;
name|setStatus
argument_list|(
name|ReadPastEnd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|noswap
condition|)
block|{
union|union
block|{
name|float
name|val1
decl_stmt|;
name|quint32
name|val2
decl_stmt|;
block|}
name|x
union|;
name|x
operator|.
name|val2
operator|=
name|qbswap
argument_list|(
operator|*
cast|reinterpret_cast
argument_list|<
name|quint32
operator|*
argument_list|>
argument_list|(
operator|&
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|x
operator|.
name|val1
expr_stmt|;
block|}
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Reads a floating point number from the stream into \a f,     using the standard IEEE 754 format. Returns a reference to the     stream.      \sa setFloatingPointPrecision() */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|>>
parameter_list|(
name|double
modifier|&
name|f
parameter_list|)
block|{
if|if
condition|(
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_6
operator|&&
name|floatingPointPrecision
argument_list|()
operator|==
name|QDataStream
operator|::
name|SinglePrecision
condition|)
block|{
name|float
name|d
decl_stmt|;
operator|*
name|this
operator|>>
name|d
expr_stmt|;
name|f
operator|=
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|f
operator|=
literal|0.0
expr_stmt|;
name|CHECK_STREAM_PRECOND
argument_list|(
argument|*this
argument_list|)
if|if
condition|(
name|dev
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|f
argument_list|,
literal|8
argument_list|)
operator|!=
literal|8
condition|)
block|{
name|f
operator|=
literal|0.0
expr_stmt|;
name|setStatus
argument_list|(
name|ReadPastEnd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|noswap
condition|)
block|{
union|union
block|{
name|double
name|val1
decl_stmt|;
name|quint64
name|val2
decl_stmt|;
block|}
name|x
union|;
name|x
operator|.
name|val2
operator|=
name|qbswap
argument_list|(
operator|*
cast|reinterpret_cast
argument_list|<
name|quint64
operator|*
argument_list|>
argument_list|(
operator|&
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|x
operator|.
name|val1
expr_stmt|;
block|}
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Reads the '\\0'-terminated string \a s from the stream and returns     a reference to the stream.      The string is deserialized using \c{readBytes()}.      Space for the string is allocated using \c{new []} -- the caller must     destroy it with \c{delete []}.      \sa readBytes(), readRawData() */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|>>
parameter_list|(
name|char
modifier|*
modifier|&
name|s
parameter_list|)
block|{
name|uint
name|len
init|=
literal|0
decl_stmt|;
return|return
name|readBytes
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Reads the buffer \a s from the stream and returns a reference to     the stream.      The buffer \a s is allocated using \c{new []}. Destroy it with the     \c{delete []} operator.      The \a l parameter is set to the length of the buffer. If the     string read is empty, \a l is set to 0 and \a s is set to     a null pointer.      The serialization format is a quint32 length specifier first,     then \a l bytes of data.      \sa readRawData(), writeBytes() */
end_comment
begin_function
DECL|function|readBytes
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|readBytes
parameter_list|(
name|char
modifier|*
modifier|&
name|s
parameter_list|,
name|uint
modifier|&
name|l
parameter_list|)
block|{
name|s
operator|=
literal|0
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
name|CHECK_STREAM_PRECOND
argument_list|(
argument|*this
argument_list|)
name|quint32
name|len
decl_stmt|;
operator|*
name|this
operator|>>
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|*
name|this
return|;
specifier|const
name|quint32
name|Step
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
name|quint32
name|allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|prevBuf
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|curBuf
init|=
literal|0
decl_stmt|;
do|do
block|{
name|int
name|blockSize
init|=
name|qMin
argument_list|(
name|Step
argument_list|,
name|len
operator|-
name|allocated
argument_list|)
decl_stmt|;
name|prevBuf
operator|=
name|curBuf
expr_stmt|;
name|curBuf
operator|=
operator|new
name|char
index|[
name|allocated
operator|+
name|blockSize
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|prevBuf
condition|)
block|{
name|memcpy
argument_list|(
name|curBuf
argument_list|,
name|prevBuf
argument_list|,
name|allocated
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|prevBuf
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|read
argument_list|(
name|curBuf
operator|+
name|allocated
argument_list|,
name|blockSize
argument_list|)
operator|!=
name|blockSize
condition|)
block|{
operator|delete
index|[]
name|curBuf
expr_stmt|;
name|setStatus
argument_list|(
name|ReadPastEnd
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|allocated
operator|+=
name|blockSize
expr_stmt|;
block|}
do|while
condition|(
name|allocated
operator|<
name|len
condition|)
do|;
name|s
operator|=
name|curBuf
expr_stmt|;
name|s
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|l
operator|=
operator|(
name|uint
operator|)
name|len
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Reads at most \a len bytes from the stream into \a s and returns the number of     bytes read. If an error occurs, this function returns -1.      The buffer \a s must be preallocated. The data is \e not encoded.      \sa readBytes(), QIODevice::read(), writeRawData() */
end_comment
begin_function
DECL|function|readRawData
name|int
name|QDataStream
operator|::
name|readRawData
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|CHECK_STREAM_PRECOND
argument_list|(
argument|-
literal|1
argument_list|)
return|return
name|dev
operator|->
name|read
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QDataStream write functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \fn QDataStream&QDataStream::operator<<(quint8 i)     \overload      Writes an unsigned byte, \a i, to the stream and returns a     reference to the stream. */
end_comment
begin_comment
comment|/*!     Writes a signed byte, \a i, to the stream and returns a reference     to the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|<<
parameter_list|(
name|qint8
name|i
parameter_list|)
block|{
name|CHECK_STREAM_WRITE_PRECOND
argument_list|(
argument|*this
argument_list|)
if|if
condition|(
operator|!
name|dev
operator|->
name|putChar
argument_list|(
name|i
argument_list|)
condition|)
name|q_status
operator|=
name|WriteFailed
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&QDataStream::operator<<(quint16 i)     \overload      Writes an unsigned 16-bit integer, \a i, to the stream and returns     a reference to the stream. */
end_comment
begin_comment
comment|/*!     \overload      Writes a signed 16-bit integer, \a i, to the stream and returns a     reference to the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|<<
parameter_list|(
name|qint16
name|i
parameter_list|)
block|{
name|CHECK_STREAM_WRITE_PRECOND
argument_list|(
argument|*this
argument_list|)
if|if
condition|(
operator|!
name|noswap
condition|)
block|{
name|i
operator|=
name|qbswap
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|qint16
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|qint16
argument_list|)
condition|)
name|q_status
operator|=
name|WriteFailed
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes a signed 32-bit integer, \a i, to the stream and returns a     reference to the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|<<
parameter_list|(
name|qint32
name|i
parameter_list|)
block|{
name|CHECK_STREAM_WRITE_PRECOND
argument_list|(
argument|*this
argument_list|)
if|if
condition|(
operator|!
name|noswap
condition|)
block|{
name|i
operator|=
name|qbswap
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|qint32
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|qint32
argument_list|)
condition|)
name|q_status
operator|=
name|WriteFailed
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&QDataStream::operator<<(quint64 i)     \overload      Writes an unsigned 64-bit integer, \a i, to the stream and returns a     reference to the stream. */
end_comment
begin_comment
comment|/*!     \overload      Writes a signed 64-bit integer, \a i, to the stream and returns a     reference to the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|<<
parameter_list|(
name|qint64
name|i
parameter_list|)
block|{
name|CHECK_STREAM_WRITE_PRECOND
argument_list|(
argument|*this
argument_list|)
if|if
condition|(
name|version
argument_list|()
operator|<
literal|6
condition|)
block|{
name|quint32
name|i1
init|=
name|i
operator|&
literal|0xffffffff
decl_stmt|;
name|quint32
name|i2
init|=
name|i
operator|>>
literal|32
decl_stmt|;
operator|*
name|this
operator|<<
name|i2
operator|<<
name|i1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|noswap
condition|)
block|{
name|i
operator|=
name|qbswap
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|qint64
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|qint64
argument_list|)
condition|)
name|q_status
operator|=
name|WriteFailed
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&QDataStream::operator<<(quint32 i)     \overload      Writes an unsigned integer, \a i, to the stream as a 32-bit     unsigned integer (quint32). Returns a reference to the stream. */
end_comment
begin_comment
comment|/*!     Writes a boolean value, \a i, to the stream. Returns a reference     to the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|<<
parameter_list|(
name|bool
name|i
parameter_list|)
block|{
name|CHECK_STREAM_WRITE_PRECOND
argument_list|(
argument|*this
argument_list|)
if|if
condition|(
operator|!
name|dev
operator|->
name|putChar
argument_list|(
name|qint8
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|q_status
operator|=
name|WriteFailed
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes a floating point number, \a f, to the stream using     the standard IEEE 754 format. Returns a reference to the stream.      \sa setFloatingPointPrecision() */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|<<
parameter_list|(
name|float
name|f
parameter_list|)
block|{
if|if
condition|(
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_6
operator|&&
name|floatingPointPrecision
argument_list|()
operator|==
name|QDataStream
operator|::
name|DoublePrecision
condition|)
block|{
operator|*
name|this
operator|<<
name|double
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|CHECK_STREAM_WRITE_PRECOND
argument_list|(
argument|*this
argument_list|)
name|float
name|g
init|=
name|f
decl_stmt|;
comment|// fixes float-on-stack problem
if|if
condition|(
operator|!
name|noswap
condition|)
block|{
union|union
block|{
name|float
name|val1
decl_stmt|;
name|quint32
name|val2
decl_stmt|;
block|}
name|x
union|;
name|x
operator|.
name|val1
operator|=
name|g
expr_stmt|;
name|x
operator|.
name|val2
operator|=
name|qbswap
argument_list|(
name|x
operator|.
name|val2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|x
operator|.
name|val2
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
name|q_status
operator|=
name|WriteFailed
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
if|if
condition|(
name|dev
operator|->
name|write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|g
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
name|q_status
operator|=
name|WriteFailed
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes a floating point number, \a f, to the stream using     the standard IEEE 754 format. Returns a reference to the stream.      \sa setFloatingPointPrecision() */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|<<
parameter_list|(
name|double
name|f
parameter_list|)
block|{
if|if
condition|(
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_6
operator|&&
name|floatingPointPrecision
argument_list|()
operator|==
name|QDataStream
operator|::
name|SinglePrecision
condition|)
block|{
operator|*
name|this
operator|<<
name|float
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|CHECK_STREAM_WRITE_PRECOND
argument_list|(
argument|*this
argument_list|)
if|if
condition|(
name|noswap
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|f
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|q_status
operator|=
name|WriteFailed
expr_stmt|;
block|}
else|else
block|{
union|union
block|{
name|double
name|val1
decl_stmt|;
name|quint64
name|val2
decl_stmt|;
block|}
name|x
union|;
name|x
operator|.
name|val1
operator|=
name|f
expr_stmt|;
name|x
operator|.
name|val2
operator|=
name|qbswap
argument_list|(
name|x
operator|.
name|val2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|x
operator|.
name|val2
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|q_status
operator|=
name|WriteFailed
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes the '\\0'-terminated string \a s to the stream and returns a     reference to the stream.      The string is serialized using \c{writeBytes()}.      \sa writeBytes(), writeRawData() */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|operator
name|<<
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|s
condition|)
block|{
operator|*
name|this
operator|<<
operator|(
name|quint32
operator|)
literal|0
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|uint
name|len
init|=
name|qstrlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|// also write null terminator
operator|*
name|this
operator|<<
operator|(
name|quint32
operator|)
name|len
expr_stmt|;
comment|// write length specifier
name|writeRawData
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Writes the length specifier \a len and the buffer \a s to the     stream and returns a reference to the stream.      The \a len is serialized as a quint32, followed by \a len bytes     from \a s. Note that the data is \e not encoded.      \sa writeRawData(), readBytes() */
end_comment
begin_function
DECL|function|writeBytes
name|QDataStream
modifier|&
name|QDataStream
operator|::
name|writeBytes
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
name|CHECK_STREAM_WRITE_PRECOND
argument_list|(
operator|*
name|this
argument_list|)
operator|*
name|this
operator|<<
operator|(
name|quint32
operator|)
name|len
expr_stmt|;
comment|// write length specifier
if|if
condition|(
name|len
condition|)
name|writeRawData
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Writes \a len bytes from \a s to the stream. Returns the     number of bytes actually written, or -1 on error.     The data is \e not encoded.      \sa writeBytes(), QIODevice::write(), readRawData() */
end_comment
begin_function
DECL|function|writeRawData
name|int
name|QDataStream
operator|::
name|writeRawData
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|CHECK_STREAM_WRITE_PRECOND
argument_list|(
argument|-
literal|1
argument_list|)
name|int
name|ret
init|=
name|dev
operator|->
name|write
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|len
condition|)
name|q_status
operator|=
name|WriteFailed
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Skips \a len bytes from the device. Returns the number of bytes     actually skipped, or -1 on error.      This is equivalent to calling readRawData() on a buffer of length     \a len and ignoring the buffer.      \sa QIODevice::seek() */
end_comment
begin_function
DECL|function|skipRawData
name|int
name|QDataStream
operator|::
name|skipRawData
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|CHECK_STREAM_PRECOND
argument_list|(
argument|-
literal|1
argument_list|)
if|if
condition|(
name|dev
operator|->
name|isSequential
argument_list|()
condition|)
block|{
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|sumRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|blockSize
init|=
name|qMin
argument_list|(
name|len
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|dev
operator|->
name|read
argument_list|(
name|buf
argument_list|,
name|blockSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|sumRead
return|;
name|sumRead
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|blockSize
expr_stmt|;
block|}
return|return
name|sumRead
return|;
block|}
else|else
block|{
name|qint64
name|pos
init|=
name|dev
operator|->
name|pos
argument_list|()
decl_stmt|;
name|qint64
name|size
init|=
name|dev
operator|->
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|pos
operator|+
name|len
operator|>
name|size
condition|)
name|len
operator|=
name|size
operator|-
name|pos
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|seek
argument_list|(
name|pos
operator|+
name|len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|len
return|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
end_unit
