begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 Intel Corporation. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qurl.h"
end_include
begin_include
include|#
directive|include
file|"private/qutfcodec_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qtools_p.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|// ### move to qurl_p.h
DECL|enum|EncodingAction
name|enum
name|EncodingAction
argument_list|{
DECL|enumerator|DecodeCharacter
name|DecodeCharacter
operator|=
literal|0
argument_list|,
DECL|enumerator|LeaveCharacter
name|LeaveCharacter
operator|=
literal|1
argument_list|,
DECL|enumerator|EncodeCharacter
name|EncodeCharacter
operator|=
literal|2
argument_list|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|// From RFC 3896, Appendix A Collected ABNF for URI
end_comment
begin_comment
comment|//    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
end_comment
begin_comment
comment|//    reserved      = gen-delims / sub-delims
end_comment
begin_comment
comment|//    gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
end_comment
begin_comment
comment|//    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
end_comment
begin_comment
comment|//                  / "*" / "+" / "," / ";" / "="
end_comment
begin_decl_stmt
DECL|variable|defaultActionTable
specifier|static
specifier|const
name|uchar
name|defaultActionTable
index|[
literal|96
index|]
init|=
block|{
literal|2
block|,
comment|// space
literal|1
block|,
comment|// '!' (sub-delim)
literal|2
block|,
comment|// '"'
literal|1
block|,
comment|// '#' (gen-delim)
literal|1
block|,
comment|// '$' (gen-delim)
literal|2
block|,
comment|// '%' (percent)
literal|1
block|,
comment|// '&' (gen-delim)
literal|1
block|,
comment|// "'" (sub-delim)
literal|1
block|,
comment|// '(' (sub-delim)
literal|1
block|,
comment|// ')' (sub-delim)
literal|1
block|,
comment|// '*' (sub-delim)
literal|1
block|,
comment|// '+' (sub-delim)
literal|1
block|,
comment|// ',' (sub-delim)
literal|0
block|,
comment|// '-' (unreserved)
literal|0
block|,
comment|// '.' (unreserved)
literal|1
block|,
comment|// '/' (gen-delim)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// '0' to '4' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// '5' to '9' (unreserved)
literal|1
block|,
comment|// ':' (gen-delim)
literal|1
block|,
comment|// ';' (sub-delim)
literal|2
block|,
comment|// '<'
literal|1
block|,
comment|// '=' (sub-delim)
literal|2
block|,
comment|// '>'
literal|1
block|,
comment|// '?' (gen-delim)
literal|1
block|,
comment|// '@' (gen-delim)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'A' to 'E' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'F' to 'J' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'K' to 'O' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'P' to 'T' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'U' to 'Z' (unreserved)
literal|1
block|,
comment|// '[' (gen-delim)
literal|2
block|,
comment|// '\'
literal|1
block|,
comment|// ']' (gen-delim)
literal|2
block|,
comment|// '^'
literal|0
block|,
comment|// '_' (unreserved)
literal|2
block|,
comment|// '`'
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'a' to 'e' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'f' to 'j' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'k' to 'o' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'p' to 't' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'u' to 'z' (unreserved)
literal|2
block|,
comment|// '{'
literal|2
block|,
comment|// '|'
literal|2
block|,
comment|// '}'
literal|0
block|,
comment|// '~' (unreserved)
literal|2
comment|// BSKP
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|// mask tables, in negative polarity
end_comment
begin_comment
comment|// 0x00 if it belongs to this category
end_comment
begin_comment
comment|// 0xff if it doesn't
end_comment
begin_decl_stmt
DECL|variable|reservedMask
specifier|static
specifier|const
name|uchar
name|reservedMask
index|[
literal|96
index|]
init|=
block|{
literal|0xff
block|,
comment|// space
literal|0xff
block|,
comment|// '!' (sub-delim)
literal|0x00
block|,
comment|// '"'
literal|0xff
block|,
comment|// '#' (gen-delim)
literal|0xff
block|,
comment|// '$' (gen-delim)
literal|0xff
block|,
comment|// '%' (percent)
literal|0xff
block|,
comment|// '&' (gen-delim)
literal|0xff
block|,
comment|// "'" (sub-delim)
literal|0xff
block|,
comment|// '(' (sub-delim)
literal|0xff
block|,
comment|// ')' (sub-delim)
literal|0xff
block|,
comment|// '*' (sub-delim)
literal|0xff
block|,
comment|// '+' (sub-delim)
literal|0xff
block|,
comment|// ',' (sub-delim)
literal|0xff
block|,
comment|// '-' (unreserved)
literal|0xff
block|,
comment|// '.' (unreserved)
literal|0xff
block|,
comment|// '/' (gen-delim)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// '0' to '4' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// '5' to '9' (unreserved)
literal|0xff
block|,
comment|// ':' (gen-delim)
literal|0xff
block|,
comment|// ';' (sub-delim)
literal|0x00
block|,
comment|// '<'
literal|0xff
block|,
comment|// '=' (sub-delim)
literal|0x00
block|,
comment|// '>'
literal|0xff
block|,
comment|// '?' (gen-delim)
literal|0xff
block|,
comment|// '@' (gen-delim)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'A' to 'E' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'F' to 'J' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'K' to 'O' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'P' to 'T' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'U' to 'Z' (unreserved)
literal|0xff
block|,
comment|// '[' (gen-delim)
literal|0x00
block|,
comment|// '\'
literal|0xff
block|,
comment|// ']' (gen-delim)
literal|0x00
block|,
comment|// '^'
literal|0xff
block|,
comment|// '_' (unreserved)
literal|0x00
block|,
comment|// '`'
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'a' to 'e' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'f' to 'j' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'k' to 'o' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'p' to 't' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'u' to 'z' (unreserved)
literal|0x00
block|,
comment|// '{'
literal|0x00
block|,
comment|// '|'
literal|0x00
block|,
comment|// '}'
literal|0xff
block|,
comment|// '~' (unreserved)
literal|0xff
comment|// BSKP
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|isHex
specifier|static
specifier|inline
name|bool
name|isHex
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isUpperHex
specifier|static
specifier|inline
name|bool
name|isUpperHex
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
comment|// undefined behaviour if c isn't an hex char!
return|return
name|c
operator|<
literal|0x60
return|;
block|}
end_function
begin_function
DECL|function|toUpperHex
specifier|static
specifier|inline
name|ushort
name|toUpperHex
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
name|isUpperHex
argument_list|(
name|c
argument_list|)
condition|?
name|c
else|:
name|c
operator|-
literal|0x20
return|;
block|}
end_function
begin_function
DECL|function|decodeNibble
specifier|static
specifier|inline
name|ushort
name|decodeNibble
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
name|c
operator|>=
literal|'a'
condition|?
name|c
operator|-
literal|'a'
operator|+
literal|0xA
else|:
name|c
operator|>=
literal|'A'
condition|?
name|c
operator|-
literal|'A'
operator|+
literal|0xA
else|:
name|c
operator|-
literal|'0'
return|;
block|}
end_function
begin_comment
comment|// if the sequence at input is 2*HEXDIG, returns its decoding
end_comment
begin_comment
comment|// returns -1 if it isn't.
end_comment
begin_comment
comment|// assumes that the range has been checked already
end_comment
begin_function
DECL|function|decodePercentEncoding
specifier|static
specifier|inline
name|ushort
name|decodePercentEncoding
parameter_list|(
specifier|const
name|ushort
modifier|*
name|input
parameter_list|)
block|{
name|ushort
name|c1
init|=
name|input
index|[
literal|1
index|]
decl_stmt|;
name|ushort
name|c2
init|=
name|input
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isHex
argument_list|(
name|c1
argument_list|)
operator|||
operator|!
name|isHex
argument_list|(
name|c2
argument_list|)
condition|)
return|return
name|ushort
argument_list|(
operator|-
literal|1
argument_list|)
return|;
return|return
name|decodeNibble
argument_list|(
name|c1
argument_list|)
operator|<<
literal|4
operator||
name|decodeNibble
argument_list|(
name|c2
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|encodeNibble
specifier|static
specifier|inline
name|ushort
name|encodeNibble
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
name|ushort
argument_list|(
name|QtMiscUtils
operator|::
name|toHexUpper
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ensureDetached
specifier|static
name|void
name|ensureDetached
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
name|ushort
modifier|*
modifier|&
name|output
parameter_list|,
specifier|const
name|ushort
modifier|*
name|begin
parameter_list|,
specifier|const
name|ushort
modifier|*
name|input
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|,
name|int
name|add
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
operator|!
name|output
condition|)
block|{
comment|// now detach
comment|// create enough space if the rest of the string needed to be percent-encoded
name|int
name|charsProcessed
init|=
name|input
operator|-
name|begin
decl_stmt|;
name|int
name|charsRemaining
init|=
name|end
operator|-
name|input
decl_stmt|;
name|int
name|spaceNeeded
init|=
name|end
operator|-
name|begin
operator|+
literal|2
operator|*
name|charsRemaining
operator|+
name|add
decl_stmt|;
name|int
name|origSize
init|=
name|result
operator|.
name|size
argument_list|()
decl_stmt|;
name|result
operator|.
name|resize
argument_list|(
name|origSize
operator|+
name|spaceNeeded
argument_list|)
expr_stmt|;
comment|// we know that resize() above detached, so we bypass the reference count check
name|output
operator|=
cast|const_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
operator|+
name|origSize
expr_stmt|;
comment|// copy the chars we've already processed
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|charsProcessed
condition|;
operator|++
name|i
control|)
name|output
index|[
name|i
index|]
operator|=
name|begin
index|[
name|i
index|]
expr_stmt|;
name|output
operator|+=
name|i
expr_stmt|;
block|}
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|struct|QUrlUtf8Traits
struct|struct
name|QUrlUtf8Traits
super|:
specifier|public
name|QUtf8BaseTraitsNoAscii
block|{
comment|// From RFC 3987:
comment|//    iunreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~" / ucschar
comment|//
comment|//    ucschar        = %xA0-D7FF / %xF900-FDCF / %xFDF0-FFEF
comment|//                   / %x10000-1FFFD / %x20000-2FFFD / %x30000-3FFFD
comment|//                   / %x40000-4FFFD / %x50000-5FFFD / %x60000-6FFFD
comment|//                   / %x70000-7FFFD / %x80000-8FFFD / %x90000-9FFFD
comment|//                   / %xA0000-AFFFD / %xB0000-BFFFD / %xC0000-CFFFD
comment|//                   / %xD0000-DFFFD / %xE1000-EFFFD
comment|//
comment|//    iprivate       = %xE000-F8FF / %xF0000-FFFFD / %x100000-10FFFD
comment|//
comment|// That RFC allows iprivate only as part of iquery, but we don't know here
comment|// whether we're looking at a query or another part of an URI, so we accept
comment|// them too. The definition above excludes U+FFF0 to U+FFFD from appearing
comment|// unencoded, but we see no reason for its exclusion, so we allow them to
comment|// be decoded (and we need U+FFFD the replacement character to indicate
comment|// failure to decode).
comment|//
comment|// That means we must disallow:
comment|//  * unpaired surrogates (QUtf8Functions takes care of that for us)
comment|//  * non-characters
DECL|member|allowNonCharacters
specifier|static
specifier|const
name|bool
name|allowNonCharacters
init|=
literal|false
decl_stmt|;
comment|// override: our "bytes" are three percent-encoded UTF-16 characters
DECL|function|appendByte
specifier|static
name|void
name|appendByte
parameter_list|(
name|ushort
modifier|*
modifier|&
name|ptr
parameter_list|,
name|uchar
name|b
parameter_list|)
block|{
comment|// b>= 0x80, by construction, so percent-encode
operator|*
name|ptr
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|encodeNibble
argument_list|(
name|b
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|encodeNibble
argument_list|(
name|b
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
DECL|function|peekByte
specifier|static
name|uchar
name|peekByte
parameter_list|(
specifier|const
name|ushort
modifier|*
name|ptr
parameter_list|,
name|int
name|n
init|=
literal|0
parameter_list|)
block|{
comment|// decodePercentEncoding returns ushort(-1) if it can't decode,
comment|// which means we return 0xff, which is not a valid continuation byte.
comment|// If ptr[i * 3] is not '%', we'll multiply by zero and return 0,
comment|// also not a valid continuation byte (if it's '%', we multiply by 1).
return|return
name|uchar
argument_list|(
name|decodePercentEncoding
argument_list|(
name|ptr
operator|+
name|n
operator|*
literal|3
argument_list|)
argument_list|)
operator|*
name|uchar
argument_list|(
name|ptr
index|[
name|n
operator|*
literal|3
index|]
operator|==
literal|'%'
argument_list|)
return|;
block|}
DECL|function|availableBytes
specifier|static
name|qptrdiff
name|availableBytes
parameter_list|(
specifier|const
name|ushort
modifier|*
name|ptr
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|)
block|{
return|return
operator|(
name|end
operator|-
name|ptr
operator|)
operator|/
literal|3
return|;
block|}
DECL|function|advanceByte
specifier|static
name|void
name|advanceByte
parameter_list|(
specifier|const
name|ushort
modifier|*
modifier|&
name|ptr
parameter_list|,
name|int
name|n
init|=
literal|1
parameter_list|)
block|{
name|ptr
operator|+=
name|n
operator|*
literal|3
expr_stmt|;
block|}
block|}
struct|;
block|}
end_namespace
begin_comment
comment|// returns true if we performed an UTF-8 decoding
end_comment
begin_function
DECL|function|encodedUtf8ToUtf16
specifier|static
name|bool
name|encodedUtf8ToUtf16
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
name|ushort
modifier|*
modifier|&
name|output
parameter_list|,
specifier|const
name|ushort
modifier|*
name|begin
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|input
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|,
name|ushort
name|decoded
parameter_list|)
block|{
name|uint
name|ucs4
decl_stmt|,
modifier|*
name|dst
init|=
operator|&
name|ucs4
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|src
init|=
name|input
operator|+
literal|3
decl_stmt|;
comment|// skip the %XX that yielded \a decoded
name|int
name|charsNeeded
init|=
name|QUtf8Functions
operator|::
name|fromUtf8
argument_list|<
name|QUrlUtf8Traits
argument_list|>
argument_list|(
name|decoded
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|charsNeeded
operator|<
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|ucs4
argument_list|)
condition|)
block|{
comment|// UTF-8 decoded and no surrogates are required
comment|// detach if necessary
comment|// possibilities are: 6 chars (%XX%XX) -> one char; 9 chars (%XX%XX%XX) -> one char
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
operator|-
literal|3
operator|*
name|charsNeeded
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|ucs4
expr_stmt|;
block|}
else|else
block|{
comment|// UTF-8 decoded to something that requires a surrogate pair
comment|// compressing from %XX%XX%XX%XX (12 chars) to two
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
operator|-
literal|10
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|ucs4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|ucs4
argument_list|)
expr_stmt|;
block|}
name|input
operator|=
name|src
operator|-
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|unicodeToEncodedUtf8
specifier|static
name|void
name|unicodeToEncodedUtf8
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
name|ushort
modifier|*
modifier|&
name|output
parameter_list|,
specifier|const
name|ushort
modifier|*
name|begin
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|input
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|,
name|ushort
name|decoded
parameter_list|)
block|{
comment|// calculate the utf8 length and ensure enough space is available
name|int
name|utf8len
init|=
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|decoded
argument_list|)
condition|?
literal|4
else|:
name|decoded
operator|>=
literal|0x800
condition|?
literal|3
else|:
literal|2
decl_stmt|;
comment|// detach
if|if
condition|(
operator|!
name|output
condition|)
block|{
comment|// we need 3 * utf8len for the encoded UTF-8 sequence
comment|// but ensureDetached already adds 3 for the char we're processing
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
literal|3
operator|*
name|utf8len
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// verify that there's enough space or expand
name|int
name|charsRemaining
init|=
name|end
operator|-
name|input
operator|-
literal|1
decl_stmt|;
comment|// not including this one
name|int
name|pos
init|=
name|output
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|spaceRemaining
init|=
name|result
operator|.
name|size
argument_list|()
operator|-
name|pos
decl_stmt|;
if|if
condition|(
name|spaceRemaining
operator|<
literal|3
operator|*
name|charsRemaining
operator|+
literal|3
operator|*
name|utf8len
condition|)
block|{
comment|// must resize
name|result
operator|.
name|resize
argument_list|(
name|result
operator|.
name|size
argument_list|()
operator|+
literal|3
operator|*
name|utf8len
argument_list|)
expr_stmt|;
comment|// we know that resize() above detached, so we bypass the reference count check
name|output
operator|=
cast|const_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|+=
name|pos
expr_stmt|;
block|}
block|}
operator|++
name|input
expr_stmt|;
name|int
name|res
init|=
name|QUtf8Functions
operator|::
name|toUtf8
argument_list|<
name|QUrlUtf8Traits
argument_list|>
argument_list|(
name|decoded
argument_list|,
name|output
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
decl_stmt|;
operator|--
name|input
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
comment|// bad surrogate pair sequence
comment|// we will encode bad UTF-16 to UTF-8
comment|// but they don't get decoded back
comment|// first of three bytes
name|uchar
name|c
init|=
literal|0xe0
operator||
name|uchar
argument_list|(
name|decoded
operator|>>
literal|12
argument_list|)
decl_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'E'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
comment|// second byte
name|c
operator|=
literal|0x80
operator||
operator|(
name|uchar
argument_list|(
name|decoded
operator|>>
literal|6
argument_list|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
comment|// third byte
name|c
operator|=
literal|0x80
operator||
operator|(
name|decoded
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|recode
specifier|static
name|int
name|recode
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
specifier|const
name|ushort
modifier|*
name|begin
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|,
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
parameter_list|,
specifier|const
name|uchar
modifier|*
name|actionTable
parameter_list|,
name|bool
name|retryBadEncoding
parameter_list|)
block|{
specifier|const
name|int
name|origSize
init|=
name|result
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|input
init|=
name|begin
decl_stmt|;
name|ushort
modifier|*
name|output
init|=
literal|0
decl_stmt|;
name|EncodingAction
name|action
init|=
name|EncodeCharacter
decl_stmt|;
for|for
control|(
init|;
name|input
operator|!=
name|end
condition|;
operator|++
name|input
control|)
block|{
name|ushort
name|c
decl_stmt|;
comment|// try a run where no change is necessary
for|for
control|(
init|;
name|input
operator|!=
name|end
condition|;
operator|++
name|input
control|)
block|{
name|c
operator|=
operator|*
name|input
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x20U
condition|)
name|action
operator|=
name|EncodeCharacter
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x20U
operator|||
name|c
operator|>=
literal|0x80U
condition|)
comment|// also: (c - 0x20< 0x60U)
goto|goto
name|non_trivial
goto|;
name|action
operator|=
name|EncodingAction
argument_list|(
name|actionTable
index|[
name|c
operator|-
literal|' '
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|EncodeCharacter
condition|)
goto|goto
name|non_trivial
goto|;
if|if
condition|(
name|output
condition|)
operator|*
name|output
operator|++
operator|=
name|c
expr_stmt|;
block|}
break|break;
name|non_trivial
label|:
name|uint
name|decoded
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|retryBadEncoding
condition|)
block|{
comment|// always write "%25"
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'2'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'5'
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
comment|// check if the input is valid
if|if
condition|(
name|input
operator|+
literal|2
operator|>=
name|end
operator|||
operator|(
name|decoded
operator|=
name|decodePercentEncoding
argument_list|(
name|input
argument_list|)
operator|)
operator|==
name|ushort
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|// not valid, retry
name|result
operator|.
name|resize
argument_list|(
name|origSize
argument_list|)
expr_stmt|;
return|return
name|recode
argument_list|(
name|result
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|encoding
argument_list|,
name|actionTable
argument_list|,
literal|true
argument_list|)
return|;
block|}
if|if
condition|(
name|decoded
operator|>=
literal|0x80
condition|)
block|{
comment|// decode the UTF-8 sequence
if|if
condition|(
operator|!
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeUnicode
operator|)
operator|&&
name|encodedUtf8ToUtf16
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
name|decoded
argument_list|)
condition|)
continue|continue;
comment|// decoding the encoded UTF-8 failed
name|action
operator|=
name|LeaveCharacter
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|>=
literal|0x20
condition|)
block|{
name|action
operator|=
name|EncodingAction
argument_list|(
name|actionTable
index|[
name|decoded
operator|-
literal|' '
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|decoded
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|decoded
operator|>=
literal|0x80
operator|&&
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeUnicode
condition|)
block|{
comment|// encode the UTF-8 sequence
name|unicodeToEncodedUtf8
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|>=
literal|0x80
condition|)
block|{
if|if
condition|(
name|output
condition|)
operator|*
name|output
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
block|}
comment|// there are six possibilities:
comment|//  current \ action  | DecodeCharacter | LeaveCharacter | EncodeCharacter
comment|//      decoded       |    1:leave      |    2:leave     |    3:encode
comment|//      encoded       |    4:decode     |    5:leave     |    6:leave
comment|// cases 1 and 2 were handled before this section
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|action
operator|!=
name|DecodeCharacter
condition|)
block|{
comment|// cases 5 and 6: it's encoded and we're leaving it as it is
comment|// except we're pedantic and we'll uppercase the hex
if|if
condition|(
name|output
operator|||
operator|!
name|isUpperHex
argument_list|(
name|input
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isUpperHex
argument_list|(
name|input
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|toUpperHex
argument_list|(
operator|*
operator|++
name|input
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|toUpperHex
argument_list|(
operator|*
operator|++
name|input
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|action
operator|==
name|DecodeCharacter
condition|)
block|{
comment|// case 4: we need to decode
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|decoded
expr_stmt|;
name|input
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|// must be case 3: we need to encode
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|output
condition|)
block|{
name|int
name|len
init|=
name|output
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|result
operator|.
name|truncate
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
name|len
operator|-
name|origSize
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     \internal      This function decodes a percent-encoded string located from \a begin to \a     end, by appending each character to \a appendTo. It returns the number of     characters appended. Each percent-encoded sequence is decoded as follows:      \list       \li from %00 to %7F: the exact decoded value is appended;       \li from %80 to %FF: QChar::ReplacementCharacter is appended;       \li bad encoding: original input is copied to the output, undecoded.     \endlist      Given the above, it's important for the input to already have all UTF-8     percent sequences decoded by qt_urlRecode (that is, the input should not     have been processed with QUrl::EncodeUnicode).      The input should also be a valid percent-encoded sequence (the output of     qt_urlRecode is always valid). */
end_comment
begin_function
DECL|function|decode
specifier|static
name|int
name|decode
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
specifier|const
name|ushort
modifier|*
name|begin
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|)
block|{
specifier|const
name|int
name|origSize
init|=
name|appendTo
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|input
init|=
name|begin
decl_stmt|;
name|ushort
modifier|*
name|output
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|input
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|input
operator|!=
literal|'%'
condition|)
block|{
if|if
condition|(
name|output
condition|)
operator|*
name|output
operator|++
operator|=
operator|*
name|input
expr_stmt|;
operator|++
name|input
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|end
operator|-
name|input
operator|<
literal|3
operator|||
operator|!
name|isHex
argument_list|(
name|input
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isHex
argument_list|(
name|input
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
block|{
comment|// badly-encoded data
name|appendTo
operator|.
name|resize
argument_list|(
name|origSize
operator|+
operator|(
name|end
operator|-
name|begin
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|appendTo
operator|.
name|begin
argument_list|()
operator|+
name|origSize
argument_list|,
name|begin
argument_list|,
operator|(
name|end
operator|-
name|begin
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|end
operator|-
name|begin
return|;
block|}
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
operator|!
name|output
argument_list|)
condition|)
block|{
comment|// detach
name|appendTo
operator|.
name|resize
argument_list|(
name|origSize
operator|+
operator|(
name|end
operator|-
name|begin
operator|)
argument_list|)
expr_stmt|;
name|output
operator|=
cast|reinterpret_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|appendTo
operator|.
name|begin
argument_list|()
argument_list|)
operator|+
name|origSize
expr_stmt|;
name|memcpy
argument_list|(
name|output
argument_list|,
name|begin
argument_list|,
operator|(
name|input
operator|-
name|begin
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|+=
name|input
operator|-
name|begin
expr_stmt|;
block|}
operator|++
name|input
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|decodeNibble
argument_list|(
name|input
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
operator||
name|decodeNibble
argument_list|(
name|input
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
index|[
operator|-
literal|1
index|]
operator|>=
literal|0x80
condition|)
name|output
index|[
operator|-
literal|1
index|]
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
name|input
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|output
condition|)
block|{
name|int
name|len
init|=
name|output
operator|-
cast|reinterpret_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|appendTo
operator|.
name|begin
argument_list|()
argument_list|)
decl_stmt|;
name|appendTo
operator|.
name|truncate
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
name|len
operator|-
name|origSize
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
template|template
parameter_list|<
name|size_t
name|N
parameter_list|>
DECL|variable|uchar
specifier|static
name|void
name|maskTable
argument_list|(
name|uchar
argument_list|(
operator|&
name|table
argument_list|)
index|[
name|N
index|]
argument_list|,
specifier|const
name|uchar
argument_list|(
operator|&
name|mask
argument_list|)
index|[
name|N
index|]
argument_list|)
argument_list|{     for
operator|(
name|size_t
name|i
operator|=
literal|0
expr|;
name|i
operator|<
name|N
expr|;
operator|++
name|i
operator|)
name|table
index|[
name|i
index|]
operator|&=
name|mask
index|[
name|i
index|]
argument_list|; }
comment|/*!     \internal      Recodes the string from \a begin to \a end. If any transformations are     done, append them to \a appendTo and return the number of characters added.     If no transformations were required, return 0.      The \a encoding option modifies the default behaviour:     \list     \li QUrl::DecodeReserved: if set, reserved characters will be decoded;                               if unset, reserved characters will be encoded     \li QUrl::EncodeSpaces: if set, spaces will be encoded to "%20"; if unset, they will be " "     \li QUrl::EncodeUnicode: if set, characters above U+0080 will be encoded to their UTF-8                              percent-encoded form; if unset, they will be decoded to UTF-16     \li QUrl::FullyDecoded: if set, this function will decode all percent-encoded sequences,                             including that of the percent character. The resulting string                             will not be percent-encoded anymore. Use with caution!                             In this mode, the behaviour is undefined if the input string                             contains any percent-encoding sequences above %80.                             Also, the function will not correct bad % sequences.     \endlist      Other flags are ignored (including QUrl::EncodeReserved).      The \a tableModifications argument can be used to supply extra     modifications to the tables, to be applied after the flags above are     handled. It consists of a sequence of 16-bit values, where the low 8 bits     indicate the character in question and the high 8 bits are either \c     EncodeCharacter, \c LeaveCharacter or \c DecodeCharacter.      This function corrects percent-encoded errors by interpreting every '%' as     meaning "%25" (all percents in the same content).  */
name|Q_AUTOTEST_EXPORT
name|int
DECL|function|qt_urlRecode
name|qt_urlRecode
argument_list|(
name|QString
operator|&
name|appendTo
argument_list|,
specifier|const
name|QChar
operator|*
name|begin
argument_list|,
specifier|const
name|QChar
operator|*
name|end
argument_list|,
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
argument_list|,
specifier|const
name|ushort
operator|*
name|tableModifications
argument_list|)
argument_list|{
name|uchar
name|actionTable
index|[
sizeof|sizeof
name|defaultActionTable
index|]
argument_list|;     if
operator|(
name|encoding
operator|==
name|QUrl
operator|::
name|FullyDecoded
operator|)
block|{
return|return
name|decode
argument_list|(
name|appendTo
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|begin
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|end
argument_list|)
argument_list|)
return|;
block|}
name|memcpy
argument_list|(
name|actionTable
argument_list|,
name|defaultActionTable
argument_list|,
sizeof|sizeof
name|actionTable
argument_list|)
argument_list|;     if
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|DecodeReserved
operator|)
name|maskTable
argument_list|(
name|actionTable
argument_list|,
name|reservedMask
argument_list|)
argument_list|;     if
operator|(
operator|!
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeSpaces
operator|)
operator|)
name|actionTable
index|[
literal|0
index|]
operator|=
name|DecodeCharacter
argument_list|;
comment|// decode
argument_list|if
operator|(
name|tableModifications
operator|)
block|{
for|for
control|(
specifier|const
name|ushort
modifier|*
name|p
type|=
name|tableModifications
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
name|actionTable
index|[
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
operator|-
literal|' '
index|]
operator|=
operator|*
name|p
operator|>>
literal|8
expr_stmt|;
block|}
return|return
name|recode
argument_list|(
name|appendTo
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|begin
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|end
argument_list|)
argument_list|,
name|encoding
argument_list|,
name|actionTable
argument_list|,
literal|false
argument_list|)
return|;
end_decl_stmt
begin_comment
unit|}
comment|/*!     \internal     \since 5.0      \a ba contains an 8-bit form of the component and it might be     percent-encoded already. We can't use QString::fromUtf8 because it might     contain non-UTF8 sequences. We can't use QByteArray::toPercentEncoding     because it might already contain percent-encoded sequences. We can't use     qt_urlRecode because it needs UTF-16 input. */
end_comment
begin_function
unit|Q_AUTOTEST_EXPORT
DECL|function|qt_urlRecodeByteArray
name|QString
name|qt_urlRecodeByteArray
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
if|if
condition|(
name|ba
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// scan ba for anything above or equal to 0x80
comment|// control points below 0x20 are fine in QString
specifier|const
name|char
modifier|*
name|in
init|=
name|ba
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|end
init|=
name|ba
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|in
operator|<
name|end
condition|;
operator|++
name|in
control|)
block|{
if|if
condition|(
operator|*
name|in
operator|&
literal|0x80
condition|)
break|break;
block|}
if|if
condition|(
name|in
operator|==
name|end
condition|)
block|{
comment|// no non-ASCII found, we're safe to convert to QString
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|ba
argument_list|,
name|ba
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|// we found something that we need to encode
name|QByteArray
name|intermediate
init|=
name|ba
decl_stmt|;
name|intermediate
operator|.
name|resize
argument_list|(
name|ba
operator|.
name|size
argument_list|()
operator|*
literal|3
operator|-
operator|(
name|in
operator|-
name|ba
operator|.
name|constData
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|out
init|=
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|intermediate
operator|.
name|data
argument_list|()
operator|+
operator|(
name|in
operator|-
name|ba
operator|.
name|constData
argument_list|()
operator|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|in
operator|<
name|end
condition|;
operator|++
name|in
control|)
block|{
if|if
condition|(
operator|*
name|in
operator|&
literal|0x80
condition|)
block|{
comment|// encode
operator|*
name|out
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|encodeNibble
argument_list|(
name|uchar
argument_list|(
operator|*
name|in
argument_list|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|encodeNibble
argument_list|(
name|uchar
argument_list|(
operator|*
name|in
argument_list|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// keep
operator|*
name|out
operator|++
operator|=
name|uchar
argument_list|(
operator|*
name|in
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now it's safe to call fromLatin1
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|intermediate
argument_list|,
name|out
operator|-
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|intermediate
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
