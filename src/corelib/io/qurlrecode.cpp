begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Intel Corporation ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qurl.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|// ### move to qurl_p.h
DECL|enum|EncodingAction
name|enum
name|EncodingAction
argument_list|{
DECL|enumerator|DecodeCharacter
name|DecodeCharacter
operator|=
literal|0
argument_list|,
DECL|enumerator|LeaveCharacter
name|LeaveCharacter
operator|=
literal|1
argument_list|,
DECL|enumerator|EncodeCharacter
name|EncodeCharacter
operator|=
literal|2
argument_list|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|// From RFC 3896, Appendix A Collected ABNF for URI
end_comment
begin_comment
comment|//    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
end_comment
begin_comment
comment|//    reserved      = gen-delims / sub-delims
end_comment
begin_comment
comment|//    gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
end_comment
begin_comment
comment|//    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
end_comment
begin_comment
comment|//                  / "*" / "+" / "," / ";" / "="
end_comment
begin_decl_stmt
DECL|variable|defaultActionTable
specifier|static
specifier|const
name|uchar
name|defaultActionTable
index|[
literal|96
index|]
init|=
block|{
literal|2
block|,
comment|// space
literal|1
block|,
comment|// '!' (sub-delim)
literal|2
block|,
comment|// '"'
literal|1
block|,
comment|// '#' (gen-delim)
literal|1
block|,
comment|// '$' (gen-delim)
literal|2
block|,
comment|// '%' (percent)
literal|1
block|,
comment|// '&' (gen-delim)
literal|1
block|,
comment|// "'" (sub-delim)
literal|1
block|,
comment|// '(' (sub-delim)
literal|1
block|,
comment|// ')' (sub-delim)
literal|1
block|,
comment|// '*' (sub-delim)
literal|1
block|,
comment|// '+' (sub-delim)
literal|1
block|,
comment|// ',' (sub-delim)
literal|0
block|,
comment|// '-' (unreserved)
literal|0
block|,
comment|// '.' (unreserved)
literal|1
block|,
comment|// '/' (gen-delim)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// '0' to '4' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// '5' to '9' (unreserved)
literal|1
block|,
comment|// ':' (gen-delim)
literal|1
block|,
comment|// ';' (sub-delim)
literal|2
block|,
comment|// '<'
literal|1
block|,
comment|// '=' (sub-delim)
literal|2
block|,
comment|// '>'
literal|1
block|,
comment|// '?' (gen-delim)
literal|1
block|,
comment|// '@' (gen-delim)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'A' to 'E' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'F' to 'J' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'K' to 'O' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'P' to 'T' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'U' to 'Z' (unreserved)
literal|1
block|,
comment|// '[' (gen-delim)
literal|2
block|,
comment|// '\'
literal|1
block|,
comment|// ']' (gen-delim)
literal|2
block|,
comment|// '^'
literal|0
block|,
comment|// '_' (unreserved)
literal|2
block|,
comment|// '`'
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'a' to 'e' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'f' to 'j' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'k' to 'o' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'p' to 't' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'u' to 'z' (unreserved)
literal|2
block|,
comment|// '{'
literal|2
block|,
comment|// '|'
literal|2
block|,
comment|// '}'
literal|0
block|,
comment|// '~' (unreserved)
literal|2
comment|// BSKP
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|// mask tables, in negative polarity
end_comment
begin_comment
comment|// 0x00 if it belongs to this category
end_comment
begin_comment
comment|// 0xff if it doesn't
end_comment
begin_decl_stmt
DECL|variable|delimsMask
specifier|static
specifier|const
name|uchar
name|delimsMask
index|[
literal|96
index|]
init|=
block|{
literal|0xff
block|,
comment|// space
literal|0x00
block|,
comment|// '!' (sub-delim)
literal|0xff
block|,
comment|// '"'
literal|0x00
block|,
comment|// '#' (gen-delim)
literal|0x00
block|,
comment|// '$' (gen-delim)
literal|0xff
block|,
comment|// '%' (percent)
literal|0x00
block|,
comment|// '&' (gen-delim)
literal|0x00
block|,
comment|// "'" (sub-delim)
literal|0x00
block|,
comment|// '(' (sub-delim)
literal|0x00
block|,
comment|// ')' (sub-delim)
literal|0x00
block|,
comment|// '*' (sub-delim)
literal|0x00
block|,
comment|// '+' (sub-delim)
literal|0x00
block|,
comment|// ',' (sub-delim)
literal|0xff
block|,
comment|// '-' (unreserved)
literal|0xff
block|,
comment|// '.' (unreserved)
literal|0x00
block|,
comment|// '/' (gen-delim)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// '0' to '4' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// '5' to '9' (unreserved)
literal|0x00
block|,
comment|// ':' (gen-delim)
literal|0x00
block|,
comment|// ';' (sub-delim)
literal|0xff
block|,
comment|// '<'
literal|0x00
block|,
comment|// '=' (sub-delim)
literal|0xff
block|,
comment|// '>'
literal|0x00
block|,
comment|// '?' (gen-delim)
literal|0x00
block|,
comment|// '@' (gen-delim)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'A' to 'E' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'F' to 'J' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'K' to 'O' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'P' to 'T' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'U' to 'Z' (unreserved)
literal|0x00
block|,
comment|// '[' (gen-delim)
literal|0xff
block|,
comment|// '\'
literal|0x00
block|,
comment|// ']' (gen-delim)
literal|0xff
block|,
comment|// '^'
literal|0xff
block|,
comment|// '_' (unreserved)
literal|0xff
block|,
comment|// '`'
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'a' to 'e' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'f' to 'j' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'k' to 'o' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'p' to 't' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'u' to 'z' (unreserved)
literal|0xff
block|,
comment|// '{'
literal|0xff
block|,
comment|// '|'
literal|0xff
block|,
comment|// '}'
literal|0xff
block|,
comment|// '~' (unreserved)
literal|0xff
comment|// BSKP
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|reservedMask
specifier|static
specifier|const
name|uchar
name|reservedMask
index|[
literal|96
index|]
init|=
block|{
literal|0xff
block|,
comment|// space
literal|0xff
block|,
comment|// '!' (sub-delim)
literal|0x00
block|,
comment|// '"'
literal|0xff
block|,
comment|// '#' (gen-delim)
literal|0xff
block|,
comment|// '$' (gen-delim)
literal|0xff
block|,
comment|// '%' (percent)
literal|0xff
block|,
comment|// '&' (gen-delim)
literal|0xff
block|,
comment|// "'" (sub-delim)
literal|0xff
block|,
comment|// '(' (sub-delim)
literal|0xff
block|,
comment|// ')' (sub-delim)
literal|0xff
block|,
comment|// '*' (sub-delim)
literal|0xff
block|,
comment|// '+' (sub-delim)
literal|0xff
block|,
comment|// ',' (sub-delim)
literal|0xff
block|,
comment|// '-' (unreserved)
literal|0xff
block|,
comment|// '.' (unreserved)
literal|0xff
block|,
comment|// '/' (gen-delim)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// '0' to '4' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// '5' to '9' (unreserved)
literal|0xff
block|,
comment|// ':' (gen-delim)
literal|0xff
block|,
comment|// ';' (sub-delim)
literal|0x00
block|,
comment|// '<'
literal|0xff
block|,
comment|// '=' (sub-delim)
literal|0x00
block|,
comment|// '>'
literal|0xff
block|,
comment|// '?' (gen-delim)
literal|0xff
block|,
comment|// '@' (gen-delim)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'A' to 'E' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'F' to 'J' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'K' to 'O' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'P' to 'T' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'U' to 'Z' (unreserved)
literal|0xff
block|,
comment|// '[' (gen-delim)
literal|0x00
block|,
comment|// '\'
literal|0xff
block|,
comment|// ']' (gen-delim)
literal|0x00
block|,
comment|// '^'
literal|0xff
block|,
comment|// '_' (unreserved)
literal|0x00
block|,
comment|// '`'
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'a' to 'e' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'f' to 'j' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'k' to 'o' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'p' to 't' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'u' to 'z' (unreserved)
literal|0x00
block|,
comment|// '{'
literal|0x00
block|,
comment|// '|'
literal|0x00
block|,
comment|// '}'
literal|0xff
block|,
comment|// '~' (unreserved)
literal|0xff
comment|// BSKP
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|isHex
specifier|static
specifier|inline
name|bool
name|isHex
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isUpperHex
specifier|static
specifier|inline
name|bool
name|isUpperHex
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
comment|// undefined behaviour if c isn't an hex char!
return|return
name|c
operator|<
literal|0x60
return|;
block|}
end_function
begin_function
DECL|function|toUpperHex
specifier|static
specifier|inline
name|ushort
name|toUpperHex
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
name|isUpperHex
argument_list|(
name|c
argument_list|)
condition|?
name|c
else|:
name|c
operator|-
literal|0x20
return|;
block|}
end_function
begin_function
DECL|function|decodeNibble
specifier|static
specifier|inline
name|ushort
name|decodeNibble
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
name|c
operator|>=
literal|'a'
condition|?
name|c
operator|-
literal|'a'
operator|+
literal|0xA
else|:
name|c
operator|>=
literal|'A'
condition|?
name|c
operator|-
literal|'A'
operator|+
literal|0xA
else|:
name|c
operator|-
literal|'0'
return|;
block|}
end_function
begin_comment
comment|// if the sequence at input is 2*HEXDIG, returns its decoding
end_comment
begin_comment
comment|// returns -1 if it isn't.
end_comment
begin_comment
comment|// assumes that the range has been checked already
end_comment
begin_function
DECL|function|decodePercentEncoding
specifier|static
specifier|inline
name|ushort
name|decodePercentEncoding
parameter_list|(
specifier|const
name|ushort
modifier|*
name|input
parameter_list|)
block|{
name|ushort
name|c1
init|=
name|input
index|[
literal|1
index|]
decl_stmt|;
name|ushort
name|c2
init|=
name|input
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isHex
argument_list|(
name|c1
argument_list|)
operator|||
operator|!
name|isHex
argument_list|(
name|c2
argument_list|)
condition|)
return|return
name|ushort
argument_list|(
operator|-
literal|1
argument_list|)
return|;
return|return
name|decodeNibble
argument_list|(
name|c1
argument_list|)
operator|<<
literal|4
operator||
name|decodeNibble
argument_list|(
name|c2
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|encodeNibble
specifier|static
specifier|inline
name|ushort
name|encodeNibble
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
specifier|static
specifier|const
name|uchar
name|hexnumbers
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
return|return
name|hexnumbers
index|[
name|c
operator|&
literal|0xf
index|]
return|;
block|}
end_function
begin_function
DECL|function|ensureDetached
specifier|static
name|void
name|ensureDetached
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
name|ushort
modifier|*
modifier|&
name|output
parameter_list|,
specifier|const
name|ushort
modifier|*
name|begin
parameter_list|,
specifier|const
name|ushort
modifier|*
name|input
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|,
name|int
name|add
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
operator|!
name|output
condition|)
block|{
comment|// now detach
comment|// create enough space if the rest of the string needed to be percent-encoded
name|int
name|charsProcessed
init|=
name|input
operator|-
name|begin
decl_stmt|;
name|int
name|charsRemaining
init|=
name|end
operator|-
name|input
decl_stmt|;
name|int
name|spaceNeeded
init|=
name|end
operator|-
name|begin
operator|+
literal|2
operator|*
name|charsRemaining
operator|+
name|add
decl_stmt|;
name|int
name|origSize
init|=
name|result
operator|.
name|size
argument_list|()
decl_stmt|;
name|result
operator|.
name|resize
argument_list|(
name|origSize
operator|+
name|spaceNeeded
argument_list|)
expr_stmt|;
comment|// we know that resize() above detached, so we bypass the reference count check
name|output
operator|=
cast|const_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
operator|+
name|origSize
expr_stmt|;
comment|// copy the chars we've already processed
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|charsProcessed
condition|;
operator|++
name|i
control|)
name|output
index|[
name|i
index|]
operator|=
name|begin
index|[
name|i
index|]
expr_stmt|;
name|output
operator|+=
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// returns true if we performed an UTF-8 decoding
end_comment
begin_function
DECL|function|encodedUtf8ToUtf16
specifier|static
name|bool
name|encodedUtf8ToUtf16
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
name|ushort
modifier|*
modifier|&
name|output
parameter_list|,
specifier|const
name|ushort
modifier|*
name|begin
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|input
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|,
name|ushort
name|decoded
parameter_list|)
block|{
name|int
name|charsNeeded
decl_stmt|;
name|uint
name|min_uc
decl_stmt|;
name|uint
name|uc
decl_stmt|;
if|if
condition|(
name|decoded
operator|<=
literal|0xC1
condition|)
block|{
comment|// an UTF-8 first character must be at least 0xC0
comment|// however, all 0xC0 and 0xC1 first bytes can only produce overlong sequences
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|<
literal|0xe0
condition|)
block|{
name|charsNeeded
operator|=
literal|2
expr_stmt|;
name|min_uc
operator|=
literal|0x80
expr_stmt|;
name|uc
operator|=
name|decoded
operator|&
literal|0x1f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|<
literal|0xf0
condition|)
block|{
name|charsNeeded
operator|=
literal|3
expr_stmt|;
name|min_uc
operator|=
literal|0x800
expr_stmt|;
name|uc
operator|=
name|decoded
operator|&
literal|0x0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|<
literal|0xf5
condition|)
block|{
name|charsNeeded
operator|=
literal|4
expr_stmt|;
name|min_uc
operator|=
literal|0x10000
expr_stmt|;
name|uc
operator|=
name|decoded
operator|&
literal|0x07
expr_stmt|;
block|}
else|else
block|{
comment|// the last Unicode character is U+10FFFF
comment|// it's encoded in UTF-8 as "\xF4\x8F\xBF\xBF"
comment|// therefore, a byte higher than 0xF4 is not the UTF-8 first byte
return|return
literal|false
return|;
block|}
comment|// are there enough remaining?
if|if
condition|(
name|end
operator|-
name|input
operator|<
literal|3
operator|*
name|charsNeeded
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|input
index|[
literal|3
index|]
operator|!=
literal|'%'
condition|)
return|return
literal|false
return|;
comment|// first continuation character
name|decoded
operator|=
name|decodePercentEncoding
argument_list|(
name|input
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|decoded
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
literal|false
return|;
name|uc
operator|<<=
literal|6
expr_stmt|;
name|uc
operator||=
name|decoded
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|charsNeeded
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|input
index|[
literal|6
index|]
operator|!=
literal|'%'
condition|)
return|return
literal|false
return|;
comment|// second continuation character
name|decoded
operator|=
name|decodePercentEncoding
argument_list|(
name|input
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|decoded
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
literal|false
return|;
name|uc
operator|<<=
literal|6
expr_stmt|;
name|uc
operator||=
name|decoded
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|charsNeeded
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|input
index|[
literal|9
index|]
operator|!=
literal|'%'
condition|)
return|return
literal|false
return|;
comment|// third continuation character
name|decoded
operator|=
name|decodePercentEncoding
argument_list|(
name|input
operator|+
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|decoded
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
literal|false
return|;
name|uc
operator|<<=
literal|6
expr_stmt|;
name|uc
operator||=
name|decoded
operator|&
literal|0x3f
expr_stmt|;
block|}
block|}
comment|// we've decoded something; safety-check it
if|if
condition|(
name|uc
operator|<
name|min_uc
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|QChar
operator|::
name|isSurrogate
argument_list|(
name|uc
argument_list|)
operator|||
name|QChar
operator|::
name|isNonCharacter
argument_list|(
name|uc
argument_list|)
operator|||
name|uc
operator|>
name|QChar
operator|::
name|LastValidCodePoint
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|uc
argument_list|)
condition|)
block|{
comment|// UTF-8 decoded and no surrogates are required
comment|// detach if necessary
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
operator|-
literal|9
operator|*
name|charsNeeded
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|uc
expr_stmt|;
block|}
else|else
block|{
comment|// UTF-8 decoded to something that requires a surrogate pair
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
operator|-
literal|9
operator|*
name|charsNeeded
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|uc
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|uc
argument_list|)
expr_stmt|;
block|}
name|input
operator|+=
name|charsNeeded
operator|*
literal|3
operator|-
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|unicodeToEncodedUtf8
specifier|static
name|void
name|unicodeToEncodedUtf8
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
name|ushort
modifier|*
modifier|&
name|output
parameter_list|,
specifier|const
name|ushort
modifier|*
name|begin
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|input
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|,
name|ushort
name|decoded
parameter_list|)
block|{
name|uint
name|uc
init|=
name|decoded
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|uc
argument_list|)
condition|)
block|{
if|if
condition|(
name|input
operator|<
name|end
operator|&&
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|input
index|[
literal|1
index|]
argument_list|)
condition|)
name|uc
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|uc
argument_list|,
name|input
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|// note: we will encode bad UTF-16 to UTF-8
comment|// but they don't get decoded back
comment|// calculate the utf8 length
name|int
name|utf8len
init|=
name|uc
operator|>=
literal|0x10000
condition|?
literal|4
else|:
name|uc
operator|>=
literal|0x800
condition|?
literal|3
else|:
literal|2
decl_stmt|;
comment|// detach
if|if
condition|(
operator|!
name|output
condition|)
block|{
comment|// we need 3 * utf8len for the encoded UTF-8 sequence
comment|// but ensureDetached already adds 3 for the char we're processing
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
literal|3
operator|*
name|utf8len
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// verify that there's enough space or expand
name|int
name|charsRemaining
init|=
name|end
operator|-
name|input
operator|-
literal|1
decl_stmt|;
comment|// not including this one
name|int
name|pos
init|=
name|output
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|spaceRemaining
init|=
name|result
operator|.
name|size
argument_list|()
operator|-
name|pos
decl_stmt|;
if|if
condition|(
name|spaceRemaining
operator|<
literal|3
operator|*
name|charsRemaining
operator|+
literal|3
operator|*
name|utf8len
condition|)
block|{
comment|// must resize
name|result
operator|.
name|resize
argument_list|(
name|result
operator|.
name|size
argument_list|()
operator|+
literal|3
operator|*
name|utf8len
argument_list|)
expr_stmt|;
comment|// we know that resize() above detached, so we bypass the reference count check
name|output
operator|=
cast|const_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|+=
name|pos
expr_stmt|;
block|}
block|}
comment|// write the sequence
if|if
condition|(
name|uc
operator|<
literal|0x800
condition|)
block|{
comment|// first of two bytes
name|uchar
name|c
init|=
literal|0xc0
operator||
name|uchar
argument_list|(
name|uc
operator|>>
literal|6
argument_list|)
decl_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uchar
name|c
decl_stmt|;
if|if
condition|(
name|uc
operator|>
literal|0xFFFF
condition|)
block|{
comment|// first two of four bytes
name|c
operator|=
literal|0xf0
operator||
name|uchar
argument_list|(
name|uc
operator|>>
literal|18
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'F'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
comment|// continuation byte
name|c
operator|=
literal|0x80
operator||
operator|(
name|uchar
argument_list|(
name|uc
operator|>>
literal|12
argument_list|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
comment|// this was a surrogate pair
operator|++
name|input
expr_stmt|;
block|}
else|else
block|{
comment|// first of three bytes
name|c
operator|=
literal|0xe0
operator||
name|uchar
argument_list|(
name|uc
operator|>>
literal|12
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'E'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
comment|// continuation byte
name|c
operator|=
literal|0x80
operator||
operator|(
name|uchar
argument_list|(
name|uc
operator|>>
literal|6
argument_list|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
comment|// continuation byte
name|uchar
name|c
init|=
literal|0x80
operator||
operator|(
name|uc
operator|&
literal|0x3f
operator|)
decl_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|recode
specifier|static
name|int
name|recode
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
specifier|const
name|ushort
modifier|*
name|begin
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|,
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
parameter_list|,
specifier|const
name|uchar
modifier|*
name|actionTable
parameter_list|,
name|bool
name|retryBadEncoding
parameter_list|)
block|{
specifier|const
name|int
name|origSize
init|=
name|result
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|input
init|=
name|begin
decl_stmt|;
name|ushort
modifier|*
name|output
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|input
operator|!=
name|end
condition|;
operator|++
name|input
control|)
block|{
name|ushort
name|c
decl_stmt|;
name|EncodingAction
name|action
decl_stmt|;
comment|// try a run where no change is necessary
for|for
control|(
init|;
name|input
operator|!=
name|end
condition|;
operator|++
name|input
control|)
block|{
name|c
operator|=
operator|*
name|input
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x20U
condition|)
name|action
operator|=
name|EncodeCharacter
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x20U
operator|||
name|c
operator|>=
literal|0x80U
condition|)
comment|// also: (c - 0x20< 0x60U)
goto|goto
name|non_trivial
goto|;
name|action
operator|=
name|EncodingAction
argument_list|(
name|actionTable
index|[
name|c
operator|-
literal|' '
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|EncodeCharacter
condition|)
goto|goto
name|non_trivial
goto|;
if|if
condition|(
name|output
condition|)
operator|*
name|output
operator|++
operator|=
name|c
expr_stmt|;
block|}
break|break;
name|non_trivial
label|:
name|uint
name|decoded
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|retryBadEncoding
condition|)
block|{
comment|// always write "%25"
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'2'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'5'
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
comment|// check if the input is valid
if|if
condition|(
name|input
operator|+
literal|2
operator|>=
name|end
operator|||
operator|(
name|decoded
operator|=
name|decodePercentEncoding
argument_list|(
name|input
argument_list|)
operator|)
operator|==
name|ushort
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|// not valid, retry
name|result
operator|.
name|resize
argument_list|(
name|origSize
argument_list|)
expr_stmt|;
return|return
name|recode
argument_list|(
name|result
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|encoding
argument_list|,
name|actionTable
argument_list|,
literal|true
argument_list|)
return|;
block|}
if|if
condition|(
name|decoded
operator|>=
literal|0x80
condition|)
block|{
comment|// decode the UTF-8 sequence
if|if
condition|(
operator|!
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeUnicode
operator|)
operator|&&
name|encodedUtf8ToUtf16
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
name|decoded
argument_list|)
condition|)
continue|continue;
comment|// decoding the encoded UTF-8 failed
name|action
operator|=
name|LeaveCharacter
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|>=
literal|0x20
condition|)
block|{
name|action
operator|=
name|EncodingAction
argument_list|(
name|actionTable
index|[
name|decoded
operator|-
literal|' '
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|decoded
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|decoded
operator|>=
literal|0x80
operator|&&
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeUnicode
condition|)
block|{
comment|// encode the UTF-8 sequence
name|unicodeToEncodedUtf8
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|>=
literal|0x80
condition|)
block|{
if|if
condition|(
name|output
condition|)
operator|*
name|output
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
block|}
comment|// there are six possibilities:
comment|//  current \ action  | DecodeCharacter | LeaveCharacter | EncodeCharacter
comment|//      decoded       |    1:leave      |    2:leave     |    3:encode
comment|//      encoded       |    4:decode     |    5:leave     |    6:leave
comment|// cases 1 and 2 were handled before this section
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|action
operator|!=
name|DecodeCharacter
condition|)
block|{
comment|// cases 5 and 6: it's encoded and we're leaving it as it is
comment|// except we're pedantic and we'll uppercase the hex
if|if
condition|(
name|output
operator|||
operator|!
name|isUpperHex
argument_list|(
name|input
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isUpperHex
argument_list|(
name|input
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|toUpperHex
argument_list|(
operator|*
operator|++
name|input
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|toUpperHex
argument_list|(
operator|*
operator|++
name|input
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|action
operator|==
name|DecodeCharacter
condition|)
block|{
comment|// case 4: we need to decode
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|decoded
expr_stmt|;
name|input
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|// must be case 3: we need to encode
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|output
condition|)
block|{
name|int
name|len
init|=
name|output
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|result
operator|.
name|truncate
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
name|len
operator|-
name|origSize
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|decode
specifier|static
name|int
name|decode
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
specifier|const
name|ushort
modifier|*
name|begin
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|)
block|{
specifier|const
name|int
name|origSize
init|=
name|appendTo
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|input
init|=
name|begin
decl_stmt|;
name|ushort
modifier|*
name|output
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|input
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|input
operator|!=
literal|'%'
condition|)
block|{
if|if
condition|(
name|output
condition|)
operator|*
name|output
operator|++
operator|=
operator|*
name|input
expr_stmt|;
operator|++
name|input
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|end
operator|-
name|input
operator|<
literal|3
operator|||
operator|!
name|isHex
argument_list|(
name|input
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isHex
argument_list|(
name|input
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
block|{
comment|// badly-encoded data
name|appendTo
operator|.
name|resize
argument_list|(
name|origSize
operator|+
operator|(
name|end
operator|-
name|begin
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|appendTo
operator|.
name|begin
argument_list|()
operator|+
name|origSize
argument_list|,
name|begin
argument_list|,
operator|(
name|end
operator|-
name|begin
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|end
operator|-
name|begin
return|;
block|}
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
operator|!
name|output
argument_list|)
condition|)
block|{
comment|// detach
name|appendTo
operator|.
name|resize
argument_list|(
name|origSize
operator|+
operator|(
name|end
operator|-
name|begin
operator|)
argument_list|)
expr_stmt|;
name|output
operator|=
cast|reinterpret_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|appendTo
operator|.
name|begin
argument_list|()
argument_list|)
operator|+
name|origSize
expr_stmt|;
name|memcpy
argument_list|(
name|output
argument_list|,
name|begin
argument_list|,
operator|(
name|input
operator|-
name|begin
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|+=
name|input
operator|-
name|begin
expr_stmt|;
block|}
operator|++
name|input
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|decodeNibble
argument_list|(
name|input
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
operator||
name|decodeNibble
argument_list|(
name|input
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|input
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|output
condition|)
block|{
name|int
name|len
init|=
name|output
operator|-
cast|reinterpret_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|appendTo
operator|.
name|begin
argument_list|()
argument_list|)
decl_stmt|;
name|appendTo
operator|.
name|truncate
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
name|len
operator|-
name|origSize
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
template|template
parameter_list|<
name|size_t
name|N
parameter_list|>
DECL|variable|uchar
specifier|static
name|void
name|maskTable
argument_list|(
name|uchar
argument_list|(
operator|&
name|table
argument_list|)
index|[
name|N
index|]
argument_list|,
specifier|const
name|uchar
argument_list|(
operator|&
name|mask
argument_list|)
index|[
name|N
index|]
argument_list|)
argument_list|{     for
operator|(
name|size_t
name|i
operator|=
literal|0
expr|;
name|i
operator|<
name|N
expr|;
operator|++
name|i
operator|)
name|table
index|[
name|i
index|]
operator|&=
name|mask
index|[
name|i
index|]
argument_list|; }
comment|/*!     \internal      Recodes the string from \a begin to \a end. If any transformations are     done, append them to \a appendTo and return the number of characters added.     If no transformations were required, return 0.      The \a encoding option modifies the default behaviour:     \list     \li QUrl::EncodeDelimiters: if set, delimiters will be left untransformed (note: not encoded!);                                 if unset, delimiters will be decoded     \li QUrl::DecodeReserved: if set, reserved characters will be decoded;                               if unset, reserved characters will be encoded     \li QUrl::EncodeSpaces: if set, spaces will be encoded to "%20"; if unset, they will be " "     \li QUrl::EncodeUnicode: if set, characters above U+0080 will be encoded to their UTF-8                              percent-encoded form; if unset, they will be decoded to UTF-16     \li QUrl::FullyDecoded: if set, this function will decode all percent-encoded sequences,                             including that of the percent character. The resulting string                             will not be percent-encoded anymore. Use with caution!                             In this mode, the behaviour is undefined if the input string                             contains any percent-encoding sequences above %80.                             Also, the function will not correct bad % sequences.     \endlist      Other flags are ignored (including QUrl::EncodeReserved).      The \a tableModifications argument can be used to supply extra     modifications to the tables, to be applied after the flags above are     handled. It consists of a sequence of 16-bit values, where the low 8 bits     indicate the character in question and the high 8 bits are either \c     EncodeCharacter, \c LeaveCharacter or \c DecodeCharacter.      This function corrects percent-encoded errors by interpreting every '%' as     meaning "%25" (all percents in the same content).  */
name|Q_AUTOTEST_EXPORT
name|int
DECL|function|qt_urlRecode
name|qt_urlRecode
argument_list|(
name|QString
operator|&
name|appendTo
argument_list|,
specifier|const
name|QChar
operator|*
name|begin
argument_list|,
specifier|const
name|QChar
operator|*
name|end
argument_list|,
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
argument_list|,
specifier|const
name|ushort
operator|*
name|tableModifications
argument_list|)
argument_list|{
name|uchar
name|actionTable
index|[
sizeof|sizeof
name|defaultActionTable
index|]
argument_list|;     if
operator|(
name|encoding
operator|==
name|QUrl
operator|::
name|FullyDecoded
operator|)
block|{
return|return
name|decode
argument_list|(
name|appendTo
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|begin
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|end
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeDelimiters
operator|)
operator|&&
name|encoding
operator|&
name|QUrl
operator|::
name|DecodeReserved
condition|)
block|{
comment|// reset the table
name|memset
argument_list|(
name|actionTable
argument_list|,
name|DecodeCharacter
argument_list|,
sizeof|sizeof
name|actionTable
argument_list|)
block|;
end_decl_stmt
begin_if
if|if
condition|(
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeSpaces
condition|)
name|actionTable
index|[
literal|0
index|]
operator|=
name|EncodeCharacter
expr_stmt|;
end_if
begin_comment
comment|// these are always encoded
end_comment
begin_expr_stmt
name|actionTable
index|[
literal|'%'
operator|-
literal|' '
index|]
operator|=
name|EncodeCharacter
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|actionTable
index|[
literal|0x7F
operator|-
literal|' '
index|]
operator|=
name|EncodeCharacter
expr_stmt|;
end_expr_stmt
begin_block
unit|} else
block|{
name|memcpy
argument_list|(
name|actionTable
argument_list|,
name|defaultActionTable
argument_list|,
sizeof|sizeof
name|actionTable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeDelimiters
operator|)
condition|)
name|maskTable
argument_list|(
name|actionTable
argument_list|,
name|delimsMask
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoding
operator|&
name|QUrl
operator|::
name|DecodeReserved
condition|)
name|maskTable
argument_list|(
name|actionTable
argument_list|,
name|reservedMask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeSpaces
operator|)
condition|)
name|actionTable
index|[
literal|0
index|]
operator|=
name|DecodeCharacter
expr_stmt|;
comment|// decode
block|}
end_block
begin_if
if|if
condition|(
name|tableModifications
condition|)
block|{
for|for
control|(
specifier|const
name|ushort
modifier|*
name|p
init|=
name|tableModifications
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
name|actionTable
index|[
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
operator|-
literal|' '
index|]
operator|=
operator|*
name|p
operator|>>
literal|8
expr_stmt|;
block|}
end_if
begin_return
return|return
name|recode
argument_list|(
name|appendTo
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|begin
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|end
argument_list|)
argument_list|,
name|encoding
argument_list|,
name|actionTable
argument_list|,
literal|false
argument_list|)
return|;
end_return
begin_comment
unit|}
comment|/*!     \internal     \since 5.0      \a ba contains an 8-bit form of the component and it might be     percent-encoded already. We can't use QString::fromUtf8 because it might     contain non-UTF8 sequences. We can't use QByteArray::toPercentEncoding     because it might already contain percent-encoded sequences. We can't use     qt_urlRecode because it needs UTF-16 input. */
end_comment
begin_function
unit|Q_AUTOTEST_EXPORT
DECL|function|qt_urlRecodeByteArray
name|QString
name|qt_urlRecodeByteArray
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
if|if
condition|(
name|ba
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// scan ba for anything above or equal to 0x80
comment|// control points below 0x20 are fine in QString
specifier|const
name|char
modifier|*
name|in
init|=
name|ba
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|end
init|=
name|ba
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|in
operator|<
name|end
condition|;
operator|++
name|in
control|)
block|{
if|if
condition|(
operator|*
name|in
operator|&
literal|0x80
condition|)
break|break;
block|}
if|if
condition|(
name|in
operator|==
name|end
condition|)
block|{
comment|// no non-ASCII found, we're safe to convert to QString
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|ba
argument_list|,
name|ba
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|// we found something that we need to encode
name|QByteArray
name|intermediate
init|=
name|ba
decl_stmt|;
name|intermediate
operator|.
name|resize
argument_list|(
name|ba
operator|.
name|size
argument_list|()
operator|*
literal|3
operator|-
operator|(
name|in
operator|-
name|ba
operator|.
name|constData
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|out
init|=
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|intermediate
operator|.
name|data
argument_list|()
operator|+
operator|(
name|in
operator|-
name|ba
operator|.
name|constData
argument_list|()
operator|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|in
operator|<
name|end
condition|;
operator|++
name|in
control|)
block|{
if|if
condition|(
operator|*
name|in
operator|&
literal|0x80
condition|)
block|{
comment|// encode
operator|*
name|out
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|encodeNibble
argument_list|(
name|uchar
argument_list|(
operator|*
name|in
argument_list|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|encodeNibble
argument_list|(
name|uchar
argument_list|(
operator|*
name|in
argument_list|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// keep
operator|*
name|out
operator|++
operator|=
name|uchar
argument_list|(
operator|*
name|in
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now it's safe to call fromLatin1
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|intermediate
argument_list|,
name|out
operator|-
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|intermediate
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
