begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Intel Corporation ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qurl.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|// ### move to qurl_p.h
DECL|enum|EncodingAction
name|enum
name|EncodingAction
argument_list|{
DECL|enumerator|DecodeCharacter
name|DecodeCharacter
operator|=
literal|0
argument_list|,
DECL|enumerator|LeaveCharacter
name|LeaveCharacter
operator|=
literal|1
argument_list|,
DECL|enumerator|EncodeCharacter
name|EncodeCharacter
operator|=
literal|2
argument_list|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|// From RFC 3896, Appendix A Collected ABNF for URI
end_comment
begin_comment
comment|//    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
end_comment
begin_comment
comment|//    reserved      = gen-delims / sub-delims
end_comment
begin_comment
comment|//    gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
end_comment
begin_comment
comment|//    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
end_comment
begin_comment
comment|//                  / "*" / "+" / "," / ";" / "="
end_comment
begin_decl_stmt
DECL|variable|defaultActionTable
specifier|static
specifier|const
name|uchar
name|defaultActionTable
index|[
literal|96
index|]
init|=
block|{
literal|2
block|,
comment|// space
literal|1
block|,
comment|// '!' (sub-delim)
literal|2
block|,
comment|// '"'
literal|1
block|,
comment|// '#' (gen-delim)
literal|1
block|,
comment|// '$' (gen-delim)
literal|2
block|,
comment|// '%' (percent)
literal|1
block|,
comment|// '&' (gen-delim)
literal|1
block|,
comment|// "'" (sub-delim)
literal|1
block|,
comment|// '(' (sub-delim)
literal|1
block|,
comment|// ')' (sub-delim)
literal|1
block|,
comment|// '*' (sub-delim)
literal|1
block|,
comment|// '+' (sub-delim)
literal|1
block|,
comment|// ',' (sub-delim)
literal|0
block|,
comment|// '-' (unreserved)
literal|0
block|,
comment|// '.' (unreserved)
literal|1
block|,
comment|// '/' (gen-delim)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// '0' to '4' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// '5' to '9' (unreserved)
literal|1
block|,
comment|// ':' (gen-delim)
literal|1
block|,
comment|// ';' (sub-delim)
literal|2
block|,
comment|// '<'
literal|1
block|,
comment|// '=' (sub-delim)
literal|2
block|,
comment|// '>'
literal|1
block|,
comment|// '?' (gen-delim)
literal|1
block|,
comment|// '@' (gen-delim)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'A' to 'E' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'F' to 'J' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'K' to 'O' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'P' to 'T' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'U' to 'Z' (unreserved)
literal|1
block|,
comment|// '[' (gen-delim)
literal|2
block|,
comment|// '\'
literal|1
block|,
comment|// ']' (gen-delim)
literal|2
block|,
comment|// '^'
literal|0
block|,
comment|// '_' (unreserved)
literal|2
block|,
comment|// '`'
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'a' to 'e' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'f' to 'j' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'k' to 'o' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'p' to 't' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'u' to 'z' (unreserved)
literal|2
block|,
comment|// '{'
literal|2
block|,
comment|// '|'
literal|2
block|,
comment|// '}'
literal|0
block|,
comment|// '~' (unreserved)
literal|2
comment|// BSKP
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|isHex
specifier|static
specifier|inline
name|bool
name|isHex
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isUpperHex
specifier|static
specifier|inline
name|bool
name|isUpperHex
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
comment|// undefined behaviour if c isn't an hex char!
return|return
name|c
operator|<
literal|0x60
return|;
block|}
end_function
begin_function
DECL|function|toUpperHex
specifier|static
specifier|inline
name|ushort
name|toUpperHex
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
name|isUpperHex
argument_list|(
name|c
argument_list|)
condition|?
name|c
else|:
name|c
operator|-
literal|0x20
return|;
block|}
end_function
begin_function
DECL|function|decodeNibble
specifier|static
specifier|inline
name|ushort
name|decodeNibble
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
name|c
operator|>=
literal|'a'
condition|?
name|c
operator|-
literal|'a'
operator|+
literal|0xA
else|:
name|c
operator|>=
literal|'A'
condition|?
name|c
operator|-
literal|'A'
operator|+
literal|0xA
else|:
name|c
operator|-
literal|'0'
return|;
block|}
end_function
begin_comment
comment|// if the sequence at input is 2*HEXDIG, returns its decoding
end_comment
begin_comment
comment|// returns -1 if it isn't.
end_comment
begin_comment
comment|// assumes that the range has been checked already
end_comment
begin_function
DECL|function|decodePercentEncoding
specifier|static
specifier|inline
name|ushort
name|decodePercentEncoding
parameter_list|(
specifier|const
name|ushort
modifier|*
name|input
parameter_list|)
block|{
name|ushort
name|c1
init|=
name|input
index|[
literal|0
index|]
decl_stmt|;
name|ushort
name|c2
init|=
name|input
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isHex
argument_list|(
name|c1
argument_list|)
operator|||
operator|!
name|isHex
argument_list|(
name|c2
argument_list|)
condition|)
return|return
name|ushort
argument_list|(
operator|-
literal|1
argument_list|)
return|;
return|return
name|decodeNibble
argument_list|(
name|c1
argument_list|)
operator|<<
literal|4
operator||
name|decodeNibble
argument_list|(
name|c2
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|encodeNibble
specifier|static
specifier|inline
name|ushort
name|encodeNibble
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
specifier|static
specifier|const
name|uchar
name|hexnumbers
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
return|return
name|hexnumbers
index|[
name|c
operator|&
literal|0xf
index|]
return|;
block|}
end_function
begin_function
DECL|function|ensureDetached
specifier|static
name|void
name|ensureDetached
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
name|ushort
modifier|*
modifier|&
name|output
parameter_list|,
specifier|const
name|ushort
modifier|*
name|input
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|)
block|{
if|if
condition|(
operator|!
name|output
condition|)
block|{
comment|// now detach
comment|// create enough space if the rest of the string needed to be percent-encoded
name|int
name|charsProcessed
init|=
name|input
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|charsRemaining
init|=
name|end
operator|-
name|input
operator|+
literal|1
decl_stmt|;
name|int
name|newSize
init|=
name|result
operator|.
name|size
argument_list|()
operator|+
literal|2
operator|*
name|charsRemaining
decl_stmt|;
name|result
operator|.
name|resize
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
comment|// set the output variable
name|output
operator|=
cast|reinterpret_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|data
argument_list|()
argument_list|)
operator|+
name|charsProcessed
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|isUnicodeNonCharacter
specifier|static
specifier|inline
name|bool
name|isUnicodeNonCharacter
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
comment|// Unicode has a couple of "non-characters" that one can use internally,
comment|// but are not allowed to be used for text interchange.
comment|//
comment|// Those are the last two entries each Unicode Plane (U+FFFE, U+FFFF,
comment|// U+1FFFE, U+1FFFF, etc.) as well as the entries between U+FDD0 and
comment|// U+FDEF (inclusive)
return|return
operator|(
name|ucs4
operator|&
literal|0xfffe
operator|)
operator|==
literal|0xfffe
operator|||
operator|(
name|ucs4
operator|-
literal|0xfdd0U
operator|)
operator|<
literal|16
return|;
block|}
end_function
begin_comment
comment|// returns true if we performed an UTF-8 decoding
end_comment
begin_function
DECL|function|encodedUtf8ToUcs4
specifier|static
name|uint
name|encodedUtf8ToUcs4
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
name|ushort
modifier|*
modifier|&
name|output
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|input
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|,
name|ushort
name|decoded
parameter_list|)
block|{
name|int
name|charsNeeded
decl_stmt|;
name|uint
name|min_uc
decl_stmt|;
name|uint
name|uc
decl_stmt|;
if|if
condition|(
name|decoded
operator|<=
literal|0xC1
condition|)
block|{
comment|// an UTF-8 first character must be at least 0xC0
comment|// however, all 0xC0 and 0xC1 first bytes can only produce overlong sequences
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|<
literal|0xe0
condition|)
block|{
name|charsNeeded
operator|=
literal|1
expr_stmt|;
name|min_uc
operator|=
literal|0x80
expr_stmt|;
name|uc
operator|=
name|decoded
operator|&
literal|0x1f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|<
literal|0xf0
condition|)
block|{
name|charsNeeded
operator|=
literal|2
expr_stmt|;
name|min_uc
operator|=
literal|0x800
expr_stmt|;
name|uc
operator|=
name|decoded
operator|&
literal|0x0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|<
literal|0xf5
condition|)
block|{
name|charsNeeded
operator|=
literal|3
expr_stmt|;
name|min_uc
operator|=
literal|0x10000
expr_stmt|;
name|uc
operator|=
name|decoded
operator|&
literal|0x07
expr_stmt|;
block|}
else|else
block|{
comment|// the last Unicode character is U+10FFFF
comment|// it's encoded in UTF-8 as "\xF4\x8F\xBF\xBF"
comment|// therefore, a byte higher than 0xF4 is not the UTF-8 first byte
return|return
literal|false
return|;
block|}
comment|// are there enough remaining?
if|if
condition|(
name|end
operator|-
name|input
operator|<
literal|3
operator|*
name|charsNeeded
operator|+
literal|2
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|input
index|[
literal|2
index|]
operator|!=
literal|'%'
condition|)
return|return
literal|false
return|;
comment|// first continuation character
name|decoded
operator|=
name|decodePercentEncoding
argument_list|(
name|input
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|decoded
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
literal|false
return|;
name|uc
operator|<<=
literal|6
expr_stmt|;
name|uc
operator||=
name|decoded
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|charsNeeded
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|input
index|[
literal|5
index|]
operator|!=
literal|'%'
condition|)
return|return
literal|false
return|;
comment|// second continuation character
name|decoded
operator|=
name|decodePercentEncoding
argument_list|(
name|input
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|decoded
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
literal|false
return|;
name|uc
operator|<<=
literal|6
expr_stmt|;
name|uc
operator||=
name|decoded
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|charsNeeded
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|input
index|[
literal|8
index|]
operator|!=
literal|'%'
condition|)
return|return
literal|false
return|;
comment|// third continuation character
name|decoded
operator|=
name|decodePercentEncoding
argument_list|(
name|input
operator|+
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|decoded
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
literal|false
return|;
name|uc
operator|<<=
literal|6
expr_stmt|;
name|uc
operator||=
name|decoded
operator|&
literal|0x3f
expr_stmt|;
block|}
block|}
comment|// we've decoded something; safety-check it
if|if
condition|(
name|uc
operator|<
name|min_uc
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|isUnicodeNonCharacter
argument_list|(
name|uc
argument_list|)
operator|||
operator|(
name|uc
operator|>=
literal|0xD800
operator|&&
name|uc
operator|<=
literal|0xDFFF
operator|)
operator|||
name|uc
operator|>=
literal|0x110000
condition|)
return|return
literal|false
return|;
comment|// detach if necessary
if|if
condition|(
operator|!
name|output
condition|)
block|{
comment|// create enough space if the rest of the string needed to be percent-encoded
name|int
name|charsProcessed
init|=
name|input
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|charsRemaining
init|=
name|end
operator|-
name|input
operator|-
literal|2
operator|-
literal|3
operator|*
name|charsNeeded
decl_stmt|;
name|int
name|newSize
init|=
name|result
operator|.
name|size
argument_list|()
operator|+
literal|2
operator|*
name|charsRemaining
decl_stmt|;
name|result
operator|.
name|resize
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
comment|// set the output variable
name|output
operator|=
cast|reinterpret_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|data
argument_list|()
argument_list|)
operator|+
name|charsProcessed
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|uc
argument_list|)
condition|)
block|{
comment|// UTF-8 decoded and no surrogates are required
operator|*
name|output
operator|++
operator|=
name|uc
expr_stmt|;
block|}
else|else
block|{
comment|// UTF-8 decoded to something that requires a surrogate pair
operator|*
name|output
operator|++
operator|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|uc
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|uc
argument_list|)
expr_stmt|;
block|}
name|input
operator|+=
name|charsNeeded
operator|*
literal|3
operator|+
literal|2
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|unicodeToEncodedUtf8
specifier|static
name|void
name|unicodeToEncodedUtf8
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
name|ushort
modifier|*
modifier|&
name|output
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|input
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|,
name|ushort
name|decoded
parameter_list|)
block|{
name|uint
name|uc
init|=
name|decoded
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|uc
argument_list|)
condition|)
block|{
if|if
condition|(
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
operator|*
name|input
argument_list|)
condition|)
name|uc
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|uc
argument_list|,
operator|*
name|input
argument_list|)
expr_stmt|;
block|}
comment|// note: we will encode bad UTF-16 to UTF-8
comment|// but they don't get decoded back
comment|// calculate the utf8 length
name|int
name|utf8len
init|=
name|uc
operator|>=
literal|0x10000
condition|?
literal|4
else|:
name|uc
operator|>=
literal|0x800
condition|?
literal|3
else|:
literal|2
decl_stmt|;
comment|// detach
if|if
condition|(
operator|!
name|output
condition|)
block|{
comment|// create enough space if the rest of the string needed to be percent-encoded
name|int
name|charsProcessed
init|=
name|input
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|charsRemaining
init|=
name|end
operator|-
name|input
decl_stmt|;
name|int
name|newSize
init|=
name|result
operator|.
name|size
argument_list|()
operator|+
literal|2
operator|*
name|charsRemaining
operator|-
literal|1
operator|+
literal|3
operator|*
name|utf8len
decl_stmt|;
name|result
operator|.
name|resize
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
comment|// set the output variable
name|output
operator|=
cast|reinterpret_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|data
argument_list|()
argument_list|)
operator|+
name|charsProcessed
expr_stmt|;
block|}
else|else
block|{
comment|// verify that there's enough space or expand
name|int
name|charsRemaining
init|=
name|end
operator|-
name|input
decl_stmt|;
name|int
name|pos
init|=
name|output
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|spaceRemaining
init|=
name|result
operator|.
name|size
argument_list|()
operator|-
name|pos
decl_stmt|;
if|if
condition|(
name|spaceRemaining
operator|<
literal|3
operator|*
name|charsRemaining
operator|+
literal|3
operator|*
name|utf8len
condition|)
block|{
comment|// must resize
name|result
operator|.
name|resize
argument_list|(
name|result
operator|.
name|size
argument_list|()
operator|+
literal|3
operator|*
name|utf8len
argument_list|)
expr_stmt|;
name|output
operator|=
cast|reinterpret_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|data
argument_list|()
argument_list|)
operator|+
name|pos
expr_stmt|;
block|}
block|}
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|uc
argument_list|)
condition|)
operator|++
name|input
expr_stmt|;
comment|// write the sequence
if|if
condition|(
name|uc
operator|<
literal|0x800
condition|)
block|{
comment|// first of two bytes
name|uchar
name|c
init|=
literal|0xc0
operator||
name|uchar
argument_list|(
name|uc
operator|>>
literal|6
argument_list|)
decl_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uchar
name|c
decl_stmt|;
if|if
condition|(
name|uc
operator|>
literal|0xFFFF
condition|)
block|{
comment|// first two of four bytes
name|c
operator|=
literal|0xf0
operator||
name|uchar
argument_list|(
name|uc
operator|>>
literal|18
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'F'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
comment|// continuation byte
name|c
operator|=
literal|0x80
operator||
operator|(
name|uchar
argument_list|(
name|uc
operator|>>
literal|12
argument_list|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// first of three bytes
name|c
operator|=
literal|0xe0
operator||
name|uchar
argument_list|(
name|uc
operator|>>
literal|12
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'E'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
comment|// continuation byte
name|c
operator|=
literal|0x80
operator||
operator|(
name|uchar
argument_list|(
name|uc
operator|>>
literal|6
argument_list|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
comment|// continuation byte
name|uchar
name|c
init|=
literal|0x80
operator||
operator|(
name|uc
operator|&
literal|0x3f
operator|)
decl_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|recode
specifier|static
name|QString
name|recode
parameter_list|(
specifier|const
name|QString
modifier|&
name|component
parameter_list|,
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
parameter_list|,
specifier|const
name|uchar
modifier|*
name|actionTable
parameter_list|,
name|bool
name|retryBadEncoding
parameter_list|)
block|{
name|QString
name|result
init|=
name|component
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|input
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|component
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
specifier|const
name|end
init|=
name|input
operator|+
name|component
operator|.
name|length
argument_list|()
decl_stmt|;
name|ushort
modifier|*
name|output
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|input
operator|!=
name|end
condition|)
block|{
specifier|register
name|ushort
name|c
decl_stmt|;
name|EncodingAction
name|action
decl_stmt|;
comment|// try a run where no change is necessary
while|while
condition|(
name|input
operator|!=
name|end
condition|)
block|{
name|c
operator|=
operator|*
name|input
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x20
operator|||
name|c
operator|>=
literal|0x80
condition|)
comment|// also: (c - 0x20< 0x60U)
goto|goto
name|non_trivial
goto|;
name|action
operator|=
name|EncodingAction
argument_list|(
name|actionTable
index|[
name|c
operator|-
literal|' '
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|EncodeCharacter
condition|)
goto|goto
name|non_trivial
goto|;
if|if
condition|(
name|output
condition|)
operator|*
name|output
operator|++
operator|=
name|c
expr_stmt|;
block|}
break|break;
name|non_trivial
label|:
specifier|register
name|uint
name|decoded
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|retryBadEncoding
condition|)
block|{
comment|// always write "%25"
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'2'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'5'
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
comment|// check if the input is valid
if|if
condition|(
name|input
operator|+
literal|1
operator|>=
name|end
operator|||
operator|(
name|decoded
operator|=
name|decodePercentEncoding
argument_list|(
name|input
argument_list|)
operator|)
operator|==
name|ushort
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|// not valid, retry
name|result
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|recode
argument_list|(
name|component
argument_list|,
name|encoding
argument_list|,
name|actionTable
argument_list|,
literal|true
argument_list|)
return|;
block|}
if|if
condition|(
name|decoded
operator|>=
literal|0x80
condition|)
block|{
comment|// decode the UTF-8 sequence
if|if
condition|(
name|encoding
operator|&
name|QUrl
operator|::
name|DecodeUnicode
operator|&&
name|encodedUtf8ToUcs4
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
name|decoded
argument_list|)
condition|)
continue|continue;
comment|// decoding the encoded UTF-8 failed
name|action
operator|=
name|LeaveCharacter
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|>=
literal|0x20
condition|)
block|{
name|action
operator|=
name|EncodingAction
argument_list|(
name|actionTable
index|[
name|decoded
operator|-
literal|' '
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|decoded
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|decoded
operator|>=
literal|0x80
operator|&&
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|DecodeUnicode
operator|)
operator|==
literal|0
condition|)
block|{
comment|// encode the UTF-8 sequence
name|unicodeToEncodedUtf8
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|>=
literal|0x80
condition|)
block|{
if|if
condition|(
name|output
condition|)
operator|*
name|output
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|decoded
operator|<
literal|0x20
condition|)
name|action
operator|=
name|EncodeCharacter
expr_stmt|;
comment|// there are six possibilities:
comment|//  current \ action  | DecodeCharacter | LeaveCharacter | EncodeCharacter
comment|//      decoded       |    1:leave      |    2:leave     |    3:encode
comment|//      encoded       |    4:decode     |    5:leave     |    6:leave
comment|// cases 1 and 2 were handled before this section
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|action
operator|!=
name|DecodeCharacter
condition|)
block|{
comment|// cases 5 and 6: it's encoded and we're leaving it as it is
comment|// except we're pedantic and we'll uppercase the hex
if|if
condition|(
name|output
operator|||
operator|!
name|isUpperHex
argument_list|(
name|input
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|isUpperHex
argument_list|(
name|input
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|toUpperHex
argument_list|(
operator|*
name|input
operator|++
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|toUpperHex
argument_list|(
operator|*
name|input
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|action
operator|==
name|DecodeCharacter
condition|)
block|{
comment|// case 4: we need to decode
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|decoded
expr_stmt|;
name|input
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|// must be case 3: we need to encode
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|output
condition|)
name|result
operator|.
name|truncate
argument_list|(
name|output
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
name|Q_AUTOTEST_EXPORT
name|QString
DECL|function|qt_urlRecode
name|qt_urlRecode
parameter_list|(
specifier|const
name|QString
modifier|&
name|component
parameter_list|,
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
parameter_list|,
specifier|const
name|ushort
modifier|*
name|tableModifications
parameter_list|)
block|{
name|uchar
name|actionTable
index|[
sizeof|sizeof
name|defaultActionTable
index|]
decl_stmt|;
if|if
condition|(
name|encoding
operator|&
name|QUrl
operator|::
name|DecodeAllDelimiters
condition|)
block|{
comment|// reset the table
name|memset
argument_list|(
name|actionTable
argument_list|,
name|DecodeCharacter
argument_list|,
sizeof|sizeof
name|actionTable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|DecodeSpaces
operator|)
condition|)
name|actionTable
index|[
literal|0
index|]
operator|=
name|EncodeCharacter
expr_stmt|;
comment|// these are always encoded
name|actionTable
index|[
literal|'%'
operator|-
literal|' '
index|]
operator|=
name|EncodeCharacter
expr_stmt|;
name|actionTable
index|[
literal|0x7F
operator|-
literal|' '
index|]
operator|=
name|EncodeCharacter
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|actionTable
argument_list|,
name|defaultActionTable
argument_list|,
sizeof|sizeof
name|actionTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoding
operator|&
name|QUrl
operator|::
name|DecodeSpaces
condition|)
name|actionTable
index|[
literal|0
index|]
operator|=
name|DecodeCharacter
expr_stmt|;
comment|// decode
block|}
if|if
condition|(
name|tableModifications
condition|)
block|{
for|for
control|(
specifier|const
name|ushort
modifier|*
name|p
init|=
name|tableModifications
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
name|actionTable
index|[
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
operator|-
literal|' '
index|]
operator|=
operator|*
name|p
operator|>>
literal|8
expr_stmt|;
block|}
return|return
name|recode
argument_list|(
name|component
argument_list|,
name|encoding
argument_list|,
name|actionTable
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
