begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Intel Corporation ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qurl.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|// ### move to qurl_p.h
DECL|enum|EncodingAction
name|enum
name|EncodingAction
argument_list|{
DECL|enumerator|DecodeCharacter
name|DecodeCharacter
operator|=
literal|0
argument_list|,
DECL|enumerator|LeaveCharacter
name|LeaveCharacter
operator|=
literal|1
argument_list|,
DECL|enumerator|EncodeCharacter
name|EncodeCharacter
operator|=
literal|2
argument_list|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|// From RFC 3896, Appendix A Collected ABNF for URI
end_comment
begin_comment
comment|//    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
end_comment
begin_comment
comment|//    reserved      = gen-delims / sub-delims
end_comment
begin_comment
comment|//    gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
end_comment
begin_comment
comment|//    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
end_comment
begin_comment
comment|//                  / "*" / "+" / "," / ";" / "="
end_comment
begin_decl_stmt
DECL|variable|defaultActionTable
specifier|static
specifier|const
name|uchar
name|defaultActionTable
index|[
literal|96
index|]
init|=
block|{
literal|2
block|,
comment|// space
literal|1
block|,
comment|// '!' (sub-delim)
literal|2
block|,
comment|// '"'
literal|1
block|,
comment|// '#' (gen-delim)
literal|1
block|,
comment|// '$' (gen-delim)
literal|2
block|,
comment|// '%' (percent)
literal|1
block|,
comment|// '&' (gen-delim)
literal|1
block|,
comment|// "'" (sub-delim)
literal|1
block|,
comment|// '(' (sub-delim)
literal|1
block|,
comment|// ')' (sub-delim)
literal|1
block|,
comment|// '*' (sub-delim)
literal|1
block|,
comment|// '+' (sub-delim)
literal|1
block|,
comment|// ',' (sub-delim)
literal|0
block|,
comment|// '-' (unreserved)
literal|0
block|,
comment|// '.' (unreserved)
literal|1
block|,
comment|// '/' (gen-delim)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// '0' to '4' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// '5' to '9' (unreserved)
literal|1
block|,
comment|// ':' (gen-delim)
literal|1
block|,
comment|// ';' (sub-delim)
literal|2
block|,
comment|// '<'
literal|1
block|,
comment|// '=' (sub-delim)
literal|2
block|,
comment|// '>'
literal|1
block|,
comment|// '?' (gen-delim)
literal|1
block|,
comment|// '@' (gen-delim)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'A' to 'E' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'F' to 'J' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'K' to 'O' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'P' to 'T' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'U' to 'Z' (unreserved)
literal|1
block|,
comment|// '[' (gen-delim)
literal|2
block|,
comment|// '\'
literal|1
block|,
comment|// ']' (gen-delim)
literal|2
block|,
comment|// '^'
literal|0
block|,
comment|// '_' (unreserved)
literal|2
block|,
comment|// '`'
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'a' to 'e' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'f' to 'j' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'k' to 'o' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'p' to 't' (unreserved)
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// 'u' to 'z' (unreserved)
literal|2
block|,
comment|// '{'
literal|2
block|,
comment|// '|'
literal|2
block|,
comment|// '}'
literal|0
block|,
comment|// '~' (unreserved)
literal|2
comment|// BSKP
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|// mask tables, in negative polarity
end_comment
begin_comment
comment|// 0x00 if it belongs to this category
end_comment
begin_comment
comment|// 0xff if it doesn't
end_comment
begin_decl_stmt
DECL|variable|delimsMask
specifier|static
specifier|const
name|uchar
name|delimsMask
index|[
literal|96
index|]
init|=
block|{
literal|0xff
block|,
comment|// space
literal|0x00
block|,
comment|// '!' (sub-delim)
literal|0xff
block|,
comment|// '"'
literal|0x00
block|,
comment|// '#' (gen-delim)
literal|0x00
block|,
comment|// '$' (gen-delim)
literal|0xff
block|,
comment|// '%' (percent)
literal|0x00
block|,
comment|// '&' (gen-delim)
literal|0x00
block|,
comment|// "'" (sub-delim)
literal|0x00
block|,
comment|// '(' (sub-delim)
literal|0x00
block|,
comment|// ')' (sub-delim)
literal|0x00
block|,
comment|// '*' (sub-delim)
literal|0x00
block|,
comment|// '+' (sub-delim)
literal|0x00
block|,
comment|// ',' (sub-delim)
literal|0xff
block|,
comment|// '-' (unreserved)
literal|0xff
block|,
comment|// '.' (unreserved)
literal|0x00
block|,
comment|// '/' (gen-delim)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// '0' to '4' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// '5' to '9' (unreserved)
literal|0x00
block|,
comment|// ':' (gen-delim)
literal|0x00
block|,
comment|// ';' (sub-delim)
literal|0xff
block|,
comment|// '<'
literal|0x00
block|,
comment|// '=' (sub-delim)
literal|0xff
block|,
comment|// '>'
literal|0x00
block|,
comment|// '?' (gen-delim)
literal|0x00
block|,
comment|// '@' (gen-delim)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'A' to 'E' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'F' to 'J' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'K' to 'O' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'P' to 'T' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'U' to 'Z' (unreserved)
literal|0x00
block|,
comment|// '[' (gen-delim)
literal|0xff
block|,
comment|// '\'
literal|0x00
block|,
comment|// ']' (gen-delim)
literal|0xff
block|,
comment|// '^'
literal|0xff
block|,
comment|// '_' (unreserved)
literal|0xff
block|,
comment|// '`'
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'a' to 'e' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'f' to 'j' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'k' to 'o' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'p' to 't' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'u' to 'z' (unreserved)
literal|0xff
block|,
comment|// '{'
literal|0xff
block|,
comment|// '|'
literal|0xff
block|,
comment|// '}'
literal|0xff
block|,
comment|// '~' (unreserved)
literal|0xff
comment|// BSKP
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|reservedMask
specifier|static
specifier|const
name|uchar
name|reservedMask
index|[
literal|96
index|]
init|=
block|{
literal|0xff
block|,
comment|// space
literal|0xff
block|,
comment|// '!' (sub-delim)
literal|0x00
block|,
comment|// '"'
literal|0xff
block|,
comment|// '#' (gen-delim)
literal|0xff
block|,
comment|// '$' (gen-delim)
literal|0xff
block|,
comment|// '%' (percent)
literal|0xff
block|,
comment|// '&' (gen-delim)
literal|0xff
block|,
comment|// "'" (sub-delim)
literal|0xff
block|,
comment|// '(' (sub-delim)
literal|0xff
block|,
comment|// ')' (sub-delim)
literal|0xff
block|,
comment|// '*' (sub-delim)
literal|0xff
block|,
comment|// '+' (sub-delim)
literal|0xff
block|,
comment|// ',' (sub-delim)
literal|0xff
block|,
comment|// '-' (unreserved)
literal|0xff
block|,
comment|// '.' (unreserved)
literal|0xff
block|,
comment|// '/' (gen-delim)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// '0' to '4' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// '5' to '9' (unreserved)
literal|0xff
block|,
comment|// ':' (gen-delim)
literal|0xff
block|,
comment|// ';' (sub-delim)
literal|0x00
block|,
comment|// '<'
literal|0xff
block|,
comment|// '=' (sub-delim)
literal|0x00
block|,
comment|// '>'
literal|0xff
block|,
comment|// '?' (gen-delim)
literal|0xff
block|,
comment|// '@' (gen-delim)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'A' to 'E' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'F' to 'J' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'K' to 'O' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'P' to 'T' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'U' to 'Z' (unreserved)
literal|0xff
block|,
comment|// '[' (gen-delim)
literal|0x00
block|,
comment|// '\'
literal|0xff
block|,
comment|// ']' (gen-delim)
literal|0x00
block|,
comment|// '^'
literal|0xff
block|,
comment|// '_' (unreserved)
literal|0x00
block|,
comment|// '`'
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'a' to 'e' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'f' to 'j' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'k' to 'o' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'p' to 't' (unreserved)
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|// 'u' to 'z' (unreserved)
literal|0x00
block|,
comment|// '{'
literal|0x00
block|,
comment|// '|'
literal|0x00
block|,
comment|// '}'
literal|0xff
block|,
comment|// '~' (unreserved)
literal|0xff
comment|// BSKP
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|isHex
specifier|static
specifier|inline
name|bool
name|isHex
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isUpperHex
specifier|static
specifier|inline
name|bool
name|isUpperHex
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
comment|// undefined behaviour if c isn't an hex char!
return|return
name|c
operator|<
literal|0x60
return|;
block|}
end_function
begin_function
DECL|function|toUpperHex
specifier|static
specifier|inline
name|ushort
name|toUpperHex
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
name|isUpperHex
argument_list|(
name|c
argument_list|)
condition|?
name|c
else|:
name|c
operator|-
literal|0x20
return|;
block|}
end_function
begin_function
DECL|function|decodeNibble
specifier|static
specifier|inline
name|ushort
name|decodeNibble
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
return|return
name|c
operator|>=
literal|'a'
condition|?
name|c
operator|-
literal|'a'
operator|+
literal|0xA
else|:
name|c
operator|>=
literal|'A'
condition|?
name|c
operator|-
literal|'A'
operator|+
literal|0xA
else|:
name|c
operator|-
literal|'0'
return|;
block|}
end_function
begin_comment
comment|// if the sequence at input is 2*HEXDIG, returns its decoding
end_comment
begin_comment
comment|// returns -1 if it isn't.
end_comment
begin_comment
comment|// assumes that the range has been checked already
end_comment
begin_function
DECL|function|decodePercentEncoding
specifier|static
specifier|inline
name|ushort
name|decodePercentEncoding
parameter_list|(
specifier|const
name|ushort
modifier|*
name|input
parameter_list|)
block|{
name|ushort
name|c1
init|=
name|input
index|[
literal|1
index|]
decl_stmt|;
name|ushort
name|c2
init|=
name|input
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isHex
argument_list|(
name|c1
argument_list|)
operator|||
operator|!
name|isHex
argument_list|(
name|c2
argument_list|)
condition|)
return|return
name|ushort
argument_list|(
operator|-
literal|1
argument_list|)
return|;
return|return
name|decodeNibble
argument_list|(
name|c1
argument_list|)
operator|<<
literal|4
operator||
name|decodeNibble
argument_list|(
name|c2
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|encodeNibble
specifier|static
specifier|inline
name|ushort
name|encodeNibble
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
specifier|static
specifier|const
name|uchar
name|hexnumbers
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
return|return
name|hexnumbers
index|[
name|c
operator|&
literal|0xf
index|]
return|;
block|}
end_function
begin_function
DECL|function|ensureDetached
specifier|static
name|void
name|ensureDetached
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
name|ushort
modifier|*
modifier|&
name|output
parameter_list|,
specifier|const
name|ushort
modifier|*
name|begin
parameter_list|,
specifier|const
name|ushort
modifier|*
name|input
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|,
name|int
name|add
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
operator|!
name|output
condition|)
block|{
comment|// now detach
comment|// create enough space if the rest of the string needed to be percent-encoded
name|int
name|charsProcessed
init|=
name|input
operator|-
name|begin
decl_stmt|;
name|int
name|charsRemaining
init|=
name|end
operator|-
name|input
decl_stmt|;
name|int
name|spaceNeeded
init|=
name|end
operator|-
name|begin
operator|+
literal|2
operator|*
name|charsRemaining
operator|+
name|add
decl_stmt|;
name|int
name|origSize
init|=
name|result
operator|.
name|size
argument_list|()
decl_stmt|;
name|result
operator|.
name|resize
argument_list|(
name|origSize
operator|+
name|spaceNeeded
argument_list|)
expr_stmt|;
comment|// we know that resize() above detached, so we bypass the reference count check
name|output
operator|=
cast|const_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
operator|+
name|origSize
expr_stmt|;
comment|// copy the chars we've already processed
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|charsProcessed
condition|;
operator|++
name|i
control|)
name|output
index|[
name|i
index|]
operator|=
name|begin
index|[
name|i
index|]
expr_stmt|;
name|output
operator|+=
name|i
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|isUnicodeNonCharacter
specifier|static
specifier|inline
name|bool
name|isUnicodeNonCharacter
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
comment|// Unicode has a couple of "non-characters" that one can use internally,
comment|// but are not allowed to be used for text interchange.
comment|//
comment|// Those are the last two entries each Unicode Plane (U+FFFE, U+FFFF,
comment|// U+1FFFE, U+1FFFF, etc.) as well as the entries between U+FDD0 and
comment|// U+FDEF (inclusive)
return|return
operator|(
name|ucs4
operator|&
literal|0xfffe
operator|)
operator|==
literal|0xfffe
operator|||
operator|(
name|ucs4
operator|-
literal|0xfdd0U
operator|)
operator|<
literal|16
return|;
block|}
end_function
begin_comment
comment|// returns true if we performed an UTF-8 decoding
end_comment
begin_function
DECL|function|encodedUtf8ToUtf16
specifier|static
name|bool
name|encodedUtf8ToUtf16
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
name|ushort
modifier|*
modifier|&
name|output
parameter_list|,
specifier|const
name|ushort
modifier|*
name|begin
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|input
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|,
name|ushort
name|decoded
parameter_list|)
block|{
name|int
name|charsNeeded
decl_stmt|;
name|uint
name|min_uc
decl_stmt|;
name|uint
name|uc
decl_stmt|;
if|if
condition|(
name|decoded
operator|<=
literal|0xC1
condition|)
block|{
comment|// an UTF-8 first character must be at least 0xC0
comment|// however, all 0xC0 and 0xC1 first bytes can only produce overlong sequences
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|<
literal|0xe0
condition|)
block|{
name|charsNeeded
operator|=
literal|2
expr_stmt|;
name|min_uc
operator|=
literal|0x80
expr_stmt|;
name|uc
operator|=
name|decoded
operator|&
literal|0x1f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|<
literal|0xf0
condition|)
block|{
name|charsNeeded
operator|=
literal|3
expr_stmt|;
name|min_uc
operator|=
literal|0x800
expr_stmt|;
name|uc
operator|=
name|decoded
operator|&
literal|0x0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|<
literal|0xf5
condition|)
block|{
name|charsNeeded
operator|=
literal|4
expr_stmt|;
name|min_uc
operator|=
literal|0x10000
expr_stmt|;
name|uc
operator|=
name|decoded
operator|&
literal|0x07
expr_stmt|;
block|}
else|else
block|{
comment|// the last Unicode character is U+10FFFF
comment|// it's encoded in UTF-8 as "\xF4\x8F\xBF\xBF"
comment|// therefore, a byte higher than 0xF4 is not the UTF-8 first byte
return|return
literal|false
return|;
block|}
comment|// are there enough remaining?
if|if
condition|(
name|end
operator|-
name|input
operator|<
literal|3
operator|*
name|charsNeeded
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|input
index|[
literal|3
index|]
operator|!=
literal|'%'
condition|)
return|return
literal|false
return|;
comment|// first continuation character
name|decoded
operator|=
name|decodePercentEncoding
argument_list|(
name|input
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|decoded
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
literal|false
return|;
name|uc
operator|<<=
literal|6
expr_stmt|;
name|uc
operator||=
name|decoded
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|charsNeeded
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|input
index|[
literal|6
index|]
operator|!=
literal|'%'
condition|)
return|return
literal|false
return|;
comment|// second continuation character
name|decoded
operator|=
name|decodePercentEncoding
argument_list|(
name|input
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|decoded
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
literal|false
return|;
name|uc
operator|<<=
literal|6
expr_stmt|;
name|uc
operator||=
name|decoded
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|charsNeeded
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|input
index|[
literal|9
index|]
operator|!=
literal|'%'
condition|)
return|return
literal|false
return|;
comment|// third continuation character
name|decoded
operator|=
name|decodePercentEncoding
argument_list|(
name|input
operator|+
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|decoded
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
literal|false
return|;
name|uc
operator|<<=
literal|6
expr_stmt|;
name|uc
operator||=
name|decoded
operator|&
literal|0x3f
expr_stmt|;
block|}
block|}
comment|// we've decoded something; safety-check it
if|if
condition|(
name|uc
operator|<
name|min_uc
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|isUnicodeNonCharacter
argument_list|(
name|uc
argument_list|)
operator|||
operator|(
name|uc
operator|>=
literal|0xD800
operator|&&
name|uc
operator|<=
literal|0xDFFF
operator|)
operator|||
name|uc
operator|>=
literal|0x110000
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|uc
argument_list|)
condition|)
block|{
comment|// UTF-8 decoded and no surrogates are required
comment|// detach if necessary
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
operator|-
literal|9
operator|*
name|charsNeeded
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|uc
expr_stmt|;
block|}
else|else
block|{
comment|// UTF-8 decoded to something that requires a surrogate pair
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
operator|-
literal|9
operator|*
name|charsNeeded
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|uc
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|uc
argument_list|)
expr_stmt|;
block|}
name|input
operator|+=
name|charsNeeded
operator|*
literal|3
operator|-
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|unicodeToEncodedUtf8
specifier|static
name|void
name|unicodeToEncodedUtf8
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
name|ushort
modifier|*
modifier|&
name|output
parameter_list|,
specifier|const
name|ushort
modifier|*
name|begin
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|input
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|,
name|ushort
name|decoded
parameter_list|)
block|{
name|uint
name|uc
init|=
name|decoded
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|uc
argument_list|)
condition|)
block|{
if|if
condition|(
name|input
operator|<
name|end
operator|&&
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|input
index|[
literal|1
index|]
argument_list|)
condition|)
name|uc
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|uc
argument_list|,
name|input
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|// note: we will encode bad UTF-16 to UTF-8
comment|// but they don't get decoded back
comment|// calculate the utf8 length
name|int
name|utf8len
init|=
name|uc
operator|>=
literal|0x10000
condition|?
literal|4
else|:
name|uc
operator|>=
literal|0x800
condition|?
literal|3
else|:
literal|2
decl_stmt|;
comment|// detach
if|if
condition|(
operator|!
name|output
condition|)
block|{
comment|// we need 3 * utf8len for the encoded UTF-8 sequence
comment|// but ensureDetached already adds 3 for the char we're processing
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
literal|3
operator|*
name|utf8len
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// verify that there's enough space or expand
name|int
name|charsRemaining
init|=
name|end
operator|-
name|input
operator|-
literal|1
decl_stmt|;
comment|// not including this one
name|int
name|pos
init|=
name|output
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|spaceRemaining
init|=
name|result
operator|.
name|size
argument_list|()
operator|-
name|pos
decl_stmt|;
if|if
condition|(
name|spaceRemaining
operator|<
literal|3
operator|*
name|charsRemaining
operator|+
literal|3
operator|*
name|utf8len
condition|)
block|{
comment|// must resize
name|result
operator|.
name|resize
argument_list|(
name|result
operator|.
name|size
argument_list|()
operator|+
literal|3
operator|*
name|utf8len
argument_list|)
expr_stmt|;
comment|// we know that resize() above detached, so we bypass the reference count check
name|output
operator|=
cast|const_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|+=
name|pos
expr_stmt|;
block|}
block|}
comment|// write the sequence
if|if
condition|(
name|uc
operator|<
literal|0x800
condition|)
block|{
comment|// first of two bytes
name|uchar
name|c
init|=
literal|0xc0
operator||
name|uchar
argument_list|(
name|uc
operator|>>
literal|6
argument_list|)
decl_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uchar
name|c
decl_stmt|;
if|if
condition|(
name|uc
operator|>
literal|0xFFFF
condition|)
block|{
comment|// first two of four bytes
name|c
operator|=
literal|0xf0
operator||
name|uchar
argument_list|(
name|uc
operator|>>
literal|18
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'F'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
comment|// continuation byte
name|c
operator|=
literal|0x80
operator||
operator|(
name|uchar
argument_list|(
name|uc
operator|>>
literal|12
argument_list|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
comment|// this was a surrogate pair
operator|++
name|input
expr_stmt|;
block|}
else|else
block|{
comment|// first of three bytes
name|c
operator|=
literal|0xe0
operator||
name|uchar
argument_list|(
name|uc
operator|>>
literal|12
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'E'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
comment|// continuation byte
name|c
operator|=
literal|0x80
operator||
operator|(
name|uchar
argument_list|(
name|uc
operator|>>
literal|6
argument_list|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
comment|// continuation byte
name|uchar
name|c
init|=
literal|0x80
operator||
operator|(
name|uc
operator|&
literal|0x3f
operator|)
decl_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|recode
specifier|static
name|int
name|recode
parameter_list|(
name|QString
modifier|&
name|result
parameter_list|,
specifier|const
name|ushort
modifier|*
name|begin
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|,
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
parameter_list|,
specifier|const
name|uchar
modifier|*
name|actionTable
parameter_list|,
name|bool
name|retryBadEncoding
parameter_list|)
block|{
specifier|const
name|int
name|origSize
init|=
name|result
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|input
init|=
name|begin
decl_stmt|;
name|ushort
modifier|*
name|output
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|input
operator|!=
name|end
condition|;
operator|++
name|input
control|)
block|{
specifier|register
name|ushort
name|c
decl_stmt|;
name|EncodingAction
name|action
decl_stmt|;
comment|// try a run where no change is necessary
for|for
control|(
init|;
name|input
operator|!=
name|end
condition|;
operator|++
name|input
control|)
block|{
name|c
operator|=
operator|*
name|input
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x20U
condition|)
name|action
operator|=
name|EncodeCharacter
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x20U
operator|||
name|c
operator|>=
literal|0x80U
condition|)
comment|// also: (c - 0x20< 0x60U)
goto|goto
name|non_trivial
goto|;
name|action
operator|=
name|EncodingAction
argument_list|(
name|actionTable
index|[
name|c
operator|-
literal|' '
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|EncodeCharacter
condition|)
goto|goto
name|non_trivial
goto|;
if|if
condition|(
name|output
condition|)
operator|*
name|output
operator|++
operator|=
name|c
expr_stmt|;
block|}
break|break;
name|non_trivial
label|:
specifier|register
name|uint
name|decoded
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|retryBadEncoding
condition|)
block|{
comment|// always write "%25"
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'2'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'5'
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
comment|// check if the input is valid
if|if
condition|(
name|input
operator|+
literal|2
operator|>=
name|end
operator|||
operator|(
name|decoded
operator|=
name|decodePercentEncoding
argument_list|(
name|input
argument_list|)
operator|)
operator|==
name|ushort
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|// not valid, retry
name|result
operator|.
name|resize
argument_list|(
name|origSize
argument_list|)
expr_stmt|;
return|return
name|recode
argument_list|(
name|result
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|encoding
argument_list|,
name|actionTable
argument_list|,
literal|true
argument_list|)
return|;
block|}
if|if
condition|(
name|decoded
operator|>=
literal|0x80
condition|)
block|{
comment|// decode the UTF-8 sequence
if|if
condition|(
operator|!
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeUnicode
operator|)
operator|&&
name|encodedUtf8ToUtf16
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
name|decoded
argument_list|)
condition|)
continue|continue;
comment|// decoding the encoded UTF-8 failed
name|action
operator|=
name|LeaveCharacter
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|>=
literal|0x20
condition|)
block|{
name|action
operator|=
name|EncodingAction
argument_list|(
name|actionTable
index|[
name|decoded
operator|-
literal|' '
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|decoded
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|decoded
operator|>=
literal|0x80
operator|&&
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeUnicode
condition|)
block|{
comment|// encode the UTF-8 sequence
name|unicodeToEncodedUtf8
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|>=
literal|0x80
condition|)
block|{
if|if
condition|(
name|output
condition|)
operator|*
name|output
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
block|}
comment|// there are six possibilities:
comment|//  current \ action  | DecodeCharacter | LeaveCharacter | EncodeCharacter
comment|//      decoded       |    1:leave      |    2:leave     |    3:encode
comment|//      encoded       |    4:decode     |    5:leave     |    6:leave
comment|// cases 1 and 2 were handled before this section
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|action
operator|!=
name|DecodeCharacter
condition|)
block|{
comment|// cases 5 and 6: it's encoded and we're leaving it as it is
comment|// except we're pedantic and we'll uppercase the hex
if|if
condition|(
name|output
operator|||
operator|!
name|isUpperHex
argument_list|(
name|input
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isUpperHex
argument_list|(
name|input
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|toUpperHex
argument_list|(
operator|*
operator|++
name|input
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|toUpperHex
argument_list|(
operator|*
operator|++
name|input
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|action
operator|==
name|DecodeCharacter
condition|)
block|{
comment|// case 4: we need to decode
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|decoded
expr_stmt|;
name|input
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|// must be case 3: we need to encode
name|ensureDetached
argument_list|(
name|result
argument_list|,
name|output
argument_list|,
name|begin
argument_list|,
name|input
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|encodeNibble
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|output
condition|)
block|{
name|int
name|len
init|=
name|output
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|result
operator|.
name|truncate
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
name|len
operator|-
name|origSize
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
template|template
parameter_list|<
name|size_t
name|N
parameter_list|>
DECL|variable|uchar
specifier|static
name|void
name|maskTable
argument_list|(
name|uchar
argument_list|(
operator|&
name|table
argument_list|)
index|[
name|N
index|]
argument_list|,
specifier|const
name|uchar
argument_list|(
operator|&
name|mask
argument_list|)
index|[
name|N
index|]
argument_list|)
argument_list|{     for
operator|(
name|size_t
name|i
operator|=
literal|0
expr|;
name|i
operator|<
name|N
expr|;
operator|++
name|i
operator|)
name|table
index|[
name|i
index|]
operator|&=
name|mask
index|[
name|i
index|]
argument_list|; }
comment|/*!     \internal      Recodes the string from \a begin to \a end. If any transformations are     done, append them to \a appendTo and return the number of characters added.     If no transformations were required, return 0.      The \a encoding option modifies the default behaviour:     \list     \li QUrl::EncodeDelimiters: if set, delimiters will be left untransformed (note: not encoded!);                                 if unset, delimiters will be decoded     \li QUrl::DecodeReserved: if set, reserved characters will be decoded;                               if unset, reserved characters will be encoded     \li QUrl::EncodeSpaces: if set, spaces will be encoded to "%20"; if unset, they will be " "     \li QUrl::EncodeUnicode: if set, characters above U+0080 will be encoded to their UTF-8                              percent-encoded form; if unset, they will be decoded to UTF-16     \endlist      Other flags are ignored (including QUrl::EncodeReserved).      The \a tableModifications argument can be used to supply extra     modifications to the tables, to be applied after the flags above are     handled. It consists of a sequence of 16-bit values, where the low 8 bits     indicate the character in question and the high 8 bits are either \c     EncodeCharacter, \c LeaveCharacter or \c DecodeCharacter.  */
name|Q_AUTOTEST_EXPORT
name|int
DECL|function|qt_urlRecode
name|qt_urlRecode
argument_list|(
name|QString
operator|&
name|appendTo
argument_list|,
specifier|const
name|QChar
operator|*
name|begin
argument_list|,
specifier|const
name|QChar
operator|*
name|end
argument_list|,
name|QUrl
operator|::
name|ComponentFormattingOptions
name|encoding
argument_list|,
specifier|const
name|ushort
operator|*
name|tableModifications
argument_list|)
argument_list|{
name|uchar
name|actionTable
index|[
sizeof|sizeof
name|defaultActionTable
index|]
argument_list|;     if
operator|(
operator|!
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeDelimiters
operator|)
operator|&&
name|encoding
operator|&
name|QUrl
operator|::
name|DecodeReserved
operator|)
block|{
comment|// reset the table
name|memset
argument_list|(
name|actionTable
argument_list|,
name|DecodeCharacter
argument_list|,
sizeof|sizeof
name|actionTable
argument_list|)
block|;
if|if
condition|(
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeSpaces
condition|)
name|actionTable
index|[
literal|0
index|]
operator|=
name|EncodeCharacter
expr_stmt|;
comment|// these are always encoded
name|actionTable
index|[
literal|'%'
operator|-
literal|' '
index|]
operator|=
name|EncodeCharacter
argument_list|;
name|actionTable
index|[
literal|0x7F
operator|-
literal|' '
index|]
operator|=
name|EncodeCharacter
argument_list|;     }
decl|else
argument_list|{
name|memcpy
argument_list|(
name|actionTable
argument_list|,
name|defaultActionTable
argument_list|,
sizeof|sizeof
name|actionTable
argument_list|)
argument_list|;         if
operator|(
operator|!
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeDelimiters
operator|)
operator|)
name|maskTable
argument_list|(
name|actionTable
argument_list|,
name|delimsMask
argument_list|)
argument_list|;         if
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|DecodeReserved
operator|)
name|maskTable
argument_list|(
name|actionTable
argument_list|,
name|reservedMask
argument_list|)
argument_list|;         if
operator|(
operator|!
operator|(
name|encoding
operator|&
name|QUrl
operator|::
name|EncodeSpaces
operator|)
operator|)
name|actionTable
index|[
literal|0
index|]
operator|=
name|DecodeCharacter
argument_list|;
comment|// decode
argument_list|}
decl|if
argument_list|(
name|tableModifications
argument_list|)
argument_list|{         for
operator|(
specifier|const
name|ushort
operator|*
name|p
operator|=
name|tableModifications
expr|;
operator|*
name|p
expr|;
operator|++
name|p
operator|)
name|actionTable
index|[
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
operator|-
literal|' '
index|]
operator|=
operator|*
name|p
operator|>>
literal|8
argument_list|;     }
decl|return
name|recode
argument_list|(
name|appendTo
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|begin
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|end
argument_list|)
argument_list|,
name|encoding
argument_list|,
name|actionTable
argument_list|,
literal|false
argument_list|)
decl_stmt|;
end_decl_stmt
unit|}  QT_END_NAMESPACE
end_unit
