begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qfileinfo.h"
end_include
begin_include
include|#
directive|include
file|"qglobal.h"
end_include
begin_include
include|#
directive|include
file|"qdir.h"
end_include
begin_include
include|#
directive|include
file|"qfileinfo_p.h"
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|getFileName
name|QString
name|QFileInfoPrivate
operator|::
name|getFileName
parameter_list|(
name|QAbstractFileEngine
operator|::
name|FileName
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|cache_enabled
operator|&&
operator|!
name|fileNames
index|[
operator|(
name|int
operator|)
name|name
index|]
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|fileNames
index|[
operator|(
name|int
operator|)
name|name
index|]
return|;
name|QString
name|ret
decl_stmt|;
if|if
condition|(
name|fileEngine
operator|==
literal|0
condition|)
block|{
comment|// local file; use the QFileSystemEngine directly
switch|switch
condition|(
name|name
condition|)
block|{
case|case
name|QAbstractFileEngine
operator|::
name|CanonicalName
case|:
case|case
name|QAbstractFileEngine
operator|::
name|CanonicalPathName
case|:
block|{
name|QFileSystemEntry
name|entry
init|=
name|QFileSystemEngine
operator|::
name|canonicalName
argument_list|(
name|fileEntry
argument_list|,
name|metaData
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache_enabled
condition|)
block|{
comment|// be smart and store both
name|fileNames
index|[
name|QAbstractFileEngine
operator|::
name|CanonicalName
index|]
operator|=
name|entry
operator|.
name|filePath
argument_list|()
expr_stmt|;
name|fileNames
index|[
name|QAbstractFileEngine
operator|::
name|CanonicalPathName
index|]
operator|=
name|entry
operator|.
name|path
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|QAbstractFileEngine
operator|::
name|CanonicalName
condition|)
name|ret
operator|=
name|entry
operator|.
name|filePath
argument_list|()
expr_stmt|;
else|else
name|ret
operator|=
name|entry
operator|.
name|path
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|QAbstractFileEngine
operator|::
name|LinkName
case|:
name|ret
operator|=
name|QFileSystemEngine
operator|::
name|getLinkTarget
argument_list|(
name|fileEntry
argument_list|,
name|metaData
argument_list|)
operator|.
name|filePath
argument_list|()
expr_stmt|;
break|break;
case|case
name|QAbstractFileEngine
operator|::
name|BundleName
case|:
name|ret
operator|=
name|QFileSystemEngine
operator|::
name|bundleName
argument_list|(
name|fileEntry
argument_list|)
expr_stmt|;
break|break;
case|case
name|QAbstractFileEngine
operator|::
name|AbsoluteName
case|:
case|case
name|QAbstractFileEngine
operator|::
name|AbsolutePathName
case|:
block|{
name|QFileSystemEntry
name|entry
init|=
name|QFileSystemEngine
operator|::
name|absoluteName
argument_list|(
name|fileEntry
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache_enabled
condition|)
block|{
comment|// be smart and store both
name|fileNames
index|[
name|QAbstractFileEngine
operator|::
name|AbsoluteName
index|]
operator|=
name|entry
operator|.
name|filePath
argument_list|()
expr_stmt|;
name|fileNames
index|[
name|QAbstractFileEngine
operator|::
name|AbsolutePathName
index|]
operator|=
name|entry
operator|.
name|path
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|QAbstractFileEngine
operator|::
name|AbsoluteName
condition|)
name|ret
operator|=
name|entry
operator|.
name|filePath
argument_list|()
expr_stmt|;
else|else
name|ret
operator|=
name|entry
operator|.
name|path
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
else|else
block|{
name|ret
operator|=
name|fileEngine
operator|->
name|fileName
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|.
name|isNull
argument_list|()
condition|)
name|ret
operator|=
name|QLatin1String
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache_enabled
condition|)
name|fileNames
index|[
operator|(
name|int
operator|)
name|name
index|]
operator|=
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|getFileOwner
name|QString
name|QFileInfoPrivate
operator|::
name|getFileOwner
parameter_list|(
name|QAbstractFileEngine
operator|::
name|FileOwner
name|own
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|cache_enabled
operator|&&
operator|!
name|fileOwners
index|[
operator|(
name|int
operator|)
name|own
index|]
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|fileOwners
index|[
operator|(
name|int
operator|)
name|own
index|]
return|;
name|QString
name|ret
decl_stmt|;
if|if
condition|(
name|fileEngine
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|own
condition|)
block|{
case|case
name|QAbstractFileEngine
operator|::
name|OwnerUser
case|:
name|ret
operator|=
name|QFileSystemEngine
operator|::
name|resolveUserName
argument_list|(
name|fileEntry
argument_list|,
name|metaData
argument_list|)
expr_stmt|;
break|break;
case|case
name|QAbstractFileEngine
operator|::
name|OwnerGroup
case|:
name|ret
operator|=
name|QFileSystemEngine
operator|::
name|resolveGroupName
argument_list|(
name|fileEntry
argument_list|,
name|metaData
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|ret
operator|=
name|fileEngine
operator|->
name|owner
argument_list|(
name|own
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|.
name|isNull
argument_list|()
condition|)
name|ret
operator|=
name|QLatin1String
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache_enabled
condition|)
name|fileOwners
index|[
operator|(
name|int
operator|)
name|own
index|]
operator|=
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|getFileFlags
name|uint
name|QFileInfoPrivate
operator|::
name|getFileFlags
parameter_list|(
name|QAbstractFileEngine
operator|::
name|FileFlags
name|request
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|fileEngine
argument_list|)
expr_stmt|;
comment|// should never be called when using the native FS
comment|// We split the testing into tests for for LinkType, BundleType, PermsMask
comment|// and the rest.
comment|// Tests for file permissions on Windows can be slow, expecially on network
comment|// paths and NTFS drives.
comment|// In order to determine if a file is a symlink or not, we have to lstat().
comment|// If we're not interested in that information, we might as well avoid one
comment|// extra syscall. Bundle detecton on Mac can be slow, expecially on network
comment|// paths, so we separate out that as well.
name|QAbstractFileEngine
operator|::
name|FileFlags
name|req
init|=
literal|0
decl_stmt|;
name|uint
name|cachedFlags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|request
operator|&
operator|(
name|QAbstractFileEngine
operator|::
name|FlagsMask
operator||
name|QAbstractFileEngine
operator|::
name|TypesMask
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|getCachedFlag
argument_list|(
name|CachedFileFlags
argument_list|)
condition|)
block|{
name|req
operator||=
name|QAbstractFileEngine
operator|::
name|FlagsMask
expr_stmt|;
name|req
operator||=
name|QAbstractFileEngine
operator|::
name|TypesMask
expr_stmt|;
name|req
operator|&=
operator|(
operator|~
name|QAbstractFileEngine
operator|::
name|LinkType
operator|)
expr_stmt|;
name|req
operator|&=
operator|(
operator|~
name|QAbstractFileEngine
operator|::
name|BundleType
operator|)
expr_stmt|;
name|cachedFlags
operator||=
name|CachedFileFlags
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|&
name|QAbstractFileEngine
operator|::
name|LinkType
condition|)
block|{
if|if
condition|(
operator|!
name|getCachedFlag
argument_list|(
name|CachedLinkTypeFlag
argument_list|)
condition|)
block|{
name|req
operator||=
name|QAbstractFileEngine
operator|::
name|LinkType
expr_stmt|;
name|cachedFlags
operator||=
name|CachedLinkTypeFlag
expr_stmt|;
block|}
block|}
if|if
condition|(
name|request
operator|&
name|QAbstractFileEngine
operator|::
name|BundleType
condition|)
block|{
if|if
condition|(
operator|!
name|getCachedFlag
argument_list|(
name|CachedBundleTypeFlag
argument_list|)
condition|)
block|{
name|req
operator||=
name|QAbstractFileEngine
operator|::
name|BundleType
expr_stmt|;
name|cachedFlags
operator||=
name|CachedBundleTypeFlag
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|request
operator|&
name|QAbstractFileEngine
operator|::
name|PermsMask
condition|)
block|{
if|if
condition|(
operator|!
name|getCachedFlag
argument_list|(
name|CachedPerms
argument_list|)
condition|)
block|{
name|req
operator||=
name|QAbstractFileEngine
operator|::
name|PermsMask
expr_stmt|;
name|cachedFlags
operator||=
name|CachedPerms
expr_stmt|;
block|}
block|}
if|if
condition|(
name|req
condition|)
block|{
if|if
condition|(
name|cache_enabled
condition|)
name|req
operator|&=
operator|(
operator|~
name|QAbstractFileEngine
operator|::
name|Refresh
operator|)
expr_stmt|;
else|else
name|req
operator||=
name|QAbstractFileEngine
operator|::
name|Refresh
expr_stmt|;
name|QAbstractFileEngine
operator|::
name|FileFlags
name|flags
init|=
name|fileEngine
operator|->
name|fileFlags
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|fileFlags
operator||=
name|uint
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|setCachedFlag
argument_list|(
name|cachedFlags
argument_list|)
expr_stmt|;
block|}
return|return
name|fileFlags
operator|&
name|request
return|;
block|}
end_function
begin_function
DECL|function|getFileTime
name|QDateTime
modifier|&
name|QFileInfoPrivate
operator|::
name|getFileTime
parameter_list|(
name|QAbstractFileEngine
operator|::
name|FileTime
name|request
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|fileEngine
argument_list|)
expr_stmt|;
comment|// should never be called when using the native FS
if|if
condition|(
name|fileTimes
operator|.
name|size
argument_list|()
operator|!=
literal|3
condition|)
name|fileTimes
operator|.
name|resize
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cache_enabled
condition|)
name|clearFlags
argument_list|()
expr_stmt|;
name|uint
name|cf
decl_stmt|;
if|if
condition|(
name|request
operator|==
name|QAbstractFileEngine
operator|::
name|CreationTime
condition|)
name|cf
operator|=
name|CachedCTime
expr_stmt|;
elseif|else
if|if
condition|(
name|request
operator|==
name|QAbstractFileEngine
operator|::
name|ModificationTime
condition|)
name|cf
operator|=
name|CachedMTime
expr_stmt|;
else|else
name|cf
operator|=
name|CachedATime
expr_stmt|;
if|if
condition|(
operator|!
name|getCachedFlag
argument_list|(
name|cf
argument_list|)
condition|)
block|{
name|fileTimes
index|[
name|request
index|]
operator|=
name|fileEngine
operator|->
name|fileTime
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|setCachedFlag
argument_list|(
name|cf
argument_list|)
expr_stmt|;
block|}
return|return
name|fileTimes
index|[
name|request
index|]
return|;
block|}
end_function
begin_comment
comment|//************* QFileInfo
end_comment
begin_comment
comment|/*!     \class QFileInfo     \inmodule QtCore     \reentrant     \brief The QFileInfo class provides system-independent file information.      \ingroup io     \ingroup shared      QFileInfo provides information about a file's name and position     (path) in the file system, its access rights and whether it is a     directory or symbolic link, etc. The file's size and last     modified/read times are also available. QFileInfo can also be     used to obtain information about a Qt \l{resource     system}{resource}.      A QFileInfo can point to a file with either a relative or an     absolute file path. Absolute file paths begin with the directory     separator "/" (or with a drive specification on Windows). Relative     file names begin with a directory name or a file name and specify     a path relative to the current working directory. An example of an     absolute path is the string "/tmp/quartz". A relative path might     look like "src/fatlib". You can use the function isRelative() to     check whether a QFileInfo is using a relative or an absolute file     path. You can call the function makeAbsolute() to convert a     relative QFileInfo's path to an absolute path.      The file that the QFileInfo works on is set in the constructor or     later with setFile(). Use exists() to see if the file exists and     size() to get its size.      The file's type is obtained with isFile(), isDir() and     isSymLink(). The symLinkTarget() function provides the name of the file     the symlink points to.      On Unix (including Mac OS X), the symlink has the same size() has     the file it points to, because Unix handles symlinks     transparently; similarly, opening a symlink using QFile     effectively opens the link's target. For example:      \snippet code/src_corelib_io_qfileinfo.cpp 0      On Windows, symlinks (shortcuts) are \c .lnk files. The reported     size() is that of the symlink (not the link's target), and     opening a symlink using QFile opens the \c .lnk file. For     example:      \snippet code/src_corelib_io_qfileinfo.cpp 1      Elements of the file's name can be extracted with path() and     fileName(). The fileName()'s parts can be extracted with     baseName(), suffix() or completeSuffix(). QFileInfo objects to     directories created by Qt classes will not have a trailing file     separator. If you wish to use trailing separators in your own file     info objects, just append one to the file name given to the constructors     or setFile().      The file's dates are returned by created(), lastModified() and     lastRead(). Information about the file's access permissions is     obtained with isReadable(), isWritable() and isExecutable(). The     file's ownership is available from owner(), ownerId(), group() and     groupId(). You can examine a file's permissions and ownership in a     single statement using the permission() function.      \section1 Performance Issues      Some of QFileInfo's functions query the file system, but for     performance reasons, some functions only operate on the     file name itself. For example: To return the absolute path of     a relative file name, absolutePath() has to query the file system.     The path() function, however, can work on the file name directly,     and so it is faster.      \note To speed up performance, QFileInfo caches information about     the file.      To speed up performance, QFileInfo caches information about the     file. Because files can be changed by other users or programs, or     even by other parts of the same program, there is a function that     refreshes the file information: refresh(). If you want to switch     off a QFileInfo's caching and force it to access the file system     every time you request information from it call setCaching(false).      \sa QDir, QFile */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QFileInfo
name|QFileInfo
operator|::
name|QFileInfo
parameter_list|(
name|QFileInfoPrivate
modifier|*
name|p
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
name|p
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs an empty QFileInfo object.      Note that an empty QFileInfo object contain no file reference.      \sa setFile() */
end_comment
begin_constructor
DECL|function|QFileInfo
name|QFileInfo
operator|::
name|QFileInfo
parameter_list|()
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QFileInfoPrivate
argument_list|()
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a new QFileInfo that gives information about the given     file. The \a file can also include an absolute or relative path.      \sa setFile(), isRelative(), QDir::setCurrent(), QDir::isRelativePath() */
end_comment
begin_constructor
DECL|function|QFileInfo
name|QFileInfo
operator|::
name|QFileInfo
parameter_list|(
specifier|const
name|QString
modifier|&
name|file
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QFileInfoPrivate
argument_list|(
name|file
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a new QFileInfo that gives information about file \a     file.      If the \a file has a relative path, the QFileInfo will also have a     relative path.      \sa isRelative() */
end_comment
begin_constructor
DECL|function|QFileInfo
name|QFileInfo
operator|::
name|QFileInfo
parameter_list|(
specifier|const
name|QFile
modifier|&
name|file
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QFileInfoPrivate
argument_list|(
name|file
operator|.
name|fileName
argument_list|()
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a new QFileInfo that gives information about the given     \a file in the directory \a dir.      If \a dir has a relative path, the QFileInfo will also have a     relative path.      If \a file is an absolute path, then the directory specified     by \a dir will be disregarded.      \sa isRelative() */
end_comment
begin_constructor
DECL|function|QFileInfo
name|QFileInfo
operator|::
name|QFileInfo
parameter_list|(
specifier|const
name|QDir
modifier|&
name|dir
parameter_list|,
specifier|const
name|QString
modifier|&
name|file
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QFileInfoPrivate
argument_list|(
name|dir
operator|.
name|filePath
argument_list|(
name|file
argument_list|)
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a new QFileInfo that is a copy of the given \a fileinfo. */
end_comment
begin_constructor
DECL|function|QFileInfo
name|QFileInfo
operator|::
name|QFileInfo
parameter_list|(
specifier|const
name|QFileInfo
modifier|&
name|fileinfo
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
name|fileinfo
operator|.
name|d_ptr
argument_list|)
block|{  }
end_constructor
begin_comment
comment|/*!     Destroys the QFileInfo and frees its resources. */
end_comment
begin_destructor
DECL|function|~QFileInfo
name|QFileInfo
operator|::
name|~
name|QFileInfo
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \fn bool QFileInfo::operator!=(const QFileInfo&fileinfo) const      Returns true if this QFileInfo object refers to a different file     than the one specified by \a fileinfo; otherwise returns false.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns true if this QFileInfo object refers to a file in the same     location as \a fileinfo; otherwise returns false.      Note that the result of comparing two empty QFileInfo objects,     containing no file references (file paths that do not exist or     are empty), is undefined.      \warning This will not compare two different symbolic links     pointing to the same file.      \warning Long and short file names that refer to the same file on Windows     are treated as if they referred to different files.      \sa operator!=() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QFileInfo
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QFileInfo
modifier|&
name|fileinfo
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
comment|// ### Qt 5: understand long and short file names on Windows
comment|// ### (GetFullPathName()).
if|if
condition|(
name|fileinfo
operator|.
name|d_ptr
operator|==
name|d_ptr
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
operator|||
name|fileinfo
operator|.
name|d_ptr
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|false
return|;
comment|// Assume files are the same if path is the same
if|if
condition|(
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
operator|==
name|fileinfo
operator|.
name|d_ptr
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
condition|)
return|return
literal|true
return|;
name|Qt
operator|::
name|CaseSensitivity
name|sensitive
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
operator|||
name|fileinfo
operator|.
name|d_ptr
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|!=
name|fileinfo
operator|.
name|d_ptr
operator|->
name|fileEngine
condition|)
comment|// one is native, the other is a custom file-engine
return|return
literal|false
return|;
name|sensitive
operator|=
name|QFileSystemEngine
operator|::
name|isCaseSensitive
argument_list|()
condition|?
name|Qt
operator|::
name|CaseSensitive
else|:
name|Qt
operator|::
name|CaseInsensitive
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|->
name|caseSensitive
argument_list|()
operator|!=
name|fileinfo
operator|.
name|d_ptr
operator|->
name|fileEngine
operator|->
name|caseSensitive
argument_list|()
condition|)
return|return
literal|false
return|;
name|sensitive
operator|=
name|d
operator|->
name|fileEngine
operator|->
name|caseSensitive
argument_list|()
condition|?
name|Qt
operator|::
name|CaseSensitive
else|:
name|Qt
operator|::
name|CaseInsensitive
expr_stmt|;
block|}
comment|// Fallback to expensive canonical path computation
return|return
name|canonicalFilePath
argument_list|()
operator|.
name|compare
argument_list|(
name|fileinfo
operator|.
name|canonicalFilePath
argument_list|()
argument_list|,
name|sensitive
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Makes a copy of the given \a fileinfo and assigns it to this QFileInfo. */
end_comment
begin_function
DECL|function|operator =
name|QFileInfo
modifier|&
name|QFileInfo
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QFileInfo
modifier|&
name|fileinfo
parameter_list|)
block|{
name|d_ptr
operator|=
name|fileinfo
operator|.
name|d_ptr
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QFileInfo::swap(QFileInfo&other)     \since 5.0      Swaps this file info with \a other. This function is very fast and     never fails. */
end_comment
begin_comment
comment|/*!     Sets the file that the QFileInfo provides information about to \a     file.      The \a file can also include an absolute or relative file path.     Absolute paths begin with the directory separator (e.g. "/" under     Unix) or a drive specification (under Windows). Relative file     names begin with a directory name or a file name and specify a     path relative to the current directory.      Example:     \snippet code/src_corelib_io_qfileinfo.cpp 2      \sa isRelative(), QDir::setCurrent(), QDir::isRelativePath() */
end_comment
begin_function
DECL|function|setFile
name|void
name|QFileInfo
operator|::
name|setFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|file
parameter_list|)
block|{
name|bool
name|caching
init|=
name|d_ptr
operator|.
name|constData
argument_list|()
operator|->
name|cache_enabled
decl_stmt|;
operator|*
name|this
operator|=
name|QFileInfo
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|cache_enabled
operator|=
name|caching
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the file that the QFileInfo provides information about to \a     file.      If \a file includes a relative path, the QFileInfo will also have     a relative path.      \sa isRelative() */
end_comment
begin_function
DECL|function|setFile
name|void
name|QFileInfo
operator|::
name|setFile
parameter_list|(
specifier|const
name|QFile
modifier|&
name|file
parameter_list|)
block|{
name|setFile
argument_list|(
name|file
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the file that the QFileInfo provides information about to \a     file in directory \a dir.      If \a file includes a relative path, the QFileInfo will also     have a relative path.      \sa isRelative() */
end_comment
begin_function
DECL|function|setFile
name|void
name|QFileInfo
operator|::
name|setFile
parameter_list|(
specifier|const
name|QDir
modifier|&
name|dir
parameter_list|,
specifier|const
name|QString
modifier|&
name|file
parameter_list|)
block|{
name|setFile
argument_list|(
name|dir
operator|.
name|filePath
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns an absolute path including the file name.      The absolute path name consists of the full path and the file     name. On Unix this will always begin with the root, '/',     directory. On Windows this will always begin 'D:/' where D is a     drive letter, except for network shares that are not mapped to a     drive letter, in which case the path will begin '//sharename/'.     QFileInfo will uppercase drive letters. Note that QDir does not do     this. The code snippet below shows this.      \snippet code/src_corelib_io_qfileinfo.cpp newstuff      This function returns the same as filePath(), unless isRelative()     is true. In contrast to canonicalFilePath(), symbolic links or     redundant "." or ".." elements are not necessarily removed.      If the QFileInfo is empty it returns QDir::currentPath().      \sa filePath(), canonicalFilePath(), isRelative() */
end_comment
begin_function
DECL|function|absoluteFilePath
name|QString
name|QFileInfo
operator|::
name|absoluteFilePath
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|d
operator|->
name|getFileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|AbsoluteName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the canonical path including the file name, i.e. an absolute     path without symbolic links or redundant "." or ".." elements.      If the file does not exist, canonicalFilePath() returns an empty     string.      \sa filePath(), absoluteFilePath(), dir() */
end_comment
begin_function
DECL|function|canonicalFilePath
name|QString
name|QFileInfo
operator|::
name|canonicalFilePath
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|d
operator|->
name|getFileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|CanonicalName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a file's path absolute path. This doesn't include the     file name.      On Unix the absolute path will always begin with the root, '/',     directory. On Windows this will always begin 'D:/' where D is a     drive letter, except for network shares that are not mapped to a     drive letter, in which case the path will begin '//sharename/'.      In contrast to canonicalPath() symbolic links or redundant "." or     ".." elements are not necessarily removed.      \warning If the QFileInfo object was created with an empty QString,               the behavior of this function is undefined.      \sa absoluteFilePath(), path(), canonicalPath(), fileName(), isRelative() */
end_comment
begin_function
DECL|function|absolutePath
name|QString
name|QFileInfo
operator|::
name|absolutePath
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
block|{
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|fileEntry
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFileInfo::absolutePath: Constructed with empty filename"
argument_list|)
expr_stmt|;
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
block|}
return|return
name|d
operator|->
name|getFileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|AbsolutePathName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the file's path canonical path (excluding the file name),     i.e. an absolute path without symbolic links or redundant "." or ".." elements.      If the file does not exist, canonicalPath() returns an empty string.      \sa path(), absolutePath() */
end_comment
begin_function
DECL|function|canonicalPath
name|QString
name|QFileInfo
operator|::
name|canonicalPath
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|d
operator|->
name|getFileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|CanonicalPathName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the file's path. This doesn't include the file name.      Note that, if this QFileInfo object is given a path ending in a     slash, the name of the file is considered empty and this function     will return the entire path.      \sa filePath(), absolutePath(), canonicalPath(), dir(), fileName(), isRelative() */
end_comment
begin_function
DECL|function|path
name|QString
name|QFileInfo
operator|::
name|path
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|d
operator|->
name|fileEntry
operator|.
name|path
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QFileInfo::isAbsolute() const      Returns true if the file path name is absolute, otherwise returns     false if the path is relative.      \sa isRelative() */
end_comment
begin_comment
comment|/*!     Returns true if the file path name is relative, otherwise returns     false if the path is absolute (e.g. under Unix a path is absolute     if it begins with a "/").      \sa isAbsolute() */
end_comment
begin_function
DECL|function|isRelative
name|bool
name|QFileInfo
operator|::
name|isRelative
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
return|return
name|d
operator|->
name|fileEntry
operator|.
name|isRelative
argument_list|()
return|;
return|return
name|d
operator|->
name|fileEngine
operator|->
name|isRelativePath
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Converts the file's path to an absolute path if it is not already in that form.     Returns true to indicate that the path was converted; otherwise returns false     to indicate that the path was already absolute.      \sa filePath(), isRelative() */
end_comment
begin_function
DECL|function|makeAbsolute
name|bool
name|QFileInfo
operator|::
name|makeAbsolute
parameter_list|()
block|{
if|if
condition|(
name|d_ptr
operator|.
name|constData
argument_list|()
operator|->
name|isDefaultConstructed
operator|||
operator|!
name|d_ptr
operator|.
name|constData
argument_list|()
operator|->
name|fileEntry
operator|.
name|isRelative
argument_list|()
condition|)
return|return
literal|false
return|;
name|setFile
argument_list|(
name|absoluteFilePath
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the file exists; otherwise returns false.      \note If the file is a symlink that points to a non existing      file, false is returned. */
end_comment
begin_function
DECL|function|exists
name|bool
name|QFileInfo
operator|::
name|exists
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|ExistsAttribute
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|ExistsAttribute
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|metaData
operator|.
name|exists
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|getFileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|ExistsFlag
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Refreshes the information about the file, i.e. reads in information     from the file system the next time a cached property is fetched.     \note On Windows CE, there might be a delay for the file system driver     to detect changes on the file. */
end_comment
begin_function
DECL|function|refresh
name|void
name|QFileInfo
operator|::
name|refresh
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFileInfo
argument_list|)
expr_stmt|;
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the file name, including the path (which may be absolute     or relative).      \sa absoluteFilePath(), canonicalFilePath(), isRelative() */
end_comment
begin_function
DECL|function|filePath
name|QString
name|QFileInfo
operator|::
name|filePath
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|d
operator|->
name|fileEntry
operator|.
name|filePath
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the file, excluding the path.      Example:     \snippet code/src_corelib_io_qfileinfo.cpp 3      Note that, if this QFileInfo object is given a path ending in a     slash, the name of the file is considered empty.      \sa isRelative(), filePath(), baseName(), suffix() */
end_comment
begin_function
DECL|function|fileName
name|QString
name|QFileInfo
operator|::
name|fileName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|d
operator|->
name|fileEntry
operator|.
name|fileName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3     Returns the name of the bundle.      On Mac OS X this returns the proper localized name for a bundle if the     path isBundle(). On all other platforms an empty QString is returned.      Example:     \snippet code/src_corelib_io_qfileinfo.cpp 4      \sa isBundle(), filePath(), baseName(), suffix() */
end_comment
begin_function
DECL|function|bundleName
name|QString
name|QFileInfo
operator|::
name|bundleName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|d
operator|->
name|getFileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|BundleName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the base name of the file without the path.      The base name consists of all characters in the file up to (but     not including) the \e first '.' character.      Example:     \snippet code/src_corelib_io_qfileinfo.cpp 5       The base name of a file is computed equally on all platforms, independent     of file naming conventions (e.g., ".bashrc" on Unix has an empty base     name, and the suffix is "bashrc").      \sa fileName(), suffix(), completeSuffix(), completeBaseName() */
end_comment
begin_function
DECL|function|baseName
name|QString
name|QFileInfo
operator|::
name|baseName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|d
operator|->
name|fileEntry
operator|.
name|baseName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the complete base name of the file without the path.      The complete base name consists of all characters in the file up     to (but not including) the \e last '.' character.      Example:     \snippet code/src_corelib_io_qfileinfo.cpp 6      \sa fileName(), suffix(), completeSuffix(), baseName() */
end_comment
begin_function
DECL|function|completeBaseName
name|QString
name|QFileInfo
operator|::
name|completeBaseName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|d
operator|->
name|fileEntry
operator|.
name|completeBaseName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the complete suffix of the file.      The complete suffix consists of all characters in the file after     (but not including) the first '.'.      Example:     \snippet code/src_corelib_io_qfileinfo.cpp 7      \sa fileName(), suffix(), baseName(), completeBaseName() */
end_comment
begin_function
DECL|function|completeSuffix
name|QString
name|QFileInfo
operator|::
name|completeSuffix
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|d
operator|->
name|fileEntry
operator|.
name|completeSuffix
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the suffix of the file.      The suffix consists of all characters in the file after (but not     including) the last '.'.      Example:     \snippet code/src_corelib_io_qfileinfo.cpp 8      The suffix of a file is computed equally on all platforms, independent of     file naming conventions (e.g., ".bashrc" on Unix has an empty base name,     and the suffix is "bashrc").      \sa fileName(), completeSuffix(), baseName(), completeBaseName() */
end_comment
begin_function
DECL|function|suffix
name|QString
name|QFileInfo
operator|::
name|suffix
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|d
operator|->
name|fileEntry
operator|.
name|suffix
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the path of the object's parent directory as a QDir object.      \b{Note:} The QDir returned always corresponds to the object's     parent directory, even if the QFileInfo represents a directory.      For each of the following, dir() returns a QDir for     \c{"~/examples/191697"}.      \snippet fileinfo/main.cpp 0      For each of the following, dir() returns a QDir for     \c{"."}.      \snippet fileinfo/main.cpp 1      \sa absolutePath(), filePath(), fileName(), isRelative(), absoluteDir() */
end_comment
begin_function
DECL|function|dir
name|QDir
name|QFileInfo
operator|::
name|dir
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
comment|// ### Qt 6: Maybe rename this to parentDirectory(), considering what it actually does?
return|return
name|QDir
argument_list|(
name|d
operator|->
name|fileEntry
operator|.
name|path
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the file's absolute path as a QDir object.      \sa dir(), filePath(), fileName(), isRelative() */
end_comment
begin_function
DECL|function|absoluteDir
name|QDir
name|QFileInfo
operator|::
name|absoluteDir
parameter_list|()
specifier|const
block|{
return|return
name|QDir
argument_list|(
name|absolutePath
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the user can read the file; otherwise returns false.      \sa isWritable(), isExecutable(), permission() */
end_comment
begin_function
DECL|function|isReadable
name|bool
name|QFileInfo
operator|::
name|isReadable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|UserReadPermission
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|UserReadPermission
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|metaData
operator|.
name|permissions
argument_list|()
operator|&
name|QFile
operator|::
name|ReadUser
operator|)
operator|!=
literal|0
return|;
block|}
return|return
name|d
operator|->
name|getFileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|ReadUserPerm
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the user can write to the file; otherwise returns false.      \sa isReadable(), isExecutable(), permission() */
end_comment
begin_function
DECL|function|isWritable
name|bool
name|QFileInfo
operator|::
name|isWritable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|UserWritePermission
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|UserWritePermission
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|metaData
operator|.
name|permissions
argument_list|()
operator|&
name|QFile
operator|::
name|WriteUser
operator|)
operator|!=
literal|0
return|;
block|}
return|return
name|d
operator|->
name|getFileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|WriteUserPerm
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the file is executable; otherwise returns false.      \sa isReadable(), isWritable(), permission() */
end_comment
begin_function
DECL|function|isExecutable
name|bool
name|QFileInfo
operator|::
name|isExecutable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|UserExecutePermission
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|UserExecutePermission
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|metaData
operator|.
name|permissions
argument_list|()
operator|&
name|QFile
operator|::
name|ExeUser
operator|)
operator|!=
literal|0
return|;
block|}
return|return
name|d
operator|->
name|getFileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|ExeUserPerm
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this is a `hidden' file; otherwise returns false.      \b{Note:} This function returns true for the special entries     "." and ".." on Unix, even though QDir::entryList threats them as shown. */
end_comment
begin_function
DECL|function|isHidden
name|bool
name|QFileInfo
operator|::
name|isHidden
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|HiddenAttribute
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|HiddenAttribute
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|metaData
operator|.
name|isHidden
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|getFileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|HiddenFlag
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     Returns true if the file path can be used directly with native APIs.     Returns false if the file is otherwise supported by a virtual file system     inside Qt, such as \l{the Qt Resource System}.      \b{Note:} Native paths may still require conversion of path separators     and character encoding, depending on platform and input requirements of the     native API.      \sa QDir::toNativeSeparators(), QFile::encodeName(), filePath(),     absoluteFilePath(), canonicalFilePath() */
end_comment
begin_function
DECL|function|isNativePath
name|bool
name|QFileInfo
operator|::
name|isNativePath
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
return|return
literal|true
return|;
return|return
name|d
operator|->
name|getFileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|LocalDiskFlag
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this object points to a file or to a symbolic     link to a file. Returns false if the     object points to something which isn't a file, such as a directory.      \sa isDir(), isSymLink(), isBundle() */
end_comment
begin_function
DECL|function|isFile
name|bool
name|QFileInfo
operator|::
name|isFile
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|FileType
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|FileType
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|metaData
operator|.
name|isFile
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|getFileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|FileType
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this object points to a directory or to a symbolic     link to a directory; otherwise returns false.      \sa isFile(), isSymLink(), isBundle() */
end_comment
begin_function
DECL|function|isDir
name|bool
name|QFileInfo
operator|::
name|isDir
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|DirectoryType
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|DirectoryType
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|metaData
operator|.
name|isDirectory
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|getFileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|DirectoryType
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3     Returns true if this object points to a bundle or to a symbolic     link to a bundle on Mac OS X; otherwise returns false.      \sa isDir(), isSymLink(), isFile() */
end_comment
begin_function
DECL|function|isBundle
name|bool
name|QFileInfo
operator|::
name|isBundle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|BundleType
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|BundleType
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|metaData
operator|.
name|isBundle
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|getFileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|BundleType
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this object points to a symbolic link (or to a     shortcut on Windows); otherwise returns false.      On Unix (including Mac OS X), opening a symlink effectively opens     the \l{symLinkTarget()}{link's target}. On Windows, it opens the \c     .lnk file itself.      Example:      \snippet code/src_corelib_io_qfileinfo.cpp 9      \note If the symlink points to a non existing file, exists() returns      false.      \sa isFile(), isDir(), symLinkTarget() */
end_comment
begin_function
DECL|function|isSymLink
name|bool
name|QFileInfo
operator|::
name|isSymLink
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|LegacyLinkType
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|LegacyLinkType
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|metaData
operator|.
name|isLegacyLink
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|getFileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|LinkType
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the object points to a directory or to a symbolic     link to a directory, and that directory is the root directory; otherwise     returns false. */
end_comment
begin_function
DECL|function|isRoot
name|bool
name|QFileInfo
operator|::
name|isRoot
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|fileEntry
operator|.
name|isRoot
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
comment|//the path is a drive root, but the drive may not exist
comment|//for backward compatibility, return true only if the drive exists
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|ExistsAttribute
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|ExistsAttribute
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|metaData
operator|.
name|exists
argument_list|()
return|;
else|#
directive|else
return|return
literal|true
return|;
endif|#
directive|endif
block|}
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|getFileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|RootFlag
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QFileInfo::symLinkTarget() const     \since 4.2      Returns the absolute path to the file or directory a symlink (or shortcut     on Windows) points to, or a an empty string if the object isn't a symbolic     link.      This name may not represent an existing file; it is only a string.     QFileInfo::exists() returns true if the symlink points to an     existing file.      \sa exists(), isSymLink(), isDir(), isFile() */
end_comment
begin_comment
comment|/*!     \obsolete      Use symLinkTarget() instead. */
end_comment
begin_function
DECL|function|readLink
name|QString
name|QFileInfo
operator|::
name|readLink
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|d
operator|->
name|getFileName
argument_list|(
name|QAbstractFileEngine
operator|::
name|LinkName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the owner of the file. On systems where files     do not have owners, or if an error occurs, an empty string is     returned.      This function can be time consuming under Unix (in the order of     milliseconds).      \sa ownerId(), group(), groupId() */
end_comment
begin_function
DECL|function|owner
name|QString
name|QFileInfo
operator|::
name|owner
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|d
operator|->
name|getFileOwner
argument_list|(
name|QAbstractFileEngine
operator|::
name|OwnerUser
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the id of the owner of the file.      On Windows and on systems where files do not have owners this     function returns ((uint) -2).      \sa owner(), group(), groupId() */
end_comment
begin_function
DECL|function|ownerId
name|uint
name|QFileInfo
operator|::
name|ownerId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|UserId
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|UserId
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|metaData
operator|.
name|userId
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|fileEngine
operator|->
name|ownerId
argument_list|(
name|QAbstractFileEngine
operator|::
name|OwnerUser
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the group of the file. On Windows, on systems where files     do not have groups, or if an error occurs, an empty string is     returned.      This function can be time consuming under Unix (in the order of     milliseconds).      \sa groupId(), owner(), ownerId() */
end_comment
begin_function
DECL|function|group
name|QString
name|QFileInfo
operator|::
name|group
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|d
operator|->
name|getFileOwner
argument_list|(
name|QAbstractFileEngine
operator|::
name|OwnerGroup
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the id of the group the file belongs to.      On Windows and on systems where files do not have groups this     function always returns (uint) -2.      \sa group(), owner(), ownerId() */
end_comment
begin_function
DECL|function|groupId
name|uint
name|QFileInfo
operator|::
name|groupId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|GroupId
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|GroupId
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|metaData
operator|.
name|groupId
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|fileEngine
operator|->
name|ownerId
argument_list|(
name|QAbstractFileEngine
operator|::
name|OwnerGroup
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Tests for file permissions. The \a permissions argument can be     several flags of type QFile::Permissions OR-ed together to check     for permission combinations.      On systems where files do not have permissions this function     always returns true.      Example:     \snippet code/src_corelib_io_qfileinfo.cpp 10      \sa isReadable(), isWritable(), isExecutable() */
end_comment
begin_function
DECL|function|permission
name|bool
name|QFileInfo
operator|::
name|permission
parameter_list|(
name|QFile
operator|::
name|Permissions
name|permissions
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
comment|// the QFileSystemMetaData::MetaDataFlag and QFile::Permissions overlap, so just static cast.
name|QFileSystemMetaData
operator|::
name|MetaDataFlag
name|permissionFlags
init|=
cast|static_cast
argument_list|<
name|QFileSystemMetaData
operator|::
name|MetaDataFlag
argument_list|>
argument_list|(
operator|(
name|int
operator|)
name|permissions
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|permissionFlags
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|permissionFlags
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|metaData
operator|.
name|permissions
argument_list|()
operator|&
name|permissions
operator|)
operator|==
name|permissions
return|;
block|}
return|return
name|d
operator|->
name|getFileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|FileFlags
argument_list|(
operator|(
name|int
operator|)
name|permissions
argument_list|)
argument_list|)
operator|==
operator|(
name|uint
operator|)
name|permissions
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the complete OR-ed together combination of     QFile::Permissions for the file. */
end_comment
begin_function
DECL|function|permissions
name|QFile
operator|::
name|Permissions
name|QFileInfo
operator|::
name|permissions
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|Permissions
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|Permissions
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|metaData
operator|.
name|permissions
argument_list|()
return|;
block|}
return|return
name|QFile
operator|::
name|Permissions
argument_list|(
name|d
operator|->
name|getFileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|PermsMask
argument_list|)
operator|&
name|QAbstractFileEngine
operator|::
name|PermsMask
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the file size in bytes. If the file does not exist or cannot be     fetched, 0 is returned.      \sa exists() */
end_comment
begin_function
DECL|function|size
name|qint64
name|QFileInfo
operator|::
name|size
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|SizeAttribute
argument_list|)
condition|)
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|SizeAttribute
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|metaData
operator|.
name|size
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|getCachedFlag
argument_list|(
name|QFileInfoPrivate
operator|::
name|CachedSize
argument_list|)
condition|)
block|{
name|d
operator|->
name|setCachedFlag
argument_list|(
name|QFileInfoPrivate
operator|::
name|CachedSize
argument_list|)
expr_stmt|;
name|d
operator|->
name|fileSize
operator|=
name|d
operator|->
name|fileEngine
operator|->
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|d
operator|->
name|fileSize
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the date and time when the file was created.      On most Unix systems, this function returns the time of the last     status change. A status change occurs when the file is created,     but it also occurs whenever the user writes or sets inode     information (for example, changing the file permissions).      If neither creation time nor "last status change" time are not     available, returns the same as lastModified().      \sa lastModified(), lastRead() */
end_comment
begin_function
DECL|function|created
name|QDateTime
name|QFileInfo
operator|::
name|created
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QDateTime
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|CreationTime
argument_list|)
condition|)
if|if
condition|(
operator|!
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|CreationTime
argument_list|)
condition|)
return|return
name|QDateTime
argument_list|()
return|;
return|return
name|d
operator|->
name|metaData
operator|.
name|creationTime
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|getFileTime
argument_list|(
name|QAbstractFileEngine
operator|::
name|CreationTime
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the date and time when the file was last modified.      \sa created(), lastRead() */
end_comment
begin_function
DECL|function|lastModified
name|QDateTime
name|QFileInfo
operator|::
name|lastModified
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QDateTime
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|ModificationTime
argument_list|)
condition|)
if|if
condition|(
operator|!
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|ModificationTime
argument_list|)
condition|)
return|return
name|QDateTime
argument_list|()
return|;
return|return
name|d
operator|->
name|metaData
operator|.
name|modificationTime
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|getFileTime
argument_list|(
name|QAbstractFileEngine
operator|::
name|ModificationTime
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the date and time when the file was last read (accessed).      On platforms where this information is not available, returns the     same as lastModified().      \sa created(), lastModified() */
end_comment
begin_function
DECL|function|lastRead
name|QDateTime
name|QFileInfo
operator|::
name|lastRead
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isDefaultConstructed
condition|)
return|return
name|QDateTime
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cache_enabled
operator|||
operator|!
name|d
operator|->
name|metaData
operator|.
name|hasFlags
argument_list|(
name|QFileSystemMetaData
operator|::
name|AccessTime
argument_list|)
condition|)
if|if
condition|(
operator|!
name|QFileSystemEngine
operator|::
name|fillMetaData
argument_list|(
name|d
operator|->
name|fileEntry
argument_list|,
name|d
operator|->
name|metaData
argument_list|,
name|QFileSystemMetaData
operator|::
name|AccessTime
argument_list|)
condition|)
return|return
name|QDateTime
argument_list|()
return|;
return|return
name|d
operator|->
name|metaData
operator|.
name|accessTime
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|getFileTime
argument_list|(
name|QAbstractFileEngine
operator|::
name|AccessTime
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|d_func
name|QFileInfoPrivate
modifier|*
name|QFileInfo
operator|::
name|d_func
parameter_list|()
block|{
return|return
name|d_ptr
operator|.
name|data
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if caching is enabled; otherwise returns false.      \sa setCaching(), refresh() */
end_comment
begin_function
DECL|function|caching
name|bool
name|QFileInfo
operator|::
name|caching
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileInfo
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|cache_enabled
return|;
block|}
end_function
begin_comment
comment|/*!     If \a enable is true, enables caching of file information. If \a     enable is false caching is disabled.      When caching is enabled, QFileInfo reads the file information from     the file system the first time it's needed, but generally not     later.      Caching is enabled by default.      \sa refresh(), caching() */
end_comment
begin_function
DECL|function|setCaching
name|void
name|QFileInfo
operator|::
name|setCaching
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFileInfo
argument_list|)
expr_stmt|;
name|d
operator|->
name|cache_enabled
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \typedef QFileInfoList     \relates QFileInfo      Synonym for QList<QFileInfo>. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
