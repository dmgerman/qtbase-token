begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qsettings.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SETTINGS
end_ifndef
begin_include
include|#
directive|include
file|"qsettings_p.h"
end_include
begin_include
include|#
directive|include
file|"qvector.h"
end_include
begin_include
include|#
directive|include
file|"qmap.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|<qt_windows.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|/*  Keys are stored in QStrings. If the variable name starts with 'u', this is a "user"     key, ie. "foo/bar/alpha/beta". If the variable name starts with 'r', this is a "registry"     key, ie. "\foo\bar\alpha\beta". */
comment|/******************************************************************************* ** Some convenience functions */
comment|/*   We don't use KEY_ALL_ACCESS because it gives more rights than what we   need. See task 199061.  */
DECL|variable|registryPermissions
specifier|static
specifier|const
name|REGSAM
name|registryPermissions
init|=
name|KEY_READ
operator||
name|KEY_WRITE
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|keyPath
specifier|static
name|QString
name|keyPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|rKey
parameter_list|)
block|{
name|int
name|idx
init|=
name|rKey
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|rKey
operator|.
name|left
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|keyName
specifier|static
name|QString
name|keyName
parameter_list|(
specifier|const
name|QString
modifier|&
name|rKey
parameter_list|)
block|{
name|int
name|idx
init|=
name|rKey
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|res
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
name|res
operator|=
name|rKey
expr_stmt|;
else|else
name|res
operator|=
name|rKey
operator|.
name|mid
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|QLatin1String
argument_list|(
literal|"Default"
argument_list|)
operator|||
name|res
operator|==
name|QLatin1String
argument_list|(
literal|"."
argument_list|)
condition|)
name|res
operator|=
name|QLatin1String
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|escapedKey
specifier|static
name|QString
name|escapedKey
parameter_list|(
name|QString
name|uKey
parameter_list|)
block|{
name|QChar
modifier|*
name|data
init|=
name|uKey
operator|.
name|data
argument_list|()
decl_stmt|;
name|int
name|l
init|=
name|uKey
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
operator|++
name|i
control|)
block|{
name|ushort
modifier|&
name|ucs
init|=
name|data
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|ucs
operator|==
literal|'\\'
condition|)
name|ucs
operator|=
literal|'/'
expr_stmt|;
elseif|else
if|if
condition|(
name|ucs
operator|==
literal|'/'
condition|)
name|ucs
operator|=
literal|'\\'
expr_stmt|;
block|}
return|return
name|uKey
return|;
block|}
end_function
begin_function
DECL|function|unescapedKey
specifier|static
name|QString
name|unescapedKey
parameter_list|(
name|QString
name|rKey
parameter_list|)
block|{
return|return
name|escapedKey
argument_list|(
name|rKey
argument_list|)
return|;
block|}
end_function
begin_typedef
DECL|typedef|NameSet
typedef|typedef
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|NameSet
typedef|;
end_typedef
begin_function
DECL|function|mergeKeySets
specifier|static
name|void
name|mergeKeySets
parameter_list|(
name|NameSet
modifier|*
name|dest
parameter_list|,
specifier|const
name|NameSet
modifier|&
name|src
parameter_list|)
block|{
name|NameSet
operator|::
name|const_iterator
name|it
init|=
name|src
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|src
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|dest
operator|->
name|insert
argument_list|(
name|unescapedKey
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mergeKeySets
specifier|static
name|void
name|mergeKeySets
parameter_list|(
name|NameSet
modifier|*
name|dest
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|src
parameter_list|)
block|{
name|QStringList
operator|::
name|const_iterator
name|it
init|=
name|src
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|src
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|dest
operator|->
name|insert
argument_list|(
name|unescapedKey
argument_list|(
operator|*
name|it
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/******************************************************************************* ** Wrappers for the insane windows registry API */
end_comment
begin_function
DECL|function|errorCodeToString
specifier|static
name|QString
name|errorCodeToString
parameter_list|(
name|DWORD
name|errorCode
parameter_list|)
block|{
name|wchar_t
modifier|*
name|data
init|=
literal|0
decl_stmt|;
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_ALLOCATE_BUFFER
operator||
name|FORMAT_MESSAGE_FROM_SYSTEM
argument_list|,
literal|0
argument_list|,
name|errorCode
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QString
name|result
init|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|0
condition|)
name|LocalFree
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
condition|)
name|result
operator|.
name|truncate
argument_list|(
name|result
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|// Open a key with the specified perms
end_comment
begin_function
DECL|function|openKey
specifier|static
name|HKEY
name|openKey
parameter_list|(
name|HKEY
name|parentHandle
parameter_list|,
name|REGSAM
name|perms
parameter_list|,
specifier|const
name|QString
modifier|&
name|rSubKey
parameter_list|)
block|{
name|HKEY
name|resultHandle
init|=
literal|0
decl_stmt|;
name|LONG
name|res
init|=
name|RegOpenKeyEx
argument_list|(
name|parentHandle
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|rSubKey
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|,
name|perms
argument_list|,
operator|&
name|resultHandle
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|ERROR_SUCCESS
condition|)
return|return
name|resultHandle
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|// Open a key with the specified perms, create it if it does not exist
end_comment
begin_function
DECL|function|createOrOpenKey
specifier|static
name|HKEY
name|createOrOpenKey
parameter_list|(
name|HKEY
name|parentHandle
parameter_list|,
name|REGSAM
name|perms
parameter_list|,
specifier|const
name|QString
modifier|&
name|rSubKey
parameter_list|)
block|{
comment|// try to open it
name|HKEY
name|resultHandle
init|=
name|openKey
argument_list|(
name|parentHandle
argument_list|,
name|perms
argument_list|,
name|rSubKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultHandle
operator|!=
literal|0
condition|)
return|return
name|resultHandle
return|;
comment|// try to create it
name|LONG
name|res
init|=
name|RegCreateKeyEx
argument_list|(
name|parentHandle
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|rSubKey
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|REG_OPTION_NON_VOLATILE
argument_list|,
name|perms
argument_list|,
literal|0
argument_list|,
operator|&
name|resultHandle
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|ERROR_SUCCESS
condition|)
return|return
name|resultHandle
return|;
comment|//qWarning("QSettings: Failed to create subkey \"%s\": %s",
comment|//        rSubKey.toLatin1().data(), errorCodeToString(res).toLatin1().data());
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|// Open or create a key in read-write mode if possible, otherwise read-only
end_comment
begin_function
DECL|function|createOrOpenKey
specifier|static
name|HKEY
name|createOrOpenKey
parameter_list|(
name|HKEY
name|parentHandle
parameter_list|,
specifier|const
name|QString
modifier|&
name|rSubKey
parameter_list|,
name|bool
modifier|*
name|readOnly
parameter_list|)
block|{
comment|// try to open or create it read/write
name|HKEY
name|resultHandle
init|=
name|createOrOpenKey
argument_list|(
name|parentHandle
argument_list|,
name|registryPermissions
argument_list|,
name|rSubKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultHandle
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|readOnly
operator|!=
literal|0
condition|)
operator|*
name|readOnly
operator|=
literal|false
expr_stmt|;
return|return
name|resultHandle
return|;
block|}
comment|// try to open or create it read/only
name|resultHandle
operator|=
name|createOrOpenKey
argument_list|(
name|parentHandle
argument_list|,
name|KEY_READ
argument_list|,
name|rSubKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|resultHandle
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|readOnly
operator|!=
literal|0
condition|)
operator|*
name|readOnly
operator|=
literal|true
expr_stmt|;
return|return
name|resultHandle
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|childKeysOrGroups
specifier|static
name|QStringList
name|childKeysOrGroups
parameter_list|(
name|HKEY
name|parentHandle
parameter_list|,
name|QSettingsPrivate
operator|::
name|ChildSpec
name|spec
parameter_list|)
block|{
name|QStringList
name|result
decl_stmt|;
name|DWORD
name|numKeys
decl_stmt|;
name|DWORD
name|maxKeySize
decl_stmt|;
name|DWORD
name|numSubgroups
decl_stmt|;
name|DWORD
name|maxSubgroupSize
decl_stmt|;
comment|// Find the number of keys and subgroups, as well as the max of their lengths.
name|LONG
name|res
init|=
name|RegQueryInfoKey
argument_list|(
name|parentHandle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|numSubgroups
argument_list|,
operator|&
name|maxSubgroupSize
argument_list|,
literal|0
argument_list|,
operator|&
name|numKeys
argument_list|,
operator|&
name|maxKeySize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSettings: RegQueryInfoKey() failed: %s"
argument_list|,
name|errorCodeToString
argument_list|(
name|res
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
operator|++
name|maxSubgroupSize
expr_stmt|;
operator|++
name|maxKeySize
expr_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
name|spec
operator|==
name|QSettingsPrivate
operator|::
name|ChildKeys
condition|)
block|{
name|n
operator|=
name|numKeys
expr_stmt|;
name|m
operator|=
name|maxKeySize
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|numSubgroups
expr_stmt|;
name|m
operator|=
name|maxSubgroupSize
expr_stmt|;
block|}
comment|/* The size does not include the terminating null character. */
operator|++
name|m
expr_stmt|;
comment|// Get the list
name|QByteArray
name|buff
argument_list|(
name|m
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|item
decl_stmt|;
name|DWORD
name|l
init|=
name|buff
operator|.
name|size
argument_list|()
operator|/
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|==
name|QSettingsPrivate
operator|::
name|ChildKeys
condition|)
block|{
name|res
operator|=
name|RegEnumValue
argument_list|(
name|parentHandle
argument_list|,
name|i
argument_list|,
cast|reinterpret_cast
argument_list|<
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|buff
operator|.
name|data
argument_list|()
argument_list|)
argument_list|,
operator|&
name|l
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|RegEnumKeyEx
argument_list|(
name|parentHandle
argument_list|,
name|i
argument_list|,
cast|reinterpret_cast
argument_list|<
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|buff
operator|.
name|data
argument_list|()
argument_list|)
argument_list|,
operator|&
name|l
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
name|ERROR_SUCCESS
condition|)
name|item
operator|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|buff
operator|.
name|constData
argument_list|()
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSettings: RegEnumValue failed: %s"
argument_list|,
name|errorCodeToString
argument_list|(
name|res
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|item
operator|.
name|isEmpty
argument_list|()
condition|)
name|item
operator|=
name|QLatin1String
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|allKeys
specifier|static
name|void
name|allKeys
parameter_list|(
name|HKEY
name|parentHandle
parameter_list|,
specifier|const
name|QString
modifier|&
name|rSubKey
parameter_list|,
name|NameSet
modifier|*
name|result
parameter_list|)
block|{
name|HKEY
name|handle
init|=
name|openKey
argument_list|(
name|parentHandle
argument_list|,
name|KEY_READ
argument_list|,
name|rSubKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
return|return;
name|QStringList
name|childKeys
init|=
name|childKeysOrGroups
argument_list|(
name|handle
argument_list|,
name|QSettingsPrivate
operator|::
name|ChildKeys
argument_list|)
decl_stmt|;
name|QStringList
name|childGroups
init|=
name|childKeysOrGroups
argument_list|(
name|handle
argument_list|,
name|QSettingsPrivate
operator|::
name|ChildGroups
argument_list|)
decl_stmt|;
name|RegCloseKey
argument_list|(
name|handle
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childKeys
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|s
init|=
name|rSubKey
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
name|s
operator|+=
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|s
operator|+=
name|childKeys
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|result
operator|->
name|insert
argument_list|(
name|s
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childGroups
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|s
init|=
name|rSubKey
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
name|s
operator|+=
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|s
operator|+=
name|childGroups
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|allKeys
argument_list|(
name|parentHandle
argument_list|,
name|s
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|deleteChildGroups
specifier|static
name|void
name|deleteChildGroups
parameter_list|(
name|HKEY
name|parentHandle
parameter_list|)
block|{
name|QStringList
name|childGroups
init|=
name|childKeysOrGroups
argument_list|(
name|parentHandle
argument_list|,
name|QSettingsPrivate
operator|::
name|ChildGroups
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childGroups
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|group
init|=
name|childGroups
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// delete subgroups in group
name|HKEY
name|childGroupHandle
init|=
name|openKey
argument_list|(
name|parentHandle
argument_list|,
name|registryPermissions
argument_list|,
name|group
argument_list|)
decl_stmt|;
if|if
condition|(
name|childGroupHandle
operator|==
literal|0
condition|)
continue|continue;
name|deleteChildGroups
argument_list|(
name|childGroupHandle
argument_list|)
expr_stmt|;
name|RegCloseKey
argument_list|(
name|childGroupHandle
argument_list|)
expr_stmt|;
comment|// delete group itself
name|LONG
name|res
init|=
name|RegDeleteKey
argument_list|(
name|parentHandle
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|group
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSettings: RegDeleteKey failed on subkey \"%s\": %s"
argument_list|,
name|group
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|errorCodeToString
argument_list|(
name|res
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_comment
comment|/******************************************************************************* ** class RegistryKey */
end_comment
begin_class
DECL|class|RegistryKey
class|class
name|RegistryKey
block|{
public|public:
name|RegistryKey
parameter_list|(
name|HKEY
name|parent_handle
init|=
literal|0
parameter_list|,
specifier|const
name|QString
modifier|&
name|key
init|=
name|QString
argument_list|()
parameter_list|,
name|bool
name|read_only
init|=
literal|true
parameter_list|)
constructor_decl|;
name|QString
name|key
parameter_list|()
specifier|const
function_decl|;
name|HKEY
name|handle
parameter_list|()
specifier|const
function_decl|;
name|HKEY
name|parentHandle
parameter_list|()
specifier|const
function_decl|;
name|bool
name|readOnly
parameter_list|()
specifier|const
function_decl|;
name|void
name|close
parameter_list|()
function_decl|;
private|private:
DECL|member|m_parent_handle
name|HKEY
name|m_parent_handle
decl_stmt|;
DECL|member|m_handle
specifier|mutable
name|HKEY
name|m_handle
decl_stmt|;
DECL|member|m_key
name|QString
name|m_key
decl_stmt|;
DECL|member|m_read_only
specifier|mutable
name|bool
name|m_read_only
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|RegistryKey
name|RegistryKey
operator|::
name|RegistryKey
parameter_list|(
name|HKEY
name|parent_handle
parameter_list|,
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
name|bool
name|read_only
parameter_list|)
block|{
name|m_parent_handle
operator|=
name|parent_handle
expr_stmt|;
name|m_handle
operator|=
literal|0
expr_stmt|;
name|m_read_only
operator|=
name|read_only
expr_stmt|;
name|m_key
operator|=
name|key
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|key
name|QString
name|RegistryKey
operator|::
name|key
parameter_list|()
specifier|const
block|{
return|return
name|m_key
return|;
block|}
end_function
begin_function
DECL|function|handle
name|HKEY
name|RegistryKey
operator|::
name|handle
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|m_handle
operator|!=
literal|0
condition|)
return|return
name|m_handle
return|;
if|if
condition|(
name|m_read_only
condition|)
name|m_handle
operator|=
name|openKey
argument_list|(
name|m_parent_handle
argument_list|,
name|KEY_READ
argument_list|,
name|m_key
argument_list|)
expr_stmt|;
else|else
name|m_handle
operator|=
name|createOrOpenKey
argument_list|(
name|m_parent_handle
argument_list|,
name|m_key
argument_list|,
operator|&
name|m_read_only
argument_list|)
expr_stmt|;
return|return
name|m_handle
return|;
block|}
end_function
begin_function
DECL|function|parentHandle
name|HKEY
name|RegistryKey
operator|::
name|parentHandle
parameter_list|()
specifier|const
block|{
return|return
name|m_parent_handle
return|;
block|}
end_function
begin_function
DECL|function|readOnly
name|bool
name|RegistryKey
operator|::
name|readOnly
parameter_list|()
specifier|const
block|{
return|return
name|m_read_only
return|;
block|}
end_function
begin_function
DECL|function|close
name|void
name|RegistryKey
operator|::
name|close
parameter_list|()
block|{
if|if
condition|(
name|m_handle
operator|!=
literal|0
condition|)
name|RegCloseKey
argument_list|(
name|m_handle
argument_list|)
expr_stmt|;
name|m_handle
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_typedef
DECL|typedef|RegistryKeyList
typedef|typedef
name|QVector
argument_list|<
name|RegistryKey
argument_list|>
name|RegistryKeyList
typedef|;
end_typedef
begin_comment
comment|/******************************************************************************* ** class QWinSettingsPrivate */
end_comment
begin_class
DECL|class|QWinSettingsPrivate
class|class
name|QWinSettingsPrivate
super|:
specifier|public
name|QSettingsPrivate
block|{
public|public:
name|QWinSettingsPrivate
parameter_list|(
name|QSettings
operator|::
name|Scope
name|scope
parameter_list|,
specifier|const
name|QString
modifier|&
name|organization
parameter_list|,
specifier|const
name|QString
modifier|&
name|application
parameter_list|)
constructor_decl|;
name|QWinSettingsPrivate
parameter_list|(
name|QString
name|rKey
parameter_list|)
constructor_decl|;
name|~
name|QWinSettingsPrivate
parameter_list|()
destructor_decl|;
name|void
name|remove
parameter_list|(
specifier|const
name|QString
modifier|&
name|uKey
parameter_list|)
function_decl|;
name|void
name|set
parameter_list|(
specifier|const
name|QString
modifier|&
name|uKey
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
function_decl|;
name|bool
name|get
parameter_list|(
specifier|const
name|QString
modifier|&
name|uKey
parameter_list|,
name|QVariant
modifier|*
name|value
parameter_list|)
specifier|const
function_decl|;
name|QStringList
name|children
parameter_list|(
specifier|const
name|QString
modifier|&
name|uKey
parameter_list|,
name|ChildSpec
name|spec
parameter_list|)
specifier|const
function_decl|;
name|void
name|clear
parameter_list|()
function_decl|;
name|void
name|sync
parameter_list|()
function_decl|;
name|void
name|flush
parameter_list|()
function_decl|;
name|bool
name|isWritable
parameter_list|()
specifier|const
function_decl|;
name|HKEY
name|writeHandle
parameter_list|()
specifier|const
function_decl|;
name|bool
name|readKey
parameter_list|(
name|HKEY
name|parentHandle
parameter_list|,
specifier|const
name|QString
modifier|&
name|rSubKey
parameter_list|,
name|QVariant
modifier|*
name|value
parameter_list|)
specifier|const
function_decl|;
name|QString
name|fileName
parameter_list|()
specifier|const
function_decl|;
private|private:
DECL|member|regList
name|RegistryKeyList
name|regList
decl_stmt|;
comment|// list of registry locations to search for keys
DECL|member|deleteWriteHandleOnExit
name|bool
name|deleteWriteHandleOnExit
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|QWinSettingsPrivate
name|QWinSettingsPrivate
operator|::
name|QWinSettingsPrivate
parameter_list|(
name|QSettings
operator|::
name|Scope
name|scope
parameter_list|,
specifier|const
name|QString
modifier|&
name|organization
parameter_list|,
specifier|const
name|QString
modifier|&
name|application
parameter_list|)
member_init_list|:
name|QSettingsPrivate
argument_list|(
name|QSettings
operator|::
name|NativeFormat
argument_list|,
name|scope
argument_list|,
name|organization
argument_list|,
name|application
argument_list|)
block|{
name|deleteWriteHandleOnExit
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|organization
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|prefix
init|=
name|QLatin1String
argument_list|(
literal|"Software\\"
argument_list|)
operator|+
name|organization
decl_stmt|;
name|QString
name|orgPrefix
init|=
name|prefix
operator|+
name|QLatin1String
argument_list|(
literal|"\\OrganizationDefaults"
argument_list|)
decl_stmt|;
name|QString
name|appPrefix
init|=
name|prefix
operator|+
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
operator|+
name|application
decl_stmt|;
if|if
condition|(
name|scope
operator|==
name|QSettings
operator|::
name|UserScope
condition|)
block|{
if|if
condition|(
operator|!
name|application
operator|.
name|isEmpty
argument_list|()
condition|)
name|regList
operator|.
name|append
argument_list|(
name|RegistryKey
argument_list|(
name|HKEY_CURRENT_USER
argument_list|,
name|appPrefix
argument_list|,
operator|!
name|regList
operator|.
name|isEmpty
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|regList
operator|.
name|append
argument_list|(
name|RegistryKey
argument_list|(
name|HKEY_CURRENT_USER
argument_list|,
name|orgPrefix
argument_list|,
operator|!
name|regList
operator|.
name|isEmpty
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|application
operator|.
name|isEmpty
argument_list|()
condition|)
name|regList
operator|.
name|append
argument_list|(
name|RegistryKey
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|appPrefix
argument_list|,
operator|!
name|regList
operator|.
name|isEmpty
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|regList
operator|.
name|append
argument_list|(
name|RegistryKey
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|orgPrefix
argument_list|,
operator|!
name|regList
operator|.
name|isEmpty
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regList
operator|.
name|isEmpty
argument_list|()
condition|)
name|setStatus
argument_list|(
name|QSettings
operator|::
name|AccessError
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QWinSettingsPrivate
name|QWinSettingsPrivate
operator|::
name|QWinSettingsPrivate
parameter_list|(
name|QString
name|rPath
parameter_list|)
member_init_list|:
name|QSettingsPrivate
argument_list|(
name|QSettings
operator|::
name|NativeFormat
argument_list|)
block|{
name|deleteWriteHandleOnExit
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|rPath
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"\\"
argument_list|)
argument_list|)
condition|)
name|rPath
operator|=
name|rPath
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rPath
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"HKEY_CURRENT_USER\\"
argument_list|)
argument_list|)
condition|)
name|regList
operator|.
name|append
argument_list|(
name|RegistryKey
argument_list|(
name|HKEY_CURRENT_USER
argument_list|,
name|rPath
operator|.
name|mid
argument_list|(
literal|18
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rPath
operator|==
name|QLatin1String
argument_list|(
literal|"HKEY_CURRENT_USER"
argument_list|)
condition|)
name|regList
operator|.
name|append
argument_list|(
name|RegistryKey
argument_list|(
name|HKEY_CURRENT_USER
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rPath
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"HKEY_LOCAL_MACHINE\\"
argument_list|)
argument_list|)
condition|)
name|regList
operator|.
name|append
argument_list|(
name|RegistryKey
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|rPath
operator|.
name|mid
argument_list|(
literal|19
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rPath
operator|==
name|QLatin1String
argument_list|(
literal|"HKEY_LOCAL_MACHINE"
argument_list|)
condition|)
name|regList
operator|.
name|append
argument_list|(
name|RegistryKey
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rPath
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"HKEY_CLASSES_ROOT\\"
argument_list|)
argument_list|)
condition|)
name|regList
operator|.
name|append
argument_list|(
name|RegistryKey
argument_list|(
name|HKEY_CLASSES_ROOT
argument_list|,
name|rPath
operator|.
name|mid
argument_list|(
literal|18
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rPath
operator|==
name|QLatin1String
argument_list|(
literal|"HKEY_CLASSES_ROOT"
argument_list|)
condition|)
name|regList
operator|.
name|append
argument_list|(
name|RegistryKey
argument_list|(
name|HKEY_CLASSES_ROOT
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rPath
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"HKEY_USERS\\"
argument_list|)
argument_list|)
condition|)
name|regList
operator|.
name|append
argument_list|(
name|RegistryKey
argument_list|(
name|HKEY_USERS
argument_list|,
name|rPath
operator|.
name|mid
argument_list|(
literal|11
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rPath
operator|==
name|QLatin1String
argument_list|(
name|QLatin1String
argument_list|(
literal|"HKEY_USERS"
argument_list|)
argument_list|)
condition|)
name|regList
operator|.
name|append
argument_list|(
name|RegistryKey
argument_list|(
name|HKEY_USERS
argument_list|,
name|QString
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|regList
operator|.
name|append
argument_list|(
name|RegistryKey
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|rPath
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|readKey
name|bool
name|QWinSettingsPrivate
operator|::
name|readKey
parameter_list|(
name|HKEY
name|parentHandle
parameter_list|,
specifier|const
name|QString
modifier|&
name|rSubKey
parameter_list|,
name|QVariant
modifier|*
name|value
parameter_list|)
specifier|const
block|{
name|QString
name|rSubkeyName
init|=
name|keyName
argument_list|(
name|rSubKey
argument_list|)
decl_stmt|;
name|QString
name|rSubkeyPath
init|=
name|keyPath
argument_list|(
name|rSubKey
argument_list|)
decl_stmt|;
comment|// open a handle on the subkey
name|HKEY
name|handle
init|=
name|openKey
argument_list|(
name|parentHandle
argument_list|,
name|KEY_READ
argument_list|,
name|rSubkeyPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
return|return
literal|false
return|;
comment|// get the size and type of the value
name|DWORD
name|dataType
decl_stmt|;
name|DWORD
name|dataSize
decl_stmt|;
name|LONG
name|res
init|=
name|RegQueryValueEx
argument_list|(
name|handle
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|rSubkeyName
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|dataType
argument_list|,
literal|0
argument_list|,
operator|&
name|dataSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|RegCloseKey
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// get the value
name|QByteArray
name|data
argument_list|(
name|dataSize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|res
operator|=
name|RegQueryValueEx
argument_list|(
name|handle
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|rSubkeyName
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|)
argument_list|,
operator|&
name|dataSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|RegCloseKey
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|dataType
condition|)
block|{
case|case
name|REG_EXPAND_SZ
case|:
case|case
name|REG_SZ
case|:
block|{
name|QString
name|s
decl_stmt|;
if|if
condition|(
name|dataSize
condition|)
block|{
name|s
operator|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
operator|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|data
operator|.
name|constData
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
operator|*
name|value
operator|=
name|stringToVariant
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|REG_MULTI_SZ
case|:
block|{
name|QStringList
name|l
decl_stmt|;
if|if
condition|(
name|dataSize
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|QString
name|s
init|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|data
operator|.
name|constData
argument_list|()
operator|+
name|i
argument_list|)
decl_stmt|;
name|i
operator|+=
name|s
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
name|l
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
operator|*
name|value
operator|=
name|stringListToVariantList
argument_list|(
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|REG_NONE
case|:
case|case
name|REG_BINARY
case|:
block|{
name|QString
name|s
decl_stmt|;
if|if
condition|(
name|dataSize
condition|)
block|{
name|s
operator|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|data
operator|.
name|constData
argument_list|()
argument_list|,
name|data
operator|.
name|size
argument_list|()
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
operator|*
name|value
operator|=
name|stringToVariant
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|REG_DWORD_BIG_ENDIAN
case|:
case|case
name|REG_DWORD
case|:
block|{
name|Q_ASSERT
argument_list|(
name|data
operator|.
name|size
argument_list|()
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|i
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
name|data
operator|.
name|constData
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
operator|*
name|value
operator|=
name|i
expr_stmt|;
break|break;
block|}
case|case
name|REG_QWORD
case|:
block|{
name|Q_ASSERT
argument_list|(
name|data
operator|.
name|size
argument_list|()
operator|==
sizeof|sizeof
argument_list|(
name|qint64
argument_list|)
argument_list|)
expr_stmt|;
name|qint64
name|i
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
name|data
operator|.
name|constData
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|qint64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
operator|*
name|value
operator|=
name|i
expr_stmt|;
break|break;
block|}
default|default:
name|qWarning
argument_list|(
literal|"QSettings: Unknown data %d type in Windows registry"
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|dataType
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
operator|*
name|value
operator|=
name|QVariant
argument_list|()
expr_stmt|;
break|break;
block|}
name|RegCloseKey
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|writeHandle
name|HKEY
name|QWinSettingsPrivate
operator|::
name|writeHandle
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|regList
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
specifier|const
name|RegistryKey
modifier|&
name|key
init|=
name|regList
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|handle
argument_list|()
operator|==
literal|0
operator|||
name|key
operator|.
name|readOnly
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|key
operator|.
name|handle
argument_list|()
return|;
block|}
end_function
begin_destructor
DECL|function|~QWinSettingsPrivate
name|QWinSettingsPrivate
operator|::
name|~
name|QWinSettingsPrivate
parameter_list|()
block|{
if|if
condition|(
name|deleteWriteHandleOnExit
operator|&&
name|writeHandle
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|remove
argument_list|(
name|regList
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|QString
name|emptyKey
decl_stmt|;
name|DWORD
name|res
init|=
name|RegDeleteKey
argument_list|(
name|writeHandle
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|emptyKey
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSettings: Failed to delete key \"%s\": %s"
argument_list|,
name|regList
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|errorCodeToString
argument_list|(
name|res
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|regList
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|remove
name|void
name|QWinSettingsPrivate
operator|::
name|remove
parameter_list|(
specifier|const
name|QString
modifier|&
name|uKey
parameter_list|)
block|{
if|if
condition|(
name|writeHandle
argument_list|()
operator|==
literal|0
condition|)
block|{
name|setStatus
argument_list|(
name|QSettings
operator|::
name|AccessError
argument_list|)
expr_stmt|;
return|return;
block|}
name|QString
name|rKey
init|=
name|escapedKey
argument_list|(
name|uKey
argument_list|)
decl_stmt|;
comment|// try to delete value bar in key foo
name|LONG
name|res
decl_stmt|;
name|HKEY
name|handle
init|=
name|openKey
argument_list|(
name|writeHandle
argument_list|()
argument_list|,
name|registryPermissions
argument_list|,
name|keyPath
argument_list|(
name|rKey
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|0
condition|)
block|{
name|res
operator|=
name|RegDeleteValue
argument_list|(
name|handle
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|keyName
argument_list|(
name|rKey
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|RegCloseKey
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
comment|// try to delete key foo/bar and all subkeys
name|handle
operator|=
name|openKey
argument_list|(
name|writeHandle
argument_list|()
argument_list|,
name|registryPermissions
argument_list|,
name|rKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|0
condition|)
block|{
name|deleteChildGroups
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|rKey
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
name|childKeys
init|=
name|childKeysOrGroups
argument_list|(
name|handle
argument_list|,
name|QSettingsPrivate
operator|::
name|ChildKeys
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childKeys
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|group
init|=
name|childKeys
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|LONG
name|res
init|=
name|RegDeleteValue
argument_list|(
name|handle
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|group
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSettings: RegDeleteValue failed on subkey \"%s\": %s"
argument_list|,
name|group
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|errorCodeToString
argument_list|(
name|res
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
comment|// For WinCE always Close the handle first.
name|RegCloseKey
argument_list|(
name|handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|res
operator|=
name|RegDeleteKey
argument_list|(
name|writeHandle
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|rKey
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSettings: RegDeleteKey failed on key \"%s\": %s"
argument_list|,
name|rKey
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|errorCodeToString
argument_list|(
name|res
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|RegCloseKey
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|stringContainsNullChar
specifier|static
name|bool
name|stringContainsNullChar
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|unicode
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|set
name|void
name|QWinSettingsPrivate
operator|::
name|set
parameter_list|(
specifier|const
name|QString
modifier|&
name|uKey
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
name|writeHandle
argument_list|()
operator|==
literal|0
condition|)
block|{
name|setStatus
argument_list|(
name|QSettings
operator|::
name|AccessError
argument_list|)
expr_stmt|;
return|return;
block|}
name|QString
name|rKey
init|=
name|escapedKey
argument_list|(
name|uKey
argument_list|)
decl_stmt|;
name|HKEY
name|handle
init|=
name|createOrOpenKey
argument_list|(
name|writeHandle
argument_list|()
argument_list|,
name|registryPermissions
argument_list|,
name|keyPath
argument_list|(
name|rKey
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
block|{
name|setStatus
argument_list|(
name|QSettings
operator|::
name|AccessError
argument_list|)
expr_stmt|;
return|return;
block|}
name|DWORD
name|type
decl_stmt|;
name|QByteArray
name|regValueBuff
decl_stmt|;
comment|// Determine the type
switch|switch
condition|(
name|value
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|QVariant
operator|::
name|List
case|:
case|case
name|QVariant
operator|::
name|StringList
case|:
block|{
comment|// If none of the elements contains '\0', we can use REG_MULTI_SZ, the
comment|// native registry string list type. Otherwise we use REG_BINARY.
name|type
operator|=
name|REG_MULTI_SZ
expr_stmt|;
name|QStringList
name|l
init|=
name|variantListToStringList
argument_list|(
name|value
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|QStringList
operator|::
name|const_iterator
name|it
init|=
name|l
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|l
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|stringContainsNullChar
argument_list|(
operator|*
name|it
argument_list|)
condition|)
block|{
name|type
operator|=
name|REG_BINARY
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|REG_BINARY
condition|)
block|{
name|QString
name|s
init|=
name|variantToString
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|regValueBuff
operator|=
name|QByteArray
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|s
operator|.
name|utf16
argument_list|()
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QStringList
operator|::
name|const_iterator
name|it
init|=
name|l
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|l
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QString
modifier|&
name|s
init|=
operator|*
name|it
decl_stmt|;
name|regValueBuff
operator|+=
name|QByteArray
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|s
operator|.
name|utf16
argument_list|()
argument_list|,
operator|(
name|s
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
name|regValueBuff
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
literal|0
argument_list|)
expr_stmt|;
name|regValueBuff
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QVariant
operator|::
name|Int
case|:
case|case
name|QVariant
operator|::
name|UInt
case|:
block|{
name|type
operator|=
name|REG_DWORD
expr_stmt|;
name|qint32
name|i
init|=
name|value
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|regValueBuff
operator|=
name|QByteArray
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|qint32
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|LongLong
case|:
case|case
name|QVariant
operator|::
name|ULongLong
case|:
block|{
name|type
operator|=
name|REG_QWORD
expr_stmt|;
name|qint64
name|i
init|=
name|value
operator|.
name|toLongLong
argument_list|()
decl_stmt|;
name|regValueBuff
operator|=
name|QByteArray
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|qint64
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|ByteArray
case|:
comment|// fallthrough intended
default|default:
block|{
comment|// If the string does not contain '\0', we can use REG_SZ, the native registry
comment|// string type. Otherwise we use REG_BINARY.
name|QString
name|s
init|=
name|variantToString
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|type
operator|=
name|stringContainsNullChar
argument_list|(
name|s
argument_list|)
condition|?
name|REG_BINARY
else|:
name|REG_SZ
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|REG_BINARY
condition|)
block|{
name|regValueBuff
operator|=
name|QByteArray
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|s
operator|.
name|utf16
argument_list|()
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regValueBuff
operator|=
name|QByteArray
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|s
operator|.
name|utf16
argument_list|()
argument_list|,
operator|(
name|s
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|// set the value
name|LONG
name|res
init|=
name|RegSetValueEx
argument_list|(
name|handle
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|keyName
argument_list|(
name|rKey
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|regValueBuff
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|,
name|regValueBuff
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|ERROR_SUCCESS
condition|)
block|{
name|deleteWriteHandleOnExit
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QSettings: failed to set subkey \"%s\": %s"
argument_list|,
name|rKey
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|errorCodeToString
argument_list|(
name|res
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|setStatus
argument_list|(
name|QSettings
operator|::
name|AccessError
argument_list|)
expr_stmt|;
block|}
name|RegCloseKey
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get
name|bool
name|QWinSettingsPrivate
operator|::
name|get
parameter_list|(
specifier|const
name|QString
modifier|&
name|uKey
parameter_list|,
name|QVariant
modifier|*
name|value
parameter_list|)
specifier|const
block|{
name|QString
name|rKey
init|=
name|escapedKey
argument_list|(
name|uKey
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|HKEY
name|handle
init|=
name|regList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|handle
argument_list|()
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|0
operator|&&
name|readKey
argument_list|(
name|handle
argument_list|,
name|rKey
argument_list|,
name|value
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|fallbacks
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|children
name|QStringList
name|QWinSettingsPrivate
operator|::
name|children
parameter_list|(
specifier|const
name|QString
modifier|&
name|uKey
parameter_list|,
name|ChildSpec
name|spec
parameter_list|)
specifier|const
block|{
name|NameSet
name|result
decl_stmt|;
name|QString
name|rKey
init|=
name|escapedKey
argument_list|(
name|uKey
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|HKEY
name|parent_handle
init|=
name|regList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|handle
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent_handle
operator|==
literal|0
condition|)
continue|continue;
name|HKEY
name|handle
init|=
name|openKey
argument_list|(
name|parent_handle
argument_list|,
name|KEY_READ
argument_list|,
name|rKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|spec
operator|==
name|AllKeys
condition|)
block|{
name|NameSet
name|keys
decl_stmt|;
name|allKeys
argument_list|(
name|handle
argument_list|,
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
operator|&
name|keys
argument_list|)
expr_stmt|;
name|mergeKeySets
argument_list|(
operator|&
name|result
argument_list|,
name|keys
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// ChildGroups or ChildKeys
name|QStringList
name|names
init|=
name|childKeysOrGroups
argument_list|(
name|handle
argument_list|,
name|spec
argument_list|)
decl_stmt|;
name|mergeKeySets
argument_list|(
operator|&
name|result
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
name|RegCloseKey
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fallbacks
condition|)
return|return
name|result
operator|.
name|keys
argument_list|()
return|;
block|}
return|return
name|result
operator|.
name|keys
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|clear
name|void
name|QWinSettingsPrivate
operator|::
name|clear
parameter_list|()
block|{
name|remove
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|deleteWriteHandleOnExit
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sync
name|void
name|QWinSettingsPrivate
operator|::
name|sync
parameter_list|()
block|{
name|RegFlushKey
argument_list|(
name|writeHandle
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|flush
name|void
name|QWinSettingsPrivate
operator|::
name|flush
parameter_list|()
block|{
comment|// Windows does this for us.
block|}
end_function
begin_function
DECL|function|fileName
name|QString
name|QWinSettingsPrivate
operator|::
name|fileName
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|regList
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
specifier|const
name|RegistryKey
modifier|&
name|key
init|=
name|regList
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QString
name|result
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|parentHandle
argument_list|()
operator|==
name|HKEY_CURRENT_USER
condition|)
name|result
operator|=
name|QLatin1String
argument_list|(
literal|"\\HKEY_CURRENT_USER\\"
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|QLatin1String
argument_list|(
literal|"\\HKEY_LOCAL_MACHINE\\"
argument_list|)
expr_stmt|;
return|return
name|result
operator|+
name|regList
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|isWritable
name|bool
name|QWinSettingsPrivate
operator|::
name|isWritable
parameter_list|()
specifier|const
block|{
return|return
name|writeHandle
argument_list|()
operator|!=
literal|0
return|;
block|}
end_function
begin_function
DECL|function|create
name|QSettingsPrivate
modifier|*
name|QSettingsPrivate
operator|::
name|create
parameter_list|(
name|QSettings
operator|::
name|Format
name|format
parameter_list|,
name|QSettings
operator|::
name|Scope
name|scope
parameter_list|,
specifier|const
name|QString
modifier|&
name|organization
parameter_list|,
specifier|const
name|QString
modifier|&
name|application
parameter_list|)
block|{
if|if
condition|(
name|format
operator|==
name|QSettings
operator|::
name|NativeFormat
condition|)
block|{
return|return
operator|new
name|QWinSettingsPrivate
argument_list|(
name|scope
argument_list|,
name|organization
argument_list|,
name|application
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|QConfFileSettingsPrivate
argument_list|(
name|format
argument_list|,
name|scope
argument_list|,
name|organization
argument_list|,
name|application
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|create
name|QSettingsPrivate
modifier|*
name|QSettingsPrivate
operator|::
name|create
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QSettings
operator|::
name|Format
name|format
parameter_list|)
block|{
if|if
condition|(
name|format
operator|==
name|QSettings
operator|::
name|NativeFormat
condition|)
block|{
return|return
operator|new
name|QWinSettingsPrivate
argument_list|(
name|fileName
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|QConfFileSettingsPrivate
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|)
return|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_SETTINGS
end_comment
end_unit
