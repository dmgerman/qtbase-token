begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qsettings.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SETTINGS
end_ifndef
begin_include
include|#
directive|include
file|"qsettings_p.h"
end_include
begin_include
include|#
directive|include
file|"qcache.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qdir.h"
end_include
begin_include
include|#
directive|include
file|"qfileinfo.h"
end_include
begin_include
include|#
directive|include
file|"qmutex.h"
end_include
begin_include
include|#
directive|include
file|"qlibraryinfo.h"
end_include
begin_include
include|#
directive|include
file|"qtemporaryfile.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
end_ifndef
begin_include
include|#
directive|include
file|"qtextcodec.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GEOM_VARIANT
end_ifndef
begin_include
include|#
directive|include
file|"qsize.h"
end_include
begin_include
include|#
directive|include
file|"qpoint.h"
end_include
begin_include
include|#
directive|include
file|"qrect.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !QT_NO_GEOM_VARIANT
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_VXWORKS
end_ifdef
begin_include
include|#
directive|include
file|<ioLib.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_comment
comment|// for homedirpath reading from registry
end_comment
begin_include
include|#
directive|include
file|<private/qsystemlibrary_p.h>
end_include
begin_include
include|#
directive|include
file|<qt_windows.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|CSIDL_COMMON_APPDATA
end_ifndef
begin_define
DECL|macro|CSIDL_COMMON_APPDATA
define|#
directive|define
name|CSIDL_COMMON_APPDATA
value|0x0023
end_define
begin_comment
DECL|macro|CSIDL_COMMON_APPDATA
comment|// All Users\Application Data
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|CSIDL_APPDATA
end_ifndef
begin_define
DECL|macro|CSIDL_APPDATA
define|#
directive|define
name|CSIDL_APPDATA
value|0x001a
end_define
begin_comment
DECL|macro|CSIDL_APPDATA
comment|//<username>\Application Data
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_AUTOTEST_EXPORT
end_ifdef
begin_define
DECL|macro|Q_AUTOTEST_EXPORT_HELPER
define|#
directive|define
name|Q_AUTOTEST_EXPORT_HELPER
value|Q_AUTOTEST_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_AUTOTEST_EXPORT_HELPER
define|#
directive|define
name|Q_AUTOTEST_EXPORT_HELPER
value|static
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// ************************************************************************
end_comment
begin_comment
comment|// QConfFile
end_comment
begin_comment
comment|/*     QConfFile objects are explicitly shared within the application.     This ensures that modification to the settings done through one     QSettings object are immediately reflected in other setting     objects of the same application. */
end_comment
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_struct
DECL|struct|QConfFileCustomFormat
struct|struct
name|QConfFileCustomFormat
block|{
DECL|member|extension
name|QString
name|extension
decl_stmt|;
DECL|member|readFunc
name|QSettings
operator|::
name|ReadFunc
name|readFunc
decl_stmt|;
DECL|member|writeFunc
name|QSettings
operator|::
name|WriteFunc
name|writeFunc
decl_stmt|;
DECL|member|caseSensitivity
name|Qt
operator|::
name|CaseSensitivity
name|caseSensitivity
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|ConfFileHash
typedef|typedef
name|QHash
argument_list|<
name|QString
argument_list|,
name|QConfFile
modifier|*
argument_list|>
name|ConfFileHash
typedef|;
end_typedef
begin_typedef
DECL|typedef|ConfFileCache
typedef|typedef
name|QCache
argument_list|<
name|QString
argument_list|,
name|QConfFile
argument_list|>
name|ConfFileCache
typedef|;
end_typedef
begin_typedef
DECL|typedef|PathHash
typedef|typedef
name|QHash
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
name|PathHash
typedef|;
end_typedef
begin_typedef
DECL|typedef|CustomFormatVector
typedef|typedef
name|QVector
argument_list|<
name|QConfFileCustomFormat
argument_list|>
name|CustomFormatVector
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|ConfFileHash
argument_list|,
argument|usedHashFunc
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|ConfFileCache
argument_list|,
argument|unusedCacheFunc
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|PathHash
argument_list|,
argument|pathHashFunc
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|CustomFormatVector
argument_list|,
argument|customFormatVectorFunc
argument_list|)
end_macro
begin_decl_stmt
DECL|variable|settingsGlobalMutex
specifier|static
name|QBasicMutex
name|settingsGlobalMutex
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|globalDefaultFormat
specifier|static
name|QSettings
operator|::
name|Format
name|globalDefaultFormat
init|=
name|QSettings
operator|::
name|NativeFormat
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_WIN
end_ifndef
begin_function
DECL|function|qt_isEvilFsTypeName
specifier|inline
name|bool
name|qt_isEvilFsTypeName
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|qstrncmp
argument_list|(
name|name
argument_list|,
literal|"nfs"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|qstrncmp
argument_list|(
name|name
argument_list|,
literal|"autofs"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|qstrncmp
argument_list|(
name|name
argument_list|,
literal|"cachefs"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_BSD4
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_NETBSD
argument_list|)
end_if
begin_function
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|<sys/param.h>
include|#
directive|include
file|<sys/mount.h>
name|QT_END_INCLUDE_NAMESPACE
DECL|function|qIsLikelyToBeNfs
name|Q_AUTOTEST_EXPORT_HELPER
name|bool
name|qIsLikelyToBeNfs
parameter_list|(
name|int
name|handle
parameter_list|)
block|{
name|struct
name|statfs
name|buf
decl_stmt|;
if|if
condition|(
name|fstatfs
argument_list|(
name|handle
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
return|return
name|qt_isEvilFsTypeName
argument_list|(
name|buf
operator|.
name|f_fstypename
argument_list|)
return|;
block|}
end_function
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_HURD
argument_list|)
end_elif
begin_function
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|<sys/vfs.h>
ifdef|#
directive|ifdef
name|QT_LINUXBASE
comment|// LSB 3.2 has fstatfs in sys/statfs.h, sys/vfs.h is just an empty dummy header
include|#
directive|include
file|<sys/statfs.h>
endif|#
directive|endif
name|QT_END_INCLUDE_NAMESPACE
ifndef|#
directive|ifndef
name|NFS_SUPER_MAGIC
DECL|macro|NFS_SUPER_MAGIC
define|#
directive|define
name|NFS_SUPER_MAGIC
value|0x00006969
endif|#
directive|endif
ifndef|#
directive|ifndef
name|AUTOFS_SUPER_MAGIC
DECL|macro|AUTOFS_SUPER_MAGIC
define|#
directive|define
name|AUTOFS_SUPER_MAGIC
value|0x00000187
endif|#
directive|endif
ifndef|#
directive|ifndef
name|AUTOFSNG_SUPER_MAGIC
DECL|macro|AUTOFSNG_SUPER_MAGIC
define|#
directive|define
name|AUTOFSNG_SUPER_MAGIC
value|0x7d92b1a0
endif|#
directive|endif
DECL|function|qIsLikelyToBeNfs
name|Q_AUTOTEST_EXPORT_HELPER
name|bool
name|qIsLikelyToBeNfs
parameter_list|(
name|int
name|handle
parameter_list|)
block|{
name|struct
name|statfs
name|buf
decl_stmt|;
if|if
condition|(
name|fstatfs
argument_list|(
name|handle
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
return|return
name|buf
operator|.
name|f_type
operator|==
name|NFS_SUPER_MAGIC
operator|||
name|buf
operator|.
name|f_type
operator|==
name|AUTOFS_SUPER_MAGIC
operator|||
name|buf
operator|.
name|f_type
operator|==
name|AUTOFSNG_SUPER_MAGIC
return|;
block|}
end_function
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_SOLARIS
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_IRIX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_AIX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|Q_OS_OSF
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_SCO
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|Q_OS_UNIXWARE
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_RELIANT
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_NETBSD
argument_list|)
end_elif
begin_function
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|<sys/statvfs.h>
name|QT_END_INCLUDE_NAMESPACE
DECL|function|qIsLikelyToBeNfs
name|Q_AUTOTEST_EXPORT_HELPER
name|bool
name|qIsLikelyToBeNfs
parameter_list|(
name|int
name|handle
parameter_list|)
block|{
name|struct
name|statvfs
name|buf
decl_stmt|;
if|if
condition|(
name|fstatvfs
argument_list|(
name|handle
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_NETBSD
argument_list|)
return|return
name|qt_isEvilFsTypeName
argument_list|(
name|buf
operator|.
name|f_fstypename
argument_list|)
return|;
else|#
directive|else
return|return
name|qt_isEvilFsTypeName
argument_list|(
name|buf
operator|.
name|f_basetype
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|qIsLikelyToBeNfs
name|Q_AUTOTEST_EXPORT_HELPER
specifier|inline
name|bool
name|qIsLikelyToBeNfs
parameter_list|(
name|int
comment|/* handle */
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|unixLock
specifier|static
name|bool
name|unixLock
parameter_list|(
name|int
name|handle
parameter_list|,
name|int
name|lockType
parameter_list|)
block|{
comment|/*         NFS hangs on the fcntl() call below when statd or lockd isn't         running. There's no way to detect this. Our work-around for         now is to disable locking when we detect NFS (or AutoFS or         CacheFS, which are probably wrapping NFS).     */
if|if
condition|(
name|qIsLikelyToBeNfs
argument_list|(
name|handle
argument_list|)
condition|)
return|return
literal|false
return|;
name|struct
name|flock
name|fl
decl_stmt|;
name|fl
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|fl
operator|.
name|l_start
operator|=
literal|0
expr_stmt|;
name|fl
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
name|fl
operator|.
name|l_type
operator|=
name|lockType
expr_stmt|;
return|return
name|fcntl
argument_list|(
name|handle
argument_list|,
name|F_SETLKW
argument_list|,
operator|&
name|fl
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|QConfFile
name|QConfFile
operator|::
name|QConfFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|bool
name|_userPerms
parameter_list|)
member_init_list|:
name|name
argument_list|(
name|fileName
argument_list|)
member_init_list|,
name|size
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|userPerms
argument_list|(
name|_userPerms
argument_list|)
block|{
name|usedHashFunc
argument_list|()
operator|->
name|insert
argument_list|(
name|name
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QConfFile
name|QConfFile
operator|::
name|~
name|QConfFile
parameter_list|()
block|{
if|if
condition|(
name|usedHashFunc
argument_list|()
condition|)
name|usedHashFunc
argument_list|()
operator|->
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|mergedKeyMap
name|ParsedSettingsMap
name|QConfFile
operator|::
name|mergedKeyMap
parameter_list|()
specifier|const
block|{
name|ParsedSettingsMap
name|result
init|=
name|originalKeys
decl_stmt|;
name|ParsedSettingsMap
operator|::
name|const_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|removedKeys
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|removedKeys
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
name|result
operator|.
name|remove
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|addedKeys
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|addedKeys
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
name|result
operator|.
name|insert
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|,
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|isWritable
name|bool
name|QConfFile
operator|::
name|isWritable
parameter_list|()
specifier|const
block|{
name|QFileInfo
name|fileInfo
argument_list|(
name|name
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEMPORARYFILE
if|if
condition|(
name|fileInfo
operator|.
name|exists
argument_list|()
condition|)
block|{
endif|#
directive|endif
name|QFile
name|file
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadWrite
argument_list|)
return|;
ifndef|#
directive|ifndef
name|QT_NO_TEMPORARYFILE
block|}
else|else
block|{
comment|// Create the directories to the file.
name|QDir
name|dir
argument_list|(
name|fileInfo
operator|.
name|absolutePath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dir
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|dir
operator|.
name|mkpath
argument_list|(
name|dir
operator|.
name|absolutePath
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
comment|// we use a temporary file to avoid race conditions
name|QTemporaryFile
name|file
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|file
operator|.
name|open
argument_list|()
return|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|fromName
name|QConfFile
modifier|*
name|QConfFile
operator|::
name|fromName
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|bool
name|_userPerms
parameter_list|)
block|{
name|QString
name|absPath
init|=
name|QFileInfo
argument_list|(
name|fileName
argument_list|)
operator|.
name|absoluteFilePath
argument_list|()
decl_stmt|;
name|ConfFileHash
modifier|*
name|usedHash
init|=
name|usedHashFunc
argument_list|()
decl_stmt|;
name|ConfFileCache
modifier|*
name|unusedCache
init|=
name|unusedCacheFunc
argument_list|()
decl_stmt|;
name|QConfFile
modifier|*
name|confFile
init|=
literal|0
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|settingsGlobalMutex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|confFile
operator|=
name|usedHash
operator|->
name|value
argument_list|(
name|absPath
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|confFile
operator|=
name|unusedCache
operator|->
name|take
argument_list|(
name|absPath
argument_list|)
operator|)
condition|)
name|usedHash
operator|->
name|insert
argument_list|(
name|absPath
argument_list|,
name|confFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|confFile
condition|)
block|{
name|confFile
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
return|return
name|confFile
return|;
block|}
return|return
operator|new
name|QConfFile
argument_list|(
name|absPath
argument_list|,
name|_userPerms
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|clearCache
name|void
name|QConfFile
operator|::
name|clearCache
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|settingsGlobalMutex
argument_list|)
decl_stmt|;
name|unusedCacheFunc
argument_list|()
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// ************************************************************************
end_comment
begin_comment
comment|// QSettingsPrivate
end_comment
begin_constructor
DECL|function|QSettingsPrivate
name|QSettingsPrivate
operator|::
name|QSettingsPrivate
parameter_list|(
name|QSettings
operator|::
name|Format
name|format
parameter_list|)
member_init_list|:
name|format
argument_list|(
name|format
argument_list|)
member_init_list|,
name|scope
argument_list|(
name|QSettings
operator|::
name|UserScope
comment|/* nothing better to put */
argument_list|)
member_init_list|,
name|iniCodec
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|spec
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|fallbacks
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|pendingChanges
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|status
argument_list|(
name|QSettings
operator|::
name|NoError
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QSettingsPrivate
name|QSettingsPrivate
operator|::
name|QSettingsPrivate
parameter_list|(
name|QSettings
operator|::
name|Format
name|format
parameter_list|,
name|QSettings
operator|::
name|Scope
name|scope
parameter_list|,
specifier|const
name|QString
modifier|&
name|organization
parameter_list|,
specifier|const
name|QString
modifier|&
name|application
parameter_list|)
member_init_list|:
name|format
argument_list|(
name|format
argument_list|)
member_init_list|,
name|scope
argument_list|(
name|scope
argument_list|)
member_init_list|,
name|organizationName
argument_list|(
name|organization
argument_list|)
member_init_list|,
name|applicationName
argument_list|(
name|application
argument_list|)
member_init_list|,
name|iniCodec
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|spec
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|fallbacks
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|pendingChanges
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|status
argument_list|(
name|QSettings
operator|::
name|NoError
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QSettingsPrivate
name|QSettingsPrivate
operator|::
name|~
name|QSettingsPrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|actualKey
name|QString
name|QSettingsPrivate
operator|::
name|actualKey
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
name|QString
name|n
init|=
name|normalizedKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
operator|!
name|n
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"QSettings"
argument_list|,
literal|"empty key"
argument_list|)
expr_stmt|;
name|n
operator|.
name|prepend
argument_list|(
name|groupPrefix
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*     Returns a string that never starts nor ends with a slash (or an     empty string). Examples:              "foo"            becomes   "foo"             "/foo//bar///"   becomes   "foo/bar"             "///"            becomes   ""      This function is optimized to avoid a QString deep copy in the     common case where the key is already normalized. */
end_comment
begin_function
DECL|function|normalizedKey
name|QString
name|QSettingsPrivate
operator|::
name|normalizedKey
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
name|QString
name|result
init|=
name|key
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|result
operator|.
name|size
argument_list|()
condition|)
block|{
while|while
condition|(
name|result
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
name|result
operator|.
name|remove
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|result
operator|.
name|size
argument_list|()
condition|)
goto|goto
name|after_loop
goto|;
block|}
while|while
condition|(
name|result
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|result
operator|.
name|size
argument_list|()
condition|)
return|return
name|result
return|;
block|}
operator|++
name|i
expr_stmt|;
comment|// leave the slash alone
block|}
name|after_loop
label|:
if|if
condition|(
operator|!
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|.
name|truncate
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// remove the trailing slash
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|// see also qsettings_win.cpp and qsettings_mac.cpp
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
end_if
begin_function
DECL|function|create
name|QSettingsPrivate
modifier|*
name|QSettingsPrivate
operator|::
name|create
parameter_list|(
name|QSettings
operator|::
name|Format
name|format
parameter_list|,
name|QSettings
operator|::
name|Scope
name|scope
parameter_list|,
specifier|const
name|QString
modifier|&
name|organization
parameter_list|,
specifier|const
name|QString
modifier|&
name|application
parameter_list|)
block|{
return|return
operator|new
name|QConfFileSettingsPrivate
argument_list|(
name|format
argument_list|,
name|scope
argument_list|,
name|organization
argument_list|,
name|application
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_function
DECL|function|create
name|QSettingsPrivate
modifier|*
name|QSettingsPrivate
operator|::
name|create
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QSettings
operator|::
name|Format
name|format
parameter_list|)
block|{
return|return
operator|new
name|QConfFileSettingsPrivate
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|processChild
name|void
name|QSettingsPrivate
operator|::
name|processChild
parameter_list|(
name|QString
name|key
parameter_list|,
name|ChildSpec
name|spec
parameter_list|,
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
modifier|&
name|result
parameter_list|)
block|{
if|if
condition|(
name|spec
operator|!=
name|AllKeys
condition|)
block|{
name|int
name|slashPos
init|=
name|key
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|slashPos
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|spec
operator|!=
name|ChildKeys
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
name|spec
operator|!=
name|ChildGroups
condition|)
return|return;
name|key
operator|.
name|truncate
argument_list|(
name|slashPos
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|beginGroupOrArray
name|void
name|QSettingsPrivate
operator|::
name|beginGroupOrArray
parameter_list|(
specifier|const
name|QSettingsGroup
modifier|&
name|group
parameter_list|)
block|{
name|groupStack
operator|.
name|push
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|group
operator|.
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|groupPrefix
operator|+=
name|group
operator|.
name|name
argument_list|()
expr_stmt|;
name|groupPrefix
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*     We only set an error if there isn't one set already. This way the user always gets the     first error that occurred. We always allow clearing errors. */
end_comment
begin_function
DECL|function|setStatus
name|void
name|QSettingsPrivate
operator|::
name|setStatus
parameter_list|(
name|QSettings
operator|::
name|Status
name|status
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|status
operator|==
name|QSettings
operator|::
name|NoError
operator|||
name|this
operator|->
name|status
operator|==
name|QSettings
operator|::
name|NoError
condition|)
name|this
operator|->
name|status
operator|=
name|status
expr_stmt|;
block|}
end_function
begin_function
DECL|function|update
name|void
name|QSettingsPrivate
operator|::
name|update
parameter_list|()
block|{
name|flush
argument_list|()
expr_stmt|;
name|pendingChanges
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|requestUpdate
name|void
name|QSettingsPrivate
operator|::
name|requestUpdate
parameter_list|()
block|{
if|if
condition|(
operator|!
name|pendingChanges
condition|)
block|{
name|pendingChanges
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|Q_Q
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|q
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|UpdateRequest
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|update
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_function
DECL|function|variantListToStringList
name|QStringList
name|QSettingsPrivate
operator|::
name|variantListToStringList
parameter_list|(
specifier|const
name|QVariantList
modifier|&
name|l
parameter_list|)
block|{
name|QStringList
name|result
decl_stmt|;
name|QVariantList
operator|::
name|const_iterator
name|it
init|=
name|l
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|l
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|result
operator|.
name|append
argument_list|(
name|variantToString
argument_list|(
operator|*
name|it
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|stringListToVariantList
name|QVariant
name|QSettingsPrivate
operator|::
name|stringListToVariantList
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|l
parameter_list|)
block|{
name|QStringList
name|outStringList
init|=
name|l
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|outStringList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
modifier|&
name|str
init|=
name|outStringList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|str
operator|.
name|length
argument_list|()
operator|>=
literal|2
operator|&&
name|str
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
condition|)
block|{
name|outStringList
index|[
name|i
index|]
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QVariantList
name|variantList
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|l
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
name|variantList
operator|.
name|append
argument_list|(
name|stringToVariant
argument_list|(
name|l
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|variantList
return|;
block|}
block|}
block|}
return|return
name|outStringList
return|;
block|}
end_function
begin_function
DECL|function|variantToString
name|QString
name|QSettingsPrivate
operator|::
name|variantToString
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|v
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
switch|switch
condition|(
name|v
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|QVariant
operator|::
name|Invalid
case|:
name|result
operator|=
name|QLatin1String
argument_list|(
literal|"@Invalid()"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|ByteArray
case|:
block|{
name|QByteArray
name|a
init|=
name|v
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|result
operator|=
name|QLatin1String
argument_list|(
literal|"@ByteArray("
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|a
operator|.
name|constData
argument_list|()
argument_list|,
name|a
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|String
case|:
case|case
name|QVariant
operator|::
name|LongLong
case|:
case|case
name|QVariant
operator|::
name|ULongLong
case|:
case|case
name|QVariant
operator|::
name|Int
case|:
case|case
name|QVariant
operator|::
name|UInt
case|:
case|case
name|QVariant
operator|::
name|Bool
case|:
case|case
name|QVariant
operator|::
name|Double
case|:
case|case
name|QVariant
operator|::
name|KeySequence
case|:
block|{
name|result
operator|=
name|v
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
argument_list|)
condition|)
name|result
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GEOM_VARIANT
case|case
name|QVariant
operator|::
name|Rect
case|:
block|{
name|QRect
name|r
init|=
name|qvariant_cast
argument_list|<
name|QRect
argument_list|>
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"@Rect("
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|r
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|r
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|r
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|Size
case|:
block|{
name|QSize
name|s
init|=
name|qvariant_cast
argument_list|<
name|QSize
argument_list|>
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"@Size("
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|s
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|s
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|Point
case|:
block|{
name|QPoint
name|p
init|=
name|qvariant_cast
argument_list|<
name|QPoint
argument_list|>
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|result
operator|+=
name|QLatin1String
argument_list|(
literal|"@Point("
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|// !QT_NO_GEOM_VARIANT
default|default:
block|{
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
name|QByteArray
name|a
decl_stmt|;
block|{
name|QDataStream
name|s
argument_list|(
operator|&
name|a
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|s
operator|.
name|setVersion
argument_list|(
name|QDataStream
operator|::
name|Qt_4_0
argument_list|)
expr_stmt|;
name|s
operator|<<
name|v
expr_stmt|;
block|}
name|result
operator|=
name|QLatin1String
argument_list|(
literal|"@Variant("
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|a
operator|.
name|constData
argument_list|()
argument_list|,
name|a
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_ASSERT
argument_list|(
operator|!
literal|"QSettings: Cannot save custom types without QDataStream support"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|stringToVariant
name|QVariant
name|QSettingsPrivate
operator|::
name|stringToVariant
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"@ByteArray("
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|QVariant
argument_list|(
name|s
operator|.
name|toLatin1
argument_list|()
operator|.
name|mid
argument_list|(
literal|11
argument_list|,
name|s
operator|.
name|size
argument_list|()
operator|-
literal|12
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"@Variant("
argument_list|)
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
name|QByteArray
name|a
argument_list|(
name|s
operator|.
name|toLatin1
argument_list|()
operator|.
name|mid
argument_list|(
literal|9
argument_list|)
argument_list|)
decl_stmt|;
name|QDataStream
name|stream
argument_list|(
operator|&
name|a
argument_list|,
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
decl_stmt|;
name|stream
operator|.
name|setVersion
argument_list|(
name|QDataStream
operator|::
name|Qt_4_0
argument_list|)
expr_stmt|;
name|QVariant
name|result
decl_stmt|;
name|stream
operator|>>
name|result
expr_stmt|;
return|return
name|result
return|;
else|#
directive|else
name|Q_ASSERT
argument_list|(
operator|!
literal|"QSettings: Cannot load custom types without QDataStream support"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_GEOM_VARIANT
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"@Rect("
argument_list|)
argument_list|)
condition|)
block|{
name|QStringList
name|args
init|=
name|QSettingsPrivate
operator|::
name|splitArgs
argument_list|(
name|s
argument_list|,
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|size
argument_list|()
operator|==
literal|4
condition|)
return|return
name|QVariant
argument_list|(
name|QRect
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|()
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|()
argument_list|,
name|args
index|[
literal|2
index|]
operator|.
name|toInt
argument_list|()
argument_list|,
name|args
index|[
literal|3
index|]
operator|.
name|toInt
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"@Size("
argument_list|)
argument_list|)
condition|)
block|{
name|QStringList
name|args
init|=
name|QSettingsPrivate
operator|::
name|splitArgs
argument_list|(
name|s
argument_list|,
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
return|return
name|QVariant
argument_list|(
name|QSize
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|()
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"@Point("
argument_list|)
argument_list|)
condition|)
block|{
name|QStringList
name|args
init|=
name|QSettingsPrivate
operator|::
name|splitArgs
argument_list|(
name|s
argument_list|,
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
return|return
name|QVariant
argument_list|(
name|QPoint
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|toInt
argument_list|()
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|toInt
argument_list|()
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|QLatin1String
argument_list|(
literal|"@Invalid()"
argument_list|)
condition|)
block|{
return|return
name|QVariant
argument_list|()
return|;
block|}
block|}
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"@@"
argument_list|)
argument_list|)
condition|)
return|return
name|QVariant
argument_list|(
name|s
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
return|return
name|QVariant
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|hexDigits
specifier|static
specifier|const
name|char
name|hexDigits
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|iniEscapedKey
name|void
name|QSettingsPrivate
operator|::
name|iniEscapedKey
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
name|QByteArray
modifier|&
name|result
parameter_list|)
block|{
name|result
operator|.
name|reserve
argument_list|(
name|result
operator|.
name|length
argument_list|()
operator|+
name|key
operator|.
name|length
argument_list|()
operator|*
literal|3
operator|/
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|uint
name|ch
init|=
name|key
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
block|{
name|result
operator|+=
literal|'\\'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
name|ch
operator|==
literal|'_'
operator|||
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'.'
condition|)
block|{
name|result
operator|+=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<=
literal|0xFF
condition|)
block|{
name|result
operator|+=
literal|'%'
expr_stmt|;
name|result
operator|+=
name|hexDigits
index|[
name|ch
operator|/
literal|16
index|]
expr_stmt|;
name|result
operator|+=
name|hexDigits
index|[
name|ch
operator|%
literal|16
index|]
expr_stmt|;
block|}
else|else
block|{
name|result
operator|+=
literal|"%U"
expr_stmt|;
name|QByteArray
name|hexCode
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|hexCode
operator|.
name|prepend
argument_list|(
name|hexDigits
index|[
name|ch
operator|%
literal|16
index|]
argument_list|)
expr_stmt|;
name|ch
operator|>>=
literal|4
expr_stmt|;
block|}
name|result
operator|+=
name|hexCode
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|iniUnescapedKey
name|bool
name|QSettingsPrivate
operator|::
name|iniUnescapedKey
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|key
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|QString
modifier|&
name|result
parameter_list|)
block|{
name|bool
name|lowercaseOnly
init|=
literal|true
decl_stmt|;
name|int
name|i
init|=
name|from
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|result
operator|.
name|length
argument_list|()
operator|+
operator|(
name|to
operator|-
name|from
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|to
condition|)
block|{
name|int
name|ch
init|=
operator|(
name|uchar
operator|)
name|key
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ch
operator|!=
literal|'%'
operator|||
name|i
operator|==
name|to
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|uint
argument_list|(
name|ch
operator|-
literal|'A'
argument_list|)
operator|<=
literal|'Z'
operator|-
literal|'A'
condition|)
comment|// only for ASCII
name|lowercaseOnly
operator|=
literal|false
expr_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
name|ch
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
name|int
name|numDigits
init|=
literal|2
decl_stmt|;
name|int
name|firstDigitPos
init|=
name|i
operator|+
literal|1
decl_stmt|;
name|ch
operator|=
name|key
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'U'
condition|)
block|{
operator|++
name|firstDigitPos
expr_stmt|;
name|numDigits
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|firstDigitPos
operator|+
name|numDigits
operator|>
name|to
condition|)
block|{
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
comment|// ### missing U
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
name|bool
name|ok
decl_stmt|;
name|ch
operator|=
name|key
operator|.
name|mid
argument_list|(
name|firstDigitPos
argument_list|,
name|numDigits
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
comment|// ### missing U
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
name|QChar
name|qch
argument_list|(
name|ch
argument_list|)
decl_stmt|;
if|if
condition|(
name|qch
operator|.
name|isUpper
argument_list|()
condition|)
name|lowercaseOnly
operator|=
literal|false
expr_stmt|;
name|result
operator|+=
name|qch
expr_stmt|;
name|i
operator|=
name|firstDigitPos
operator|+
name|numDigits
expr_stmt|;
block|}
return|return
name|lowercaseOnly
return|;
block|}
end_function
begin_function
DECL|function|iniEscapedString
name|void
name|QSettingsPrivate
operator|::
name|iniEscapedString
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|QByteArray
modifier|&
name|result
parameter_list|,
name|QTextCodec
modifier|*
name|codec
parameter_list|)
block|{
name|bool
name|needsQuotes
init|=
literal|false
decl_stmt|;
name|bool
name|escapeNextIfDigit
init|=
literal|false
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|startPos
init|=
name|result
operator|.
name|size
argument_list|()
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|startPos
operator|+
name|str
operator|.
name|size
argument_list|()
operator|*
literal|3
operator|/
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|str
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|uint
name|ch
init|=
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|';'
operator|||
name|ch
operator|==
literal|','
operator|||
name|ch
operator|==
literal|'='
condition|)
name|needsQuotes
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|escapeNextIfDigit
operator|&&
operator|(
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
operator|)
operator|)
condition|)
block|{
name|result
operator|+=
literal|"\\x"
expr_stmt|;
name|result
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|ch
argument_list|,
literal|16
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|escapeNextIfDigit
operator|=
literal|false
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\0'
case|:
name|result
operator|+=
literal|"\\0"
expr_stmt|;
name|escapeNextIfDigit
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|'\a'
case|:
name|result
operator|+=
literal|"\\a"
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|result
operator|+=
literal|"\\b"
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|result
operator|+=
literal|"\\f"
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|result
operator|+=
literal|"\\n"
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|result
operator|+=
literal|"\\r"
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|result
operator|+=
literal|"\\t"
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|result
operator|+=
literal|"\\v"
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
name|result
operator|+=
literal|'\\'
expr_stmt|;
name|result
operator|+=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ch
operator|<=
literal|0x1F
operator|||
operator|(
name|ch
operator|>=
literal|0x7F
operator|&&
operator|!
name|codec
operator|)
condition|)
block|{
name|result
operator|+=
literal|"\\x"
expr_stmt|;
name|result
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|ch
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|escapeNextIfDigit
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
block|}
elseif|else
if|if
condition|(
name|codec
condition|)
block|{
comment|// slow
name|result
operator|+=
name|codec
operator|->
name|fromUnicode
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|result
operator|+=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|needsQuotes
operator|||
operator|(
name|startPos
operator|<
name|result
operator|.
name|size
argument_list|()
operator|&&
operator|(
name|result
operator|.
name|at
argument_list|(
name|startPos
argument_list|)
operator|==
literal|' '
operator|||
name|result
operator|.
name|at
argument_list|(
name|result
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|' '
operator|)
operator|)
condition|)
block|{
name|result
operator|.
name|insert
argument_list|(
name|startPos
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|result
operator|+=
literal|'"'
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|iniChopTrailingSpaces
specifier|inline
specifier|static
name|void
name|iniChopTrailingSpaces
parameter_list|(
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|int
name|n
init|=
name|str
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
name|QChar
name|ch
decl_stmt|;
while|while
condition|(
name|n
operator|>=
literal|0
operator|&&
operator|(
operator|(
name|ch
operator|=
name|str
operator|.
name|at
argument_list|(
name|n
argument_list|)
operator|)
operator|==
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'\t'
argument_list|)
operator|)
condition|)
name|str
operator|.
name|truncate
argument_list|(
name|n
operator|--
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|iniEscapedStringList
name|void
name|QSettingsPrivate
operator|::
name|iniEscapedStringList
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|strs
parameter_list|,
name|QByteArray
modifier|&
name|result
parameter_list|,
name|QTextCodec
modifier|*
name|codec
parameter_list|)
block|{
if|if
condition|(
name|strs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|/*             We need to distinguish between empty lists and one-item             lists that contain an empty string. Ideally, we'd have a             @EmptyList() symbol but that would break compatibility             with Qt 4.0. @Invalid() stands for QVariant(), and             QVariant().toStringList() returns an empty QStringList,             so we're in good shape.         */
name|result
operator|+=
literal|"@Invalid()"
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|result
operator|+=
literal|", "
expr_stmt|;
name|iniEscapedString
argument_list|(
name|strs
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|result
argument_list|,
name|codec
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|iniUnescapedStringList
name|bool
name|QSettingsPrivate
operator|::
name|iniUnescapedStringList
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|str
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|QString
modifier|&
name|stringResult
parameter_list|,
name|QStringList
modifier|&
name|stringListResult
parameter_list|,
name|QTextCodec
modifier|*
name|codec
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|escapeCodes
index|[]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|'a'
block|,
literal|'\a'
block|}
block|,
block|{
literal|'b'
block|,
literal|'\b'
block|}
block|,
block|{
literal|'f'
block|,
literal|'\f'
block|}
block|,
block|{
literal|'n'
block|,
literal|'\n'
block|}
block|,
block|{
literal|'r'
block|,
literal|'\r'
block|}
block|,
block|{
literal|'t'
block|,
literal|'\t'
block|}
block|,
block|{
literal|'v'
block|,
literal|'\v'
block|}
block|,
block|{
literal|'"'
block|,
literal|'"'
block|}
block|,
block|{
literal|'?'
block|,
literal|'?'
block|}
block|,
block|{
literal|'\''
block|,
literal|'\''
block|}
block|,
block|{
literal|'\\'
block|,
literal|'\\'
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|numEscapeCodes
init|=
sizeof|sizeof
argument_list|(
name|escapeCodes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|escapeCodes
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bool
name|isStringList
init|=
literal|false
decl_stmt|;
name|bool
name|inQuotedString
init|=
literal|false
decl_stmt|;
name|bool
name|currentValueIsQuoted
init|=
literal|false
decl_stmt|;
name|int
name|escapeVal
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
name|from
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|StSkipSpaces
label|:
while|while
condition|(
name|i
operator|<
name|to
operator|&&
operator|(
operator|(
name|ch
operator|=
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|ch
operator|==
literal|'\t'
operator|)
condition|)
operator|++
name|i
expr_stmt|;
comment|// fallthrough
name|StNormal
label|:
while|while
condition|(
name|i
operator|<
name|to
condition|)
block|{
switch|switch
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
literal|'\\'
case|:
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|to
condition|)
goto|goto
name|end
goto|;
name|ch
operator|=
name|str
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numEscapeCodes
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|ch
operator|==
name|escapeCodes
index|[
name|j
index|]
index|[
literal|0
index|]
condition|)
block|{
name|stringResult
operator|+=
name|QLatin1Char
argument_list|(
name|escapeCodes
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|StNormal
goto|;
block|}
block|}
if|if
condition|(
name|ch
operator|==
literal|'x'
condition|)
block|{
name|escapeVal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|to
condition|)
goto|goto
name|end
goto|;
name|ch
operator|=
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
operator|)
condition|)
goto|goto
name|StHexEscape
goto|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'7'
condition|)
block|{
name|escapeVal
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
goto|goto
name|StOctEscape
goto|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|to
condition|)
block|{
name|char
name|ch2
init|=
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// \n, \r, \r\n, and \n\r are legitimate line terminators in INI files
if|if
condition|(
operator|(
name|ch2
operator|==
literal|'\n'
operator|||
name|ch2
operator|==
literal|'\r'
operator|)
operator|&&
name|ch2
operator|!=
name|ch
condition|)
operator|++
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// the character is skipped
block|}
break|break;
case|case
literal|'"'
case|:
operator|++
name|i
expr_stmt|;
name|currentValueIsQuoted
operator|=
literal|true
expr_stmt|;
name|inQuotedString
operator|=
operator|!
name|inQuotedString
expr_stmt|;
if|if
condition|(
operator|!
name|inQuotedString
condition|)
goto|goto
name|StSkipSpaces
goto|;
break|break;
case|case
literal|','
case|:
if|if
condition|(
operator|!
name|inQuotedString
condition|)
block|{
if|if
condition|(
operator|!
name|currentValueIsQuoted
condition|)
name|iniChopTrailingSpaces
argument_list|(
name|stringResult
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isStringList
condition|)
block|{
name|isStringList
operator|=
literal|true
expr_stmt|;
name|stringListResult
operator|.
name|clear
argument_list|()
expr_stmt|;
name|stringResult
operator|.
name|squeeze
argument_list|()
expr_stmt|;
block|}
name|stringListResult
operator|.
name|append
argument_list|(
name|stringResult
argument_list|)
expr_stmt|;
name|stringResult
operator|.
name|clear
argument_list|()
expr_stmt|;
name|currentValueIsQuoted
operator|=
literal|false
expr_stmt|;
operator|++
name|i
expr_stmt|;
goto|goto
name|StSkipSpaces
goto|;
block|}
comment|// fallthrough
default|default:
block|{
name|int
name|j
init|=
name|i
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|j
operator|<
name|to
condition|)
block|{
name|ch
operator|=
name|str
operator|.
name|at
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
operator|||
name|ch
operator|==
literal|'"'
operator|||
name|ch
operator|==
literal|','
condition|)
break|break;
operator|++
name|j
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
if|if
condition|(
name|codec
condition|)
block|{
name|stringResult
operator|+=
name|codec
operator|->
name|toUnicode
argument_list|(
name|str
operator|.
name|constData
argument_list|()
operator|+
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|int
name|n
init|=
name|stringResult
operator|.
name|size
argument_list|()
decl_stmt|;
name|stringResult
operator|.
name|resize
argument_list|(
name|n
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
name|QChar
modifier|*
name|resultData
init|=
name|stringResult
operator|.
name|data
argument_list|()
operator|+
name|n
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
name|i
init|;
name|k
operator|<
name|j
condition|;
operator|++
name|k
control|)
operator|*
name|resultData
operator|++
operator|=
name|QLatin1Char
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|j
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|end
goto|;
name|StHexEscape
label|:
if|if
condition|(
name|i
operator|>=
name|to
condition|)
block|{
name|stringResult
operator|+=
name|QChar
argument_list|(
name|escapeVal
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|ch
operator|=
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'a'
condition|)
name|ch
operator|-=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
operator|)
condition|)
block|{
name|escapeVal
operator|<<=
literal|4
expr_stmt|;
name|escapeVal
operator|+=
name|strchr
argument_list|(
name|hexDigits
argument_list|,
name|ch
argument_list|)
operator|-
name|hexDigits
expr_stmt|;
operator|++
name|i
expr_stmt|;
goto|goto
name|StHexEscape
goto|;
block|}
else|else
block|{
name|stringResult
operator|+=
name|QChar
argument_list|(
name|escapeVal
argument_list|)
expr_stmt|;
goto|goto
name|StNormal
goto|;
block|}
name|StOctEscape
label|:
if|if
condition|(
name|i
operator|>=
name|to
condition|)
block|{
name|stringResult
operator|+=
name|QChar
argument_list|(
name|escapeVal
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|ch
operator|=
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'7'
condition|)
block|{
name|escapeVal
operator|<<=
literal|3
expr_stmt|;
name|escapeVal
operator|+=
name|ch
operator|-
literal|'0'
expr_stmt|;
operator|++
name|i
expr_stmt|;
goto|goto
name|StOctEscape
goto|;
block|}
else|else
block|{
name|stringResult
operator|+=
name|QChar
argument_list|(
name|escapeVal
argument_list|)
expr_stmt|;
goto|goto
name|StNormal
goto|;
block|}
name|end
label|:
if|if
condition|(
operator|!
name|currentValueIsQuoted
condition|)
name|iniChopTrailingSpaces
argument_list|(
name|stringResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|isStringList
condition|)
name|stringListResult
operator|.
name|append
argument_list|(
name|stringResult
argument_list|)
expr_stmt|;
return|return
name|isStringList
return|;
block|}
end_function
begin_function
DECL|function|splitArgs
name|QStringList
name|QSettingsPrivate
operator|::
name|splitArgs
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|l
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|l
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|s
operator|.
name|at
argument_list|(
name|idx
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'('
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|s
operator|.
name|at
argument_list|(
name|l
operator|-
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
argument_list|)
expr_stmt|;
name|QStringList
name|result
decl_stmt|;
name|QString
name|item
decl_stmt|;
for|for
control|(
operator|++
name|idx
init|;
name|idx
operator|<
name|l
condition|;
operator|++
name|idx
control|)
block|{
name|QChar
name|c
init|=
name|s
operator|.
name|at
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|idx
operator|==
name|l
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|item
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|// ************************************************************************
end_comment
begin_comment
comment|// QConfFileSettingsPrivate
end_comment
begin_function
DECL|function|initFormat
name|void
name|QConfFileSettingsPrivate
operator|::
name|initFormat
parameter_list|()
block|{
name|extension
operator|=
operator|(
name|format
operator|==
name|QSettings
operator|::
name|NativeFormat
operator|)
condition|?
name|QLatin1String
argument_list|(
literal|".conf"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|".ini"
argument_list|)
expr_stmt|;
name|readFunc
operator|=
literal|0
expr_stmt|;
name|writeFunc
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
name|caseSensitivity
operator|=
operator|(
name|format
operator|==
name|QSettings
operator|::
name|NativeFormat
operator|)
condition|?
name|Qt
operator|::
name|CaseSensitive
else|:
name|IniCaseSensitivity
expr_stmt|;
else|#
directive|else
name|caseSensitivity
operator|=
name|IniCaseSensitivity
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|format
operator|>
name|QSettings
operator|::
name|IniFormat
condition|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|settingsGlobalMutex
argument_list|)
decl_stmt|;
specifier|const
name|CustomFormatVector
modifier|*
name|customFormatVector
init|=
name|customFormatVectorFunc
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|(
name|int
operator|)
name|format
operator|-
operator|(
name|int
operator|)
name|QSettings
operator|::
name|CustomFormat1
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|customFormatVector
operator|->
name|size
argument_list|()
condition|)
block|{
name|QConfFileCustomFormat
name|info
init|=
name|customFormatVector
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|extension
operator|=
name|info
operator|.
name|extension
expr_stmt|;
name|readFunc
operator|=
name|info
operator|.
name|readFunc
expr_stmt|;
name|writeFunc
operator|=
name|info
operator|.
name|writeFunc
expr_stmt|;
name|caseSensitivity
operator|=
name|info
operator|.
name|caseSensitivity
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|initAccess
name|void
name|QConfFileSettingsPrivate
operator|::
name|initAccess
parameter_list|()
block|{
if|if
condition|(
name|confFiles
index|[
name|spec
index|]
condition|)
block|{
if|if
condition|(
name|format
operator|>
name|QSettings
operator|::
name|IniFormat
condition|)
block|{
if|if
condition|(
operator|!
name|readFunc
condition|)
name|setStatus
argument_list|(
name|QSettings
operator|::
name|AccessError
argument_list|)
expr_stmt|;
block|}
block|}
name|sync
argument_list|()
expr_stmt|;
comment|// loads the files the first time
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_function
DECL|function|windowsConfigPath
specifier|static
name|QString
name|windowsConfigPath
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_WINCE
name|QSystemLibrary
name|library
argument_list|(
name|QLatin1String
argument_list|(
literal|"shell32"
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|QSystemLibrary
name|library
argument_list|(
name|QLatin1String
argument_list|(
literal|"coredll"
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|// Q_OS_WINCE
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|GetSpecialFolderPath
function_decl|)
parameter_list|(
name|HWND
parameter_list|,
name|LPWSTR
parameter_list|,
name|int
parameter_list|,
name|BOOL
parameter_list|)
function_decl|;
name|GetSpecialFolderPath
name|SHGetSpecialFolderPath
init|=
operator|(
name|GetSpecialFolderPath
operator|)
name|library
operator|.
name|resolve
argument_list|(
literal|"SHGetSpecialFolderPathW"
argument_list|)
decl_stmt|;
if|if
condition|(
name|SHGetSpecialFolderPath
condition|)
block|{
name|wchar_t
name|path
index|[
name|MAX_PATH
index|]
decl_stmt|;
name|SHGetSpecialFolderPath
argument_list|(
literal|0
argument_list|,
name|path
argument_list|,
name|type
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|result
operator|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
ifndef|#
directive|ifndef
name|Q_OS_WINCE
case|case
name|CSIDL_COMMON_APPDATA
case|:
name|result
operator|=
name|QLatin1String
argument_list|(
literal|"C:\\temp\\qt-common"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CSIDL_APPDATA
case|:
name|result
operator|=
name|QLatin1String
argument_list|(
literal|"C:\\temp\\qt-user"
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
case|case
name|CSIDL_COMMON_APPDATA
case|:
name|result
operator|=
name|QLatin1String
argument_list|(
literal|"\\Temp\\qt-common"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CSIDL_APPDATA
case|:
name|result
operator|=
name|QLatin1String
argument_list|(
literal|"\\Temp\\qt-user"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
empty_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_OS_WIN
end_comment
begin_function
DECL|function|pathHashKey
specifier|static
specifier|inline
name|int
name|pathHashKey
parameter_list|(
name|QSettings
operator|::
name|Format
name|format
parameter_list|,
name|QSettings
operator|::
name|Scope
name|scope
parameter_list|)
block|{
return|return
name|int
argument_list|(
operator|(
name|uint
argument_list|(
name|format
argument_list|)
operator|<<
literal|1
operator|)
operator||
name|uint
argument_list|(
name|scope
operator|==
name|QSettings
operator|::
name|SystemScope
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|initDefaultPaths
specifier|static
name|void
name|initDefaultPaths
parameter_list|(
name|QMutexLocker
modifier|*
name|locker
parameter_list|)
block|{
name|PathHash
modifier|*
name|pathHash
init|=
name|pathHashFunc
argument_list|()
decl_stmt|;
name|QString
name|homePath
init|=
name|QDir
operator|::
name|homePath
argument_list|()
decl_stmt|;
name|QString
name|systemPath
decl_stmt|;
name|locker
operator|->
name|unlock
argument_list|()
expr_stmt|;
comment|/*        QLibraryInfo::location() uses QSettings, so in order to        avoid a dead-lock, we can't hold the global mutex while        calling it.     */
name|systemPath
operator|=
name|QLibraryInfo
operator|::
name|location
argument_list|(
name|QLibraryInfo
operator|::
name|SettingsPath
argument_list|)
expr_stmt|;
name|systemPath
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|locker
operator|->
name|relock
argument_list|()
expr_stmt|;
if|if
condition|(
name|pathHash
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
comment|/*            Lazy initialization of pathHash. We initialize the            IniFormat paths and (on Unix) the NativeFormat paths.            (The NativeFormat paths are not configurable for the            Windows registry and the Mac CFPreferences.)        */
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|pathHash
operator|->
name|insert
argument_list|(
name|pathHashKey
argument_list|(
name|QSettings
operator|::
name|IniFormat
argument_list|,
name|QSettings
operator|::
name|UserScope
argument_list|)
argument_list|,
name|windowsConfigPath
argument_list|(
name|CSIDL_APPDATA
argument_list|)
operator|+
name|QDir
operator|::
name|separator
argument_list|()
argument_list|)
expr_stmt|;
name|pathHash
operator|->
name|insert
argument_list|(
name|pathHashKey
argument_list|(
name|QSettings
operator|::
name|IniFormat
argument_list|,
name|QSettings
operator|::
name|SystemScope
argument_list|)
argument_list|,
name|windowsConfigPath
argument_list|(
name|CSIDL_COMMON_APPDATA
argument_list|)
operator|+
name|QDir
operator|::
name|separator
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|QString
name|userPath
decl_stmt|;
name|char
modifier|*
name|env
init|=
name|getenv
argument_list|(
literal|"XDG_CONFIG_HOME"
argument_list|)
decl_stmt|;
if|if
condition|(
name|env
operator|==
literal|0
condition|)
block|{
name|userPath
operator|=
name|homePath
expr_stmt|;
name|userPath
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|userPath
operator|+=
name|QLatin1String
argument_list|(
literal|".config"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|env
operator|==
literal|'/'
condition|)
block|{
name|userPath
operator|=
name|QFile
operator|::
name|decodeName
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|userPath
operator|=
name|homePath
expr_stmt|;
name|userPath
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|userPath
operator|+=
name|QFile
operator|::
name|decodeName
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
name|userPath
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|pathHash
operator|->
name|insert
argument_list|(
name|pathHashKey
argument_list|(
name|QSettings
operator|::
name|IniFormat
argument_list|,
name|QSettings
operator|::
name|UserScope
argument_list|)
argument_list|,
name|userPath
argument_list|)
expr_stmt|;
name|pathHash
operator|->
name|insert
argument_list|(
name|pathHashKey
argument_list|(
name|QSettings
operator|::
name|IniFormat
argument_list|,
name|QSettings
operator|::
name|SystemScope
argument_list|)
argument_list|,
name|systemPath
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_MAC
name|pathHash
operator|->
name|insert
argument_list|(
name|pathHashKey
argument_list|(
name|QSettings
operator|::
name|NativeFormat
argument_list|,
name|QSettings
operator|::
name|UserScope
argument_list|)
argument_list|,
name|userPath
argument_list|)
expr_stmt|;
name|pathHash
operator|->
name|insert
argument_list|(
name|pathHashKey
argument_list|(
name|QSettings
operator|::
name|NativeFormat
argument_list|,
name|QSettings
operator|::
name|SystemScope
argument_list|)
argument_list|,
name|systemPath
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
end_function
begin_function
DECL|function|getPath
specifier|static
name|QString
name|getPath
parameter_list|(
name|QSettings
operator|::
name|Format
name|format
parameter_list|,
name|QSettings
operator|::
name|Scope
name|scope
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|(
name|int
operator|)
name|QSettings
operator|::
name|NativeFormat
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|(
name|int
operator|)
name|QSettings
operator|::
name|IniFormat
operator|==
literal|1
argument_list|)
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|settingsGlobalMutex
argument_list|)
decl_stmt|;
name|PathHash
modifier|*
name|pathHash
init|=
name|pathHashFunc
argument_list|()
decl_stmt|;
if|if
condition|(
name|pathHash
operator|->
name|isEmpty
argument_list|()
condition|)
name|initDefaultPaths
argument_list|(
operator|&
name|locker
argument_list|)
expr_stmt|;
name|QString
name|result
init|=
name|pathHash
operator|->
name|value
argument_list|(
name|pathHashKey
argument_list|(
name|format
argument_list|,
name|scope
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|result
return|;
comment|// fall back on INI path
return|return
name|pathHash
operator|->
name|value
argument_list|(
name|pathHashKey
argument_list|(
name|QSettings
operator|::
name|IniFormat
argument_list|,
name|scope
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_constructor
DECL|function|QConfFileSettingsPrivate
name|QConfFileSettingsPrivate
operator|::
name|QConfFileSettingsPrivate
parameter_list|(
name|QSettings
operator|::
name|Format
name|format
parameter_list|,
name|QSettings
operator|::
name|Scope
name|scope
parameter_list|,
specifier|const
name|QString
modifier|&
name|organization
parameter_list|,
specifier|const
name|QString
modifier|&
name|application
parameter_list|)
member_init_list|:
name|QSettingsPrivate
argument_list|(
name|format
argument_list|,
name|scope
argument_list|,
name|organization
argument_list|,
name|application
argument_list|)
member_init_list|,
name|nextPosition
argument_list|(
literal|0x40000000
argument_list|)
comment|// big positive number
block|{
name|int
name|i
decl_stmt|;
name|initFormat
argument_list|()
expr_stmt|;
name|QString
name|org
init|=
name|organization
decl_stmt|;
if|if
condition|(
name|org
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|setStatus
argument_list|(
name|QSettings
operator|::
name|AccessError
argument_list|)
expr_stmt|;
name|org
operator|=
name|QLatin1String
argument_list|(
literal|"Unknown Organization"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
name|QString
name|appFile
init|=
name|org
operator|+
name|QDir
operator|::
name|separator
argument_list|()
operator|+
name|application
operator|+
name|extension
decl_stmt|;
name|QString
name|orgFile
init|=
name|org
operator|+
name|extension
decl_stmt|;
if|if
condition|(
name|scope
operator|==
name|QSettings
operator|::
name|UserScope
condition|)
block|{
name|QString
name|userPath
init|=
name|getPath
argument_list|(
name|format
argument_list|,
name|QSettings
operator|::
name|UserScope
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|application
operator|.
name|isEmpty
argument_list|()
condition|)
name|confFiles
index|[
name|F_User
operator||
name|F_Application
index|]
operator|.
name|reset
argument_list|(
name|QConfFile
operator|::
name|fromName
argument_list|(
name|userPath
operator|+
name|appFile
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|confFiles
index|[
name|F_User
operator||
name|F_Organization
index|]
operator|.
name|reset
argument_list|(
name|QConfFile
operator|::
name|fromName
argument_list|(
name|userPath
operator|+
name|orgFile
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QString
name|systemPath
init|=
name|getPath
argument_list|(
name|format
argument_list|,
name|QSettings
operator|::
name|SystemScope
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|application
operator|.
name|isEmpty
argument_list|()
condition|)
name|confFiles
index|[
name|F_System
operator||
name|F_Application
index|]
operator|.
name|reset
argument_list|(
name|QConfFile
operator|::
name|fromName
argument_list|(
name|systemPath
operator|+
name|appFile
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|confFiles
index|[
name|F_System
operator||
name|F_Organization
index|]
operator|.
name|reset
argument_list|(
name|QConfFile
operator|::
name|fromName
argument_list|(
name|systemPath
operator|+
name|orgFile
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|QString
name|confName
init|=
name|getPath
argument_list|(
name|format
argument_list|,
name|QSettings
operator|::
name|UserScope
argument_list|)
operator|+
name|org
decl_stmt|;
if|if
condition|(
operator|!
name|application
operator|.
name|isEmpty
argument_list|()
condition|)
name|confName
operator|+=
name|QDir
operator|::
name|separator
argument_list|()
operator|+
name|application
expr_stmt|;
name|confName
operator|+=
name|extension
expr_stmt|;
name|confFiles
index|[
name|SandboxConfFile
index|]
operator|.
name|reset
argument_list|(
name|QConfFile
operator|::
name|fromName
argument_list|(
name|confName
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumConfFiles
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|confFiles
index|[
name|i
index|]
condition|)
block|{
name|spec
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|initAccess
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QConfFileSettingsPrivate
name|QConfFileSettingsPrivate
operator|::
name|QConfFileSettingsPrivate
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QSettings
operator|::
name|Format
name|format
parameter_list|)
member_init_list|:
name|QSettingsPrivate
argument_list|(
name|format
argument_list|)
member_init_list|,
name|nextPosition
argument_list|(
literal|0x40000000
argument_list|)
comment|// big positive number
block|{
name|initFormat
argument_list|()
expr_stmt|;
name|confFiles
index|[
literal|0
index|]
operator|.
name|reset
argument_list|(
name|QConfFile
operator|::
name|fromName
argument_list|(
name|fileName
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|initAccess
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QConfFileSettingsPrivate
name|QConfFileSettingsPrivate
operator|::
name|~
name|QConfFileSettingsPrivate
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|settingsGlobalMutex
argument_list|)
decl_stmt|;
name|ConfFileHash
modifier|*
name|usedHash
init|=
name|usedHashFunc
argument_list|()
decl_stmt|;
name|ConfFileCache
modifier|*
name|unusedCache
init|=
name|unusedCacheFunc
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumConfFiles
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|confFiles
index|[
name|i
index|]
operator|&&
operator|!
name|confFiles
index|[
name|i
index|]
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
block|{
if|if
condition|(
name|confFiles
index|[
name|i
index|]
operator|->
name|size
operator|==
literal|0
condition|)
block|{
operator|delete
name|confFiles
index|[
name|i
index|]
operator|.
name|take
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|usedHash
condition|)
name|usedHash
operator|->
name|remove
argument_list|(
name|confFiles
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unusedCache
condition|)
block|{
name|QT_TRY
block|{
comment|// compute a better size?
name|unusedCache
operator|->
name|insert
argument_list|(
name|confFiles
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|confFiles
index|[
name|i
index|]
operator|.
name|data
argument_list|()
argument_list|,
literal|10
operator|+
operator|(
name|confFiles
index|[
name|i
index|]
operator|->
name|originalKeys
operator|.
name|size
argument_list|()
operator|/
literal|4
operator|)
argument_list|)
expr_stmt|;
name|confFiles
index|[
name|i
index|]
operator|.
name|take
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
comment|// out of memory. Do not cache the file.
operator|delete
name|confFiles
index|[
name|i
index|]
operator|.
name|take
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// unusedCache is gone - delete the entry to prevent a memory leak
operator|delete
name|confFiles
index|[
name|i
index|]
operator|.
name|take
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// prevent the ScopedPointer to deref it again.
name|confFiles
index|[
name|i
index|]
operator|.
name|take
argument_list|()
expr_stmt|;
block|}
block|}
end_destructor
begin_function
DECL|function|remove
name|void
name|QConfFileSettingsPrivate
operator|::
name|remove
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
name|QConfFile
modifier|*
name|confFile
init|=
name|confFiles
index|[
name|spec
index|]
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|confFile
condition|)
return|return;
name|QSettingsKey
name|theKey
argument_list|(
name|key
argument_list|,
name|caseSensitivity
argument_list|)
decl_stmt|;
name|QSettingsKey
name|prefix
argument_list|(
name|key
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|caseSensitivity
argument_list|)
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|confFile
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|ensureSectionParsed
argument_list|(
name|confFile
argument_list|,
name|theKey
argument_list|)
expr_stmt|;
name|ensureSectionParsed
argument_list|(
name|confFile
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|ParsedSettingsMap
operator|::
name|iterator
name|i
init|=
name|confFile
operator|->
name|addedKeys
operator|.
name|lowerBound
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|confFile
operator|->
name|addedKeys
operator|.
name|end
argument_list|()
operator|&&
name|i
operator|.
name|key
argument_list|()
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
name|i
operator|=
name|confFile
operator|->
name|addedKeys
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|confFile
operator|->
name|addedKeys
operator|.
name|remove
argument_list|(
name|theKey
argument_list|)
expr_stmt|;
name|ParsedSettingsMap
operator|::
name|const_iterator
name|j
init|=
cast|const_cast
argument_list|<
specifier|const
name|ParsedSettingsMap
operator|*
argument_list|>
argument_list|(
operator|&
name|confFile
operator|->
name|originalKeys
argument_list|)
operator|->
name|lowerBound
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
while|while
condition|(
name|j
operator|!=
name|confFile
operator|->
name|originalKeys
operator|.
name|constEnd
argument_list|()
operator|&&
name|j
operator|.
name|key
argument_list|()
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
name|confFile
operator|->
name|removedKeys
operator|.
name|insert
argument_list|(
name|j
operator|.
name|key
argument_list|()
argument_list|,
name|QVariant
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
if|if
condition|(
name|confFile
operator|->
name|originalKeys
operator|.
name|contains
argument_list|(
name|theKey
argument_list|)
condition|)
name|confFile
operator|->
name|removedKeys
operator|.
name|insert
argument_list|(
name|theKey
argument_list|,
name|QVariant
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|set
name|void
name|QConfFileSettingsPrivate
operator|::
name|set
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|QConfFile
modifier|*
name|confFile
init|=
name|confFiles
index|[
name|spec
index|]
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|confFile
condition|)
return|return;
name|QSettingsKey
name|theKey
argument_list|(
name|key
argument_list|,
name|caseSensitivity
argument_list|,
name|nextPosition
operator|++
argument_list|)
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|confFile
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|confFile
operator|->
name|removedKeys
operator|.
name|remove
argument_list|(
name|theKey
argument_list|)
expr_stmt|;
name|confFile
operator|->
name|addedKeys
operator|.
name|insert
argument_list|(
name|theKey
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get
name|bool
name|QConfFileSettingsPrivate
operator|::
name|get
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
name|QVariant
modifier|*
name|value
parameter_list|)
specifier|const
block|{
name|QSettingsKey
name|theKey
argument_list|(
name|key
argument_list|,
name|caseSensitivity
argument_list|)
decl_stmt|;
name|ParsedSettingsMap
operator|::
name|const_iterator
name|j
decl_stmt|;
name|bool
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumConfFiles
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|QConfFile
modifier|*
name|confFile
init|=
name|confFiles
index|[
name|i
index|]
operator|.
name|data
argument_list|()
condition|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|confFile
operator|->
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|confFile
operator|->
name|addedKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|j
operator|=
name|confFile
operator|->
name|addedKeys
operator|.
name|constFind
argument_list|(
name|theKey
argument_list|)
expr_stmt|;
name|found
operator|=
operator|(
name|j
operator|!=
name|confFile
operator|->
name|addedKeys
operator|.
name|constEnd
argument_list|()
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|ensureSectionParsed
argument_list|(
name|confFile
argument_list|,
name|theKey
argument_list|)
expr_stmt|;
name|j
operator|=
name|confFile
operator|->
name|originalKeys
operator|.
name|constFind
argument_list|(
name|theKey
argument_list|)
expr_stmt|;
name|found
operator|=
operator|(
name|j
operator|!=
name|confFile
operator|->
name|originalKeys
operator|.
name|constEnd
argument_list|()
operator|&&
operator|!
name|confFile
operator|->
name|removedKeys
operator|.
name|contains
argument_list|(
name|theKey
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|&&
name|value
condition|)
operator|*
name|value
operator|=
operator|*
name|j
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|fallbacks
condition|)
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|children
name|QStringList
name|QConfFileSettingsPrivate
operator|::
name|children
parameter_list|(
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|,
name|ChildSpec
name|spec
parameter_list|)
specifier|const
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|result
decl_stmt|;
name|ParsedSettingsMap
operator|::
name|const_iterator
name|j
decl_stmt|;
name|QSettingsKey
name|thePrefix
argument_list|(
name|prefix
argument_list|,
name|caseSensitivity
argument_list|)
decl_stmt|;
name|int
name|startPos
init|=
name|prefix
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumConfFiles
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|QConfFile
modifier|*
name|confFile
init|=
name|confFiles
index|[
name|i
index|]
operator|.
name|data
argument_list|()
condition|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|confFile
operator|->
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|thePrefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ensureAllSectionsParsed
argument_list|(
name|confFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ensureSectionParsed
argument_list|(
name|confFile
argument_list|,
name|thePrefix
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
cast|const_cast
argument_list|<
specifier|const
name|ParsedSettingsMap
operator|*
argument_list|>
argument_list|(
operator|&
name|confFile
operator|->
name|originalKeys
argument_list|)
operator|->
name|lowerBound
argument_list|(
name|thePrefix
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|!=
name|confFile
operator|->
name|originalKeys
operator|.
name|constEnd
argument_list|()
operator|&&
name|j
operator|.
name|key
argument_list|()
operator|.
name|startsWith
argument_list|(
name|thePrefix
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|confFile
operator|->
name|removedKeys
operator|.
name|contains
argument_list|(
name|j
operator|.
name|key
argument_list|()
argument_list|)
condition|)
name|processChild
argument_list|(
name|j
operator|.
name|key
argument_list|()
operator|.
name|originalCaseKey
argument_list|()
operator|.
name|mid
argument_list|(
name|startPos
argument_list|)
argument_list|,
name|spec
argument_list|,
name|result
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
name|j
operator|=
cast|const_cast
argument_list|<
specifier|const
name|ParsedSettingsMap
operator|*
argument_list|>
argument_list|(
operator|&
name|confFile
operator|->
name|addedKeys
argument_list|)
operator|->
name|lowerBound
argument_list|(
name|thePrefix
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|!=
name|confFile
operator|->
name|addedKeys
operator|.
name|constEnd
argument_list|()
operator|&&
name|j
operator|.
name|key
argument_list|()
operator|.
name|startsWith
argument_list|(
name|thePrefix
argument_list|)
condition|)
block|{
name|processChild
argument_list|(
name|j
operator|.
name|key
argument_list|()
operator|.
name|originalCaseKey
argument_list|()
operator|.
name|mid
argument_list|(
name|startPos
argument_list|)
argument_list|,
name|spec
argument_list|,
name|result
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fallbacks
condition|)
break|break;
block|}
block|}
return|return
name|result
operator|.
name|keys
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|clear
name|void
name|QConfFileSettingsPrivate
operator|::
name|clear
parameter_list|()
block|{
name|QConfFile
modifier|*
name|confFile
init|=
name|confFiles
index|[
name|spec
index|]
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|confFile
condition|)
return|return;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|confFile
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|ensureAllSectionsParsed
argument_list|(
name|confFile
argument_list|)
expr_stmt|;
name|confFile
operator|->
name|addedKeys
operator|.
name|clear
argument_list|()
expr_stmt|;
name|confFile
operator|->
name|removedKeys
operator|=
name|confFile
operator|->
name|originalKeys
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sync
name|void
name|QConfFileSettingsPrivate
operator|::
name|sync
parameter_list|()
block|{
comment|// people probably won't be checking the status a whole lot, so in case of
comment|// error we just try to go on and make the best of it
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumConfFiles
condition|;
operator|++
name|i
control|)
block|{
name|QConfFile
modifier|*
name|confFile
init|=
name|confFiles
index|[
name|i
index|]
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|confFile
condition|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|confFile
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|syncConfFile
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|flush
name|void
name|QConfFileSettingsPrivate
operator|::
name|flush
parameter_list|()
block|{
name|sync
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fileName
name|QString
name|QConfFileSettingsPrivate
operator|::
name|fileName
parameter_list|()
specifier|const
block|{
name|QConfFile
modifier|*
name|confFile
init|=
name|confFiles
index|[
name|spec
index|]
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|confFile
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|confFile
operator|->
name|name
return|;
block|}
end_function
begin_function
DECL|function|isWritable
name|bool
name|QConfFileSettingsPrivate
operator|::
name|isWritable
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|format
operator|>
name|QSettings
operator|::
name|IniFormat
operator|&&
operator|!
name|writeFunc
condition|)
return|return
literal|false
return|;
name|QConfFile
modifier|*
name|confFile
init|=
name|confFiles
index|[
name|spec
index|]
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|confFile
condition|)
return|return
literal|false
return|;
return|return
name|confFile
operator|->
name|isWritable
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|syncConfFile
name|void
name|QConfFileSettingsPrivate
operator|::
name|syncConfFile
parameter_list|(
name|int
name|confFileNo
parameter_list|)
block|{
name|QConfFile
modifier|*
name|confFile
init|=
name|confFiles
index|[
name|confFileNo
index|]
operator|.
name|data
argument_list|()
decl_stmt|;
name|bool
name|readOnly
init|=
name|confFile
operator|->
name|addedKeys
operator|.
name|isEmpty
argument_list|()
operator|&&
name|confFile
operator|->
name|removedKeys
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|bool
name|ok
decl_stmt|;
comment|/*         We can often optimize the read-only case, if the file on disk         hasn't changed.     */
if|if
condition|(
name|readOnly
operator|&&
name|confFile
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|QFileInfo
name|fileInfo
argument_list|(
name|confFile
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|confFile
operator|->
name|size
operator|==
name|fileInfo
operator|.
name|size
argument_list|()
operator|&&
name|confFile
operator|->
name|timeStamp
operator|==
name|fileInfo
operator|.
name|lastModified
argument_list|()
condition|)
return|return;
block|}
comment|/*         Open the configuration file and try to use it using a named         semaphore on Windows and an advisory lock on Unix-based         systems. This protect us against other QSettings instances         trying to access the same file from other threads or         processes.          As it stands now, the locking mechanism doesn't work for         .plist files.     */
name|QFile
name|file
argument_list|(
name|confFile
operator|->
name|name
argument_list|)
decl_stmt|;
name|bool
name|createFile
init|=
operator|!
name|file
operator|.
name|exists
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|readOnly
operator|&&
name|confFile
operator|->
name|isWritable
argument_list|()
condition|)
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadWrite
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|isOpen
argument_list|()
condition|)
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|createFile
operator|&&
operator|!
name|file
operator|.
name|isOpen
argument_list|()
condition|)
name|setStatus
argument_list|(
name|QSettings
operator|::
name|AccessError
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|HANDLE
name|readSemaphore
init|=
literal|0
decl_stmt|;
name|HANDLE
name|writeSemaphore
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|int
name|FileLockSemMax
init|=
literal|50
decl_stmt|;
name|int
name|numReadLocks
init|=
name|readOnly
condition|?
literal|1
else|:
name|FileLockSemMax
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|isOpen
argument_list|()
condition|)
block|{
comment|// Acquire the write lock if we will be writing
if|if
condition|(
operator|!
name|readOnly
condition|)
block|{
name|QString
name|writeSemName
init|=
name|QLatin1String
argument_list|(
literal|"QSettingsWriteSem "
argument_list|)
decl_stmt|;
name|writeSemName
operator|.
name|append
argument_list|(
name|file
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
name|writeSemaphore
operator|=
name|CreateSemaphore
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|writeSemName
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeSemaphore
condition|)
block|{
name|WaitForSingleObject
argument_list|(
name|writeSemaphore
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setStatus
argument_list|(
name|QSettings
operator|::
name|AccessError
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// Acquire all the read locks if we will be writing, to make sure nobody
comment|// reads while we're writing. If we are only reading, acquire a single
comment|// read lock.
name|QString
name|readSemName
argument_list|(
name|QLatin1String
argument_list|(
literal|"QSettingsReadSem "
argument_list|)
argument_list|)
decl_stmt|;
name|readSemName
operator|.
name|append
argument_list|(
name|file
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
name|readSemaphore
operator|=
name|CreateSemaphore
argument_list|(
literal|0
argument_list|,
name|FileLockSemMax
argument_list|,
name|FileLockSemMax
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|readSemName
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readSemaphore
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numReadLocks
condition|;
operator|++
name|i
control|)
name|WaitForSingleObject
argument_list|(
name|readSemaphore
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setStatus
argument_list|(
name|QSettings
operator|::
name|AccessError
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeSemaphore
operator|!=
literal|0
condition|)
block|{
name|ReleaseSemaphore
argument_list|(
name|writeSemaphore
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|writeSemaphore
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|file
operator|.
name|isOpen
argument_list|()
condition|)
name|unixLock
argument_list|(
name|file
operator|.
name|handle
argument_list|()
argument_list|,
name|readOnly
condition|?
name|F_RDLCK
else|:
name|F_WRLCK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// If we have created the file, apply the file perms
if|if
condition|(
name|file
operator|.
name|isOpen
argument_list|()
condition|)
block|{
if|if
condition|(
name|createFile
condition|)
block|{
name|QFile
operator|::
name|Permissions
name|perms
init|=
name|file
operator|.
name|permissions
argument_list|()
operator||
name|QFile
operator|::
name|ReadOwner
operator||
name|QFile
operator|::
name|WriteOwner
decl_stmt|;
if|if
condition|(
operator|!
name|confFile
operator|->
name|userPerms
condition|)
name|perms
operator||=
name|QFile
operator|::
name|ReadGroup
operator||
name|QFile
operator|::
name|ReadOther
expr_stmt|;
name|file
operator|.
name|setPermissions
argument_list|(
name|perms
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*         We hold the lock. Let's reread the file if it has changed         since last time we read it.     */
name|QFileInfo
name|fileInfo
argument_list|(
name|confFile
operator|->
name|name
argument_list|)
decl_stmt|;
name|bool
name|mustReadFile
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|readOnly
condition|)
name|mustReadFile
operator|=
operator|(
name|confFile
operator|->
name|size
operator|!=
name|fileInfo
operator|.
name|size
argument_list|()
operator|||
operator|(
name|confFile
operator|->
name|size
operator|!=
literal|0
operator|&&
name|confFile
operator|->
name|timeStamp
operator|!=
name|fileInfo
operator|.
name|lastModified
argument_list|()
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|mustReadFile
condition|)
block|{
name|confFile
operator|->
name|unparsedIniSections
operator|.
name|clear
argument_list|()
expr_stmt|;
name|confFile
operator|->
name|originalKeys
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|/*             Files that we can't read (because of permissions or             because they don't exist) are treated as empty files.         */
if|if
condition|(
name|file
operator|.
name|isReadable
argument_list|()
operator|&&
name|fileInfo
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_MAC
if|if
condition|(
name|format
operator|==
name|QSettings
operator|::
name|NativeFormat
condition|)
block|{
name|ok
operator|=
name|readPlistFile
argument_list|(
name|confFile
operator|->
name|name
argument_list|,
operator|&
name|confFile
operator|->
name|originalKeys
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|format
operator|<=
name|QSettings
operator|::
name|IniFormat
condition|)
block|{
name|QByteArray
name|data
init|=
name|file
operator|.
name|readAll
argument_list|()
decl_stmt|;
name|ok
operator|=
name|readIniFile
argument_list|(
name|data
argument_list|,
operator|&
name|confFile
operator|->
name|unparsedIniSections
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|readFunc
condition|)
block|{
name|QSettings
operator|::
name|SettingsMap
name|tempNewKeys
decl_stmt|;
name|ok
operator|=
name|readFunc
argument_list|(
name|file
argument_list|,
name|tempNewKeys
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|QSettings
operator|::
name|SettingsMap
operator|::
name|const_iterator
name|i
init|=
name|tempNewKeys
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|tempNewKeys
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|confFile
operator|->
name|originalKeys
operator|.
name|insert
argument_list|(
name|QSettingsKey
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|,
name|caseSensitivity
argument_list|)
argument_list|,
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ok
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
name|setStatus
argument_list|(
name|QSettings
operator|::
name|FormatError
argument_list|)
expr_stmt|;
block|}
name|confFile
operator|->
name|size
operator|=
name|fileInfo
operator|.
name|size
argument_list|()
expr_stmt|;
name|confFile
operator|->
name|timeStamp
operator|=
name|fileInfo
operator|.
name|lastModified
argument_list|()
expr_stmt|;
block|}
comment|/*         We also need to save the file. We still hold the file lock,         so everything is under control.     */
if|if
condition|(
operator|!
name|readOnly
condition|)
block|{
name|ensureAllSectionsParsed
argument_list|(
name|confFile
argument_list|)
expr_stmt|;
name|ParsedSettingsMap
name|mergedKeys
init|=
name|confFile
operator|->
name|mergedKeyMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|isWritable
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_MAC
if|if
condition|(
name|format
operator|==
name|QSettings
operator|::
name|NativeFormat
condition|)
block|{
name|ok
operator|=
name|writePlistFile
argument_list|(
name|confFile
operator|->
name|name
argument_list|,
name|mergedKeys
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|file
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|file
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|<=
name|QSettings
operator|::
name|IniFormat
condition|)
block|{
name|ok
operator|=
name|writeIniFile
argument_list|(
name|file
argument_list|,
name|mergedKeys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
comment|// try to restore old data; might work if the disk was full and the new data
comment|// was larger than the old data
name|file
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|file
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|writeIniFile
argument_list|(
name|file
argument_list|,
name|confFile
operator|->
name|originalKeys
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|writeFunc
condition|)
block|{
name|QSettings
operator|::
name|SettingsMap
name|tempOriginalKeys
decl_stmt|;
name|ParsedSettingsMap
operator|::
name|const_iterator
name|i
init|=
name|mergedKeys
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|mergedKeys
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|tempOriginalKeys
operator|.
name|insert
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|,
name|i
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|ok
operator|=
name|writeFunc
argument_list|(
name|file
argument_list|,
name|tempOriginalKeys
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|ok
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
name|confFile
operator|->
name|unparsedIniSections
operator|.
name|clear
argument_list|()
expr_stmt|;
name|confFile
operator|->
name|originalKeys
operator|=
name|mergedKeys
expr_stmt|;
name|confFile
operator|->
name|addedKeys
operator|.
name|clear
argument_list|()
expr_stmt|;
name|confFile
operator|->
name|removedKeys
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QFileInfo
name|fileInfo
argument_list|(
name|confFile
operator|->
name|name
argument_list|)
decl_stmt|;
name|confFile
operator|->
name|size
operator|=
name|fileInfo
operator|.
name|size
argument_list|()
expr_stmt|;
name|confFile
operator|->
name|timeStamp
operator|=
name|fileInfo
operator|.
name|lastModified
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|setStatus
argument_list|(
name|QSettings
operator|::
name|AccessError
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*         Release the file lock.     */
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
name|readSemaphore
operator|!=
literal|0
condition|)
block|{
name|ReleaseSemaphore
argument_list|(
name|readSemaphore
argument_list|,
name|numReadLocks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|readSemaphore
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writeSemaphore
operator|!=
literal|0
condition|)
block|{
name|ReleaseSemaphore
argument_list|(
name|writeSemaphore
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|writeSemaphore
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_enum
DECL|enumerator|Space
DECL|enumerator|Special
enum|enum
block|{
name|Space
init|=
literal|0x1
block|,
name|Special
init|=
literal|0x2
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|charTraits
specifier|static
specifier|const
name|char
name|charTraits
index|[
literal|256
index|]
init|=
block|{
comment|// Space: '\t', '\n', '\r', ' '
comment|// Special: '\n', '\r', '"', ';', '=', '\\'
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|Space
block|,
name|Space
operator||
name|Special
block|,
literal|0
block|,
literal|0
block|,
name|Space
operator||
name|Special
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|Space
block|,
literal|0
block|,
name|Special
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|Special
block|,
literal|0
block|,
name|Special
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|Special
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|readIniLine
name|bool
name|QConfFileSettingsPrivate
operator|::
name|readIniLine
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|int
modifier|&
name|dataPos
parameter_list|,
name|int
modifier|&
name|lineStart
parameter_list|,
name|int
modifier|&
name|lineLen
parameter_list|,
name|int
modifier|&
name|equalsPos
parameter_list|)
block|{
name|int
name|dataLen
init|=
name|data
operator|.
name|length
argument_list|()
decl_stmt|;
name|bool
name|inQuotes
init|=
literal|false
decl_stmt|;
name|equalsPos
operator|=
operator|-
literal|1
expr_stmt|;
name|lineStart
operator|=
name|dataPos
expr_stmt|;
while|while
condition|(
name|lineStart
operator|<
name|dataLen
operator|&&
operator|(
name|charTraits
index|[
name|uint
argument_list|(
name|uchar
argument_list|(
name|data
operator|.
name|at
argument_list|(
name|lineStart
argument_list|)
argument_list|)
argument_list|)
index|]
operator|&
name|Space
operator|)
condition|)
operator|++
name|lineStart
expr_stmt|;
name|int
name|i
init|=
name|lineStart
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|dataLen
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|charTraits
index|[
name|uint
argument_list|(
name|uchar
argument_list|(
name|data
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
index|]
operator|&
name|Special
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|dataLen
condition|)
goto|goto
name|break_out_of_outer_loop
goto|;
block|}
name|char
name|ch
init|=
name|data
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
operator|!
name|inQuotes
operator|&&
name|equalsPos
operator|==
operator|-
literal|1
condition|)
name|equalsPos
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|lineStart
operator|+
literal|1
condition|)
block|{
operator|++
name|lineStart
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|inQuotes
condition|)
block|{
operator|--
name|i
expr_stmt|;
goto|goto
name|break_out_of_outer_loop
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|dataLen
condition|)
block|{
name|char
name|ch
init|=
name|data
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|dataLen
condition|)
block|{
name|char
name|ch2
init|=
name|data
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// \n, \r, \r\n, and \n\r are legitimate line terminators in INI files
if|if
condition|(
operator|(
name|ch
operator|==
literal|'\n'
operator|&&
name|ch2
operator|==
literal|'\r'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'\r'
operator|&&
name|ch2
operator|==
literal|'\n'
operator|)
condition|)
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'"'
condition|)
block|{
name|inQuotes
operator|=
operator|!
name|inQuotes
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|ch
operator|==
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|lineStart
operator|+
literal|1
condition|)
block|{
name|char
name|ch
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|dataLen
operator|&&
operator|(
operator|(
name|ch
operator|=
name|data
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
literal|'\n'
operator|)
operator|&&
name|ch
operator|!=
literal|'\r'
operator|)
condition|)
operator|++
name|i
expr_stmt|;
name|lineStart
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|inQuotes
condition|)
block|{
operator|--
name|i
expr_stmt|;
goto|goto
name|break_out_of_outer_loop
goto|;
block|}
block|}
block|}
name|break_out_of_outer_loop
label|:
name|dataPos
operator|=
name|i
expr_stmt|;
name|lineLen
operator|=
name|i
operator|-
name|lineStart
expr_stmt|;
return|return
name|lineLen
operator|>
literal|0
return|;
block|}
end_function
begin_comment
comment|/*     Returns false on parse error. However, as many keys are read as     possible, so if the user doesn't check the status he will get the     most out of the file anyway. */
end_comment
begin_function
DECL|function|readIniFile
name|bool
name|QConfFileSettingsPrivate
operator|::
name|readIniFile
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|UnparsedSettingsMap
modifier|*
name|unparsedIniSections
parameter_list|)
block|{
DECL|macro|FLUSH_CURRENT_SECTION
define|#
directive|define
name|FLUSH_CURRENT_SECTION
parameter_list|()
define|\
value|{ \         QByteArray&sectionData = (*unparsedIniSections)[QSettingsKey(currentSection, \                                                                       IniCaseSensitivity, \                                                                       sectionPosition)]; \         if (!sectionData.isEmpty()) \             sectionData.append('\n'); \         sectionData += data.mid(currentSectionStart, lineStart - currentSectionStart); \         sectionPosition = ++position; \     }
name|QString
name|currentSection
decl_stmt|;
name|int
name|currentSectionStart
init|=
literal|0
decl_stmt|;
name|int
name|dataPos
init|=
literal|0
decl_stmt|;
name|int
name|lineStart
decl_stmt|;
name|int
name|lineLen
decl_stmt|;
name|int
name|equalsPos
decl_stmt|;
name|int
name|position
init|=
literal|0
decl_stmt|;
name|int
name|sectionPosition
init|=
literal|0
decl_stmt|;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|readIniLine
argument_list|(
name|data
argument_list|,
name|dataPos
argument_list|,
name|lineStart
argument_list|,
name|lineLen
argument_list|,
name|equalsPos
argument_list|)
condition|)
block|{
name|char
name|ch
init|=
name|data
operator|.
name|at
argument_list|(
name|lineStart
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'['
condition|)
block|{
name|FLUSH_CURRENT_SECTION
argument_list|()
expr_stmt|;
comment|// this is a section
name|QByteArray
name|iniSection
decl_stmt|;
name|int
name|idx
init|=
name|data
operator|.
name|indexOf
argument_list|(
literal|']'
argument_list|,
name|lineStart
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|idx
operator|>=
name|lineStart
operator|+
name|lineLen
condition|)
block|{
name|ok
operator|=
literal|false
expr_stmt|;
name|iniSection
operator|=
name|data
operator|.
name|mid
argument_list|(
name|lineStart
operator|+
literal|1
argument_list|,
name|lineLen
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iniSection
operator|=
name|data
operator|.
name|mid
argument_list|(
name|lineStart
operator|+
literal|1
argument_list|,
name|idx
operator|-
name|lineStart
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|iniSection
operator|=
name|iniSection
operator|.
name|trimmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|qstricmp
argument_list|(
name|iniSection
operator|.
name|constData
argument_list|()
argument_list|,
literal|"general"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|currentSection
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|qstricmp
argument_list|(
name|iniSection
operator|.
name|constData
argument_list|()
argument_list|,
literal|"%general"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|currentSection
operator|=
name|QLatin1String
argument_list|(
name|iniSection
operator|.
name|constData
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentSection
operator|.
name|clear
argument_list|()
expr_stmt|;
name|iniUnescapedKey
argument_list|(
name|iniSection
argument_list|,
literal|0
argument_list|,
name|iniSection
operator|.
name|size
argument_list|()
argument_list|,
name|currentSection
argument_list|)
expr_stmt|;
block|}
name|currentSection
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|currentSectionStart
operator|=
name|dataPos
expr_stmt|;
block|}
operator|++
name|position
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|lineStart
operator|==
name|data
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|FLUSH_CURRENT_SECTION
argument_list|()
expr_stmt|;
return|return
name|ok
return|;
DECL|macro|FLUSH_CURRENT_SECTION
undef|#
directive|undef
name|FLUSH_CURRENT_SECTION
block|}
end_function
begin_function
DECL|function|readIniSection
name|bool
name|QConfFileSettingsPrivate
operator|::
name|readIniSection
parameter_list|(
specifier|const
name|QSettingsKey
modifier|&
name|section
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|ParsedSettingsMap
modifier|*
name|settingsMap
parameter_list|,
name|QTextCodec
modifier|*
name|codec
parameter_list|)
block|{
name|QStringList
name|strListValue
decl_stmt|;
name|bool
name|sectionIsLowercase
init|=
operator|(
name|section
operator|==
name|section
operator|.
name|originalCaseKey
argument_list|()
operator|)
decl_stmt|;
name|int
name|equalsPos
decl_stmt|;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
name|int
name|dataPos
init|=
literal|0
decl_stmt|;
name|int
name|lineStart
decl_stmt|;
name|int
name|lineLen
decl_stmt|;
name|int
name|position
init|=
name|section
operator|.
name|originalKeyPosition
argument_list|()
decl_stmt|;
while|while
condition|(
name|readIniLine
argument_list|(
name|data
argument_list|,
name|dataPos
argument_list|,
name|lineStart
argument_list|,
name|lineLen
argument_list|,
name|equalsPos
argument_list|)
condition|)
block|{
name|char
name|ch
init|=
name|data
operator|.
name|at
argument_list|(
name|lineStart
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ch
operator|!=
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|equalsPos
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ch
operator|!=
literal|';'
condition|)
name|ok
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
name|int
name|keyEnd
init|=
name|equalsPos
decl_stmt|;
while|while
condition|(
name|keyEnd
operator|>
name|lineStart
operator|&&
operator|(
operator|(
name|ch
operator|=
name|data
operator|.
name|at
argument_list|(
name|keyEnd
operator|-
literal|1
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|ch
operator|==
literal|'\t'
operator|)
condition|)
operator|--
name|keyEnd
expr_stmt|;
name|int
name|valueStart
init|=
name|equalsPos
operator|+
literal|1
decl_stmt|;
name|QString
name|key
init|=
name|section
operator|.
name|originalCaseKey
argument_list|()
decl_stmt|;
name|bool
name|keyIsLowercase
init|=
operator|(
name|iniUnescapedKey
argument_list|(
name|data
argument_list|,
name|lineStart
argument_list|,
name|keyEnd
argument_list|,
name|key
argument_list|)
operator|&&
name|sectionIsLowercase
operator|)
decl_stmt|;
name|QString
name|strValue
decl_stmt|;
name|strValue
operator|.
name|reserve
argument_list|(
name|lineLen
operator|-
operator|(
name|valueStart
operator|-
name|lineStart
operator|)
argument_list|)
expr_stmt|;
name|bool
name|isStringList
init|=
name|iniUnescapedStringList
argument_list|(
name|data
argument_list|,
name|valueStart
argument_list|,
name|lineStart
operator|+
name|lineLen
argument_list|,
name|strValue
argument_list|,
name|strListValue
argument_list|,
name|codec
argument_list|)
decl_stmt|;
name|QVariant
name|variant
decl_stmt|;
if|if
condition|(
name|isStringList
condition|)
block|{
name|variant
operator|=
name|stringListToVariantList
argument_list|(
name|strListValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|variant
operator|=
name|stringToVariant
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
block|}
comment|/*             We try to avoid the expensive toLower() call in             QSettingsKey by passing Qt::CaseSensitive when the             key is already in lowercase.         */
name|settingsMap
operator|->
name|insert
argument_list|(
name|QSettingsKey
argument_list|(
name|key
argument_list|,
name|keyIsLowercase
condition|?
name|Qt
operator|::
name|CaseSensitive
else|:
name|IniCaseSensitivity
argument_list|,
name|position
argument_list|)
argument_list|,
name|variant
argument_list|)
expr_stmt|;
operator|++
name|position
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function
begin_class
DECL|class|QSettingsIniKey
class|class
name|QSettingsIniKey
super|:
specifier|public
name|QString
block|{
public|public:
DECL|function|QSettingsIniKey
specifier|inline
name|QSettingsIniKey
parameter_list|()
member_init_list|:
name|position
argument_list|(
operator|-
literal|1
argument_list|)
block|{}
DECL|function|QSettingsIniKey
specifier|inline
name|QSettingsIniKey
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|pos
init|=
operator|-
literal|1
parameter_list|)
member_init_list|:
name|QString
argument_list|(
name|str
argument_list|)
member_init_list|,
name|position
argument_list|(
name|pos
argument_list|)
block|{}
DECL|member|position
name|int
name|position
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|operator <
specifier|static
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|QSettingsIniKey
modifier|&
name|k1
parameter_list|,
specifier|const
name|QSettingsIniKey
modifier|&
name|k2
parameter_list|)
block|{
if|if
condition|(
name|k1
operator|.
name|position
operator|!=
name|k2
operator|.
name|position
condition|)
return|return
name|k1
operator|.
name|position
operator|<
name|k2
operator|.
name|position
return|;
return|return
cast|static_cast
argument_list|<
specifier|const
name|QString
operator|&
argument_list|>
argument_list|(
name|k1
argument_list|)
operator|<
cast|static_cast
argument_list|<
specifier|const
name|QString
operator|&
argument_list|>
argument_list|(
name|k2
argument_list|)
return|;
block|}
end_function
begin_typedef
DECL|typedef|IniKeyMap
typedef|typedef
name|QMap
argument_list|<
name|QSettingsIniKey
argument_list|,
name|QVariant
argument_list|>
name|IniKeyMap
typedef|;
end_typedef
begin_struct
DECL|struct|QSettingsIniSection
struct|struct
name|QSettingsIniSection
block|{
DECL|member|position
name|int
name|position
decl_stmt|;
DECL|member|keyMap
name|IniKeyMap
name|keyMap
decl_stmt|;
DECL|function|QSettingsIniSection
specifier|inline
name|QSettingsIniSection
parameter_list|()
member_init_list|:
name|position
argument_list|(
operator|-
literal|1
argument_list|)
block|{}
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|IniMap
typedef|typedef
name|QMap
argument_list|<
name|QString
argument_list|,
name|QSettingsIniSection
argument_list|>
name|IniMap
typedef|;
end_typedef
begin_comment
comment|/*     This would be more straightforward if we didn't try to remember the original     key order in the .ini file, but we do. */
end_comment
begin_function
DECL|function|writeIniFile
name|bool
name|QConfFileSettingsPrivate
operator|::
name|writeIniFile
parameter_list|(
name|QIODevice
modifier|&
name|device
parameter_list|,
specifier|const
name|ParsedSettingsMap
modifier|&
name|map
parameter_list|)
block|{
name|IniMap
name|iniMap
decl_stmt|;
name|IniMap
operator|::
name|const_iterator
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
specifier|const
name|char
modifier|*
specifier|const
name|eol
init|=
literal|"\r\n"
decl_stmt|;
else|#
directive|else
specifier|const
name|char
name|eol
init|=
literal|'\n'
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|ParsedSettingsMap
operator|::
name|const_iterator
name|j
init|=
name|map
operator|.
name|constBegin
argument_list|()
init|;
name|j
operator|!=
name|map
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|QString
name|section
decl_stmt|;
name|QSettingsIniKey
name|key
argument_list|(
name|j
operator|.
name|key
argument_list|()
operator|.
name|originalCaseKey
argument_list|()
argument_list|,
name|j
operator|.
name|key
argument_list|()
operator|.
name|originalKeyPosition
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|slashPos
decl_stmt|;
if|if
condition|(
operator|(
name|slashPos
operator|=
name|key
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|section
operator|=
name|key
operator|.
name|left
argument_list|(
name|slashPos
argument_list|)
expr_stmt|;
name|key
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|slashPos
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|QSettingsIniSection
modifier|&
name|iniSection
init|=
name|iniMap
index|[
name|section
index|]
decl_stmt|;
comment|// -1 means infinity
if|if
condition|(
name|uint
argument_list|(
name|key
operator|.
name|position
argument_list|)
operator|<
name|uint
argument_list|(
name|iniSection
operator|.
name|position
argument_list|)
condition|)
name|iniSection
operator|.
name|position
operator|=
name|key
operator|.
name|position
expr_stmt|;
name|iniSection
operator|.
name|keyMap
index|[
name|key
index|]
operator|=
name|j
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
specifier|const
name|int
name|sectionCount
init|=
name|iniMap
operator|.
name|size
argument_list|()
decl_stmt|;
name|QVector
argument_list|<
name|QSettingsIniKey
argument_list|>
name|sections
decl_stmt|;
name|sections
operator|.
name|reserve
argument_list|(
name|sectionCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|iniMap
operator|.
name|constBegin
argument_list|()
init|;
name|i
operator|!=
name|iniMap
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|i
control|)
name|sections
operator|.
name|append
argument_list|(
name|QSettingsIniKey
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|,
name|i
operator|.
name|value
argument_list|()
operator|.
name|position
argument_list|)
argument_list|)
expr_stmt|;
name|qSort
argument_list|(
name|sections
argument_list|)
expr_stmt|;
name|bool
name|writeError
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
operator|!
name|writeError
operator|&&
name|j
operator|<
name|sectionCount
condition|;
operator|++
name|j
control|)
block|{
name|i
operator|=
name|iniMap
operator|.
name|constFind
argument_list|(
name|sections
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|i
operator|!=
name|iniMap
operator|.
name|constEnd
argument_list|()
argument_list|)
expr_stmt|;
name|QByteArray
name|realSection
decl_stmt|;
name|iniEscapedKey
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|,
name|realSection
argument_list|)
expr_stmt|;
if|if
condition|(
name|realSection
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|realSection
operator|=
literal|"[General]"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qstricmp
argument_list|(
name|realSection
operator|.
name|constData
argument_list|()
argument_list|,
literal|"general"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|realSection
operator|=
literal|"[%General]"
expr_stmt|;
block|}
else|else
block|{
name|realSection
operator|.
name|prepend
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|realSection
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
name|realSection
operator|.
name|prepend
argument_list|(
name|eol
argument_list|)
expr_stmt|;
name|realSection
operator|+=
name|eol
expr_stmt|;
name|device
operator|.
name|write
argument_list|(
name|realSection
argument_list|)
expr_stmt|;
specifier|const
name|IniKeyMap
modifier|&
name|ents
init|=
name|i
operator|.
name|value
argument_list|()
operator|.
name|keyMap
decl_stmt|;
for|for
control|(
name|IniKeyMap
operator|::
name|const_iterator
name|j
init|=
name|ents
operator|.
name|constBegin
argument_list|()
init|;
name|j
operator|!=
name|ents
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|QByteArray
name|block
decl_stmt|;
name|iniEscapedKey
argument_list|(
name|j
operator|.
name|key
argument_list|()
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|block
operator|+=
literal|'='
expr_stmt|;
specifier|const
name|QVariant
modifier|&
name|value
init|=
name|j
operator|.
name|value
argument_list|()
decl_stmt|;
comment|/*                 The size() != 1 trick is necessary because                 QVariant(QString("foo")).toList() returns an empty                 list, not a list containing "foo".             */
if|if
condition|(
name|value
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|StringList
operator|||
operator|(
name|value
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|List
operator|&&
name|value
operator|.
name|toList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|)
condition|)
block|{
name|iniEscapedStringList
argument_list|(
name|variantListToStringList
argument_list|(
name|value
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|,
name|block
argument_list|,
name|iniCodec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iniEscapedString
argument_list|(
name|variantToString
argument_list|(
name|value
argument_list|)
argument_list|,
name|block
argument_list|,
name|iniCodec
argument_list|)
expr_stmt|;
block|}
name|block
operator|+=
name|eol
expr_stmt|;
if|if
condition|(
name|device
operator|.
name|write
argument_list|(
name|block
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|writeError
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|!
name|writeError
return|;
block|}
end_function
begin_function
DECL|function|ensureAllSectionsParsed
name|void
name|QConfFileSettingsPrivate
operator|::
name|ensureAllSectionsParsed
parameter_list|(
name|QConfFile
modifier|*
name|confFile
parameter_list|)
specifier|const
block|{
name|UnparsedSettingsMap
operator|::
name|const_iterator
name|i
init|=
name|confFile
operator|->
name|unparsedIniSections
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|UnparsedSettingsMap
operator|::
name|const_iterator
name|end
init|=
name|confFile
operator|->
name|unparsedIniSections
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|i
operator|!=
name|end
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|QConfFileSettingsPrivate
operator|::
name|readIniSection
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|,
name|i
operator|.
name|value
argument_list|()
argument_list|,
operator|&
name|confFile
operator|->
name|originalKeys
argument_list|,
name|iniCodec
argument_list|)
condition|)
name|setStatus
argument_list|(
name|QSettings
operator|::
name|FormatError
argument_list|)
expr_stmt|;
block|}
name|confFile
operator|->
name|unparsedIniSections
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ensureSectionParsed
name|void
name|QConfFileSettingsPrivate
operator|::
name|ensureSectionParsed
parameter_list|(
name|QConfFile
modifier|*
name|confFile
parameter_list|,
specifier|const
name|QSettingsKey
modifier|&
name|key
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|confFile
operator|->
name|unparsedIniSections
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|UnparsedSettingsMap
operator|::
name|iterator
name|i
decl_stmt|;
name|int
name|indexOfSlash
init|=
name|key
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexOfSlash
operator|!=
operator|-
literal|1
condition|)
block|{
name|i
operator|=
name|confFile
operator|->
name|unparsedIniSections
operator|.
name|upperBound
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|confFile
operator|->
name|unparsedIniSections
operator|.
name|begin
argument_list|()
condition|)
return|return;
operator|--
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|key
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|key
operator|.
name|startsWith
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
name|i
operator|=
name|confFile
operator|->
name|unparsedIniSections
operator|.
name|begin
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|confFile
operator|->
name|unparsedIniSections
operator|.
name|end
argument_list|()
operator|||
operator|!
name|i
operator|.
name|key
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
block|}
if|if
condition|(
operator|!
name|QConfFileSettingsPrivate
operator|::
name|readIniSection
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|,
name|i
operator|.
name|value
argument_list|()
argument_list|,
operator|&
name|confFile
operator|->
name|originalKeys
argument_list|,
name|iniCodec
argument_list|)
condition|)
name|setStatus
argument_list|(
name|QSettings
operator|::
name|FormatError
argument_list|)
expr_stmt|;
name|confFile
operator|->
name|unparsedIniSections
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QSettings     \inmodule QtCore     \brief The QSettings class provides persistent platform-independent application settings.      \ingroup io      \reentrant      Users normally expect an application to remember its settings     (window sizes and positions, options, etc.) across sessions. This     information is often stored in the system registry on Windows,     and in XML preferences files on Mac OS X. On Unix systems, in the     absence of a standard, many applications (including the KDE     applications) use INI text files.      QSettings is an abstraction around these technologies, enabling     you to save and restore application settings in a portable     manner. It also supports \l{registerFormat()}{custom storage     formats}.      QSettings's API is based on QVariant, allowing you to save     most value-based types, such as QString, QRect, and QImage,     with the minimum of effort.      If all you need is a non-persistent memory-based structure,     consider using QMap<QString, QVariant> instead.      \tableofcontents section1      \section1 Basic Usage      When creating a QSettings object, you must pass the name of your     company or organization as well as the name of your application.     For example, if your product is called Star Runner and your     company is called MySoft, you would construct the QSettings     object as follows:      \snippet settings/settings.cpp 0      QSettings objects can be created either on the stack or on     the heap (i.e. using \c new). Constructing and destroying a     QSettings object is very fast.      If you use QSettings from many places in your application, you     might want to specify the organization name and the application     name using QCoreApplication::setOrganizationName() and     QCoreApplication::setApplicationName(), and then use the default     QSettings constructor:      \snippet settings/settings.cpp 1     \snippet settings/settings.cpp 2     \snippet settings/settings.cpp 3     \dots     \snippet settings/settings.cpp 4      (Here, we also specify the organization's Internet domain. When     the Internet domain is set, it is used on Mac OS X instead of the     organization name, since Mac OS X applications conventionally use     Internet domains to identify themselves. If no domain is set, a     fake domain is derived from the organization name. See the     \l{Platform-Specific Notes} below for details.)      QSettings stores settings. Each setting consists of a QString     that specifies the setting's name (the \e key) and a QVariant     that stores the data associated with the key. To write a setting,     use setValue(). For example:      \snippet settings/settings.cpp 5      If there already exists a setting with the same key, the existing     value is overwritten by the new value. For efficiency, the     changes may not be saved to permanent storage immediately. (You     can always call sync() to commit your changes.)      You can get a setting's value back using value():      \snippet settings/settings.cpp 6      If there is no setting with the specified name, QSettings     returns a null QVariant (which can be converted to the integer 0).     You can specify another default value by passing a second     argument to value():      \snippet settings/settings.cpp 7      To test whether a given key exists, call contains(). To remove     the setting associated with a key, call remove(). To obtain the     list of all keys, call allKeys(). To remove all keys, call     clear().      \section1 QVariant and GUI Types      Because QVariant is part of the \l QtCore library, it cannot provide     conversion functions to data types such as QColor, QImage, and     QPixmap, which are part of \l QtGui. In other words, there is no     \c toColor(), \c toImage(), or \c toPixmap() functions in QVariant.      Instead, you can use the QVariant::value() or the qVariantValue()     template function. For example:      \snippet code/src_corelib_io_qsettings.cpp 0      The inverse conversion (e.g., from QColor to QVariant) is     automatic for all data types supported by QVariant, including     GUI-related types:      \snippet code/src_corelib_io_qsettings.cpp 1      Custom types registered using qRegisterMetaType() and     qRegisterMetaTypeStreamOperators() can be stored using QSettings.      \section1 Section and Key Syntax      Setting keys can contain any Unicode characters. The Windows     registry and INI files use case-insensitive keys, whereas the     Carbon Preferences API on Mac OS X uses case-sensitive keys. To     avoid portability problems, follow these simple rules:      \list 1     \li Always refer to the same key using the same case. For example,        if you refer to a key as "text fonts" in one place in your        code, don't refer to it as "Text Fonts" somewhere else.      \li Avoid key names that are identical except for the case. For        example, if you have a key called "MainWindow", don't try to        save another key as "mainwindow".      \li Do not use slashes ('/' and '\\') in section or key names; the        backslash character is used to separate sub keys (see below). On        windows '\\' are converted by QSettings to '/', which makes        them identical.     \endlist      You can form hierarchical keys using the '/' character as a     separator, similar to Unix file paths. For example:      \snippet settings/settings.cpp 8     \snippet settings/settings.cpp 9     \snippet settings/settings.cpp 10      If you want to save or restore many settings with the same     prefix, you can specify the prefix using beginGroup() and call     endGroup() at the end. Here's the same example again, but this     time using the group mechanism:      \snippet settings/settings.cpp 11     \codeline     \snippet settings/settings.cpp 12      If a group is set using beginGroup(), the behavior of most     functions changes consequently. Groups can be set recursively.      In addition to groups, QSettings also supports an "array"     concept. See beginReadArray() and beginWriteArray() for details.      \section1 Fallback Mechanism      Let's assume that you have created a QSettings object with the     organization name MySoft and the application name Star Runner.     When you look up a value, up to four locations are searched in     that order:      \list 1     \li a user-specific location for the Star Runner application     \li a user-specific location for all applications by MySoft     \li a system-wide location for the Star Runner application     \li a system-wide location for all applications by MySoft     \endlist      (See \l{Platform-Specific Notes} below for information on what     these locations are on the different platforms supported by Qt.)      If a key cannot be found in the first location, the search goes     on in the second location, and so on. This enables you to store     system-wide or organization-wide settings and to override them on     a per-user or per-application basis. To turn off this mechanism,     call setFallbacksEnabled(false).      Although keys from all four locations are available for reading,     only the first file (the user-specific location for the     application at hand) is accessible for writing. To write to any     of the other files, omit the application name and/or specify     QSettings::SystemScope (as opposed to QSettings::UserScope, the     default).      Let's see with an example:      \snippet settings/settings.cpp 13     \snippet settings/settings.cpp 14      The table below summarizes which QSettings objects access     which location. "\b{X}" means that the location is the main     location associated to the QSettings object and is used both     for reading and for writing; "o" means that the location is used     as a fallback when reading.      \table     \header \li Locations               \li \c{obj1} \li \c{obj2} \li \c{obj3} \li \c{obj4}     \row    \li 1. User, Application    \li \b{X} \li          \li          \li     \row    \li 2. User, Organization   \li o        \li \b{X} \li          \li     \row    \li 3. System, Application  \li o        \li          \li \b{X} \li     \row    \li 4. System, Organization \li o        \li o        \li o        \li \b{X}     \endtable      The beauty of this mechanism is that it works on all platforms     supported by Qt and that it still gives you a lot of flexibility,     without requiring you to specify any file names or registry     paths.      If you want to use INI files on all platforms instead of the     native API, you can pass QSettings::IniFormat as the first     argument to the QSettings constructor, followed by the scope, the     organization name, and the application name:      \snippet settings/settings.cpp 15      The \l{tools/settingseditor}{Settings Editor} example lets you     experiment with different settings location and with fallbacks     turned on or off.      \section1 Restoring the State of a GUI Application      QSettings is often used to store the state of a GUI     application. The following example illustrates how to use QSettings     to save and restore the geometry of an application's main window.      \snippet settings/settings.cpp 16     \codeline     \snippet settings/settings.cpp 17      See \l{Window Geometry} for a discussion on why it is better to     call QWidget::resize() and QWidget::move() rather than QWidget::setGeometry()     to restore a window's geometry.      The \c readSettings() and \c writeSettings() functions must be     called from the main window's constructor and close event handler     as follows:      \snippet settings/settings.cpp 18     \dots     \snippet settings/settings.cpp 19     \snippet settings/settings.cpp 20     \codeline     \snippet settings/settings.cpp 21      See the \l{mainwindows/application}{Application} example for a     self-contained example that uses QSettings.      \section1 Accessing Settings from Multiple Threads or Processes Simultaneously      QSettings is \l{reentrant}. This means that you can use     distinct QSettings object in different threads     simultaneously. This guarantee stands even when the QSettings     objects refer to the same files on disk (or to the same entries     in the system registry). If a setting is modified through one     QSettings object, the change will immediately be visible in     any other QSettings objects that operate on the same location     and that live in the same process.      QSettings can safely be used from different processes (which can     be different instances of your application running at the same     time or different applications altogether) to read and write to     the same system locations. It uses advisory file locking and a     smart merging algorithm to ensure data integrity. Note that sync()     imports changes made by other processes (in addition to writing     the changes from this QSettings).      \section1 Platform-Specific Notes      \section2 Locations Where Application Settings Are Stored      As mentioned in the \l{Fallback Mechanism} section, QSettings     stores settings for an application in up to four locations,     depending on whether the settings are user-specific or     system-wide and whether the settings are application-specific     or organization-wide. For simplicity, we're assuming the     organization is called MySoft and the application is called Star     Runner.      On Unix systems, if the file format is NativeFormat, the     following files are used by default:      \list 1     \li \c{$HOME/.config/MySoft/Star Runner.conf} (Qt for Embedded Linux: \c{$HOME/Settings/MySoft/Star Runner.conf})     \li \c{$HOME/.config/MySoft.conf} (Qt for Embedded Linux: \c{$HOME/Settings/MySoft.conf})     \li \c{/etc/xdg/MySoft/Star Runner.conf}     \li \c{/etc/xdg/MySoft.conf}     \endlist      On Mac OS X versions 10.2 and 10.3, these files are used by     default:      \list 1     \li \c{$HOME/Library/Preferences/com.MySoft.Star Runner.plist}     \li \c{$HOME/Library/Preferences/com.MySoft.plist}     \li \c{/Library/Preferences/com.MySoft.Star Runner.plist}     \li \c{/Library/Preferences/com.MySoft.plist}     \endlist      On Windows, NativeFormat settings are stored in the following     registry paths:      \list 1     \li \c{HKEY_CURRENT_USER\Software\MySoft\Star Runner}     \li \c{HKEY_CURRENT_USER\Software\MySoft\OrganizationDefaults}     \li \c{HKEY_LOCAL_MACHINE\Software\MySoft\Star Runner}     \li \c{HKEY_LOCAL_MACHINE\Software\MySoft\OrganizationDefaults}     \endlist      \note On Windows, for 32-bit programs running in WOW64 mode, settings are     stored in the following registry path:     \c{HKEY_LOCAL_MACHINE\Software\WOW6432node}.      If the file format is IniFormat, the following files are     used on Unix and Mac OS X:      \list 1     \li \c{$HOME/.config/MySoft/Star Runner.ini} (Qt for Embedded Linux: \c{$HOME/Settings/MySoft/Star Runner.ini})     \li \c{$HOME/.config/MySoft.ini} (Qt for Embedded Linux: \c{$HOME/Settings/MySoft.ini})     \li \c{/etc/xdg/MySoft/Star Runner.ini}     \li \c{/etc/xdg/MySoft.ini}     \endlist      On Windows, the following files are used:      \list 1     \li \c{%APPDATA%\MySoft\Star Runner.ini}     \li \c{%APPDATA%\MySoft.ini}     \li \c{%COMMON_APPDATA%\MySoft\Star Runner.ini}     \li \c{%COMMON_APPDATA%\MySoft.ini}     \endlist      The \c %APPDATA% path is usually \tt{C:\\Documents and     Settings\\\e{User Name}\\Application Data}; the \c     %COMMON_APPDATA% path is usually \tt{C:\\Documents and     Settings\\All Users\\Application Data}.      The paths for the \c .ini and \c .conf files can be changed using     setPath(). On Unix and Mac OS X, the user can override them by by     setting the \c XDG_CONFIG_HOME environment variable; see     setPath() for details.      \section2 Accessing INI and .plist Files Directly      Sometimes you do want to access settings stored in a specific     file or registry path. On all platforms, if you want to read an     INI file directly, you can use the QSettings constructor that     takes a file name as first argument and pass QSettings::IniFormat     as second argument. For example:      \snippet code/src_corelib_io_qsettings.cpp 2      You can then use the QSettings object to read and write settings     in the file.      On Mac OS X, you can access XML-based \c .plist files by passing     QSettings::NativeFormat as second argument. For example:      \snippet code/src_corelib_io_qsettings.cpp 3      \section2 Accessing the Windows Registry Directly      On Windows, QSettings lets you access settings that have been     written with QSettings (or settings in a supported format, e.g., string     data) in the system registry. This is done by constructing a QSettings     object with a path in the registry and QSettings::NativeFormat.      For example:      \snippet code/src_corelib_io_qsettings.cpp 4      All the registry entries that appear under the specified path can     be read or written through the QSettings object as usual (using     forward slashes instead of backslashes). For example:      \snippet code/src_corelib_io_qsettings.cpp 5      Note that the backslash character is, as mentioned, used by     QSettings to separate subkeys. As a result, you cannot read or     write windows registry entries that contain slashes or     backslashes; you should use a native windows API if you need to do     so.      \section2 Accessing Common Registry Settings on Windows      On Windows, it is possible for a key to have both a value and subkeys.     Its default value is accessed by using "Default" or "." in     place of a subkey:      \snippet code/src_corelib_io_qsettings.cpp 6      On other platforms than Windows, "Default" and "." would be     treated as regular subkeys.      \section2 Platform Limitations      While QSettings attempts to smooth over the differences between     the different supported platforms, there are still a few     differences that you should be aware of when porting your     application:      \list     \li  The Windows system registry has the following limitations: A         subkey may not exceed 255 characters, an entry's value may         not exceed 16,383 characters, and all the values of a key may         not exceed 65,535 characters. One way to work around these         limitations is to store the settings using the IniFormat         instead of the NativeFormat.      \li  On Mac OS X, allKeys() will return some extra keys for global         settings that apply to all applications. These keys can be         read using value() but cannot be changed, only shadowed.         Calling setFallbacksEnabled(false) will hide these global         settings.      \li  On Mac OS X, the CFPreferences API used by QSettings expects         Internet domain names rather than organization names. To         provide a uniform API, QSettings derives a fake domain name         from the organization name (unless the organization name         already is a domain name, e.g. OpenOffice.org). The algorithm         appends ".com" to the company name and replaces spaces and         other illegal characters with hyphens. If you want to specify         a different domain name, call         QCoreApplication::setOrganizationDomain(),         QCoreApplication::setOrganizationName(), and         QCoreApplication::setApplicationName() in your \c main()         function and then use the default QSettings constructor.         Another solution is to use preprocessor directives, for         example:          \snippet code/src_corelib_io_qsettings.cpp 7      \li On Unix and Mac OS X systems, the advisory file locking is disabled        if NFS (or AutoFS or CacheFS) is detected to work around a bug in the        NFS fcntl() implementation, which hangs forever if statd or lockd aren't        running. Also, the locking isn't performed when accessing \c .plist        files.      \li On the BlackBerry platform, applications run in a sandbox. They are not        allowed to read or write outside of this sandbox. This involves the        following limitations:        \list        \li As there is only a single scope the scope is simply ignored.        \li The \l{Fallback Mechanism} is not applied, i.e. only a single           location is considered.        \li It is advised against setting and using custom file paths.        \endlist      \endlist      \sa QVariant, QSessionManager, {Settings Editor Example}, {Application Example} */
end_comment
begin_comment
comment|/*! \enum QSettings::Status      The following status values are possible:      \value NoError  No error occurred.     \value AccessError  An access error occurred (e.g. trying to write to a read-only file).     \value FormatError  A format error occurred (e.g. loading a malformed INI file).      \sa status() */
end_comment
begin_comment
comment|/*! \enum QSettings::Format      This enum type specifies the storage format used by QSettings.      \value NativeFormat  Store the settings using the most                          appropriate storage format for the platform.                          On Windows, this means the system registry;                          on Mac OS X, this means the CFPreferences                          API; on Unix, this means textual                          configuration files in INI format.     \value IniFormat  Store the settings in INI files.     \value InvalidFormat Special value returned by registerFormat().     \omitvalue CustomFormat1     \omitvalue CustomFormat2     \omitvalue CustomFormat3     \omitvalue CustomFormat4     \omitvalue CustomFormat5     \omitvalue CustomFormat6     \omitvalue CustomFormat7     \omitvalue CustomFormat8     \omitvalue CustomFormat9     \omitvalue CustomFormat10     \omitvalue CustomFormat11     \omitvalue CustomFormat12     \omitvalue CustomFormat13     \omitvalue CustomFormat14     \omitvalue CustomFormat15     \omitvalue CustomFormat16      On Unix, NativeFormat and IniFormat mean the same thing, except     that the file extension is different (\c .conf for NativeFormat,     \c .ini for IniFormat).      The INI file format is a Windows file format that Qt supports on     all platforms. In the absence of an INI standard, we try to     follow what Microsoft does, with the following exceptions:      \list     \li  If you store types that QVariant can't convert to QString         (e.g., QPoint, QRect, and QSize), Qt uses an \c{@}-based         syntax to encode the type. For example:          \snippet code/src_corelib_io_qsettings.cpp 8          To minimize compatibility issues, any \c @ that doesn't         appear at the first position in the value or that isn't         followed by a Qt type (\c Point, \c Rect, \c Size, etc.) is         treated as a normal character.      \li  Although backslash is a special character in INI files, most         Windows applications don't escape backslashes (\c{\}) in file         paths:          \snippet code/src_corelib_io_qsettings.cpp 9          QSettings always treats backslash as a special character and         provides no API for reading or writing such entries.      \li  The INI file format has severe restrictions on the syntax of         a key. Qt works around this by using \c % as an escape         character in keys. In addition, if you save a top-level         setting (a key with no slashes in it, e.g., "someKey"), it         will appear in the INI file's "General" section. To avoid         overwriting other keys, if you save something using the a key         such as "General/someKey", the key will be located in the         "%General" section, \e not in the "General" section.      \li  Following the philosophy that we should be liberal in what         we accept and conservative in what we generate, QSettings         will accept Latin-1 encoded INI files, but generate pure         ASCII files, where non-ASCII values are encoded using standard         INI escape sequences. To make the INI files more readable (but         potentially less compatible), call setIniCodec().     \endlist      \sa registerFormat(), setPath() */
end_comment
begin_comment
comment|/*! \enum QSettings::Scope      This enum specifies whether settings are user-specific or shared     by all users of the same system.      \value UserScope  Store settings in a location specific to the                       current user (e.g., in the user's home                       directory).     \value SystemScope  Store settings in a global location, so that                         all users on the same machine access the same                         set of settings.      \sa setPath() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_comment
comment|/*!     Constructs a QSettings object for accessing settings of the     application called \a application from the organization called \a     organization, and with parent \a parent.      Example:     \snippet code/src_corelib_io_qsettings.cpp 10      The scope is set to QSettings::UserScope, and the format is     set to QSettings::NativeFormat (i.e. calling setDefaultFormat()     before calling this constructor has no effect).      \sa setDefaultFormat(), {Fallback Mechanism} */
end_comment
begin_constructor
DECL|function|QSettings
name|QSettings
operator|::
name|QSettings
parameter_list|(
specifier|const
name|QString
modifier|&
name|organization
parameter_list|,
specifier|const
name|QString
modifier|&
name|application
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
name|QSettingsPrivate
operator|::
name|create
argument_list|(
name|NativeFormat
argument_list|,
name|UserScope
argument_list|,
name|organization
argument_list|,
name|application
argument_list|)
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QSettings object for accessing settings of the     application called \a application from the organization called \a     organization, and with parent \a parent.      If \a scope is QSettings::UserScope, the QSettings object searches     user-specific settings first, before it searches system-wide     settings as a fallback. If \a scope is QSettings::SystemScope, the     QSettings object ignores user-specific settings and provides     access to system-wide settings.      The storage format is set to QSettings::NativeFormat (i.e. calling     setDefaultFormat() before calling this constructor has no effect).      If no application name is given, the QSettings object will     only access the organization-wide \l{Fallback Mechanism}{locations}.      \sa setDefaultFormat() */
end_comment
begin_constructor
DECL|function|QSettings
name|QSettings
operator|::
name|QSettings
parameter_list|(
name|Scope
name|scope
parameter_list|,
specifier|const
name|QString
modifier|&
name|organization
parameter_list|,
specifier|const
name|QString
modifier|&
name|application
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
name|QSettingsPrivate
operator|::
name|create
argument_list|(
name|NativeFormat
argument_list|,
name|scope
argument_list|,
name|organization
argument_list|,
name|application
argument_list|)
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QSettings object for accessing settings of the     application called \a application from the organization called     \a organization, and with parent \a parent.      If \a scope is QSettings::UserScope, the QSettings object searches     user-specific settings first, before it searches system-wide     settings as a fallback. If \a scope is     QSettings::SystemScope, the QSettings object ignores user-specific     settings and provides access to system-wide settings.      If \a format is QSettings::NativeFormat, the native API is used for     storing settings. If \a format is QSettings::IniFormat, the INI format     is used.      If no application name is given, the QSettings object will     only access the organization-wide \l{Fallback Mechanism}{locations}. */
end_comment
begin_constructor
DECL|function|QSettings
name|QSettings
operator|::
name|QSettings
parameter_list|(
name|Format
name|format
parameter_list|,
name|Scope
name|scope
parameter_list|,
specifier|const
name|QString
modifier|&
name|organization
parameter_list|,
specifier|const
name|QString
modifier|&
name|application
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
name|QSettingsPrivate
operator|::
name|create
argument_list|(
name|format
argument_list|,
name|scope
argument_list|,
name|organization
argument_list|,
name|application
argument_list|)
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QSettings object for accessing the settings     stored in the file called \a fileName, with parent \a parent. If     the file doesn't already exist, it is created.      If \a format is QSettings::NativeFormat, the meaning of \a     fileName depends on the platform. On Unix, \a fileName is the     name of an INI file. On Mac OS X, \a fileName is the name of a     \c .plist file. On Windows, \a fileName is a path in the system     registry.      If \a format is QSettings::IniFormat, \a fileName is the name of an INI     file.      \warning This function is provided for convenience. It works well for     accessing INI or \c .plist files generated by Qt, but might fail on some     syntaxes found in such files originated by other programs. In particular,     be aware of the following limitations:      \list     \li QSettings provides no way of reading INI "path" entries, i.e., entries        with unescaped slash characters. (This is because these entries are        ambiguous and cannot be resolved automatically.)     \li In INI files, QSettings uses the \c @ character as a metacharacter in some        contexts, to encode Qt-specific data types (e.g., \c @Rect), and might        therefore misinterpret it when it occurs in pure INI files.     \endlist      \sa fileName() */
end_comment
begin_constructor
DECL|function|QSettings
name|QSettings
operator|::
name|QSettings
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|Format
name|format
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
name|QSettingsPrivate
operator|::
name|create
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|)
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QSettings object for accessing settings of the     application and organization set previously with a call to     QCoreApplication::setOrganizationName(),     QCoreApplication::setOrganizationDomain(), and     QCoreApplication::setApplicationName().      The scope is QSettings::UserScope and the format is     defaultFormat() (QSettings::NativeFormat by default).     Use setDefaultFormat() before calling this constructor     to change the default format used by this constructor.      The code      \snippet code/src_corelib_io_qsettings.cpp 11      is equivalent to      \snippet code/src_corelib_io_qsettings.cpp 12      If QCoreApplication::setOrganizationName() and     QCoreApplication::setApplicationName() has not been previously     called, the QSettings object will not be able to read or write     any settings, and status() will return AccessError.      On Mac OS X, if both a name and an Internet domain are specified     for the organization, the domain is preferred over the name. On     other platforms, the name is preferred over the domain.      \sa QCoreApplication::setOrganizationName(),         QCoreApplication::setOrganizationDomain(),         QCoreApplication::setApplicationName(),         setDefaultFormat() */
end_comment
begin_constructor
DECL|function|QSettings
name|QSettings
operator|::
name|QSettings
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
name|QSettingsPrivate
operator|::
name|create
argument_list|(
name|globalDefaultFormat
argument_list|,
name|UserScope
argument_list|,
ifdef|#
directive|ifdef
name|Q_OS_MAC
name|QCoreApplication
operator|::
name|organizationDomain
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
name|QCoreApplication
operator|::
name|organizationName
argument_list|()
else|:
name|QCoreApplication
operator|::
name|organizationDomain
operator|(
operator|)
else|#
directive|else
name|QCoreApplication
operator|::
name|organizationName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
name|QCoreApplication
operator|::
name|organizationDomain
argument_list|()
else|:
name|QCoreApplication
operator|::
name|organizationName
argument_list|()
endif|#
directive|endif
argument_list|,
name|QCoreApplication
operator|::
name|applicationName
argument_list|()
argument_list|)
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_else
else|#
directive|else
end_else
begin_constructor
DECL|function|QSettings
name|QSettings
operator|::
name|QSettings
parameter_list|(
specifier|const
name|QString
modifier|&
name|organization
parameter_list|,
specifier|const
name|QString
modifier|&
name|application
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
name|QSettingsPrivate
operator|::
name|create
argument_list|(
name|globalDefaultFormat
argument_list|,
name|QSettings
operator|::
name|UserScope
argument_list|,
name|organization
argument_list|,
name|application
argument_list|)
argument_list|)
block|{
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QSettings
name|QSettings
operator|::
name|QSettings
parameter_list|(
name|Scope
name|scope
parameter_list|,
specifier|const
name|QString
modifier|&
name|organization
parameter_list|,
specifier|const
name|QString
modifier|&
name|application
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
name|QSettingsPrivate
operator|::
name|create
argument_list|(
name|globalDefaultFormat
argument_list|,
name|scope
argument_list|,
name|organization
argument_list|,
name|application
argument_list|)
argument_list|)
block|{
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QSettings
name|QSettings
operator|::
name|QSettings
parameter_list|(
name|Format
name|format
parameter_list|,
name|Scope
name|scope
parameter_list|,
specifier|const
name|QString
modifier|&
name|organization
parameter_list|,
specifier|const
name|QString
modifier|&
name|application
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
name|QSettingsPrivate
operator|::
name|create
argument_list|(
name|format
argument_list|,
name|scope
argument_list|,
name|organization
argument_list|,
name|application
argument_list|)
argument_list|)
block|{
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QSettings
name|QSettings
operator|::
name|QSettings
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|Format
name|format
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
name|QSettingsPrivate
operator|::
name|create
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|)
argument_list|)
block|{
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Destroys the QSettings object.      Any unsaved changes will eventually be written to permanent     storage.      \sa sync() */
end_comment
begin_destructor
DECL|function|~QSettings
name|QSettings
operator|::
name|~
name|QSettings
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pendingChanges
condition|)
block|{
name|QT_TRY
block|{
name|d
operator|->
name|flush
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
empty_stmt|;
comment|// ok. then don't flush but at least don't throw in the destructor
block|}
block|}
block|}
end_destructor
begin_comment
comment|/*!     Removes all entries in the primary location associated to this     QSettings object.      Entries in fallback locations are not removed.      If you only want to remove the entries in the current group(),     use remove("") instead.      \sa remove(), setFallbacksEnabled() */
end_comment
begin_function
DECL|function|clear
name|void
name|QSettings
operator|::
name|clear
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|requestUpdate
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Writes any unsaved changes to permanent storage, and reloads any     settings that have been changed in the meantime by another     application.      This function is called automatically from QSettings's destructor and     by the event loop at regular intervals, so you normally don't need to     call it yourself.      \sa status() */
end_comment
begin_function
DECL|function|sync
name|void
name|QSettings
operator|::
name|sync
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
name|d
operator|->
name|sync
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the path where settings written using this QSettings     object are stored.      On Windows, if the format is QSettings::NativeFormat, the return value     is a system registry path, not a file path.      \sa isWritable(), format() */
end_comment
begin_function
DECL|function|fileName
name|QString
name|QSettings
operator|::
name|fileName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fileName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the format used for storing the settings.      \sa defaultFormat(), fileName(), scope(), organizationName(), applicationName() */
end_comment
begin_function
DECL|function|format
name|QSettings
operator|::
name|Format
name|QSettings
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|format
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the scope used for storing the settings.      \sa format(), organizationName(), applicationName() */
end_comment
begin_function
DECL|function|scope
name|QSettings
operator|::
name|Scope
name|QSettings
operator|::
name|scope
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|scope
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the organization name used for storing the settings.      \sa QCoreApplication::organizationName(), format(), scope(), applicationName() */
end_comment
begin_function
DECL|function|organizationName
name|QString
name|QSettings
operator|::
name|organizationName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|organizationName
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the application name used for storing the settings.      \sa QCoreApplication::applicationName(), format(), scope(), organizationName() */
end_comment
begin_function
DECL|function|applicationName
name|QString
name|QSettings
operator|::
name|applicationName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|applicationName
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
end_ifndef
begin_comment
comment|/*!     \since 4.5      Sets the codec for accessing INI files (including \c .conf files on Unix)     to \a codec. The codec is used for decoding any data that is read from     the INI file, and for encoding any data that is written to the file. By     default, no codec is used, and non-ASCII characters are encoded using     standard INI escape sequences.      \warning The codec must be set immediately after creating the QSettings     object, before accessing any data.      \sa iniCodec() */
end_comment
begin_function
DECL|function|setIniCodec
name|void
name|QSettings
operator|::
name|setIniCodec
parameter_list|(
name|QTextCodec
modifier|*
name|codec
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
name|d
operator|->
name|iniCodec
operator|=
name|codec
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     \overload      Sets the codec for accessing INI files (including \c .conf files on Unix)     to the QTextCodec for the encoding specified by \a codecName. Common     values for \c codecName include "ISO 8859-1", "UTF-8", and "UTF-16".     If the encoding isn't recognized, nothing happens.      \sa QTextCodec::codecForName() */
end_comment
begin_function
DECL|function|setIniCodec
name|void
name|QSettings
operator|::
name|setIniCodec
parameter_list|(
specifier|const
name|char
modifier|*
name|codecName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
if|if
condition|(
name|QTextCodec
modifier|*
name|codec
init|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|codecName
argument_list|)
condition|)
name|d
operator|->
name|iniCodec
operator|=
name|codec
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the codec that is used for accessing INI files. By default,     no codec is used, so a null pointer is returned. */
end_comment
begin_function
DECL|function|iniCodec
name|QTextCodec
modifier|*
name|QSettings
operator|::
name|iniCodec
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|iniCodec
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTCODEC
end_comment
begin_comment
comment|/*!     Returns a status code indicating the first error that was met by     QSettings, or QSettings::NoError if no error occurred.      Be aware that QSettings delays performing some operations. For this     reason, you might want to call sync() to ensure that the data stored     in QSettings is written to disk before calling status().      \sa sync() */
end_comment
begin_function
DECL|function|status
name|QSettings
operator|::
name|Status
name|QSettings
operator|::
name|status
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|status
return|;
block|}
end_function
begin_comment
comment|/*!     Appends \a prefix to the current group.      The current group is automatically prepended to all keys     specified to QSettings. In addition, query functions such as     childGroups(), childKeys(), and allKeys() are based on the group.     By default, no group is set.      Groups are useful to avoid typing in the same setting paths over     and over. For example:      \snippet code/src_corelib_io_qsettings.cpp 13      This will set the value of three settings:      \list     \li \c mainwindow/size     \li \c mainwindow/fullScreen     \li \c outputpanel/visible     \endlist      Call endGroup() to reset the current group to what it was before     the corresponding beginGroup() call. Groups can be nested.      \sa endGroup(), group() */
end_comment
begin_function
DECL|function|beginGroup
name|void
name|QSettings
operator|::
name|beginGroup
parameter_list|(
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
name|d
operator|->
name|beginGroupOrArray
argument_list|(
name|QSettingsGroup
argument_list|(
name|d
operator|->
name|normalizedKey
argument_list|(
name|prefix
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resets the group to what it was before the corresponding     beginGroup() call.      Example:      \snippet code/src_corelib_io_qsettings.cpp 14      \sa beginGroup(), group() */
end_comment
begin_function
DECL|function|endGroup
name|void
name|QSettings
operator|::
name|endGroup
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|groupStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSettings::endGroup: No matching beginGroup()"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QSettingsGroup
name|group
init|=
name|d
operator|->
name|groupStack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|group
operator|.
name|toString
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|d
operator|->
name|groupPrefix
operator|.
name|truncate
argument_list|(
name|d
operator|->
name|groupPrefix
operator|.
name|size
argument_list|()
operator|-
operator|(
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|.
name|isArray
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QSettings::endGroup: Expected endArray() instead"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current group.      \sa beginGroup(), endGroup() */
end_comment
begin_function
DECL|function|group
name|QString
name|QSettings
operator|::
name|group
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|groupPrefix
operator|.
name|left
argument_list|(
name|d
operator|->
name|groupPrefix
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Adds \a prefix to the current group and starts reading from an     array. Returns the size of the array.      Example:      \snippet code/src_corelib_io_qsettings.cpp 15      Use beginWriteArray() to write the array in the first place.      \sa beginWriteArray(), endArray(), setArrayIndex() */
end_comment
begin_function
DECL|function|beginReadArray
name|int
name|QSettings
operator|::
name|beginReadArray
parameter_list|(
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
name|d
operator|->
name|beginGroupOrArray
argument_list|(
name|QSettingsGroup
argument_list|(
name|d
operator|->
name|normalizedKey
argument_list|(
name|prefix
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"size"
argument_list|)
argument_list|)
operator|.
name|toInt
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Adds \a prefix to the current group and starts writing an array     of size \a size. If \a size is -1 (the default), it is automatically     determined based on the indexes of the entries written.      If you have many occurrences of a certain set of keys, you can     use arrays to make your life easier. For example, let's suppose     that you want to save a variable-length list of user names and     passwords. You could then write:      \snippet code/src_corelib_io_qsettings.cpp 16      The generated keys will have the form      \list     \li \c logins/size     \li \c logins/1/userName     \li \c logins/1/password     \li \c logins/2/userName     \li \c logins/2/password     \li \c logins/3/userName     \li \c logins/3/password     \li ...     \endlist      To read back an array, use beginReadArray().      \sa beginReadArray(), endArray(), setArrayIndex() */
end_comment
begin_function
DECL|function|beginWriteArray
name|void
name|QSettings
operator|::
name|beginWriteArray
parameter_list|(
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
name|d
operator|->
name|beginGroupOrArray
argument_list|(
name|QSettingsGroup
argument_list|(
name|d
operator|->
name|normalizedKey
argument_list|(
name|prefix
argument_list|)
argument_list|,
name|size
operator|<
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|remove
argument_list|(
name|QLatin1String
argument_list|(
literal|"size"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|setValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"size"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Closes the array that was started using beginReadArray() or     beginWriteArray().      \sa beginReadArray(), beginWriteArray() */
end_comment
begin_function
DECL|function|endArray
name|void
name|QSettings
operator|::
name|endArray
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|groupStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSettings::endArray: No matching beginArray()"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QSettingsGroup
name|group
init|=
name|d
operator|->
name|groupStack
operator|.
name|top
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|group
operator|.
name|toString
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|d
operator|->
name|groupStack
operator|.
name|pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|d
operator|->
name|groupPrefix
operator|.
name|truncate
argument_list|(
name|d
operator|->
name|groupPrefix
operator|.
name|size
argument_list|()
operator|-
operator|(
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|.
name|arraySizeGuess
argument_list|()
operator|!=
operator|-
literal|1
condition|)
name|setValue
argument_list|(
name|group
operator|.
name|name
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|"/size"
argument_list|)
argument_list|,
name|group
operator|.
name|arraySizeGuess
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|group
operator|.
name|isArray
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QSettings::endArray: Expected endGroup() instead"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the current array index to \a i. Calls to functions such as     setValue(), value(), remove(), and contains() will operate on the     array entry at that index.      You must call beginReadArray() or beginWriteArray() before you     can call this function. */
end_comment
begin_function
DECL|function|setArrayIndex
name|void
name|QSettings
operator|::
name|setArrayIndex
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|groupStack
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|d
operator|->
name|groupStack
operator|.
name|top
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSettings::setArrayIndex: Missing beginArray()"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QSettingsGroup
modifier|&
name|top
init|=
name|d
operator|->
name|groupStack
operator|.
name|top
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|top
operator|.
name|toString
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|top
operator|.
name|setArrayIndex
argument_list|(
name|qMax
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|groupPrefix
operator|.
name|replace
argument_list|(
name|d
operator|->
name|groupPrefix
operator|.
name|size
argument_list|()
operator|-
name|len
operator|-
literal|1
argument_list|,
name|len
argument_list|,
name|top
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all keys, including subkeys, that can be read     using the QSettings object.      Example:      \snippet code/src_corelib_io_qsettings.cpp 17      If a group is set using beginGroup(), only the keys in the group     are returned, without the group prefix:      \snippet code/src_corelib_io_qsettings.cpp 18      \sa childGroups(), childKeys() */
end_comment
begin_function
DECL|function|allKeys
name|QStringList
name|QSettings
operator|::
name|allKeys
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|children
argument_list|(
name|d
operator|->
name|groupPrefix
argument_list|,
name|QSettingsPrivate
operator|::
name|AllKeys
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all top-level keys that can be read using the     QSettings object.      Example:      \snippet code/src_corelib_io_qsettings.cpp 19      If a group is set using beginGroup(), the top-level keys in that     group are returned, without the group prefix:      \snippet code/src_corelib_io_qsettings.cpp 20      You can navigate through the entire setting hierarchy using     childKeys() and childGroups() recursively.      \sa childGroups(), allKeys() */
end_comment
begin_function
DECL|function|childKeys
name|QStringList
name|QSettings
operator|::
name|childKeys
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|children
argument_list|(
name|d
operator|->
name|groupPrefix
argument_list|,
name|QSettingsPrivate
operator|::
name|ChildKeys
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all key top-level groups that contain keys that     can be read using the QSettings object.      Example:      \snippet code/src_corelib_io_qsettings.cpp 21      If a group is set using beginGroup(), the first-level keys in     that group are returned, without the group prefix.      \snippet code/src_corelib_io_qsettings.cpp 22      You can navigate through the entire setting hierarchy using     childKeys() and childGroups() recursively.      \sa childKeys(), allKeys() */
end_comment
begin_function
DECL|function|childGroups
name|QStringList
name|QSettings
operator|::
name|childGroups
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|children
argument_list|(
name|d
operator|->
name|groupPrefix
argument_list|,
name|QSettingsPrivate
operator|::
name|ChildGroups
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if settings can be written using this QSettings     object; returns false otherwise.      One reason why isWritable() might return false is if     QSettings operates on a read-only file.      \warning This function is not perfectly reliable, because the     file permissions can change at any time.      \sa fileName(), status(), sync() */
end_comment
begin_function
DECL|function|isWritable
name|bool
name|QSettings
operator|::
name|isWritable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|isWritable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!      Sets the value of setting \a key to \a value. If the \a key already   exists, the previous value is overwritten.    Note that the Windows registry and INI files use case-insensitive   keys, whereas the Carbon Preferences API on Mac OS X uses   case-sensitive keys. To avoid portability problems, see the   \l{Section and Key Syntax} rules.    Example:    \snippet code/src_corelib_io_qsettings.cpp 23    \sa value(), remove(), contains() */
end_comment
begin_function
DECL|function|setValue
name|void
name|QSettings
operator|::
name|setValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
name|QString
name|k
init|=
name|d
operator|->
name|actualKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|d
operator|->
name|set
argument_list|(
name|k
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|d
operator|->
name|requestUpdate
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes the setting \a key and any sub-settings of \a key.      Example:      \snippet code/src_corelib_io_qsettings.cpp 24      Be aware that if one of the fallback locations contains a setting     with the same key, that setting will be visible after calling     remove().      If \a key is an empty string, all keys in the current group() are     removed. For example:      \snippet code/src_corelib_io_qsettings.cpp 25      Note that the Windows registry and INI files use case-insensitive     keys, whereas the Carbon Preferences API on Mac OS X uses     case-sensitive keys. To avoid portability problems, see the     \l{Section and Key Syntax} rules.      \sa setValue(), value(), contains() */
end_comment
begin_function
DECL|function|remove
name|void
name|QSettings
operator|::
name|remove
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
comment|/*         We cannot use actualKey(), because remove() supports empty         keys. The code is also tricky because of slash handling.     */
name|QString
name|theKey
init|=
name|d
operator|->
name|normalizedKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|theKey
operator|.
name|isEmpty
argument_list|()
condition|)
name|theKey
operator|=
name|group
argument_list|()
expr_stmt|;
else|else
name|theKey
operator|.
name|prepend
argument_list|(
name|d
operator|->
name|groupPrefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|theKey
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|remove
argument_list|(
name|theKey
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|requestUpdate
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if there exists a setting called \a key; returns     false otherwise.      If a group is set using beginGroup(), \a key is taken to be     relative to that group.      Note that the Windows registry and INI files use case-insensitive     keys, whereas the Carbon Preferences API on Mac OS X uses     case-sensitive keys. To avoid portability problems, see the     \l{Section and Key Syntax} rules.      \sa value(), setValue() */
end_comment
begin_function
DECL|function|contains
name|bool
name|QSettings
operator|::
name|contains
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
name|QString
name|k
init|=
name|d
operator|->
name|actualKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|get
argument_list|(
name|k
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets whether fallbacks are enabled to \a b.      By default, fallbacks are enabled.      \sa fallbacksEnabled() */
end_comment
begin_function
DECL|function|setFallbacksEnabled
name|void
name|QSettings
operator|::
name|setFallbacksEnabled
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
name|d
operator|->
name|fallbacks
operator|=
operator|!
operator|!
name|b
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if fallbacks are enabled; returns false otherwise.      By default, fallbacks are enabled.      \sa setFallbacksEnabled() */
end_comment
begin_function
DECL|function|fallbacksEnabled
name|bool
name|QSettings
operator|::
name|fallbacksEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fallbacks
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QSettings
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSettings
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|UpdateRequest
condition|)
block|{
name|d
operator|->
name|update
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|QObject
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Returns the value for setting \a key. If the setting doesn't     exist, returns \a defaultValue.      If no default value is specified, a default QVariant is     returned.      Note that the Windows registry and INI files use case-insensitive     keys, whereas the Carbon Preferences API on Mac OS X uses     case-sensitive keys. To avoid portability problems, see the     \l{Section and Key Syntax} rules.      Example:      \snippet code/src_corelib_io_qsettings.cpp 26      \sa setValue(), contains(), remove() */
end_comment
begin_function
DECL|function|value
name|QVariant
name|QSettings
operator|::
name|value
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|defaultValue
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSettings
argument_list|)
expr_stmt|;
name|QVariant
name|result
init|=
name|defaultValue
decl_stmt|;
name|QString
name|k
init|=
name|d
operator|->
name|actualKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|d
operator|->
name|get
argument_list|(
name|k
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the default file format to the given \a format, which is used     for storing settings for the QSettings(QObject *) constructor.      If no default format is set, QSettings::NativeFormat is used. See     the documentation for the QSettings constructor you are using to     see if that constructor will ignore this function.      \sa format() */
end_comment
begin_function
DECL|function|setDefaultFormat
name|void
name|QSettings
operator|::
name|setDefaultFormat
parameter_list|(
name|Format
name|format
parameter_list|)
block|{
name|globalDefaultFormat
operator|=
name|format
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns default file format used for storing settings for the QSettings(QObject *) constructor.     If no default format is set, QSettings::NativeFormat is used.      \sa format() */
end_comment
begin_function
DECL|function|defaultFormat
name|QSettings
operator|::
name|Format
name|QSettings
operator|::
name|defaultFormat
parameter_list|()
block|{
return|return
name|globalDefaultFormat
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use setPath() instead.      \oldcode         setSystemIniPath(path);     \newcode         setPath(QSettings::NativeFormat, QSettings::SystemScope, path);         setPath(QSettings::IniFormat, QSettings::SystemScope, path);     \endcode */
end_comment
begin_function
DECL|function|setSystemIniPath
name|void
name|QSettings
operator|::
name|setSystemIniPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|dir
parameter_list|)
block|{
name|setPath
argument_list|(
name|IniFormat
argument_list|,
name|SystemScope
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
name|setPath
argument_list|(
name|NativeFormat
argument_list|,
name|SystemScope
argument_list|,
name|dir
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use setPath() instead. */
end_comment
begin_function
DECL|function|setUserIniPath
name|void
name|QSettings
operator|::
name|setUserIniPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|dir
parameter_list|)
block|{
name|setPath
argument_list|(
name|IniFormat
argument_list|,
name|UserScope
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
name|setPath
argument_list|(
name|NativeFormat
argument_list|,
name|UserScope
argument_list|,
name|dir
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Sets the path used for storing settings for the given \a format     and \a scope, to \a path. The \a format can be a custom format.      The table below summarizes the default values:      \table     \header \li Platform         \li Format                       \li Scope       \li Path     \row    \li{1,2} Windows     \li{1,2} IniFormat               \li UserScope   \li \c %APPDATA%     \row                                                        \li SystemScope \li \c %COMMON_APPDATA%     \row    \li{1,2} Unix        \li{1,2} NativeFormat, IniFormat \li UserScope   \li \c $HOME/.config     \row                                                        \li SystemScope \li \c /etc/xdg     \row    \li{1,2} Qt for Embedded Linux \li{1,2} NativeFormat, IniFormat \li UserScope   \li \c $HOME/Settings     \row                                                        \li SystemScope \li \c /etc/xdg     \row    \li{1,2} Mac OS X    \li{1,2} IniFormat               \li UserScope   \li \c $HOME/.config     \row                                                        \li SystemScope \li \c /etc/xdg     \endtable      The default UserScope paths on Unix and Mac OS X (\c     $HOME/.config or $HOME/Settings) can be overridden by the user by setting the     \c XDG_CONFIG_HOME environment variable. The default SystemScope     paths on Unix and Mac OS X (\c /etc/xdg) can be overridden when     building the Qt library using the \c configure script's \c     --sysconfdir flag (see QLibraryInfo for details).      Setting the NativeFormat paths on Windows and Mac OS X has no     effect.      \warning This function doesn't affect existing QSettings objects.      \sa registerFormat() */
end_comment
begin_function
DECL|function|setPath
name|void
name|QSettings
operator|::
name|setPath
parameter_list|(
name|Format
name|format
parameter_list|,
name|Scope
name|scope
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|settingsGlobalMutex
argument_list|)
decl_stmt|;
name|PathHash
modifier|*
name|pathHash
init|=
name|pathHashFunc
argument_list|()
decl_stmt|;
if|if
condition|(
name|pathHash
operator|->
name|isEmpty
argument_list|()
condition|)
name|initDefaultPaths
argument_list|(
operator|&
name|locker
argument_list|)
expr_stmt|;
name|pathHash
operator|->
name|insert
argument_list|(
name|pathHashKey
argument_list|(
name|format
argument_list|,
name|scope
argument_list|)
argument_list|,
name|path
operator|+
name|QDir
operator|::
name|separator
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \typedef QSettings::SettingsMap      Typedef for QMap<QString, QVariant>. 	     \sa registerFormat() */
end_comment
begin_comment
comment|/*!     \typedef QSettings::ReadFunc      Typedef for a pointer to a function with the following signature:      \snippet code/src_corelib_io_qsettings.cpp 27      \c ReadFunc is used in \c registerFormat() as a pointer to a function     that reads a set of key/value pairs. \c ReadFunc should read all the      options in one pass, and return all the settings in the \c SettingsMap      container, which is initially empty.      \sa WriteFunc, registerFormat() */
end_comment
begin_comment
comment|/*!     \typedef QSettings::WriteFunc      Typedef for a pointer to a function with the following signature:      \snippet code/src_corelib_io_qsettings.cpp 28      \c WriteFunc is used in \c registerFormat() as a pointer to a function      that writes a set of key/value pairs. \c WriteFunc is only called once,     so you need to output the settings in one go.      \sa ReadFunc, registerFormat() */
end_comment
begin_comment
comment|/*!     \since 4.1     \threadsafe      Registers a custom storage format. On success, returns a special     Format value that can then be passed to the QSettings constructor.     On failure, returns InvalidFormat.      The \a extension is the file     extension associated to the format (without the '.').      The \a readFunc and \a writeFunc parameters are pointers to     functions that read and write a set of key/value pairs. The     QIODevice parameter to the read and write functions is always     opened in binary mode (i.e., without the QIODevice::Text flag).      The \a caseSensitivity parameter specifies whether keys are case     sensitive or not. This makes a difference when looking up values     using QSettings. The default is case sensitive.      By default, if you use one of the constructors that work in terms     of an organization name and an application name, the file system     locations used are the same as for IniFormat. Use setPath() to     specify other locations.      Example:      \snippet code/src_corelib_io_qsettings.cpp 29      \sa setPath() */
end_comment
begin_function
DECL|function|registerFormat
name|QSettings
operator|::
name|Format
name|QSettings
operator|::
name|registerFormat
parameter_list|(
specifier|const
name|QString
modifier|&
name|extension
parameter_list|,
name|ReadFunc
name|readFunc
parameter_list|,
name|WriteFunc
name|writeFunc
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|caseSensitivity
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_QSETTINGS_ALWAYS_CASE_SENSITIVE_AND_FORGET_ORIGINAL_KEY_ORDER
name|Q_ASSERT
argument_list|(
name|caseSensitivity
operator|==
name|Qt
operator|::
name|CaseSensitive
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|settingsGlobalMutex
argument_list|)
decl_stmt|;
name|CustomFormatVector
modifier|*
name|customFormatVector
init|=
name|customFormatVectorFunc
argument_list|()
decl_stmt|;
name|int
name|index
init|=
name|customFormatVector
operator|->
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|16
condition|)
comment|// the QSettings::Format enum has room for 16 custom formats
return|return
name|QSettings
operator|::
name|InvalidFormat
return|;
name|QConfFileCustomFormat
name|info
decl_stmt|;
name|info
operator|.
name|extension
operator|=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|info
operator|.
name|extension
operator|+=
name|extension
expr_stmt|;
name|info
operator|.
name|readFunc
operator|=
name|readFunc
expr_stmt|;
name|info
operator|.
name|writeFunc
operator|=
name|writeFunc
expr_stmt|;
name|info
operator|.
name|caseSensitivity
operator|=
name|caseSensitivity
expr_stmt|;
name|customFormatVector
operator|->
name|append
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|QSettings
operator|::
name|Format
argument_list|(
operator|(
name|int
operator|)
name|QSettings
operator|::
name|CustomFormat1
operator|+
name|index
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_SETTINGS
end_comment
end_unit
