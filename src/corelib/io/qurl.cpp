begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Copyright (C) 2012 Intel Corporation. ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QUrl      \brief The QUrl class provides a convenient interface for working     with URLs.      \reentrant     \ingroup io     \ingroup network     \ingroup shared       It can parse and construct URLs in both encoded and unencoded     form. QUrl also has support for internationalized domain names     (IDNs).      The most common way to use QUrl is to initialize it via the     constructor by passing a QString. Otherwise, setUrl() and     setEncodedUrl() can also be used.      URLs can be represented in two forms: encoded or unencoded. The     unencoded representation is suitable for showing to users, but     the encoded representation is typically what you would send to     a web server. For example, the unencoded URL     "http://b\\uuml\c{}hler.example.com" would be sent to the server as     "http://xn--bhler-kva.example.com/List%20of%20applicants.xml".      A URL can also be constructed piece by piece by calling     setScheme(), setUserName(), setPassword(), setHost(), setPort(),     setPath(), setEncodedQuery() and setFragment(). Some convenience     functions are also available: setAuthority() sets the user name,     password, host and port. setUserInfo() sets the user name and     password at once.      Call isValid() to check if the URL is valid. This can be done at     any point during the constructing of a URL.      Constructing a query is particularly convenient through the use     of setQueryItems(), addQueryItem() and removeQueryItem(). Use     setQueryDelimiters() to customize the delimiters used for     generating the query string.      For the convenience of generating encoded URL strings or query     strings, there are two static functions called     fromPercentEncoding() and toPercentEncoding() which deal with     percent encoding and decoding of QStrings.      Calling isRelative() will tell whether or not the URL is     relative. A relative URL can be resolved by passing it as argument     to resolved(), which returns an absolute URL. isParentOf() is used     for determining whether one URL is a parent of another.      fromLocalFile() constructs a QUrl by parsing a local     file path. toLocalFile() converts a URL to a local file path.      The human readable representation of the URL is fetched with     toString(). This representation is appropriate for displaying a     URL to a user in unencoded form. The encoded form however, as     returned by toEncoded(), is for internal use, passing to web     servers, mail clients and so on.      QUrl conforms to the URI specification from     \l{RFC 3986} (Uniform Resource Identifier: Generic Syntax), and includes     scheme extensions from \l{RFC 1738} (Uniform Resource Locators). Case     folding rules in QUrl conform to \l{RFC 3491} (Nameprep: A Stringprep     Profile for Internationalized Domain Names (IDN)).      \section2 Character Conversions      Follow these rules to avoid erroneous character conversion when     dealing with URLs and strings:      \list     \li When creating an QString to contain a URL from a QByteArray or a        char*, always use QString::fromUtf8().     \endlist      \sa QUrlInfo */
end_comment
begin_comment
comment|/*!     \enum QUrl::ParsingMode      The parsing mode controls the way QUrl parses strings.      \value TolerantMode QUrl will try to correct some common errors in URLs.                         This mode is useful for parsing URLs coming from sources                         not known to be strictly standards-conforming.      \value StrictMode Only valid URLs are accepted. This mode is useful for                       general URL validation.      In TolerantMode, the parser has the following behaviour:      \list      \li Spaces and "%20": unencoded space characters will be accepted and will     be treated as equivalent to "%20".      \li Single "%" characters: Any occurrences of a percent character "%" not     followed by exactly two hexadecimal characters (e.g., "13% coverage.html")     will be replaced by "%25". Note that one lone "%" character will trigger     the correction mode for all percent characters.      \li Reserved and unreserved characters: An encoded URL should only     contain a few characters as literals; all other characters should     be percent-encoded. In TolerantMode, these characters will be     automatically percent-encoded where they are not allowed:             space / double-quote / "<" / ">" / "\" /             "^" / "`" / "{" / "|" / "}"     Those same characters can be decoded again by passing QUrl::DecodeReserved     to toString() or toEncoded().      \endlist      When in StrictMode, if a parsing error is found, isValid() will return \c     false and errorString() will return a simple message describing the error.     If more than one error is detected, it is undefined which error gets     reported.      Note that TolerantMode is not usually enough for parsing user input, which     often contains more errors and expectations than the parser can deal with.     When dealing with data coming directly from the user -- as opposed to data     coming from data-transfer sources, such as other programs -- it is     recommended to use fromUserInput().      \sa fromUserInput(), setUrl(), toString(), toEncoded(), QUrl::FormattingOptions */
end_comment
begin_comment
comment|/*!     \enum QUrl::FormattingOptions      The formatting options define how the URL is formatted when written out     as text.      \value None The format of the URL is unchanged.     \value RemoveScheme  The scheme is removed from the URL.     \value RemovePassword  Any password in the URL is removed.     \value RemoveUserInfo  Any user information in the URL is removed.     \value RemovePort      Any specified port is removed from the URL.     \value RemoveAuthority     \value RemovePath   The URL's path is removed, leaving only the scheme,                         host address, and port (if present).     \value RemoveQuery  The query part of the URL (following a '?' character)                         is removed.     \value RemoveFragment     \value PreferLocalFile If the URL is a local file according to isLocalFile()      and contains no query or fragment, a local file path is returned.     \value StripTrailingSlash  The trailing slash is removed if one is present.      Note that the case folding rules in \l{RFC 3491}{Nameprep}, which QUrl     conforms to, require host names to always be converted to lower case,     regardless of the Qt::FormattingOptions used.      The options from QUrl::ComponentFormattingOptions are also possible.      \sa QUrl::ComponentFormattingOptions */
end_comment
begin_comment
comment|/*!     \enum QUrl::ComponentFormattingOptions     \since 5.0      The component formatting options define how the components of an URL will     be formatted when written out as text. They can be combined with the     options from QUrl::FormattingOptions when used in toString() and     toEncoded().      \value PrettyDecoded   The component is returned in a "pretty form", with                            most percent-encoded characters decoded. The exact                            behavior of PrettyDecoded varies from component to                            component and may also change from Qt release to Qt                            release. This is the default.      \value EncodeSpaces    Leave space characters in their encoded form ("%20").      \value EncodeUnicode   Leave non-US-ASCII characters encoded in their UTF-8                            percent-encoded form (e.g., "%C3%A9" for the U+00E9                            codepoint, LATIN SMALL LETTER E WITH ACUTE).      \value EncodeDelimiters Leave certain delimiters in their encoded form, as                             would appear in the URL when the full URL is                             represented as text. The delimiters are affected                             by this option change from component to component.      \value EncodeReserved  Leave the US-ASCII reserved characters in their encoded                            forms.      \value DecodeReseved   Decode the US-ASCII reserved characters.      \value FullyEncoded    Leave all characters in their properly-encoded form,                            as this component would appear as part of a URL. When                            used with toString(), this produces a fully-compliant                            URL in QString form, exactly equal to the result of                            toEncoded()      \value MostDecoded     Attempt to decode as much as possible. For individual                            components of the URL, this decodes every percent                            encoding sequence, control characters (U+0000 to U+001F)                            and non-US-ASCII sequences that aren't valid UTF-8                            sequences.      The values of EncodeReserved and DecodeReserved should not be used together     in one call. The behaviour is undefined if that happens. They are provided     as separate values because the behaviour of the "pretty mode" with regards     to reserved characters is different on certain components and specially on     the full URL.      \sa QUrl::FormattingOptions */
end_comment
begin_include
include|#
directive|include
file|"qurl.h"
end_include
begin_include
include|#
directive|include
file|"qurl_p.h"
end_include
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|"qdir.h"
end_include
begin_comment
comment|// for QDir::fromNativeSeparators
end_comment
begin_include
include|#
directive|include
file|"qtldurl_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qipaddress_p.h"
end_include
begin_include
include|#
directive|include
file|"qurlquery.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE_WM
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|optimize
name|(
literal|"g"
name|,
name|off
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|isHex
specifier|inline
specifier|static
name|bool
name|isHex
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|c
operator||=
literal|0x20
expr_stmt|;
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|toHex
specifier|static
specifier|inline
name|char
name|toHex
parameter_list|(
name|quint8
name|c
parameter_list|)
block|{
return|return
name|c
operator|>
literal|9
condition|?
name|c
operator|-
literal|10
operator|+
literal|'A'
else|:
name|c
operator|+
literal|'0'
return|;
block|}
end_function
begin_function
DECL|function|fromHex
specifier|static
specifier|inline
name|quint8
name|fromHex
parameter_list|(
name|quint8
name|c
parameter_list|)
block|{
name|c
operator||=
literal|0x20
expr_stmt|;
return|return
name|c
operator|>=
literal|'a'
condition|?
name|c
operator|-
literal|'a'
operator|+
literal|10
else|:
name|c
operator|-
literal|'0'
return|;
block|}
end_function
begin_function
DECL|function|ftpScheme
specifier|static
specifier|inline
name|QString
name|ftpScheme
parameter_list|()
block|{
return|return
name|QStringLiteral
argument_list|(
literal|"ftp"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|httpScheme
specifier|static
specifier|inline
name|QString
name|httpScheme
parameter_list|()
block|{
return|return
name|QStringLiteral
argument_list|(
literal|"http"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fileScheme
specifier|static
specifier|inline
name|QString
name|fileScheme
parameter_list|()
block|{
return|return
name|QStringLiteral
argument_list|(
literal|"file"
argument_list|)
return|;
block|}
end_function
begin_constructor
DECL|function|QUrlPrivate
name|QUrlPrivate
operator|::
name|QUrlPrivate
parameter_list|()
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|port
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|errorCode
argument_list|(
name|NoError
argument_list|)
member_init_list|,
name|errorSupplement
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|sectionIsPresent
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|sectionHasError
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QUrlPrivate
name|QUrlPrivate
operator|::
name|QUrlPrivate
parameter_list|(
specifier|const
name|QUrlPrivate
modifier|&
name|copy
parameter_list|)
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|port
argument_list|(
name|copy
operator|.
name|port
argument_list|)
member_init_list|,
name|scheme
argument_list|(
name|copy
operator|.
name|scheme
argument_list|)
member_init_list|,
name|userName
argument_list|(
name|copy
operator|.
name|userName
argument_list|)
member_init_list|,
name|password
argument_list|(
name|copy
operator|.
name|password
argument_list|)
member_init_list|,
name|host
argument_list|(
name|copy
operator|.
name|host
argument_list|)
member_init_list|,
name|path
argument_list|(
name|copy
operator|.
name|path
argument_list|)
member_init_list|,
name|query
argument_list|(
name|copy
operator|.
name|query
argument_list|)
member_init_list|,
name|fragment
argument_list|(
name|copy
operator|.
name|fragment
argument_list|)
member_init_list|,
name|errorCode
argument_list|(
name|copy
operator|.
name|errorCode
argument_list|)
member_init_list|,
name|errorSupplement
argument_list|(
name|copy
operator|.
name|errorSupplement
argument_list|)
member_init_list|,
name|sectionIsPresent
argument_list|(
name|copy
operator|.
name|sectionIsPresent
argument_list|)
member_init_list|,
name|sectionHasError
argument_list|(
name|copy
operator|.
name|sectionHasError
argument_list|)
block|{ }
end_constructor
begin_comment
comment|// From RFC 3896, Appendix A Collected ABNF for URI
end_comment
begin_comment
comment|//    URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
end_comment
begin_comment
comment|//[...]
end_comment
begin_comment
comment|//    scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    authority     = [ userinfo "@" ] host [ ":" port ]
end_comment
begin_comment
comment|//    userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
end_comment
begin_comment
comment|//    host          = IP-literal / IPv4address / reg-name
end_comment
begin_comment
comment|//    port          = *DIGIT
end_comment
begin_comment
comment|//[...]
end_comment
begin_comment
comment|//    reg-name      = *( unreserved / pct-encoded / sub-delims )
end_comment
begin_comment
comment|//[..]
end_comment
begin_comment
comment|//    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    query         = *( pchar / "/" / "?" )
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    fragment      = *( pchar / "/" / "?" )
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    pct-encoded   = "%" HEXDIG HEXDIG
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
end_comment
begin_comment
comment|//    reserved      = gen-delims / sub-delims
end_comment
begin_comment
comment|//    gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
end_comment
begin_comment
comment|//    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
end_comment
begin_comment
comment|//                  / "*" / "+" / "," / ";" / "="
end_comment
begin_comment
comment|// the path component has a complex ABNF that basically boils down to
end_comment
begin_comment
comment|// slash-separated segments of "pchar"
end_comment
begin_comment
comment|// The above is the strict definition of the URL components and it is what we
end_comment
begin_comment
comment|// return encoded as FullyEncoded. However, we store the equivalent to
end_comment
begin_comment
comment|// PrettyDecoded internally, as that is the default formatting mode and most
end_comment
begin_comment
comment|// likely to be used. PrettyDecoded decodes spaces, unicode sequences and
end_comment
begin_comment
comment|// unambiguous delimiters.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// An ambiguous delimiter is a delimiter that, if appeared decoded, would be
end_comment
begin_comment
comment|// interpreted as the beginning of a new component. The exact delimiters that
end_comment
begin_comment
comment|// match that definition change according to the use. When each field is
end_comment
begin_comment
comment|// considered in isolation from the rest, there are no ambiguities. In other
end_comment
begin_comment
comment|// words, we always store the most decoded form (except for the query, see
end_comment
begin_comment
comment|// below).
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The ambiguities arise when components are put together. From last to first
end_comment
begin_comment
comment|// component of a full URL, the ambiguities are:
end_comment
begin_comment
comment|//  - fragment: none, since it's the last.
end_comment
begin_comment
comment|//  - query: the "#" character is ambiguous, as it starts the fragment. In
end_comment
begin_comment
comment|//    addition, the "+" character is treated specially, as should be both
end_comment
begin_comment
comment|//    intra-query delimiters. Since we don't know which ones they are, we
end_comment
begin_comment
comment|//    keep all reserved characters untouched.
end_comment
begin_comment
comment|//  - path: the "#" and "?" characters are ambigous. In addition to them,
end_comment
begin_comment
comment|//    the slash itself is considered special.
end_comment
begin_comment
comment|//  - host: completely special but never ambiguous, see setHost() below.
end_comment
begin_comment
comment|//  - password: the "#", "?", "/", "[", "]" and "@" characters are ambiguous
end_comment
begin_comment
comment|//  - username: the "#", "?", "/", "[", "]", "@", and ":" characters are ambiguous
end_comment
begin_comment
comment|//  - scheme: doesn't accept any delimiter, see setScheme() below.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// When the authority component is considered in isolation, the ambiguities of
end_comment
begin_comment
comment|// its components are:
end_comment
begin_comment
comment|//  - host: special, never ambiguous
end_comment
begin_comment
comment|//  - password: "[", "]", "@" are ambiguous
end_comment
begin_comment
comment|//  - username: "[", "]", "@", ":" are ambiguous
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Finally, when the userinfo is considered in isolation, the ambiguities of its
end_comment
begin_comment
comment|// components are:
end_comment
begin_comment
comment|//  - password: none, since it's the last
end_comment
begin_comment
comment|//  - username: ":" is ambiguous
end_comment
begin_comment
comment|// list the recoding table modifications to be used with the recodeFromUser and
end_comment
begin_comment
comment|// appendToUser functions, according to the rules above.
end_comment
begin_comment
comment|// the encodedXXX tables are run with the delimiters set to "leave" by default;
end_comment
begin_comment
comment|// the decodedXXX tables are run with the delimiters set to "decode" by default
end_comment
begin_comment
comment|// (except for the query, which doesn't use these functions)
end_comment
begin_define
DECL|macro|decode
define|#
directive|define
name|decode
parameter_list|(
name|x
parameter_list|)
value|ushort(x)
end_define
begin_define
DECL|macro|leave
define|#
directive|define
name|leave
parameter_list|(
name|x
parameter_list|)
value|ushort(0x100 | (x))
end_define
begin_define
DECL|macro|encode
define|#
directive|define
name|encode
parameter_list|(
name|x
parameter_list|)
value|ushort(0x200 | (x))
end_define
begin_decl_stmt
DECL|variable|encodedUserNameActions
specifier|static
specifier|const
name|ushort
name|encodedUserNameActions
index|[]
init|=
block|{
comment|// first field, everything must be encoded, including the ":"
comment|//    userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
name|encode
argument_list|(
literal|'/'
argument_list|)
block|,
comment|// 0
name|encode
argument_list|(
literal|'?'
argument_list|)
block|,
comment|// 1
name|encode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 2
name|encode
argument_list|(
literal|'['
argument_list|)
block|,
comment|// 3
name|encode
argument_list|(
literal|']'
argument_list|)
block|,
comment|// 4
name|encode
argument_list|(
literal|'@'
argument_list|)
block|,
comment|// 5
name|encode
argument_list|(
literal|':'
argument_list|)
block|,
comment|// 6
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedUserNameInAuthorityActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedUserNameInAuthorityActions
init|=
name|encodedUserNameActions
operator|+
literal|3
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedUserNameInUserInfoActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedUserNameInUserInfoActions
init|=
name|encodedUserNameActions
operator|+
literal|6
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedUserNameInUrlActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedUserNameInUrlActions
init|=
name|encodedUserNameActions
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedUserNameInIsolationActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedUserNameInIsolationActions
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|encodedPasswordActions
specifier|static
specifier|const
name|ushort
name|encodedPasswordActions
index|[]
init|=
block|{
comment|// same as encodedUserNameActions, but decode ":"
comment|//    userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
name|encode
argument_list|(
literal|'/'
argument_list|)
block|,
comment|// 0
name|encode
argument_list|(
literal|'?'
argument_list|)
block|,
comment|// 1
name|encode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 2
name|encode
argument_list|(
literal|'['
argument_list|)
block|,
comment|// 3
name|encode
argument_list|(
literal|']'
argument_list|)
block|,
comment|// 4
name|encode
argument_list|(
literal|'@'
argument_list|)
block|,
comment|// 5
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedPasswordInAuthorityActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedPasswordInAuthorityActions
init|=
name|encodedPasswordActions
operator|+
literal|3
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedPasswordInUserInfoActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedPasswordInUserInfoActions
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedPasswordInUrlActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedPasswordInUrlActions
init|=
name|encodedPasswordActions
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedPasswordInIsolationActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedPasswordInIsolationActions
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|encodedPathActions
specifier|static
specifier|const
name|ushort
name|encodedPathActions
index|[]
init|=
block|{
comment|//    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
name|encode
argument_list|(
literal|'['
argument_list|)
block|,
comment|// 0
name|encode
argument_list|(
literal|']'
argument_list|)
block|,
comment|// 1
name|encode
argument_list|(
literal|'?'
argument_list|)
block|,
comment|// 2
name|encode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 3
name|leave
argument_list|(
literal|'/'
argument_list|)
block|,
comment|// 4
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedPathInUrlActions
specifier|static
specifier|const
name|ushort
name|decodedPathInUrlActions
index|[]
init|=
block|{
name|decode
argument_list|(
literal|'{'
argument_list|)
block|,
comment|// 0
name|decode
argument_list|(
literal|'}'
argument_list|)
block|,
comment|// 1
name|encode
argument_list|(
literal|'?'
argument_list|)
block|,
comment|// 2
name|encode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 3
name|leave
argument_list|(
literal|'/'
argument_list|)
block|,
comment|// 4
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedPathInIsolationActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedPathInIsolationActions
init|=
name|encodedPathActions
operator|+
literal|4
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|decodedPathInIsolationActions
comment|// leave('/')
end_comment
begin_decl_stmt
DECL|variable|encodedFragmentActions
specifier|static
specifier|const
name|ushort
name|encodedFragmentActions
index|[]
init|=
block|{
comment|//    fragment      = *( pchar / "/" / "?" )
comment|// gen-delims permitted: ":" / "@" / "/" / "?"
comment|//   ->   must encode: "[" / "]" / "#"
comment|// HOWEVER: we allow "#" to remain decoded
name|decode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 0
name|decode
argument_list|(
literal|':'
argument_list|)
block|,
comment|// 1
name|decode
argument_list|(
literal|'@'
argument_list|)
block|,
comment|// 2
name|decode
argument_list|(
literal|'/'
argument_list|)
block|,
comment|// 3
name|decode
argument_list|(
literal|'?'
argument_list|)
block|,
comment|// 4
name|encode
argument_list|(
literal|'['
argument_list|)
block|,
comment|// 5
name|encode
argument_list|(
literal|']'
argument_list|)
block|,
comment|// 6
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedFragmentInUrlActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedFragmentInUrlActions
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedFragmentInIsolationActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedFragmentInIsolationActions
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|// the query is handled specially: the decodedQueryXXX tables are run with
end_comment
begin_comment
comment|// the delimiters set to "leave" by default and the others set to "encode"
end_comment
begin_decl_stmt
DECL|variable|encodedQueryActions
specifier|static
specifier|const
name|ushort
name|encodedQueryActions
index|[]
init|=
block|{
comment|//    query         = *( pchar / "/" / "?" )
comment|// gen-delims permitted: ":" / "@" / "/" / "?"
comment|// HOWEVER: we leave alone them alone, plus "[" and "]"
comment|//   ->   must encode: "#"
name|encode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 0
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedQueryInIsolationActions
specifier|static
specifier|const
name|ushort
name|decodedQueryInIsolationActions
index|[]
init|=
block|{
name|decode
argument_list|(
literal|'"'
argument_list|)
block|,
comment|// 0
name|decode
argument_list|(
literal|'<'
argument_list|)
block|,
comment|// 1
name|decode
argument_list|(
literal|'>'
argument_list|)
block|,
comment|// 2
name|decode
argument_list|(
literal|'^'
argument_list|)
block|,
comment|// 3
name|decode
argument_list|(
literal|'\\'
argument_list|)
block|,
comment|// 4
name|decode
argument_list|(
literal|'|'
argument_list|)
block|,
comment|// 5
name|decode
argument_list|(
literal|'{'
argument_list|)
block|,
comment|// 6
name|decode
argument_list|(
literal|'}'
argument_list|)
block|,
comment|// 7
name|decode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 8
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedQueryInUrlActions
specifier|static
specifier|const
name|ushort
name|decodedQueryInUrlActions
index|[]
init|=
block|{
name|decode
argument_list|(
literal|'{'
argument_list|)
block|,
comment|// 6
name|decode
argument_list|(
literal|'}'
argument_list|)
block|,
comment|// 7
name|encode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 8
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
specifier|inline
name|QString
DECL|function|recodeFromUser
name|recodeFromUser
parameter_list|(
specifier|const
name|QString
modifier|&
name|input
parameter_list|,
specifier|const
name|ushort
modifier|*
name|actions
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|QString
name|output
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|begin
init|=
name|input
operator|.
name|constData
argument_list|()
operator|+
name|from
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|end
init|=
name|input
operator|.
name|constData
argument_list|()
operator|+
name|to
decl_stmt|;
if|if
condition|(
name|qt_urlRecode
argument_list|(
name|output
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|QUrl
operator|::
name|MostDecoded
argument_list|,
name|actions
argument_list|)
condition|)
return|return
name|output
return|;
return|return
name|input
operator|.
name|mid
argument_list|(
name|from
argument_list|,
name|to
operator|-
name|from
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// appendXXXX functions:
end_comment
begin_comment
comment|// the internal value is stored in its most decoded form, so that case is easy.
end_comment
begin_comment
comment|// DecodeUnicode and DecodeSpaces are handled by qt_urlRecode.
end_comment
begin_comment
comment|// That leaves these functions to handle two cases related to delimiters:
end_comment
begin_comment
comment|//  1) encoded                           encodedXXXX tables
end_comment
begin_comment
comment|//  2) decoded                           decodedXXXX tables
end_comment
begin_function
DECL|function|appendToUser
specifier|static
specifier|inline
name|void
name|appendToUser
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|,
specifier|const
name|ushort
modifier|*
name|encodedActions
parameter_list|,
specifier|const
name|ushort
modifier|*
name|decodedActions
parameter_list|)
block|{
if|if
condition|(
name|options
operator|==
name|QUrl
operator|::
name|PrettyDecoded
condition|)
block|{
name|appendTo
operator|+=
name|value
expr_stmt|;
return|return;
block|}
specifier|const
name|ushort
modifier|*
name|actions
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|options
operator|&
name|QUrl
operator|::
name|EncodeDelimiters
condition|)
name|actions
operator|=
name|encodedActions
expr_stmt|;
else|else
name|actions
operator|=
name|decodedActions
expr_stmt|;
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|appendTo
argument_list|,
name|value
operator|.
name|constData
argument_list|()
argument_list|,
name|value
operator|.
name|constEnd
argument_list|()
argument_list|,
name|options
argument_list|,
name|actions
argument_list|)
condition|)
name|appendTo
operator|+=
name|value
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendAuthority
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendAuthority
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|,
name|Section
name|appendingTo
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveUserInfo
operator|)
operator|!=
name|QUrl
operator|::
name|RemoveUserInfo
condition|)
block|{
name|appendUserInfo
argument_list|(
name|appendTo
argument_list|,
name|options
argument_list|,
name|appendingTo
argument_list|)
expr_stmt|;
comment|// add '@' only if we added anything
if|if
condition|(
name|hasUserName
argument_list|()
operator|||
operator|(
name|hasPassword
argument_list|()
operator|&&
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemovePassword
operator|)
operator|==
literal|0
operator|)
condition|)
name|appendTo
operator|+=
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
block|}
name|appendHost
argument_list|(
name|appendTo
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemovePort
operator|)
operator|&&
name|port
operator|!=
operator|-
literal|1
condition|)
name|appendTo
operator|+=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendUserInfo
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendUserInfo
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|,
name|Section
name|appendingTo
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|userName
operator|.
name|isEmpty
argument_list|()
operator|&&
name|password
operator|.
name|isEmpty
argument_list|()
argument_list|)
condition|)
return|return;
specifier|const
name|ushort
modifier|*
name|userNameActions
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|passwordActions
decl_stmt|;
if|if
condition|(
name|options
operator|&
name|QUrl
operator|::
name|EncodeDelimiters
condition|)
block|{
name|userNameActions
operator|=
name|encodedUserNameActions
expr_stmt|;
name|passwordActions
operator|=
name|encodedPasswordActions
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|appendingTo
condition|)
block|{
case|case
name|UserInfo
case|:
name|userNameActions
operator|=
name|decodedUserNameInUserInfoActions
expr_stmt|;
name|passwordActions
operator|=
name|decodedPasswordInUserInfoActions
expr_stmt|;
break|break;
case|case
name|Authority
case|:
name|userNameActions
operator|=
name|decodedUserNameInAuthorityActions
expr_stmt|;
name|passwordActions
operator|=
name|decodedPasswordInAuthorityActions
expr_stmt|;
break|break;
case|case
name|FullUrl
case|:
default|default:
name|userNameActions
operator|=
name|decodedUserNameInUrlActions
expr_stmt|;
name|passwordActions
operator|=
name|decodedPasswordInUrlActions
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|EncodeReserved
operator|)
operator|==
literal|0
condition|)
name|options
operator||=
name|QUrl
operator|::
name|DecodeReserved
expr_stmt|;
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|appendTo
argument_list|,
name|userName
operator|.
name|constData
argument_list|()
argument_list|,
name|userName
operator|.
name|constEnd
argument_list|()
argument_list|,
name|options
argument_list|,
name|userNameActions
argument_list|)
condition|)
name|appendTo
operator|+=
name|userName
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|QUrl
operator|::
name|RemovePassword
operator|||
operator|!
name|hasPassword
argument_list|()
condition|)
block|{
return|return;
block|}
else|else
block|{
name|appendTo
operator|+=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|appendTo
argument_list|,
name|password
operator|.
name|constData
argument_list|()
argument_list|,
name|password
operator|.
name|constEnd
argument_list|()
argument_list|,
name|options
argument_list|,
name|passwordActions
argument_list|)
condition|)
name|appendTo
operator|+=
name|password
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|appendUserName
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendUserName
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
name|appendToUser
argument_list|(
name|appendTo
argument_list|,
name|userName
argument_list|,
name|options
argument_list|,
name|encodedUserNameActions
argument_list|,
name|decodedUserNameInIsolationActions
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendPassword
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendPassword
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
name|appendToUser
argument_list|(
name|appendTo
argument_list|,
name|password
argument_list|,
name|options
argument_list|,
name|encodedPasswordActions
argument_list|,
name|decodedPasswordInIsolationActions
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendPath
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendPath
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|,
name|Section
name|appendingTo
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|appendingTo
operator|!=
name|Path
operator|&&
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|EncodeDelimiters
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|appendTo
argument_list|,
name|path
operator|.
name|constData
argument_list|()
argument_list|,
name|path
operator|.
name|constEnd
argument_list|()
argument_list|,
name|options
argument_list|,
name|decodedPathInUrlActions
argument_list|)
condition|)
name|appendTo
operator|+=
name|path
expr_stmt|;
block|}
else|else
block|{
name|appendToUser
argument_list|(
name|appendTo
argument_list|,
name|path
argument_list|,
name|options
argument_list|,
name|encodedPathActions
argument_list|,
name|decodedPathInIsolationActions
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|appendFragment
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendFragment
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
name|appendToUser
argument_list|(
name|appendTo
argument_list|,
name|fragment
argument_list|,
name|options
argument_list|,
name|encodedFragmentActions
argument_list|,
name|decodedFragmentInIsolationActions
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendQuery
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendQuery
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|,
name|Section
name|appendingTo
parameter_list|)
specifier|const
block|{
comment|// almost the same code as the previous functions
comment|// except we prefer not to touch the delimiters
if|if
condition|(
name|options
operator|==
name|QUrl
operator|::
name|PrettyDecoded
operator|&&
name|appendingTo
operator|==
name|Query
condition|)
block|{
name|appendTo
operator|+=
name|query
expr_stmt|;
return|return;
block|}
specifier|const
name|ushort
modifier|*
name|actions
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|options
operator|&
name|QUrl
operator|::
name|EncodeDelimiters
condition|)
block|{
name|actions
operator|=
name|encodedQueryActions
expr_stmt|;
block|}
else|else
block|{
comment|// reset to default qt_urlRecode behaviour (leave delimiters alone)
name|options
operator||=
name|QUrl
operator|::
name|EncodeDelimiters
expr_stmt|;
name|actions
operator|=
name|appendingTo
operator|==
name|Query
condition|?
name|decodedQueryInIsolationActions
else|:
name|decodedQueryInUrlActions
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|appendTo
argument_list|,
name|query
operator|.
name|constData
argument_list|()
argument_list|,
name|query
operator|.
name|constData
argument_list|()
operator|+
name|query
operator|.
name|length
argument_list|()
argument_list|,
name|options
argument_list|,
name|actions
argument_list|)
condition|)
name|appendTo
operator|+=
name|query
expr_stmt|;
block|}
end_function
begin_comment
comment|// setXXX functions
end_comment
begin_function
DECL|function|setScheme
name|bool
name|QUrlPrivate
operator|::
name|setScheme
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|len
parameter_list|,
name|bool
name|decoded
parameter_list|)
block|{
comment|// schemes are strictly RFC-compliant:
comment|//    scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
comment|// but we need to decode any percent-encoding sequences that fall on
comment|// those characters
comment|// we also lowercase the scheme
name|scheme
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sectionIsPresent
operator||=
name|Scheme
expr_stmt|;
name|sectionHasError
operator||=
name|Scheme
expr_stmt|;
comment|// assume it has errors, we'll clear before returning true
name|errorCode
operator|=
name|SchemeEmptyError
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|false
return|;
comment|// validate it:
name|errorCode
operator|=
name|InvalidSchemeError
expr_stmt|;
name|int
name|needsLowercasing
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|p
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|value
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|>=
literal|'a'
operator|&&
name|p
index|[
name|i
index|]
operator|<=
literal|'z'
condition|)
continue|continue;
if|if
condition|(
name|p
index|[
name|i
index|]
operator|>=
literal|'A'
operator|&&
name|p
index|[
name|i
index|]
operator|<=
literal|'Z'
condition|)
block|{
name|needsLowercasing
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|p
index|[
name|i
index|]
operator|<=
literal|'9'
operator|&&
name|i
operator|>
literal|0
condition|)
continue|continue;
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
name|i
index|]
operator|==
literal|'-'
operator|||
name|p
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
continue|continue;
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|'%'
condition|)
block|{
comment|// found a percent-encoded sign
comment|// if we haven't decoded yet, decode and try again
name|errorSupplement
operator|=
literal|'%'
expr_stmt|;
if|if
condition|(
name|decoded
condition|)
return|return
literal|false
return|;
name|QString
name|decodedScheme
decl_stmt|;
if|if
condition|(
name|qt_urlRecode
argument_list|(
name|decodedScheme
argument_list|,
name|value
operator|.
name|constData
argument_list|()
argument_list|,
name|value
operator|.
name|constData
argument_list|()
operator|+
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|false
return|;
return|return
name|setScheme
argument_list|(
name|decodedScheme
argument_list|,
name|decodedScheme
operator|.
name|length
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|// found something else
name|errorSupplement
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
return|return
literal|false
return|;
block|}
name|scheme
operator|=
name|value
operator|.
name|left
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sectionHasError
operator|&=
operator|~
name|Scheme
expr_stmt|;
name|errorCode
operator|=
name|NoError
expr_stmt|;
if|if
condition|(
name|needsLowercasing
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// schemes are ASCII only, so we don't need the full Unicode toLower
name|QChar
modifier|*
name|schemeData
init|=
name|scheme
operator|.
name|data
argument_list|()
decl_stmt|;
comment|// force detaching here
for|for
control|(
name|int
name|i
init|=
name|needsLowercasing
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
specifier|register
name|ushort
name|c
init|=
name|schemeData
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
name|schemeData
index|[
name|i
index|]
operator|=
name|c
operator|+
literal|0x20
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setAuthority
name|bool
name|QUrlPrivate
operator|::
name|setAuthority
parameter_list|(
specifier|const
name|QString
modifier|&
name|auth
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|sectionHasError
operator|&=
operator|~
name|Authority
expr_stmt|;
name|sectionIsPresent
operator|&=
operator|~
name|Authority
expr_stmt|;
name|sectionIsPresent
operator||=
name|Host
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|end
condition|)
block|{
name|userName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|password
operator|.
name|clear
argument_list|()
expr_stmt|;
name|host
operator|.
name|clear
argument_list|()
expr_stmt|;
name|port
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
name|int
name|userInfoIndex
init|=
name|auth
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
argument_list|,
name|from
argument_list|)
decl_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|userInfoIndex
argument_list|)
operator|<
name|uint
argument_list|(
name|end
argument_list|)
condition|)
block|{
name|setUserInfo
argument_list|(
name|auth
argument_list|,
name|from
argument_list|,
name|userInfoIndex
argument_list|)
expr_stmt|;
name|from
operator|=
name|userInfoIndex
operator|+
literal|1
expr_stmt|;
block|}
name|int
name|colonIndex
init|=
name|auth
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|,
name|end
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|colonIndex
operator|<
name|from
condition|)
name|colonIndex
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|colonIndex
argument_list|)
operator|<
name|uint
argument_list|(
name|end
argument_list|)
condition|)
block|{
if|if
condition|(
name|auth
operator|.
name|at
argument_list|(
name|from
argument_list|)
operator|.
name|unicode
argument_list|()
operator|==
literal|'['
condition|)
block|{
comment|// check if colonIndex isn't inside the "[...]" part
name|int
name|closingBracket
init|=
name|auth
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
argument_list|,
name|from
argument_list|)
decl_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|closingBracket
argument_list|)
operator|>
name|uint
argument_list|(
name|colonIndex
argument_list|)
condition|)
name|colonIndex
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|colonIndex
operator|==
name|end
operator|-
literal|1
condition|)
block|{
comment|// found a colon but no digits after it
name|sectionHasError
operator||=
name|Port
expr_stmt|;
name|errorCode
operator|=
name|PortEmptyError
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uint
argument_list|(
name|colonIndex
argument_list|)
operator|<
name|uint
argument_list|(
name|end
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|colonIndex
operator|+
literal|1
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
block|{
name|ushort
name|c
init|=
name|auth
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|x
operator|*=
literal|10
expr_stmt|;
name|x
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|sectionHasError
operator||=
name|Port
expr_stmt|;
name|errorCode
operator|=
name|InvalidPortError
expr_stmt|;
name|x
operator|=
name|ulong
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// x != ushort(x)
break|break;
block|}
block|}
if|if
condition|(
name|x
operator|==
name|ushort
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|port
operator|=
name|ushort
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sectionHasError
operator||=
name|Port
expr_stmt|;
name|errorCode
operator|=
name|InvalidPortError
expr_stmt|;
block|}
block|}
else|else
block|{
name|port
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|setHost
argument_list|(
name|auth
argument_list|,
name|from
argument_list|,
name|qMin
argument_list|<
name|uint
argument_list|>
argument_list|(
name|end
argument_list|,
name|colonIndex
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|sectionHasError
operator|&
name|Port
operator|)
return|;
block|}
end_function
begin_function
DECL|function|setUserInfo
name|void
name|QUrlPrivate
operator|::
name|setUserInfo
parameter_list|(
specifier|const
name|QString
modifier|&
name|userInfo
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|int
name|delimIndex
init|=
name|userInfo
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|,
name|from
argument_list|)
decl_stmt|;
name|setUserName
argument_list|(
name|userInfo
argument_list|,
name|from
argument_list|,
name|qMin
argument_list|<
name|uint
argument_list|>
argument_list|(
name|delimIndex
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|delimIndex
argument_list|)
operator|>=
name|uint
argument_list|(
name|end
argument_list|)
condition|)
block|{
name|password
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sectionIsPresent
operator|&=
operator|~
name|Password
expr_stmt|;
name|sectionHasError
operator|&=
operator|~
name|Password
expr_stmt|;
block|}
else|else
block|{
name|setPassword
argument_list|(
name|userInfo
argument_list|,
name|delimIndex
operator|+
literal|1
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setUserName
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|setUserName
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|sectionIsPresent
operator||=
name|UserName
expr_stmt|;
name|sectionHasError
operator|&=
operator|~
name|UserName
expr_stmt|;
name|userName
operator|=
name|recodeFromUser
argument_list|(
name|value
argument_list|,
name|decodedUserNameInIsolationActions
argument_list|,
name|from
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setPassword
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|setPassword
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|sectionIsPresent
operator||=
name|Password
expr_stmt|;
name|sectionHasError
operator|&=
operator|~
name|Password
expr_stmt|;
name|password
operator|=
name|recodeFromUser
argument_list|(
name|value
argument_list|,
name|decodedPasswordInIsolationActions
argument_list|,
name|from
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setPath
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|setPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
block|{
comment|// sectionIsPresent |= Path; // not used, save some cycles
name|sectionHasError
operator|&=
operator|~
name|Path
expr_stmt|;
name|path
operator|=
name|recodeFromUser
argument_list|(
name|value
argument_list|,
name|decodedPathInIsolationActions
argument_list|,
name|from
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|// ### FIXME?
comment|// check for the "path-noscheme" case
comment|// if the path contains a ":" before the first "/", it could be misinterpreted
comment|// as a scheme
block|}
end_function
begin_function
DECL|function|setFragment
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|setFragment
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|sectionIsPresent
operator||=
name|Fragment
expr_stmt|;
name|sectionHasError
operator|&=
operator|~
name|Fragment
expr_stmt|;
name|fragment
operator|=
name|recodeFromUser
argument_list|(
name|value
argument_list|,
name|decodedFragmentInIsolationActions
argument_list|,
name|from
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setQuery
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|setQuery
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|iend
parameter_list|)
block|{
name|sectionIsPresent
operator||=
name|Query
expr_stmt|;
name|sectionHasError
operator|&=
operator|~
name|Query
expr_stmt|;
comment|// use the default actions for the query (don't set QUrl::DecodeAllDelimiters)
name|QString
name|output
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|begin
init|=
name|value
operator|.
name|constData
argument_list|()
operator|+
name|from
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|end
init|=
name|value
operator|.
name|constData
argument_list|()
operator|+
name|iend
decl_stmt|;
comment|// leave delimiters alone but decode the rest
if|if
condition|(
name|qt_urlRecode
argument_list|(
name|output
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|QUrl
operator|::
name|EncodeDelimiters
argument_list|,
name|decodedQueryInIsolationActions
argument_list|)
condition|)
name|query
operator|=
name|output
expr_stmt|;
else|else
name|query
operator|=
name|value
operator|.
name|mid
argument_list|(
name|from
argument_list|,
name|iend
operator|-
name|from
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Host handling
end_comment
begin_comment
comment|// The RFC says the host is:
end_comment
begin_comment
comment|//    host          = IP-literal / IPv4address / reg-name
end_comment
begin_comment
comment|//    IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"
end_comment
begin_comment
comment|//    IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
end_comment
begin_comment
comment|//  [a strict definition of IPv6Address and IPv4Address]
end_comment
begin_comment
comment|//     reg-name      = *( unreserved / pct-encoded / sub-delims )
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// We deviate from the standard in all but IPvFuture. For IPvFuture we accept
end_comment
begin_comment
comment|// and store only exactly what the RFC says we should. No percent-encoding is
end_comment
begin_comment
comment|// permitted in this field, so Unicode characters and space aren't either.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// For IPv4 addresses, we accept broken addresses like inet_aton does (that is,
end_comment
begin_comment
comment|// less than three dots). However, we correct the address to the proper form
end_comment
begin_comment
comment|// and store the corrected address. After correction, we comply to the RFC and
end_comment
begin_comment
comment|// it's exclusively composed of unreserved characters.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// For IPv6 addresses, we accept addresses including trailing (embedded) IPv4
end_comment
begin_comment
comment|// addresses, the so-called v4-compat and v4-mapped addresses. We also store
end_comment
begin_comment
comment|// those addresses like that in the hostname field, which violates the spec.
end_comment
begin_comment
comment|// IPv6 hosts are stored with the square brackets in the QString. It also
end_comment
begin_comment
comment|// requires no transformation in any way.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// As for registered names, it's the other way around: we accept only valid
end_comment
begin_comment
comment|// hostnames as specified by STD 3 and IDNA. That means everything we accept is
end_comment
begin_comment
comment|// valid in the RFC definition above, but there are many valid reg-names
end_comment
begin_comment
comment|// according to the RFC that we do not accept in the name of security. Since we
end_comment
begin_comment
comment|// do accept IDNA, reg-names are subject to ACE encoding and decoding, which is
end_comment
begin_comment
comment|// specified by the DecodeUnicode flag. The hostname is stored in its Unicode form.
end_comment
begin_function
DECL|function|appendHost
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendHost
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
comment|// this is the only flag that matters
name|options
operator|&=
name|QUrl
operator|::
name|EncodeUnicode
expr_stmt|;
if|if
condition|(
name|host
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|host
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|unicode
argument_list|()
operator|==
literal|'['
condition|)
block|{
comment|// IPv6Address and IPvFuture address never require any transformation
name|appendTo
operator|+=
name|host
expr_stmt|;
block|}
else|else
block|{
comment|// this is either an IPv4Address or a reg-name
comment|// if it is a reg-name, it is already stored in Unicode form
if|if
condition|(
name|options
operator|==
name|QUrl
operator|::
name|EncodeUnicode
condition|)
name|appendTo
operator|+=
name|qt_ACE_do
argument_list|(
name|host
argument_list|,
name|ToAceOnly
argument_list|)
expr_stmt|;
else|else
name|appendTo
operator|+=
name|host
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// the whole IPvFuture is passed and parsed here, including brackets
end_comment
begin_function
DECL|function|parseIpFuture
specifier|static
name|int
name|parseIpFuture
parameter_list|(
name|QString
modifier|&
name|host
parameter_list|,
specifier|const
name|QChar
modifier|*
name|begin
parameter_list|,
specifier|const
name|QChar
modifier|*
name|end
parameter_list|)
block|{
comment|//    IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
specifier|static
specifier|const
name|char
name|acceptable
index|[]
init|=
literal|"!$&'()*+,;="
comment|// sub-delims
literal|":"
comment|// ":"
literal|"-._~"
decl_stmt|;
comment|// unreserved
comment|// the brackets and the "v" have been checked
if|if
condition|(
name|begin
index|[
literal|3
index|]
operator|.
name|unicode
argument_list|()
operator|!=
literal|'.'
condition|)
return|return
name|begin
index|[
literal|3
index|]
operator|.
name|unicode
argument_list|()
return|;
if|if
condition|(
operator|(
name|begin
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|>=
literal|'A'
operator|&&
name|begin
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|>=
literal|'F'
operator|)
operator|||
operator|(
name|begin
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|>=
literal|'a'
operator|&&
name|begin
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|begin
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|>=
literal|'0'
operator|&&
name|begin
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|<=
literal|'9'
operator|)
condition|)
block|{
comment|// this is so unlikely that we'll just go down the slow path
comment|// decode the whole string, skipping the "[vH." and "]" which we already know to be there
name|host
operator|+=
name|QString
operator|::
name|fromRawData
argument_list|(
name|begin
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|begin
operator|+=
literal|4
expr_stmt|;
operator|--
name|end
expr_stmt|;
name|QString
name|decoded
decl_stmt|;
if|if
condition|(
name|qt_urlRecode
argument_list|(
name|decoded
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|QUrl
operator|::
name|FullyEncoded
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|begin
operator|=
name|decoded
operator|.
name|constBegin
argument_list|()
expr_stmt|;
name|end
operator|=
name|decoded
operator|.
name|constEnd
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
name|begin
operator|!=
name|end
condition|;
operator|++
name|begin
control|)
block|{
if|if
condition|(
name|begin
operator|->
name|unicode
argument_list|()
operator|>=
literal|'A'
operator|&&
name|begin
operator|->
name|unicode
argument_list|()
operator|<=
literal|'Z'
condition|)
name|host
operator|+=
operator|*
name|begin
expr_stmt|;
elseif|else
if|if
condition|(
name|begin
operator|->
name|unicode
argument_list|()
operator|>=
literal|'a'
operator|&&
name|begin
operator|->
name|unicode
argument_list|()
operator|<=
literal|'z'
condition|)
name|host
operator|+=
operator|*
name|begin
expr_stmt|;
elseif|else
if|if
condition|(
name|begin
operator|->
name|unicode
argument_list|()
operator|>=
literal|'0'
operator|&&
name|begin
operator|->
name|unicode
argument_list|()
operator|<=
literal|'9'
condition|)
name|host
operator|+=
operator|*
name|begin
expr_stmt|;
elseif|else
if|if
condition|(
name|begin
operator|->
name|unicode
argument_list|()
operator|<
literal|0x80
operator|&&
name|strchr
argument_list|(
name|acceptable
argument_list|,
name|begin
operator|->
name|unicode
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
name|host
operator|+=
operator|*
name|begin
expr_stmt|;
else|else
return|return
name|begin
operator|->
name|unicode
argument_list|()
return|;
block|}
name|host
operator|+=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|begin
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// ONLY the IPv6 address is parsed here, WITHOUT the brackets
end_comment
begin_function
DECL|function|parseIp6
specifier|static
name|bool
name|parseIp6
parameter_list|(
name|QString
modifier|&
name|host
parameter_list|,
specifier|const
name|QChar
modifier|*
name|begin
parameter_list|,
specifier|const
name|QChar
modifier|*
name|end
parameter_list|)
block|{
name|QIPAddressUtils
operator|::
name|IPv6Address
name|address
decl_stmt|;
if|if
condition|(
operator|!
name|QIPAddressUtils
operator|::
name|parseIp6
argument_list|(
name|address
argument_list|,
name|begin
argument_list|,
name|end
argument_list|)
condition|)
block|{
comment|// IPv6 failed parsing, check if it was a percent-encoded character in
comment|// the middle and try again
name|QString
name|decoded
decl_stmt|;
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|decoded
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|QUrl
operator|::
name|FullyEncoded
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|// no transformation, nothing to re-parse
return|return
literal|false
return|;
block|}
comment|// recurse
comment|// if the parsing fails again, the qt_urlRecode above will return 0
return|return
name|parseIp6
argument_list|(
name|host
argument_list|,
name|decoded
operator|.
name|constBegin
argument_list|()
argument_list|,
name|decoded
operator|.
name|constEnd
argument_list|()
argument_list|)
return|;
block|}
name|host
operator|.
name|reserve
argument_list|(
name|host
operator|.
name|size
argument_list|()
operator|+
operator|(
name|end
operator|-
name|begin
operator|)
argument_list|)
expr_stmt|;
name|host
operator|+=
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|QIPAddressUtils
operator|::
name|toString
argument_list|(
name|host
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|host
operator|+=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setHost
name|bool
name|QUrlPrivate
operator|::
name|setHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|iend
parameter_list|,
name|bool
name|maybePercentEncoded
parameter_list|)
block|{
specifier|const
name|QChar
modifier|*
name|begin
init|=
name|value
operator|.
name|constData
argument_list|()
operator|+
name|from
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|end
init|=
name|value
operator|.
name|constData
argument_list|()
operator|+
name|iend
decl_stmt|;
specifier|const
name|int
name|len
init|=
name|end
operator|-
name|begin
decl_stmt|;
name|host
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sectionIsPresent
operator||=
name|Host
expr_stmt|;
name|sectionHasError
operator|&=
operator|~
name|Host
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|begin
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'['
condition|)
block|{
comment|// IPv6Address or IPvFuture
comment|// smallest IPv6 address is      "[::]"   (len = 4)
comment|// smallest IPvFuture address is "[v7.X]" (len = 6)
if|if
condition|(
name|end
index|[
operator|-
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|!=
literal|']'
condition|)
block|{
name|sectionHasError
operator||=
name|Host
expr_stmt|;
name|errorCode
operator|=
name|HostMissingEndBracket
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|len
operator|>
literal|5
operator|&&
name|begin
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'v'
condition|)
block|{
name|int
name|c
init|=
name|parseIpFuture
argument_list|(
name|host
argument_list|,
name|begin
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|sectionHasError
operator||=
name|Host
expr_stmt|;
name|errorCode
operator|=
name|InvalidIPvFutureError
expr_stmt|;
name|errorSupplement
operator|=
name|short
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|c
operator|==
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|parseIp6
argument_list|(
name|host
argument_list|,
name|begin
operator|+
literal|1
argument_list|,
name|end
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|true
return|;
name|sectionHasError
operator||=
name|Host
expr_stmt|;
name|errorCode
operator|=
name|begin
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'v'
condition|?
name|InvalidIPvFutureError
else|:
name|InvalidIPv6AddressError
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// check if it's an IPv4 address
name|QIPAddressUtils
operator|::
name|IPv4Address
name|ip4
decl_stmt|;
if|if
condition|(
name|QIPAddressUtils
operator|::
name|parseIp4
argument_list|(
name|ip4
argument_list|,
name|begin
argument_list|,
name|end
argument_list|)
condition|)
block|{
comment|// yes, it was
name|QIPAddressUtils
operator|::
name|toString
argument_list|(
name|host
argument_list|,
name|ip4
argument_list|)
expr_stmt|;
name|sectionHasError
operator|&=
operator|~
name|Host
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// This is probably a reg-name.
comment|// But it can also be an encoded string that, when decoded becomes one
comment|// of the types above.
comment|//
comment|// Two types of encoding are possible:
comment|//  percent encoding (e.g., "%31%30%2E%30%2E%30%2E%31" -> "10.0.0.1")
comment|//  Unicode encoding (some non-ASCII characters case-fold to digits
comment|//                    when nameprepping is done)
comment|//
comment|// The qt_ACE_do function below applies nameprepping and the STD3 check.
comment|// That means a Unicode string may become an IPv4 address, but it cannot
comment|// produce a '[' or a '%'.
comment|// check for percent-encoding first
name|QString
name|s
decl_stmt|;
if|if
condition|(
name|maybePercentEncoded
operator|&&
name|qt_urlRecode
argument_list|(
name|s
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|QUrl
operator|::
name|MostDecoded
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|// something was decoded
comment|// anything encoded left?
if|if
condition|(
name|s
operator|.
name|contains
argument_list|(
name|QChar
argument_list|(
literal|0x25
argument_list|)
argument_list|)
condition|)
block|{
comment|// '%'
name|sectionHasError
operator||=
name|Host
expr_stmt|;
name|errorCode
operator|=
name|InvalidRegNameError
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// recurse
return|return
name|setHost
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|s
operator|=
name|qt_ACE_do
argument_list|(
name|QString
operator|::
name|fromRawData
argument_list|(
name|begin
argument_list|,
name|len
argument_list|)
argument_list|,
name|NormalizeAce
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sectionHasError
operator||=
name|Host
expr_stmt|;
name|errorCode
operator|=
name|InvalidRegNameError
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// check IPv4 again
if|if
condition|(
name|QIPAddressUtils
operator|::
name|parseIp4
argument_list|(
name|ip4
argument_list|,
name|s
operator|.
name|constBegin
argument_list|()
argument_list|,
name|s
operator|.
name|constEnd
argument_list|()
argument_list|)
condition|)
block|{
name|QIPAddressUtils
operator|::
name|toString
argument_list|(
name|host
argument_list|,
name|ip4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|host
operator|=
name|s
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|parse
name|void
name|QUrlPrivate
operator|::
name|parse
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
name|QUrl
operator|::
name|ParsingMode
name|parsingMode
parameter_list|)
block|{
comment|//   URI-reference = URI / relative-ref
comment|//   URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
comment|//   relative-ref  = relative-part [ "?" query ] [ "#" fragment ]
comment|//   hier-part     = "//" authority path-abempty
comment|//                 / other path types
comment|//   relative-part = "//" authority path-abempty
comment|//                 /  other path types here
name|sectionIsPresent
operator|=
literal|0
expr_stmt|;
name|sectionHasError
operator|=
literal|0
expr_stmt|;
comment|// find the important delimiters
name|int
name|colon
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|question
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|hash
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|int
name|len
init|=
name|url
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
specifier|const
name|begin
init|=
name|url
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|ushort
modifier|*
specifier|const
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|begin
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|uint
name|uc
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|uc
operator|==
literal|'#'
operator|&&
name|hash
operator|==
operator|-
literal|1
condition|)
block|{
name|hash
operator|=
name|i
expr_stmt|;
comment|// nothing more to be found
break|break;
block|}
if|if
condition|(
name|question
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|uc
operator|==
literal|':'
operator|&&
name|colon
operator|==
operator|-
literal|1
condition|)
name|colon
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|uc
operator|==
literal|'?'
condition|)
name|question
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|// check if we have a scheme
name|int
name|hierStart
decl_stmt|;
if|if
condition|(
name|colon
operator|!=
operator|-
literal|1
operator|&&
name|setScheme
argument_list|(
name|url
argument_list|,
name|colon
argument_list|)
condition|)
block|{
name|hierStart
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// recover from a failed scheme: it might not have been a scheme at all
name|scheme
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sectionHasError
operator|=
literal|0
expr_stmt|;
name|sectionIsPresent
operator|=
literal|0
expr_stmt|;
name|hierStart
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|pathStart
decl_stmt|;
name|int
name|hierEnd
init|=
name|qMin
argument_list|<
name|uint
argument_list|>
argument_list|(
name|qMin
argument_list|<
name|uint
argument_list|>
argument_list|(
name|question
argument_list|,
name|hash
argument_list|)
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|hierEnd
operator|-
name|hierStart
operator|>=
literal|2
operator|&&
name|data
index|[
name|hierStart
index|]
operator|==
literal|'/'
operator|&&
name|data
index|[
name|hierStart
operator|+
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|// we have an authority, it ends at the first slash after these
name|int
name|authorityEnd
init|=
name|hierEnd
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|hierStart
operator|+
literal|2
init|;
name|i
operator|<
name|authorityEnd
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
block|{
name|authorityEnd
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|setAuthority
argument_list|(
name|url
argument_list|,
name|hierStart
operator|+
literal|2
argument_list|,
name|authorityEnd
argument_list|)
expr_stmt|;
comment|// even if we failed to set the authority properly, let's try to recover
name|pathStart
operator|=
name|authorityEnd
expr_stmt|;
name|setPath
argument_list|(
name|url
argument_list|,
name|pathStart
argument_list|,
name|hierEnd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|userName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|password
operator|.
name|clear
argument_list|()
expr_stmt|;
name|host
operator|.
name|clear
argument_list|()
expr_stmt|;
name|port
operator|=
operator|-
literal|1
expr_stmt|;
name|pathStart
operator|=
name|hierStart
expr_stmt|;
if|if
condition|(
name|hierStart
operator|<
name|hierEnd
condition|)
name|setPath
argument_list|(
name|url
argument_list|,
name|hierStart
argument_list|,
name|hierEnd
argument_list|)
expr_stmt|;
else|else
name|path
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|uint
argument_list|(
name|question
argument_list|)
operator|<
name|uint
argument_list|(
name|hash
argument_list|)
condition|)
name|setQuery
argument_list|(
name|url
argument_list|,
name|question
operator|+
literal|1
argument_list|,
name|qMin
argument_list|<
name|uint
argument_list|>
argument_list|(
name|hash
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
operator|!=
operator|-
literal|1
condition|)
name|setFragment
argument_list|(
name|url
argument_list|,
name|hash
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sectionHasError
operator|||
name|parsingMode
operator|==
name|QUrl
operator|::
name|TolerantMode
condition|)
return|return;
comment|// The parsing so far was tolerant of errors, so the StrictMode
comment|// parsing is actually implemented here, as an extra post-check.
comment|// We only execute it if we haven't found any errors so far.
comment|// What we need to look out for, that the regular parser tolerates:
comment|//  - percent signs not followed by two hex digits
comment|//  - forbidden characters, which should always appear encoded
comment|//    '"' / '<' / '>' / '\' / '^' / '`' / '{' / '|' / '}' / BKSP
comment|//    control characters
comment|//  - delimiters not allowed in certain positions
comment|//    . scheme: parser is already strict
comment|//    . user info: gen-delims (except for ':') disallowed
comment|//    . host: parser is stricter than the standard
comment|//    . port: parser is stricter than the standard
comment|//    . path: all delimiters allowed
comment|//    . fragment: all delimiters allowed
comment|//    . query: all delimiters allowed
comment|//    We would only need to check the user-info. However, the presence
comment|//    of the disallowed gen-delims changes the parsing, so we don't
comment|//    actually need to do anything
specifier|static
specifier|const
name|char
name|forbidden
index|[]
init|=
literal|"\"<>\\^`{|}\x7F"
decl_stmt|;
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uint
argument_list|(
name|len
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|uint
name|uc
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|uc
operator|>=
literal|0x80
condition|)
continue|continue;
if|if
condition|(
operator|(
name|uc
operator|==
literal|'%'
operator|&&
operator|(
name|uint
argument_list|(
name|len
argument_list|)
operator|<
name|i
operator|+
literal|2
operator|||
operator|!
name|isHex
argument_list|(
name|data
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isHex
argument_list|(
name|data
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
operator|)
operator|)
operator|||
name|uc
operator|<=
literal|0x20
operator|||
name|strchr
argument_list|(
name|forbidden
argument_list|,
name|uc
argument_list|)
condition|)
block|{
comment|// found an error
name|errorSupplement
operator|=
name|uc
expr_stmt|;
comment|// where are we?
if|if
condition|(
name|i
operator|>
name|uint
argument_list|(
name|hash
argument_list|)
condition|)
block|{
name|errorCode
operator|=
name|InvalidFragmentError
expr_stmt|;
name|sectionHasError
operator||=
name|Fragment
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
name|uint
argument_list|(
name|question
argument_list|)
condition|)
block|{
name|errorCode
operator|=
name|InvalidQueryError
expr_stmt|;
name|sectionHasError
operator||=
name|Query
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
name|uint
argument_list|(
name|pathStart
argument_list|)
condition|)
block|{
comment|// pathStart is never -1
name|errorCode
operator|=
name|InvalidPathError
expr_stmt|;
name|sectionHasError
operator||=
name|Path
expr_stmt|;
block|}
else|else
block|{
comment|// It must be in the authority, since the scheme is strict.
comment|// Since the port and hostname parsers are also strict,
comment|// the error can only have happened in the user info.
name|int
name|pos
init|=
name|url
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|,
name|hierStart
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
name|uint
argument_list|(
name|pos
argument_list|)
condition|)
block|{
name|errorCode
operator|=
name|InvalidPasswordError
expr_stmt|;
name|sectionHasError
operator||=
name|Password
expr_stmt|;
block|}
else|else
block|{
name|errorCode
operator|=
name|InvalidUserNameError
expr_stmt|;
name|sectionHasError
operator||=
name|UserName
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*     From http://www.ietf.org/rfc/rfc3986.txt, 5.2.3: Merge paths      Returns a merge of the current path with the relative path passed     as argument.      Note: \a relativePath is relative (does not start with '/'). */
end_comment
begin_function
DECL|function|mergePaths
name|QString
name|QUrlPrivate
operator|::
name|mergePaths
parameter_list|(
specifier|const
name|QString
modifier|&
name|relativePath
parameter_list|)
specifier|const
block|{
comment|// If the base URI has a defined authority component and an empty
comment|// path, then return a string consisting of "/" concatenated with
comment|// the reference's path; otherwise,
if|if
condition|(
operator|!
name|host
operator|.
name|isEmpty
argument_list|()
operator|&&
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|relativePath
return|;
comment|// Return a string consisting of the reference's path component
comment|// appended to all but the last segment of the base URI's path
comment|// (i.e., excluding any characters after the right-most "/" in the
comment|// base URI path, or excluding the entire base URI path if it does
comment|// not contain any "/" characters).
name|QString
name|newPath
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|newPath
operator|=
name|relativePath
expr_stmt|;
else|else
name|newPath
operator|=
name|path
operator|.
name|leftRef
argument_list|(
name|path
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
operator|+
name|relativePath
expr_stmt|;
return|return
name|newPath
return|;
block|}
end_function
begin_comment
comment|/*     From http://www.ietf.org/rfc/rfc3986.txt, 5.2.4: Remove dot segments      Removes unnecessary ../ and ./ from the path. Used for normalizing     the URL. */
end_comment
begin_function
DECL|function|removeDotsFromPath
specifier|static
name|void
name|removeDotsFromPath
parameter_list|(
name|QString
modifier|*
name|path
parameter_list|)
block|{
comment|// The input buffer is initialized with the now-appended path
comment|// components and the output buffer is initialized to the empty
comment|// string.
name|QChar
modifier|*
name|out
init|=
name|path
operator|->
name|data
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|in
init|=
name|out
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|end
init|=
name|out
operator|+
name|path
operator|->
name|size
argument_list|()
decl_stmt|;
comment|// If the input buffer consists only of
comment|// "." or "..", then remove that from the input
comment|// buffer;
if|if
condition|(
name|path
operator|->
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
condition|)
operator|++
name|in
expr_stmt|;
elseif|else
if|if
condition|(
name|path
operator|->
name|size
argument_list|()
operator|==
literal|2
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
condition|)
name|in
operator|+=
literal|2
expr_stmt|;
comment|// While the input buffer is not empty, loop:
while|while
condition|(
name|in
operator|<
name|end
condition|)
block|{
comment|// otherwise, if the input buffer begins with a prefix of "../" or "./",
comment|// then remove that prefix from the input buffer;
if|if
condition|(
name|path
operator|->
name|size
argument_list|()
operator|>=
literal|2
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
condition|)
name|in
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|path
operator|->
name|size
argument_list|()
operator|>=
literal|3
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
condition|)
name|in
operator|+=
literal|3
expr_stmt|;
comment|// otherwise, if the input buffer begins with a prefix of
comment|// "/./" or "/.", where "." is a complete path segment,
comment|// then replace that prefix with "/" in the input buffer;
if|if
condition|(
name|in
operator|<=
name|end
operator|-
literal|3
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
operator|&&
name|in
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
condition|)
block|{
name|in
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|in
operator|==
name|end
operator|-
literal|2
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
operator|&&
name|in
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
condition|)
block|{
operator|*
name|out
operator|++
operator|=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|in
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
comment|// otherwise, if the input buffer begins with a prefix
comment|// of "/../" or "/..", where ".." is a complete path
comment|// segment, then replace that prefix with "/" in the
comment|// input buffer and remove the last //segment and its
comment|// preceding "/" (if any) from the output buffer;
if|if
condition|(
name|in
operator|<=
name|end
operator|-
literal|4
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
operator|&&
name|in
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|3
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
condition|)
block|{
while|while
condition|(
name|out
operator|>
name|path
operator|->
name|constData
argument_list|()
operator|&&
operator|(
operator|--
name|out
operator|)
operator|->
name|unicode
argument_list|()
operator|!=
literal|'/'
condition|)
empty_stmt|;
if|if
condition|(
name|out
operator|==
name|path
operator|->
name|constData
argument_list|()
operator|&&
name|out
operator|->
name|unicode
argument_list|()
operator|!=
literal|'/'
condition|)
operator|++
name|in
expr_stmt|;
name|in
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|in
operator|==
name|end
operator|-
literal|3
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
operator|&&
name|in
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
condition|)
block|{
while|while
condition|(
name|out
operator|>
name|path
operator|->
name|constData
argument_list|()
operator|&&
operator|(
operator|--
name|out
operator|)
operator|->
name|unicode
argument_list|()
operator|!=
literal|'/'
condition|)
empty_stmt|;
if|if
condition|(
name|out
operator|->
name|unicode
argument_list|()
operator|==
literal|'/'
condition|)
operator|++
name|out
expr_stmt|;
name|in
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
comment|// otherwise move the first path segment in
comment|// the input buffer to the end of the output
comment|// buffer, including the initial "/" character
comment|// (if any) and any subsequent characters up
comment|// to, but not including, the next "/"
comment|// character or the end of the input buffer.
operator|*
name|out
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
while|while
condition|(
name|in
operator|<
name|end
operator|&&
name|in
operator|->
name|unicode
argument_list|()
operator|!=
literal|'/'
condition|)
operator|*
name|out
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
block|}
name|path
operator|->
name|truncate
argument_list|(
name|out
operator|-
name|path
operator|->
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
unit|void QUrlPrivate::validate() const {     QUrlPrivate *that = (QUrlPrivate *)this;     that->encodedOriginal = that->toEncoded();
comment|// may detach
end_comment
begin_comment
unit|parse(ParseOnly);      QURL_SETFLAG(that->stateFlags, Validated);      if (!isValid)         return;      QString auth = authority();
comment|// causes the non-encoded forms to be valid
end_comment
begin_comment
comment|// authority() calls canonicalHost() which sets this
end_comment
begin_comment
unit|if (!isHostValid)         return;      if (scheme == QLatin1String("mailto")) {         if (!host.isEmpty() || port != -1 || !userName.isEmpty() || !password.isEmpty()) {             that->isValid = false;             that->errorInfo.setParams(0, QT_TRANSLATE_NOOP(QUrl, "expected empty host, username,"                                                            "port and password"),                                       0, 0);         }     } else if (scheme == ftpScheme() || scheme == httpScheme()) {         if (host.isEmpty()&& !(path.isEmpty()&& encodedPath.isEmpty())) {             that->isValid = false;             that->errorInfo.setParams(0, QT_TRANSLATE_NOOP(QUrl, "the host is empty, but not the path"),                                       0, 0);         }     } }  const QByteArray&QUrlPrivate::normalized() const {     if (QURL_HASFLAG(stateFlags, QUrlPrivate::Normalized))         return encodedNormalized;      QUrlPrivate *that = const_cast<QUrlPrivate *>(this);     QURL_SETFLAG(that->stateFlags, QUrlPrivate::Normalized);      QUrlPrivate tmp = *this;     tmp.scheme = tmp.scheme.toLower();     tmp.host = tmp.canonicalHost();
comment|// ensure the encoded and normalized parts of the URL
end_comment
begin_comment
unit|tmp.ensureEncodedParts();     if (tmp.encodedUserName.contains('%'))         q_normalizePercentEncoding(&tmp.encodedUserName, userNameExcludeChars);     if (tmp.encodedPassword.contains('%'))         q_normalizePercentEncoding(&tmp.encodedPassword, passwordExcludeChars);     if (tmp.encodedFragment.contains('%'))         q_normalizePercentEncoding(&tmp.encodedFragment, fragmentExcludeChars);      if (tmp.encodedPath.contains('%')) {
comment|// the path is a bit special:
end_comment
begin_comment
comment|// the slashes shouldn't be encoded or decoded.
end_comment
begin_comment
comment|// They should remain exactly like they are right now
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// treat the path as a slash-separated sequence of pchar
end_comment
begin_comment
unit|QByteArray result;         result.reserve(tmp.encodedPath.length());         if (tmp.encodedPath.startsWith('/'))             result.append('/');          const char *data = tmp.encodedPath.constData();         int lastSlash = 0;         int nextSlash;         do {             ++lastSlash;             nextSlash = tmp.encodedPath.indexOf('/', lastSlash);             int len;             if (nextSlash == -1)                 len = tmp.encodedPath.length() - lastSlash;             else                 len = nextSlash - lastSlash;              if (memchr(data + lastSlash, '%', len)) {
comment|// there's at least one percent before the next slash
end_comment
begin_comment
unit|QByteArray block = QByteArray(data + lastSlash, len);                 q_normalizePercentEncoding(&block, pathExcludeChars);                 result.append(block);             } else {
comment|// no percents in this path segment, append wholesale
end_comment
begin_comment
unit|result.append(data + lastSlash, len);             }
comment|// append the slash too, if it's there
end_comment
begin_comment
unit|if (nextSlash != -1)                 result.append('/');              lastSlash = nextSlash;         } while (lastSlash != -1);          tmp.encodedPath = result;     }      if (!tmp.scheme.isEmpty())
comment|// relative test
end_comment
begin_endif
unit|removeDotsFromPath(&tmp.encodedPath);      int qLen = tmp.query.length();     for (int i = 0; i< qLen; i++) {         if (qLen - i> 2&& tmp.query.at(i) == '%') {             ++i;             tmp.query[i] = qToLower(tmp.query.at(i));             ++i;             tmp.query[i] = qToLower(tmp.query.at(i));         }     }     encodedNormalized = tmp.toEncoded();      return encodedNormalized; }
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \macro QT_NO_URL_CAST_FROM_STRING     \relates QUrl      Disables automatic conversions from QString (or char *) to QUrl.      Compiling your code with this define is useful when you have a lot of     code that uses QString for file names and you wish to convert it to     use QUrl for network transparency. In any code that uses QUrl, it can     help avoid missing QUrl::resolved() calls, and other misuses of     QString to QUrl conversions.      \oldcode         url = filename; // probably not what you want     \newcode         url = QUrl::fromLocalFile(filename);         url = baseurl.resolved(QUrl(filename));     \endcode      \sa QT_NO_CAST_FROM_ASCII */
end_comment
begin_comment
comment|/*!     Constructs a URL by parsing \a url. QUrl will automatically percent encode     all characters that are not allowed in a URL and decode the percent-encoded     sequences that represent a character that is allowed in a URL.      Parses the \a url using the parser mode \a parsingMode. In TolerantMode     (the default), QUrl will correct certain mistakes, notably the presence of     a percent character ('%') not followed by two hexadecimal digits, and it     will accept any character in any position. In StrictMode, encoding mistakes     will not be tolerated and QUrl will also check that certain forbidden     characters are not present in unencoded form. If an error is detected in     StrictMode, isValid() will return false.      Example:      \snippet code/src_corelib_io_qurl.cpp 0      To construct a URL from an encoded string, call fromEncoded():      \snippet code/src_corelib_io_qurl.cpp 1      \sa setUrl(), setEncodedUrl(), fromEncoded(), TolerantMode */
end_comment
begin_constructor
DECL|function|QUrl
name|QUrl
operator|::
name|QUrl
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
name|ParsingMode
name|parsingMode
parameter_list|)
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{
name|setUrl
argument_list|(
name|url
argument_list|,
name|parsingMode
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an empty QUrl object. */
end_comment
begin_constructor
DECL|function|QUrl
name|QUrl
operator|::
name|QUrl
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a other. */
end_comment
begin_constructor
DECL|function|QUrl
name|QUrl
operator|::
name|QUrl
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Destructor; called immediately before the object is deleted. */
end_comment
begin_destructor
DECL|function|~QUrl
name|QUrl
operator|::
name|~
name|QUrl
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns true if the URL is non-empty and valid; otherwise returns false.      The URL is run through a conformance test. Every part of the URL     must conform to the standard encoding rules of the URI standard     for the URL to be reported as valid.      \snippet code/src_corelib_io_qurl.cpp 2 */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QUrl
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|sectionHasError
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the URL has no data; otherwise returns false. */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QUrl
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|true
return|;
return|return
name|d
operator|->
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Resets the content of the QUrl. After calling this function, the     QUrl is equal to one that has been constructed with the default     empty constructor. */
end_comment
begin_function
DECL|function|clear
name|void
name|QUrl
operator|::
name|clear
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Parses \a url and sets this object to that value. QUrl will automatically     percent encode all characters that are not allowed in a URL and decode the     percent-encoded sequences that represent a character that is allowed in a     URL.      Parses the \a url using the parser mode \a parsingMode. In TolerantMode     (the default), QUrl will correct certain mistakes, notably the presence of     a percent character ('%') not followed by two hexadecimal digits, and it     will accept any character in any position. In StrictMode, encoding mistakes     will not be tolerated and QUrl will also check that certain forbidden     characters are not present in unencoded form. If an error is detected in     StrictMode, isValid() will return false.      \sa setEncodedUrl() */
end_comment
begin_function
DECL|function|setUrl
name|void
name|QUrl
operator|::
name|setUrl
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
name|ParsingMode
name|parsingMode
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|parse
argument_list|(
name|url
argument_list|,
name|parsingMode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the scheme of the URL to \a scheme. As a scheme can only     contain ASCII characters, no conversion or encoding is done on the     input.      The scheme describes the type (or protocol) of the URL. It's     represented by one or more ASCII characters at the start the URL,     and is followed by a ':'. The following example shows a URL where     the scheme is "ftp":      \image qurl-authority2.png      The scheme can also be empty, in which case the URL is interpreted     as relative.      \sa scheme(), isRelative() */
end_comment
begin_function
DECL|function|setScheme
name|void
name|QUrl
operator|::
name|setScheme
parameter_list|(
specifier|const
name|QString
modifier|&
name|scheme
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|scheme
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// schemes are not allowed to be empty
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Scheme
expr_stmt|;
name|d
operator|->
name|sectionHasError
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Scheme
expr_stmt|;
name|d
operator|->
name|scheme
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|setScheme
argument_list|(
name|scheme
argument_list|,
name|scheme
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the scheme of the URL. If an empty string is returned,     this means the scheme is undefined and the URL is then relative.      \sa setScheme(), isRelative() */
end_comment
begin_function
DECL|function|scheme
name|QString
name|QUrl
operator|::
name|scheme
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|d
operator|->
name|scheme
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the authority of the URL to \a authority.      The authority of a URL is the combination of user info, a host     name and a port. All of these elements are optional; an empty     authority is therefore valid.      The user info and host are separated by a '@', and the host and     port are separated by a ':'. If the user info is empty, the '@'     must be omitted; although a stray ':' is permitted if the port is     empty.      The following example shows a valid authority string:      \image qurl-authority.png */
end_comment
begin_function
DECL|function|setAuthority
name|void
name|QUrl
operator|::
name|setAuthority
parameter_list|(
specifier|const
name|QString
modifier|&
name|authority
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|setAuthority
argument_list|(
name|authority
argument_list|,
literal|0
argument_list|,
name|authority
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|authority
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// QUrlPrivate::setAuthority cleared almost everything
comment|// but it leaves the Host bit set
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Authority
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the authority of the URL if it is defined; otherwise     an empty string is returned.      \sa setAuthority() */
end_comment
begin_function
DECL|function|authority
name|QString
name|QUrl
operator|::
name|authority
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendAuthority
argument_list|(
name|result
argument_list|,
name|options
argument_list|,
name|QUrlPrivate
operator|::
name|Authority
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the user info of the URL to \a userInfo. The user info is an     optional part of the authority of the URL, as described in     setAuthority().      The user info consists of a user name and optionally a password,     separated by a ':'. If the password is empty, the colon must be     omitted. The following example shows a valid user info string:      \image qurl-authority3.png      \sa userInfo(), setUserName(), setPassword(), setAuthority() */
end_comment
begin_function
DECL|function|setUserInfo
name|void
name|QUrl
operator|::
name|setUserInfo
parameter_list|(
specifier|const
name|QString
modifier|&
name|userInfo
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|QString
name|trimmed
init|=
name|userInfo
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|d
operator|->
name|setUserInfo
argument_list|(
name|trimmed
argument_list|,
literal|0
argument_list|,
name|trimmed
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|userInfo
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// QUrlPrivate::setUserInfo cleared almost everything
comment|// but it leaves the UserName bit set
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|UserInfo
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the user info of the URL, or an empty string if the user     info is undefined. */
end_comment
begin_function
DECL|function|userInfo
name|QString
name|QUrl
operator|::
name|userInfo
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendUserInfo
argument_list|(
name|result
argument_list|,
name|options
argument_list|,
name|QUrlPrivate
operator|::
name|UserInfo
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the URL's user name to \a userName. The \a userName is part     of the user info element in the authority of the URL, as described     in setUserInfo().      \sa setEncodedUserName(), userName(), setUserInfo() */
end_comment
begin_function
DECL|function|setUserName
name|void
name|QUrl
operator|::
name|setUserName
parameter_list|(
specifier|const
name|QString
modifier|&
name|userName
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|setUserName
argument_list|(
name|userName
argument_list|,
literal|0
argument_list|,
name|userName
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|userName
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|UserName
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the user name of the URL if it is defined; otherwise     an empty string is returned.      \sa setUserName(), encodedUserName() */
end_comment
begin_function
DECL|function|userName
name|QString
name|QUrl
operator|::
name|userName
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendUserName
argument_list|(
name|result
argument_list|,
name|options
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the URL's password to \a password. The \a password is part of     the user info element in the authority of the URL, as described in     setUserInfo().      \sa password(), setUserInfo() */
end_comment
begin_function
DECL|function|setPassword
name|void
name|QUrl
operator|::
name|setPassword
parameter_list|(
specifier|const
name|QString
modifier|&
name|password
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|setPassword
argument_list|(
name|password
argument_list|,
literal|0
argument_list|,
name|password
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|password
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Password
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the password of the URL if it is defined; otherwise     an empty string is returned.      \sa setPassword() */
end_comment
begin_function
DECL|function|password
name|QString
name|QUrl
operator|::
name|password
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendPassword
argument_list|(
name|result
argument_list|,
name|options
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the host of the URL to \a host. The host is part of the     authority.      \sa host(), setAuthority() */
end_comment
begin_function
DECL|function|setHost
name|void
name|QUrl
operator|::
name|setHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|host
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|setHost
argument_list|(
name|host
argument_list|,
literal|0
argument_list|,
name|host
operator|.
name|length
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|host
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Host
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|host
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
argument_list|)
condition|)
block|{
comment|// setHost failed, it might be IPv6 or IPvFuture in need of bracketing
name|ushort
name|oldCode
init|=
name|d
operator|->
name|errorCode
decl_stmt|;
name|ushort
name|oldSupplement
init|=
name|d
operator|->
name|errorSupplement
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|setHost
argument_list|(
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
operator|+
name|host
operator|+
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
argument_list|,
literal|0
argument_list|,
name|host
operator|.
name|length
argument_list|()
operator|+
literal|2
argument_list|)
condition|)
block|{
comment|// failed again: choose if this was an IPv6 error or not
if|if
condition|(
operator|!
name|host
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
block|{
name|d
operator|->
name|errorCode
operator|=
name|oldCode
expr_stmt|;
name|d
operator|->
name|errorSupplement
operator|=
name|oldSupplement
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the host of the URL if it is defined; otherwise     an empty string is returned. */
end_comment
begin_function
DECL|function|host
name|QString
name|QUrl
operator|::
name|host
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendHost
argument_list|(
name|result
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
argument_list|)
condition|)
return|return
name|result
operator|.
name|mid
argument_list|(
literal|1
argument_list|,
name|result
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
return|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the port of the URL to \a port. The port is part of the     authority of the URL, as described in setAuthority().      \a port must be between 0 and 65535 inclusive. Setting the     port to -1 indicates that the port is unspecified. */
end_comment
begin_function
DECL|function|setPort
name|void
name|QUrl
operator|::
name|setPort
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|port
argument_list|<
operator|-
literal|1
operator|||
name|port
argument_list|>
literal|65535
condition|)
block|{
name|qWarning
argument_list|(
literal|"QUrl::setPort: Out of range"
argument_list|)
expr_stmt|;
name|port
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|sectionHasError
operator||=
name|QUrlPrivate
operator|::
name|Port
expr_stmt|;
name|d
operator|->
name|errorCode
operator|=
name|QUrlPrivate
operator|::
name|InvalidPortError
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|sectionHasError
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Port
expr_stmt|;
block|}
name|d
operator|->
name|port
operator|=
name|port
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the port of the URL, or \a defaultPort if the port is     unspecified.      Example:      \snippet code/src_corelib_io_qurl.cpp 3 */
end_comment
begin_function
DECL|function|port
name|int
name|QUrl
operator|::
name|port
parameter_list|(
name|int
name|defaultPort
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|defaultPort
return|;
return|return
name|d
operator|->
name|port
operator|==
operator|-
literal|1
condition|?
name|defaultPort
else|:
name|d
operator|->
name|port
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the path of the URL to \a path. The path is the part of the     URL that comes after the authority but before the query string.      \image qurl-ftppath.png      For non-hierarchical schemes, the path will be everything     following the scheme declaration, as in the following example:      \image qurl-mailtopath.png      \sa path() */
end_comment
begin_function
DECL|function|setPath
name|void
name|QUrl
operator|::
name|setPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|setPath
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|path
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// optimized out, since there is no path delimiter
comment|//    if (path.isNull())
comment|//        d->sectionIsPresent&= ~QUrlPrivate::Path;
block|}
end_function
begin_comment
comment|/*!     Returns the path of the URL.      \sa setPath() */
end_comment
begin_function
DECL|function|path
name|QString
name|QUrl
operator|::
name|path
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendPath
argument_list|(
name|result
argument_list|,
name|options
argument_list|,
name|QUrlPrivate
operator|::
name|Path
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns true if this URL contains a Query (i.e., if ? was seen on it).      \sa hasQueryItem(), encodedQuery() */
end_comment
begin_function
DECL|function|hasQuery
name|bool
name|QUrl
operator|::
name|hasQuery
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|hasQuery
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the query string of the URL to \a query. The string is     inserted as-is, and no further encoding is performed when calling     toEncoded().      This function is useful if you need to pass a query string that     does not fit into the key-value pattern, or that uses a different     scheme for encoding special characters than what is suggested by     QUrl.      Passing a value of QByteArray() to \a query (a null QByteArray) unsets     the query completely. However, passing a value of QByteArray("")     will set the query to an empty value, as if the original URL     had a lone "?".      \sa encodedQuery(), hasQuery() */
end_comment
begin_function
DECL|function|setQuery
name|void
name|QUrl
operator|::
name|setQuery
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|setQuery
argument_list|(
name|query
argument_list|,
literal|0
argument_list|,
name|query
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Query
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setQuery
name|void
name|QUrl
operator|::
name|setQuery
parameter_list|(
specifier|const
name|QUrlQuery
modifier|&
name|query
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
comment|// we know the data is in the right format
name|d
operator|->
name|query
operator|=
name|query
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Query
expr_stmt|;
else|else
name|d
operator|->
name|sectionIsPresent
operator||=
name|QUrlPrivate
operator|::
name|Query
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the query string of the URL in percent encoded form. */
end_comment
begin_function
DECL|function|query
name|QString
name|QUrl
operator|::
name|query
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendQuery
argument_list|(
name|result
argument_list|,
name|options
argument_list|,
name|QUrlPrivate
operator|::
name|Query
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasQuery
argument_list|()
operator|&&
name|result
operator|.
name|isNull
argument_list|()
condition|)
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the fragment of the URL to \a fragment. The fragment is the     last part of the URL, represented by a '#' followed by a string of     characters. It is typically used in HTTP for referring to a     certain link or point on a page:      \image qurl-fragment.png      The fragment is sometimes also referred to as the URL "reference".      Passing an argument of QString() (a null QString) will unset the fragment.     Passing an argument of QString("") (an empty but not null QString)     will set the fragment to an empty string (as if the original URL     had a lone "#").      \sa fragment(), hasFragment() */
end_comment
begin_function
DECL|function|setFragment
name|void
name|QUrl
operator|::
name|setFragment
parameter_list|(
specifier|const
name|QString
modifier|&
name|fragment
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|setFragment
argument_list|(
name|fragment
argument_list|,
literal|0
argument_list|,
name|fragment
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragment
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Fragment
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the fragment of the URL.      \sa setFragment() */
end_comment
begin_function
DECL|function|fragment
name|QString
name|QUrl
operator|::
name|fragment
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendFragment
argument_list|(
name|result
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasFragment
argument_list|()
operator|&&
name|result
operator|.
name|isNull
argument_list|()
condition|)
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns true if this URL contains a fragment (i.e., if # was seen on it).      \sa fragment(), setFragment() */
end_comment
begin_function
DECL|function|hasFragment
name|bool
name|QUrl
operator|::
name|hasFragment
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|hasFragment
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns the TLD (Top-Level Domain) of the URL, (e.g. .co.uk, .net).     Note that the return value is prefixed with a '.' unless the     URL does not contain a valid TLD, in which case the function returns     an empty string. */
end_comment
begin_function
DECL|function|topLevelDomain
name|QString
name|QUrl
operator|::
name|topLevelDomain
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
name|QString
name|tld
init|=
name|qTopLevelDomain
argument_list|(
name|host
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|options
operator|&
name|EncodeUnicode
condition|)
block|{
return|return
name|qt_ACE_do
argument_list|(
name|tld
argument_list|,
name|ToAceOnly
argument_list|)
return|;
block|}
return|return
name|tld
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the result of the merge of this URL with \a relative. This     URL is used as a base to convert \a relative to an absolute URL.      If \a relative is not a relative URL, this function will return \a     relative directly. Otherwise, the paths of the two URLs are     merged, and the new URL returned has the scheme and authority of     the base URL, but with the merged path, as in the following     example:      \snippet code/src_corelib_io_qurl.cpp 5      Calling resolved() with ".." returns a QUrl whose directory is     one level higher than the original. Similarly, calling resolved()     with "../.." removes two levels from the path. If \a relative is     "/", the path becomes "/".      \sa isRelative() */
end_comment
begin_function
DECL|function|resolved
name|QUrl
name|QUrl
operator|::
name|resolved
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|relative
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|relative
return|;
if|if
condition|(
operator|!
name|relative
operator|.
name|d
condition|)
return|return
operator|*
name|this
return|;
name|QUrl
name|t
decl_stmt|;
comment|// be non strict and allow scheme in relative url
if|if
condition|(
operator|!
name|relative
operator|.
name|d
operator|->
name|scheme
operator|.
name|isEmpty
argument_list|()
operator|&&
name|relative
operator|.
name|d
operator|->
name|scheme
operator|!=
name|d
operator|->
name|scheme
condition|)
block|{
name|t
operator|=
name|relative
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|relative
operator|.
name|d
operator|->
name|hasAuthority
argument_list|()
condition|)
block|{
name|t
operator|=
name|relative
expr_stmt|;
block|}
else|else
block|{
name|t
operator|.
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
comment|// copy the authority
name|t
operator|.
name|d
operator|->
name|userName
operator|=
name|d
operator|->
name|userName
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|password
operator|=
name|d
operator|->
name|password
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|host
operator|=
name|d
operator|->
name|host
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|port
operator|=
name|d
operator|->
name|port
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator|=
name|d
operator|->
name|sectionIsPresent
operator|&
name|QUrlPrivate
operator|::
name|Authority
expr_stmt|;
if|if
condition|(
name|relative
operator|.
name|d
operator|->
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|t
operator|.
name|d
operator|->
name|path
operator|=
name|d
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|relative
operator|.
name|d
operator|->
name|hasQuery
argument_list|()
condition|)
block|{
name|t
operator|.
name|d
operator|->
name|query
operator|=
name|relative
operator|.
name|d
operator|->
name|query
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator||=
name|QUrlPrivate
operator|::
name|Query
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|hasQuery
argument_list|()
condition|)
block|{
name|t
operator|.
name|d
operator|->
name|query
operator|=
name|d
operator|->
name|query
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator||=
name|QUrlPrivate
operator|::
name|Query
expr_stmt|;
block|}
block|}
else|else
block|{
name|t
operator|.
name|d
operator|->
name|path
operator|=
name|relative
operator|.
name|d
operator|->
name|path
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|?
name|relative
operator|.
name|d
operator|->
name|path
else|:
name|d
operator|->
name|mergePaths
argument_list|(
name|relative
operator|.
name|d
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|relative
operator|.
name|d
operator|->
name|hasQuery
argument_list|()
condition|)
block|{
name|t
operator|.
name|d
operator|->
name|query
operator|=
name|relative
operator|.
name|d
operator|->
name|query
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator||=
name|QUrlPrivate
operator|::
name|Query
expr_stmt|;
block|}
block|}
block|}
name|t
operator|.
name|d
operator|->
name|scheme
operator|=
name|d
operator|->
name|scheme
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasScheme
argument_list|()
condition|)
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator||=
name|QUrlPrivate
operator|::
name|Scheme
expr_stmt|;
else|else
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Scheme
expr_stmt|;
block|}
name|t
operator|.
name|d
operator|->
name|fragment
operator|=
name|relative
operator|.
name|d
operator|->
name|fragment
expr_stmt|;
if|if
condition|(
name|relative
operator|.
name|d
operator|->
name|hasFragment
argument_list|()
condition|)
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator||=
name|QUrlPrivate
operator|::
name|Fragment
expr_stmt|;
else|else
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Fragment
expr_stmt|;
name|removeDotsFromPath
argument_list|(
operator|&
name|t
operator|.
name|d
operator|->
name|path
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QURL_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QUrl(\"%s\").resolved(\"%s\") = \"%s\""
argument_list|,
name|qPrintable
argument_list|(
name|url
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|relative
operator|.
name|url
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|t
operator|.
name|url
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the URL is relative; otherwise returns false. A URL is     relative reference if its scheme is undefined; this function is therefore     equivalent to calling scheme().isEmpty().      Relative references are defined in RFC 3986 section 4.2. */
end_comment
begin_function
DECL|function|isRelative
name|bool
name|QUrl
operator|::
name|isRelative
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|true
return|;
return|return
operator|!
name|d
operator|->
name|hasScheme
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a string representation of the URL.     The output can be customized by passing flags with \a options.      The resulting QString can be passed back to a QUrl later on.      Synonym for toString(options).      \sa FormattingOptions, toEncoded(), toString() */
end_comment
begin_function
DECL|function|url
name|QString
name|QUrl
operator|::
name|url
parameter_list|(
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
return|return
name|toString
argument_list|(
name|options
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a string representation of the URL.     The output can be customized by passing flags with \a options.      \sa FormattingOptions, url(), setUrl() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QUrl
operator|::
name|toString
parameter_list|(
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// return just the path if:
comment|//  - QUrl::PreferLocalFile is passed
comment|//  - QUrl::RemovePath isn't passed (rather stupid if the user did...)
comment|//  - there's no query or fragment to return
comment|//    that is, either they aren't present, or we're removing them
comment|//  - it's a local file
comment|//    (test done last since it's the most expensive)
if|if
condition|(
name|options
operator|.
name|testFlag
argument_list|(
name|QUrl
operator|::
name|PreferLocalFile
argument_list|)
operator|&&
operator|!
name|options
operator|.
name|testFlag
argument_list|(
name|QUrl
operator|::
name|RemovePath
argument_list|)
operator|&&
operator|(
operator|!
name|d
operator|->
name|hasQuery
argument_list|()
operator|||
name|options
operator|.
name|testFlag
argument_list|(
name|QUrl
operator|::
name|RemoveQuery
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|d
operator|->
name|hasFragment
argument_list|()
operator|||
name|options
operator|.
name|testFlag
argument_list|(
name|QUrl
operator|::
name|RemoveFragment
argument_list|)
operator|)
operator|&&
name|isLocalFile
argument_list|()
condition|)
block|{
return|return
name|path
argument_list|(
name|options
argument_list|)
return|;
block|}
name|QString
name|url
decl_stmt|;
comment|// for the full URL, we consider that the reserved characters are prettier if encoded
if|if
condition|(
name|options
operator|&
name|DecodeReserved
condition|)
name|options
operator|&=
operator|~
name|EncodeReserved
expr_stmt|;
else|else
name|options
operator||=
name|EncodeReserved
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveScheme
operator|)
operator|&&
name|d
operator|->
name|hasScheme
argument_list|()
condition|)
name|url
operator|+=
name|d
operator|->
name|scheme
operator|+
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|bool
name|pathIsAbsolute
init|=
name|d
operator|->
name|path
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveAuthority
operator|)
operator|==
name|QUrl
operator|::
name|RemoveAuthority
operator|)
operator|&&
name|d
operator|->
name|hasAuthority
argument_list|()
condition|)
block|{
name|url
operator|+=
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
expr_stmt|;
name|d
operator|->
name|appendAuthority
argument_list|(
name|url
argument_list|,
name|options
argument_list|,
name|QUrlPrivate
operator|::
name|FullUrl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isLocalFile
argument_list|()
operator|&&
name|pathIsAbsolute
condition|)
block|{
name|url
operator|+=
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemovePath
operator|)
condition|)
block|{
comment|// check if we need to insert a slash
if|if
condition|(
operator|!
name|pathIsAbsolute
operator|&&
operator|!
name|d
operator|->
name|path
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|url
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|url
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
name|url
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|d
operator|->
name|appendPath
argument_list|(
name|url
argument_list|,
name|options
argument_list|,
name|QUrlPrivate
operator|::
name|FullUrl
argument_list|)
expr_stmt|;
comment|// check if we need to remove trailing slashes
if|if
condition|(
operator|(
name|options
operator|&
name|StripTrailingSlash
operator|)
operator|&&
operator|!
name|d
operator|->
name|path
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|path
operator|!=
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
operator|&&
name|url
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|url
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveQuery
operator|)
operator|&&
name|d
operator|->
name|hasQuery
argument_list|()
condition|)
block|{
name|url
operator|+=
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
name|d
operator|->
name|appendQuery
argument_list|(
name|url
argument_list|,
name|options
argument_list|,
name|QUrlPrivate
operator|::
name|FullUrl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveFragment
operator|)
operator|&&
name|d
operator|->
name|hasFragment
argument_list|()
condition|)
block|{
name|url
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|d
operator|->
name|appendFragment
argument_list|(
name|url
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
return|return
name|url
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Returns a human-displayable string representation of the URL.     The output can be customized by passing flags with \a options.     The option RemovePassword is always enabled, since passwords     should never be shown back to users.      With the default options, the resulting QString can be passed back     to a QUrl later on, but any password that was present initially will     be lost.      \sa FormattingOptions, toEncoded(), toString() */
end_comment
begin_function
DECL|function|toDisplayString
name|QString
name|QUrl
operator|::
name|toDisplayString
parameter_list|(
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
return|return
name|toString
argument_list|(
name|options
operator||
name|RemovePassword
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the encoded representation of the URL if it's valid;     otherwise an empty QByteArray is returned. The output can be     customized by passing flags with \a options.      The user info, path and fragment are all converted to UTF-8, and     all non-ASCII characters are then percent encoded. The host name     is encoded using Punycode. */
end_comment
begin_function
DECL|function|toEncoded
name|QByteArray
name|QUrl
operator|::
name|toEncoded
parameter_list|(
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
name|options
operator|&=
operator|~
name|DecodeReserved
expr_stmt|;
name|QString
name|stringForm
init|=
name|toString
argument_list|(
name|options
operator||
name|FullyEncoded
argument_list|)
decl_stmt|;
return|return
name|stringForm
operator|.
name|toLatin1
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QUrl QUrl::fromEncoded(const QByteArray&input, ParsingMode parsingMode)      Parses \a input and returns the corresponding QUrl. \a input is     assumed to be in encoded form, containing only ASCII characters.      Parses the URL using \a parsingMode.      \sa toEncoded(), setUrl() */
end_comment
begin_function
DECL|function|fromEncoded
name|QUrl
name|QUrl
operator|::
name|fromEncoded
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|input
parameter_list|,
name|ParsingMode
name|mode
parameter_list|)
block|{
return|return
name|QUrl
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
name|input
operator|.
name|constData
argument_list|()
argument_list|,
name|input
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a decoded copy of \a input. \a input is first decoded from     percent encoding, then converted from UTF-8 to unicode. */
end_comment
begin_function
DECL|function|fromPercentEncoding
name|QString
name|QUrl
operator|::
name|fromPercentEncoding
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|input
parameter_list|)
block|{
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
name|QByteArray
operator|::
name|fromPercentEncoding
argument_list|(
name|input
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an encoded copy of \a input. \a input is first converted     to UTF-8, and all ASCII-characters that are not in the unreserved group     are percent encoded. To prevent characters from being percent encoded     pass them to \a exclude. To force characters to be percent encoded pass     them to \a include.      Unreserved is defined as:        ALPHA / DIGIT / "-" / "." / "_" / "~"      \snippet code/src_corelib_io_qurl.cpp 6 */
end_comment
begin_function
DECL|function|toPercentEncoding
name|QByteArray
name|QUrl
operator|::
name|toPercentEncoding
parameter_list|(
specifier|const
name|QString
modifier|&
name|input
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|exclude
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|include
parameter_list|)
block|{
return|return
name|input
operator|.
name|toUtf8
argument_list|()
operator|.
name|toPercentEncoding
argument_list|(
name|exclude
argument_list|,
name|include
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray QUrl::toPunycode(const QString&uc)     \obsolete     Returns a \a uc in Punycode encoding.      Punycode is a Unicode encoding used for internationalized domain     names, as defined in RFC3492. If you want to convert a domain name from     Unicode to its ASCII-compatible representation, use toAce(). */
end_comment
begin_comment
comment|/*!     \fn QString QUrl::fromPunycode(const QByteArray&pc)     \obsolete     Returns the Punycode decoded representation of \a pc.      Punycode is a Unicode encoding used for internationalized domain     names, as defined in RFC3492. If you want to convert a domain from     its ASCII-compatible encoding to the Unicode representation, use     fromAce(). */
end_comment
begin_comment
comment|/*!     \since 4.2      Returns the Unicode form of the given domain name     \a domain, which is encoded in the ASCII Compatible Encoding (ACE).     The result of this function is considered equivalent to \a domain.      If the value in \a domain cannot be encoded, it will be converted     to QString and returned.      The ASCII Compatible Encoding (ACE) is defined by RFC 3490, RFC 3491     and RFC 3492. It is part of the Internationalizing Domain Names in     Applications (IDNA) specification, which allows for domain names     (like \c "example.com") to be written using international     characters. */
end_comment
begin_function
DECL|function|fromAce
name|QString
name|QUrl
operator|::
name|fromAce
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|domain
parameter_list|)
block|{
return|return
name|qt_ACE_do
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|domain
argument_list|)
argument_list|,
name|NormalizeAce
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the ASCII Compatible Encoding of the given domain name \a domain.     The result of this function is considered equivalent to \a domain.      The ASCII-Compatible Encoding (ACE) is defined by RFC 3490, RFC 3491     and RFC 3492. It is part of the Internationalizing Domain Names in     Applications (IDNA) specification, which allows for domain names     (like \c "example.com") to be written using international     characters.      This function return an empty QByteArra if \a domain is not a valid     hostname. Note, in particular, that IPv6 literals are not valid domain     names. */
end_comment
begin_function
DECL|function|toAce
name|QByteArray
name|QUrl
operator|::
name|toAce
parameter_list|(
specifier|const
name|QString
modifier|&
name|domain
parameter_list|)
block|{
name|QString
name|result
init|=
name|qt_ACE_do
argument_list|(
name|domain
argument_list|,
name|ToAceOnly
argument_list|)
decl_stmt|;
return|return
name|result
operator|.
name|toLatin1
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns true if this URL is "less than" the given \a url. This     provides a means of ordering URLs. */
end_comment
begin_function
DECL|function|operator <
name|bool
name|QUrl
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|url
operator|.
name|d
condition|)
block|{
name|bool
name|thisIsEmpty
init|=
operator|!
name|d
operator|||
name|d
operator|->
name|isEmpty
argument_list|()
decl_stmt|;
name|bool
name|thatIsEmpty
init|=
operator|!
name|url
operator|.
name|d
operator|||
name|url
operator|.
name|d
operator|->
name|isEmpty
argument_list|()
decl_stmt|;
comment|// sort an empty URL first
return|return
name|thisIsEmpty
operator|&&
operator|!
name|thatIsEmpty
return|;
block|}
name|int
name|cmp
decl_stmt|;
name|cmp
operator|=
name|d
operator|->
name|scheme
operator|.
name|compare
argument_list|(
name|url
operator|.
name|d
operator|->
name|scheme
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
operator|<
literal|0
return|;
name|cmp
operator|=
name|d
operator|->
name|userName
operator|.
name|compare
argument_list|(
name|url
operator|.
name|d
operator|->
name|userName
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
operator|<
literal|0
return|;
name|cmp
operator|=
name|d
operator|->
name|password
operator|.
name|compare
argument_list|(
name|url
operator|.
name|d
operator|->
name|password
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
operator|<
literal|0
return|;
name|cmp
operator|=
name|d
operator|->
name|host
operator|.
name|compare
argument_list|(
name|url
operator|.
name|d
operator|->
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
operator|<
literal|0
return|;
if|if
condition|(
name|d
operator|->
name|port
operator|!=
name|url
operator|.
name|d
operator|->
name|port
condition|)
return|return
name|d
operator|->
name|port
operator|<
name|url
operator|.
name|d
operator|->
name|port
return|;
name|cmp
operator|=
name|d
operator|->
name|path
operator|.
name|compare
argument_list|(
name|url
operator|.
name|d
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
operator|<
literal|0
return|;
name|cmp
operator|=
name|d
operator|->
name|query
operator|.
name|compare
argument_list|(
name|url
operator|.
name|d
operator|->
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
operator|<
literal|0
return|;
name|cmp
operator|=
name|d
operator|->
name|fragment
operator|.
name|compare
argument_list|(
name|url
operator|.
name|d
operator|->
name|fragment
argument_list|)
expr_stmt|;
return|return
name|cmp
operator|<
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this URL and the given \a url are equal;     otherwise returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QUrl
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|&&
operator|!
name|url
operator|.
name|d
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|url
operator|.
name|d
operator|->
name|isEmpty
argument_list|()
return|;
if|if
condition|(
operator|!
name|url
operator|.
name|d
condition|)
return|return
name|d
operator|->
name|isEmpty
argument_list|()
return|;
return|return
name|d
operator|->
name|scheme
operator|==
name|url
operator|.
name|d
operator|->
name|scheme
operator|&&
name|d
operator|->
name|userName
operator|==
name|url
operator|.
name|d
operator|->
name|userName
operator|&&
name|d
operator|->
name|password
operator|==
name|url
operator|.
name|d
operator|->
name|password
operator|&&
name|d
operator|->
name|host
operator|==
name|url
operator|.
name|d
operator|->
name|host
operator|&&
name|d
operator|->
name|port
operator|==
name|url
operator|.
name|d
operator|->
name|port
operator|&&
name|d
operator|->
name|path
operator|==
name|url
operator|.
name|d
operator|->
name|path
operator|&&
name|d
operator|->
name|query
operator|==
name|url
operator|.
name|d
operator|->
name|query
operator|&&
name|d
operator|->
name|fragment
operator|==
name|url
operator|.
name|d
operator|->
name|fragment
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this URL and the given \a url are not equal;     otherwise returns false. */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QUrl
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|url
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Assigns the specified \a url to this object. */
end_comment
begin_function
DECL|function|operator =
name|QUrl
modifier|&
name|QUrl
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
if|if
condition|(
name|url
operator|.
name|d
condition|)
block|{
name|url
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|d
operator|=
name|url
operator|.
name|d
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|url
operator|.
name|d
condition|)
name|qAtomicAssign
argument_list|(
name|d
argument_list|,
name|url
operator|.
name|d
argument_list|)
expr_stmt|;
else|else
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Assigns the specified \a url to this object. */
end_comment
begin_function
DECL|function|operator =
name|QUrl
modifier|&
name|QUrl
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|)
block|{
if|if
condition|(
name|url
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|parse
argument_list|(
name|url
argument_list|,
name|TolerantMode
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QUrl::swap(QUrl&other)     \since 4.8      Swaps URL \a other with this URL. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*! \internal      Forces a detach. */
end_comment
begin_function
DECL|function|detach
name|void
name|QUrl
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
else|else
name|qAtomicDetach
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|isDetached
name|bool
name|QUrl
operator|::
name|isDetached
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d
operator|||
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QUrl representation of \a localFile, interpreted as a local     file. This function accepts paths separated by slashes as well as the     native separator for this platform.      This function also accepts paths with a doubled leading slash (or     backslash) to indicate a remote file, as in     "//servername/path/to/file.txt". Note that only certain platforms can     actually open this file using QFile::open().      \sa toLocalFile(), isLocalFile(), QDir::toNativeSeparators() */
end_comment
begin_function
DECL|function|fromLocalFile
name|QUrl
name|QUrl
operator|::
name|fromLocalFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|localFile
parameter_list|)
block|{
name|QUrl
name|url
decl_stmt|;
name|url
operator|.
name|setScheme
argument_list|(
name|fileScheme
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|deslashified
init|=
name|QDir
operator|::
name|fromNativeSeparators
argument_list|(
name|localFile
argument_list|)
decl_stmt|;
comment|// magic for drives on windows
if|if
condition|(
name|deslashified
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|deslashified
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|&&
name|deslashified
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
name|deslashified
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|deslashified
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
argument_list|)
condition|)
block|{
comment|// magic for shared drive on windows
name|int
name|indexOfPath
init|=
name|deslashified
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|url
operator|.
name|setHost
argument_list|(
name|deslashified
operator|.
name|mid
argument_list|(
literal|2
argument_list|,
name|indexOfPath
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexOfPath
operator|>
literal|2
condition|)
name|deslashified
operator|=
name|deslashified
operator|.
name|right
argument_list|(
name|deslashified
operator|.
name|length
argument_list|()
operator|-
name|indexOfPath
argument_list|)
expr_stmt|;
else|else
name|deslashified
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|url
operator|.
name|setPath
argument_list|(
name|deslashified
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
argument_list|,
name|QStringLiteral
argument_list|(
literal|"%25"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|url
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the path of this URL formatted as a local file path. The path     returned will use forward slashes, even if it was originally created     from one with backslashes.      If this URL contains a non-empty hostname, it will be encoded in the     returned value in the form found on SMB networks (for example,     "//servername/path/to/file.txt").      Note: if the path component of this URL contains a non-UTF-8 binary     sequence (such as %80), the behaviour of this function is undefined.      \sa fromLocalFile(), isLocalFile() */
end_comment
begin_function
DECL|function|toLocalFile
name|QString
name|QUrl
operator|::
name|toLocalFile
parameter_list|()
specifier|const
block|{
comment|// the call to isLocalFile() also ensures that we're parsed
if|if
condition|(
operator|!
name|isLocalFile
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|tmp
decl_stmt|;
name|QString
name|ourPath
init|=
name|path
argument_list|(
name|QUrl
operator|::
name|MostDecoded
argument_list|)
decl_stmt|;
comment|// magic for shared drive on windows
if|if
condition|(
operator|!
name|d
operator|->
name|host
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|QStringLiteral
argument_list|(
literal|"//"
argument_list|)
operator|+
name|host
argument_list|()
operator|+
operator|(
name|ourPath
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|ourPath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|?
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|ourPath
else|:
name|ourPath
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|ourPath
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// magic for drives on windows
if|if
condition|(
name|ourPath
operator|.
name|length
argument_list|()
operator|>
literal|2
operator|&&
name|ourPath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|&&
name|ourPath
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
condition|)
name|tmp
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|// check if we need to do one more decoding pass
name|int
name|pct
init|=
name|tmp
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|pct
operator|!=
operator|-
literal|1
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|tmp
operator|.
name|size
argument_list|()
operator|>=
name|pct
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ushort
name|char1
init|=
name|tmp
operator|.
name|at
argument_list|(
name|pct
operator|+
literal|1
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|ushort
name|char2
init|=
name|tmp
operator|.
name|at
argument_list|(
name|pct
operator|+
literal|2
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|isHex
argument_list|(
name|char1
argument_list|)
operator|&&
name|char1
operator|<
literal|0x80u
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|isHex
argument_list|(
name|char2
argument_list|)
operator|&&
name|char2
operator|<
literal|0x80u
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|replace
argument_list|(
name|pct
argument_list|,
literal|3
argument_list|,
name|QChar
argument_list|(
name|fromHex
argument_list|(
name|char1
argument_list|)
operator|<<
literal|4
operator||
name|fromHex
argument_list|(
name|char2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// next iteration
name|pct
operator|=
name|tmp
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
argument_list|,
name|pct
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7     Returns true if this URL is pointing to a local file path. A URL is a     local file path if the scheme is "file".      Note that this function considers URLs with hostnames to be local file     paths, even if the eventual file path cannot be opened with     QFile::open().      \sa fromLocalFile(), toLocalFile() */
end_comment
begin_function
DECL|function|isLocalFile
name|bool
name|QUrl
operator|::
name|isLocalFile
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|scheme
operator|!=
name|fileScheme
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// not file
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this URL is a parent of \a childUrl. \a childUrl is a child     of this URL if the two URLs share the same scheme and authority,     and this URL's path is a parent of the path of \a childUrl. */
end_comment
begin_function
DECL|function|isParentOf
name|bool
name|QUrl
operator|::
name|isParentOf
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|childUrl
parameter_list|)
specifier|const
block|{
name|QString
name|childPath
init|=
name|childUrl
operator|.
name|path
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
operator|(
operator|(
name|childUrl
operator|.
name|scheme
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
name|childUrl
operator|.
name|authority
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
name|childPath
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|childPath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|)
return|;
name|QString
name|ourPath
init|=
name|path
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|childUrl
operator|.
name|scheme
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|d
operator|->
name|scheme
operator|==
name|childUrl
operator|.
name|scheme
argument_list|()
operator|)
operator|&&
operator|(
name|childUrl
operator|.
name|authority
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|authority
argument_list|()
operator|==
name|childUrl
operator|.
name|authority
argument_list|()
operator|)
operator|&&
name|childPath
operator|.
name|startsWith
argument_list|(
name|ourPath
argument_list|)
operator|&&
operator|(
operator|(
name|ourPath
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|&&
name|childPath
operator|.
name|length
argument_list|()
operator|>
name|ourPath
operator|.
name|length
argument_list|()
operator|)
operator|||
operator|(
operator|!
name|ourPath
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|&&
name|childPath
operator|.
name|length
argument_list|()
operator|>
name|ourPath
operator|.
name|length
argument_list|()
operator|&&
name|childPath
operator|.
name|at
argument_list|(
name|ourPath
operator|.
name|length
argument_list|()
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*! \relates QUrl      Writes url \a url to the stream \a out and returns a reference     to the stream.      \sa \link datastreamformat.html Format of the QDataStream operators \endlink */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|QByteArray
name|u
init|=
name|url
operator|.
name|toString
argument_list|(
name|QUrl
operator|::
name|FullyEncoded
argument_list|)
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
name|out
operator|<<
name|u
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*! \relates QUrl      Reads a url into \a url from the stream \a in and returns a     reference to the stream.      \sa \link datastreamformat.html Format of the QDataStream operators \endlink */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|QByteArray
name|u
decl_stmt|;
name|in
operator|>>
name|u
expr_stmt|;
name|url
operator|.
name|setUrl
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|d
parameter_list|,
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|d
operator|.
name|maybeSpace
argument_list|()
operator|<<
literal|"QUrl("
operator|<<
name|url
operator|.
name|toDisplayString
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|d
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \since 4.2      Returns a text string that explains why an URL is invalid in the case being;     otherwise returns an empty string. */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QUrl
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|sectionHasError
operator|==
literal|0
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// check if the error code matches a section with error
if|if
condition|(
operator|(
name|d
operator|->
name|sectionHasError
operator|&
operator|(
name|d
operator|->
name|errorCode
operator|>>
literal|8
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|QString
argument_list|()
return|;
name|QChar
name|c
init|=
name|d
operator|->
name|errorSupplement
decl_stmt|;
switch|switch
condition|(
name|QUrlPrivate
operator|::
name|ErrorCode
argument_list|(
name|d
operator|->
name|errorCode
argument_list|)
condition|)
block|{
case|case
name|QUrlPrivate
operator|::
name|NoError
case|:
return|return
name|QString
argument_list|()
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidSchemeError
case|:
block|{
name|QString
name|msg
init|=
name|QStringLiteral
argument_list|(
literal|"Invalid scheme (character '%1' not permitted)"
argument_list|)
decl_stmt|;
return|return
name|msg
operator|.
name|arg
argument_list|(
name|c
argument_list|)
return|;
block|}
case|case
name|QUrlPrivate
operator|::
name|SchemeEmptyError
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"Empty scheme"
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidUserNameError
case|:
return|return
name|QString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Invalid user name (character '%1' not permitted)"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidPasswordError
case|:
return|return
name|QString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Invalid password (character '%1' not permitted)"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidRegNameError
case|:
if|if
condition|(
name|d
operator|->
name|errorSupplement
condition|)
return|return
name|QString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Invalid hostname (character '%1' not permitted)"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
return|;
else|else
return|return
name|QStringLiteral
argument_list|(
literal|"Hostname contains invalid characters"
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidIPv4AddressError
case|:
return|return
name|QString
argument_list|()
return|;
comment|// doesn't happen yet
case|case
name|QUrlPrivate
operator|::
name|InvalidIPv6AddressError
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"Invalid IPv6 address"
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidIPvFutureError
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"Invalid IPvFuture address"
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|HostMissingEndBracket
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"Expected ']' to match '[' in hostname"
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidPortError
case|:
case|case
name|QUrlPrivate
operator|::
name|PortEmptyError
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"Invalid port or port number out of range"
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidPathError
case|:
return|return
name|QString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Invalid path (character '%1' not permitted)"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|PathContainsColonBeforeSlash
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"Path component contains ':' before any '/'"
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidQueryError
case|:
return|return
name|QString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Invalid query (character '%1' not permitted)"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidFragmentError
case|:
return|return
name|QString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Invalid fragment (character '%1' not permitted)"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
return|;
block|}
return|return
name|QStringLiteral
argument_list|(
literal|"<unknown error>"
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \typedef QUrl::DataPtr     \internal */
end_comment
begin_comment
comment|/*!     \fn DataPtr&QUrl::data_ptr()     \internal */
end_comment
begin_comment
comment|/*! \fn uint qHash(const QUrl&url, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a url. */
end_comment
begin_function
DECL|function|qHash
name|uint
name|qHash
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|,
name|uint
name|seed
parameter_list|)
block|{
if|if
condition|(
operator|!
name|url
operator|.
name|d
condition|)
return|return
name|qHash
argument_list|(
operator|-
literal|1
argument_list|,
name|seed
argument_list|)
return|;
comment|// the hash of an unset port (-1)
return|return
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|scheme
argument_list|)
operator|^
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|userName
argument_list|)
operator|^
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|password
argument_list|)
operator|^
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|host
argument_list|)
operator|^
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|port
argument_list|,
name|seed
argument_list|)
operator|^
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|path
argument_list|)
operator|^
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|query
argument_list|)
operator|^
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|fragment
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|adjustFtpPath
specifier|static
name|QUrl
name|adjustFtpPath
parameter_list|(
name|QUrl
name|url
parameter_list|)
block|{
if|if
condition|(
name|url
operator|.
name|scheme
argument_list|()
operator|==
name|ftpScheme
argument_list|()
condition|)
block|{
name|QString
name|path
init|=
name|url
operator|.
name|path
argument_list|()
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
argument_list|)
condition|)
name|url
operator|.
name|setPath
argument_list|(
name|QLatin1String
argument_list|(
literal|"/%2F"
argument_list|)
operator|+
name|path
operator|.
name|midRef
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|url
return|;
block|}
end_function
begin_comment
comment|// The following code has the following copyright:
end_comment
begin_comment
comment|/*    Copyright (C) Research In Motion Limited 2009. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:     * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     * Neither the name of Research In Motion Limited nor the       names of its contributors may be used to endorse or promote products       derived from this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY Research In Motion Limited ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Research In Motion Limited BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_comment
comment|/*!     Returns a valid URL from a user supplied \a userInput string if one can be     deducted. In the case that is not possible, an invalid QUrl() is returned.      \since 4.6      Most applications that can browse the web, allow the user to input a URL     in the form of a plain string. This string can be manually typed into     a location bar, obtained from the clipboard, or passed in via command     line arguments.      When the string is not already a valid URL, a best guess is performed,     making various web related assumptions.      In the case the string corresponds to a valid file path on the system,     a file:// URL is constructed, using QUrl::fromLocalFile().      If that is not the case, an attempt is made to turn the string into a     http:// or ftp:// URL. The latter in the case the string starts with     'ftp'. The result is then passed through QUrl's tolerant parser, and     in the case or success, a valid QUrl is returned, or else a QUrl().      \section1 Examples:      \list     \li qt.nokia.com becomes http://qt.nokia.com     \li ftp.qt.nokia.com becomes ftp://ftp.qt.nokia.com     \li hostname becomes http://hostname     \li /home/user/test.html becomes file:///home/user/test.html     \endlist */
end_comment
begin_function
DECL|function|fromUserInput
name|QUrl
name|QUrl
operator|::
name|fromUserInput
parameter_list|(
specifier|const
name|QString
modifier|&
name|userInput
parameter_list|)
block|{
name|QString
name|trimmedString
init|=
name|userInput
operator|.
name|trimmed
argument_list|()
decl_stmt|;
comment|// Check first for files, since on Windows drive letters can be interpretted as schemes
if|if
condition|(
name|QDir
operator|::
name|isAbsolutePath
argument_list|(
name|trimmedString
argument_list|)
condition|)
return|return
name|QUrl
operator|::
name|fromLocalFile
argument_list|(
name|trimmedString
argument_list|)
return|;
name|QUrl
name|url
init|=
name|QUrl
argument_list|(
name|trimmedString
argument_list|,
name|QUrl
operator|::
name|TolerantMode
argument_list|)
decl_stmt|;
name|QUrl
name|urlPrepended
init|=
name|QUrl
argument_list|(
name|QStringLiteral
argument_list|(
literal|"http://"
argument_list|)
operator|+
name|trimmedString
argument_list|,
name|QUrl
operator|::
name|TolerantMode
argument_list|)
decl_stmt|;
comment|// Check the most common case of a valid url with scheme and host
comment|// We check if the port would be valid by adding the scheme to handle the case host:port
comment|// where the host would be interpretted as the scheme
if|if
condition|(
name|url
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|url
operator|.
name|scheme
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|!
name|url
operator|.
name|host
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|url
operator|.
name|path
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
name|urlPrepended
operator|.
name|port
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
name|adjustFtpPath
argument_list|(
name|url
argument_list|)
return|;
comment|// Else, try the prepended one and adjust the scheme from the host name
if|if
condition|(
name|urlPrepended
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
operator|!
name|urlPrepended
operator|.
name|host
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|urlPrepended
operator|.
name|path
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|int
name|dotIndex
init|=
name|trimmedString
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|hostscheme
init|=
name|trimmedString
operator|.
name|left
argument_list|(
name|dotIndex
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|hostscheme
operator|==
name|ftpScheme
argument_list|()
condition|)
name|urlPrepended
operator|.
name|setScheme
argument_list|(
name|ftpScheme
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|adjustFtpPath
argument_list|(
name|urlPrepended
argument_list|)
return|;
block|}
return|return
name|QUrl
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// end of BSD code
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
