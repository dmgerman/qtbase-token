begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Copyright (C) 2012 Intel Corporation. ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QUrl     \inmodule QtCore      \brief The QUrl class provides a convenient interface for working     with URLs.      \reentrant     \ingroup io     \ingroup network     \ingroup shared       It can parse and construct URLs in both encoded and unencoded     form. QUrl also has support for internationalized domain names     (IDNs).      The most common way to use QUrl is to initialize it via the     constructor by passing a QString. Otherwise, setUrl() can also     be used.      URLs can be represented in two forms: encoded or unencoded. The     unencoded representation is suitable for showing to users, but     the encoded representation is typically what you would send to     a web server. For example, the unencoded URL     "http://b\\uuml\c{}hler.example.com" would be sent to the server as     "http://xn--bhler-kva.example.com/List%20of%20applicants.xml".      A URL can also be constructed piece by piece by calling     setScheme(), setUserName(), setPassword(), setHost(), setPort(),     setPath(), setQuery() and setFragment(). Some convenience     functions are also available: setAuthority() sets the user name,     password, host and port. setUserInfo() sets the user name and     password at once.      Call isValid() to check if the URL is valid. This can be done at     any point during the constructing of a URL.      Constructing a query is particularly convenient through the use of the \l     QUrlQuery class and its methods QUrlQuery::setQueryItems(),     QUrlQuery::addQueryItem() and QUrlQuery::removeQueryItem(). Use     QUrlQuery::setQueryDelimiters() to customize the delimiters used for     generating the query string.      For the convenience of generating encoded URL strings or query     strings, there are two static functions called     fromPercentEncoding() and toPercentEncoding() which deal with     percent encoding and decoding of QStrings.      Calling isRelative() will tell whether or not the URL is     relative. A relative URL can be resolved by passing it as argument     to resolved(), which returns an absolute URL. isParentOf() is used     for determining whether one URL is a parent of another.      fromLocalFile() constructs a QUrl by parsing a local     file path. toLocalFile() converts a URL to a local file path.      The human readable representation of the URL is fetched with     toString(). This representation is appropriate for displaying a     URL to a user in unencoded form. The encoded form however, as     returned by toEncoded(), is for internal use, passing to web     servers, mail clients and so on.      QUrl conforms to the URI specification from     \l{RFC 3986} (Uniform Resource Identifier: Generic Syntax), and includes     scheme extensions from \l{RFC 1738} (Uniform Resource Locators). Case     folding rules in QUrl conform to \l{RFC 3491} (Nameprep: A Stringprep     Profile for Internationalized Domain Names (IDN)).      \section2 Error checking      QUrl is capable of detecting many errors in URLs while parsing it or when     components of the URL are set with individual setter methods (like     setScheme(), setHost() or setPath()). If the parsing or setter function is     succesful, any previously recorded error conditions will be discarded.      By default, QUrl setter methods operate in QUrl::TolerantMode, which means     they accept some common mistakes and mis-representation of data. An     alternate method of parsing is QUrl::StrictMode, which applies further     checks. See QUrl::ParsingMode for a description of the difference of the     parsing modes.      QUrl only checks for conformance with the URL specification. It does not     try to verify that high-level protocol URLs are in the format they are     expected to be by handlers elsewhere. For example, the following URIs are     all considered valid by QUrl, even if they do not make sense when used:      \list       \li "http:/filename.html"       \li "mailto://example.com"     \endlist      When the parser encounters an error, it signals the event by making     isValid() return false and toString() / toEncoded() return an empty string.     If it is necessary to show the user the reason why the URL failed to parse,     the error condition can be obtained from QUrl by calling errorString().     Note that this message is highly technical and may not make sense to     end-users.      QUrl is capable of recording only one error condition. If more than one     error is found, it is undefined which error is reported.      \section2 Character Conversions      Follow these rules to avoid erroneous character conversion when     dealing with URLs and strings:      \list     \li When creating an QString to contain a URL from a QByteArray or a        char*, always use QString::fromUtf8().     \endlist */
end_comment
begin_comment
comment|/*!     \enum QUrl::ParsingMode      The parsing mode controls the way QUrl parses strings.      \value TolerantMode QUrl will try to correct some common errors in URLs.                         This mode is useful for parsing URLs coming from sources                         not known to be strictly standards-conforming.      \value StrictMode Only valid URLs are accepted. This mode is useful for                       general URL validation.      \value DecodedMode QUrl will interpret the URL component in the fully-decoded form,                        where percent characters stand for themselves, not as the beginning                        of a percent-encoded sequence. This mode is only valid for the                        setters setting components of a URL; it is not permitted in                        the QUrl constructor, in fromEncoded() or in setUrl().      In TolerantMode, the parser has the following behaviour:      \list      \li Spaces and "%20": unencoded space characters will be accepted and will     be treated as equivalent to "%20".      \li Single "%" characters: Any occurrences of a percent character "%" not     followed by exactly two hexadecimal characters (e.g., "13% coverage.html")     will be replaced by "%25". Note that one lone "%" character will trigger     the correction mode for all percent characters.      \li Reserved and unreserved characters: An encoded URL should only     contain a few characters as literals; all other characters should     be percent-encoded. In TolerantMode, these characters will be     automatically percent-encoded where they are not allowed:             space / double-quote / "<" / ">" / "\" /             "^" / "`" / "{" / "|" / "}"     Those same characters can be decoded again by passing QUrl::DecodeReserved     to toString() or toEncoded().      \endlist      When in StrictMode, if a parsing error is found, isValid() will return \c     false and errorString() will return a message describing the error.     If more than one error is detected, it is undefined which error gets     reported.      Note that TolerantMode is not usually enough for parsing user input, which     often contains more errors and expectations than the parser can deal with.     When dealing with data coming directly from the user -- as opposed to data     coming from data-transfer sources, such as other programs -- it is     recommended to use fromUserInput().      \sa fromUserInput(), setUrl(), toString(), toEncoded(), QUrl::FormattingOptions */
end_comment
begin_comment
comment|/*!     \enum QUrl::UrlFormattingOption      The formatting options define how the URL is formatted when written out     as text.      \value None The format of the URL is unchanged.     \value RemoveScheme  The scheme is removed from the URL.     \value RemovePassword  Any password in the URL is removed.     \value RemoveUserInfo  Any user information in the URL is removed.     \value RemovePort      Any specified port is removed from the URL.     \value RemoveAuthority     \value RemovePath   The URL's path is removed, leaving only the scheme,                         host address, and port (if present).     \value RemoveQuery  The query part of the URL (following a '?' character)                         is removed.     \value RemoveFragment     \value PreferLocalFile If the URL is a local file according to isLocalFile()      and contains no query or fragment, a local file path is returned.     \value StripTrailingSlash  The trailing slash is removed if one is present.      Note that the case folding rules in \l{RFC 3491}{Nameprep}, which QUrl     conforms to, require host names to always be converted to lower case,     regardless of the Qt::FormattingOptions used.      The options from QUrl::ComponentFormattingOptions are also possible.      \sa QUrl::ComponentFormattingOptions */
end_comment
begin_comment
comment|/*!     \enum QUrl::ComponentFormattingOption     \since 5.0      The component formatting options define how the components of an URL will     be formatted when written out as text. They can be combined with the     options from QUrl::FormattingOptions when used in toString() and     toEncoded().      \value PrettyDecoded   The component is returned in a "pretty form", with                            most percent-encoded characters decoded. The exact                            behavior of PrettyDecoded varies from component to                            component and may also change from Qt release to Qt                            release. This is the default.      \value EncodeSpaces    Leave space characters in their encoded form ("%20").      \value EncodeUnicode   Leave non-US-ASCII characters encoded in their UTF-8                            percent-encoded form (e.g., "%C3%A9" for the U+00E9                            codepoint, LATIN SMALL LETTER E WITH ACUTE).      \value EncodeDelimiters Leave certain delimiters in their encoded form, as                             would appear in the URL when the full URL is                             represented as text. The delimiters are affected                             by this option change from component to component.      \value EncodeReserved  Leave the US-ASCII reserved characters in their encoded                            forms.      \value DecodeReserved   Decode the US-ASCII reserved characters.      \value FullyEncoded    Leave all characters in their properly-encoded form,                            as this component would appear as part of a URL. When                            used with toString(), this produces a fully-compliant                            URL in QString form, exactly equal to the result of                            toEncoded()      \value FullyDecoded    Attempt to decode as much as possible. For individual                            components of the URL, this decodes every percent                            encoding sequence, including control characters (U+0000                            to U+001F) and UTF-8 sequences found in percent-encoded form.                            Note: if the component contains non-US-ASCII sequences                            that aren't valid UTF-8 sequences, the behaviour is                            undefined since QString cannot represent those values                            (data will be lost!)                            This mode is should not be used in functions where more                            than one URL component is returned (userInfo() and authority())                            and it is not allowed in url() and toString().      The values of EncodeReserved and DecodeReserved should not be used together     in one call. The behaviour is undefined if that happens. They are provided     as separate values because the behaviour of the "pretty mode" with regards     to reserved characters is different on certain components and specially on     the full URL.      The FullyDecoded mode is similar to the behaviour of the functions     returning QString in Qt 4.x, including the fact that they will most likely     cause data loss if the component in question contains a non-UTF-8     percent-encoded sequence. Fortunately, those cases aren't common, so this     mode should be used when the component in question is used in a non-URL     context. For example, in an FTP client application, the path to the remote     file could be stored in a QUrl object, and the string to be transmitted to     the FTP server should be obtained using this flag.      \sa QUrl::FormattingOptions */
end_comment
begin_include
include|#
directive|include
file|"qurl.h"
end_include
begin_include
include|#
directive|include
file|"qurl_p.h"
end_include
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|"qdir.h"
end_include
begin_comment
comment|// for QDir::fromNativeSeparators
end_comment
begin_include
include|#
directive|include
file|"qtldurl_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qipaddress_p.h"
end_include
begin_include
include|#
directive|include
file|"qurlquery.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE_WM
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|optimize
name|(
literal|"g"
name|,
name|off
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|isHex
specifier|inline
specifier|static
name|bool
name|isHex
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|c
operator||=
literal|0x20
expr_stmt|;
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|ftpScheme
specifier|static
specifier|inline
name|QString
name|ftpScheme
parameter_list|()
block|{
return|return
name|QStringLiteral
argument_list|(
literal|"ftp"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|httpScheme
specifier|static
specifier|inline
name|QString
name|httpScheme
parameter_list|()
block|{
return|return
name|QStringLiteral
argument_list|(
literal|"http"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fileScheme
specifier|static
specifier|inline
name|QString
name|fileScheme
parameter_list|()
block|{
return|return
name|QStringLiteral
argument_list|(
literal|"file"
argument_list|)
return|;
block|}
end_function
begin_class
DECL|class|QUrlPrivate
class|class
name|QUrlPrivate
block|{
public|public:
DECL|enum|Section
enum|enum
name|Section
block|{
DECL|enumerator|Scheme
name|Scheme
init|=
literal|0x01
block|,
DECL|enumerator|UserName
name|UserName
init|=
literal|0x02
block|,
DECL|enumerator|Password
name|Password
init|=
literal|0x04
block|,
DECL|enumerator|UserInfo
name|UserInfo
init|=
name|UserName
operator||
name|Password
block|,
DECL|enumerator|Host
name|Host
init|=
literal|0x08
block|,
DECL|enumerator|Port
name|Port
init|=
literal|0x10
block|,
DECL|enumerator|Authority
name|Authority
init|=
name|UserInfo
operator||
name|Host
operator||
name|Port
block|,
DECL|enumerator|Path
name|Path
init|=
literal|0x20
block|,
DECL|enumerator|Hierarchy
name|Hierarchy
init|=
name|Authority
operator||
name|Path
block|,
DECL|enumerator|Query
name|Query
init|=
literal|0x40
block|,
DECL|enumerator|Fragment
name|Fragment
init|=
literal|0x80
block|,
DECL|enumerator|FullUrl
name|FullUrl
init|=
literal|0xff
block|}
enum|;
DECL|enum|ErrorCode
enum|enum
name|ErrorCode
block|{
comment|// the high byte of the error code matches the Section
DECL|enumerator|InvalidSchemeError
name|InvalidSchemeError
init|=
name|Scheme
operator|<<
literal|8
block|,
DECL|enumerator|InvalidUserNameError
name|InvalidUserNameError
init|=
name|UserName
operator|<<
literal|8
block|,
DECL|enumerator|InvalidPasswordError
name|InvalidPasswordError
init|=
name|Password
operator|<<
literal|8
block|,
DECL|enumerator|InvalidRegNameError
name|InvalidRegNameError
init|=
name|Host
operator|<<
literal|8
block|,
DECL|enumerator|InvalidIPv4AddressError
name|InvalidIPv4AddressError
block|,
DECL|enumerator|InvalidIPv6AddressError
name|InvalidIPv6AddressError
block|,
DECL|enumerator|InvalidIPvFutureError
name|InvalidIPvFutureError
block|,
DECL|enumerator|HostMissingEndBracket
name|HostMissingEndBracket
block|,
DECL|enumerator|InvalidPortError
name|InvalidPortError
init|=
name|Port
operator|<<
literal|8
block|,
DECL|enumerator|PortEmptyError
name|PortEmptyError
block|,
DECL|enumerator|InvalidPathError
name|InvalidPathError
init|=
name|Path
operator|<<
literal|8
block|,
DECL|enumerator|InvalidQueryError
name|InvalidQueryError
init|=
name|Query
operator|<<
literal|8
block|,
DECL|enumerator|InvalidFragmentError
name|InvalidFragmentError
init|=
name|Fragment
operator|<<
literal|8
block|,
comment|// the following two cases are only possible in combination
comment|// with presence/absence of the authority and scheme. See validityError().
DECL|enumerator|AuthorityPresentAndPathIsRelative
name|AuthorityPresentAndPathIsRelative
init|=
name|Authority
operator|<<
literal|8
operator||
name|Path
operator|<<
literal|8
operator||
literal|0x10000
block|,
DECL|enumerator|RelativeUrlPathContainsColonBeforeSlash
name|RelativeUrlPathContainsColonBeforeSlash
init|=
name|Scheme
operator|<<
literal|8
operator||
name|Authority
operator|<<
literal|8
operator||
name|Path
operator|<<
literal|8
operator||
literal|0x10000
block|,
DECL|enumerator|NoError
name|NoError
init|=
literal|0
block|}
enum|;
DECL|struct|Error
struct|struct
name|Error
block|{
DECL|member|source
name|QString
name|source
decl_stmt|;
DECL|member|code
name|ErrorCode
name|code
decl_stmt|;
DECL|member|position
name|int
name|position
decl_stmt|;
block|}
struct|;
name|QUrlPrivate
parameter_list|()
constructor_decl|;
name|QUrlPrivate
parameter_list|(
specifier|const
name|QUrlPrivate
modifier|&
name|copy
parameter_list|)
constructor_decl|;
name|~
name|QUrlPrivate
parameter_list|()
destructor_decl|;
name|void
name|parse
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
name|QUrl
operator|::
name|ParsingMode
name|parsingMode
parameter_list|)
function_decl|;
DECL|function|isEmpty
name|bool
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
name|sectionIsPresent
operator|==
literal|0
operator|&&
name|port
operator|==
operator|-
literal|1
operator|&&
name|path
operator|.
name|isEmpty
argument_list|()
return|;
block|}
name|Error
modifier|*
name|cloneError
parameter_list|()
specifier|const
function_decl|;
name|void
name|clearError
parameter_list|()
function_decl|;
name|void
name|setError
parameter_list|(
name|ErrorCode
name|errorCode
parameter_list|,
specifier|const
name|QString
modifier|&
name|source
parameter_list|,
name|int
name|supplement
init|=
operator|-
literal|1
parameter_list|)
function_decl|;
name|ErrorCode
name|validityError
parameter_list|(
name|QString
modifier|*
name|source
init|=
literal|0
parameter_list|,
name|int
modifier|*
name|position
init|=
literal|0
parameter_list|)
specifier|const
function_decl|;
comment|// no QString scheme() const;
name|void
name|appendAuthority
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|,
name|Section
name|appendingTo
parameter_list|)
specifier|const
function_decl|;
name|void
name|appendUserInfo
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|,
name|Section
name|appendingTo
parameter_list|)
specifier|const
function_decl|;
name|void
name|appendUserName
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
function_decl|;
name|void
name|appendPassword
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
function_decl|;
name|void
name|appendHost
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
function_decl|;
name|void
name|appendPath
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|,
name|Section
name|appendingTo
parameter_list|)
specifier|const
function_decl|;
name|void
name|appendQuery
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|,
name|Section
name|appendingTo
parameter_list|)
specifier|const
function_decl|;
name|void
name|appendFragment
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
function_decl|;
comment|// the "end" parameters are like STL iterators: they point to one past the last valid element
name|bool
name|setScheme
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|len
parameter_list|,
name|bool
name|doSetError
parameter_list|)
function_decl|;
name|void
name|setAuthority
parameter_list|(
specifier|const
name|QString
modifier|&
name|auth
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|,
name|QUrl
operator|::
name|ParsingMode
name|mode
parameter_list|)
function_decl|;
name|void
name|setUserInfo
parameter_list|(
specifier|const
name|QString
modifier|&
name|userInfo
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
function_decl|;
name|void
name|setUserName
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
function_decl|;
name|void
name|setPassword
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
function_decl|;
name|bool
name|setHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|,
name|QUrl
operator|::
name|ParsingMode
name|mode
parameter_list|)
function_decl|;
name|void
name|setPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
function_decl|;
name|void
name|setQuery
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
function_decl|;
name|void
name|setFragment
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
function_decl|;
DECL|function|hasScheme
specifier|inline
name|bool
name|hasScheme
parameter_list|()
specifier|const
block|{
return|return
name|sectionIsPresent
operator|&
name|Scheme
return|;
block|}
DECL|function|hasAuthority
specifier|inline
name|bool
name|hasAuthority
parameter_list|()
specifier|const
block|{
return|return
name|sectionIsPresent
operator|&
name|Authority
return|;
block|}
DECL|function|hasUserInfo
specifier|inline
name|bool
name|hasUserInfo
parameter_list|()
specifier|const
block|{
return|return
name|sectionIsPresent
operator|&
name|UserInfo
return|;
block|}
DECL|function|hasUserName
specifier|inline
name|bool
name|hasUserName
parameter_list|()
specifier|const
block|{
return|return
name|sectionIsPresent
operator|&
name|UserName
return|;
block|}
DECL|function|hasPassword
specifier|inline
name|bool
name|hasPassword
parameter_list|()
specifier|const
block|{
return|return
name|sectionIsPresent
operator|&
name|Password
return|;
block|}
DECL|function|hasHost
specifier|inline
name|bool
name|hasHost
parameter_list|()
specifier|const
block|{
return|return
name|sectionIsPresent
operator|&
name|Host
return|;
block|}
DECL|function|hasPort
specifier|inline
name|bool
name|hasPort
parameter_list|()
specifier|const
block|{
return|return
name|port
operator|!=
operator|-
literal|1
return|;
block|}
DECL|function|hasPath
specifier|inline
name|bool
name|hasPath
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|function|hasQuery
specifier|inline
name|bool
name|hasQuery
parameter_list|()
specifier|const
block|{
return|return
name|sectionIsPresent
operator|&
name|Query
return|;
block|}
DECL|function|hasFragment
specifier|inline
name|bool
name|hasFragment
parameter_list|()
specifier|const
block|{
return|return
name|sectionIsPresent
operator|&
name|Fragment
return|;
block|}
name|QString
name|mergePaths
parameter_list|(
specifier|const
name|QString
modifier|&
name|relativePath
parameter_list|)
specifier|const
function_decl|;
DECL|member|ref
name|QAtomicInt
name|ref
decl_stmt|;
DECL|member|port
name|int
name|port
decl_stmt|;
DECL|member|scheme
name|QString
name|scheme
decl_stmt|;
DECL|member|userName
name|QString
name|userName
decl_stmt|;
DECL|member|password
name|QString
name|password
decl_stmt|;
DECL|member|host
name|QString
name|host
decl_stmt|;
DECL|member|path
name|QString
name|path
decl_stmt|;
DECL|member|query
name|QString
name|query
decl_stmt|;
DECL|member|fragment
name|QString
name|fragment
decl_stmt|;
DECL|member|error
name|Error
modifier|*
name|error
decl_stmt|;
comment|// not used for:
comment|//  - Port (port == -1 means absence)
comment|//  - Path (there's no path delimiter, so we optimize its use out of existence)
comment|// Schemes are never supposed to be empty, but we keep the flag anyway
DECL|member|sectionIsPresent
name|uchar
name|sectionIsPresent
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|QUrlPrivate
specifier|inline
name|QUrlPrivate
operator|::
name|QUrlPrivate
parameter_list|()
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|port
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|error
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|sectionIsPresent
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QUrlPrivate
specifier|inline
name|QUrlPrivate
operator|::
name|QUrlPrivate
parameter_list|(
specifier|const
name|QUrlPrivate
modifier|&
name|copy
parameter_list|)
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|port
argument_list|(
name|copy
operator|.
name|port
argument_list|)
member_init_list|,
name|scheme
argument_list|(
name|copy
operator|.
name|scheme
argument_list|)
member_init_list|,
name|userName
argument_list|(
name|copy
operator|.
name|userName
argument_list|)
member_init_list|,
name|password
argument_list|(
name|copy
operator|.
name|password
argument_list|)
member_init_list|,
name|host
argument_list|(
name|copy
operator|.
name|host
argument_list|)
member_init_list|,
name|path
argument_list|(
name|copy
operator|.
name|path
argument_list|)
member_init_list|,
name|query
argument_list|(
name|copy
operator|.
name|query
argument_list|)
member_init_list|,
name|fragment
argument_list|(
name|copy
operator|.
name|fragment
argument_list|)
member_init_list|,
name|error
argument_list|(
name|copy
operator|.
name|cloneError
argument_list|()
argument_list|)
member_init_list|,
name|sectionIsPresent
argument_list|(
name|copy
operator|.
name|sectionIsPresent
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QUrlPrivate
specifier|inline
name|QUrlPrivate
operator|::
name|~
name|QUrlPrivate
parameter_list|()
block|{
operator|delete
name|error
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|cloneError
specifier|inline
name|QUrlPrivate
operator|::
name|Error
modifier|*
name|QUrlPrivate
operator|::
name|cloneError
parameter_list|()
specifier|const
block|{
return|return
name|error
condition|?
operator|new
name|Error
argument_list|(
operator|*
name|error
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|clearError
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|clearError
parameter_list|()
block|{
operator|delete
name|error
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setError
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|setError
parameter_list|(
name|ErrorCode
name|errorCode
parameter_list|,
specifier|const
name|QString
modifier|&
name|source
parameter_list|,
name|int
name|supplement
parameter_list|)
block|{
if|if
condition|(
name|error
condition|)
block|{
comment|// don't overwrite an error set in a previous section during parsing
return|return;
block|}
name|error
operator|=
operator|new
name|Error
expr_stmt|;
name|error
operator|->
name|code
operator|=
name|errorCode
expr_stmt|;
name|error
operator|->
name|source
operator|=
name|source
expr_stmt|;
name|error
operator|->
name|position
operator|=
name|supplement
expr_stmt|;
block|}
end_function
begin_comment
comment|// From RFC 3896, Appendix A Collected ABNF for URI
end_comment
begin_comment
comment|//    URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
end_comment
begin_comment
comment|//[...]
end_comment
begin_comment
comment|//    scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    authority     = [ userinfo "@" ] host [ ":" port ]
end_comment
begin_comment
comment|//    userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
end_comment
begin_comment
comment|//    host          = IP-literal / IPv4address / reg-name
end_comment
begin_comment
comment|//    port          = *DIGIT
end_comment
begin_comment
comment|//[...]
end_comment
begin_comment
comment|//    reg-name      = *( unreserved / pct-encoded / sub-delims )
end_comment
begin_comment
comment|//[..]
end_comment
begin_comment
comment|//    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    query         = *( pchar / "/" / "?" )
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    fragment      = *( pchar / "/" / "?" )
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    pct-encoded   = "%" HEXDIG HEXDIG
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
end_comment
begin_comment
comment|//    reserved      = gen-delims / sub-delims
end_comment
begin_comment
comment|//    gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
end_comment
begin_comment
comment|//    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
end_comment
begin_comment
comment|//                  / "*" / "+" / "," / ";" / "="
end_comment
begin_comment
comment|// the path component has a complex ABNF that basically boils down to
end_comment
begin_comment
comment|// slash-separated segments of "pchar"
end_comment
begin_comment
comment|// The above is the strict definition of the URL components and it is what we
end_comment
begin_comment
comment|// return encoded as FullyEncoded. However, we store the equivalent to
end_comment
begin_comment
comment|// PrettyDecoded internally, as that is the default formatting mode and most
end_comment
begin_comment
comment|// likely to be used. PrettyDecoded decodes spaces, unicode sequences and
end_comment
begin_comment
comment|// unambiguous delimiters.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// An ambiguous delimiter is a delimiter that, if appeared decoded, would be
end_comment
begin_comment
comment|// interpreted as the beginning of a new component. The exact delimiters that
end_comment
begin_comment
comment|// match that definition change according to the use. When each field is
end_comment
begin_comment
comment|// considered in isolation from the rest, there are no ambiguities. In other
end_comment
begin_comment
comment|// words, we always store the most decoded form (except for the query, see
end_comment
begin_comment
comment|// below).
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The ambiguities arise when components are put together. From last to first
end_comment
begin_comment
comment|// component of a full URL, the ambiguities are:
end_comment
begin_comment
comment|//  - fragment: none, since it's the last.
end_comment
begin_comment
comment|//  - query: the "#" character is ambiguous, as it starts the fragment. In
end_comment
begin_comment
comment|//    addition, the "+" character is treated specially, as should be both
end_comment
begin_comment
comment|//    intra-query delimiters. Since we don't know which ones they are, we
end_comment
begin_comment
comment|//    keep all reserved characters untouched.
end_comment
begin_comment
comment|//  - path: the "#" and "?" characters are ambigous. In addition to them,
end_comment
begin_comment
comment|//    the slash itself is considered special.
end_comment
begin_comment
comment|//  - host: completely special but never ambiguous, see setHost() below.
end_comment
begin_comment
comment|//  - password: the "#", "?", "/", "[", "]" and "@" characters are ambiguous
end_comment
begin_comment
comment|//  - username: the "#", "?", "/", "[", "]", "@", and ":" characters are ambiguous
end_comment
begin_comment
comment|//  - scheme: doesn't accept any delimiter, see setScheme() below.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// When the authority component is considered in isolation, the ambiguities of
end_comment
begin_comment
comment|// its components are:
end_comment
begin_comment
comment|//  - host: special, never ambiguous
end_comment
begin_comment
comment|//  - password: "[", "]", "@" are ambiguous
end_comment
begin_comment
comment|//  - username: "[", "]", "@", ":" are ambiguous
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Finally, when the userinfo is considered in isolation, the ambiguities of its
end_comment
begin_comment
comment|// components are:
end_comment
begin_comment
comment|//  - password: none, since it's the last
end_comment
begin_comment
comment|//  - username: ":" is ambiguous
end_comment
begin_comment
comment|// list the recoding table modifications to be used with the recodeFromUser and
end_comment
begin_comment
comment|// appendToUser functions, according to the rules above.
end_comment
begin_comment
comment|// the encodedXXX tables are run with the delimiters set to "leave" by default;
end_comment
begin_comment
comment|// the decodedXXX tables are run with the delimiters set to "decode" by default
end_comment
begin_comment
comment|// (except for the query, which doesn't use these functions)
end_comment
begin_define
DECL|macro|decode
define|#
directive|define
name|decode
parameter_list|(
name|x
parameter_list|)
value|ushort(x)
end_define
begin_define
DECL|macro|leave
define|#
directive|define
name|leave
parameter_list|(
name|x
parameter_list|)
value|ushort(0x100 | (x))
end_define
begin_define
DECL|macro|encode
define|#
directive|define
name|encode
parameter_list|(
name|x
parameter_list|)
value|ushort(0x200 | (x))
end_define
begin_decl_stmt
DECL|variable|encodedUserNameActions
specifier|static
specifier|const
name|ushort
name|encodedUserNameActions
index|[]
init|=
block|{
comment|// first field, everything must be encoded, including the ":"
comment|//    userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
name|encode
argument_list|(
literal|'/'
argument_list|)
block|,
comment|// 0
name|encode
argument_list|(
literal|'?'
argument_list|)
block|,
comment|// 1
name|encode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 2
name|encode
argument_list|(
literal|'['
argument_list|)
block|,
comment|// 3
name|encode
argument_list|(
literal|']'
argument_list|)
block|,
comment|// 4
name|encode
argument_list|(
literal|'@'
argument_list|)
block|,
comment|// 5
name|encode
argument_list|(
literal|':'
argument_list|)
block|,
comment|// 6
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedUserNameInAuthorityActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedUserNameInAuthorityActions
init|=
name|encodedUserNameActions
operator|+
literal|3
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedUserNameInUserInfoActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedUserNameInUserInfoActions
init|=
name|encodedUserNameActions
operator|+
literal|6
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedUserNameInUrlActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedUserNameInUrlActions
init|=
name|encodedUserNameActions
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedUserNameInIsolationActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedUserNameInIsolationActions
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|encodedPasswordActions
specifier|static
specifier|const
name|ushort
name|encodedPasswordActions
index|[]
init|=
block|{
comment|// same as encodedUserNameActions, but decode ":"
comment|//    userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
name|encode
argument_list|(
literal|'/'
argument_list|)
block|,
comment|// 0
name|encode
argument_list|(
literal|'?'
argument_list|)
block|,
comment|// 1
name|encode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 2
name|encode
argument_list|(
literal|'['
argument_list|)
block|,
comment|// 3
name|encode
argument_list|(
literal|']'
argument_list|)
block|,
comment|// 4
name|encode
argument_list|(
literal|'@'
argument_list|)
block|,
comment|// 5
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedPasswordInAuthorityActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedPasswordInAuthorityActions
init|=
name|encodedPasswordActions
operator|+
literal|3
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedPasswordInUserInfoActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedPasswordInUserInfoActions
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedPasswordInUrlActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedPasswordInUrlActions
init|=
name|encodedPasswordActions
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedPasswordInIsolationActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedPasswordInIsolationActions
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|encodedPathActions
specifier|static
specifier|const
name|ushort
name|encodedPathActions
index|[]
init|=
block|{
comment|//    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
name|encode
argument_list|(
literal|'['
argument_list|)
block|,
comment|// 0
name|encode
argument_list|(
literal|']'
argument_list|)
block|,
comment|// 1
name|encode
argument_list|(
literal|'?'
argument_list|)
block|,
comment|// 2
name|encode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 3
name|leave
argument_list|(
literal|'/'
argument_list|)
block|,
comment|// 4
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedPathInUrlActions
specifier|static
specifier|const
name|ushort
name|decodedPathInUrlActions
index|[]
init|=
block|{
name|decode
argument_list|(
literal|'{'
argument_list|)
block|,
comment|// 0
name|decode
argument_list|(
literal|'}'
argument_list|)
block|,
comment|// 1
name|encode
argument_list|(
literal|'?'
argument_list|)
block|,
comment|// 2
name|encode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 3
name|leave
argument_list|(
literal|'/'
argument_list|)
block|,
comment|// 4
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedPathInIsolationActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedPathInIsolationActions
init|=
name|encodedPathActions
operator|+
literal|4
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|decodedPathInIsolationActions
comment|// leave('/')
end_comment
begin_decl_stmt
DECL|variable|encodedFragmentActions
specifier|static
specifier|const
name|ushort
name|encodedFragmentActions
index|[]
init|=
block|{
comment|//    fragment      = *( pchar / "/" / "?" )
comment|// gen-delims permitted: ":" / "@" / "/" / "?"
comment|//   ->   must encode: "[" / "]" / "#"
comment|// HOWEVER: we allow "#" to remain decoded
name|decode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 0
name|decode
argument_list|(
literal|':'
argument_list|)
block|,
comment|// 1
name|decode
argument_list|(
literal|'@'
argument_list|)
block|,
comment|// 2
name|decode
argument_list|(
literal|'/'
argument_list|)
block|,
comment|// 3
name|decode
argument_list|(
literal|'?'
argument_list|)
block|,
comment|// 4
name|encode
argument_list|(
literal|'['
argument_list|)
block|,
comment|// 5
name|encode
argument_list|(
literal|']'
argument_list|)
block|,
comment|// 6
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedFragmentInUrlActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedFragmentInUrlActions
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedFragmentInIsolationActions
specifier|static
specifier|const
name|ushort
modifier|*
specifier|const
name|decodedFragmentInIsolationActions
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|// the query is handled specially: the decodedQueryXXX tables are run with
end_comment
begin_comment
comment|// the delimiters set to "leave" by default and the others set to "encode"
end_comment
begin_decl_stmt
DECL|variable|encodedQueryActions
specifier|static
specifier|const
name|ushort
name|encodedQueryActions
index|[]
init|=
block|{
comment|//    query         = *( pchar / "/" / "?" )
comment|// gen-delims permitted: ":" / "@" / "/" / "?"
comment|// HOWEVER: we leave alone them alone, plus "[" and "]"
comment|//   ->   must encode: "#"
name|encode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 0
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedQueryInIsolationActions
specifier|static
specifier|const
name|ushort
name|decodedQueryInIsolationActions
index|[]
init|=
block|{
name|decode
argument_list|(
literal|'"'
argument_list|)
block|,
comment|// 0
name|decode
argument_list|(
literal|'<'
argument_list|)
block|,
comment|// 1
name|decode
argument_list|(
literal|'>'
argument_list|)
block|,
comment|// 2
name|decode
argument_list|(
literal|'^'
argument_list|)
block|,
comment|// 3
name|decode
argument_list|(
literal|'\\'
argument_list|)
block|,
comment|// 4
name|decode
argument_list|(
literal|'|'
argument_list|)
block|,
comment|// 5
name|decode
argument_list|(
literal|'{'
argument_list|)
block|,
comment|// 6
name|decode
argument_list|(
literal|'}'
argument_list|)
block|,
comment|// 7
name|decode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 8
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decodedQueryInUrlActions
specifier|static
specifier|const
name|ushort
name|decodedQueryInUrlActions
index|[]
init|=
block|{
name|decode
argument_list|(
literal|'{'
argument_list|)
block|,
comment|// 6
name|decode
argument_list|(
literal|'}'
argument_list|)
block|,
comment|// 7
name|encode
argument_list|(
literal|'#'
argument_list|)
block|,
comment|// 8
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|parseDecodedComponent
specifier|static
specifier|inline
name|void
name|parseDecodedComponent
parameter_list|(
name|QString
modifier|&
name|data
parameter_list|)
block|{
name|data
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
argument_list|,
name|QStringLiteral
argument_list|(
literal|"%25"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|QString
DECL|function|recodeFromUser
name|recodeFromUser
parameter_list|(
specifier|const
name|QString
modifier|&
name|input
parameter_list|,
specifier|const
name|ushort
modifier|*
name|actions
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|QString
name|output
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|begin
init|=
name|input
operator|.
name|constData
argument_list|()
operator|+
name|from
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|end
init|=
name|input
operator|.
name|constData
argument_list|()
operator|+
name|to
decl_stmt|;
if|if
condition|(
name|qt_urlRecode
argument_list|(
name|output
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|QUrl
operator|::
name|DecodeReserved
argument_list|,
name|actions
argument_list|)
condition|)
return|return
name|output
return|;
return|return
name|input
operator|.
name|mid
argument_list|(
name|from
argument_list|,
name|to
operator|-
name|from
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// appendXXXX functions:
end_comment
begin_comment
comment|// the internal value is stored in its most decoded form, so that case is easy.
end_comment
begin_comment
comment|// DecodeUnicode and DecodeSpaces are handled by qt_urlRecode.
end_comment
begin_comment
comment|// That leaves these functions to handle two cases related to delimiters:
end_comment
begin_comment
comment|//  1) encoded                           encodedXXXX tables
end_comment
begin_comment
comment|//  2) decoded                           decodedXXXX tables
end_comment
begin_function
DECL|function|appendToUser
specifier|static
specifier|inline
name|void
name|appendToUser
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|,
specifier|const
name|ushort
modifier|*
name|encodedActions
parameter_list|,
specifier|const
name|ushort
modifier|*
name|decodedActions
parameter_list|)
block|{
if|if
condition|(
name|options
operator|==
name|QUrl
operator|::
name|PrettyDecoded
condition|)
block|{
name|appendTo
operator|+=
name|value
expr_stmt|;
return|return;
block|}
specifier|const
name|ushort
modifier|*
name|actions
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|options
operator|&
name|QUrl
operator|::
name|EncodeDelimiters
condition|)
name|actions
operator|=
name|encodedActions
expr_stmt|;
else|else
name|actions
operator|=
name|decodedActions
expr_stmt|;
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|appendTo
argument_list|,
name|value
operator|.
name|constData
argument_list|()
argument_list|,
name|value
operator|.
name|constEnd
argument_list|()
argument_list|,
name|options
argument_list|,
name|actions
argument_list|)
condition|)
name|appendTo
operator|+=
name|value
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendAuthority
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendAuthority
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|,
name|Section
name|appendingTo
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveUserInfo
operator|)
operator|!=
name|QUrl
operator|::
name|RemoveUserInfo
condition|)
block|{
name|appendUserInfo
argument_list|(
name|appendTo
argument_list|,
name|options
argument_list|,
name|appendingTo
argument_list|)
expr_stmt|;
comment|// add '@' only if we added anything
if|if
condition|(
name|hasUserName
argument_list|()
operator|||
operator|(
name|hasPassword
argument_list|()
operator|&&
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemovePassword
operator|)
operator|==
literal|0
operator|)
condition|)
name|appendTo
operator|+=
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
block|}
name|appendHost
argument_list|(
name|appendTo
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemovePort
operator|)
operator|&&
name|port
operator|!=
operator|-
literal|1
condition|)
name|appendTo
operator|+=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendUserInfo
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendUserInfo
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|,
name|Section
name|appendingTo
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|Q_LIKELY
argument_list|(
operator|!
name|hasUserInfo
argument_list|()
argument_list|)
condition|)
return|return;
specifier|const
name|ushort
modifier|*
name|userNameActions
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|passwordActions
decl_stmt|;
if|if
condition|(
name|options
operator|&
name|QUrl
operator|::
name|EncodeDelimiters
condition|)
block|{
name|userNameActions
operator|=
name|encodedUserNameActions
expr_stmt|;
name|passwordActions
operator|=
name|encodedPasswordActions
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|appendingTo
condition|)
block|{
case|case
name|UserInfo
case|:
name|userNameActions
operator|=
name|decodedUserNameInUserInfoActions
expr_stmt|;
name|passwordActions
operator|=
name|decodedPasswordInUserInfoActions
expr_stmt|;
break|break;
case|case
name|Authority
case|:
name|userNameActions
operator|=
name|decodedUserNameInAuthorityActions
expr_stmt|;
name|passwordActions
operator|=
name|decodedPasswordInAuthorityActions
expr_stmt|;
break|break;
case|case
name|FullUrl
case|:
default|default:
name|userNameActions
operator|=
name|decodedUserNameInUrlActions
expr_stmt|;
name|passwordActions
operator|=
name|decodedPasswordInUrlActions
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|EncodeReserved
operator|)
operator|==
literal|0
condition|)
name|options
operator||=
name|QUrl
operator|::
name|DecodeReserved
expr_stmt|;
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|appendTo
argument_list|,
name|userName
operator|.
name|constData
argument_list|()
argument_list|,
name|userName
operator|.
name|constEnd
argument_list|()
argument_list|,
name|options
argument_list|,
name|userNameActions
argument_list|)
condition|)
name|appendTo
operator|+=
name|userName
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|QUrl
operator|::
name|RemovePassword
operator|||
operator|!
name|hasPassword
argument_list|()
condition|)
block|{
return|return;
block|}
else|else
block|{
name|appendTo
operator|+=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|appendTo
argument_list|,
name|password
operator|.
name|constData
argument_list|()
argument_list|,
name|password
operator|.
name|constEnd
argument_list|()
argument_list|,
name|options
argument_list|,
name|passwordActions
argument_list|)
condition|)
name|appendTo
operator|+=
name|password
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|appendUserName
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendUserName
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
name|appendToUser
argument_list|(
name|appendTo
argument_list|,
name|userName
argument_list|,
name|options
argument_list|,
name|encodedUserNameActions
argument_list|,
name|decodedUserNameInIsolationActions
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendPassword
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendPassword
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
name|appendToUser
argument_list|(
name|appendTo
argument_list|,
name|password
argument_list|,
name|options
argument_list|,
name|encodedPasswordActions
argument_list|,
name|decodedPasswordInIsolationActions
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendPath
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendPath
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|,
name|Section
name|appendingTo
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|appendingTo
operator|!=
name|Path
operator|&&
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|EncodeDelimiters
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|appendTo
argument_list|,
name|path
operator|.
name|constData
argument_list|()
argument_list|,
name|path
operator|.
name|constEnd
argument_list|()
argument_list|,
name|options
argument_list|,
name|decodedPathInUrlActions
argument_list|)
condition|)
name|appendTo
operator|+=
name|path
expr_stmt|;
block|}
else|else
block|{
name|appendToUser
argument_list|(
name|appendTo
argument_list|,
name|path
argument_list|,
name|options
argument_list|,
name|encodedPathActions
argument_list|,
name|decodedPathInIsolationActions
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|appendFragment
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendFragment
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
name|appendToUser
argument_list|(
name|appendTo
argument_list|,
name|fragment
argument_list|,
name|options
argument_list|,
name|encodedFragmentActions
argument_list|,
name|decodedFragmentInIsolationActions
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendQuery
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendQuery
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|,
name|Section
name|appendingTo
parameter_list|)
specifier|const
block|{
comment|// almost the same code as the previous functions
comment|// except we prefer not to touch the delimiters
if|if
condition|(
name|options
operator|==
name|QUrl
operator|::
name|PrettyDecoded
operator|&&
name|appendingTo
operator|==
name|Query
condition|)
block|{
name|appendTo
operator|+=
name|query
expr_stmt|;
return|return;
block|}
specifier|const
name|ushort
modifier|*
name|actions
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|options
operator|&
name|QUrl
operator|::
name|EncodeDelimiters
condition|)
block|{
name|actions
operator|=
name|encodedQueryActions
expr_stmt|;
block|}
else|else
block|{
comment|// reset to default qt_urlRecode behaviour (leave delimiters alone)
name|options
operator||=
name|QUrl
operator|::
name|EncodeDelimiters
expr_stmt|;
name|actions
operator|=
name|appendingTo
operator|==
name|Query
condition|?
name|decodedQueryInIsolationActions
else|:
name|decodedQueryInUrlActions
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|appendTo
argument_list|,
name|query
operator|.
name|constData
argument_list|()
argument_list|,
name|query
operator|.
name|constData
argument_list|()
operator|+
name|query
operator|.
name|length
argument_list|()
argument_list|,
name|options
argument_list|,
name|actions
argument_list|)
condition|)
name|appendTo
operator|+=
name|query
expr_stmt|;
block|}
end_function
begin_comment
comment|// setXXX functions
end_comment
begin_function
DECL|function|setScheme
specifier|inline
name|bool
name|QUrlPrivate
operator|::
name|setScheme
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|len
parameter_list|,
name|bool
name|doSetError
parameter_list|)
block|{
comment|// schemes are strictly RFC-compliant:
comment|//    scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
comment|// we also lowercase the scheme
comment|// schemes in URLs are not allowed to be empty, but they can be in
comment|// "Relative URIs" which QUrl also supports. QUrl::setScheme does
comment|// not call us with len == 0, so this can only be from parse()
name|scheme
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|false
return|;
name|sectionIsPresent
operator||=
name|Scheme
expr_stmt|;
comment|// validate it:
name|int
name|needsLowercasing
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|p
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|value
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|>=
literal|'a'
operator|&&
name|p
index|[
name|i
index|]
operator|<=
literal|'z'
condition|)
continue|continue;
if|if
condition|(
name|p
index|[
name|i
index|]
operator|>=
literal|'A'
operator|&&
name|p
index|[
name|i
index|]
operator|<=
literal|'Z'
condition|)
block|{
name|needsLowercasing
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|p
index|[
name|i
index|]
operator|<=
literal|'9'
operator|&&
name|i
operator|>
literal|0
condition|)
continue|continue;
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
name|i
index|]
operator|==
literal|'-'
operator|||
name|p
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
continue|continue;
comment|// found something else
comment|// don't call setError needlessly:
comment|// if we've been called from parse(), it will try to recover
if|if
condition|(
name|doSetError
condition|)
name|setError
argument_list|(
name|InvalidSchemeError
argument_list|,
name|value
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|scheme
operator|=
name|value
operator|.
name|left
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsLowercasing
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// schemes are ASCII only, so we don't need the full Unicode toLower
name|QChar
modifier|*
name|schemeData
init|=
name|scheme
operator|.
name|data
argument_list|()
decl_stmt|;
comment|// force detaching here
for|for
control|(
name|int
name|i
init|=
name|needsLowercasing
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
specifier|register
name|ushort
name|c
init|=
name|schemeData
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
name|schemeData
index|[
name|i
index|]
operator|=
name|c
operator|+
literal|0x20
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setAuthority
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|setAuthority
parameter_list|(
specifier|const
name|QString
modifier|&
name|auth
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|,
name|QUrl
operator|::
name|ParsingMode
name|mode
parameter_list|)
block|{
name|sectionIsPresent
operator|&=
operator|~
name|Authority
expr_stmt|;
name|sectionIsPresent
operator||=
name|Host
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|end
condition|)
block|{
name|userName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|password
operator|.
name|clear
argument_list|()
expr_stmt|;
name|host
operator|.
name|clear
argument_list|()
expr_stmt|;
name|port
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|int
name|userInfoIndex
init|=
name|auth
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
argument_list|,
name|from
argument_list|)
decl_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|userInfoIndex
argument_list|)
operator|<
name|uint
argument_list|(
name|end
argument_list|)
condition|)
block|{
name|setUserInfo
argument_list|(
name|auth
argument_list|,
name|from
argument_list|,
name|userInfoIndex
argument_list|)
expr_stmt|;
name|from
operator|=
name|userInfoIndex
operator|+
literal|1
expr_stmt|;
block|}
name|int
name|colonIndex
init|=
name|auth
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|,
name|end
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|colonIndex
operator|<
name|from
condition|)
name|colonIndex
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|colonIndex
argument_list|)
operator|<
name|uint
argument_list|(
name|end
argument_list|)
condition|)
block|{
if|if
condition|(
name|auth
operator|.
name|at
argument_list|(
name|from
argument_list|)
operator|.
name|unicode
argument_list|()
operator|==
literal|'['
condition|)
block|{
comment|// check if colonIndex isn't inside the "[...]" part
name|int
name|closingBracket
init|=
name|auth
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
argument_list|,
name|from
argument_list|)
decl_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|closingBracket
argument_list|)
operator|>
name|uint
argument_list|(
name|colonIndex
argument_list|)
condition|)
name|colonIndex
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|colonIndex
operator|==
name|end
operator|-
literal|1
condition|)
block|{
comment|// found a colon but no digits after it
name|setError
argument_list|(
name|PortEmptyError
argument_list|,
name|auth
argument_list|,
name|colonIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uint
argument_list|(
name|colonIndex
argument_list|)
operator|<
name|uint
argument_list|(
name|end
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|colonIndex
operator|+
literal|1
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
block|{
name|ushort
name|c
init|=
name|auth
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|x
operator|*=
literal|10
expr_stmt|;
name|x
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|ulong
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// x != ushort(x)
break|break;
block|}
block|}
if|if
condition|(
name|x
operator|==
name|ushort
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|port
operator|=
name|ushort
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setError
argument_list|(
name|InvalidPortError
argument_list|,
name|auth
argument_list|,
name|colonIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|port
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|setHost
argument_list|(
name|auth
argument_list|,
name|from
argument_list|,
name|qMin
argument_list|<
name|uint
argument_list|>
argument_list|(
name|end
argument_list|,
name|colonIndex
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setUserInfo
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|setUserInfo
parameter_list|(
specifier|const
name|QString
modifier|&
name|userInfo
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|int
name|delimIndex
init|=
name|userInfo
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|,
name|from
argument_list|)
decl_stmt|;
name|setUserName
argument_list|(
name|userInfo
argument_list|,
name|from
argument_list|,
name|qMin
argument_list|<
name|uint
argument_list|>
argument_list|(
name|delimIndex
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|delimIndex
argument_list|)
operator|>=
name|uint
argument_list|(
name|end
argument_list|)
condition|)
block|{
name|password
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sectionIsPresent
operator|&=
operator|~
name|Password
expr_stmt|;
block|}
else|else
block|{
name|setPassword
argument_list|(
name|userInfo
argument_list|,
name|delimIndex
operator|+
literal|1
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setUserName
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|setUserName
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|sectionIsPresent
operator||=
name|UserName
expr_stmt|;
name|userName
operator|=
name|recodeFromUser
argument_list|(
name|value
argument_list|,
name|decodedUserNameInIsolationActions
argument_list|,
name|from
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setPassword
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|setPassword
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|sectionIsPresent
operator||=
name|Password
expr_stmt|;
name|password
operator|=
name|recodeFromUser
argument_list|(
name|value
argument_list|,
name|decodedPasswordInIsolationActions
argument_list|,
name|from
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setPath
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|setPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
block|{
comment|// sectionIsPresent |= Path; // not used, save some cycles
name|path
operator|=
name|recodeFromUser
argument_list|(
name|value
argument_list|,
name|decodedPathInIsolationActions
argument_list|,
name|from
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setFragment
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|setFragment
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|sectionIsPresent
operator||=
name|Fragment
expr_stmt|;
name|fragment
operator|=
name|recodeFromUser
argument_list|(
name|value
argument_list|,
name|decodedFragmentInIsolationActions
argument_list|,
name|from
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setQuery
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|setQuery
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|iend
parameter_list|)
block|{
name|sectionIsPresent
operator||=
name|Query
expr_stmt|;
comment|// use the default actions for the query (don't set QUrl::DecodeAllDelimiters)
name|QString
name|output
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|begin
init|=
name|value
operator|.
name|constData
argument_list|()
operator|+
name|from
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|end
init|=
name|value
operator|.
name|constData
argument_list|()
operator|+
name|iend
decl_stmt|;
comment|// leave delimiters alone but decode the rest
if|if
condition|(
name|qt_urlRecode
argument_list|(
name|output
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|QUrl
operator|::
name|EncodeDelimiters
argument_list|,
name|decodedQueryInIsolationActions
argument_list|)
condition|)
name|query
operator|=
name|output
expr_stmt|;
else|else
name|query
operator|=
name|value
operator|.
name|mid
argument_list|(
name|from
argument_list|,
name|iend
operator|-
name|from
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Host handling
end_comment
begin_comment
comment|// The RFC says the host is:
end_comment
begin_comment
comment|//    host          = IP-literal / IPv4address / reg-name
end_comment
begin_comment
comment|//    IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"
end_comment
begin_comment
comment|//    IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
end_comment
begin_comment
comment|//  [a strict definition of IPv6Address and IPv4Address]
end_comment
begin_comment
comment|//     reg-name      = *( unreserved / pct-encoded / sub-delims )
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// We deviate from the standard in all but IPvFuture. For IPvFuture we accept
end_comment
begin_comment
comment|// and store only exactly what the RFC says we should. No percent-encoding is
end_comment
begin_comment
comment|// permitted in this field, so Unicode characters and space aren't either.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// For IPv4 addresses, we accept broken addresses like inet_aton does (that is,
end_comment
begin_comment
comment|// less than three dots). However, we correct the address to the proper form
end_comment
begin_comment
comment|// and store the corrected address. After correction, we comply to the RFC and
end_comment
begin_comment
comment|// it's exclusively composed of unreserved characters.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// For IPv6 addresses, we accept addresses including trailing (embedded) IPv4
end_comment
begin_comment
comment|// addresses, the so-called v4-compat and v4-mapped addresses. We also store
end_comment
begin_comment
comment|// those addresses like that in the hostname field, which violates the spec.
end_comment
begin_comment
comment|// IPv6 hosts are stored with the square brackets in the QString. It also
end_comment
begin_comment
comment|// requires no transformation in any way.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// As for registered names, it's the other way around: we accept only valid
end_comment
begin_comment
comment|// hostnames as specified by STD 3 and IDNA. That means everything we accept is
end_comment
begin_comment
comment|// valid in the RFC definition above, but there are many valid reg-names
end_comment
begin_comment
comment|// according to the RFC that we do not accept in the name of security. Since we
end_comment
begin_comment
comment|// do accept IDNA, reg-names are subject to ACE encoding and decoding, which is
end_comment
begin_comment
comment|// specified by the DecodeUnicode flag. The hostname is stored in its Unicode form.
end_comment
begin_function
DECL|function|appendHost
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|appendHost
parameter_list|(
name|QString
modifier|&
name|appendTo
parameter_list|,
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
comment|// this is the only flag that matters
name|options
operator|&=
name|QUrl
operator|::
name|EncodeUnicode
expr_stmt|;
if|if
condition|(
name|host
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|host
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|unicode
argument_list|()
operator|==
literal|'['
condition|)
block|{
comment|// IPv6Address and IPvFuture address never require any transformation
name|appendTo
operator|+=
name|host
expr_stmt|;
block|}
else|else
block|{
comment|// this is either an IPv4Address or a reg-name
comment|// if it is a reg-name, it is already stored in Unicode form
if|if
condition|(
name|options
operator|==
name|QUrl
operator|::
name|EncodeUnicode
condition|)
name|appendTo
operator|+=
name|qt_ACE_do
argument_list|(
name|host
argument_list|,
name|ToAceOnly
argument_list|)
expr_stmt|;
else|else
name|appendTo
operator|+=
name|host
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// the whole IPvFuture is passed and parsed here, including brackets;
end_comment
begin_comment
comment|// returns null if the parsing was successful, or the QChar of the first failure
end_comment
begin_function
DECL|function|parseIpFuture
specifier|static
specifier|const
name|QChar
modifier|*
name|parseIpFuture
parameter_list|(
name|QString
modifier|&
name|host
parameter_list|,
specifier|const
name|QChar
modifier|*
name|begin
parameter_list|,
specifier|const
name|QChar
modifier|*
name|end
parameter_list|)
block|{
comment|//    IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
specifier|static
specifier|const
name|char
name|acceptable
index|[]
init|=
literal|"!$&'()*+,;="
comment|// sub-delims
literal|":"
comment|// ":"
literal|"-._~"
decl_stmt|;
comment|// unreserved
comment|// the brackets and the "v" have been checked
if|if
condition|(
name|begin
index|[
literal|3
index|]
operator|.
name|unicode
argument_list|()
operator|!=
literal|'.'
condition|)
return|return
operator|&
name|begin
index|[
literal|3
index|]
return|;
if|if
condition|(
operator|(
name|begin
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|>=
literal|'A'
operator|&&
name|begin
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|>=
literal|'F'
operator|)
operator|||
operator|(
name|begin
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|>=
literal|'a'
operator|&&
name|begin
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|begin
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|>=
literal|'0'
operator|&&
name|begin
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|<=
literal|'9'
operator|)
condition|)
block|{
comment|// this is so unlikely that we'll just go down the slow path
comment|// decode the whole string, skipping the "[vH." and "]" which we already know to be there
name|host
operator|+=
name|QString
operator|::
name|fromRawData
argument_list|(
name|begin
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|begin
operator|+=
literal|4
expr_stmt|;
operator|--
name|end
expr_stmt|;
name|QString
name|decoded
decl_stmt|;
if|if
condition|(
name|qt_urlRecode
argument_list|(
name|decoded
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|QUrl
operator|::
name|FullyEncoded
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|begin
operator|=
name|decoded
operator|.
name|constBegin
argument_list|()
expr_stmt|;
name|end
operator|=
name|decoded
operator|.
name|constEnd
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
name|begin
operator|!=
name|end
condition|;
operator|++
name|begin
control|)
block|{
if|if
condition|(
name|begin
operator|->
name|unicode
argument_list|()
operator|>=
literal|'A'
operator|&&
name|begin
operator|->
name|unicode
argument_list|()
operator|<=
literal|'Z'
condition|)
name|host
operator|+=
operator|*
name|begin
expr_stmt|;
elseif|else
if|if
condition|(
name|begin
operator|->
name|unicode
argument_list|()
operator|>=
literal|'a'
operator|&&
name|begin
operator|->
name|unicode
argument_list|()
operator|<=
literal|'z'
condition|)
name|host
operator|+=
operator|*
name|begin
expr_stmt|;
elseif|else
if|if
condition|(
name|begin
operator|->
name|unicode
argument_list|()
operator|>=
literal|'0'
operator|&&
name|begin
operator|->
name|unicode
argument_list|()
operator|<=
literal|'9'
condition|)
name|host
operator|+=
operator|*
name|begin
expr_stmt|;
elseif|else
if|if
condition|(
name|begin
operator|->
name|unicode
argument_list|()
operator|<
literal|0x80
operator|&&
name|strchr
argument_list|(
name|acceptable
argument_list|,
name|begin
operator|->
name|unicode
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
name|host
operator|+=
operator|*
name|begin
expr_stmt|;
else|else
return|return
name|begin
return|;
block|}
name|host
operator|+=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|&
name|begin
index|[
literal|2
index|]
return|;
block|}
end_function
begin_comment
comment|// ONLY the IPv6 address is parsed here, WITHOUT the brackets
end_comment
begin_function
DECL|function|parseIp6
specifier|static
name|bool
name|parseIp6
parameter_list|(
name|QString
modifier|&
name|host
parameter_list|,
specifier|const
name|QChar
modifier|*
name|begin
parameter_list|,
specifier|const
name|QChar
modifier|*
name|end
parameter_list|)
block|{
name|QIPAddressUtils
operator|::
name|IPv6Address
name|address
decl_stmt|;
if|if
condition|(
operator|!
name|QIPAddressUtils
operator|::
name|parseIp6
argument_list|(
name|address
argument_list|,
name|begin
argument_list|,
name|end
argument_list|)
condition|)
block|{
comment|// IPv6 failed parsing, check if it was a percent-encoded character in
comment|// the middle and try again
name|QString
name|decoded
decl_stmt|;
if|if
condition|(
operator|!
name|qt_urlRecode
argument_list|(
name|decoded
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|QUrl
operator|::
name|FullyEncoded
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|// no transformation, nothing to re-parse
return|return
literal|false
return|;
block|}
comment|// recurse
comment|// if the parsing fails again, the qt_urlRecode above will return 0
return|return
name|parseIp6
argument_list|(
name|host
argument_list|,
name|decoded
operator|.
name|constBegin
argument_list|()
argument_list|,
name|decoded
operator|.
name|constEnd
argument_list|()
argument_list|)
return|;
block|}
name|host
operator|.
name|reserve
argument_list|(
name|host
operator|.
name|size
argument_list|()
operator|+
operator|(
name|end
operator|-
name|begin
operator|)
argument_list|)
expr_stmt|;
name|host
operator|+=
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|QIPAddressUtils
operator|::
name|toString
argument_list|(
name|host
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|host
operator|+=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setHost
specifier|inline
name|bool
name|QUrlPrivate
operator|::
name|setHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|iend
parameter_list|,
name|QUrl
operator|::
name|ParsingMode
name|mode
parameter_list|)
block|{
specifier|const
name|QChar
modifier|*
name|begin
init|=
name|value
operator|.
name|constData
argument_list|()
operator|+
name|from
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|end
init|=
name|value
operator|.
name|constData
argument_list|()
operator|+
name|iend
decl_stmt|;
specifier|const
name|int
name|len
init|=
name|end
operator|-
name|begin
decl_stmt|;
name|host
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sectionIsPresent
operator||=
name|Host
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|begin
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'['
condition|)
block|{
comment|// IPv6Address or IPvFuture
comment|// smallest IPv6 address is      "[::]"   (len = 4)
comment|// smallest IPvFuture address is "[v7.X]" (len = 6)
if|if
condition|(
name|end
index|[
operator|-
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|!=
literal|']'
condition|)
block|{
name|setError
argument_list|(
name|HostMissingEndBracket
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|len
operator|>
literal|5
operator|&&
name|begin
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'v'
condition|)
block|{
specifier|const
name|QChar
modifier|*
name|c
init|=
name|parseIpFuture
argument_list|(
name|host
argument_list|,
name|begin
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
condition|)
name|setError
argument_list|(
name|InvalidIPvFutureError
argument_list|,
name|value
argument_list|,
name|c
operator|-
name|value
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|!
name|c
return|;
block|}
if|if
condition|(
name|parseIp6
argument_list|(
name|host
argument_list|,
name|begin
operator|+
literal|1
argument_list|,
name|end
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|true
return|;
name|setError
argument_list|(
name|begin
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'v'
condition|?
name|InvalidIPvFutureError
else|:
name|InvalidIPv6AddressError
argument_list|,
name|value
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// check if it's an IPv4 address
name|QIPAddressUtils
operator|::
name|IPv4Address
name|ip4
decl_stmt|;
if|if
condition|(
name|QIPAddressUtils
operator|::
name|parseIp4
argument_list|(
name|ip4
argument_list|,
name|begin
argument_list|,
name|end
argument_list|)
condition|)
block|{
comment|// yes, it was
name|QIPAddressUtils
operator|::
name|toString
argument_list|(
name|host
argument_list|,
name|ip4
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// This is probably a reg-name.
comment|// But it can also be an encoded string that, when decoded becomes one
comment|// of the types above.
comment|//
comment|// Two types of encoding are possible:
comment|//  percent encoding (e.g., "%31%30%2E%30%2E%30%2E%31" -> "10.0.0.1")
comment|//  Unicode encoding (some non-ASCII characters case-fold to digits
comment|//                    when nameprepping is done)
comment|//
comment|// The qt_ACE_do function below applies nameprepping and the STD3 check.
comment|// That means a Unicode string may become an IPv4 address, but it cannot
comment|// produce a '[' or a '%'.
comment|// check for percent-encoding first
name|QString
name|s
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|QUrl
operator|::
name|TolerantMode
operator|&&
name|qt_urlRecode
argument_list|(
name|s
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|QUrl
operator|::
name|DecodeReserved
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|// something was decoded
comment|// anything encoded left?
name|int
name|pos
init|=
name|s
operator|.
name|indexOf
argument_list|(
name|QChar
argument_list|(
literal|0x25
argument_list|)
argument_list|)
decl_stmt|;
comment|// '%'
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
name|setError
argument_list|(
name|InvalidRegNameError
argument_list|,
name|s
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// recurse
return|return
name|setHost
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|,
name|QUrl
operator|::
name|StrictMode
argument_list|)
return|;
block|}
name|s
operator|=
name|qt_ACE_do
argument_list|(
name|QString
operator|::
name|fromRawData
argument_list|(
name|begin
argument_list|,
name|len
argument_list|)
argument_list|,
name|NormalizeAce
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|setError
argument_list|(
name|InvalidRegNameError
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// check IPv4 again
if|if
condition|(
name|QIPAddressUtils
operator|::
name|parseIp4
argument_list|(
name|ip4
argument_list|,
name|s
operator|.
name|constBegin
argument_list|()
argument_list|,
name|s
operator|.
name|constEnd
argument_list|()
argument_list|)
condition|)
block|{
name|QIPAddressUtils
operator|::
name|toString
argument_list|(
name|host
argument_list|,
name|ip4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|host
operator|=
name|s
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|parse
specifier|inline
name|void
name|QUrlPrivate
operator|::
name|parse
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
name|QUrl
operator|::
name|ParsingMode
name|parsingMode
parameter_list|)
block|{
comment|//   URI-reference = URI / relative-ref
comment|//   URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
comment|//   relative-ref  = relative-part [ "?" query ] [ "#" fragment ]
comment|//   hier-part     = "//" authority path-abempty
comment|//                 / other path types
comment|//   relative-part = "//" authority path-abempty
comment|//                 /  other path types here
name|sectionIsPresent
operator|=
literal|0
expr_stmt|;
name|clearError
argument_list|()
expr_stmt|;
comment|// find the important delimiters
name|int
name|colon
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|question
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|hash
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|int
name|len
init|=
name|url
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
specifier|const
name|begin
init|=
name|url
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|ushort
modifier|*
specifier|const
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|begin
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|uint
name|uc
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|uc
operator|==
literal|'#'
operator|&&
name|hash
operator|==
operator|-
literal|1
condition|)
block|{
name|hash
operator|=
name|i
expr_stmt|;
comment|// nothing more to be found
break|break;
block|}
if|if
condition|(
name|question
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|uc
operator|==
literal|':'
operator|&&
name|colon
operator|==
operator|-
literal|1
condition|)
name|colon
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|uc
operator|==
literal|'?'
condition|)
name|question
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|// check if we have a scheme
name|int
name|hierStart
decl_stmt|;
if|if
condition|(
name|colon
operator|!=
operator|-
literal|1
operator|&&
name|setScheme
argument_list|(
name|url
argument_list|,
name|colon
argument_list|,
comment|/* don't set error */
literal|false
argument_list|)
condition|)
block|{
name|hierStart
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// recover from a failed scheme: it might not have been a scheme at all
name|scheme
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sectionIsPresent
operator|=
literal|0
expr_stmt|;
name|hierStart
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|pathStart
decl_stmt|;
name|int
name|hierEnd
init|=
name|qMin
argument_list|<
name|uint
argument_list|>
argument_list|(
name|qMin
argument_list|<
name|uint
argument_list|>
argument_list|(
name|question
argument_list|,
name|hash
argument_list|)
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|hierEnd
operator|-
name|hierStart
operator|>=
literal|2
operator|&&
name|data
index|[
name|hierStart
index|]
operator|==
literal|'/'
operator|&&
name|data
index|[
name|hierStart
operator|+
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|// we have an authority, it ends at the first slash after these
name|int
name|authorityEnd
init|=
name|hierEnd
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|hierStart
operator|+
literal|2
init|;
name|i
operator|<
name|authorityEnd
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
block|{
name|authorityEnd
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|setAuthority
argument_list|(
name|url
argument_list|,
name|hierStart
operator|+
literal|2
argument_list|,
name|authorityEnd
argument_list|,
name|parsingMode
argument_list|)
expr_stmt|;
comment|// even if we failed to set the authority properly, let's try to recover
name|pathStart
operator|=
name|authorityEnd
expr_stmt|;
name|setPath
argument_list|(
name|url
argument_list|,
name|pathStart
argument_list|,
name|hierEnd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|userName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|password
operator|.
name|clear
argument_list|()
expr_stmt|;
name|host
operator|.
name|clear
argument_list|()
expr_stmt|;
name|port
operator|=
operator|-
literal|1
expr_stmt|;
name|pathStart
operator|=
name|hierStart
expr_stmt|;
if|if
condition|(
name|hierStart
operator|<
name|hierEnd
condition|)
name|setPath
argument_list|(
name|url
argument_list|,
name|hierStart
argument_list|,
name|hierEnd
argument_list|)
expr_stmt|;
else|else
name|path
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|uint
argument_list|(
name|question
argument_list|)
operator|<
name|uint
argument_list|(
name|hash
argument_list|)
condition|)
name|setQuery
argument_list|(
name|url
argument_list|,
name|question
operator|+
literal|1
argument_list|,
name|qMin
argument_list|<
name|uint
argument_list|>
argument_list|(
name|hash
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
operator|!=
operator|-
literal|1
condition|)
name|setFragment
argument_list|(
name|url
argument_list|,
name|hash
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|parsingMode
operator|==
name|QUrl
operator|::
name|TolerantMode
condition|)
return|return;
comment|// The parsing so far was tolerant of errors, so the StrictMode
comment|// parsing is actually implemented here, as an extra post-check.
comment|// We only execute it if we haven't found any errors so far.
comment|// What we need to look out for, that the regular parser tolerates:
comment|//  - percent signs not followed by two hex digits
comment|//  - forbidden characters, which should always appear encoded
comment|//    '"' / '<' / '>' / '\' / '^' / '`' / '{' / '|' / '}' / BKSP
comment|//    control characters
comment|//  - delimiters not allowed in certain positions
comment|//    . scheme: parser is already strict
comment|//    . user info: gen-delims (except for ':') disallowed
comment|//    . host: parser is stricter than the standard
comment|//    . port: parser is stricter than the standard
comment|//    . path: all delimiters allowed
comment|//    . fragment: all delimiters allowed
comment|//    . query: all delimiters allowed
comment|//    We would only need to check the user-info. However, the presence
comment|//    of the disallowed gen-delims changes the parsing, so we don't
comment|//    actually need to do anything
specifier|static
specifier|const
name|char
name|forbidden
index|[]
init|=
literal|"\"<>\\^`{|}\x7F"
decl_stmt|;
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uint
argument_list|(
name|len
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|uint
name|uc
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|uc
operator|>=
literal|0x80
condition|)
continue|continue;
if|if
condition|(
operator|(
name|uc
operator|==
literal|'%'
operator|&&
operator|(
name|uint
argument_list|(
name|len
argument_list|)
operator|<
name|i
operator|+
literal|2
operator|||
operator|!
name|isHex
argument_list|(
name|data
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isHex
argument_list|(
name|data
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
operator|)
operator|)
operator|||
name|uc
operator|<=
literal|0x20
operator|||
name|strchr
argument_list|(
name|forbidden
argument_list|,
name|uc
argument_list|)
condition|)
block|{
comment|// found an error
name|ErrorCode
name|errorCode
decl_stmt|;
comment|// where are we?
if|if
condition|(
name|i
operator|>
name|uint
argument_list|(
name|hash
argument_list|)
condition|)
block|{
name|errorCode
operator|=
name|InvalidFragmentError
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
name|uint
argument_list|(
name|question
argument_list|)
condition|)
block|{
name|errorCode
operator|=
name|InvalidQueryError
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
name|uint
argument_list|(
name|pathStart
argument_list|)
condition|)
block|{
comment|// pathStart is never -1
name|errorCode
operator|=
name|InvalidPathError
expr_stmt|;
block|}
else|else
block|{
comment|// It must be in the authority, since the scheme is strict.
comment|// Since the port and hostname parsers are also strict,
comment|// the error can only have happened in the user info.
name|int
name|pos
init|=
name|url
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|,
name|hierStart
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
name|uint
argument_list|(
name|pos
argument_list|)
condition|)
block|{
name|errorCode
operator|=
name|InvalidPasswordError
expr_stmt|;
block|}
else|else
block|{
name|errorCode
operator|=
name|InvalidUserNameError
expr_stmt|;
block|}
block|}
name|setError
argument_list|(
name|errorCode
argument_list|,
name|url
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_comment
comment|/*     From http://www.ietf.org/rfc/rfc3986.txt, 5.2.3: Merge paths      Returns a merge of the current path with the relative path passed     as argument.      Note: \a relativePath is relative (does not start with '/'). */
end_comment
begin_function
DECL|function|mergePaths
specifier|inline
name|QString
name|QUrlPrivate
operator|::
name|mergePaths
parameter_list|(
specifier|const
name|QString
modifier|&
name|relativePath
parameter_list|)
specifier|const
block|{
comment|// If the base URI has a defined authority component and an empty
comment|// path, then return a string consisting of "/" concatenated with
comment|// the reference's path; otherwise,
if|if
condition|(
operator|!
name|host
operator|.
name|isEmpty
argument_list|()
operator|&&
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|relativePath
return|;
comment|// Return a string consisting of the reference's path component
comment|// appended to all but the last segment of the base URI's path
comment|// (i.e., excluding any characters after the right-most "/" in the
comment|// base URI path, or excluding the entire base URI path if it does
comment|// not contain any "/" characters).
name|QString
name|newPath
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|newPath
operator|=
name|relativePath
expr_stmt|;
else|else
name|newPath
operator|=
name|path
operator|.
name|leftRef
argument_list|(
name|path
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
operator|+
name|relativePath
expr_stmt|;
return|return
name|newPath
return|;
block|}
end_function
begin_comment
comment|/*     From http://www.ietf.org/rfc/rfc3986.txt, 5.2.4: Remove dot segments      Removes unnecessary ../ and ./ from the path. Used for normalizing     the URL. */
end_comment
begin_function
DECL|function|removeDotsFromPath
specifier|static
name|void
name|removeDotsFromPath
parameter_list|(
name|QString
modifier|*
name|path
parameter_list|)
block|{
comment|// The input buffer is initialized with the now-appended path
comment|// components and the output buffer is initialized to the empty
comment|// string.
name|QChar
modifier|*
name|out
init|=
name|path
operator|->
name|data
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|in
init|=
name|out
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|end
init|=
name|out
operator|+
name|path
operator|->
name|size
argument_list|()
decl_stmt|;
comment|// If the input buffer consists only of
comment|// "." or "..", then remove that from the input
comment|// buffer;
if|if
condition|(
name|path
operator|->
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
condition|)
operator|++
name|in
expr_stmt|;
elseif|else
if|if
condition|(
name|path
operator|->
name|size
argument_list|()
operator|==
literal|2
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
condition|)
name|in
operator|+=
literal|2
expr_stmt|;
comment|// While the input buffer is not empty, loop:
while|while
condition|(
name|in
operator|<
name|end
condition|)
block|{
comment|// otherwise, if the input buffer begins with a prefix of "../" or "./",
comment|// then remove that prefix from the input buffer;
if|if
condition|(
name|path
operator|->
name|size
argument_list|()
operator|>=
literal|2
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
condition|)
name|in
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|path
operator|->
name|size
argument_list|()
operator|>=
literal|3
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
condition|)
name|in
operator|+=
literal|3
expr_stmt|;
comment|// otherwise, if the input buffer begins with a prefix of
comment|// "/./" or "/.", where "." is a complete path segment,
comment|// then replace that prefix with "/" in the input buffer;
if|if
condition|(
name|in
operator|<=
name|end
operator|-
literal|3
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
operator|&&
name|in
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
condition|)
block|{
name|in
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|in
operator|==
name|end
operator|-
literal|2
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
operator|&&
name|in
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
condition|)
block|{
operator|*
name|out
operator|++
operator|=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|in
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
comment|// otherwise, if the input buffer begins with a prefix
comment|// of "/../" or "/..", where ".." is a complete path
comment|// segment, then replace that prefix with "/" in the
comment|// input buffer and remove the last //segment and its
comment|// preceding "/" (if any) from the output buffer;
if|if
condition|(
name|in
operator|<=
name|end
operator|-
literal|4
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
operator|&&
name|in
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|3
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
condition|)
block|{
while|while
condition|(
name|out
operator|>
name|path
operator|->
name|constData
argument_list|()
operator|&&
operator|(
operator|--
name|out
operator|)
operator|->
name|unicode
argument_list|()
operator|!=
literal|'/'
condition|)
empty_stmt|;
if|if
condition|(
name|out
operator|==
name|path
operator|->
name|constData
argument_list|()
operator|&&
name|out
operator|->
name|unicode
argument_list|()
operator|!=
literal|'/'
condition|)
operator|++
name|in
expr_stmt|;
name|in
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|in
operator|==
name|end
operator|-
literal|3
operator|&&
name|in
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'/'
operator|&&
name|in
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|2
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|'.'
condition|)
block|{
while|while
condition|(
name|out
operator|>
name|path
operator|->
name|constData
argument_list|()
operator|&&
operator|(
operator|--
name|out
operator|)
operator|->
name|unicode
argument_list|()
operator|!=
literal|'/'
condition|)
empty_stmt|;
if|if
condition|(
name|out
operator|->
name|unicode
argument_list|()
operator|==
literal|'/'
condition|)
operator|++
name|out
expr_stmt|;
name|in
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
comment|// otherwise move the first path segment in
comment|// the input buffer to the end of the output
comment|// buffer, including the initial "/" character
comment|// (if any) and any subsequent characters up
comment|// to, but not including, the next "/"
comment|// character or the end of the input buffer.
operator|*
name|out
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
while|while
condition|(
name|in
operator|<
name|end
operator|&&
name|in
operator|->
name|unicode
argument_list|()
operator|!=
literal|'/'
condition|)
operator|*
name|out
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
block|}
name|path
operator|->
name|truncate
argument_list|(
name|out
operator|-
name|path
operator|->
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|validityError
specifier|inline
name|QUrlPrivate
operator|::
name|ErrorCode
name|QUrlPrivate
operator|::
name|validityError
parameter_list|(
name|QString
modifier|*
name|source
parameter_list|,
name|int
modifier|*
name|position
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|source
operator|==
operator|!
name|position
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|source
condition|)
block|{
operator|*
name|source
operator|=
name|error
operator|->
name|source
expr_stmt|;
operator|*
name|position
operator|=
name|error
operator|->
name|position
expr_stmt|;
block|}
return|return
name|error
operator|->
name|code
return|;
block|}
comment|// There are two more cases of invalid URLs that QUrl recognizes and they
comment|// are only possible with constructed URLs (setXXX methods), not with
comment|// parsing. Therefore, they are tested here.
comment|//
comment|// The two cases are a non-empty path that doesn't start with a slash and:
comment|//  - with an authority
comment|//  - without an authority, without scheme but the path with a colon before
comment|//    the first slash
comment|// Those cases are considered invalid because toString() would produce a URL
comment|// that wouldn't be parsed back to the same QUrl.
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
operator|||
name|path
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
return|return
name|NoError
return|;
if|if
condition|(
name|sectionIsPresent
operator|&
name|QUrlPrivate
operator|::
name|Host
condition|)
block|{
if|if
condition|(
name|source
condition|)
block|{
operator|*
name|source
operator|=
name|path
expr_stmt|;
operator|*
name|position
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|AuthorityPresentAndPathIsRelative
return|;
block|}
if|if
condition|(
name|sectionIsPresent
operator|&
name|QUrlPrivate
operator|::
name|Scheme
condition|)
return|return
name|NoError
return|;
comment|// check for a path of "text:text/"
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|ushort
name|c
init|=
name|path
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
comment|// found the slash before the colon
return|return
name|NoError
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
comment|// found the colon before the slash, it's invalid
if|if
condition|(
name|source
condition|)
block|{
operator|*
name|source
operator|=
name|path
expr_stmt|;
operator|*
name|position
operator|=
name|i
expr_stmt|;
block|}
return|return
name|RelativeUrlPathContainsColonBeforeSlash
return|;
block|}
block|}
return|return
name|NoError
return|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
unit|inline void QUrlPrivate::validate() const {     QUrlPrivate *that = (QUrlPrivate *)this;     that->encodedOriginal = that->toEncoded();
comment|// may detach
end_comment
begin_comment
unit|parse(ParseOnly);      QURL_SETFLAG(that->stateFlags, Validated);      if (!isValid)         return;      QString auth = authority();
comment|// causes the non-encoded forms to be valid
end_comment
begin_comment
comment|// authority() calls canonicalHost() which sets this
end_comment
begin_comment
unit|if (!isHostValid)         return;      if (scheme == QLatin1String("mailto")) {         if (!host.isEmpty() || port != -1 || !userName.isEmpty() || !password.isEmpty()) {             that->isValid = false;             that->errorInfo.setParams(0, QT_TRANSLATE_NOOP(QUrl, "expected empty host, username,"                                                            "port and password"),                                       0, 0);         }     } else if (scheme == ftpScheme() || scheme == httpScheme()) {         if (host.isEmpty()&& !(path.isEmpty()&& encodedPath.isEmpty())) {             that->isValid = false;             that->errorInfo.setParams(0, QT_TRANSLATE_NOOP(QUrl, "the host is empty, but not the path"),                                       0, 0);         }     } }  inline const QByteArray&QUrlPrivate::normalized() const {     if (QURL_HASFLAG(stateFlags, QUrlPrivate::Normalized))         return encodedNormalized;      QUrlPrivate *that = const_cast<QUrlPrivate *>(this);     QURL_SETFLAG(that->stateFlags, QUrlPrivate::Normalized);      QUrlPrivate tmp = *this;     tmp.scheme = tmp.scheme.toLower();     tmp.host = tmp.canonicalHost();
comment|// ensure the encoded and normalized parts of the URL
end_comment
begin_comment
unit|tmp.ensureEncodedParts();     if (tmp.encodedUserName.contains('%'))         q_normalizePercentEncoding(&tmp.encodedUserName, userNameExcludeChars);     if (tmp.encodedPassword.contains('%'))         q_normalizePercentEncoding(&tmp.encodedPassword, passwordExcludeChars);     if (tmp.encodedFragment.contains('%'))         q_normalizePercentEncoding(&tmp.encodedFragment, fragmentExcludeChars);      if (tmp.encodedPath.contains('%')) {
comment|// the path is a bit special:
end_comment
begin_comment
comment|// the slashes shouldn't be encoded or decoded.
end_comment
begin_comment
comment|// They should remain exactly like they are right now
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// treat the path as a slash-separated sequence of pchar
end_comment
begin_comment
unit|QByteArray result;         result.reserve(tmp.encodedPath.length());         if (tmp.encodedPath.startsWith('/'))             result.append('/');          const char *data = tmp.encodedPath.constData();         int lastSlash = 0;         int nextSlash;         do {             ++lastSlash;             nextSlash = tmp.encodedPath.indexOf('/', lastSlash);             int len;             if (nextSlash == -1)                 len = tmp.encodedPath.length() - lastSlash;             else                 len = nextSlash - lastSlash;              if (memchr(data + lastSlash, '%', len)) {
comment|// there's at least one percent before the next slash
end_comment
begin_comment
unit|QByteArray block = QByteArray(data + lastSlash, len);                 q_normalizePercentEncoding(&block, pathExcludeChars);                 result.append(block);             } else {
comment|// no percents in this path segment, append wholesale
end_comment
begin_comment
unit|result.append(data + lastSlash, len);             }
comment|// append the slash too, if it's there
end_comment
begin_comment
unit|if (nextSlash != -1)                 result.append('/');              lastSlash = nextSlash;         } while (lastSlash != -1);          tmp.encodedPath = result;     }      if (!tmp.scheme.isEmpty())
comment|// relative test
end_comment
begin_endif
unit|removeDotsFromPath(&tmp.encodedPath);      int qLen = tmp.query.length();     for (int i = 0; i< qLen; i++) {         if (qLen - i> 2&& tmp.query.at(i) == '%') {             ++i;             tmp.query[i] = qToLower(tmp.query.at(i));             ++i;             tmp.query[i] = qToLower(tmp.query.at(i));         }     }     encodedNormalized = tmp.toEncoded();      return encodedNormalized; }
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \macro QT_NO_URL_CAST_FROM_STRING     \relates QUrl      Disables automatic conversions from QString (or char *) to QUrl.      Compiling your code with this define is useful when you have a lot of     code that uses QString for file names and you wish to convert it to     use QUrl for network transparency. In any code that uses QUrl, it can     help avoid missing QUrl::resolved() calls, and other misuses of     QString to QUrl conversions.      \oldcode         url = filename; // probably not what you want     \newcode         url = QUrl::fromLocalFile(filename);         url = baseurl.resolved(QUrl(filename));     \endcode      \sa QT_NO_CAST_FROM_ASCII */
end_comment
begin_comment
comment|/*!     Constructs a URL by parsing \a url. QUrl will automatically percent encode     all characters that are not allowed in a URL and decode the percent-encoded     sequences that represent a character that is allowed in a URL.      Parses the \a url using the parser mode \a parsingMode. In TolerantMode     (the default), QUrl will correct certain mistakes, notably the presence of     a percent character ('%') not followed by two hexadecimal digits, and it     will accept any character in any position. In StrictMode, encoding mistakes     will not be tolerated and QUrl will also check that certain forbidden     characters are not present in unencoded form. If an error is detected in     StrictMode, isValid() will return false. The parsing mode DecodedMode is not     permitted in this context.      Example:      \snippet code/src_corelib_io_qurl.cpp 0      To construct a URL from an encoded string, you can also use fromEncoded():      \snippet code/src_corelib_io_qurl.cpp 1      Both functions are equivalent and, in Qt 5, both functions accept encoded     data. Usually, the choice of the QUrl constructor or setUrl() versus     fromEncoded() will depend on the source data: the constructor and setUrl()     take a QString, whereas fromEncoded takes a QByteArray.      \sa setUrl(), fromEncoded(), TolerantMode */
end_comment
begin_constructor
DECL|function|QUrl
name|QUrl
operator|::
name|QUrl
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
name|ParsingMode
name|parsingMode
parameter_list|)
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{
name|setUrl
argument_list|(
name|url
argument_list|,
name|parsingMode
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an empty QUrl object. */
end_comment
begin_constructor
DECL|function|QUrl
name|QUrl
operator|::
name|QUrl
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a other. */
end_comment
begin_constructor
DECL|function|QUrl
name|QUrl
operator|::
name|QUrl
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Destructor; called immediately before the object is deleted. */
end_comment
begin_destructor
DECL|function|~QUrl
name|QUrl
operator|::
name|~
name|QUrl
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns true if the URL is non-empty and valid; otherwise returns false.      The URL is run through a conformance test. Every part of the URL     must conform to the standard encoding rules of the URI standard     for the URL to be reported as valid.      \snippet code/src_corelib_io_qurl.cpp 2 */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QUrl
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
comment|// also catches d == 0
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|validityError
argument_list|()
operator|==
name|QUrlPrivate
operator|::
name|NoError
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the URL has no data; otherwise returns false.      \sa clear() */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QUrl
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|true
return|;
return|return
name|d
operator|->
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Resets the content of the QUrl. After calling this function, the     QUrl is equal to one that has been constructed with the default     empty constructor.      \sa isEmpty() */
end_comment
begin_function
DECL|function|clear
name|void
name|QUrl
operator|::
name|clear
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Parses \a url and sets this object to that value. QUrl will automatically     percent encode all characters that are not allowed in a URL and decode the     percent-encoded sequences that represent a character that is allowed in a     URL.      Parses the \a url using the parser mode \a parsingMode. In TolerantMode     (the default), QUrl will correct certain mistakes, notably the presence of     a percent character ('%') not followed by two hexadecimal digits, and it     will accept any character in any position. In StrictMode, encoding mistakes     will not be tolerated and QUrl will also check that certain forbidden     characters are not present in unencoded form. If an error is detected in     StrictMode, isValid() will return false. The parsing mode DecodedMode is     not permitted in this context and will produce a run-time warning.      \sa url(), toString() */
end_comment
begin_function
DECL|function|setUrl
name|void
name|QUrl
operator|::
name|setUrl
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
name|ParsingMode
name|parsingMode
parameter_list|)
block|{
if|if
condition|(
name|parsingMode
operator|==
name|DecodedMode
condition|)
block|{
name|qWarning
argument_list|(
literal|"QUrl: QUrl::DecodedMode is not permitted when parsing a full URL"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|parse
argument_list|(
name|url
argument_list|,
name|parsingMode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QUrl::setEncodedUrl(const QByteArray&encodedUrl, ParsingMode parsingMode)     \deprecated     Constructs a URL by parsing the contents of \a encodedUrl.      \a encodedUrl is assumed to be a URL string in percent encoded     form, containing only ASCII characters.      The parsing mode \a parsingMode is used for parsing \a encodedUrl.      \obsolete Use setUrl(QString::fromUtf8(encodedUrl), parsingMode)      \sa setUrl() */
end_comment
begin_comment
comment|/*!     Sets the scheme of the URL to \a scheme. As a scheme can only     contain ASCII characters, no conversion or decoding is done on the     input. It must also start with an ASCII letter.      The scheme describes the type (or protocol) of the URL. It's     represented by one or more ASCII characters at the start the URL,     and is followed by a ':'. The following example shows a URL where     the scheme is "ftp":      \image qurl-authority2.png      The scheme can also be empty, in which case the URL is interpreted     as relative.      \sa scheme(), isRelative() */
end_comment
begin_function
DECL|function|setScheme
name|void
name|QUrl
operator|::
name|setScheme
parameter_list|(
specifier|const
name|QString
modifier|&
name|scheme
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearError
argument_list|()
expr_stmt|;
if|if
condition|(
name|scheme
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// schemes are not allowed to be empty
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Scheme
expr_stmt|;
name|d
operator|->
name|scheme
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|setScheme
argument_list|(
name|scheme
argument_list|,
name|scheme
operator|.
name|length
argument_list|()
argument_list|,
comment|/* do set error */
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the scheme of the URL. If an empty string is returned,     this means the scheme is undefined and the URL is then relative.      The scheme can only contain US-ASCII letters or digits, which means it     cannot contain any character that would otherwise require encoding.      \sa setScheme(), isRelative() */
end_comment
begin_function
DECL|function|scheme
name|QString
name|QUrl
operator|::
name|scheme
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|d
operator|->
name|scheme
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the authority of the URL to \a authority.      The authority of a URL is the combination of user info, a host     name and a port. All of these elements are optional; an empty     authority is therefore valid.      The user info and host are separated by a '@', and the host and     port are separated by a ':'. If the user info is empty, the '@'     must be omitted; although a stray ':' is permitted if the port is     empty.      The following example shows a valid authority string:      \image qurl-authority.png      The \a authority data is interpreted according to \a mode: in StrictMode,     any '%' characters must be followed by exactly two hexadecimal characters     and some characters (including space) are not allowed in undecoded form. In     TolerantMode (the default), all characters are accepted in undecoded form     and the tolerant parser will correct stray '%' not followed by two hex     characters. In DecodedMode, '%' stand for themselves and encoded characters     are not possible. Because of that, in DecodedMode, it is not possible to     use the delimiter characters as non-delimiters (e.g., a password containing     a '@').      \sa setUserInfo(), setHost(), setPort() */
end_comment
begin_function
DECL|function|setAuthority
name|void
name|QUrl
operator|::
name|setAuthority
parameter_list|(
specifier|const
name|QString
modifier|&
name|authority
parameter_list|,
name|ParsingMode
name|mode
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearError
argument_list|()
expr_stmt|;
name|QString
name|data
init|=
name|authority
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|DecodedMode
condition|)
block|{
name|parseDecodedComponent
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TolerantMode
expr_stmt|;
block|}
name|d
operator|->
name|setAuthority
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|authority
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// QUrlPrivate::setAuthority cleared almost everything
comment|// but it leaves the Host bit set
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Authority
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the authority of the URL if it is defined; otherwise     an empty string is returned.      The \a options argument controls how to format the authority portion of the     URL. The value of QUrl::FullyDecoded should be avoided, since it may     produce an ambiguous return value (for example, if the username contains a     colon ':' or either the username or password contain an at-sign '@'). In     all other cases, this function returns an unambiguous value, which may     contain those characters still percent-encoded, plus some control     sequences not representable in decoded form in QString.      \sa setAuthority(), userInfo(), userName(), password(), host(), port() */
end_comment
begin_function
DECL|function|authority
name|QString
name|QUrl
operator|::
name|authority
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendAuthority
argument_list|(
name|result
argument_list|,
name|options
argument_list|,
name|QUrlPrivate
operator|::
name|Authority
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the user info of the URL to \a userInfo. The user info is an     optional part of the authority of the URL, as described in     setAuthority().      The user info consists of a user name and optionally a password,     separated by a ':'. If the password is empty, the colon must be     omitted. The following example shows a valid user info string:      \image qurl-authority3.png      The \a userInfo data is interpreted according to \a mode: in StrictMode,     any '%' characters must be followed by exactly two hexadecimal characters     and some characters (including space) are not allowed in undecoded form. In     TolerantMode (the default), all characters are accepted in undecoded form     and the tolerant parser will correct stray '%' not followed by two hex     characters. In DecodedMode, '%' stand for themselves and encoded characters     are not possible. Because of that, in DecodedMode, it is not possible to     use the ':' delimiter characters as non-delimiter in the user name.      \sa userInfo(), setUserName(), setPassword(), setAuthority() */
end_comment
begin_function
DECL|function|setUserInfo
name|void
name|QUrl
operator|::
name|setUserInfo
parameter_list|(
specifier|const
name|QString
modifier|&
name|userInfo
parameter_list|,
name|ParsingMode
name|mode
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearError
argument_list|()
expr_stmt|;
name|QString
name|trimmed
init|=
name|userInfo
operator|.
name|trimmed
argument_list|()
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|DecodedMode
condition|)
block|{
name|parseDecodedComponent
argument_list|(
name|trimmed
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TolerantMode
expr_stmt|;
block|}
name|d
operator|->
name|setUserInfo
argument_list|(
name|trimmed
argument_list|,
literal|0
argument_list|,
name|trimmed
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|userInfo
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// QUrlPrivate::setUserInfo cleared almost everything
comment|// but it leaves the UserName bit set
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|UserInfo
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the user info of the URL, or an empty string if the user     info is undefined.      The \a options argument controls how to format the user info component. The     value of QUrl::FullyDecoded should be avoided, since it may produce an     ambiguous return value (for example, if the username contains a colon ':').     In all other cases, this function returns an unambiguous value, which may     contain that characters still percent-encoded, plus some control sequences     not representable in decoded form in QString.      \sa setUserInfo(), userName(), password(), authority() */
end_comment
begin_function
DECL|function|userInfo
name|QString
name|QUrl
operator|::
name|userInfo
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendUserInfo
argument_list|(
name|result
argument_list|,
name|options
argument_list|,
name|QUrlPrivate
operator|::
name|UserInfo
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the URL's user name to \a userName. The \a userName is part     of the user info element in the authority of the URL, as described     in setUserInfo().      The \a userName data is interpreted according to \a mode: in StrictMode,     any '%' characters must be followed by exactly two hexadecimal characters     and some characters (including space) are not allowed in undecoded form. In     TolerantMode (the default), all characters are accepted in undecoded form     and the tolerant parser will correct stray '%' not followed by two hex     characters. In DecodedMode, '%' stand for themselves and encoded characters     are not possible.      QUrl::DecodedMode should be used when setting the user name from a data     source which is not a URL, such as a password dialog shown to the user or     with a user name obtained by calling userName() with the QUrl::FullyDecoded     formatting option.      \sa userName(), setUserInfo() */
end_comment
begin_function
DECL|function|setUserName
name|void
name|QUrl
operator|::
name|setUserName
parameter_list|(
specifier|const
name|QString
modifier|&
name|userName
parameter_list|,
name|ParsingMode
name|mode
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearError
argument_list|()
expr_stmt|;
name|QString
name|data
init|=
name|userName
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|DecodedMode
condition|)
block|{
name|parseDecodedComponent
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TolerantMode
expr_stmt|;
block|}
name|d
operator|->
name|setUserName
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|userName
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|UserName
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the user name of the URL if it is defined; otherwise     an empty string is returned.      The \a options argument controls how to format the user name component. All     values produce an unambiguous result. With QUrl::FullyDecoded, all     percent-encoded sequences are decoded; otherwise, the returned value may     contain some percent-encoded sequences for some control sequences not     representable in decoded form in QString.      Note that QUrl::FullyDecoded may cause data loss if those non-representable     sequences are present. It is recommended to use that value when the result     will be used in a non-URL context, such as setting in QAuthenticator or     negotiating a login.      \sa setUserName(), userInfo() */
end_comment
begin_function
DECL|function|userName
name|QString
name|QUrl
operator|::
name|userName
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendUserName
argument_list|(
name|result
argument_list|,
name|options
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QUrl::setEncodedUserName(const QByteArray&userName)     \deprecated     \since 4.4      Sets the URL's user name to the percent-encoded \a userName. The \a     userName is part of the user info element in the authority of the     URL, as described in setUserInfo().      \obsolete Use setUserName(QString::fromUtf8(userName))      \sa setUserName(), encodedUserName(), setUserInfo() */
end_comment
begin_comment
comment|/*!     \fn QByteArray QUrl::encodedUserName() const     \deprecated     \since 4.4      Returns the user name of the URL if it is defined; otherwise     an empty string is returned. The returned value will have its     non-ASCII and other control characters percent-encoded, as in     toEncoded().      \obsolete Use userName(QUrl::FullyEncoded).toLatin1()      \sa setEncodedUserName() */
end_comment
begin_comment
comment|/*!     Sets the URL's password to \a password. The \a password is part of     the user info element in the authority of the URL, as described in     setUserInfo().      The \a password data is interpreted according to \a mode: in StrictMode,     any '%' characters must be followed by exactly two hexadecimal characters     and some characters (including space) are not allowed in undecoded form. In     TolerantMode, all characters are accepted in undecoded form and the     tolerant parser will correct stray '%' not followed by two hex characters.     In DecodedMode, '%' stand for themselves and encoded characters are not     possible.      QUrl::DecodedMode should be used when setting the password from a data     source which is not a URL, such as a password dialog shown to the user or     with a password obtained by calling password() with the QUrl::FullyDecoded     formatting option.      \sa password(), setUserInfo() */
end_comment
begin_function
DECL|function|setPassword
name|void
name|QUrl
operator|::
name|setPassword
parameter_list|(
specifier|const
name|QString
modifier|&
name|password
parameter_list|,
name|ParsingMode
name|mode
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearError
argument_list|()
expr_stmt|;
name|QString
name|data
init|=
name|password
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|DecodedMode
condition|)
block|{
name|parseDecodedComponent
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TolerantMode
expr_stmt|;
block|}
name|d
operator|->
name|setPassword
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|password
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Password
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the password of the URL if it is defined; otherwise     an empty string is returned.      The \a options argument controls how to format the user name component. All     values produce an unambiguous result. With QUrl::FullyDecoded, all     percent-encoded sequences are decoded; otherwise, the returned value may     contain some percent-encoded sequences for some control sequences not     representable in decoded form in QString.      Note that QUrl::FullyDecoded may cause data loss if those non-representable     sequences are present. It is recommended to use that value when the result     will be used in a non-URL context, such as setting in QAuthenticator or     negotiating a login.      \sa setPassword() */
end_comment
begin_function
DECL|function|password
name|QString
name|QUrl
operator|::
name|password
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendPassword
argument_list|(
name|result
argument_list|,
name|options
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QUrl::setEncodedPassword(const QByteArray&password)     \deprecated     \since 4.4      Sets the URL's password to the percent-encoded \a password. The \a     password is part of the user info element in the authority of the     URL, as described in setUserInfo().      \obsolete Use setPassword(QString::fromUtf8(password));      \sa setPassword(), encodedPassword(), setUserInfo() */
end_comment
begin_comment
comment|/*!     \fn QByteArray QUrl::encodedPassword() const     \deprecated     \since 4.4      Returns the password of the URL if it is defined; otherwise an     empty string is returned. The returned value will have its     non-ASCII and other control characters percent-encoded, as in     toEncoded().      \obsolete Use password(QUrl::FullyEncoded).toLatin1()      \sa setEncodedPassword(), toEncoded() */
end_comment
begin_comment
comment|/*!     Sets the host of the URL to \a host. The host is part of the     authority.      The \a host data is interpreted according to \a mode: in StrictMode,     any '%' characters must be followed by exactly two hexadecimal characters     and some characters (including space) are not allowed in undecoded form. In     TolerantMode, all characters are accepted in undecoded form and the     tolerant parser will correct stray '%' not followed by two hex characters.     In DecodedMode, '%' stand for themselves and encoded characters are not     possible.      Note that, in all cases, the result of the parsing must be a valid hostname     according to STD 3 rules, as modified by the Internationalized Resource     Identifiers specification (RFC 3987). Invalid hostnames are not permitted     and will cause isValid() to become false.      \sa host(), setAuthority() */
end_comment
begin_function
DECL|function|setHost
name|void
name|QUrl
operator|::
name|setHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|host
parameter_list|,
name|ParsingMode
name|mode
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearError
argument_list|()
expr_stmt|;
name|QString
name|data
init|=
name|host
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|DecodedMode
condition|)
block|{
name|parseDecodedComponent
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TolerantMode
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|setHost
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|host
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Host
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|data
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
argument_list|)
condition|)
block|{
comment|// setHost failed, it might be IPv6 or IPvFuture in need of bracketing
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|error
argument_list|)
expr_stmt|;
name|data
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|setHost
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|,
name|mode
argument_list|)
condition|)
block|{
comment|// failed again
if|if
condition|(
name|data
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
block|{
comment|// source data contains ':', so it's an IPv6 error
name|d
operator|->
name|error
operator|->
name|code
operator|=
name|QUrlPrivate
operator|::
name|InvalidIPv6AddressError
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// succeeded
name|d
operator|->
name|clearError
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the host of the URL if it is defined; otherwise     an empty string is returned.      The \a options argument controls how the hostname will be formatted. The     QUrl::EncodeUnicode option will cause this function to return the hostname     in the ASCII-Compatible Encoding (ACE) form, which is suitable for use in     channels that are not 8-bit clean or that require the legacy hostname (such     as DNS requests or in HTTP request headers). If that flag is not present,     this function returns the International Domain Name (IDN) in Unicode form,     according to the list of permissible top-level domains (see     idnWhiteList()).      All other flags are ignored. Host names cannot contain control or percent     characters, so the returned value can be considered fully decoded.      \sa setHost(), idnWhitelist(), setIdnWhitelist(), authority() */
end_comment
begin_function
DECL|function|host
name|QString
name|QUrl
operator|::
name|host
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendHost
argument_list|(
name|result
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
argument_list|)
condition|)
return|return
name|result
operator|.
name|mid
argument_list|(
literal|1
argument_list|,
name|result
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
return|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QUrl::setEncodedHost(const QByteArray&host)     \deprecated     \since 4.4      Sets the URL's host to the ACE- or percent-encoded \a host. The \a     host is part of the user info element in the authority of the     URL, as described in setAuthority().      \obsolete Use setHost(QString::fromUtf8(host)).      \sa setHost(), encodedHost(), setAuthority(), fromAce() */
end_comment
begin_comment
comment|/*!     \fn QByteArray QUrl::encodedHost() const     \deprecated     \since 4.4      Returns the host part of the URL if it is defined; otherwise     an empty string is returned.      Note: encodedHost() does not return percent-encoded hostnames. Instead,     the ACE-encoded (bare ASCII in Punycode encoding) form will be     returned for any non-ASCII hostname.      This function is equivalent to calling QUrl::toAce() on the return     value of host().      \obsolete Use host(QUrl::FullyEncoded).toLatin1() or toAce(host()).      \sa setEncodedHost() */
end_comment
begin_comment
comment|/*!     Sets the port of the URL to \a port. The port is part of the     authority of the URL, as described in setAuthority().      \a port must be between 0 and 65535 inclusive. Setting the     port to -1 indicates that the port is unspecified. */
end_comment
begin_function
DECL|function|setPort
name|void
name|QUrl
operator|::
name|setPort
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearError
argument_list|()
expr_stmt|;
if|if
condition|(
name|port
argument_list|<
operator|-
literal|1
operator|||
name|port
argument_list|>
literal|65535
condition|)
block|{
name|port
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QUrlPrivate
operator|::
name|InvalidPortError
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|port
operator|=
name|port
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the port of the URL, or \a defaultPort if the port is     unspecified.      Example:      \snippet code/src_corelib_io_qurl.cpp 3 */
end_comment
begin_function
DECL|function|port
name|int
name|QUrl
operator|::
name|port
parameter_list|(
name|int
name|defaultPort
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|defaultPort
return|;
return|return
name|d
operator|->
name|port
operator|==
operator|-
literal|1
condition|?
name|defaultPort
else|:
name|d
operator|->
name|port
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the path of the URL to \a path. The path is the part of the     URL that comes after the authority but before the query string.      \image qurl-ftppath.png      For non-hierarchical schemes, the path will be everything     following the scheme declaration, as in the following example:      \image qurl-mailtopath.png      The \a path data is interpreted according to \a mode: in StrictMode,     any '%' characters must be followed by exactly two hexadecimal characters     and some characters (including space) are not allowed in undecoded form. In     TolerantMode (the default), all characters are accepted in undecoded form and the     tolerant parser will correct stray '%' not followed by two hex characters.     In DecodedMode, '%' stand for themselves and encoded characters are not     possible.      QUrl::DecodedMode should be used when setting the path from a data source     which is not a URL, such as a dialog shown to the user or with a path     obtained by calling path() with the QUrl::FullyDecoded formatting option.      \sa path() */
end_comment
begin_function
DECL|function|setPath
name|void
name|QUrl
operator|::
name|setPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|ParsingMode
name|mode
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearError
argument_list|()
expr_stmt|;
name|QString
name|data
init|=
name|path
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|DecodedMode
condition|)
block|{
name|parseDecodedComponent
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TolerantMode
expr_stmt|;
block|}
name|d
operator|->
name|setPath
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// optimized out, since there is no path delimiter
comment|//    if (path.isNull())
comment|//        d->sectionIsPresent&= ~QUrlPrivate::Path;
block|}
end_function
begin_comment
comment|/*!     Returns the path of the URL.      The \a options argument controls how to format the path component. All     values produce an unambiguous result. With QUrl::FullyDecoded, all     percent-encoded sequences are decoded; otherwise, the returned value may     contain some percent-encoded sequences for some control sequences not     representable in decoded form in QString.      Note that QUrl::FullyDecoded may cause data loss if those non-representable     sequences are present. It is recommended to use that value when the result     will be used in a non-URL context, such as sending to an FTP server.      \sa setPath() */
end_comment
begin_function
DECL|function|path
name|QString
name|QUrl
operator|::
name|path
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendPath
argument_list|(
name|result
argument_list|,
name|options
argument_list|,
name|QUrlPrivate
operator|::
name|Path
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QUrl::setEncodedPath(const QByteArray&path)     \deprecated     \since 4.4      Sets the URL's path to the percent-encoded \a path.  The path is     the part of the URL that comes after the authority but before the     query string.      \image qurl-ftppath.png      For non-hierarchical schemes, the path will be everything     following the scheme declaration, as in the following example:      \image qurl-mailtopath.png      \obsolete Use setPath(QString::fromUtf8(path)).      \sa setPath(), encodedPath(), setUserInfo() */
end_comment
begin_comment
comment|/*!     \fn QByteArray QUrl::encodedPath() const     \deprecated     \since 4.4      Returns the path of the URL if it is defined; otherwise an     empty string is returned. The returned value will have its     non-ASCII and other control characters percent-encoded, as in     toEncoded().      \obsolete Use path(QUrl::FullyEncoded).toLatin1().      \sa setEncodedPath(), toEncoded() */
end_comment
begin_comment
comment|/*!     \since 4.2      Returns true if this URL contains a Query (i.e., if ? was seen on it).      \sa setQuery(), query(), hasFragment() */
end_comment
begin_function
DECL|function|hasQuery
name|bool
name|QUrl
operator|::
name|hasQuery
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|hasQuery
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the query string of the URL to \a query.      This function is useful if you need to pass a query string that     does not fit into the key-value pattern, or that uses a different     scheme for encoding special characters than what is suggested by     QUrl.      Passing a value of QString() to \a query (a null QString) unsets     the query completely. However, passing a value of QString("")     will set the query to an empty value, as if the original URL     had a lone "?".      The \a query data is interpreted according to \a mode: in StrictMode,     any '%' characters must be followed by exactly two hexadecimal characters     and some characters (including space) are not allowed in undecoded form. In     TolerantMode, all characters are accepted in undecoded form and the     tolerant parser will correct stray '%' not followed by two hex characters.     In DecodedMode, '%' stand for themselves and encoded characters are not     possible.      Query strings often contain percent-encoded sequences, so use of     DecodedMode is discouraged. One special sequence to be aware of is that of     the plus character ('+'). QUrl does not convert spaces to plus characters,     even though HTML forms posted by web browsers do. In order to represent an     actual plus character in a query, the sequence "%2B" is usually used. This     function will leave "%2B" sequences untouched in TolerantMode or     StrictMode.      \sa query(), hasQuery() */
end_comment
begin_function
DECL|function|setQuery
name|void
name|QUrl
operator|::
name|setQuery
parameter_list|(
specifier|const
name|QString
modifier|&
name|query
parameter_list|,
name|ParsingMode
name|mode
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearError
argument_list|()
expr_stmt|;
name|QString
name|data
init|=
name|query
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|DecodedMode
condition|)
block|{
name|parseDecodedComponent
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TolerantMode
expr_stmt|;
block|}
name|d
operator|->
name|setQuery
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Query
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QUrl::setEncodedQuery(const QByteArray&query)     \deprecated      Sets the query string of the URL to \a query. The string is     inserted as-is, and no further encoding is performed when calling     toEncoded().      This function is useful if you need to pass a query string that     does not fit into the key-value pattern, or that uses a different     scheme for encoding special characters than what is suggested by     QUrl.      Passing a value of QByteArray() to \a query (a null QByteArray) unsets     the query completely. However, passing a value of QByteArray("")     will set the query to an empty value, as if the original URL     had a lone "?".      \obsolete Use setQuery, which has the same null / empty behavior.      \sa encodedQuery(), hasQuery() */
end_comment
begin_comment
comment|/*!     \overload     \since 5.0     Sets the query string of the URL to \a query.      This function reconstructs the query string from the QUrlQuery object and     sets on this QUrl object. This function does not have parsing parameters     because the QUrlQuery contains data that is already parsed.      \sa query(), hasQuery() */
end_comment
begin_function
DECL|function|setQuery
name|void
name|QUrl
operator|::
name|setQuery
parameter_list|(
specifier|const
name|QUrlQuery
modifier|&
name|query
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearError
argument_list|()
expr_stmt|;
comment|// we know the data is in the right format
name|d
operator|->
name|query
operator|=
name|query
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Query
expr_stmt|;
else|else
name|d
operator|->
name|sectionIsPresent
operator||=
name|QUrlPrivate
operator|::
name|Query
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QUrl::setQueryItems(const QList<QPair<QString, QString>>&query)     \deprecated      Sets the query string of the URL to an encoded version of \a     query. The contents of \a query are converted to a string     internally, each pair delimited by the character returned by     pairDelimiter(), and the key and value are delimited by     valueDelimiter().      \note This method does not encode spaces (ASCII 0x20) as plus (+) signs,     like HTML forms do. If you need that kind of encoding, you must encode     the value yourself and use QUrl::setEncodedQueryItems.      \obsolete Use QUrlQuery and setQuery().      \sa queryItems(), setEncodedQueryItems() */
end_comment
begin_comment
comment|/*!     \fn void QUrl::setEncodedQueryItems(const QList<QPair<QByteArray, QByteArray>>&query)     \deprecated     \since 4.4      Sets the query string of the URL to the encoded version of \a     query. The contents of \a query are converted to a string     internally, each pair delimited by the character returned by     pairDelimiter(), and the key and value are delimited by     valueDelimiter().      \obsolete Use QUrlQuery and setQuery().      \sa encodedQueryItems(), setQueryItems() */
end_comment
begin_comment
comment|/*!     \fn void QUrl::addQueryItem(const QString&key, const QString&value)     \deprecated      Inserts the pair \a key = \a value into the query string of the     URL.      The key/value pair is encoded before it is added to the query. The     pair is converted into separate strings internally. The \a key and     \a value is first encoded into UTF-8 and then delimited by the     character returned by valueDelimiter(). Each key/value pair is     delimited by the character returned by pairDelimiter().      \note This method does not encode spaces (ASCII 0x20) as plus (+) signs,     like HTML forms do. If you need that kind of encoding, you must encode     the value yourself and use QUrl::addEncodedQueryItem.      \obsolete Use QUrlQuery and setQuery().      \sa addEncodedQueryItem() */
end_comment
begin_comment
comment|/*!     \fn void QUrl::addEncodedQueryItem(const QByteArray&key, const QByteArray&value)     \deprecated     \since 4.4      Inserts the pair \a key = \a value into the query string of the     URL.      \obsolete Use QUrlQuery and setQuery().      \sa addQueryItem() */
end_comment
begin_comment
comment|/*!     \fn QList<QPair<QString, QString>> QUrl::queryItems() const     \deprecated      Returns the query string of the URL, as a map of keys and values.      \note This method does not decode spaces plus (+) signs as spaces (ASCII     0x20), like HTML forms do. If you need that kind of decoding, you must     use QUrl::encodedQueryItems and decode the data yourself.      \obsolete Use QUrlQuery.      \sa setQueryItems(), setEncodedQuery() */
end_comment
begin_comment
comment|/*!     \fn QList<QPair<QByteArray, QByteArray>> QUrl::encodedQueryItems() const     \deprecated     \since 4.4      Returns the query string of the URL, as a map of encoded keys and values.      \obsolete Use QUrlQuery.      \sa setEncodedQueryItems(), setQueryItems(), setEncodedQuery() */
end_comment
begin_comment
comment|/*!     \fn bool QUrl::hasQueryItem(const QString&key) const     \deprecated      Returns true if there is a query string pair whose key is equal     to \a key from the URL.      \obsolete Use QUrlQuery.      \sa hasEncodedQueryItem() */
end_comment
begin_comment
comment|/*!     \fn bool QUrl::hasEncodedQueryItem(const QByteArray&key) const     \deprecated     \since 4.4      Returns true if there is a query string pair whose key is equal     to \a key from the URL.      \obsolete Use QUrlQuery.      \sa hasQueryItem() */
end_comment
begin_comment
comment|/*!     \fn QString QUrl::queryItemValue(const QString&key) const     \deprecated      Returns the first query string value whose key is equal to \a key     from the URL.      \note This method does not decode spaces plus (+) signs as spaces (ASCII     0x20), like HTML forms do. If you need that kind of decoding, you must     use QUrl::encodedQueryItemValue and decode the data yourself.      \obsolete Use QUrlQuery.      \sa allQueryItemValues() */
end_comment
begin_comment
comment|/*!     \fn QByteArray QUrl::encodedQueryItemValue(const QByteArray&key) const     \deprecated     \since 4.4      Returns the first query string value whose key is equal to \a key     from the URL.      \obsolete Use QUrlQuery.      \sa queryItemValue(), allQueryItemValues() */
end_comment
begin_comment
comment|/*!     \fn QStringList QUrl::allQueryItemValues(const QString&key) const     \deprecated      Returns the a list of query string values whose key is equal to     \a key from the URL.      \note This method does not decode spaces plus (+) signs as spaces (ASCII     0x20), like HTML forms do. If you need that kind of decoding, you must     use QUrl::allEncodedQueryItemValues and decode the data yourself.      \obsolete Use QUrlQuery.      \sa queryItemValue() */
end_comment
begin_comment
comment|/*!     \fn QList<QByteArray> QUrl::allEncodedQueryItemValues(const QByteArray&key) const     \deprecated     \since 4.4      Returns the a list of query string values whose key is equal to     \a key from the URL.      \obsolete Use QUrlQuery.      \sa allQueryItemValues(), queryItemValue(), encodedQueryItemValue() */
end_comment
begin_comment
comment|/*!     \fn void QUrl::removeQueryItem(const QString&key)     \deprecated      Removes the first query string pair whose key is equal to \a key     from the URL.      \obsolete Use QUrlQuery.      \sa removeAllQueryItems() */
end_comment
begin_comment
comment|/*!     \fn void QUrl::removeEncodedQueryItem(const QByteArray&key)     \deprecated     \since 4.4      Removes the first query string pair whose key is equal to \a key     from the URL.      \obsolete Use QUrlQuery.      \sa removeQueryItem(), removeAllQueryItems() */
end_comment
begin_comment
comment|/*!     \fn void QUrl::removeAllQueryItems(const QString&key)     \deprecated      Removes all the query string pairs whose key is equal to \a key     from the URL.      \obsolete Use QUrlQuery.     \sa removeQueryItem() */
end_comment
begin_comment
comment|/*!     \fn void QUrl::removeAllEncodedQueryItems(const QByteArray&key)     \deprecated     \since 4.4      Removes all the query string pairs whose key is equal to \a key     from the URL.      \obsolete Use QUrlQuery.     \sa removeQueryItem() */
end_comment
begin_comment
comment|/*!     \fn QByteArray QUrl::encodedQuery() const     \deprecated      Returns the query string of the URL in percent encoded form.      \obsolete Use query(QUrl::FullyEncoded).toLatin1()      \sa setEncodedQuery(), query() */
end_comment
begin_comment
comment|/*!     Returns the query string of the URL if there's a query string, or an empty     result if not. To determine if the parsed URL contained a query string, use     hasQuery().      The \a options argument controls how to format the query component. All     values produce an unambiguous result. With QUrl::FullyDecoded, all     percent-encoded sequences are decoded; otherwise, the returned value may     contain some percent-encoded sequences for some control sequences not     representable in decoded form in QString.      Note that use of QUrl::FullyDecoded in queries is discouraged, as queries     often contain data that is supposed to remain percent-encoded, including     the use of the "%2B" sequence to represent a plus character ('+').      \sa setQuery(), hasQuery() */
end_comment
begin_function
DECL|function|query
name|QString
name|QUrl
operator|::
name|query
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendQuery
argument_list|(
name|result
argument_list|,
name|options
argument_list|,
name|QUrlPrivate
operator|::
name|Query
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasQuery
argument_list|()
operator|&&
name|result
operator|.
name|isNull
argument_list|()
condition|)
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the fragment of the URL to \a fragment. The fragment is the     last part of the URL, represented by a '#' followed by a string of     characters. It is typically used in HTTP for referring to a     certain link or point on a page:      \image qurl-fragment.png      The fragment is sometimes also referred to as the URL "reference".      Passing an argument of QString() (a null QString) will unset the fragment.     Passing an argument of QString("") (an empty but not null QString)     will set the fragment to an empty string (as if the original URL     had a lone "#").      The \a fragment data is interpreted according to \a mode: in StrictMode,     any '%' characters must be followed by exactly two hexadecimal characters     and some characters (including space) are not allowed in undecoded form. In     TolerantMode, all characters are accepted in undecoded form and the     tolerant parser will correct stray '%' not followed by two hex characters.     In DecodedMode, '%' stand for themselves and encoded characters are not     possible.      QUrl::DecodedMode should be used when setting the fragment from a data     source which is not a URL or with a fragment obtained by calling     fragment() with the QUrl::FullyDecoded formatting option.      \sa fragment(), hasFragment() */
end_comment
begin_function
DECL|function|setFragment
name|void
name|QUrl
operator|::
name|setFragment
parameter_list|(
specifier|const
name|QString
modifier|&
name|fragment
parameter_list|,
name|ParsingMode
name|mode
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|clearError
argument_list|()
expr_stmt|;
name|QString
name|data
init|=
name|fragment
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|DecodedMode
condition|)
block|{
name|parseDecodedComponent
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TolerantMode
expr_stmt|;
block|}
name|d
operator|->
name|setFragment
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragment
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Fragment
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the fragment of the URL. To determine if the parsed URL contained a     fragment, use hasFragment().      The \a options argument controls how to format the fragment component. All     values produce an unambiguous result. With QUrl::FullyDecoded, all     percent-encoded sequences are decoded; otherwise, the returned value may     contain some percent-encoded sequences for some control sequences not     representable in decoded form in QString.      Note that QUrl::FullyDecoded may cause data loss if those non-representable     sequences are present. It is recommended to use that value when the result     will be used in a non-URL context.      \sa setFragment(), hasFragment() */
end_comment
begin_function
DECL|function|fragment
name|QString
name|QUrl
operator|::
name|fragment
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|d
operator|->
name|appendFragment
argument_list|(
name|result
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasFragment
argument_list|()
operator|&&
name|result
operator|.
name|isNull
argument_list|()
condition|)
name|result
operator|.
name|detach
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QUrl::setEncodedFragment(const QByteArray&fragment)     \deprecated     \since 4.4      Sets the URL's fragment to the percent-encoded \a fragment. The fragment is the     last part of the URL, represented by a '#' followed by a string of     characters. It is typically used in HTTP for referring to a     certain link or point on a page:      \image qurl-fragment.png      The fragment is sometimes also referred to as the URL "reference".      Passing an argument of QByteArray() (a null QByteArray) will unset     the fragment.  Passing an argument of QByteArray("") (an empty but     not null QByteArray) will set the fragment to an empty string (as     if the original URL had a lone "#").      \obsolete Use setFragment(), which has the same behavior of null / empty.      \sa setFragment(), encodedFragment() */
end_comment
begin_comment
comment|/*!     \fn QByteArray QUrl::encodedFragment() const     \deprecated     \since 4.4      Returns the fragment of the URL if it is defined; otherwise an     empty string is returned. The returned value will have its     non-ASCII and other control characters percent-encoded, as in     toEncoded().      \obsolete Use query(QUrl::FullyEncoded).toLatin1().      \sa setEncodedFragment(), toEncoded() */
end_comment
begin_comment
comment|/*!     \since 4.2      Returns true if this URL contains a fragment (i.e., if # was seen on it).      \sa fragment(), setFragment() */
end_comment
begin_function
DECL|function|hasFragment
name|bool
name|QUrl
operator|::
name|hasFragment
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|hasFragment
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns the TLD (Top-Level Domain) of the URL, (e.g. .co.uk, .net).     Note that the return value is prefixed with a '.' unless the     URL does not contain a valid TLD, in which case the function returns     an empty string.      If \a options includes EncodeUnicode, the returned string will be in     ASCII Compatible Encoding. */
end_comment
begin_function
DECL|function|topLevelDomain
name|QString
name|QUrl
operator|::
name|topLevelDomain
parameter_list|(
name|ComponentFormattingOptions
name|options
parameter_list|)
specifier|const
block|{
name|QString
name|tld
init|=
name|qTopLevelDomain
argument_list|(
name|host
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|options
operator|&
name|EncodeUnicode
condition|)
block|{
return|return
name|qt_ACE_do
argument_list|(
name|tld
argument_list|,
name|ToAceOnly
argument_list|)
return|;
block|}
return|return
name|tld
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the result of the merge of this URL with \a relative. This     URL is used as a base to convert \a relative to an absolute URL.      If \a relative is not a relative URL, this function will return \a     relative directly. Otherwise, the paths of the two URLs are     merged, and the new URL returned has the scheme and authority of     the base URL, but with the merged path, as in the following     example:      \snippet code/src_corelib_io_qurl.cpp 5      Calling resolved() with ".." returns a QUrl whose directory is     one level higher than the original. Similarly, calling resolved()     with "../.." removes two levels from the path. If \a relative is     "/", the path becomes "/".      \sa isRelative() */
end_comment
begin_function
DECL|function|resolved
name|QUrl
name|QUrl
operator|::
name|resolved
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|relative
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|relative
return|;
if|if
condition|(
operator|!
name|relative
operator|.
name|d
condition|)
return|return
operator|*
name|this
return|;
name|QUrl
name|t
decl_stmt|;
comment|// be non strict and allow scheme in relative url
if|if
condition|(
operator|!
name|relative
operator|.
name|d
operator|->
name|scheme
operator|.
name|isEmpty
argument_list|()
operator|&&
name|relative
operator|.
name|d
operator|->
name|scheme
operator|!=
name|d
operator|->
name|scheme
condition|)
block|{
name|t
operator|=
name|relative
expr_stmt|;
name|t
operator|.
name|detach
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|relative
operator|.
name|d
operator|->
name|hasAuthority
argument_list|()
condition|)
block|{
name|t
operator|=
name|relative
expr_stmt|;
name|t
operator|.
name|detach
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|t
operator|.
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
comment|// copy the authority
name|t
operator|.
name|d
operator|->
name|userName
operator|=
name|d
operator|->
name|userName
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|password
operator|=
name|d
operator|->
name|password
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|host
operator|=
name|d
operator|->
name|host
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|port
operator|=
name|d
operator|->
name|port
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator|=
name|d
operator|->
name|sectionIsPresent
operator|&
name|QUrlPrivate
operator|::
name|Authority
expr_stmt|;
if|if
condition|(
name|relative
operator|.
name|d
operator|->
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|t
operator|.
name|d
operator|->
name|path
operator|=
name|d
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|relative
operator|.
name|d
operator|->
name|hasQuery
argument_list|()
condition|)
block|{
name|t
operator|.
name|d
operator|->
name|query
operator|=
name|relative
operator|.
name|d
operator|->
name|query
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator||=
name|QUrlPrivate
operator|::
name|Query
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|hasQuery
argument_list|()
condition|)
block|{
name|t
operator|.
name|d
operator|->
name|query
operator|=
name|d
operator|->
name|query
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator||=
name|QUrlPrivate
operator|::
name|Query
expr_stmt|;
block|}
block|}
else|else
block|{
name|t
operator|.
name|d
operator|->
name|path
operator|=
name|relative
operator|.
name|d
operator|->
name|path
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|?
name|relative
operator|.
name|d
operator|->
name|path
else|:
name|d
operator|->
name|mergePaths
argument_list|(
name|relative
operator|.
name|d
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|relative
operator|.
name|d
operator|->
name|hasQuery
argument_list|()
condition|)
block|{
name|t
operator|.
name|d
operator|->
name|query
operator|=
name|relative
operator|.
name|d
operator|->
name|query
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator||=
name|QUrlPrivate
operator|::
name|Query
expr_stmt|;
block|}
block|}
block|}
name|t
operator|.
name|d
operator|->
name|scheme
operator|=
name|d
operator|->
name|scheme
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasScheme
argument_list|()
condition|)
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator||=
name|QUrlPrivate
operator|::
name|Scheme
expr_stmt|;
else|else
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Scheme
expr_stmt|;
block|}
name|t
operator|.
name|d
operator|->
name|fragment
operator|=
name|relative
operator|.
name|d
operator|->
name|fragment
expr_stmt|;
if|if
condition|(
name|relative
operator|.
name|d
operator|->
name|hasFragment
argument_list|()
condition|)
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator||=
name|QUrlPrivate
operator|::
name|Fragment
expr_stmt|;
else|else
name|t
operator|.
name|d
operator|->
name|sectionIsPresent
operator|&=
operator|~
name|QUrlPrivate
operator|::
name|Fragment
expr_stmt|;
name|removeDotsFromPath
argument_list|(
operator|&
name|t
operator|.
name|d
operator|->
name|path
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QURL_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QUrl(\"%s\").resolved(\"%s\") = \"%s\""
argument_list|,
name|qPrintable
argument_list|(
name|url
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|relative
operator|.
name|url
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|t
operator|.
name|url
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the URL is relative; otherwise returns false. A URL is     relative reference if its scheme is undefined; this function is therefore     equivalent to calling scheme().isEmpty().      Relative references are defined in RFC 3986 section 4.2. */
end_comment
begin_function
DECL|function|isRelative
name|bool
name|QUrl
operator|::
name|isRelative
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|true
return|;
return|return
operator|!
name|d
operator|->
name|hasScheme
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a string representation of the URL. The output can be customized by     passing flags with \a options. The option QUrl::FullyDecoded is not     permitted in this function since it would generate ambiguous data.      The resulting QString can be passed back to a QUrl later on.      Synonym for toString(options).      \sa FormattingOptions, toEncoded(), toString() */
end_comment
begin_function
DECL|function|url
name|QString
name|QUrl
operator|::
name|url
parameter_list|(
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
return|return
name|toString
argument_list|(
name|options
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a string representation of the URL. The output can be customized by     passing flags with \a options. The option QUrl::FullyDecoded is not     permitted in this function since it would generate ambiguous data.      The default formatting option is \l{QUrl::FormattingOptions}{PrettyDecoded}.      \sa FormattingOptions, url(), setUrl() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QUrl
operator|::
name|toString
parameter_list|(
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
block|{
comment|// also catches isEmpty()
return|return
name|QString
argument_list|()
return|;
block|}
if|if
condition|(
name|options
operator|==
name|QUrl
operator|::
name|FullyDecoded
condition|)
block|{
name|qWarning
argument_list|(
literal|"QUrl: QUrl::FullyDecoded is not permitted when reconstructing the full URL"
argument_list|)
expr_stmt|;
name|options
operator|=
name|QUrl
operator|::
name|PrettyDecoded
expr_stmt|;
block|}
comment|// return just the path if:
comment|//  - QUrl::PreferLocalFile is passed
comment|//  - QUrl::RemovePath isn't passed (rather stupid if the user did...)
comment|//  - there's no query or fragment to return
comment|//    that is, either they aren't present, or we're removing them
comment|//  - it's a local file
comment|//    (test done last since it's the most expensive)
if|if
condition|(
name|options
operator|.
name|testFlag
argument_list|(
name|QUrl
operator|::
name|PreferLocalFile
argument_list|)
operator|&&
operator|!
name|options
operator|.
name|testFlag
argument_list|(
name|QUrl
operator|::
name|RemovePath
argument_list|)
operator|&&
operator|(
operator|!
name|d
operator|->
name|hasQuery
argument_list|()
operator|||
name|options
operator|.
name|testFlag
argument_list|(
name|QUrl
operator|::
name|RemoveQuery
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|d
operator|->
name|hasFragment
argument_list|()
operator|||
name|options
operator|.
name|testFlag
argument_list|(
name|QUrl
operator|::
name|RemoveFragment
argument_list|)
operator|)
operator|&&
name|isLocalFile
argument_list|()
condition|)
block|{
return|return
name|path
argument_list|(
name|options
argument_list|)
return|;
block|}
name|QString
name|url
decl_stmt|;
comment|// for the full URL, we consider that the reserved characters are prettier if encoded
if|if
condition|(
name|options
operator|&
name|DecodeReserved
condition|)
name|options
operator|&=
operator|~
name|EncodeReserved
expr_stmt|;
else|else
name|options
operator||=
name|EncodeReserved
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveScheme
operator|)
operator|&&
name|d
operator|->
name|hasScheme
argument_list|()
condition|)
name|url
operator|+=
name|d
operator|->
name|scheme
operator|+
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|bool
name|pathIsAbsolute
init|=
name|d
operator|->
name|path
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveAuthority
operator|)
operator|==
name|QUrl
operator|::
name|RemoveAuthority
operator|)
operator|&&
name|d
operator|->
name|hasAuthority
argument_list|()
condition|)
block|{
name|url
operator|+=
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
expr_stmt|;
name|d
operator|->
name|appendAuthority
argument_list|(
name|url
argument_list|,
name|options
argument_list|,
name|QUrlPrivate
operator|::
name|FullUrl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isLocalFile
argument_list|()
operator|&&
name|pathIsAbsolute
condition|)
block|{
name|url
operator|+=
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemovePath
operator|)
condition|)
block|{
name|d
operator|->
name|appendPath
argument_list|(
name|url
argument_list|,
name|options
argument_list|,
name|QUrlPrivate
operator|::
name|FullUrl
argument_list|)
expr_stmt|;
comment|// check if we need to remove trailing slashes
if|if
condition|(
operator|(
name|options
operator|&
name|StripTrailingSlash
operator|)
operator|&&
operator|!
name|d
operator|->
name|path
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|path
operator|!=
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
operator|&&
name|url
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|url
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveQuery
operator|)
operator|&&
name|d
operator|->
name|hasQuery
argument_list|()
condition|)
block|{
name|url
operator|+=
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
name|d
operator|->
name|appendQuery
argument_list|(
name|url
argument_list|,
name|options
argument_list|,
name|QUrlPrivate
operator|::
name|FullUrl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveFragment
operator|)
operator|&&
name|d
operator|->
name|hasFragment
argument_list|()
condition|)
block|{
name|url
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|d
operator|->
name|appendFragment
argument_list|(
name|url
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
return|return
name|url
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Returns a human-displayable string representation of the URL.     The output can be customized by passing flags with \a options.     The option RemovePassword is always enabled, since passwords     should never be shown back to users.      With the default options, the resulting QString can be passed back     to a QUrl later on, but any password that was present initially will     be lost.      \sa FormattingOptions, toEncoded(), toString() */
end_comment
begin_function
DECL|function|toDisplayString
name|QString
name|QUrl
operator|::
name|toDisplayString
parameter_list|(
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
return|return
name|toString
argument_list|(
name|options
operator||
name|RemovePassword
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the encoded representation of the URL if it's valid;     otherwise an empty QByteArray is returned. The output can be     customized by passing flags with \a options.      The user info, path and fragment are all converted to UTF-8, and     all non-ASCII characters are then percent encoded. The host name     is encoded using Punycode. */
end_comment
begin_function
DECL|function|toEncoded
name|QByteArray
name|QUrl
operator|::
name|toEncoded
parameter_list|(
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
name|options
operator|&=
operator|~
operator|(
name|FullyDecoded
operator||
name|FullyEncoded
operator|)
expr_stmt|;
name|QString
name|stringForm
init|=
name|toString
argument_list|(
name|options
operator||
name|FullyEncoded
argument_list|)
decl_stmt|;
return|return
name|stringForm
operator|.
name|toLatin1
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QUrl QUrl::fromEncoded(const QByteArray&input, ParsingMode parsingMode)      Parses \a input and returns the corresponding QUrl. \a input is     assumed to be in encoded form, containing only ASCII characters.      Parses the URL using \a parsingMode. See setUrl() for more information on     this parameter. QUrl::DecodedMode is not permitted in this context.      \sa toEncoded(), setUrl() */
end_comment
begin_function
DECL|function|fromEncoded
name|QUrl
name|QUrl
operator|::
name|fromEncoded
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|input
parameter_list|,
name|ParsingMode
name|mode
parameter_list|)
block|{
return|return
name|QUrl
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
name|input
operator|.
name|constData
argument_list|()
argument_list|,
name|input
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a decoded copy of \a input. \a input is first decoded from     percent encoding, then converted from UTF-8 to unicode. */
end_comment
begin_function
DECL|function|fromPercentEncoding
name|QString
name|QUrl
operator|::
name|fromPercentEncoding
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|input
parameter_list|)
block|{
name|QByteArray
name|ba
init|=
name|QByteArray
operator|::
name|fromPercentEncoding
argument_list|(
name|input
argument_list|)
decl_stmt|;
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
name|ba
argument_list|,
name|ba
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an encoded copy of \a input. \a input is first converted     to UTF-8, and all ASCII-characters that are not in the unreserved group     are percent encoded. To prevent characters from being percent encoded     pass them to \a exclude. To force characters to be percent encoded pass     them to \a include.      Unreserved is defined as:        ALPHA / DIGIT / "-" / "." / "_" / "~"      \snippet code/src_corelib_io_qurl.cpp 6 */
end_comment
begin_function
DECL|function|toPercentEncoding
name|QByteArray
name|QUrl
operator|::
name|toPercentEncoding
parameter_list|(
specifier|const
name|QString
modifier|&
name|input
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|exclude
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|include
parameter_list|)
block|{
return|return
name|input
operator|.
name|toUtf8
argument_list|()
operator|.
name|toPercentEncoding
argument_list|(
name|exclude
argument_list|,
name|include
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 5.0     Used in the setEncodedXXX compatibility functions. Converts \a ba to     QString form. */
end_comment
begin_function
DECL|function|fromEncodedComponent_helper
name|QString
name|QUrl
operator|::
name|fromEncodedComponent_helper
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
return|return
name|qt_urlRecodeByteArray
argument_list|(
name|ba
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray QUrl::toPunycode(const QString&uc)     \obsolete     Returns a \a uc in Punycode encoding.      Punycode is a Unicode encoding used for internationalized domain     names, as defined in RFC3492. If you want to convert a domain name from     Unicode to its ASCII-compatible representation, use toAce(). */
end_comment
begin_comment
comment|/*!     \fn QString QUrl::fromPunycode(const QByteArray&pc)     \obsolete     Returns the Punycode decoded representation of \a pc.      Punycode is a Unicode encoding used for internationalized domain     names, as defined in RFC3492. If you want to convert a domain from     its ASCII-compatible encoding to the Unicode representation, use     fromAce(). */
end_comment
begin_comment
comment|/*!     \since 4.2      Returns the Unicode form of the given domain name     \a domain, which is encoded in the ASCII Compatible Encoding (ACE).     The result of this function is considered equivalent to \a domain.      If the value in \a domain cannot be encoded, it will be converted     to QString and returned.      The ASCII Compatible Encoding (ACE) is defined by RFC 3490, RFC 3491     and RFC 3492. It is part of the Internationalizing Domain Names in     Applications (IDNA) specification, which allows for domain names     (like \c "example.com") to be written using international     characters. */
end_comment
begin_function
DECL|function|fromAce
name|QString
name|QUrl
operator|::
name|fromAce
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|domain
parameter_list|)
block|{
return|return
name|qt_ACE_do
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|domain
argument_list|)
argument_list|,
name|NormalizeAce
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the ASCII Compatible Encoding of the given domain name \a domain.     The result of this function is considered equivalent to \a domain.      The ASCII-Compatible Encoding (ACE) is defined by RFC 3490, RFC 3491     and RFC 3492. It is part of the Internationalizing Domain Names in     Applications (IDNA) specification, which allows for domain names     (like \c "example.com") to be written using international     characters.      This function return an empty QByteArra if \a domain is not a valid     hostname. Note, in particular, that IPv6 literals are not valid domain     names. */
end_comment
begin_function
DECL|function|toAce
name|QByteArray
name|QUrl
operator|::
name|toAce
parameter_list|(
specifier|const
name|QString
modifier|&
name|domain
parameter_list|)
block|{
name|QString
name|result
init|=
name|qt_ACE_do
argument_list|(
name|domain
argument_list|,
name|ToAceOnly
argument_list|)
decl_stmt|;
return|return
name|result
operator|.
name|toLatin1
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns true if this URL is "less than" the given \a url. This     provides a means of ordering URLs. */
end_comment
begin_function
DECL|function|operator <
name|bool
name|QUrl
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|url
operator|.
name|d
condition|)
block|{
name|bool
name|thisIsEmpty
init|=
operator|!
name|d
operator|||
name|d
operator|->
name|isEmpty
argument_list|()
decl_stmt|;
name|bool
name|thatIsEmpty
init|=
operator|!
name|url
operator|.
name|d
operator|||
name|url
operator|.
name|d
operator|->
name|isEmpty
argument_list|()
decl_stmt|;
comment|// sort an empty URL first
return|return
name|thisIsEmpty
operator|&&
operator|!
name|thatIsEmpty
return|;
block|}
name|int
name|cmp
decl_stmt|;
name|cmp
operator|=
name|d
operator|->
name|scheme
operator|.
name|compare
argument_list|(
name|url
operator|.
name|d
operator|->
name|scheme
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
operator|<
literal|0
return|;
name|cmp
operator|=
name|d
operator|->
name|userName
operator|.
name|compare
argument_list|(
name|url
operator|.
name|d
operator|->
name|userName
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
operator|<
literal|0
return|;
name|cmp
operator|=
name|d
operator|->
name|password
operator|.
name|compare
argument_list|(
name|url
operator|.
name|d
operator|->
name|password
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
operator|<
literal|0
return|;
name|cmp
operator|=
name|d
operator|->
name|host
operator|.
name|compare
argument_list|(
name|url
operator|.
name|d
operator|->
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
operator|<
literal|0
return|;
if|if
condition|(
name|d
operator|->
name|port
operator|!=
name|url
operator|.
name|d
operator|->
name|port
condition|)
return|return
name|d
operator|->
name|port
operator|<
name|url
operator|.
name|d
operator|->
name|port
return|;
name|cmp
operator|=
name|d
operator|->
name|path
operator|.
name|compare
argument_list|(
name|url
operator|.
name|d
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
operator|<
literal|0
return|;
if|if
condition|(
name|d
operator|->
name|hasQuery
argument_list|()
operator|!=
name|url
operator|.
name|d
operator|->
name|hasQuery
argument_list|()
condition|)
return|return
name|url
operator|.
name|d
operator|->
name|hasQuery
argument_list|()
return|;
name|cmp
operator|=
name|d
operator|->
name|query
operator|.
name|compare
argument_list|(
name|url
operator|.
name|d
operator|->
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
operator|<
literal|0
return|;
if|if
condition|(
name|d
operator|->
name|hasFragment
argument_list|()
operator|!=
name|url
operator|.
name|d
operator|->
name|hasFragment
argument_list|()
condition|)
return|return
name|url
operator|.
name|d
operator|->
name|hasFragment
argument_list|()
return|;
name|cmp
operator|=
name|d
operator|->
name|fragment
operator|.
name|compare
argument_list|(
name|url
operator|.
name|d
operator|->
name|fragment
argument_list|)
expr_stmt|;
return|return
name|cmp
operator|<
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this URL and the given \a url are equal;     otherwise returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QUrl
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|&&
operator|!
name|url
operator|.
name|d
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|url
operator|.
name|d
operator|->
name|isEmpty
argument_list|()
return|;
if|if
condition|(
operator|!
name|url
operator|.
name|d
condition|)
return|return
name|d
operator|->
name|isEmpty
argument_list|()
return|;
comment|// Compare which sections are present, but ignore Host
comment|// which is set by parsing but not by construction, when empty.
specifier|const
name|int
name|mask
init|=
name|QUrlPrivate
operator|::
name|FullUrl
operator|&
operator|~
name|QUrlPrivate
operator|::
name|Host
decl_stmt|;
return|return
operator|(
name|d
operator|->
name|sectionIsPresent
operator|&
name|mask
operator|)
operator|==
operator|(
name|url
operator|.
name|d
operator|->
name|sectionIsPresent
operator|&
name|mask
operator|)
operator|&&
name|d
operator|->
name|scheme
operator|==
name|url
operator|.
name|d
operator|->
name|scheme
operator|&&
name|d
operator|->
name|userName
operator|==
name|url
operator|.
name|d
operator|->
name|userName
operator|&&
name|d
operator|->
name|password
operator|==
name|url
operator|.
name|d
operator|->
name|password
operator|&&
name|d
operator|->
name|host
operator|==
name|url
operator|.
name|d
operator|->
name|host
operator|&&
name|d
operator|->
name|port
operator|==
name|url
operator|.
name|d
operator|->
name|port
operator|&&
name|d
operator|->
name|path
operator|==
name|url
operator|.
name|d
operator|->
name|path
operator|&&
name|d
operator|->
name|query
operator|==
name|url
operator|.
name|d
operator|->
name|query
operator|&&
name|d
operator|->
name|fragment
operator|==
name|url
operator|.
name|d
operator|->
name|fragment
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this URL and the given \a url are not equal;     otherwise returns false. */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QUrl
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|url
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Assigns the specified \a url to this object. */
end_comment
begin_function
DECL|function|operator =
name|QUrl
modifier|&
name|QUrl
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
if|if
condition|(
name|url
operator|.
name|d
condition|)
block|{
name|url
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|d
operator|=
name|url
operator|.
name|d
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|url
operator|.
name|d
condition|)
name|qAtomicAssign
argument_list|(
name|d
argument_list|,
name|url
operator|.
name|d
argument_list|)
expr_stmt|;
else|else
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Assigns the specified \a url to this object. */
end_comment
begin_function
DECL|function|operator =
name|QUrl
modifier|&
name|QUrl
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|)
block|{
if|if
condition|(
name|url
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|parse
argument_list|(
name|url
argument_list|,
name|TolerantMode
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QUrl::swap(QUrl&other)     \since 4.8      Swaps URL \a other with this URL. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*!     \internal      Forces a detach. */
end_comment
begin_function
DECL|function|detach
name|void
name|QUrl
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
else|else
name|qAtomicDetach
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|isDetached
name|bool
name|QUrl
operator|::
name|isDetached
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d
operator|||
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QUrl representation of \a localFile, interpreted as a local     file. This function accepts paths separated by slashes as well as the     native separator for this platform.      This function also accepts paths with a doubled leading slash (or     backslash) to indicate a remote file, as in     "//servername/path/to/file.txt". Note that only certain platforms can     actually open this file using QFile::open().      \sa toLocalFile(), isLocalFile(), QDir::toNativeSeparators() */
end_comment
begin_function
DECL|function|fromLocalFile
name|QUrl
name|QUrl
operator|::
name|fromLocalFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|localFile
parameter_list|)
block|{
name|QUrl
name|url
decl_stmt|;
name|url
operator|.
name|setScheme
argument_list|(
name|fileScheme
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|deslashified
init|=
name|QDir
operator|::
name|fromNativeSeparators
argument_list|(
name|localFile
argument_list|)
decl_stmt|;
comment|// magic for drives on windows
if|if
condition|(
name|deslashified
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|deslashified
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|&&
name|deslashified
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
name|deslashified
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|deslashified
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
argument_list|)
condition|)
block|{
comment|// magic for shared drive on windows
name|int
name|indexOfPath
init|=
name|deslashified
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|url
operator|.
name|setHost
argument_list|(
name|deslashified
operator|.
name|mid
argument_list|(
literal|2
argument_list|,
name|indexOfPath
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexOfPath
operator|>
literal|2
condition|)
name|deslashified
operator|=
name|deslashified
operator|.
name|right
argument_list|(
name|deslashified
operator|.
name|length
argument_list|()
operator|-
name|indexOfPath
argument_list|)
expr_stmt|;
else|else
name|deslashified
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|url
operator|.
name|setPath
argument_list|(
name|deslashified
argument_list|,
name|DecodedMode
argument_list|)
expr_stmt|;
return|return
name|url
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the path of this URL formatted as a local file path. The path     returned will use forward slashes, even if it was originally created     from one with backslashes.      If this URL contains a non-empty hostname, it will be encoded in the     returned value in the form found on SMB networks (for example,     "//servername/path/to/file.txt").      Note: if the path component of this URL contains a non-UTF-8 binary     sequence (such as %80), the behaviour of this function is undefined.      \sa fromLocalFile(), isLocalFile() */
end_comment
begin_function
DECL|function|toLocalFile
name|QString
name|QUrl
operator|::
name|toLocalFile
parameter_list|()
specifier|const
block|{
comment|// the call to isLocalFile() also ensures that we're parsed
if|if
condition|(
operator|!
name|isLocalFile
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|tmp
decl_stmt|;
name|QString
name|ourPath
init|=
name|path
argument_list|(
name|QUrl
operator|::
name|FullyDecoded
argument_list|)
decl_stmt|;
comment|// magic for shared drive on windows
if|if
condition|(
operator|!
name|d
operator|->
name|host
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|QStringLiteral
argument_list|(
literal|"//"
argument_list|)
operator|+
name|host
argument_list|()
operator|+
operator|(
name|ourPath
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|ourPath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|?
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|ourPath
else|:
name|ourPath
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|ourPath
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// magic for drives on windows
if|if
condition|(
name|ourPath
operator|.
name|length
argument_list|()
operator|>
literal|2
operator|&&
name|ourPath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|&&
name|ourPath
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
condition|)
name|tmp
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|tmp
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     Returns true if this URL is pointing to a local file path. A URL is a     local file path if the scheme is "file".      Note that this function considers URLs with hostnames to be local file     paths, even if the eventual file path cannot be opened with     QFile::open().      \sa fromLocalFile(), toLocalFile() */
end_comment
begin_function
DECL|function|isLocalFile
name|bool
name|QUrl
operator|::
name|isLocalFile
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|scheme
operator|!=
name|fileScheme
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// not file
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this URL is a parent of \a childUrl. \a childUrl is a child     of this URL if the two URLs share the same scheme and authority,     and this URL's path is a parent of the path of \a childUrl. */
end_comment
begin_function
DECL|function|isParentOf
name|bool
name|QUrl
operator|::
name|isParentOf
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|childUrl
parameter_list|)
specifier|const
block|{
name|QString
name|childPath
init|=
name|childUrl
operator|.
name|path
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
operator|(
operator|(
name|childUrl
operator|.
name|scheme
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
name|childUrl
operator|.
name|authority
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
name|childPath
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|childPath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|)
return|;
name|QString
name|ourPath
init|=
name|path
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|childUrl
operator|.
name|scheme
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|d
operator|->
name|scheme
operator|==
name|childUrl
operator|.
name|scheme
argument_list|()
operator|)
operator|&&
operator|(
name|childUrl
operator|.
name|authority
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|authority
argument_list|()
operator|==
name|childUrl
operator|.
name|authority
argument_list|()
operator|)
operator|&&
name|childPath
operator|.
name|startsWith
argument_list|(
name|ourPath
argument_list|)
operator|&&
operator|(
operator|(
name|ourPath
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|&&
name|childPath
operator|.
name|length
argument_list|()
operator|>
name|ourPath
operator|.
name|length
argument_list|()
operator|)
operator|||
operator|(
operator|!
name|ourPath
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|&&
name|childPath
operator|.
name|length
argument_list|()
operator|>
name|ourPath
operator|.
name|length
argument_list|()
operator|&&
name|childPath
operator|.
name|at
argument_list|(
name|ourPath
operator|.
name|length
argument_list|()
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*! \relates QUrl      Writes url \a url to the stream \a out and returns a reference     to the stream.      \sa{Serializing Qt Data Types}{Format of the QDataStream operators} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|QByteArray
name|u
decl_stmt|;
if|if
condition|(
name|url
operator|.
name|isValid
argument_list|()
condition|)
name|u
operator|=
name|url
operator|.
name|toEncoded
argument_list|()
expr_stmt|;
name|out
operator|<<
name|u
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*! \relates QUrl      Reads a url into \a url from the stream \a in and returns a     reference to the stream.      \sa{Serializing Qt Data Types}{Format of the QDataStream operators} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|QByteArray
name|u
decl_stmt|;
name|in
operator|>>
name|u
expr_stmt|;
name|url
operator|.
name|setUrl
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|d
parameter_list|,
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|d
operator|.
name|maybeSpace
argument_list|()
operator|<<
literal|"QUrl("
operator|<<
name|url
operator|.
name|toDisplayString
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|d
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|errorMessage
specifier|static
name|QString
name|errorMessage
parameter_list|(
name|QUrlPrivate
operator|::
name|ErrorCode
name|errorCode
parameter_list|,
specifier|const
name|QString
modifier|&
name|errorSource
parameter_list|,
name|int
name|errorPosition
parameter_list|)
block|{
name|QChar
name|c
init|=
name|uint
argument_list|(
name|errorPosition
argument_list|)
operator|<
name|uint
argument_list|(
name|errorSource
operator|.
name|length
argument_list|()
argument_list|)
condition|?
name|errorSource
operator|.
name|at
argument_list|(
name|errorPosition
argument_list|)
else|:
name|QChar
argument_list|(
name|QChar
operator|::
name|Null
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|errorCode
condition|)
block|{
case|case
name|QUrlPrivate
operator|::
name|NoError
case|:
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QUrl::errorString"
argument_list|,
literal|"Impossible: QUrl::errorString should have treated this condition"
argument_list|)
expr_stmt|;
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidSchemeError
case|:
block|{
name|QString
name|msg
init|=
name|QStringLiteral
argument_list|(
literal|"Invalid scheme (character '%1' not permitted)"
argument_list|)
decl_stmt|;
return|return
name|msg
operator|.
name|arg
argument_list|(
name|c
argument_list|)
return|;
block|}
case|case
name|QUrlPrivate
operator|::
name|InvalidUserNameError
case|:
return|return
name|QString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Invalid user name (character '%1' not permitted)"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidPasswordError
case|:
return|return
name|QString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Invalid password (character '%1' not permitted)"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidRegNameError
case|:
if|if
condition|(
name|errorPosition
operator|!=
operator|-
literal|1
condition|)
return|return
name|QString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Invalid hostname (character '%1' not permitted)"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
return|;
else|else
return|return
name|QStringLiteral
argument_list|(
literal|"Invalid hostname (contains invalid characters)"
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidIPv4AddressError
case|:
return|return
name|QString
argument_list|()
return|;
comment|// doesn't happen yet
case|case
name|QUrlPrivate
operator|::
name|InvalidIPv6AddressError
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"Invalid IPv6 address"
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidIPvFutureError
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"Invalid IPvFuture address"
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|HostMissingEndBracket
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"Expected ']' to match '[' in hostname"
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidPortError
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"Invalid port or port number out of range"
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|PortEmptyError
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"Port field was empty"
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidPathError
case|:
return|return
name|QString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Invalid path (character '%1' not permitted)"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidQueryError
case|:
return|return
name|QString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Invalid query (character '%1' not permitted)"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|InvalidFragmentError
case|:
return|return
name|QString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Invalid fragment (character '%1' not permitted)"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|c
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|AuthorityPresentAndPathIsRelative
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"Path component is relative and authority is present"
argument_list|)
return|;
case|case
name|QUrlPrivate
operator|::
name|RelativeUrlPathContainsColonBeforeSlash
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"Relative URL's path component contains ':' before any '/'"
argument_list|)
return|;
block|}
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QUrl::errorString"
argument_list|,
literal|"Cannot happen, unknown error"
argument_list|)
expr_stmt|;
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|appendComponentIfPresent
specifier|static
specifier|inline
name|void
name|appendComponentIfPresent
parameter_list|(
name|QString
modifier|&
name|msg
parameter_list|,
name|bool
name|present
parameter_list|,
specifier|const
name|char
modifier|*
name|componentName
parameter_list|,
specifier|const
name|QString
modifier|&
name|component
parameter_list|)
block|{
if|if
condition|(
name|present
condition|)
block|{
name|msg
operator|+=
name|QLatin1String
argument_list|(
name|componentName
argument_list|)
expr_stmt|;
name|msg
operator|+=
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|msg
operator|+=
name|component
expr_stmt|;
name|msg
operator|+=
name|QLatin1String
argument_list|(
literal|"\","
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns an error message if the last operation that modified this QUrl     object ran into a parsing error. If no error was detected, this function     returns an empty string and isValid() returns true.      The error message returned by this function is technical in nature and may     not be understood by end users. It is mostly useful to developers trying to     understand why QUrl will not accept some input.      \sa QUrl::ParsingMode */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QUrl
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|errorSource
decl_stmt|;
name|int
name|errorPosition
decl_stmt|;
name|QUrlPrivate
operator|::
name|ErrorCode
name|errorCode
init|=
name|d
operator|->
name|validityError
argument_list|(
operator|&
name|errorSource
argument_list|,
operator|&
name|errorPosition
argument_list|)
decl_stmt|;
if|if
condition|(
name|errorCode
operator|==
name|QUrlPrivate
operator|::
name|NoError
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|msg
init|=
name|errorMessage
argument_list|(
name|errorCode
argument_list|,
name|errorSource
argument_list|,
name|errorPosition
argument_list|)
decl_stmt|;
name|msg
operator|+=
name|QLatin1String
argument_list|(
literal|"; source was \""
argument_list|)
expr_stmt|;
name|msg
operator|+=
name|errorSource
expr_stmt|;
name|msg
operator|+=
name|QLatin1String
argument_list|(
literal|"\";"
argument_list|)
expr_stmt|;
name|appendComponentIfPresent
argument_list|(
name|msg
argument_list|,
name|d
operator|->
name|sectionIsPresent
operator|&
name|QUrlPrivate
operator|::
name|Scheme
argument_list|,
literal|" scheme = "
argument_list|,
name|d
operator|->
name|scheme
argument_list|)
expr_stmt|;
name|appendComponentIfPresent
argument_list|(
name|msg
argument_list|,
name|d
operator|->
name|sectionIsPresent
operator|&
name|QUrlPrivate
operator|::
name|UserInfo
argument_list|,
literal|" userinfo = "
argument_list|,
name|userInfo
argument_list|()
argument_list|)
expr_stmt|;
name|appendComponentIfPresent
argument_list|(
name|msg
argument_list|,
name|d
operator|->
name|sectionIsPresent
operator|&
name|QUrlPrivate
operator|::
name|Host
argument_list|,
literal|" host = "
argument_list|,
name|d
operator|->
name|host
argument_list|)
expr_stmt|;
name|appendComponentIfPresent
argument_list|(
name|msg
argument_list|,
name|d
operator|->
name|port
operator|!=
operator|-
literal|1
argument_list|,
literal|" port = "
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|d
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|appendComponentIfPresent
argument_list|(
name|msg
argument_list|,
operator|!
name|d
operator|->
name|path
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|" path = "
argument_list|,
name|d
operator|->
name|path
argument_list|)
expr_stmt|;
name|appendComponentIfPresent
argument_list|(
name|msg
argument_list|,
name|d
operator|->
name|sectionIsPresent
operator|&
name|QUrlPrivate
operator|::
name|Query
argument_list|,
literal|" query = "
argument_list|,
name|d
operator|->
name|query
argument_list|)
expr_stmt|;
name|appendComponentIfPresent
argument_list|(
name|msg
argument_list|,
name|d
operator|->
name|sectionIsPresent
operator|&
name|QUrlPrivate
operator|::
name|Fragment
argument_list|,
literal|" fragment = "
argument_list|,
name|d
operator|->
name|fragment
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
argument_list|)
condition|)
name|msg
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
end_function
begin_comment
comment|/*!     \typedef QUrl::DataPtr     \internal */
end_comment
begin_comment
comment|/*!     \fn DataPtr&QUrl::data_ptr()     \internal */
end_comment
begin_comment
comment|/*!     Returns the hash value for the \a url. If specified, \a seed is used to     initialize the hash.      \relates QHash     \since 5.0 */
end_comment
begin_function
name|uint
name|qHash
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
if|if
condition|(
operator|!
name|url
operator|.
name|d
condition|)
return|return
name|qHash
argument_list|(
operator|-
literal|1
argument_list|,
name|seed
argument_list|)
return|;
comment|// the hash of an unset port (-1)
return|return
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|scheme
argument_list|)
operator|^
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|userName
argument_list|)
operator|^
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|password
argument_list|)
operator|^
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|host
argument_list|)
operator|^
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|port
argument_list|,
name|seed
argument_list|)
operator|^
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|path
argument_list|)
operator|^
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|query
argument_list|)
operator|^
name|qHash
argument_list|(
name|url
operator|.
name|d
operator|->
name|fragment
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|adjustFtpPath
specifier|static
name|QUrl
name|adjustFtpPath
parameter_list|(
name|QUrl
name|url
parameter_list|)
block|{
if|if
condition|(
name|url
operator|.
name|scheme
argument_list|()
operator|==
name|ftpScheme
argument_list|()
condition|)
block|{
name|QString
name|path
init|=
name|url
operator|.
name|path
argument_list|()
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
argument_list|)
condition|)
name|url
operator|.
name|setPath
argument_list|(
name|QLatin1String
argument_list|(
literal|"/%2F"
argument_list|)
operator|+
name|path
operator|.
name|midRef
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|url
return|;
block|}
end_function
begin_comment
comment|// The following code has the following copyright:
end_comment
begin_comment
comment|/*    Copyright (C) Research In Motion Limited 2009. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:     * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     * Neither the name of Research In Motion Limited nor the       names of its contributors may be used to endorse or promote products       derived from this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY Research In Motion Limited ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Research In Motion Limited BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_comment
comment|/*!     Returns a valid URL from a user supplied \a userInput string if one can be     deducted. In the case that is not possible, an invalid QUrl() is returned.      \since 4.6      Most applications that can browse the web, allow the user to input a URL     in the form of a plain string. This string can be manually typed into     a location bar, obtained from the clipboard, or passed in via command     line arguments.      When the string is not already a valid URL, a best guess is performed,     making various web related assumptions.      In the case the string corresponds to a valid file path on the system,     a file:// URL is constructed, using QUrl::fromLocalFile().      If that is not the case, an attempt is made to turn the string into a     http:// or ftp:// URL. The latter in the case the string starts with     'ftp'. The result is then passed through QUrl's tolerant parser, and     in the case or success, a valid QUrl is returned, or else a QUrl().      \section1 Examples:      \list     \li qt.nokia.com becomes http://qt.nokia.com     \li ftp.qt.nokia.com becomes ftp://ftp.qt.nokia.com     \li hostname becomes http://hostname     \li /home/user/test.html becomes file:///home/user/test.html     \endlist */
end_comment
begin_function
DECL|function|fromUserInput
name|QUrl
name|QUrl
operator|::
name|fromUserInput
parameter_list|(
specifier|const
name|QString
modifier|&
name|userInput
parameter_list|)
block|{
name|QString
name|trimmedString
init|=
name|userInput
operator|.
name|trimmed
argument_list|()
decl_stmt|;
comment|// Check first for files, since on Windows drive letters can be interpretted as schemes
if|if
condition|(
name|QDir
operator|::
name|isAbsolutePath
argument_list|(
name|trimmedString
argument_list|)
condition|)
return|return
name|QUrl
operator|::
name|fromLocalFile
argument_list|(
name|trimmedString
argument_list|)
return|;
name|QUrl
name|url
init|=
name|QUrl
argument_list|(
name|trimmedString
argument_list|,
name|QUrl
operator|::
name|TolerantMode
argument_list|)
decl_stmt|;
name|QUrl
name|urlPrepended
init|=
name|QUrl
argument_list|(
name|QStringLiteral
argument_list|(
literal|"http://"
argument_list|)
operator|+
name|trimmedString
argument_list|,
name|QUrl
operator|::
name|TolerantMode
argument_list|)
decl_stmt|;
comment|// Check the most common case of a valid url with scheme and host
comment|// We check if the port would be valid by adding the scheme to handle the case host:port
comment|// where the host would be interpretted as the scheme
if|if
condition|(
name|url
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|url
operator|.
name|scheme
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|!
name|url
operator|.
name|host
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|url
operator|.
name|path
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
name|urlPrepended
operator|.
name|port
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
name|adjustFtpPath
argument_list|(
name|url
argument_list|)
return|;
comment|// Else, try the prepended one and adjust the scheme from the host name
if|if
condition|(
name|urlPrepended
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
operator|!
name|urlPrepended
operator|.
name|host
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|urlPrepended
operator|.
name|path
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|int
name|dotIndex
init|=
name|trimmedString
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|hostscheme
init|=
name|trimmedString
operator|.
name|left
argument_list|(
name|dotIndex
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|hostscheme
operator|==
name|ftpScheme
argument_list|()
condition|)
name|urlPrepended
operator|.
name|setScheme
argument_list|(
name|ftpScheme
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|adjustFtpPath
argument_list|(
name|urlPrepended
argument_list|)
return|;
block|}
return|return
name|QUrl
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// end of BSD code
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
