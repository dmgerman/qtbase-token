begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QUrl      \brief The QUrl class provides a convenient interface for working     with URLs.      \reentrant     \ingroup io     \ingroup network     \ingroup shared       It can parse and construct URLs in both encoded and unencoded     form. QUrl also has support for internationalized domain names     (IDNs).      The most common way to use QUrl is to initialize it via the     constructor by passing a QString. Otherwise, setUrl() and     setEncodedUrl() can also be used.      URLs can be represented in two forms: encoded or unencoded. The     unencoded representation is suitable for showing to users, but     the encoded representation is typically what you would send to     a web server. For example, the unencoded URL     "http://b\uuml\c{}hler.example.com" would be sent to the server as     "http://xn--bhler-kva.example.com/List%20of%20applicants.xml".      A URL can also be constructed piece by piece by calling     setScheme(), setUserName(), setPassword(), setHost(), setPort(),     setPath(), setEncodedQuery() and setFragment(). Some convenience     functions are also available: setAuthority() sets the user name,     password, host and port. setUserInfo() sets the user name and     password at once.      Call isValid() to check if the URL is valid. This can be done at     any point during the constructing of a URL.      Constructing a query is particularly convenient through the use     of setQueryItems(), addQueryItem() and removeQueryItem(). Use     setQueryDelimiters() to customize the delimiters used for     generating the query string.      For the convenience of generating encoded URL strings or query     strings, there are two static functions called     fromPercentEncoding() and toPercentEncoding() which deal with     percent encoding and decoding of QStrings.      Calling isRelative() will tell whether or not the URL is     relative. A relative URL can be resolved by passing it as argument     to resolved(), which returns an absolute URL. isParentOf() is used     for determining whether one URL is a parent of another.      fromLocalFile() constructs a QUrl by parsing a local     file path. toLocalFile() converts a URL to a local file path.      The human readable representation of the URL is fetched with     toString(). This representation is appropriate for displaying a     URL to a user in unencoded form. The encoded form however, as     returned by toEncoded(), is for internal use, passing to web     servers, mail clients and so on.      QUrl conforms to the URI specification from     \l{RFC 3986} (Uniform Resource Identifier: Generic Syntax), and includes     scheme extensions from \l{RFC 1738} (Uniform Resource Locators). Case     folding rules in QUrl conform to \l{RFC 3491} (Nameprep: A Stringprep     Profile for Internationalized Domain Names (IDN)).      \section2 Character Conversions      Follow these rules to avoid erroneous character conversion when     dealing with URLs and strings:      \list     \li When creating an QString to contain a URL from a QByteArray or a        char*, always use QString::fromUtf8().     \endlist      \sa QUrlInfo */
end_comment
begin_comment
comment|/*!     \enum QUrl::ParsingMode      The parsing mode controls the way QUrl parses strings.      \value TolerantMode QUrl will try to correct some common errors in URLs.                         This mode is useful when processing URLs entered by                         users.      \value StrictMode Only valid URLs are accepted. This mode is useful for                       general URL validation.      In TolerantMode, the parser corrects the following invalid input:      \list      \li Spaces and "%20": If an encoded URL contains a space, this will be     replaced with "%20". If a decoded URL contains "%20", this will be     replaced with a single space before the URL is parsed.      \li Single "%" characters: Any occurrences of a percent character "%" not     followed by exactly two hexadecimal characters (e.g., "13% coverage.html")     will be replaced by "%25".      \li Reserved and unreserved characters: An encoded URL should only     contain a few characters as literals; all other characters should     be percent-encoded. In TolerantMode, these characters will be     automatically percent-encoded where they are not allowed:             space / double-quote / "<" / ">" / "[" / "\" /             "]" / "^" / "`" / "{" / "|" / "}"      \endlist */
end_comment
begin_comment
comment|/*!     \enum QUrl::FormattingOption      The formatting options define how the URL is formatted when written out     as text.      \value None The format of the URL is unchanged.     \value RemoveScheme  The scheme is removed from the URL.     \value RemovePassword  Any password in the URL is removed.     \value RemoveUserInfo  Any user information in the URL is removed.     \value RemovePort      Any specified port is removed from the URL.     \value RemoveAuthority     \value RemovePath   The URL's path is removed, leaving only the scheme,                         host address, and port (if present).     \value RemoveQuery  The query part of the URL (following a '?' character)                         is removed.     \value RemoveFragment     \value PreferLocalFile If the URL is a local file according to isLocalFile()      and contains no query or fragment, a local file path is returned.     \value StripTrailingSlash  The trailing slash is removed if one is present.      Note that the case folding rules in \l{RFC 3491}{Nameprep}, which QUrl     conforms to, require host names to always be converted to lower case,     regardless of the Qt::FormattingOptions used. */
end_comment
begin_comment
comment|/*!  \fn uint qHash(const QUrl&url)  \since 4.7  \relates QUrl   Computes a hash key from the normalized version of \a url.  */
end_comment
begin_include
include|#
directive|include
file|"qurl.h"
end_include
begin_include
include|#
directive|include
file|"qurl_p.h"
end_include
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qatomic.h"
end_include
begin_include
include|#
directive|include
file|"qbytearray.h"
end_include
begin_include
include|#
directive|include
file|"qdir.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_include
include|#
directive|include
file|"qregexp.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qstack.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qtldurl_p.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE_WM
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|optimize
name|(
literal|"g"
name|,
name|off
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|QT_BEGIN_NAMESPACE
specifier|extern
name|void
name|q_normalizePercentEncoding
parameter_list|(
name|QByteArray
modifier|*
name|ba
parameter_list|,
specifier|const
name|char
modifier|*
name|exclude
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|void
name|q_toPercentEncoding
parameter_list|(
name|QByteArray
modifier|*
name|ba
parameter_list|,
specifier|const
name|char
modifier|*
name|exclude
parameter_list|,
specifier|const
name|char
modifier|*
name|include
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|void
name|q_fromPercentEncoding
parameter_list|(
name|QByteArray
modifier|*
name|ba
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|toPercentEncodingHelper
specifier|static
name|QByteArray
name|toPercentEncodingHelper
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|exclude
parameter_list|,
specifier|const
name|char
modifier|*
name|include
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QByteArray
argument_list|()
return|;
comment|// null
name|QByteArray
name|ba
init|=
name|s
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
name|q_toPercentEncoding
argument_list|(
operator|&
name|ba
argument_list|,
name|exclude
argument_list|,
name|include
argument_list|)
expr_stmt|;
return|return
name|ba
return|;
block|}
end_function
begin_function
DECL|function|fromPercentEncodingHelper
specifier|static
name|QString
name|fromPercentEncodingHelper
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
if|if
condition|(
name|ba
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// null
name|QByteArray
name|copy
init|=
name|ba
decl_stmt|;
name|q_fromPercentEncoding
argument_list|(
operator|&
name|copy
argument_list|)
expr_stmt|;
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
name|copy
operator|.
name|constData
argument_list|()
argument_list|,
name|copy
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fromPercentEncodingMutable
specifier|static
name|QString
name|fromPercentEncodingMutable
parameter_list|(
name|QByteArray
modifier|*
name|ba
parameter_list|)
block|{
if|if
condition|(
name|ba
operator|->
name|isNull
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// null
name|q_fromPercentEncoding
argument_list|(
name|ba
argument_list|)
expr_stmt|;
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
name|ba
operator|->
name|constData
argument_list|()
argument_list|,
name|ba
operator|->
name|length
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// ### Qt 5: Consider accepting empty strings as valid. See task 144227.
end_comment
begin_comment
comment|//#define QURL_DEBUG
end_comment
begin_comment
comment|// implemented in qvsnprintf.cpp
end_comment
begin_function_decl
name|Q_CORE_EXPORT
name|int
name|qsnprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|QURL_SETFLAG
define|#
directive|define
name|QURL_SETFLAG
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|{ (a) |= (b); }
end_define
begin_define
DECL|macro|QURL_UNSETFLAG
define|#
directive|define
name|QURL_UNSETFLAG
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|{ (a)&= ~(b); }
end_define
begin_define
DECL|macro|QURL_HASFLAG
define|#
directive|define
name|QURL_HASFLAG
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)& (b)) == (b))
end_define
begin_class
DECL|class|QUrlPrivate
class|class
name|QUrlPrivate
block|{
public|public:
name|QUrlPrivate
parameter_list|()
constructor_decl|;
name|QUrlPrivate
parameter_list|(
specifier|const
name|QUrlPrivate
modifier|&
name|other
parameter_list|)
constructor_decl|;
name|bool
name|setUrl
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|)
function_decl|;
name|QString
name|canonicalHost
parameter_list|()
specifier|const
function_decl|;
name|void
name|ensureEncodedParts
parameter_list|()
specifier|const
function_decl|;
name|QString
name|authority
parameter_list|(
name|QUrl
operator|::
name|FormattingOptions
name|options
init|=
name|QUrl
operator|::
name|None
parameter_list|)
specifier|const
function_decl|;
name|void
name|setAuthority
parameter_list|(
specifier|const
name|QString
modifier|&
name|auth
parameter_list|)
function_decl|;
name|void
name|setUserInfo
parameter_list|(
specifier|const
name|QString
modifier|&
name|userInfo
parameter_list|)
function_decl|;
name|QString
name|userInfo
parameter_list|(
name|QUrl
operator|::
name|FormattingOptions
name|options
init|=
name|QUrl
operator|::
name|None
parameter_list|)
specifier|const
function_decl|;
name|void
name|setEncodedAuthority
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|authority
parameter_list|)
function_decl|;
name|void
name|setEncodedUserInfo
parameter_list|(
specifier|const
name|QUrlParseData
modifier|*
name|parseData
parameter_list|)
function_decl|;
name|void
name|setEncodedUrl
parameter_list|(
specifier|const
name|QByteArray
modifier|&
parameter_list|,
name|QUrl
operator|::
name|ParsingMode
parameter_list|)
function_decl|;
name|QByteArray
name|mergePaths
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|relativePath
parameter_list|)
specifier|const
function_decl|;
name|void
name|queryItem
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|end
parameter_list|)
function_decl|;
DECL|enum|ParseOptions
enum|enum
name|ParseOptions
block|{
DECL|enumerator|ParseAndSet
name|ParseAndSet
block|,
DECL|enumerator|ParseOnly
name|ParseOnly
block|}
enum|;
name|void
name|validate
parameter_list|()
specifier|const
function_decl|;
name|void
name|parse
parameter_list|(
name|ParseOptions
name|parseOptions
init|=
name|ParseAndSet
parameter_list|)
specifier|const
function_decl|;
name|void
name|clear
parameter_list|()
function_decl|;
name|QByteArray
name|toEncoded
parameter_list|(
name|QUrl
operator|::
name|FormattingOptions
name|options
init|=
name|QUrl
operator|::
name|None
parameter_list|)
specifier|const
function_decl|;
name|bool
name|isLocalFile
parameter_list|()
specifier|const
function_decl|;
DECL|member|ref
name|QAtomicInt
name|ref
decl_stmt|;
DECL|member|scheme
name|QString
name|scheme
decl_stmt|;
DECL|member|userName
name|QString
name|userName
decl_stmt|;
DECL|member|password
name|QString
name|password
decl_stmt|;
DECL|member|host
name|QString
name|host
decl_stmt|;
DECL|member|path
name|QString
name|path
decl_stmt|;
DECL|member|query
name|QByteArray
name|query
decl_stmt|;
DECL|member|fragment
name|QString
name|fragment
decl_stmt|;
DECL|member|encodedOriginal
name|QByteArray
name|encodedOriginal
decl_stmt|;
DECL|member|encodedUserName
name|QByteArray
name|encodedUserName
decl_stmt|;
DECL|member|encodedPassword
name|QByteArray
name|encodedPassword
decl_stmt|;
DECL|member|encodedPath
name|QByteArray
name|encodedPath
decl_stmt|;
DECL|member|encodedFragment
name|QByteArray
name|encodedFragment
decl_stmt|;
DECL|member|port
name|int
name|port
decl_stmt|;
DECL|member|parsingMode
name|QUrl
operator|::
name|ParsingMode
name|parsingMode
decl_stmt|;
DECL|member|hasQuery
name|bool
name|hasQuery
decl_stmt|;
DECL|member|hasFragment
name|bool
name|hasFragment
decl_stmt|;
DECL|member|isValid
name|bool
name|isValid
decl_stmt|;
DECL|member|isHostValid
name|bool
name|isHostValid
decl_stmt|;
DECL|member|valueDelimiter
name|char
name|valueDelimiter
decl_stmt|;
DECL|member|pairDelimiter
name|char
name|pairDelimiter
decl_stmt|;
DECL|enum|State
enum|enum
name|State
block|{
DECL|enumerator|Parsed
name|Parsed
init|=
literal|0x1
block|,
DECL|enumerator|Validated
name|Validated
init|=
literal|0x2
block|,
DECL|enumerator|Normalized
name|Normalized
init|=
literal|0x4
block|,
DECL|enumerator|HostCanonicalized
name|HostCanonicalized
init|=
literal|0x8
block|}
enum|;
DECL|member|stateFlags
name|int
name|stateFlags
decl_stmt|;
DECL|member|encodedNormalized
specifier|mutable
name|QByteArray
name|encodedNormalized
decl_stmt|;
specifier|const
name|QByteArray
modifier|&
name|normalized
parameter_list|()
specifier|const
function_decl|;
DECL|member|errorInfo
specifier|mutable
name|QUrlErrorInfo
name|errorInfo
decl_stmt|;
name|QString
name|createErrorString
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_constructor
DECL|function|QUrlPrivate
name|QUrlPrivate
operator|::
name|QUrlPrivate
parameter_list|()
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|port
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|parsingMode
argument_list|(
name|QUrl
operator|::
name|TolerantMode
argument_list|)
member_init_list|,
name|hasQuery
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|hasFragment
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isValid
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isHostValid
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|valueDelimiter
argument_list|(
literal|'='
argument_list|)
member_init_list|,
name|pairDelimiter
argument_list|(
literal|'&'
argument_list|)
member_init_list|,
name|stateFlags
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QUrlPrivate
name|QUrlPrivate
operator|::
name|QUrlPrivate
parameter_list|(
specifier|const
name|QUrlPrivate
modifier|&
name|copy
parameter_list|)
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|scheme
argument_list|(
name|copy
operator|.
name|scheme
argument_list|)
member_init_list|,
name|userName
argument_list|(
name|copy
operator|.
name|userName
argument_list|)
member_init_list|,
name|password
argument_list|(
name|copy
operator|.
name|password
argument_list|)
member_init_list|,
name|host
argument_list|(
name|copy
operator|.
name|host
argument_list|)
member_init_list|,
name|path
argument_list|(
name|copy
operator|.
name|path
argument_list|)
member_init_list|,
name|query
argument_list|(
name|copy
operator|.
name|query
argument_list|)
member_init_list|,
name|fragment
argument_list|(
name|copy
operator|.
name|fragment
argument_list|)
member_init_list|,
name|encodedOriginal
argument_list|(
name|copy
operator|.
name|encodedOriginal
argument_list|)
member_init_list|,
name|encodedUserName
argument_list|(
name|copy
operator|.
name|encodedUserName
argument_list|)
member_init_list|,
name|encodedPassword
argument_list|(
name|copy
operator|.
name|encodedPassword
argument_list|)
member_init_list|,
name|encodedPath
argument_list|(
name|copy
operator|.
name|encodedPath
argument_list|)
member_init_list|,
name|encodedFragment
argument_list|(
name|copy
operator|.
name|encodedFragment
argument_list|)
member_init_list|,
name|port
argument_list|(
name|copy
operator|.
name|port
argument_list|)
member_init_list|,
name|parsingMode
argument_list|(
name|copy
operator|.
name|parsingMode
argument_list|)
member_init_list|,
name|hasQuery
argument_list|(
name|copy
operator|.
name|hasQuery
argument_list|)
member_init_list|,
name|hasFragment
argument_list|(
name|copy
operator|.
name|hasFragment
argument_list|)
member_init_list|,
name|isValid
argument_list|(
name|copy
operator|.
name|isValid
argument_list|)
member_init_list|,
name|isHostValid
argument_list|(
name|copy
operator|.
name|isHostValid
argument_list|)
member_init_list|,
name|valueDelimiter
argument_list|(
name|copy
operator|.
name|valueDelimiter
argument_list|)
member_init_list|,
name|pairDelimiter
argument_list|(
name|copy
operator|.
name|pairDelimiter
argument_list|)
member_init_list|,
name|stateFlags
argument_list|(
name|copy
operator|.
name|stateFlags
argument_list|)
member_init_list|,
name|encodedNormalized
argument_list|(
name|copy
operator|.
name|encodedNormalized
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|canonicalHost
name|QString
name|QUrlPrivate
operator|::
name|canonicalHost
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QURL_HASFLAG
argument_list|(
name|stateFlags
argument_list|,
name|HostCanonicalized
argument_list|)
operator|||
name|host
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|host
return|;
name|QUrlPrivate
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QUrlPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QURL_SETFLAG
argument_list|(
name|that
operator|->
name|stateFlags
argument_list|,
name|HostCanonicalized
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
block|{
comment|// This is an IP Literal, use _IPLiteral to validate
name|QByteArray
name|ba
init|=
name|host
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
name|bool
name|needsBraces
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|ba
operator|.
name|startsWith
argument_list|(
literal|'['
argument_list|)
condition|)
block|{
comment|// surround the IP Literal with [ ] if it's not already done so
name|ba
operator|.
name|reserve
argument_list|(
name|ba
operator|.
name|length
argument_list|()
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ba
operator|.
name|prepend
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|ba
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|needsBraces
operator|=
literal|true
expr_stmt|;
block|}
specifier|const
name|char
modifier|*
name|ptr
init|=
name|ba
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|qt_isValidUrlIP
argument_list|(
name|ptr
argument_list|)
condition|)
name|that
operator|->
name|host
operator|.
name|clear
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|needsBraces
condition|)
name|that
operator|->
name|host
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|ba
operator|.
name|toLower
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|that
operator|->
name|host
operator|=
name|host
operator|.
name|toLower
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|that
operator|->
name|host
operator|=
name|qt_ACE_do
argument_list|(
name|host
argument_list|,
name|NormalizeAce
argument_list|)
expr_stmt|;
block|}
name|that
operator|->
name|isHostValid
operator|=
operator|!
name|that
operator|->
name|host
operator|.
name|isNull
argument_list|()
expr_stmt|;
return|return
name|that
operator|->
name|host
return|;
block|}
end_function
begin_comment
comment|// From RFC 3896, Appendix A Collected ABNF for URI
end_comment
begin_comment
comment|//    authority     = [ userinfo "@" ] host [ ":" port ]
end_comment
begin_comment
comment|//    userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
end_comment
begin_comment
comment|//    host          = IP-literal / IPv4address / reg-name
end_comment
begin_comment
comment|//    port          = *DIGIT
end_comment
begin_comment
comment|//[...]
end_comment
begin_comment
comment|//    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    query         = *( pchar / "/" / "?" )
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    fragment      = *( pchar / "/" / "?" )
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    pct-encoded   = "%" HEXDIG HEXDIG
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
end_comment
begin_comment
comment|//    reserved      = gen-delims / sub-delims
end_comment
begin_comment
comment|//    gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
end_comment
begin_comment
comment|//    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
end_comment
begin_comment
comment|//                  / "*" / "+" / "," / ";" / "="
end_comment
begin_comment
comment|// use defines for concatenation:
end_comment
begin_define
DECL|macro|ABNF_sub_delims
define|#
directive|define
name|ABNF_sub_delims
value|"!$&'()*+,;="
end_define
begin_define
DECL|macro|ABNF_gen_delims
define|#
directive|define
name|ABNF_gen_delims
value|":/?#[]@"
end_define
begin_define
DECL|macro|ABNF_pchar
define|#
directive|define
name|ABNF_pchar
value|ABNF_sub_delims ":@"
end_define
begin_define
DECL|macro|ABNF_reserved
define|#
directive|define
name|ABNF_reserved
value|ABNF_sub_delims ABNF_gen_delims
end_define
begin_comment
comment|// list the characters that don't have to be converted according to the list above.
end_comment
begin_comment
comment|// "unreserved" is already automatically not encoded, so we don't have to list it.
end_comment
begin_comment
comment|// the path component has a complex ABNF that basically boils down to
end_comment
begin_comment
comment|// slash-separated segments of "pchar"
end_comment
begin_decl_stmt
DECL|variable|userNameExcludeChars
specifier|static
specifier|const
name|char
name|userNameExcludeChars
index|[]
init|=
name|ABNF_sub_delims
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|passwordExcludeChars
specifier|static
specifier|const
name|char
name|passwordExcludeChars
index|[]
init|=
name|ABNF_sub_delims
literal|":"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pathExcludeChars
specifier|static
specifier|const
name|char
name|pathExcludeChars
index|[]
init|=
name|ABNF_pchar
literal|"/"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|queryExcludeChars
specifier|static
specifier|const
name|char
name|queryExcludeChars
index|[]
init|=
name|ABNF_pchar
literal|"/?"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fragmentExcludeChars
specifier|static
specifier|const
name|char
name|fragmentExcludeChars
index|[]
init|=
name|ABNF_pchar
literal|"/?"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|ensureEncodedParts
name|void
name|QUrlPrivate
operator|::
name|ensureEncodedParts
parameter_list|()
specifier|const
block|{
name|QUrlPrivate
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QUrlPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|encodedUserName
operator|.
name|isNull
argument_list|()
condition|)
comment|// userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
name|that
operator|->
name|encodedUserName
operator|=
name|toPercentEncodingHelper
argument_list|(
name|userName
argument_list|,
name|userNameExcludeChars
argument_list|)
expr_stmt|;
if|if
condition|(
name|encodedPassword
operator|.
name|isNull
argument_list|()
condition|)
comment|// userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
name|that
operator|->
name|encodedPassword
operator|=
name|toPercentEncodingHelper
argument_list|(
name|password
argument_list|,
name|passwordExcludeChars
argument_list|)
expr_stmt|;
if|if
condition|(
name|encodedPath
operator|.
name|isNull
argument_list|()
condition|)
comment|// pchar = unreserved / pct-encoded / sub-delims / ":" / "@" ... also "/"
name|that
operator|->
name|encodedPath
operator|=
name|toPercentEncodingHelper
argument_list|(
name|path
argument_list|,
name|pathExcludeChars
argument_list|)
expr_stmt|;
if|if
condition|(
name|encodedFragment
operator|.
name|isNull
argument_list|()
condition|)
comment|// fragment      = *( pchar / "/" / "?" )
name|that
operator|->
name|encodedFragment
operator|=
name|toPercentEncodingHelper
argument_list|(
name|fragment
argument_list|,
name|fragmentExcludeChars
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|authority
name|QString
name|QUrlPrivate
operator|::
name|authority
parameter_list|(
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveAuthority
operator|)
operator|==
name|QUrl
operator|::
name|RemoveAuthority
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|tmp
init|=
name|userInfo
argument_list|(
name|options
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|.
name|isEmpty
argument_list|()
condition|)
name|tmp
operator|+=
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
name|tmp
operator|+=
name|canonicalHost
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemovePort
operator|)
operator|&&
name|port
operator|!=
operator|-
literal|1
condition|)
name|tmp
operator|+=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function
begin_function
DECL|function|setAuthority
name|void
name|QUrlPrivate
operator|::
name|setAuthority
parameter_list|(
specifier|const
name|QString
modifier|&
name|auth
parameter_list|)
block|{
name|isHostValid
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|auth
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|setUserInfo
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|host
operator|.
name|clear
argument_list|()
expr_stmt|;
name|port
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|// find the port section of the authority by searching from the
comment|// end towards the beginning for numbers until a ':' is reached.
name|int
name|portIndex
init|=
name|auth
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|portIndex
operator|==
literal|0
condition|)
block|{
name|portIndex
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|short
name|c
init|=
name|auth
operator|.
name|at
argument_list|(
name|portIndex
operator|--
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
argument_list|<
literal|'0'
operator|||
name|c
argument_list|>
literal|'9'
condition|)
block|{
name|portIndex
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
while|while
condition|(
name|portIndex
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|auth
operator|.
name|at
argument_list|(
name|portIndex
argument_list|)
operator|.
name|unicode
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|portIndex
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
operator|--
name|portIndex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|portIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|port
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|portIndex
operator|+
literal|1
init|;
name|i
operator|<
name|auth
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
name|port
operator|=
operator|(
name|port
operator|*
literal|10
operator|)
operator|+
operator|(
name|auth
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|unicode
argument_list|()
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
else|else
block|{
name|port
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|int
name|userInfoIndex
init|=
name|auth
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|userInfoIndex
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|portIndex
operator|==
operator|-
literal|1
operator|||
name|userInfoIndex
operator|<
name|portIndex
operator|)
condition|)
name|setUserInfo
argument_list|(
name|auth
operator|.
name|left
argument_list|(
name|userInfoIndex
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|hostIndex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|userInfoIndex
operator|!=
operator|-
literal|1
condition|)
name|hostIndex
operator|=
name|userInfoIndex
operator|+
literal|1
expr_stmt|;
name|int
name|hostLength
init|=
name|auth
operator|.
name|length
argument_list|()
operator|-
name|hostIndex
decl_stmt|;
if|if
condition|(
name|portIndex
operator|!=
operator|-
literal|1
condition|)
name|hostLength
operator|-=
operator|(
name|auth
operator|.
name|length
argument_list|()
operator|-
name|portIndex
operator|)
expr_stmt|;
name|host
operator|=
name|auth
operator|.
name|mid
argument_list|(
name|hostIndex
argument_list|,
name|hostLength
argument_list|)
operator|.
name|trimmed
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setUserInfo
name|void
name|QUrlPrivate
operator|::
name|setUserInfo
parameter_list|(
specifier|const
name|QString
modifier|&
name|userInfo
parameter_list|)
block|{
name|encodedUserName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|encodedPassword
operator|.
name|clear
argument_list|()
expr_stmt|;
name|int
name|delimIndex
init|=
name|userInfo
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|delimIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|userName
operator|=
name|userInfo
expr_stmt|;
name|password
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
name|userName
operator|=
name|userInfo
operator|.
name|left
argument_list|(
name|delimIndex
argument_list|)
expr_stmt|;
name|password
operator|=
name|userInfo
operator|.
name|right
argument_list|(
name|userInfo
operator|.
name|length
argument_list|()
operator|-
name|delimIndex
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setEncodedUserInfo
name|void
name|QUrlPrivate
operator|::
name|setEncodedUserInfo
parameter_list|(
specifier|const
name|QUrlParseData
modifier|*
name|parseData
parameter_list|)
block|{
name|userName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|password
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|parseData
operator|->
name|userInfoLength
condition|)
block|{
name|encodedUserName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|encodedPassword
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parseData
operator|->
name|userInfoDelimIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|encodedUserName
operator|=
name|QByteArray
argument_list|(
name|parseData
operator|->
name|userInfo
argument_list|,
name|parseData
operator|->
name|userInfoLength
argument_list|)
expr_stmt|;
name|encodedPassword
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|encodedUserName
operator|=
name|QByteArray
argument_list|(
name|parseData
operator|->
name|userInfo
argument_list|,
name|parseData
operator|->
name|userInfoDelimIndex
argument_list|)
expr_stmt|;
name|encodedPassword
operator|=
name|QByteArray
argument_list|(
name|parseData
operator|->
name|userInfo
operator|+
name|parseData
operator|->
name|userInfoDelimIndex
operator|+
literal|1
argument_list|,
name|parseData
operator|->
name|userInfoLength
operator|-
name|parseData
operator|->
name|userInfoDelimIndex
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|userInfo
name|QString
name|QUrlPrivate
operator|::
name|userInfo
parameter_list|(
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveUserInfo
operator|)
operator|==
name|QUrl
operator|::
name|RemoveUserInfo
condition|)
return|return
name|QString
argument_list|()
return|;
name|QUrlPrivate
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QUrlPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|userName
operator|.
name|isNull
argument_list|()
condition|)
name|that
operator|->
name|userName
operator|=
name|fromPercentEncodingHelper
argument_list|(
name|encodedUserName
argument_list|)
expr_stmt|;
if|if
condition|(
name|password
operator|.
name|isNull
argument_list|()
condition|)
name|that
operator|->
name|password
operator|=
name|fromPercentEncodingHelper
argument_list|(
name|encodedPassword
argument_list|)
expr_stmt|;
name|QString
name|tmp
init|=
name|userName
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemovePassword
operator|)
operator|&&
operator|!
name|password
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|tmp
operator|+=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|tmp
operator|+=
name|password
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function
begin_comment
comment|/*     From http://www.ietf.org/rfc/rfc3986.txt, 5.2.3: Merge paths      Returns a merge of the current path with the relative path passed     as argument. */
end_comment
begin_function
DECL|function|mergePaths
name|QByteArray
name|QUrlPrivate
operator|::
name|mergePaths
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|relativePath
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|encodedPath
operator|.
name|isNull
argument_list|()
condition|)
name|ensureEncodedParts
argument_list|()
expr_stmt|;
comment|// If the base URI has a defined authority component and an empty
comment|// path, then return a string consisting of "/" concatenated with
comment|// the reference's path; otherwise,
if|if
condition|(
operator|!
name|authority
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|encodedPath
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|'/'
operator|+
name|relativePath
return|;
comment|// Return a string consisting of the reference's path component
comment|// appended to all but the last segment of the base URI's path
comment|// (i.e., excluding any characters after the right-most "/" in the
comment|// base URI path, or excluding the entire base URI path if it does
comment|// not contain any "/" characters).
name|QByteArray
name|newPath
decl_stmt|;
if|if
condition|(
operator|!
name|encodedPath
operator|.
name|contains
argument_list|(
literal|'/'
argument_list|)
condition|)
name|newPath
operator|=
name|relativePath
expr_stmt|;
else|else
name|newPath
operator|=
name|encodedPath
operator|.
name|left
argument_list|(
name|encodedPath
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
operator|+
name|relativePath
expr_stmt|;
return|return
name|newPath
return|;
block|}
end_function
begin_function
DECL|function|queryItem
name|void
name|QUrlPrivate
operator|::
name|queryItem
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|end
parameter_list|)
block|{
operator|*
name|end
operator|=
name|query
operator|.
name|indexOf
argument_list|(
name|pairDelimiter
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
operator|-
literal|1
condition|)
operator|*
name|end
operator|=
name|query
operator|.
name|size
argument_list|()
expr_stmt|;
operator|*
name|value
operator|=
name|pos
expr_stmt|;
while|while
condition|(
operator|*
name|value
operator|<
operator|*
name|end
condition|)
block|{
if|if
condition|(
name|query
index|[
operator|*
name|value
index|]
operator|==
name|valueDelimiter
condition|)
break|break;
operator|++
operator|*
name|value
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*     From http://www.ietf.org/rfc/rfc3986.txt, 5.2.4: Remove dot segments      Removes unnecessary ../ and ./ from the path. Used for normalizing     the URL. */
end_comment
begin_function
DECL|function|removeDotsFromPath
specifier|static
name|void
name|removeDotsFromPath
parameter_list|(
name|QByteArray
modifier|*
name|path
parameter_list|)
block|{
comment|// The input buffer is initialized with the now-appended path
comment|// components and the output buffer is initialized to the empty
comment|// string.
name|char
modifier|*
name|out
init|=
name|path
operator|->
name|data
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|in
init|=
name|out
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|out
operator|+
name|path
operator|->
name|size
argument_list|()
decl_stmt|;
comment|// If the input buffer consists only of
comment|// "." or "..", then remove that from the input
comment|// buffer;
if|if
condition|(
name|path
operator|->
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|in
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
operator|++
name|in
expr_stmt|;
elseif|else
if|if
condition|(
name|path
operator|->
name|size
argument_list|()
operator|==
literal|2
operator|&&
name|in
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
name|in
operator|+=
literal|2
expr_stmt|;
comment|// While the input buffer is not empty, loop:
while|while
condition|(
name|in
operator|<
name|end
condition|)
block|{
comment|// otherwise, if the input buffer begins with a prefix of "../" or "./",
comment|// then remove that prefix from the input buffer;
if|if
condition|(
name|path
operator|->
name|size
argument_list|()
operator|>=
literal|2
operator|&&
name|in
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|in
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|path
operator|->
name|size
argument_list|()
operator|>=
literal|3
operator|&&
name|in
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
name|in
operator|+=
literal|3
expr_stmt|;
comment|// otherwise, if the input buffer begins with a prefix of
comment|// "/./" or "/.", where "." is a complete path segment,
comment|// then replace that prefix with "/" in the input buffer;
if|if
condition|(
name|in
operator|<=
name|end
operator|-
literal|3
operator|&&
name|in
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|in
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
name|in
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|in
operator|==
name|end
operator|-
literal|2
operator|&&
name|in
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|in
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
operator|*
name|out
operator|++
operator|=
literal|'/'
expr_stmt|;
name|in
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
comment|// otherwise, if the input buffer begins with a prefix
comment|// of "/../" or "/..", where ".." is a complete path
comment|// segment, then replace that prefix with "/" in the
comment|// input buffer and remove the last //segment and its
comment|// preceding "/" (if any) from the output buffer;
if|if
condition|(
name|in
operator|<=
name|end
operator|-
literal|4
operator|&&
name|in
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|in
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|3
index|]
operator|==
literal|'/'
condition|)
block|{
while|while
condition|(
name|out
operator|>
name|path
operator|->
name|constData
argument_list|()
operator|&&
operator|*
operator|(
operator|--
name|out
operator|)
operator|!=
literal|'/'
condition|)
empty_stmt|;
if|if
condition|(
name|out
operator|==
name|path
operator|->
name|constData
argument_list|()
operator|&&
operator|*
name|out
operator|!=
literal|'/'
condition|)
operator|++
name|in
expr_stmt|;
name|in
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|in
operator|==
name|end
operator|-
literal|3
operator|&&
name|in
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|in
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|2
index|]
operator|==
literal|'.'
condition|)
block|{
while|while
condition|(
name|out
operator|>
name|path
operator|->
name|constData
argument_list|()
operator|&&
operator|*
operator|(
operator|--
name|out
operator|)
operator|!=
literal|'/'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|out
operator|==
literal|'/'
condition|)
operator|++
name|out
expr_stmt|;
name|in
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
comment|// otherwise move the first path segment in
comment|// the input buffer to the end of the output
comment|// buffer, including the initial "/" character
comment|// (if any) and any subsequent characters up
comment|// to, but not including, the next "/"
comment|// character or the end of the input buffer.
operator|*
name|out
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
while|while
condition|(
name|in
operator|<
name|end
operator|&&
operator|*
name|in
operator|!=
literal|'/'
condition|)
operator|*
name|out
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
block|}
name|path
operator|->
name|truncate
argument_list|(
name|out
operator|-
name|path
operator|->
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|validate
name|void
name|QUrlPrivate
operator|::
name|validate
parameter_list|()
specifier|const
block|{
name|QUrlPrivate
modifier|*
name|that
init|=
operator|(
name|QUrlPrivate
operator|*
operator|)
name|this
decl_stmt|;
name|that
operator|->
name|encodedOriginal
operator|=
name|that
operator|->
name|toEncoded
argument_list|()
expr_stmt|;
comment|// may detach
name|parse
argument_list|(
name|ParseOnly
argument_list|)
expr_stmt|;
name|QURL_SETFLAG
argument_list|(
name|that
operator|->
name|stateFlags
argument_list|,
name|Validated
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
condition|)
return|return;
name|QString
name|auth
init|=
name|authority
argument_list|()
decl_stmt|;
comment|// causes the non-encoded forms to be valid
comment|// authority() calls canonicalHost() which sets this
if|if
condition|(
operator|!
name|isHostValid
condition|)
return|return;
if|if
condition|(
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"mailto"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|host
operator|.
name|isEmpty
argument_list|()
operator|||
name|port
operator|!=
operator|-
literal|1
operator|||
operator|!
name|userName
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|password
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|that
operator|->
name|isValid
operator|=
literal|false
expr_stmt|;
name|that
operator|->
name|errorInfo
operator|.
name|setParams
argument_list|(
literal|0
argument_list|,
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|"expected empty host, username,"
literal|"port and password"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"ftp"
argument_list|)
operator|||
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"http"
argument_list|)
condition|)
block|{
if|if
condition|(
name|host
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
operator|(
name|path
operator|.
name|isEmpty
argument_list|()
operator|&&
name|encodedPath
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|that
operator|->
name|isValid
operator|=
literal|false
expr_stmt|;
name|that
operator|->
name|errorInfo
operator|.
name|setParams
argument_list|(
literal|0
argument_list|,
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|"the host is empty, but not the path"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|parse
name|void
name|QUrlPrivate
operator|::
name|parse
parameter_list|(
name|ParseOptions
name|parseOptions
parameter_list|)
specifier|const
block|{
name|QUrlPrivate
modifier|*
name|that
init|=
operator|(
name|QUrlPrivate
operator|*
operator|)
name|this
decl_stmt|;
name|that
operator|->
name|errorInfo
operator|.
name|setParams
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|encodedOriginal
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|that
operator|->
name|isValid
operator|=
literal|false
expr_stmt|;
name|that
operator|->
name|errorInfo
operator|.
name|setParams
argument_list|(
literal|0
argument_list|,
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|"empty"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QURL_SETFLAG
argument_list|(
name|that
operator|->
name|stateFlags
argument_list|,
name|Validated
operator||
name|Parsed
argument_list|)
expr_stmt|;
return|return;
block|}
name|QUrlParseData
name|parseData
decl_stmt|;
name|memset
argument_list|(
operator|&
name|parseData
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|parseData
argument_list|)
argument_list|)
expr_stmt|;
name|parseData
operator|.
name|userInfoDelimIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|parseData
operator|.
name|port
operator|=
operator|-
literal|1
expr_stmt|;
name|parseData
operator|.
name|errorInfo
operator|=
operator|&
name|that
operator|->
name|errorInfo
expr_stmt|;
specifier|const
name|char
modifier|*
name|pptr
init|=
operator|(
name|char
operator|*
operator|)
name|encodedOriginal
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|qt_urlParse
argument_list|(
name|pptr
argument_list|,
name|parseData
argument_list|)
condition|)
block|{
name|that
operator|->
name|isValid
operator|=
literal|false
expr_stmt|;
name|QURL_SETFLAG
argument_list|(
name|that
operator|->
name|stateFlags
argument_list|,
name|Validated
operator||
name|Parsed
argument_list|)
expr_stmt|;
return|return;
block|}
name|that
operator|->
name|hasQuery
operator|=
name|parseData
operator|.
name|query
expr_stmt|;
name|that
operator|->
name|hasFragment
operator|=
name|parseData
operator|.
name|fragment
expr_stmt|;
comment|// when doing lazy validation, this function is called after
comment|// encodedOriginal has been constructed from the individual parts,
comment|// only to see if the constructed URL can be parsed. in that case,
comment|// parse() is called in ParseOnly mode; we don't want to set all
comment|// the members over again.
if|if
condition|(
name|parseOptions
operator|==
name|ParseAndSet
condition|)
block|{
name|QURL_UNSETFLAG
argument_list|(
name|that
operator|->
name|stateFlags
argument_list|,
name|HostCanonicalized
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseData
operator|.
name|scheme
condition|)
block|{
name|QByteArray
name|s
argument_list|(
name|parseData
operator|.
name|scheme
argument_list|,
name|parseData
operator|.
name|schemeLength
argument_list|)
decl_stmt|;
name|that
operator|->
name|scheme
operator|=
name|fromPercentEncodingMutable
argument_list|(
operator|&
name|s
argument_list|)
operator|.
name|toLower
argument_list|()
expr_stmt|;
block|}
name|that
operator|->
name|setEncodedUserInfo
argument_list|(
operator|&
name|parseData
argument_list|)
expr_stmt|;
name|QByteArray
name|h
argument_list|(
name|parseData
operator|.
name|host
argument_list|,
name|parseData
operator|.
name|hostLength
argument_list|)
decl_stmt|;
name|that
operator|->
name|host
operator|=
name|fromPercentEncodingMutable
argument_list|(
operator|&
name|h
argument_list|)
expr_stmt|;
name|that
operator|->
name|port
operator|=
name|parseData
operator|.
name|port
expr_stmt|;
name|that
operator|->
name|path
operator|.
name|clear
argument_list|()
expr_stmt|;
name|that
operator|->
name|encodedPath
operator|=
name|QByteArray
argument_list|(
name|parseData
operator|.
name|path
argument_list|,
name|parseData
operator|.
name|pathLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|that
operator|->
name|hasQuery
condition|)
name|that
operator|->
name|query
operator|=
name|QByteArray
argument_list|(
name|parseData
operator|.
name|query
argument_list|,
name|parseData
operator|.
name|queryLength
argument_list|)
expr_stmt|;
else|else
name|that
operator|->
name|query
operator|.
name|clear
argument_list|()
expr_stmt|;
name|that
operator|->
name|fragment
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|that
operator|->
name|hasFragment
condition|)
block|{
name|that
operator|->
name|encodedFragment
operator|=
name|QByteArray
argument_list|(
name|parseData
operator|.
name|fragment
argument_list|,
name|parseData
operator|.
name|fragmentLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|that
operator|->
name|encodedFragment
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
name|that
operator|->
name|isValid
operator|=
literal|true
expr_stmt|;
name|QURL_SETFLAG
argument_list|(
name|that
operator|->
name|stateFlags
argument_list|,
name|Parsed
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QURL_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QUrl::setUrl(), scheme = %s"
argument_list|,
name|that
operator|->
name|scheme
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"QUrl::setUrl(), userInfo = %s"
argument_list|,
name|that
operator|->
name|userInfo
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"QUrl::setUrl(), host = %s"
argument_list|,
name|that
operator|->
name|host
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"QUrl::setUrl(), port = %i"
argument_list|,
name|that
operator|->
name|port
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"QUrl::setUrl(), path = %s"
argument_list|,
name|fromPercentEncodingHelper
argument_list|(
name|__path
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"QUrl::setUrl(), query = %s"
argument_list|,
name|__query
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"QUrl::setUrl(), fragment = %s"
argument_list|,
name|fromPercentEncodingHelper
argument_list|(
name|__fragment
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|clear
name|void
name|QUrlPrivate
operator|::
name|clear
parameter_list|()
block|{
name|scheme
operator|.
name|clear
argument_list|()
expr_stmt|;
name|userName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|password
operator|.
name|clear
argument_list|()
expr_stmt|;
name|host
operator|.
name|clear
argument_list|()
expr_stmt|;
name|port
operator|=
operator|-
literal|1
expr_stmt|;
name|path
operator|.
name|clear
argument_list|()
expr_stmt|;
name|query
operator|.
name|clear
argument_list|()
expr_stmt|;
name|fragment
operator|.
name|clear
argument_list|()
expr_stmt|;
name|encodedOriginal
operator|.
name|clear
argument_list|()
expr_stmt|;
name|encodedUserName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|encodedPassword
operator|.
name|clear
argument_list|()
expr_stmt|;
name|encodedPath
operator|.
name|clear
argument_list|()
expr_stmt|;
name|encodedFragment
operator|.
name|clear
argument_list|()
expr_stmt|;
name|encodedNormalized
operator|.
name|clear
argument_list|()
expr_stmt|;
name|isValid
operator|=
literal|false
expr_stmt|;
name|hasQuery
operator|=
literal|false
expr_stmt|;
name|hasFragment
operator|=
literal|false
expr_stmt|;
name|valueDelimiter
operator|=
literal|'='
expr_stmt|;
name|pairDelimiter
operator|=
literal|'&'
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|stateFlags
argument_list|,
name|Parsed
operator||
name|Validated
operator||
name|Normalized
operator||
name|HostCanonicalized
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|toEncoded
name|QByteArray
name|QUrlPrivate
operator|::
name|toEncoded
parameter_list|(
name|QUrl
operator|::
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|stateFlags
argument_list|,
name|Parsed
argument_list|)
condition|)
name|parse
argument_list|()
expr_stmt|;
else|else
name|ensureEncodedParts
argument_list|()
expr_stmt|;
if|if
condition|(
name|options
operator|==
literal|0x100
condition|)
comment|// private - see qHash(QUrl)
return|return
name|normalized
argument_list|()
return|;
if|if
condition|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|PreferLocalFile
operator|)
operator|&&
name|isLocalFile
argument_list|()
operator|&&
operator|!
name|hasQuery
operator|&&
operator|!
name|hasFragment
condition|)
return|return
name|encodedPath
return|;
name|QByteArray
name|url
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveScheme
operator|)
operator|&&
operator|!
name|scheme
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|url
operator|+=
name|scheme
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|url
operator|+=
literal|':'
expr_stmt|;
block|}
name|QString
name|savedHost
init|=
name|host
decl_stmt|;
comment|// pre-validation, may be invalid!
name|QString
name|auth
init|=
name|authority
argument_list|()
decl_stmt|;
name|bool
name|doFileScheme
init|=
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"file"
argument_list|)
operator|&&
name|encodedPath
operator|.
name|startsWith
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveAuthority
operator|)
operator|!=
name|QUrl
operator|::
name|RemoveAuthority
operator|&&
operator|(
operator|!
name|auth
operator|.
name|isEmpty
argument_list|()
operator|||
name|doFileScheme
operator|||
operator|!
name|savedHost
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|doFileScheme
operator|&&
operator|!
name|encodedPath
operator|.
name|startsWith
argument_list|(
literal|'/'
argument_list|)
condition|)
name|url
operator|+=
literal|'/'
expr_stmt|;
name|url
operator|+=
literal|"//"
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveUserInfo
operator|)
operator|!=
name|QUrl
operator|::
name|RemoveUserInfo
condition|)
block|{
name|bool
name|hasUserOrPass
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|userName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|url
operator|+=
name|encodedUserName
expr_stmt|;
name|hasUserOrPass
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemovePassword
operator|)
operator|&&
operator|!
name|password
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|url
operator|+=
literal|':'
expr_stmt|;
name|url
operator|+=
name|encodedPassword
expr_stmt|;
name|hasUserOrPass
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|hasUserOrPass
condition|)
name|url
operator|+=
literal|'@'
expr_stmt|;
block|}
if|if
condition|(
name|host
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
argument_list|)
condition|)
block|{
name|url
operator|+=
name|host
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|host
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
block|{
name|url
operator|+=
literal|'['
expr_stmt|;
name|url
operator|+=
name|host
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|url
operator|+=
literal|']'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|host
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|savedHost
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// this case is only possible with an invalid URL
comment|// it's here only so that we can keep the original, invalid hostname
comment|// in encodedOriginal.
comment|// QUrl::isValid() will return false, so toEncoded() can be anything (it's not valid)
name|url
operator|+=
name|savedHost
operator|.
name|toUtf8
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|url
operator|+=
name|qt_ACE_do
argument_list|(
name|host
argument_list|,
name|ToAceOnly
argument_list|)
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemovePort
operator|)
operator|&&
name|port
operator|!=
operator|-
literal|1
condition|)
block|{
name|url
operator|+=
literal|':'
expr_stmt|;
name|url
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|port
argument_list|)
operator|.
name|toAscii
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemovePath
operator|)
condition|)
block|{
comment|// check if we need to insert a slash
if|if
condition|(
operator|!
name|encodedPath
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|auth
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|encodedPath
operator|.
name|startsWith
argument_list|(
literal|'/'
argument_list|)
condition|)
name|url
operator|+=
literal|'/'
expr_stmt|;
block|}
name|url
operator|+=
name|encodedPath
expr_stmt|;
comment|// check if we need to remove trailing slashes
while|while
condition|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|StripTrailingSlash
operator|)
operator|&&
name|url
operator|.
name|endsWith
argument_list|(
literal|'/'
argument_list|)
condition|)
name|url
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveQuery
operator|)
operator|&&
name|hasQuery
condition|)
block|{
name|url
operator|+=
literal|'?'
expr_stmt|;
name|url
operator|+=
name|query
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveFragment
operator|)
operator|&&
name|hasFragment
condition|)
block|{
name|url
operator|+=
literal|'#'
expr_stmt|;
name|url
operator|+=
name|encodedFragment
expr_stmt|;
block|}
return|return
name|url
return|;
block|}
end_function
begin_define
DECL|macro|qToLower
define|#
directive|define
name|qToLower
parameter_list|(
name|ch
parameter_list|)
value|(((ch|32)>= 'a'&& (ch|32)<= 'z') ? (ch|32) : ch)
end_define
begin_function
DECL|function|normalized
specifier|const
name|QByteArray
modifier|&
name|QUrlPrivate
operator|::
name|normalized
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QURL_HASFLAG
argument_list|(
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Normalized
argument_list|)
condition|)
return|return
name|encodedNormalized
return|;
name|QUrlPrivate
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QUrlPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QURL_SETFLAG
argument_list|(
name|that
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Normalized
argument_list|)
expr_stmt|;
name|QUrlPrivate
name|tmp
init|=
operator|*
name|this
decl_stmt|;
name|tmp
operator|.
name|host
operator|=
name|tmp
operator|.
name|canonicalHost
argument_list|()
expr_stmt|;
comment|// ensure the encoded and normalized parts of the URL
name|tmp
operator|.
name|ensureEncodedParts
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|encodedUserName
operator|.
name|contains
argument_list|(
literal|'%'
argument_list|)
condition|)
name|q_normalizePercentEncoding
argument_list|(
operator|&
name|tmp
operator|.
name|encodedUserName
argument_list|,
name|userNameExcludeChars
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|encodedPassword
operator|.
name|contains
argument_list|(
literal|'%'
argument_list|)
condition|)
name|q_normalizePercentEncoding
argument_list|(
operator|&
name|tmp
operator|.
name|encodedPassword
argument_list|,
name|passwordExcludeChars
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|encodedFragment
operator|.
name|contains
argument_list|(
literal|'%'
argument_list|)
condition|)
name|q_normalizePercentEncoding
argument_list|(
operator|&
name|tmp
operator|.
name|encodedFragment
argument_list|,
name|fragmentExcludeChars
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|encodedPath
operator|.
name|contains
argument_list|(
literal|'%'
argument_list|)
condition|)
block|{
comment|// the path is a bit special:
comment|// the slashes shouldn't be encoded or decoded.
comment|// They should remain exactly like they are right now
comment|//
comment|// treat the path as a slash-separated sequence of pchar
name|QByteArray
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|tmp
operator|.
name|encodedPath
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|encodedPath
operator|.
name|startsWith
argument_list|(
literal|'/'
argument_list|)
condition|)
name|result
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|data
init|=
name|tmp
operator|.
name|encodedPath
operator|.
name|constData
argument_list|()
decl_stmt|;
name|int
name|lastSlash
init|=
literal|0
decl_stmt|;
name|int
name|nextSlash
decl_stmt|;
do|do
block|{
operator|++
name|lastSlash
expr_stmt|;
name|nextSlash
operator|=
name|tmp
operator|.
name|encodedPath
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|,
name|lastSlash
argument_list|)
expr_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|nextSlash
operator|==
operator|-
literal|1
condition|)
name|len
operator|=
name|tmp
operator|.
name|encodedPath
operator|.
name|length
argument_list|()
operator|-
name|lastSlash
expr_stmt|;
else|else
name|len
operator|=
name|nextSlash
operator|-
name|lastSlash
expr_stmt|;
if|if
condition|(
name|memchr
argument_list|(
name|data
operator|+
name|lastSlash
argument_list|,
literal|'%'
argument_list|,
name|len
argument_list|)
condition|)
block|{
comment|// there's at least one percent before the next slash
name|QByteArray
name|block
init|=
name|QByteArray
argument_list|(
name|data
operator|+
name|lastSlash
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|q_normalizePercentEncoding
argument_list|(
operator|&
name|block
argument_list|,
name|pathExcludeChars
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// no percents in this path segment, append wholesale
name|result
operator|.
name|append
argument_list|(
name|data
operator|+
name|lastSlash
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|// append the slash too, if it's there
if|if
condition|(
name|nextSlash
operator|!=
operator|-
literal|1
condition|)
name|result
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|lastSlash
operator|=
name|nextSlash
expr_stmt|;
block|}
do|while
condition|(
name|lastSlash
operator|!=
operator|-
literal|1
condition|)
do|;
name|tmp
operator|.
name|encodedPath
operator|=
name|result
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmp
operator|.
name|scheme
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// relative test
name|removeDotsFromPath
argument_list|(
operator|&
name|tmp
operator|.
name|encodedPath
argument_list|)
expr_stmt|;
name|int
name|qLen
init|=
name|tmp
operator|.
name|query
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|qLen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qLen
operator|-
name|i
operator|>
literal|2
operator|&&
name|tmp
operator|.
name|query
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
literal|'%'
condition|)
block|{
operator|++
name|i
expr_stmt|;
name|tmp
operator|.
name|query
index|[
name|i
index|]
operator|=
name|qToLower
argument_list|(
name|tmp
operator|.
name|query
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|tmp
operator|.
name|query
index|[
name|i
index|]
operator|=
name|qToLower
argument_list|(
name|tmp
operator|.
name|query
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|encodedNormalized
operator|=
name|tmp
operator|.
name|toEncoded
argument_list|()
expr_stmt|;
return|return
name|encodedNormalized
return|;
block|}
end_function
begin_function
DECL|function|createErrorString
name|QString
name|QUrlPrivate
operator|::
name|createErrorString
parameter_list|()
block|{
if|if
condition|(
name|isValid
operator|&&
name|isHostValid
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|errorString
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|"Invalid URL \""
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|errorString
operator|+=
name|QLatin1String
argument_list|(
name|encodedOriginal
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|errorString
operator|+=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|"\""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorInfo
operator|.
name|_source
condition|)
block|{
name|int
name|position
init|=
name|encodedOriginal
operator|.
name|indexOf
argument_list|(
name|errorInfo
operator|.
name|_source
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|position
operator|>
literal|0
condition|)
block|{
name|errorString
operator|+=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|": error at position "
argument_list|)
argument_list|)
expr_stmt|;
name|errorString
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|position
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errorString
operator|+=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|": "
argument_list|)
argument_list|)
expr_stmt|;
name|errorString
operator|+=
name|QLatin1String
argument_list|(
name|errorInfo
operator|.
name|_source
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errorInfo
operator|.
name|_expected
condition|)
block|{
name|errorString
operator|+=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|": expected \'"
argument_list|)
argument_list|)
expr_stmt|;
name|errorString
operator|+=
name|QLatin1Char
argument_list|(
name|errorInfo
operator|.
name|_expected
argument_list|)
expr_stmt|;
name|errorString
operator|+=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|"\'"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errorString
operator|+=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|": "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isHostValid
condition|)
name|errorString
operator|+=
name|QLatin1String
argument_list|(
name|errorInfo
operator|.
name|_message
argument_list|)
expr_stmt|;
else|else
name|errorString
operator|+=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|"invalid hostname"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errorInfo
operator|.
name|_found
condition|)
block|{
name|errorString
operator|+=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|", but found \'"
argument_list|)
argument_list|)
expr_stmt|;
name|errorString
operator|+=
name|QLatin1Char
argument_list|(
name|errorInfo
operator|.
name|_found
argument_list|)
expr_stmt|;
name|errorString
operator|+=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|"\'"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|errorString
return|;
block|}
end_function
begin_comment
comment|/*!     \macro QT_NO_URL_CAST_FROM_STRING     \relates QUrl      Disables automatic conversions from QString (or char *) to QUrl.      Compiling your code with this define is useful when you have a lot of     code that uses QString for file names and you wish to convert it to     use QUrl for network transparency. In any code that uses QUrl, it can     help avoid missing QUrl::resolved() calls, and other misuses of     QString to QUrl conversions.      \oldcode         url = filename; // probably not what you want     \newcode         url = QUrl::fromLocalFile(filename);         url = baseurl.resolved(QUrl(filename));     \endcode      \sa QT_NO_CAST_FROM_ASCII */
end_comment
begin_comment
comment|/*!     Constructs a URL by parsing \a url. \a url is assumed to be in human     readable representation, with no percent encoding. QUrl will automatically     percent encode all characters that are not allowed in a URL.     The default parsing mode is TolerantMode.      The parsing mode \a parsingMode is used for parsing \a url.      Example:      \snippet doc/src/snippets/code/src_corelib_io_qurl.cpp 0      \sa setUrl(), TolerantMode */
end_comment
begin_constructor
DECL|function|QUrl
name|QUrl
operator|::
name|QUrl
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
name|ParsingMode
name|parsingMode
parameter_list|)
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
operator|!
name|url
operator|.
name|isEmpty
argument_list|()
condition|)
name|setUrl
argument_list|(
name|url
argument_list|,
name|parsingMode
argument_list|)
expr_stmt|;
else|else
block|{
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
name|d
operator|->
name|parsingMode
operator|=
name|parsingMode
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Constructs an empty QUrl object. */
end_comment
begin_constructor
DECL|function|QUrl
name|QUrl
operator|::
name|QUrl
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a other. */
end_comment
begin_constructor
DECL|function|QUrl
name|QUrl
operator|::
name|QUrl
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Destructor; called immediately before the object is deleted. */
end_comment
begin_destructor
DECL|function|~QUrl
name|QUrl
operator|::
name|~
name|QUrl
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns true if the URL is valid; otherwise returns false.      The URL is run through a conformance test. Every part of the URL     must conform to the standard encoding rules of the URI standard     for the URL to be reported as valid.      \snippet doc/src/snippets/code/src_corelib_io_qurl.cpp 2 */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QUrl
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
argument_list|)
condition|)
name|d
operator|->
name|validate
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|isValid
operator|&&
name|d
operator|->
name|isHostValid
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the URL has no data; otherwise returns false. */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QUrl
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
return|return
name|d
operator|->
name|encodedOriginal
operator|.
name|isEmpty
argument_list|()
return|;
else|else
return|return
name|d
operator|->
name|scheme
operator|.
name|isEmpty
argument_list|()
comment|// no encodedScheme
operator|&&
name|d
operator|->
name|userName
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|encodedUserName
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|password
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|encodedPassword
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|host
operator|.
name|isEmpty
argument_list|()
comment|// no encodedHost
operator|&&
name|d
operator|->
name|port
operator|==
operator|-
literal|1
operator|&&
name|d
operator|->
name|path
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|encodedPath
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|query
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|fragment
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|encodedFragment
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Resets the content of the QUrl. After calling this function, the     QUrl is equal to one that has been constructed with the default     empty constructor. */
end_comment
begin_function
DECL|function|clear
name|void
name|QUrl
operator|::
name|clear
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs a URL by parsing the contents of \a url.      \a url is assumed to be in unicode format, and encoded,     such as URLs produced by url().      The parsing mode \a parsingMode is used for parsing \a url.      Calling isValid() will tell whether or not a valid URL was     constructed.      \sa setEncodedUrl() */
end_comment
begin_function
DECL|function|setUrl
name|void
name|QUrl
operator|::
name|setUrl
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|,
name|ParsingMode
name|parsingMode
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|setEncodedUrl
argument_list|(
name|url
operator|.
name|toUtf8
argument_list|()
argument_list|,
name|parsingMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|isValid
argument_list|()
operator|||
name|parsingMode
operator|==
name|StrictMode
condition|)
return|return;
comment|// Tolerant preprocessing
name|QString
name|tmp
init|=
name|url
decl_stmt|;
comment|// Allow %20 in the QString variant
name|tmp
operator|.
name|replace
argument_list|(
name|QLatin1String
argument_list|(
literal|"%20"
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
comment|// Percent-encode unsafe ASCII characters after host part
name|int
name|start
init|=
name|tmp
operator|.
name|indexOf
argument_list|(
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Has host part, find delimiter
name|start
operator|+=
literal|2
expr_stmt|;
comment|// skip "//"
specifier|const
name|char
name|delims
index|[]
init|=
literal|"/#?"
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
init|=
name|delims
decl_stmt|;
name|int
name|hostEnd
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|d
operator|&&
operator|(
name|hostEnd
operator|=
name|tmp
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
operator|*
name|d
argument_list|)
argument_list|,
name|start
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
operator|++
name|d
expr_stmt|;
name|start
operator|=
operator|(
name|hostEnd
operator|==
operator|-
literal|1
operator|)
condition|?
operator|-
literal|1
else|:
name|hostEnd
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
literal|0
expr_stmt|;
comment|// Has no host part
block|}
name|QByteArray
name|encodedUrl
decl_stmt|;
if|if
condition|(
name|start
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|hostPart
init|=
name|tmp
operator|.
name|left
argument_list|(
name|start
argument_list|)
decl_stmt|;
name|QString
name|otherPart
init|=
name|tmp
operator|.
name|mid
argument_list|(
name|start
argument_list|)
decl_stmt|;
name|encodedUrl
operator|=
name|toPercentEncodingHelper
argument_list|(
name|hostPart
argument_list|,
literal|":/?#[]@!$&'()*+,;="
argument_list|)
operator|+
name|toPercentEncodingHelper
argument_list|(
name|otherPart
argument_list|,
literal|":/?#@!$&'()*+,;="
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|encodedUrl
operator|=
name|toPercentEncodingHelper
argument_list|(
name|tmp
argument_list|,
name|ABNF_reserved
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|setEncodedUrl
argument_list|(
name|encodedUrl
argument_list|,
name|StrictMode
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isHex
specifier|inline
specifier|static
name|bool
name|isHex
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|c
operator||=
literal|0x20
expr_stmt|;
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|toHex
specifier|static
specifier|inline
name|char
name|toHex
parameter_list|(
name|quint8
name|c
parameter_list|)
block|{
return|return
name|c
operator|>
literal|9
condition|?
name|c
operator|-
literal|10
operator|+
literal|'A'
else|:
name|c
operator|+
literal|'0'
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QUrl::setEncodedUrl(const QByteArray&encodedUrl, ParsingMode parsingMode)     Constructs a URL by parsing the contents of \a encodedUrl.      \a encodedUrl is assumed to be a URL string in percent encoded     form, containing only ASCII characters.      The parsing mode \a parsingMode is used for parsing \a encodedUrl.      \obsolete Use setUrl(QString::fromUtf8(encodedUrl), parsingMode)      \sa setUrl() */
end_comment
begin_function
DECL|function|setEncodedUrl
name|void
name|QUrlPrivate
operator|::
name|setEncodedUrl
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|encodedUrl
parameter_list|,
name|QUrl
operator|::
name|ParsingMode
name|mode
parameter_list|)
block|{
name|QByteArray
name|tmp
init|=
name|encodedUrl
decl_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|parsingMode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|parsingMode
operator|==
name|QUrl
operator|::
name|TolerantMode
condition|)
block|{
comment|// Replace stray % with %25
name|QByteArray
name|copy
init|=
name|tmp
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|i
operator|<
name|copy
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
operator|,
operator|++
name|j
control|)
block|{
if|if
condition|(
name|copy
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|2
operator|>=
name|copy
operator|.
name|size
argument_list|()
operator|||
operator|!
name|isHex
argument_list|(
name|copy
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
operator|||
operator|!
name|isHex
argument_list|(
name|copy
operator|.
name|at
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|replace
argument_list|(
name|j
argument_list|,
literal|1
argument_list|,
literal|"%25"
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
comment|// Find the host part
name|int
name|hostStart
init|=
name|tmp
operator|.
name|indexOf
argument_list|(
literal|"//"
argument_list|)
decl_stmt|;
name|int
name|hostEnd
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|hostStart
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Has host part, find delimiter
name|hostStart
operator|+=
literal|2
expr_stmt|;
comment|// skip "//"
name|hostEnd
operator|=
name|tmp
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|,
name|hostStart
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostEnd
operator|==
operator|-
literal|1
condition|)
name|hostEnd
operator|=
name|tmp
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|,
name|hostStart
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostEnd
operator|==
operator|-
literal|1
condition|)
name|hostEnd
operator|=
name|tmp
operator|.
name|indexOf
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostEnd
operator|==
operator|-
literal|1
condition|)
name|hostEnd
operator|=
name|tmp
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
comment|// Reserved and unreserved characters are fine
comment|//         unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
comment|//         reserved      = gen-delims / sub-delims
comment|//         gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
comment|//         sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
comment|//                         / "*" / "+" / "," / ";" / "="
comment|// Replace everything else with percent encoding
specifier|static
specifier|const
name|char
name|doEncode
index|[]
init|=
literal|" \"<>[\\]^`{|}"
decl_stmt|;
specifier|static
specifier|const
name|char
name|doEncodeHost
index|[]
init|=
literal|" \"<>\\^`{|}"
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tmp
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|quint8
name|c
init|=
name|quint8
argument_list|(
name|tmp
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
argument_list|<
literal|32
operator|||
name|c
argument_list|>
literal|127
operator|||
name|strchr
argument_list|(
name|hostStart
operator|<=
name|i
operator|&&
name|i
operator|<=
name|hostEnd
condition|?
name|doEncodeHost
else|:
name|doEncode
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|toHex
argument_list|(
name|c
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|toHex
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tmp
operator|.
name|replace
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
name|encodedOriginal
operator|=
name|tmp
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the scheme of the URL to \a scheme. As a scheme can only     contain ASCII characters, no conversion or encoding is done on the     input.      The scheme describes the type (or protocol) of the URL. It's     represented by one or more ASCII characters at the start the URL,     and is followed by a ':'. The following example shows a URL where     the scheme is "ftp":      \img qurl-authority2.png      The scheme can also be empty, in which case the URL is interpreted     as relative.      \sa scheme(), isRelative() */
end_comment
begin_function
DECL|function|setScheme
name|void
name|QUrl
operator|::
name|setScheme
parameter_list|(
specifier|const
name|QString
modifier|&
name|scheme
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
operator||
name|QUrlPrivate
operator|::
name|Normalized
argument_list|)
expr_stmt|;
name|d
operator|->
name|scheme
operator|=
name|scheme
operator|.
name|toLower
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the scheme of the URL. If an empty string is returned,     this means the scheme is undefined and the URL is then relative.      The returned scheme is always lowercase, for convenience.      \sa setScheme(), isRelative() */
end_comment
begin_function
DECL|function|scheme
name|QString
name|QUrl
operator|::
name|scheme
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|scheme
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the authority of the URL to \a authority.      The authority of a URL is the combination of user info, a host     name and a port. All of these elements are optional; an empty     authority is therefore valid.      The user info and host are separated by a '@', and the host and     port are separated by a ':'. If the user info is empty, the '@'     must be omitted; although a stray ':' is permitted if the port is     empty.      The following example shows a valid authority string:      \img qurl-authority.png */
end_comment
begin_function
DECL|function|setAuthority
name|void
name|QUrl
operator|::
name|setAuthority
parameter_list|(
specifier|const
name|QString
modifier|&
name|authority
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
operator||
name|QUrlPrivate
operator|::
name|Normalized
operator||
name|QUrlPrivate
operator|::
name|HostCanonicalized
argument_list|)
expr_stmt|;
name|d
operator|->
name|setAuthority
argument_list|(
name|authority
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the authority of the URL if it is defined; otherwise     an empty string is returned.      \sa setAuthority() */
end_comment
begin_function
DECL|function|authority
name|QString
name|QUrl
operator|::
name|authority
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|authority
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the user info of the URL to \a userInfo. The user info is an     optional part of the authority of the URL, as described in     setAuthority().      The user info consists of a user name and optionally a password,     separated by a ':'. If the password is empty, the colon must be     omitted. The following example shows a valid user info string:      \img qurl-authority3.png      \sa userInfo(), setUserName(), setPassword(), setAuthority() */
end_comment
begin_function
DECL|function|setUserInfo
name|void
name|QUrl
operator|::
name|setUserInfo
parameter_list|(
specifier|const
name|QString
modifier|&
name|userInfo
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
operator||
name|QUrlPrivate
operator|::
name|Normalized
argument_list|)
expr_stmt|;
name|d
operator|->
name|setUserInfo
argument_list|(
name|userInfo
operator|.
name|trimmed
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the user info of the URL, or an empty string if the user     info is undefined. */
end_comment
begin_function
DECL|function|userInfo
name|QString
name|QUrl
operator|::
name|userInfo
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|userInfo
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the URL's user name to \a userName. The \a userName is part     of the user info element in the authority of the URL, as described     in setUserInfo().      \sa setEncodedUserName(), userName(), setUserInfo() */
end_comment
begin_function
DECL|function|setUserName
name|void
name|QUrl
operator|::
name|setUserName
parameter_list|(
specifier|const
name|QString
modifier|&
name|userName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
operator||
name|QUrlPrivate
operator|::
name|Normalized
argument_list|)
expr_stmt|;
name|d
operator|->
name|userName
operator|=
name|userName
expr_stmt|;
name|d
operator|->
name|encodedUserName
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the user name of the URL if it is defined; otherwise     an empty string is returned.      \sa setUserName(), encodedUserName() */
end_comment
begin_function
DECL|function|userName
name|QString
name|QUrl
operator|::
name|userName
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|d
operator|->
name|userInfo
argument_list|()
expr_stmt|;
comment|// causes the unencoded form to be set
return|return
name|d
operator|->
name|userName
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the URL's user name to the percent-encoded \a userName. The \a     userName is part of the user info element in the authority of the     URL, as described in setUserInfo().      Note: this function does not verify that \a userName is properly     encoded. It is the caller's responsibility to ensure that the any     delimiters (such as colons or slashes) are properly encoded.      \sa setUserName(), encodedUserName(), setUserInfo() */
end_comment
begin_function
DECL|function|setEncodedUserName
name|void
name|QUrl
operator|::
name|setEncodedUserName
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|userName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
operator||
name|QUrlPrivate
operator|::
name|Normalized
argument_list|)
expr_stmt|;
name|d
operator|->
name|encodedUserName
operator|=
name|userName
expr_stmt|;
name|d
operator|->
name|userName
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the user name of the URL if it is defined; otherwise     an empty string is returned. The returned value will have its     non-ASCII and other control characters percent-encoded, as in     toEncoded().      \sa setEncodedUserName() */
end_comment
begin_function
DECL|function|encodedUserName
name|QByteArray
name|QUrl
operator|::
name|encodedUserName
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QByteArray
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|d
operator|->
name|ensureEncodedParts
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|encodedUserName
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the URL's password to \a password. The \a password is part of     the user info element in the authority of the URL, as described in     setUserInfo().      \sa password(), setUserInfo() */
end_comment
begin_function
DECL|function|setPassword
name|void
name|QUrl
operator|::
name|setPassword
parameter_list|(
specifier|const
name|QString
modifier|&
name|password
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
operator||
name|QUrlPrivate
operator|::
name|Normalized
argument_list|)
expr_stmt|;
name|d
operator|->
name|password
operator|=
name|password
expr_stmt|;
name|d
operator|->
name|encodedPassword
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the password of the URL if it is defined; otherwise     an empty string is returned.      \sa setPassword() */
end_comment
begin_function
DECL|function|password
name|QString
name|QUrl
operator|::
name|password
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|d
operator|->
name|userInfo
argument_list|()
expr_stmt|;
comment|// causes the unencoded form to be set
return|return
name|d
operator|->
name|password
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the URL's password to the percent-encoded \a password. The \a     password is part of the user info element in the authority of the     URL, as described in setUserInfo().      Note: this function does not verify that \a password is properly     encoded. It is the caller's responsibility to ensure that the any     delimiters (such as colons or slashes) are properly encoded.      \sa setPassword(), encodedPassword(), setUserInfo() */
end_comment
begin_function
DECL|function|setEncodedPassword
name|void
name|QUrl
operator|::
name|setEncodedPassword
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|password
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
operator||
name|QUrlPrivate
operator|::
name|Normalized
argument_list|)
expr_stmt|;
name|d
operator|->
name|encodedPassword
operator|=
name|password
expr_stmt|;
name|d
operator|->
name|password
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the password of the URL if it is defined; otherwise an     empty string is returned. The returned value will have its     non-ASCII and other control characters percent-encoded, as in     toEncoded().      \sa setEncodedPassword(), toEncoded() */
end_comment
begin_function
DECL|function|encodedPassword
name|QByteArray
name|QUrl
operator|::
name|encodedPassword
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QByteArray
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|d
operator|->
name|ensureEncodedParts
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|encodedPassword
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the host of the URL to \a host. The host is part of the     authority.      \sa host(), setAuthority() */
end_comment
begin_function
DECL|function|setHost
name|void
name|QUrl
operator|::
name|setHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|host
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|isHostValid
operator|=
literal|true
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
operator||
name|QUrlPrivate
operator|::
name|Normalized
operator||
name|QUrlPrivate
operator|::
name|HostCanonicalized
argument_list|)
expr_stmt|;
name|d
operator|->
name|host
operator|=
name|host
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the host of the URL if it is defined; otherwise     an empty string is returned. */
end_comment
begin_function
DECL|function|host
name|QString
name|QUrl
operator|::
name|host
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|host
operator|.
name|isEmpty
argument_list|()
operator|||
name|d
operator|->
name|host
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
condition|)
return|return
name|d
operator|->
name|canonicalHost
argument_list|()
return|;
name|QString
name|tmp
init|=
name|d
operator|->
name|host
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|tmp
operator|.
name|truncate
argument_list|(
name|tmp
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the URL's host to the ACE- or percent-encoded \a host. The \a     host is part of the user info element in the authority of the     URL, as described in setAuthority().      \sa setHost(), encodedHost(), setAuthority(), fromAce() */
end_comment
begin_function
DECL|function|setEncodedHost
name|void
name|QUrl
operator|::
name|setEncodedHost
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|host
parameter_list|)
block|{
name|setHost
argument_list|(
name|fromPercentEncodingHelper
argument_list|(
name|host
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the host part of the URL if it is defined; otherwise     an empty string is returned.      Note: encodedHost() does not return percent-encoded hostnames. Instead,     the ACE-encoded (bare ASCII in Punycode encoding) form will be     returned for any non-ASCII hostname.      This function is equivalent to calling QUrl::toAce() on the return     value of host().      \sa setEncodedHost() */
end_comment
begin_function
DECL|function|encodedHost
name|QByteArray
name|QUrl
operator|::
name|encodedHost
parameter_list|()
specifier|const
block|{
comment|// should we cache this in d->encodedHost?
return|return
name|qt_ACE_do
argument_list|(
name|host
argument_list|()
argument_list|,
name|ToAceOnly
argument_list|)
operator|.
name|toLatin1
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the port of the URL to \a port. The port is part of the     authority of the URL, as described in setAuthority().      \a port must be between 0 and 65535 inclusive. Setting the     port to -1 indicates that the port is unspecified. */
end_comment
begin_function
DECL|function|setPort
name|void
name|QUrl
operator|::
name|setPort
parameter_list|(
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
operator||
name|QUrlPrivate
operator|::
name|Normalized
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
argument_list|<
operator|-
literal|1
operator|||
name|port
argument_list|>
literal|65535
condition|)
block|{
name|qWarning
argument_list|(
literal|"QUrl::setPort: Out of range"
argument_list|)
expr_stmt|;
name|port
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|d
operator|->
name|port
operator|=
name|port
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the port of the URL, or \a defaultPort if the port is     unspecified.      Example:      \snippet doc/src/snippets/code/src_corelib_io_qurl.cpp 3 */
end_comment
begin_function
DECL|function|port
name|int
name|QUrl
operator|::
name|port
parameter_list|(
name|int
name|defaultPort
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|defaultPort
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|port
operator|==
operator|-
literal|1
condition|?
name|defaultPort
else|:
name|d
operator|->
name|port
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the path of the URL to \a path. The path is the part of the     URL that comes after the authority but before the query string.      \img qurl-ftppath.png      For non-hierarchical schemes, the path will be everything     following the scheme declaration, as in the following example:      \img qurl-mailtopath.png      \sa path() */
end_comment
begin_function
DECL|function|setPath
name|void
name|QUrl
operator|::
name|setPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
operator||
name|QUrlPrivate
operator|::
name|Normalized
argument_list|)
expr_stmt|;
name|d
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|d
operator|->
name|encodedPath
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the path of the URL.      \sa setPath() */
end_comment
begin_function
DECL|function|path
name|QString
name|QUrl
operator|::
name|path
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|path
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QUrlPrivate
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QUrlPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|that
operator|->
name|path
operator|=
name|fromPercentEncodingHelper
argument_list|(
name|d
operator|->
name|encodedPath
argument_list|)
expr_stmt|;
block|}
return|return
name|d
operator|->
name|path
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the URL's path to the percent-encoded \a path.  The path is     the part of the URL that comes after the authority but before the     query string.      \img qurl-ftppath.png      For non-hierarchical schemes, the path will be everything     following the scheme declaration, as in the following example:      \img qurl-mailtopath.png      Note: this function does not verify that \a path is properly     encoded. It is the caller's responsibility to ensure that the any     delimiters (such as '?' and '#') are properly encoded.      \sa setPath(), encodedPath(), setUserInfo() */
end_comment
begin_function
DECL|function|setEncodedPath
name|void
name|QUrl
operator|::
name|setEncodedPath
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
operator||
name|QUrlPrivate
operator|::
name|Normalized
argument_list|)
expr_stmt|;
name|d
operator|->
name|encodedPath
operator|=
name|path
expr_stmt|;
name|d
operator|->
name|path
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the path of the URL if it is defined; otherwise an     empty string is returned. The returned value will have its     non-ASCII and other control characters percent-encoded, as in     toEncoded().      \sa setEncodedPath(), toEncoded() */
end_comment
begin_function
DECL|function|encodedPath
name|QByteArray
name|QUrl
operator|::
name|encodedPath
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QByteArray
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|d
operator|->
name|ensureEncodedParts
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|encodedPath
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns true if this URL contains a Query (i.e., if ? was seen on it).      \sa hasQueryItem(), encodedQuery() */
end_comment
begin_function
DECL|function|hasQuery
name|bool
name|QUrl
operator|::
name|hasQuery
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|hasQuery
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the query string of the URL to \a query. The string is     inserted as-is, and no further encoding is performed when calling     toEncoded().      This function is useful if you need to pass a query string that     does not fit into the key-value pattern, or that uses a different     scheme for encoding special characters than what is suggested by     QUrl.      Passing a value of QByteArray() to \a query (a null QByteArray) unsets     the query completely. However, passing a value of QByteArray("")     will set the query to an empty value, as if the original URL     had a lone "?".      \sa encodedQuery(), hasQuery() */
end_comment
begin_function
DECL|function|setEncodedQuery
name|void
name|QUrl
operator|::
name|setEncodedQuery
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|query
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
operator||
name|QUrlPrivate
operator|::
name|Normalized
argument_list|)
expr_stmt|;
name|d
operator|->
name|query
operator|=
name|query
expr_stmt|;
name|d
operator|->
name|hasQuery
operator|=
operator|!
name|query
operator|.
name|isNull
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the query string of the URL in percent encoded form. */
end_comment
begin_function
DECL|function|encodedQuery
name|QByteArray
name|QUrl
operator|::
name|encodedQuery
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QByteArray
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|query
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the fragment of the URL to \a fragment. The fragment is the     last part of the URL, represented by a '#' followed by a string of     characters. It is typically used in HTTP for referring to a     certain link or point on a page:      \img qurl-fragment.png      The fragment is sometimes also referred to as the URL "reference".      Passing an argument of QString() (a null QString) will unset the fragment.     Passing an argument of QString("") (an empty but not null QString)     will set the fragment to an empty string (as if the original URL     had a lone "#").      \sa fragment(), hasFragment() */
end_comment
begin_function
DECL|function|setFragment
name|void
name|QUrl
operator|::
name|setFragment
parameter_list|(
specifier|const
name|QString
modifier|&
name|fragment
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
operator||
name|QUrlPrivate
operator|::
name|Normalized
argument_list|)
expr_stmt|;
name|d
operator|->
name|fragment
operator|=
name|fragment
expr_stmt|;
name|d
operator|->
name|hasFragment
operator|=
operator|!
name|fragment
operator|.
name|isNull
argument_list|()
expr_stmt|;
name|d
operator|->
name|encodedFragment
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the fragment of the URL.      \sa setFragment() */
end_comment
begin_function
DECL|function|fragment
name|QString
name|QUrl
operator|::
name|fragment
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fragment
operator|.
name|isNull
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|encodedFragment
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QUrlPrivate
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QUrlPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|that
operator|->
name|fragment
operator|=
name|fromPercentEncodingHelper
argument_list|(
name|d
operator|->
name|encodedFragment
argument_list|)
expr_stmt|;
block|}
return|return
name|d
operator|->
name|fragment
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the URL's fragment to the percent-encoded \a fragment. The fragment is the     last part of the URL, represented by a '#' followed by a string of     characters. It is typically used in HTTP for referring to a     certain link or point on a page:      \img qurl-fragment.png      The fragment is sometimes also referred to as the URL "reference".      Passing an argument of QByteArray() (a null QByteArray) will unset     the fragment.  Passing an argument of QByteArray("") (an empty but     not null QByteArray) will set the fragment to an empty string (as     if the original URL had a lone "#").      \sa setFragment(), encodedFragment() */
end_comment
begin_function
DECL|function|setEncodedFragment
name|void
name|QUrl
operator|::
name|setEncodedFragment
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|fragment
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|detach
argument_list|()
expr_stmt|;
name|QURL_UNSETFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Validated
operator||
name|QUrlPrivate
operator|::
name|Normalized
argument_list|)
expr_stmt|;
name|d
operator|->
name|encodedFragment
operator|=
name|fragment
expr_stmt|;
name|d
operator|->
name|hasFragment
operator|=
operator|!
name|fragment
operator|.
name|isNull
argument_list|()
expr_stmt|;
name|d
operator|->
name|fragment
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the fragment of the URL if it is defined; otherwise an     empty string is returned. The returned value will have its     non-ASCII and other control characters percent-encoded, as in     toEncoded().      \sa setEncodedFragment(), toEncoded() */
end_comment
begin_function
DECL|function|encodedFragment
name|QByteArray
name|QUrl
operator|::
name|encodedFragment
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QByteArray
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|d
operator|->
name|ensureEncodedParts
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|encodedFragment
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns true if this URL contains a fragment (i.e., if # was seen on it).      \sa fragment(), setFragment() */
end_comment
begin_function
DECL|function|hasFragment
name|bool
name|QUrl
operator|::
name|hasFragment
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|hasFragment
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns the TLD (Top-Level Domain) of the URL, (e.g. .co.uk, .net).     Note that the return value is prefixed with a '.' unless the     URL does not contain a valid TLD, in which case the function returns     an empty string. */
end_comment
begin_function
DECL|function|topLevelDomain
name|QString
name|QUrl
operator|::
name|topLevelDomain
parameter_list|()
specifier|const
block|{
return|return
name|qTopLevelDomain
argument_list|(
name|host
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the result of the merge of this URL with \a relative. This     URL is used as a base to convert \a relative to an absolute URL.      If \a relative is not a relative URL, this function will return \a     relative directly. Otherwise, the paths of the two URLs are     merged, and the new URL returned has the scheme and authority of     the base URL, but with the merged path, as in the following     example:      \snippet doc/src/snippets/code/src_corelib_io_qurl.cpp 5      Calling resolved() with ".." returns a QUrl whose directory is     one level higher than the original. Similarly, calling resolved()     with "../.." removes two levels from the path. If \a relative is     "/", the path becomes "/".      \sa isRelative() */
end_comment
begin_function
DECL|function|resolved
name|QUrl
name|QUrl
operator|::
name|resolved
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|relative
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|relative
return|;
if|if
condition|(
operator|!
name|relative
operator|.
name|d
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|relative
operator|.
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|relative
operator|.
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|d
operator|->
name|ensureEncodedParts
argument_list|()
expr_stmt|;
name|relative
operator|.
name|d
operator|->
name|ensureEncodedParts
argument_list|()
expr_stmt|;
name|QUrl
name|t
decl_stmt|;
comment|// be non strict and allow scheme in relative url
if|if
condition|(
operator|!
name|relative
operator|.
name|d
operator|->
name|scheme
operator|.
name|isEmpty
argument_list|()
operator|&&
name|relative
operator|.
name|d
operator|->
name|scheme
operator|!=
name|d
operator|->
name|scheme
condition|)
block|{
name|t
operator|=
name|relative
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|relative
operator|.
name|authority
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|t
operator|=
name|relative
expr_stmt|;
block|}
else|else
block|{
name|t
operator|.
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
if|if
condition|(
name|relative
operator|.
name|d
operator|->
name|encodedPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|t
operator|.
name|d
operator|->
name|encodedPath
operator|=
name|d
operator|->
name|encodedPath
expr_stmt|;
name|t
operator|.
name|setEncodedQuery
argument_list|(
name|relative
operator|.
name|d
operator|->
name|hasQuery
condition|?
name|relative
operator|.
name|d
operator|->
name|query
else|:
name|d
operator|->
name|query
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|.
name|d
operator|->
name|encodedPath
operator|=
name|relative
operator|.
name|d
operator|->
name|encodedPath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'/'
condition|?
name|relative
operator|.
name|d
operator|->
name|encodedPath
else|:
name|d
operator|->
name|mergePaths
argument_list|(
name|relative
operator|.
name|d
operator|->
name|encodedPath
argument_list|)
expr_stmt|;
name|t
operator|.
name|setEncodedQuery
argument_list|(
name|relative
operator|.
name|d
operator|->
name|query
argument_list|)
expr_stmt|;
block|}
name|t
operator|.
name|d
operator|->
name|encodedUserName
operator|=
name|d
operator|->
name|encodedUserName
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|encodedPassword
operator|=
name|d
operator|->
name|encodedPassword
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|host
operator|=
name|d
operator|->
name|host
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|port
operator|=
name|d
operator|->
name|port
expr_stmt|;
block|}
name|t
operator|.
name|setScheme
argument_list|(
name|d
operator|->
name|scheme
argument_list|)
expr_stmt|;
block|}
name|t
operator|.
name|setFragment
argument_list|(
name|relative
operator|.
name|fragment
argument_list|()
argument_list|)
expr_stmt|;
name|removeDotsFromPath
argument_list|(
operator|&
name|t
operator|.
name|d
operator|->
name|encodedPath
argument_list|)
expr_stmt|;
name|t
operator|.
name|d
operator|->
name|path
operator|.
name|clear
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QURL_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QUrl(\"%s\").resolved(\"%s\") = \"%s\""
argument_list|,
name|toEncoded
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|relative
operator|.
name|toEncoded
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|t
operator|.
name|toEncoded
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the URL is relative; otherwise returns false. A     URL is relative if its scheme is undefined; this function is     therefore equivalent to calling scheme().isEmpty(). */
end_comment
begin_function
DECL|function|isRelative
name|bool
name|QUrl
operator|::
name|isRelative
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|scheme
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// Encodes only what really needs to be encoded.
end_comment
begin_comment
comment|// \a input must be decoded.
end_comment
begin_function
DECL|function|toPrettyPercentEncoding
specifier|static
name|QString
name|toPrettyPercentEncoding
parameter_list|(
specifier|const
name|QString
modifier|&
name|input
parameter_list|,
name|bool
name|forFragment
parameter_list|)
block|{
specifier|const
name|int
name|len
init|=
name|input
operator|.
name|length
argument_list|()
decl_stmt|;
name|QString
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QChar
name|c
init|=
name|input
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|register
name|ushort
name|u
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|u
operator|<
literal|0x20
operator|||
operator|(
operator|!
name|forFragment
operator|&&
name|u
operator|==
literal|'?'
operator|)
comment|// don't escape '?' in fragments
operator|||
name|u
operator|==
literal|'#'
operator|||
name|u
operator|==
literal|'%'
operator|||
operator|(
name|u
operator|==
literal|' '
operator|&&
operator|(
name|i
operator|+
literal|1
operator|==
name|len
operator|||
name|input
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|.
name|unicode
argument_list|()
operator|==
literal|' '
operator|)
operator|)
condition|)
block|{
specifier|static
specifier|const
name|char
name|hexdigits
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
name|hexdigits
index|[
operator|(
name|u
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|result
operator|+=
name|QLatin1Char
argument_list|(
name|hexdigits
index|[
name|u
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|+=
name|c
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a string representation of the URL.     The output can be customized by passing flags with \a options.      The resulting QString can be passed back to a QUrl later on.      Synonym for url(options).      \sa FormattingOptions, toEncoded(), url() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QUrl
operator|::
name|toString
parameter_list|(
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|QString
name|url
decl_stmt|;
specifier|const
name|QString
name|ourPath
init|=
name|path
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|PreferLocalFile
operator|)
operator|&&
name|isLocalFile
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|hasQuery
operator|&&
operator|!
name|d
operator|->
name|hasFragment
condition|)
return|return
name|ourPath
return|;
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveScheme
operator|)
operator|&&
operator|!
name|d
operator|->
name|scheme
operator|.
name|isEmpty
argument_list|()
condition|)
name|url
operator|+=
name|d
operator|->
name|scheme
operator|+
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveAuthority
operator|)
operator|!=
name|QUrl
operator|::
name|RemoveAuthority
condition|)
block|{
name|bool
name|doFileScheme
init|=
name|d
operator|->
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"file"
argument_list|)
operator|&&
name|ourPath
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|tmp
init|=
name|d
operator|->
name|authority
argument_list|(
name|options
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|.
name|isNull
argument_list|()
operator|||
name|doFileScheme
condition|)
block|{
if|if
condition|(
name|doFileScheme
operator|&&
operator|!
name|ourPath
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|url
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|url
operator|+=
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
expr_stmt|;
name|url
operator|+=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemovePath
operator|)
condition|)
block|{
comment|// check if we need to insert a slash
if|if
condition|(
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveAuthority
operator|)
operator|!=
name|QUrl
operator|::
name|RemoveAuthority
operator|&&
operator|!
name|d
operator|->
name|authority
argument_list|(
name|options
argument_list|)
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|ourPath
operator|.
name|isEmpty
argument_list|()
operator|&&
name|ourPath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
name|url
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|url
operator|+=
name|toPrettyPercentEncoding
argument_list|(
name|ourPath
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// check if we need to remove trailing slashes
while|while
condition|(
operator|(
name|options
operator|&
name|StripTrailingSlash
operator|)
operator|&&
name|url
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|url
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveQuery
operator|)
operator|&&
name|d
operator|->
name|hasQuery
condition|)
block|{
name|url
operator|+=
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
name|url
operator|+=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|QByteArray
operator|::
name|fromPercentEncoding
argument_list|(
name|d
operator|->
name|query
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QUrl
operator|::
name|RemoveFragment
operator|)
operator|&&
name|d
operator|->
name|hasFragment
condition|)
block|{
name|url
operator|+=
name|QLatin1Char
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|url
operator|+=
name|fragment
argument_list|()
expr_stmt|;
block|}
return|return
name|url
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     Returns a string representation of the URL.     The output can be customized by passing flags with \a options.      The resulting QString can be passed back to a QUrl later on.      Synonym for toString(options).      \sa FormattingOptions, toEncoded(), toString() */
end_comment
begin_function
DECL|function|url
name|QString
name|QUrl
operator|::
name|url
parameter_list|(
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
return|return
name|toString
argument_list|(
name|options
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Returns a human-displayable string representation of the URL.     The output can be customized by passing flags with \a options.     The option RemovePassword is always enabled, since passwords     should never be shown back to users.      With the default options, the resulting QString can be passed back     to a QUrl later on, but any password that was present initially will     be lost.      \sa FormattingOptions, toEncoded(), toString() */
end_comment
begin_function
DECL|function|toDisplayString
name|QString
name|QUrl
operator|::
name|toDisplayString
parameter_list|(
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
return|return
name|toString
argument_list|(
name|options
operator||
name|RemovePassword
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the encoded representation of the URL if it's valid;     otherwise an empty QByteArray is returned. The output can be     customized by passing flags with \a options.      The user info, path and fragment are all converted to UTF-8, and     all non-ASCII characters are then percent encoded. The host name     is encoded using Punycode. */
end_comment
begin_function
DECL|function|toEncoded
name|QByteArray
name|QUrl
operator|::
name|toEncoded
parameter_list|(
name|FormattingOptions
name|options
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QByteArray
argument_list|()
return|;
return|return
name|d
operator|->
name|toEncoded
argument_list|(
name|options
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QUrl QUrl::fromEncoded(const QByteArray&input, ParsingMode parsingMode)     \obsolete      Parses \a input and returns the corresponding QUrl. \a input is     assumed to be in encoded form, containing only ASCII characters.      The URL is parsed using \a parsingMode.      Use QUrl(QString::fromUtf8(input), parsingMode) instead.      \sa toEncoded(), setUrl() */
end_comment
begin_comment
comment|/*!     Returns a decoded copy of \a input. \a input is first decoded from     percent encoding, then converted from UTF-8 to unicode. */
end_comment
begin_function
DECL|function|fromPercentEncoding
name|QString
name|QUrl
operator|::
name|fromPercentEncoding
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|input
parameter_list|)
block|{
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
name|QByteArray
operator|::
name|fromPercentEncoding
argument_list|(
name|input
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an encoded copy of \a input. \a input is first converted     to UTF-8, and all ASCII-characters that are not in the unreserved group     are percent encoded. To prevent characters from being percent encoded     pass them to \a exclude. To force characters to be percent encoded pass     them to \a include.      Unreserved is defined as:        ALPHA / DIGIT / "-" / "." / "_" / "~"      \snippet doc/src/snippets/code/src_corelib_io_qurl.cpp 6 */
end_comment
begin_function
DECL|function|toPercentEncoding
name|QByteArray
name|QUrl
operator|::
name|toPercentEncoding
parameter_list|(
specifier|const
name|QString
modifier|&
name|input
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|exclude
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|include
parameter_list|)
block|{
return|return
name|input
operator|.
name|toUtf8
argument_list|()
operator|.
name|toPercentEncoding
argument_list|(
name|exclude
argument_list|,
name|include
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray QUrl::toPunycode(const QString&uc)     \obsolete     Returns a \a uc in Punycode encoding.      Punycode is a Unicode encoding used for internationalized domain     names, as defined in RFC3492. If you want to convert a domain name from     Unicode to its ASCII-compatible representation, use toAce(). */
end_comment
begin_comment
comment|/*!     \fn QString QUrl::fromPunycode(const QByteArray&pc)     \obsolete     Returns the Punycode decoded representation of \a pc.      Punycode is a Unicode encoding used for internationalized domain     names, as defined in RFC3492. If you want to convert a domain from     its ASCII-compatible encoding to the Unicode representation, use     fromAce(). */
end_comment
begin_comment
comment|/*!     \since 4.2      Returns the Unicode form of the given domain name     \a domain, which is encoded in the ASCII Compatible Encoding (ACE).     The result of this function is considered equivalent to \a domain.      If the value in \a domain cannot be encoded, it will be converted     to QString and returned.      The ASCII Compatible Encoding (ACE) is defined by RFC 3490, RFC 3491     and RFC 3492. It is part of the Internationalizing Domain Names in     Applications (IDNA) specification, which allows for domain names     (like \c "example.com") to be written using international     characters. */
end_comment
begin_function
DECL|function|fromAce
name|QString
name|QUrl
operator|::
name|fromAce
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|domain
parameter_list|)
block|{
return|return
name|qt_ACE_do
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|domain
argument_list|)
argument_list|,
name|NormalizeAce
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the ASCII Compatible Encoding of the given domain name \a domain.     The result of this function is considered equivalent to \a domain.      The ASCII-Compatible Encoding (ACE) is defined by RFC 3490, RFC 3491     and RFC 3492. It is part of the Internationalizing Domain Names in     Applications (IDNA) specification, which allows for domain names     (like \c "example.com") to be written using international     characters.      This function return an empty QByteArra if \a domain is not a valid     hostname. Note, in particular, that IPv6 literals are not valid domain     names. */
end_comment
begin_function
DECL|function|toAce
name|QByteArray
name|QUrl
operator|::
name|toAce
parameter_list|(
specifier|const
name|QString
modifier|&
name|domain
parameter_list|)
block|{
name|QString
name|result
init|=
name|qt_ACE_do
argument_list|(
name|domain
argument_list|,
name|ToAceOnly
argument_list|)
decl_stmt|;
return|return
name|result
operator|.
name|toLatin1
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns true if this URL is "less than" the given \a url. This     provides a means of ordering URLs. */
end_comment
begin_function
DECL|function|operator <
name|bool
name|QUrl
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|url
operator|.
name|d
condition|?
name|QByteArray
argument_list|()
operator|<
name|url
operator|.
name|d
operator|->
name|normalized
argument_list|()
else|:
literal|false
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|url
operator|.
name|d
condition|)
return|return
name|d
operator|->
name|normalized
argument_list|()
operator|<
name|QByteArray
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|url
operator|.
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|url
operator|.
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|normalized
argument_list|()
operator|<
name|url
operator|.
name|d
operator|->
name|normalized
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this URL and the given \a url are equal;     otherwise returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QUrl
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|url
operator|.
name|isEmpty
argument_list|()
return|;
if|if
condition|(
operator|!
name|url
operator|.
name|d
condition|)
return|return
name|isEmpty
argument_list|()
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|url
operator|.
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|url
operator|.
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|normalized
argument_list|()
operator|==
name|url
operator|.
name|d
operator|->
name|normalized
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this URL and the given \a url are not equal;     otherwise returns false. */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QUrl
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|url
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Assigns the specified \a url to this object. */
end_comment
begin_function
DECL|function|operator =
name|QUrl
modifier|&
name|QUrl
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
if|if
condition|(
name|url
operator|.
name|d
condition|)
block|{
name|url
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|d
operator|=
name|url
operator|.
name|d
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|url
operator|.
name|d
condition|)
name|qAtomicAssign
argument_list|(
name|d
argument_list|,
name|url
operator|.
name|d
argument_list|)
expr_stmt|;
else|else
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Assigns the specified \a url to this object. */
end_comment
begin_function
DECL|function|operator =
name|QUrl
modifier|&
name|QUrl
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|)
block|{
if|if
condition|(
name|url
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QUrl
name|tmp
argument_list|(
name|url
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
name|qAtomicAssign
argument_list|(
name|d
argument_list|,
name|tmp
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QUrl::swap(QUrl&other)     \since 4.8      Swaps URL \a other with this URL. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*! \internal      Forces a detach. */
end_comment
begin_function
DECL|function|detach
name|void
name|QUrl
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
operator|new
name|QUrlPrivate
expr_stmt|;
else|else
name|qAtomicDetach
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|isDetached
name|bool
name|QUrl
operator|::
name|isDetached
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d
operator|||
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QUrl representation of \a localFile, interpreted as a local     file. This function accepts paths separated by slashes as well as the     native separator for this platform.      This function also accepts paths with a doubled leading slash (or     backslash) to indicate a remote file, as in     "//servername/path/to/file.txt". Note that only certain platforms can     actually open this file using QFile::open().      \sa toLocalFile(), isLocalFile(), QDir::toNativeSeparators() */
end_comment
begin_function
DECL|function|fromLocalFile
name|QUrl
name|QUrl
operator|::
name|fromLocalFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|localFile
parameter_list|)
block|{
name|QUrl
name|url
decl_stmt|;
name|url
operator|.
name|setScheme
argument_list|(
name|QLatin1String
argument_list|(
literal|"file"
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|deslashified
init|=
name|QDir
operator|::
name|fromNativeSeparators
argument_list|(
name|localFile
argument_list|)
decl_stmt|;
comment|// magic for drives on windows
if|if
condition|(
name|deslashified
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|deslashified
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|&&
name|deslashified
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
name|url
operator|.
name|setPath
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|deslashified
argument_list|)
expr_stmt|;
comment|// magic for shared drive on windows
block|}
elseif|else
if|if
condition|(
name|deslashified
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|indexOfPath
init|=
name|deslashified
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|url
operator|.
name|setHost
argument_list|(
name|deslashified
operator|.
name|mid
argument_list|(
literal|2
argument_list|,
name|indexOfPath
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexOfPath
operator|>
literal|2
condition|)
name|url
operator|.
name|setPath
argument_list|(
name|deslashified
operator|.
name|right
argument_list|(
name|deslashified
operator|.
name|length
argument_list|()
operator|-
name|indexOfPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|url
operator|.
name|setPath
argument_list|(
name|deslashified
argument_list|)
expr_stmt|;
block|}
return|return
name|url
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the path of this URL formatted as a local file path. The path     returned will use forward slashes, even if it was originally created     from one with backslashes.      If this URL contains a non-empty hostname, it will be encoded in the     returned value in the form found on SMB networks (for example,     "//servername/path/to/file.txt").      \sa fromLocalFile(), isLocalFile() */
end_comment
begin_function
DECL|function|toLocalFile
name|QString
name|QUrl
operator|::
name|toLocalFile
parameter_list|()
specifier|const
block|{
comment|// the call to isLocalFile() also ensures that we're parsed
if|if
condition|(
operator|!
name|isLocalFile
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|tmp
decl_stmt|;
name|QString
name|ourPath
init|=
name|path
argument_list|()
decl_stmt|;
comment|// magic for shared drive on windows
if|if
condition|(
operator|!
name|d
operator|->
name|host
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
operator|+
name|d
operator|->
name|host
operator|+
operator|(
name|ourPath
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|ourPath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|?
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|ourPath
else|:
name|ourPath
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|ourPath
expr_stmt|;
comment|// magic for drives on windows
if|if
condition|(
name|ourPath
operator|.
name|length
argument_list|()
operator|>
literal|2
operator|&&
name|ourPath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|&&
name|ourPath
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
condition|)
name|tmp
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function
begin_function
DECL|function|isLocalFile
name|bool
name|QUrlPrivate
operator|::
name|isLocalFile
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|scheme
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"file"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
comment|// not file
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7     Returns true if this URL is pointing to a local file path. A URL is a     local file path if the scheme is "file".      Note that this function considers URLs with hostnames to be local file     paths, even if the eventual file path cannot be opened with     QFile::open().      \sa fromLocalFile(), toLocalFile() */
end_comment
begin_function
DECL|function|isLocalFile
name|bool
name|QUrl
operator|::
name|isLocalFile
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|isLocalFile
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this URL is a parent of \a childUrl. \a childUrl is a child     of this URL if the two URLs share the same scheme and authority,     and this URL's path is a parent of the path of \a childUrl. */
end_comment
begin_function
DECL|function|isParentOf
name|bool
name|QUrl
operator|::
name|isParentOf
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|childUrl
parameter_list|)
specifier|const
block|{
name|QString
name|childPath
init|=
name|childUrl
operator|.
name|path
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
operator|(
operator|(
name|childUrl
operator|.
name|scheme
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
name|childUrl
operator|.
name|authority
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
name|childPath
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|childPath
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|QURL_HASFLAG
argument_list|(
name|d
operator|->
name|stateFlags
argument_list|,
name|QUrlPrivate
operator|::
name|Parsed
argument_list|)
condition|)
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
name|QString
name|ourPath
init|=
name|path
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|childUrl
operator|.
name|scheme
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|d
operator|->
name|scheme
operator|==
name|childUrl
operator|.
name|scheme
argument_list|()
operator|)
operator|&&
operator|(
name|childUrl
operator|.
name|authority
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|d
operator|->
name|authority
argument_list|()
operator|==
name|childUrl
operator|.
name|authority
argument_list|()
operator|)
operator|&&
name|childPath
operator|.
name|startsWith
argument_list|(
name|ourPath
argument_list|)
operator|&&
operator|(
operator|(
name|ourPath
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|&&
name|childPath
operator|.
name|length
argument_list|()
operator|>
name|ourPath
operator|.
name|length
argument_list|()
operator|)
operator|||
operator|(
operator|!
name|ourPath
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|&&
name|childPath
operator|.
name|length
argument_list|()
operator|>
name|ourPath
operator|.
name|length
argument_list|()
operator|&&
name|childPath
operator|.
name|at
argument_list|(
name|ourPath
operator|.
name|length
argument_list|()
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*! \relates QUrl      Writes url \a url to the stream \a out and returns a reference     to the stream.      \sa \link datastreamformat.html Format of the QDataStream operators \endlink */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|QByteArray
name|u
init|=
name|url
operator|.
name|toEncoded
argument_list|()
decl_stmt|;
name|out
operator|<<
name|u
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*! \relates QUrl      Reads a url into \a url from the stream \a in and returns a     reference to the stream.      \sa \link datastreamformat.html Format of the QDataStream operators \endlink */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|QByteArray
name|u
decl_stmt|;
name|in
operator|>>
name|u
expr_stmt|;
name|url
operator|=
name|QUrl
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|d
parameter_list|,
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|d
operator|.
name|maybeSpace
argument_list|()
operator|<<
literal|"QUrl("
operator|<<
name|url
operator|.
name|toDisplayString
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|d
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \since 4.2      Returns a text string that explains why an URL is invalid in the case being;     otherwise returns an empty string. */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QUrl
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|"Invalid URL \"\": "
argument_list|)
argument_list|)
return|;
comment|// XXX not a good message, but the one an empty URL produces
return|return
name|d
operator|->
name|createErrorString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \typedef QUrl::DataPtr     \internal */
end_comment
begin_comment
comment|/*!     \fn DataPtr&QUrl::data_ptr()     \internal */
end_comment
begin_comment
comment|// The following code has the following copyright:
end_comment
begin_comment
comment|/*    Copyright (C) Research In Motion Limited 2009. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:     * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     * Neither the name of Research In Motion Limited nor the       names of its contributors may be used to endorse or promote products       derived from this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY Research In Motion Limited ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Research In Motion Limited BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_comment
comment|/*!     Returns a valid URL from a user supplied \a userInput string if one can be     deducted. In the case that is not possible, an invalid QUrl() is returned.      \since 4.6      Most applications that can browse the web, allow the user to input a URL     in the form of a plain string. This string can be manually typed into     a location bar, obtained from the clipboard, or passed in via command     line arguments.      When the string is not already a valid URL, a best guess is performed,     making various web related assumptions.      In the case the string corresponds to a valid file path on the system,     a file:// URL is constructed, using QUrl::fromLocalFile().      If that is not the case, an attempt is made to turn the string into a     http:// or ftp:// URL. The latter in the case the string starts with     'ftp'. The result is then passed through QUrl's tolerant parser, and     in the case or success, a valid QUrl is returned, or else a QUrl().      \section1 Examples:      \list     \li qt.nokia.com becomes http://qt.nokia.com     \li ftp.qt.nokia.com becomes ftp://ftp.qt.nokia.com     \li hostname becomes http://hostname     \li /home/user/test.html becomes file:///home/user/test.html     \endlist */
end_comment
begin_function
DECL|function|fromUserInput
name|QUrl
name|QUrl
operator|::
name|fromUserInput
parameter_list|(
specifier|const
name|QString
modifier|&
name|userInput
parameter_list|)
block|{
name|QString
name|trimmedString
init|=
name|userInput
operator|.
name|trimmed
argument_list|()
decl_stmt|;
comment|// Check first for files, since on Windows drive letters can be interpretted as schemes
if|if
condition|(
name|QDir
operator|::
name|isAbsolutePath
argument_list|(
name|trimmedString
argument_list|)
condition|)
return|return
name|QUrl
operator|::
name|fromLocalFile
argument_list|(
name|trimmedString
argument_list|)
return|;
name|QUrl
name|url
argument_list|(
name|trimmedString
argument_list|,
name|QUrl
operator|::
name|TolerantMode
argument_list|)
decl_stmt|;
name|QUrl
name|urlPrepended
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"http://"
argument_list|)
operator|+
name|trimmedString
argument_list|,
name|QUrl
operator|::
name|TolerantMode
argument_list|)
decl_stmt|;
comment|// Check the most common case of a valid url with scheme and host
comment|// We check if the port would be valid by adding the scheme to handle the case host:port
comment|// where the host would be interpretted as the scheme
if|if
condition|(
name|url
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|url
operator|.
name|scheme
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|!
name|url
operator|.
name|host
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|url
operator|.
name|path
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
name|urlPrepended
operator|.
name|port
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
name|url
return|;
comment|// Else, try the prepended one and adjust the scheme from the host name
if|if
condition|(
name|urlPrepended
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
operator|!
name|urlPrepended
operator|.
name|host
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|urlPrepended
operator|.
name|path
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|int
name|dotIndex
init|=
name|trimmedString
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|hostscheme
init|=
name|trimmedString
operator|.
name|left
argument_list|(
name|dotIndex
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|hostscheme
operator|==
name|QLatin1String
argument_list|(
literal|"ftp"
argument_list|)
condition|)
name|urlPrepended
operator|.
name|setScheme
argument_list|(
name|QLatin1String
argument_list|(
literal|"ftp"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|urlPrepended
return|;
block|}
return|return
name|QUrl
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// end of BSD code
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
