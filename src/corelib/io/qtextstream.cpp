begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QTEXTSTREAM_DEBUG
end_comment
begin_decl_stmt
DECL|variable|QTEXTSTREAM_BUFFERSIZE
specifier|static
specifier|const
name|int
name|QTEXTSTREAM_BUFFERSIZE
init|=
literal|16384
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     \class QTextStream     \inmodule QtCore      \brief The QTextStream class provides a convenient interface for     reading and writing text.      \ingroup io     \ingroup string-processing     \reentrant      QTextStream can operate on a QIODevice, a QByteArray or a     QString. Using QTextStream's streaming operators, you can     conveniently read and write words, lines and numbers. For     generating text, QTextStream supports formatting options for field     padding and alignment, and formatting of numbers. Example:      \snippet code/src_corelib_io_qtextstream.cpp 0      It's also common to use QTextStream to read console input and write     console output. QTextStream is locale aware, and will automatically decode     standard input using the correct codec. Example:      \snippet code/src_corelib_io_qtextstream.cpp 1      Besides using QTextStream's constructors, you can also set the     device or string QTextStream operates on by calling setDevice() or     setString(). You can seek to a position by calling seek(), and     atEnd() will return true when there is no data left to be read. If     you call flush(), QTextStream will empty all data from its write     buffer into the device and call flush() on the device.      Internally, QTextStream uses a Unicode based buffer, and     QTextCodec is used by QTextStream to automatically support     different character sets. By default, QTextCodec::codecForLocale()     is used for reading and writing, but you can also set the codec by     calling setCodec(). Automatic Unicode detection is also     supported. When this feature is enabled (the default behavior),     QTextStream will detect the UTF-16 or the UTF-32 BOM (Byte Order Mark) and     switch to the appropriate UTF codec when reading. QTextStream     does not write a BOM by default, but you can enable this by calling     setGenerateByteOrderMark(true). When QTextStream operates on a QString     directly, the codec is disabled.      There are three general ways to use QTextStream when reading text     files:      \list      \li Chunk by chunk, by calling readLine() or readAll().      \li Word by word. QTextStream supports streaming into QStrings,     QByteArrays and char* buffers. Words are delimited by space, and     leading white space is automatically skipped.      \li Character by character, by streaming into QChar or char types.     This method is often used for convenient input handling when     parsing files, independent of character encoding and end-of-line     semantics. To skip white space, call skipWhiteSpace().      \endlist      Since the text stream uses a buffer, you should not read from     the stream using the implementation of a superclass. For instance,     if you have a QFile and read from it directly using     QFile::readLine() instead of using the stream, the text stream's     internal position will be out of sync with the file's position.      By default, when reading numbers from a stream of text,     QTextStream will automatically detect the number's base     representation. For example, if the number starts with "0x", it is     assumed to be in hexadecimal form. If it starts with the digits     1-9, it is assumed to be in decimal form, and so on. You can set     the integer base, thereby disabling the automatic detection, by     calling setIntegerBase(). Example:      \snippet code/src_corelib_io_qtextstream.cpp 2      QTextStream supports many formatting options for generating text.     You can set the field width and pad character by calling     setFieldWidth() and setPadChar(). Use setFieldAlignment() to set     the alignment within each field. For real numbers, call     setRealNumberNotation() and setRealNumberPrecision() to set the     notation (SmartNotation, ScientificNotation, FixedNotation) and precision in     digits of the generated number. Some extra number formatting     options are also available through setNumberFlags().      \keyword QTextStream manipulators      Like \c<iostream> in the standard C++ library, QTextStream also     defines several global manipulator functions:      \table     \header \li Manipulator        \li Description     \row    \li \c bin             \li Same as setIntegerBase(2).     \row    \li \c oct             \li Same as setIntegerBase(8).     \row    \li \c dec             \li Same as setIntegerBase(10).     \row    \li \c hex             \li Same as setIntegerBase(16).     \row    \li \c showbase        \li Same as setNumberFlags(numberFlags() | ShowBase).     \row    \li \c forcesign       \li Same as setNumberFlags(numberFlags() | ForceSign).     \row    \li \c forcepoint      \li Same as setNumberFlags(numberFlags() | ForcePoint).     \row    \li \c noshowbase      \li Same as setNumberFlags(numberFlags()& ~ShowBase).     \row    \li \c noforcesign     \li Same as setNumberFlags(numberFlags()& ~ForceSign).     \row    \li \c noforcepoint    \li Same as setNumberFlags(numberFlags()& ~ForcePoint).     \row    \li \c uppercasebase   \li Same as setNumberFlags(numberFlags() | UppercaseBase).     \row    \li \c uppercasedigits \li Same as setNumberFlags(numberFlags() | UppercaseDigits).     \row    \li \c lowercasebase   \li Same as setNumberFlags(numberFlags()& ~UppercaseBase).     \row    \li \c lowercasedigits \li Same as setNumberFlags(numberFlags()& ~UppercaseDigits).     \row    \li \c fixed           \li Same as setRealNumberNotation(FixedNotation).     \row    \li \c scientific      \li Same as setRealNumberNotation(ScientificNotation).     \row    \li \c left            \li Same as setFieldAlignment(AlignLeft).     \row    \li \c right           \li Same as setFieldAlignment(AlignRight).     \row    \li \c center          \li Same as setFieldAlignment(AlignCenter).     \row    \li \c endl            \li Same as operator<<('\\n') and flush().     \row    \li \c flush           \li Same as flush().     \row    \li \c reset           \li Same as reset().     \row    \li \c ws              \li Same as skipWhiteSpace().     \row    \li \c bom             \li Same as setGenerateByteOrderMark(true).     \endtable      In addition, Qt provides three global manipulators that take a     parameter: qSetFieldWidth(), qSetPadChar(), and     qSetRealNumberPrecision().      \sa QDataStream, QIODevice, QFile, QBuffer, QTcpSocket, {Codecs Example} */
end_comment
begin_comment
comment|/*! \enum QTextStream::RealNumberNotation      This enum specifies which notations to use for expressing \c     float and \c double as strings.      \value ScientificNotation Scientific notation (\c{printf()}'s \c %e flag).     \value FixedNotation Fixed-point notation (\c{printf()}'s \c %f flag).     \value SmartNotation Scientific or fixed-point notation, depending on which makes most sense (\c{printf()}'s \c %g flag).      \sa setRealNumberNotation() */
end_comment
begin_comment
comment|/*! \enum QTextStream::FieldAlignment      This enum specifies how to align text in fields when the field is     wider than the text that occupies it.      \value AlignLeft  Pad on the right side of fields.     \value AlignRight  Pad on the left side of fields.     \value AlignCenter  Pad on both sides of field.     \value AlignAccountingStyle  Same as AlignRight, except that the                                  sign of a number is flush left.      \sa setFieldAlignment() */
end_comment
begin_comment
comment|/*! \enum QTextStream::NumberFlag      This enum specifies various flags that can be set to affect the     output of integers, \c{float}s, and \c{double}s.      \value ShowBase  Show the base as a prefix if the base                      is 16 ("0x"), 8 ("0"), or 2 ("0b").     \value ForcePoint  Always put the decimal separator in numbers, even if                        there are no decimals.     \value ForceSign  Always put the sign in numbers, even for positive numbers.     \value UppercaseBase  Use uppercase versions of base prefixes ("0X", "0B").     \value UppercaseDigits  Use uppercase letters for expressing                             digits 10 to 35 instead of lowercase.      \sa setNumberFlags() */
end_comment
begin_comment
comment|/*! \enum QTextStream::Status      This enum describes the current status of the text stream.      \value Ok               The text stream is operating normally.     \value ReadPastEnd      The text stream has read past the end of the                             data in the underlying device.     \value ReadCorruptData  The text stream has read corrupt data.     \value WriteFailed      The text stream cannot write to the underlying device.      \sa status() */
end_comment
begin_include
include|#
directive|include
file|"qtextstream.h"
end_include
begin_include
include|#
directive|include
file|"private/qtextstream_p.h"
end_include
begin_include
include|#
directive|include
file|"qbuffer.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qnumeric.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_WINCE
end_ifndef
begin_include
include|#
directive|include
file|<locale.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"private/qlocale_p.h"
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<new>
end_include
begin_if
if|#
directive|if
name|defined
name|QTEXTSTREAM_DEBUG
end_if
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|// Returns a human readable representation of the first \a len
comment|// characters in \a data.
DECL|function|qt_prettyDebug
specifier|static
name|QByteArray
name|qt_prettyDebug
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|maxSize
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
condition|)
return|return
literal|"(null)"
return|;
name|QByteArray
name|out
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|char
name|c
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|int
argument_list|(
name|uchar
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|out
operator|+=
name|c
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|out
operator|+=
literal|"\\n"
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|out
operator|+=
literal|"\\r"
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|out
operator|+=
literal|"\\t"
expr_stmt|;
break|break;
default|default:
name|QString
name|tmp
decl_stmt|;
name|tmp
operator|.
name|sprintf
argument_list|(
literal|"\\x%x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|out
operator|+=
name|tmp
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|<
name|maxSize
condition|)
name|out
operator|+=
literal|"..."
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// A precondition macro
end_comment
begin_define
DECL|macro|Q_VOID
define|#
directive|define
name|Q_VOID
end_define
begin_define
DECL|macro|CHECK_VALID_STREAM
define|#
directive|define
name|CHECK_VALID_STREAM
parameter_list|(
name|x
parameter_list|)
value|do { \     if (!d->string&& !d->device) { \         qWarning("QTextStream: No device"); \         return x; \     } } while (0)
end_define
begin_comment
comment|// Base implementations of operator>> for ints and reals
end_comment
begin_define
DECL|macro|IMPLEMENT_STREAM_RIGHT_INT_OPERATOR
define|#
directive|define
name|IMPLEMENT_STREAM_RIGHT_INT_OPERATOR
parameter_list|(
name|type
parameter_list|)
value|do { \     Q_D(QTextStream); \     CHECK_VALID_STREAM(*this); \     qulonglong tmp; \     switch (d->getNumber(&tmp)) { \     case QTextStreamPrivate::npsOk: \         i = (type)tmp; \         break; \     case QTextStreamPrivate::npsMissingDigit: \     case QTextStreamPrivate::npsInvalidPrefix: \         i = (type)0; \         setStatus(atEnd() ? QTextStream::ReadPastEnd : QTextStream::ReadCorruptData); \         break; \     } \     return *this; } while (0)
end_define
begin_define
DECL|macro|IMPLEMENT_STREAM_RIGHT_REAL_OPERATOR
define|#
directive|define
name|IMPLEMENT_STREAM_RIGHT_REAL_OPERATOR
parameter_list|(
name|type
parameter_list|)
value|do { \     Q_D(QTextStream); \     CHECK_VALID_STREAM(*this); \     double tmp; \     if (d->getReal(&tmp)) { \         f = (type)tmp; \     } else { \         f = (type)0; \         setStatus(atEnd() ? QTextStream::ReadPastEnd : QTextStream::ReadCorruptData); \     } \     return *this; } while (0)
end_define
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|//-------------------------------------------------------------------
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QTextStreamPrivate
name|QTextStreamPrivate
operator|::
name|QTextStreamPrivate
parameter_list|(
name|QTextStream
modifier|*
name|q_ptr
parameter_list|)
member_init_list|:
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|readConverterSavedState
argument_list|(
literal|0
argument_list|)
member_init_list|,
endif|#
directive|endif
name|readConverterSavedStateOffset
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|locale
argument_list|(
name|QLocale
operator|::
name|c
argument_list|()
argument_list|)
block|{
name|this
operator|->
name|q_ptr
operator|=
name|q_ptr
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_destructor
DECL|function|~QTextStreamPrivate
name|QTextStreamPrivate
operator|::
name|~
name|QTextStreamPrivate
parameter_list|()
block|{
if|if
condition|(
name|deleteDevice
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|device
operator|->
name|blockSignals
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|delete
name|device
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
operator|delete
name|readConverterSavedState
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
end_ifndef
begin_function
DECL|function|resetCodecConverterStateHelper
specifier|static
name|void
name|resetCodecConverterStateHelper
parameter_list|(
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
parameter_list|)
block|{
name|state
operator|->
name|~
name|ConverterState
argument_list|()
expr_stmt|;
operator|new
operator|(
name|state
operator|)
name|QTextCodec
operator|::
name|ConverterState
expr_stmt|;
block|}
end_function
begin_function
DECL|function|copyConverterStateHelper
specifier|static
name|void
name|copyConverterStateHelper
parameter_list|(
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|dest
parameter_list|,
specifier|const
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|src
parameter_list|)
block|{
comment|// ### QTextCodec::ConverterState's copy constructors and assignments are
comment|// private. This function copies the structure manually.
name|Q_ASSERT
argument_list|(
operator|!
name|src
operator|->
name|d
argument_list|)
expr_stmt|;
name|dest
operator|->
name|flags
operator|=
name|src
operator|->
name|flags
expr_stmt|;
name|dest
operator|->
name|invalidChars
operator|=
name|src
operator|->
name|invalidChars
expr_stmt|;
name|dest
operator|->
name|state_data
index|[
literal|0
index|]
operator|=
name|src
operator|->
name|state_data
index|[
literal|0
index|]
expr_stmt|;
name|dest
operator|->
name|state_data
index|[
literal|1
index|]
operator|=
name|src
operator|->
name|state_data
index|[
literal|1
index|]
expr_stmt|;
name|dest
operator|->
name|state_data
index|[
literal|2
index|]
operator|=
name|src
operator|->
name|state_data
index|[
literal|2
index|]
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|reset
name|void
name|QTextStreamPrivate
operator|::
name|Params
operator|::
name|reset
parameter_list|()
block|{
name|realNumberPrecision
operator|=
literal|6
expr_stmt|;
name|integerBase
operator|=
literal|0
expr_stmt|;
name|fieldWidth
operator|=
literal|0
expr_stmt|;
name|padChar
operator|=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|fieldAlignment
operator|=
name|QTextStream
operator|::
name|AlignRight
expr_stmt|;
name|realNumberNotation
operator|=
name|QTextStream
operator|::
name|SmartNotation
expr_stmt|;
name|numberFlags
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|reset
name|void
name|QTextStreamPrivate
operator|::
name|reset
parameter_list|()
block|{
name|params
operator|.
name|reset
argument_list|()
expr_stmt|;
name|device
operator|=
literal|0
expr_stmt|;
name|deleteDevice
operator|=
literal|false
expr_stmt|;
name|string
operator|=
literal|0
expr_stmt|;
name|stringOffset
operator|=
literal|0
expr_stmt|;
name|stringOpenMode
operator|=
name|QIODevice
operator|::
name|NotOpen
expr_stmt|;
name|readBufferOffset
operator|=
literal|0
expr_stmt|;
name|readBufferStartDevicePos
operator|=
literal|0
expr_stmt|;
name|lastTokenSize
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|codec
operator|=
name|QTextCodec
operator|::
name|codecForLocale
argument_list|()
expr_stmt|;
name|resetCodecConverterStateHelper
argument_list|(
operator|&
name|readConverterState
argument_list|)
expr_stmt|;
name|resetCodecConverterStateHelper
argument_list|(
operator|&
name|writeConverterState
argument_list|)
expr_stmt|;
operator|delete
name|readConverterSavedState
expr_stmt|;
name|readConverterSavedState
operator|=
literal|0
expr_stmt|;
name|writeConverterState
operator|.
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
name|autoDetectUnicode
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|fillReadBuffer
name|bool
name|QTextStreamPrivate
operator|::
name|fillReadBuffer
parameter_list|(
name|qint64
name|maxBytes
parameter_list|)
block|{
comment|// no buffer next to the QString itself; this function should only
comment|// be called internally, for devices.
name|Q_ASSERT
argument_list|(
operator|!
name|string
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|device
argument_list|)
expr_stmt|;
comment|// handle text translation and bypass the Text flag in the device.
name|bool
name|textModeEnabled
init|=
name|device
operator|->
name|isTextModeEnabled
argument_list|()
decl_stmt|;
if|if
condition|(
name|textModeEnabled
condition|)
name|device
operator|->
name|setTextModeEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// read raw data into a temporary buffer
name|char
name|buf
index|[
name|QTEXTSTREAM_BUFFERSIZE
index|]
decl_stmt|;
name|qint64
name|bytesRead
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
comment|// On Windows, there is no non-blocking stdin - so we fall back to reading
comment|// lines instead. If there is no QOBJECT, we read lines for all sequential
comment|// devices; otherwise, we read lines only for stdin.
name|QFile
modifier|*
name|file
init|=
literal|0
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|->
name|isSequential
argument_list|()
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_QOBJECT
argument_list|)
operator|&&
operator|(
name|file
operator|=
name|qobject_cast
argument_list|<
name|QFile
operator|*
argument_list|>
argument_list|(
name|device
argument_list|)
operator|)
operator|&&
name|file
operator|->
name|handle
argument_list|()
operator|==
literal|0
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|maxBytes
operator|!=
operator|-
literal|1
condition|)
name|bytesRead
operator|=
name|device
operator|->
name|readLine
argument_list|(
name|buf
argument_list|,
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|maxBytes
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bytesRead
operator|=
name|device
operator|->
name|readLine
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|maxBytes
operator|!=
operator|-
literal|1
condition|)
name|bytesRead
operator|=
name|device
operator|->
name|read
argument_list|(
name|buf
argument_list|,
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|maxBytes
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bytesRead
operator|=
name|device
operator|->
name|read
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
comment|// codec auto detection, explicitly defaults to locale encoding if the
comment|// codec has been set to 0.
if|if
condition|(
operator|!
name|codec
operator|||
name|autoDetectUnicode
condition|)
block|{
name|autoDetectUnicode
operator|=
literal|false
expr_stmt|;
name|codec
operator|=
name|QTextCodec
operator|::
name|codecForUtfText
argument_list|(
name|QByteArray
operator|::
name|fromRawData
argument_list|(
name|buf
argument_list|,
name|bytesRead
argument_list|)
argument_list|,
name|codec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|codec
condition|)
block|{
name|codec
operator|=
name|QTextCodec
operator|::
name|codecForLocale
argument_list|()
expr_stmt|;
name|writeConverterState
operator|.
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStreamPrivate::fillReadBuffer(), using %s codec"
argument_list|,
name|codec
operator|->
name|name
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStreamPrivate::fillReadBuffer(), device->read(\"%s\", %d) == %d"
argument_list|,
name|qt_prettyDebug
argument_list|(
name|buf
argument_list|,
name|qMin
argument_list|(
literal|32
argument_list|,
name|int
argument_list|(
name|bytesRead
argument_list|)
argument_list|)
argument_list|,
name|int
argument_list|(
name|bytesRead
argument_list|)
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|int
argument_list|(
name|bytesRead
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bytesRead
operator|<=
literal|0
condition|)
return|return
literal|false
return|;
name|int
name|oldReadBufferSize
init|=
name|readBuffer
operator|.
name|size
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
comment|// convert to unicode
name|readBuffer
operator|+=
name|codec
operator|->
name|toUnicode
argument_list|(
name|buf
argument_list|,
name|bytesRead
argument_list|,
operator|&
name|readConverterState
argument_list|)
expr_stmt|;
else|#
directive|else
name|readBuffer
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QByteArray
argument_list|(
name|buf
argument_list|,
name|bytesRead
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// reset the Text flag.
if|if
condition|(
name|textModeEnabled
condition|)
name|device
operator|->
name|setTextModeEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// remove all '\r\n' in the string.
if|if
condition|(
name|readBuffer
operator|.
name|size
argument_list|()
operator|>
name|oldReadBufferSize
operator|&&
name|textModeEnabled
condition|)
block|{
name|QChar
name|CR
init|=
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
decl_stmt|;
name|QChar
modifier|*
name|writePtr
init|=
name|readBuffer
operator|.
name|data
argument_list|()
operator|+
name|oldReadBufferSize
decl_stmt|;
name|QChar
modifier|*
name|readPtr
init|=
name|readBuffer
operator|.
name|data
argument_list|()
operator|+
name|oldReadBufferSize
decl_stmt|;
name|QChar
modifier|*
name|endPtr
init|=
name|readBuffer
operator|.
name|data
argument_list|()
operator|+
name|readBuffer
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|oldReadBufferSize
decl_stmt|;
if|if
condition|(
name|readPtr
operator|<
name|endPtr
condition|)
block|{
comment|// Cut-off to avoid unnecessary self-copying.
while|while
condition|(
operator|*
name|readPtr
operator|++
operator|!=
name|CR
condition|)
block|{
operator|++
name|n
expr_stmt|;
if|if
condition|(
operator|++
name|writePtr
operator|==
name|endPtr
condition|)
break|break;
block|}
block|}
while|while
condition|(
name|readPtr
operator|<
name|endPtr
condition|)
block|{
name|QChar
name|ch
init|=
operator|*
name|readPtr
operator|++
decl_stmt|;
if|if
condition|(
name|ch
operator|!=
name|CR
condition|)
block|{
operator|*
name|writePtr
operator|++
operator|=
name|ch
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|n
operator|<
name|readBufferOffset
condition|)
operator|--
name|readBufferOffset
expr_stmt|;
operator|--
name|bytesRead
expr_stmt|;
block|}
operator|++
name|n
expr_stmt|;
block|}
name|readBuffer
operator|.
name|resize
argument_list|(
name|writePtr
operator|-
name|readBuffer
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStreamPrivate::fillReadBuffer() read %d bytes from device. readBuffer = [%s]"
argument_list|,
name|int
argument_list|(
name|bytesRead
argument_list|)
argument_list|,
name|qt_prettyDebug
argument_list|(
name|readBuffer
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|readBuffer
operator|.
name|size
argument_list|()
argument_list|,
name|readBuffer
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|resetReadBuffer
name|void
name|QTextStreamPrivate
operator|::
name|resetReadBuffer
parameter_list|()
block|{
name|readBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|readBufferOffset
operator|=
literal|0
expr_stmt|;
name|readBufferStartDevicePos
operator|=
operator|(
name|device
condition|?
name|device
operator|->
name|pos
argument_list|()
else|:
literal|0
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|flushWriteBuffer
name|void
name|QTextStreamPrivate
operator|::
name|flushWriteBuffer
parameter_list|()
block|{
comment|// no buffer next to the QString itself; this function should only
comment|// be called internally, for devices.
if|if
condition|(
name|string
operator|||
operator|!
name|device
condition|)
return|return;
comment|// Stream went bye-bye already. Appending further data may succeed again,
comment|// but would create a corrupted stream anyway.
if|if
condition|(
name|status
operator|!=
name|QTextStream
operator|::
name|Ok
condition|)
return|return;
if|if
condition|(
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
comment|// handle text translation and bypass the Text flag in the device.
name|bool
name|textModeEnabled
init|=
name|device
operator|->
name|isTextModeEnabled
argument_list|()
decl_stmt|;
if|if
condition|(
name|textModeEnabled
condition|)
block|{
name|device
operator|->
name|setTextModeEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|writeBuffer
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
if|if
condition|(
operator|!
name|codec
condition|)
name|codec
operator|=
name|QTextCodec
operator|::
name|codecForLocale
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStreamPrivate::flushWriteBuffer(), using %s codec (%s generating BOM)"
argument_list|,
name|codec
operator|->
name|name
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|writeConverterState
operator|.
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
condition|?
literal|"not"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// convert from unicode to raw data
name|QByteArray
name|data
init|=
name|codec
operator|->
name|fromUnicode
argument_list|(
name|writeBuffer
operator|.
name|data
argument_list|()
argument_list|,
name|writeBuffer
operator|.
name|size
argument_list|()
argument_list|,
operator|&
name|writeConverterState
argument_list|)
decl_stmt|;
else|#
directive|else
name|QByteArray
name|data
init|=
name|writeBuffer
operator|.
name|toLocal8Bit
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|writeBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// write raw data to the device
name|qint64
name|bytesWritten
init|=
name|device
operator|->
name|write
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStreamPrivate::flushWriteBuffer(), device->write(\"%s\") == %d"
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
operator|.
name|constData
argument_list|()
argument_list|,
name|qMin
argument_list|(
name|data
operator|.
name|size
argument_list|()
argument_list|,
literal|32
argument_list|)
argument_list|,
name|data
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|int
argument_list|(
name|bytesWritten
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bytesWritten
operator|<=
literal|0
condition|)
block|{
name|status
operator|=
name|QTextStream
operator|::
name|WriteFailed
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
comment|// replace the text flag
if|if
condition|(
name|textModeEnabled
condition|)
name|device
operator|->
name|setTextModeEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// flush the file
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|QFileDevice
modifier|*
name|file
init|=
name|qobject_cast
argument_list|<
name|QFileDevice
operator|*
argument_list|>
argument_list|(
name|device
argument_list|)
decl_stmt|;
name|bool
name|flushed
init|=
operator|!
name|file
operator|||
name|file
operator|->
name|flush
argument_list|()
decl_stmt|;
else|#
directive|else
name|bool
name|flushed
init|=
literal|true
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStreamPrivate::flushWriteBuffer() wrote %d bytes"
argument_list|,
name|int
argument_list|(
name|bytesWritten
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|flushed
operator|||
name|bytesWritten
operator|!=
name|qint64
argument_list|(
name|data
operator|.
name|size
argument_list|()
argument_list|)
condition|)
name|status
operator|=
name|QTextStream
operator|::
name|WriteFailed
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read
name|QString
name|QTextStreamPrivate
operator|::
name|read
parameter_list|(
name|int
name|maxlen
parameter_list|)
block|{
name|QString
name|ret
decl_stmt|;
if|if
condition|(
name|string
condition|)
block|{
name|lastTokenSize
operator|=
name|qMin
argument_list|(
name|maxlen
argument_list|,
name|string
operator|->
name|size
argument_list|()
operator|-
name|stringOffset
argument_list|)
expr_stmt|;
name|ret
operator|=
name|string
operator|->
name|mid
argument_list|(
name|stringOffset
argument_list|,
name|lastTokenSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|readBuffer
operator|.
name|size
argument_list|()
operator|-
name|readBufferOffset
operator|<
name|maxlen
operator|&&
name|fillReadBuffer
argument_list|()
condition|)
empty_stmt|;
name|lastTokenSize
operator|=
name|qMin
argument_list|(
name|maxlen
argument_list|,
name|readBuffer
operator|.
name|size
argument_list|()
operator|-
name|readBufferOffset
argument_list|)
expr_stmt|;
name|ret
operator|=
name|readBuffer
operator|.
name|mid
argument_list|(
name|readBufferOffset
argument_list|,
name|lastTokenSize
argument_list|)
expr_stmt|;
block|}
name|consumeLastToken
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStreamPrivate::read() maxlen = %d, token length = %d"
argument_list|,
name|maxlen
argument_list|,
name|ret
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Scans no more than \a maxlen QChars in the current buffer for the     first \a delimiter. Stores a pointer to the start offset of the     token in \a ptr, and the length in QChars in \a length. */
end_comment
begin_function
DECL|function|scan
name|bool
name|QTextStreamPrivate
operator|::
name|scan
parameter_list|(
specifier|const
name|QChar
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|length
parameter_list|,
name|int
name|maxlen
parameter_list|,
name|TokenDelimiter
name|delimiter
parameter_list|)
block|{
name|int
name|totalSize
init|=
literal|0
decl_stmt|;
name|int
name|delimSize
init|=
literal|0
decl_stmt|;
name|bool
name|consumeDelimiter
init|=
literal|false
decl_stmt|;
name|bool
name|foundToken
init|=
literal|false
decl_stmt|;
name|int
name|startOffset
init|=
name|device
condition|?
name|readBufferOffset
else|:
name|stringOffset
decl_stmt|;
name|QChar
name|lastChar
decl_stmt|;
name|bool
name|canStillReadFromDevice
init|=
literal|true
decl_stmt|;
do|do
block|{
name|int
name|endOffset
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|chPtr
decl_stmt|;
if|if
condition|(
name|device
condition|)
block|{
name|chPtr
operator|=
name|readBuffer
operator|.
name|constData
argument_list|()
expr_stmt|;
name|endOffset
operator|=
name|readBuffer
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|chPtr
operator|=
name|string
operator|->
name|constData
argument_list|()
expr_stmt|;
name|endOffset
operator|=
name|string
operator|->
name|size
argument_list|()
expr_stmt|;
block|}
name|chPtr
operator|+=
name|startOffset
expr_stmt|;
for|for
control|(
init|;
operator|!
name|foundToken
operator|&&
name|startOffset
operator|<
name|endOffset
operator|&&
operator|(
operator|!
name|maxlen
operator|||
name|totalSize
operator|<
name|maxlen
operator|)
condition|;
operator|++
name|startOffset
control|)
block|{
specifier|const
name|QChar
name|ch
init|=
operator|*
name|chPtr
operator|++
decl_stmt|;
operator|++
name|totalSize
expr_stmt|;
switch|switch
condition|(
name|delimiter
condition|)
block|{
case|case
name|Space
case|:
if|if
condition|(
name|ch
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|foundToken
operator|=
literal|true
expr_stmt|;
name|delimSize
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|NotSpace
case|:
if|if
condition|(
operator|!
name|ch
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|foundToken
operator|=
literal|true
expr_stmt|;
name|delimSize
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|EndOfLine
case|:
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
condition|)
block|{
name|foundToken
operator|=
literal|true
expr_stmt|;
name|delimSize
operator|=
operator|(
name|lastChar
operator|==
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|consumeDelimiter
operator|=
literal|true
expr_stmt|;
block|}
name|lastChar
operator|=
name|ch
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|foundToken
operator|&&
operator|(
operator|!
name|maxlen
operator|||
name|totalSize
operator|<
name|maxlen
operator|)
operator|&&
operator|(
name|device
operator|&&
operator|(
name|canStillReadFromDevice
operator|=
name|fillReadBuffer
argument_list|()
operator|)
operator|)
condition|)
do|;
comment|// if the token was not found, but we reached the end of input,
comment|// then we accept what we got. if we are not at the end of input,
comment|// we return false.
if|if
condition|(
operator|!
name|foundToken
operator|&&
operator|(
operator|!
name|maxlen
operator|||
name|totalSize
operator|<
name|maxlen
operator|)
operator|&&
operator|(
name|totalSize
operator|==
literal|0
operator|||
operator|(
name|string
operator|&&
name|stringOffset
operator|+
name|totalSize
operator|<
name|string
operator|->
name|size
argument_list|()
operator|)
operator|||
operator|(
name|device
operator|&&
operator|!
name|device
operator|->
name|atEnd
argument_list|()
operator|&&
name|canStillReadFromDevice
operator|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStreamPrivate::scan() did not find the token."
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
comment|// if we find a '\r' at the end of the data when reading lines,
comment|// don't make it part of the line.
if|if
condition|(
name|delimiter
operator|==
name|EndOfLine
operator|&&
name|totalSize
operator|>
literal|0
operator|&&
operator|!
name|foundToken
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|string
operator|&&
name|stringOffset
operator|+
name|totalSize
operator|==
name|string
operator|->
name|size
argument_list|()
operator|)
operator|||
operator|(
name|device
operator|&&
name|device
operator|->
name|atEnd
argument_list|()
operator|)
operator|)
operator|&&
name|lastChar
operator|==
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
condition|)
block|{
name|consumeDelimiter
operator|=
literal|true
expr_stmt|;
operator|++
name|delimSize
expr_stmt|;
block|}
block|}
comment|// set the read offset and length of the token
if|if
condition|(
name|length
condition|)
operator|*
name|length
operator|=
name|totalSize
operator|-
name|delimSize
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
operator|*
name|ptr
operator|=
name|readPtr
argument_list|()
expr_stmt|;
comment|// update last token size. the callee will call consumeLastToken() when
comment|// done.
name|lastTokenSize
operator|=
name|totalSize
expr_stmt|;
if|if
condition|(
operator|!
name|consumeDelimiter
condition|)
name|lastTokenSize
operator|-=
name|delimSize
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStreamPrivate::scan(%p, %p, %d, %x) token length = %d, delimiter = %d"
argument_list|,
name|ptr
argument_list|,
name|length
argument_list|,
name|maxlen
argument_list|,
operator|(
name|int
operator|)
name|delimiter
argument_list|,
name|totalSize
operator|-
name|delimSize
argument_list|,
name|delimSize
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|readPtr
specifier|inline
specifier|const
name|QChar
modifier|*
name|QTextStreamPrivate
operator|::
name|readPtr
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|readBufferOffset
operator|<=
name|readBuffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
condition|)
return|return
name|string
operator|->
name|constData
argument_list|()
operator|+
name|stringOffset
return|;
return|return
name|readBuffer
operator|.
name|constData
argument_list|()
operator|+
name|readBufferOffset
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|consumeLastToken
specifier|inline
name|void
name|QTextStreamPrivate
operator|::
name|consumeLastToken
parameter_list|()
block|{
if|if
condition|(
name|lastTokenSize
condition|)
name|consume
argument_list|(
name|lastTokenSize
argument_list|)
expr_stmt|;
name|lastTokenSize
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|consume
specifier|inline
name|void
name|QTextStreamPrivate
operator|::
name|consume
parameter_list|(
name|int
name|size
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStreamPrivate::consume(%d)"
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|string
condition|)
block|{
name|stringOffset
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|stringOffset
operator|>
name|string
operator|->
name|size
argument_list|()
condition|)
name|stringOffset
operator|=
name|string
operator|->
name|size
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|readBufferOffset
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|readBufferOffset
operator|>=
name|readBuffer
operator|.
name|size
argument_list|()
condition|)
block|{
name|readBufferOffset
operator|=
literal|0
expr_stmt|;
name|readBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|saveConverterState
argument_list|(
name|device
operator|->
name|pos
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readBufferOffset
operator|>
name|QTEXTSTREAM_BUFFERSIZE
condition|)
block|{
name|readBuffer
operator|=
name|readBuffer
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|readBufferOffset
argument_list|)
expr_stmt|;
name|readConverterSavedStateOffset
operator|+=
name|readBufferOffset
expr_stmt|;
name|readBufferOffset
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|saveConverterState
specifier|inline
name|void
name|QTextStreamPrivate
operator|::
name|saveConverterState
parameter_list|(
name|qint64
name|newPos
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
if|if
condition|(
name|readConverterState
operator|.
name|d
condition|)
block|{
comment|// converter cannot be copied, so don't save anything
comment|// don't update readBufferStartDevicePos either
return|return;
block|}
if|if
condition|(
operator|!
name|readConverterSavedState
condition|)
name|readConverterSavedState
operator|=
operator|new
name|QTextCodec
operator|::
name|ConverterState
expr_stmt|;
name|copyConverterStateHelper
argument_list|(
name|readConverterSavedState
argument_list|,
operator|&
name|readConverterState
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|readBufferStartDevicePos
operator|=
name|newPos
expr_stmt|;
name|readConverterSavedStateOffset
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|restoreToSavedConverterState
specifier|inline
name|void
name|QTextStreamPrivate
operator|::
name|restoreToSavedConverterState
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
if|if
condition|(
name|readConverterSavedState
condition|)
block|{
comment|// we have a saved state
comment|// that means the converter can be copied
name|copyConverterStateHelper
argument_list|(
operator|&
name|readConverterState
argument_list|,
name|readConverterSavedState
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the only state we could save was the initial
comment|// so reset to that
name|resetCodecConverterStateHelper
argument_list|(
operator|&
name|readConverterState
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|write
specifier|inline
name|void
name|QTextStreamPrivate
operator|::
name|write
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
block|{
if|if
condition|(
name|string
condition|)
block|{
comment|// ### What about seek()??
name|string
operator|->
name|append
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeBuffer
operator|+=
name|data
expr_stmt|;
if|if
condition|(
name|writeBuffer
operator|.
name|size
argument_list|()
operator|>
name|QTEXTSTREAM_BUFFERSIZE
condition|)
name|flushWriteBuffer
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|getChar
specifier|inline
name|bool
name|QTextStreamPrivate
operator|::
name|getChar
parameter_list|(
name|QChar
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|(
name|string
operator|&&
name|stringOffset
operator|==
name|string
operator|->
name|size
argument_list|()
operator|)
operator|||
operator|(
name|device
operator|&&
name|readBuffer
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|fillReadBuffer
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|ch
condition|)
operator|*
name|ch
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|ch
condition|)
operator|*
name|ch
operator|=
operator|*
name|readPtr
argument_list|()
expr_stmt|;
name|consume
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|ungetChar
specifier|inline
name|void
name|QTextStreamPrivate
operator|::
name|ungetChar
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
if|if
condition|(
name|string
condition|)
block|{
if|if
condition|(
name|stringOffset
operator|==
literal|0
condition|)
name|string
operator|->
name|prepend
argument_list|(
name|ch
argument_list|)
expr_stmt|;
else|else
operator|(
operator|*
name|string
operator|)
index|[
operator|--
name|stringOffset
index|]
operator|=
name|ch
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|readBufferOffset
operator|==
literal|0
condition|)
block|{
name|readBuffer
operator|.
name|prepend
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|readBuffer
index|[
operator|--
name|readBufferOffset
index|]
operator|=
name|ch
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|putString
specifier|inline
name|void
name|QTextStreamPrivate
operator|::
name|putString
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|bool
name|number
parameter_list|)
block|{
name|QString
name|tmp
init|=
name|s
decl_stmt|;
comment|// handle padding
name|int
name|padSize
init|=
name|params
operator|.
name|fieldWidth
operator|-
name|s
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|padSize
operator|>
literal|0
condition|)
block|{
name|QString
name|pad
argument_list|(
name|padSize
argument_list|,
name|params
operator|.
name|padChar
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|params
operator|.
name|fieldAlignment
condition|)
block|{
case|case
name|QTextStream
operator|::
name|AlignLeft
case|:
name|tmp
operator|.
name|append
argument_list|(
name|pad
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextStream
operator|::
name|AlignRight
case|:
case|case
name|QTextStream
operator|::
name|AlignAccountingStyle
case|:
name|tmp
operator|.
name|prepend
argument_list|(
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|fieldAlignment
operator|==
name|QTextStream
operator|::
name|AlignAccountingStyle
operator|&&
name|number
condition|)
block|{
specifier|const
name|QChar
name|sign
init|=
name|s
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|?
name|s
operator|.
name|at
argument_list|(
literal|0
argument_list|)
else|:
name|QChar
argument_list|()
decl_stmt|;
if|if
condition|(
name|sign
operator|==
name|locale
operator|.
name|negativeSign
argument_list|()
operator|||
name|sign
operator|==
name|locale
operator|.
name|positiveSign
argument_list|()
condition|)
block|{
name|QChar
modifier|*
name|data
init|=
name|tmp
operator|.
name|data
argument_list|()
decl_stmt|;
name|data
index|[
name|padSize
index|]
operator|=
name|tmp
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
name|sign
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QTextStream
operator|::
name|AlignCenter
case|:
name|tmp
operator|.
name|prepend
argument_list|(
name|QString
argument_list|(
name|padSize
operator|/
literal|2
argument_list|,
name|params
operator|.
name|padChar
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|append
argument_list|(
name|QString
argument_list|(
name|padSize
operator|-
name|padSize
operator|/
literal|2
argument_list|,
name|params
operator|.
name|padChar
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|QByteArray
name|a
init|=
name|s
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
name|QByteArray
name|b
init|=
name|tmp
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
name|qDebug
argument_list|(
literal|"QTextStreamPrivate::putString(\"%s\") calls write(\"%s\")"
argument_list|,
name|qt_prettyDebug
argument_list|(
name|a
operator|.
name|constData
argument_list|()
argument_list|,
name|a
operator|.
name|size
argument_list|()
argument_list|,
name|qMax
argument_list|(
literal|16
argument_list|,
name|a
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|qt_prettyDebug
argument_list|(
name|b
operator|.
name|constData
argument_list|()
argument_list|,
name|b
operator|.
name|size
argument_list|()
argument_list|,
name|qMax
argument_list|(
literal|16
argument_list|,
name|b
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|write
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs a QTextStream. Before you can use it for reading or     writing, you must assign a device or a string.      \sa setDevice(), setString() */
end_comment
begin_constructor
DECL|function|QTextStream
name|QTextStream
operator|::
name|QTextStream
parameter_list|()
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QTextStreamPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStream::QTextStream()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|status
operator|=
name|Ok
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QTextStream that operates on \a device. */
end_comment
begin_constructor
DECL|function|QTextStream
name|QTextStream
operator|::
name|QTextStream
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QTextStreamPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStream::QTextStream(QIODevice *device == *%p)"
argument_list|,
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|=
name|device
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|d
operator|->
name|deviceClosedNotifier
operator|.
name|setupDevice
argument_list|(
name|this
argument_list|,
name|d
operator|->
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|status
operator|=
name|Ok
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QTextStream that operates on \a string, using \a     openMode to define the open mode. */
end_comment
begin_constructor
DECL|function|QTextStream
name|QTextStream
operator|::
name|QTextStream
parameter_list|(
name|QString
modifier|*
name|string
parameter_list|,
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QTextStreamPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStream::QTextStream(QString *string == *%p, openMode = %d)"
argument_list|,
name|string
argument_list|,
name|int
argument_list|(
name|openMode
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|string
operator|=
name|string
expr_stmt|;
name|d
operator|->
name|stringOpenMode
operator|=
name|openMode
expr_stmt|;
name|d
operator|->
name|status
operator|=
name|Ok
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QTextStream that operates on \a array, using \a     openMode to define the open mode. Internally, the array is wrapped     by a QBuffer. */
end_comment
begin_constructor
DECL|function|QTextStream
name|QTextStream
operator|::
name|QTextStream
parameter_list|(
name|QByteArray
modifier|*
name|array
parameter_list|,
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QTextStreamPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStream::QTextStream(QByteArray *array == *%p, openMode = %d)"
argument_list|,
name|array
argument_list|,
name|int
argument_list|(
name|openMode
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|=
operator|new
name|QBuffer
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|->
name|open
argument_list|(
name|openMode
argument_list|)
expr_stmt|;
name|d
operator|->
name|deleteDevice
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|d
operator|->
name|deviceClosedNotifier
operator|.
name|setupDevice
argument_list|(
name|this
argument_list|,
name|d
operator|->
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|status
operator|=
name|Ok
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QTextStream that operates on \a array, using \a     openMode to define the open mode. The array is accessed as     read-only, regardless of the values in \a openMode.      This constructor is convenient for working on constant     strings. Example:      \snippet code/src_corelib_io_qtextstream.cpp 3 */
end_comment
begin_constructor
DECL|function|QTextStream
name|QTextStream
operator|::
name|QTextStream
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|array
parameter_list|,
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QTextStreamPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStream::QTextStream(const QByteArray&array == *(%p), openMode = %d)"
argument_list|,
operator|&
name|array
argument_list|,
name|int
argument_list|(
name|openMode
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QBuffer
modifier|*
name|buffer
init|=
operator|new
name|QBuffer
decl_stmt|;
name|buffer
operator|->
name|setData
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|open
argument_list|(
name|openMode
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|=
name|buffer
expr_stmt|;
name|d
operator|->
name|deleteDevice
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|d
operator|->
name|deviceClosedNotifier
operator|.
name|setupDevice
argument_list|(
name|this
argument_list|,
name|d
operator|->
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|status
operator|=
name|Ok
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QTextStream that operates on \a fileHandle, using \a     openMode to define the open mode. Internally, a QFile is created     to handle the FILE pointer.      This constructor is useful for working directly with the common     FILE based input and output streams: stdin, stdout and stderr. Example:      \snippet code/src_corelib_io_qtextstream.cpp 4 */
end_comment
begin_constructor
DECL|function|QTextStream
name|QTextStream
operator|::
name|QTextStream
parameter_list|(
name|FILE
modifier|*
name|fileHandle
parameter_list|,
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QTextStreamPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStream::QTextStream(FILE *fileHandle = %p, openMode = %d)"
argument_list|,
name|fileHandle
argument_list|,
name|int
argument_list|(
name|openMode
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QFile
modifier|*
name|file
init|=
operator|new
name|QFile
decl_stmt|;
name|file
operator|->
name|open
argument_list|(
name|fileHandle
argument_list|,
name|openMode
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|=
name|file
expr_stmt|;
name|d
operator|->
name|deleteDevice
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|d
operator|->
name|deviceClosedNotifier
operator|.
name|setupDevice
argument_list|(
name|this
argument_list|,
name|d
operator|->
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|status
operator|=
name|Ok
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the QTextStream.      If the stream operates on a device, flush() will be called     implicitly. Otherwise, the device is unaffected. */
end_comment
begin_destructor
DECL|function|~QTextStream
name|QTextStream
operator|::
name|~
name|QTextStream
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QTEXTSTREAM_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTextStream::~QTextStream()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|flushWriteBuffer
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Resets QTextStream's formatting options, bringing it back to its     original constructed state. The device, string and any buffered     data is left untouched. */
end_comment
begin_function
DECL|function|reset
name|void
name|QTextStream
operator|::
name|reset
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|params
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Flushes any buffered data waiting to be written to the device.      If QTextStream operates on a string, this function does nothing. */
end_comment
begin_function
DECL|function|flush
name|void
name|QTextStream
operator|::
name|flush
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|flushWriteBuffer
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Seeks to the position \a pos in the device. Returns true on     success; otherwise returns false. */
end_comment
begin_function
DECL|function|seek
name|bool
name|QTextStream
operator|::
name|seek
parameter_list|(
name|qint64
name|pos
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|lastTokenSize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|device
condition|)
block|{
comment|// Empty the write buffer
name|d
operator|->
name|flushWriteBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|device
operator|->
name|seek
argument_list|(
name|pos
argument_list|)
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|resetReadBuffer
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
comment|// Reset the codec converter states.
name|resetCodecConverterStateHelper
argument_list|(
operator|&
name|d
operator|->
name|readConverterState
argument_list|)
expr_stmt|;
name|resetCodecConverterStateHelper
argument_list|(
operator|&
name|d
operator|->
name|writeConverterState
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|readConverterSavedState
expr_stmt|;
name|d
operator|->
name|readConverterSavedState
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|writeConverterState
operator|.
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
comment|// string
if|if
condition|(
name|d
operator|->
name|string
operator|&&
name|pos
operator|<=
name|d
operator|->
name|string
operator|->
name|size
argument_list|()
condition|)
block|{
name|d
operator|->
name|stringOffset
operator|=
name|int
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the device position corresponding to the current position of the     stream, or -1 if an error occurs (e.g., if there is no device or string,     or if there's a device error).      Because QTextStream is buffered, this function may have to     seek the device to reconstruct a valid device position. This     operation can be expensive, so you may want to avoid calling this     function in a tight loop.      \sa seek() */
end_comment
begin_function
DECL|function|pos
name|qint64
name|QTextStream
operator|::
name|pos
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|device
condition|)
block|{
comment|// Cutoff
if|if
condition|(
name|d
operator|->
name|readBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|d
operator|->
name|device
operator|->
name|pos
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|device
operator|->
name|isSequential
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// Seek the device
if|if
condition|(
operator|!
name|d
operator|->
name|device
operator|->
name|seek
argument_list|(
name|d
operator|->
name|readBufferStartDevicePos
argument_list|)
condition|)
return|return
name|qint64
argument_list|(
operator|-
literal|1
argument_list|)
return|;
comment|// Reset the read buffer
name|QTextStreamPrivate
modifier|*
name|thatd
init|=
cast|const_cast
argument_list|<
name|QTextStreamPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|thatd
operator|->
name|readBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|thatd
operator|->
name|restoreToSavedConverterState
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|readBufferStartDevicePos
operator|==
literal|0
condition|)
name|thatd
operator|->
name|autoDetectUnicode
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
comment|// Rewind the device to get to the current position Ensure that
comment|// readBufferOffset is unaffected by fillReadBuffer()
name|int
name|oldReadBufferOffset
init|=
name|d
operator|->
name|readBufferOffset
operator|+
name|d
operator|->
name|readConverterSavedStateOffset
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|readBuffer
operator|.
name|size
argument_list|()
operator|<
name|oldReadBufferOffset
condition|)
block|{
if|if
condition|(
operator|!
name|thatd
operator|->
name|fillReadBuffer
argument_list|(
literal|1
argument_list|)
condition|)
return|return
name|qint64
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
name|thatd
operator|->
name|readBufferOffset
operator|=
name|oldReadBufferOffset
expr_stmt|;
name|thatd
operator|->
name|readConverterSavedStateOffset
operator|=
literal|0
expr_stmt|;
comment|// Return the device position.
return|return
name|d
operator|->
name|device
operator|->
name|pos
argument_list|()
return|;
block|}
if|if
condition|(
name|d
operator|->
name|string
condition|)
return|return
name|d
operator|->
name|stringOffset
return|;
name|qWarning
argument_list|(
literal|"QTextStream::pos: no device"
argument_list|)
expr_stmt|;
return|return
name|qint64
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Reads and discards whitespace from the stream until either a     non-space character is detected, or until atEnd() returns     true. This function is useful when reading a stream character by     character.      Whitespace characters are all characters for which     QChar::isSpace() returns true.      \sa operator>>() */
end_comment
begin_function
DECL|function|skipWhiteSpace
name|void
name|QTextStream
operator|::
name|skipWhiteSpace
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
name|Q_VOID
argument_list|)
expr_stmt|;
name|d
operator|->
name|scan
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|QTextStreamPrivate
operator|::
name|NotSpace
argument_list|)
expr_stmt|;
name|d
operator|->
name|consumeLastToken
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the current device to \a device. If a device has already been     assigned, QTextStream will call flush() before the old device is     replaced.      \note This function resets locale to the default locale ('C')     and codec to the default codec, QTextCodec::codecForLocale().      \sa device(), setString() */
end_comment
begin_function
DECL|function|setDevice
name|void
name|QTextStream
operator|::
name|setDevice
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|deleteDevice
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|d
operator|->
name|deviceClosedNotifier
operator|.
name|disconnect
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|delete
name|d
operator|->
name|device
expr_stmt|;
name|d
operator|->
name|deleteDevice
operator|=
literal|false
expr_stmt|;
block|}
name|d
operator|->
name|reset
argument_list|()
expr_stmt|;
name|d
operator|->
name|status
operator|=
name|Ok
expr_stmt|;
name|d
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|d
operator|->
name|resetReadBuffer
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|d
operator|->
name|deviceClosedNotifier
operator|.
name|setupDevice
argument_list|(
name|this
argument_list|,
name|d
operator|->
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Returns the current device associated with the QTextStream,     or 0 if no device has been assigned.      \sa setDevice(), string() */
end_comment
begin_function
DECL|function|device
name|QIODevice
modifier|*
name|QTextStream
operator|::
name|device
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|device
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the current string to \a string, using the given \a     openMode. If a device has already been assigned, QTextStream will     call flush() before replacing it.      \sa string(), setDevice() */
end_comment
begin_function
DECL|function|setString
name|void
name|QTextStream
operator|::
name|setString
parameter_list|(
name|QString
modifier|*
name|string
parameter_list|,
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|deleteDevice
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|d
operator|->
name|deviceClosedNotifier
operator|.
name|disconnect
argument_list|()
expr_stmt|;
name|d
operator|->
name|device
operator|->
name|blockSignals
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|delete
name|d
operator|->
name|device
expr_stmt|;
name|d
operator|->
name|deleteDevice
operator|=
literal|false
expr_stmt|;
block|}
name|d
operator|->
name|reset
argument_list|()
expr_stmt|;
name|d
operator|->
name|status
operator|=
name|Ok
expr_stmt|;
name|d
operator|->
name|string
operator|=
name|string
expr_stmt|;
name|d
operator|->
name|stringOpenMode
operator|=
name|openMode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current string assigned to the QTextStream, or 0 if no     string has been assigned.      \sa setString(), device() */
end_comment
begin_function
DECL|function|string
name|QString
modifier|*
name|QTextStream
operator|::
name|string
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|string
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the field alignment to \a mode. When used together with     setFieldWidth(), this function allows you to generate formatted     output with text aligned to the left, to the right or center     aligned.      \sa fieldAlignment(), setFieldWidth() */
end_comment
begin_function
DECL|function|setFieldAlignment
name|void
name|QTextStream
operator|::
name|setFieldAlignment
parameter_list|(
name|FieldAlignment
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|params
operator|.
name|fieldAlignment
operator|=
name|mode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current field alignment.      \sa setFieldAlignment(), fieldWidth() */
end_comment
begin_function
DECL|function|fieldAlignment
name|QTextStream
operator|::
name|FieldAlignment
name|QTextStream
operator|::
name|fieldAlignment
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|params
operator|.
name|fieldAlignment
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the pad character to \a ch. The default value is the ASCII     space character (' '), or QChar(0x20). This character is used to     fill in the space in fields when generating text.      Example:      \snippet code/src_corelib_io_qtextstream.cpp 5      The string \c s contains:      \snippet code/src_corelib_io_qtextstream.cpp 6      \sa padChar(), setFieldWidth() */
end_comment
begin_function
DECL|function|setPadChar
name|void
name|QTextStream
operator|::
name|setPadChar
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|params
operator|.
name|padChar
operator|=
name|ch
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current pad character.      \sa setPadChar(), setFieldWidth() */
end_comment
begin_function
DECL|function|padChar
name|QChar
name|QTextStream
operator|::
name|padChar
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|params
operator|.
name|padChar
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the current field width to \a width. If \a width is 0 (the     default), the field width is equal to the length of the generated     text.      \note The field width applies to every element appended to this     stream after this function has been called (e.g., it also pads     endl). This behavior is different from similar classes in the STL,     where the field width only applies to the next element.      \sa fieldWidth(), setPadChar() */
end_comment
begin_function
DECL|function|setFieldWidth
name|void
name|QTextStream
operator|::
name|setFieldWidth
parameter_list|(
name|int
name|width
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|params
operator|.
name|fieldWidth
operator|=
name|width
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current field width.      \sa setFieldWidth() */
end_comment
begin_function
DECL|function|fieldWidth
name|int
name|QTextStream
operator|::
name|fieldWidth
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|params
operator|.
name|fieldWidth
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the current number flags to \a flags. \a flags is a set of     flags from the NumberFlag enum, and describes options for     formatting generated code (e.g., whether or not to always write     the base or sign of a number).      \sa numberFlags(), setIntegerBase(), setRealNumberNotation() */
end_comment
begin_function
DECL|function|setNumberFlags
name|void
name|QTextStream
operator|::
name|setNumberFlags
parameter_list|(
name|NumberFlags
name|flags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|params
operator|.
name|numberFlags
operator|=
name|flags
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current number flags.      \sa setNumberFlags(), integerBase(), realNumberNotation() */
end_comment
begin_function
DECL|function|numberFlags
name|QTextStream
operator|::
name|NumberFlags
name|QTextStream
operator|::
name|numberFlags
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|params
operator|.
name|numberFlags
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the base of integers to \a base, both for reading and for     generating numbers. \a base can be either 2 (binary), 8 (octal),     10 (decimal) or 16 (hexadecimal). If \a base is 0, QTextStream     will attempt to detect the base by inspecting the data on the     stream. When generating numbers, QTextStream assumes base is 10     unless the base has been set explicitly.      \sa integerBase(), QString::number(), setNumberFlags() */
end_comment
begin_function
DECL|function|setIntegerBase
name|void
name|QTextStream
operator|::
name|setIntegerBase
parameter_list|(
name|int
name|base
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|params
operator|.
name|integerBase
operator|=
name|base
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current base of integers. 0 means that the base is     detected when reading, or 10 (decimal) when generating numbers.      \sa setIntegerBase(), QString::number(), numberFlags() */
end_comment
begin_function
DECL|function|integerBase
name|int
name|QTextStream
operator|::
name|integerBase
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|params
operator|.
name|integerBase
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the real number notation to \a notation (SmartNotation,     FixedNotation, ScientificNotation). When reading and generating     numbers, QTextStream uses this value to detect the formatting of     real numbers.      \sa realNumberNotation(), setRealNumberPrecision(), setNumberFlags(), setIntegerBase() */
end_comment
begin_function
DECL|function|setRealNumberNotation
name|void
name|QTextStream
operator|::
name|setRealNumberNotation
parameter_list|(
name|RealNumberNotation
name|notation
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|params
operator|.
name|realNumberNotation
operator|=
name|notation
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current real number notation.      \sa setRealNumberNotation(), realNumberPrecision(), numberFlags(), integerBase() */
end_comment
begin_function
DECL|function|realNumberNotation
name|QTextStream
operator|::
name|RealNumberNotation
name|QTextStream
operator|::
name|realNumberNotation
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|params
operator|.
name|realNumberNotation
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the precision of real numbers to \a precision. This value     describes the number of fraction digits QTextStream should     write when generating real numbers.      The precision cannot be a negative value. The default value is 6.      \sa realNumberPrecision(), setRealNumberNotation() */
end_comment
begin_function
DECL|function|setRealNumberPrecision
name|void
name|QTextStream
operator|::
name|setRealNumberPrecision
parameter_list|(
name|int
name|precision
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|precision
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTextStream::setRealNumberPrecision: Invalid precision (%d)"
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|d
operator|->
name|params
operator|.
name|realNumberPrecision
operator|=
literal|6
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|params
operator|.
name|realNumberPrecision
operator|=
name|precision
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current real number precision, or the number of fraction     digits QTextStream will write when generating real numbers.      \sa setRealNumberNotation(), realNumberNotation(), numberFlags(), integerBase() */
end_comment
begin_function
DECL|function|realNumberPrecision
name|int
name|QTextStream
operator|::
name|realNumberPrecision
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|params
operator|.
name|realNumberPrecision
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the status of the text stream.      \sa QTextStream::Status, setStatus(), resetStatus() */
end_comment
begin_function
DECL|function|status
name|QTextStream
operator|::
name|Status
name|QTextStream
operator|::
name|status
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|status
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Resets the status of the text stream.      \sa QTextStream::Status, status(), setStatus() */
end_comment
begin_function
DECL|function|resetStatus
name|void
name|QTextStream
operator|::
name|resetStatus
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|status
operator|=
name|Ok
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Sets the status of the text stream to the \a status given.      Subsequent calls to setStatus() are ignored until resetStatus()     is called.      \sa Status, status(), resetStatus() */
end_comment
begin_function
DECL|function|setStatus
name|void
name|QTextStream
operator|::
name|setStatus
parameter_list|(
name|Status
name|status
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|status
operator|==
name|Ok
condition|)
name|d
operator|->
name|status
operator|=
name|status
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if there is no more data to be read from the     QTextStream; otherwise returns false. This is similar to, but not     the same as calling QIODevice::atEnd(), as QTextStream also takes     into account its internal Unicode buffer. */
end_comment
begin_function
DECL|function|atEnd
name|bool
name|QTextStream
operator|::
name|atEnd
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|string
condition|)
return|return
name|d
operator|->
name|string
operator|->
name|size
argument_list|()
operator|==
name|d
operator|->
name|stringOffset
return|;
return|return
name|d
operator|->
name|readBuffer
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|device
operator|->
name|atEnd
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Reads the entire content of the stream, and returns it as a     QString. Avoid this function when working on large files, as it     will consume a significant amount of memory.      Calling readLine() is better if you do not know how much data is     available.      \sa readLine() */
end_comment
begin_function
DECL|function|readAll
name|QString
name|QTextStream
operator|::
name|readAll
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|read
argument_list|(
name|INT_MAX
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Reads one line of text from the stream, and returns it as a     QString. The maximum allowed line length is set to \a maxlen. If     the stream contains lines longer than this, then the lines will be     split after \a maxlen characters and returned in parts.      If \a maxlen is 0, the lines can be of any length. A common value     for \a maxlen is 75.      The returned line has no trailing end-of-line characters ("\\n"     or "\\r\\n"), so calling QString::trimmed() is unnecessary.      If the stream has read to the end of the file, readLine() will return a     null QString. For strings, or for devices that support it, you can     explicitly test for the end of the stream using atEnd().      \sa readAll(), QIODevice::readLine() */
end_comment
begin_function
DECL|function|readLine
name|QString
name|QTextStream
operator|::
name|readLine
parameter_list|(
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|QChar
modifier|*
name|readPtr
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scan
argument_list|(
operator|&
name|readPtr
argument_list|,
operator|&
name|length
argument_list|,
name|int
argument_list|(
name|maxlen
argument_list|)
argument_list|,
name|QTextStreamPrivate
operator|::
name|EndOfLine
argument_list|)
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|tmp
init|=
name|QString
argument_list|(
name|readPtr
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|d
operator|->
name|consumeLastToken
argument_list|()
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Reads at most \a maxlen characters from the stream, and returns the data     read as a QString.      \sa readAll(), readLine(), QIODevice::read() */
end_comment
begin_function
DECL|function|read
name|QString
name|QTextStream
operator|::
name|read
parameter_list|(
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxlen
operator|<=
literal|0
condition|)
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|""
argument_list|)
return|;
comment|// empty, not null
return|return
name|d
operator|->
name|read
argument_list|(
name|int
argument_list|(
name|maxlen
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|getNumber
name|QTextStreamPrivate
operator|::
name|NumberParsingStatus
name|QTextStreamPrivate
operator|::
name|getNumber
parameter_list|(
name|qulonglong
modifier|*
name|ret
parameter_list|)
block|{
name|scan
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NotSpace
argument_list|)
expr_stmt|;
name|consumeLastToken
argument_list|()
expr_stmt|;
comment|// detect int encoding
name|int
name|base
init|=
name|params
operator|.
name|integerBase
decl_stmt|;
if|if
condition|(
name|base
operator|==
literal|0
condition|)
block|{
name|QChar
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|getChar
argument_list|(
operator|&
name|ch
argument_list|)
condition|)
return|return
name|npsInvalidPrefix
return|;
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
condition|)
block|{
name|QChar
name|ch2
decl_stmt|;
if|if
condition|(
operator|!
name|getChar
argument_list|(
operator|&
name|ch2
argument_list|)
condition|)
block|{
comment|// Result is the number 0
operator|*
name|ret
operator|=
literal|0
expr_stmt|;
return|return
name|npsOk
return|;
block|}
name|ch2
operator|=
name|ch2
operator|.
name|toLower
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch2
operator|==
name|QLatin1Char
argument_list|(
literal|'x'
argument_list|)
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch2
operator|==
name|QLatin1Char
argument_list|(
literal|'b'
argument_list|)
condition|)
block|{
name|base
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch2
operator|.
name|isDigit
argument_list|()
operator|&&
name|ch2
operator|.
name|digitValue
argument_list|()
operator|>=
literal|0
operator|&&
name|ch2
operator|.
name|digitValue
argument_list|()
operator|<=
literal|7
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
literal|10
expr_stmt|;
block|}
name|ungetChar
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|locale
operator|.
name|negativeSign
argument_list|()
operator|||
name|ch
operator|==
name|locale
operator|.
name|positiveSign
argument_list|()
operator|||
name|ch
operator|.
name|isDigit
argument_list|()
condition|)
block|{
name|base
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|ungetChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
name|npsInvalidPrefix
return|;
block|}
name|ungetChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|// State of the stream is now the same as on entry
comment|// (cursor is at prefix),
comment|// and local variable 'base' has been set appropriately.
block|}
name|qulonglong
name|val
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|2
case|:
block|{
name|QChar
name|pf1
decl_stmt|,
name|pf2
decl_stmt|,
name|dig
decl_stmt|;
comment|// Parse prefix '0b'
if|if
condition|(
operator|!
name|getChar
argument_list|(
operator|&
name|pf1
argument_list|)
operator|||
name|pf1
operator|!=
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
condition|)
return|return
name|npsInvalidPrefix
return|;
if|if
condition|(
operator|!
name|getChar
argument_list|(
operator|&
name|pf2
argument_list|)
operator|||
name|pf2
operator|.
name|toLower
argument_list|()
operator|!=
name|QLatin1Char
argument_list|(
literal|'b'
argument_list|)
condition|)
return|return
name|npsInvalidPrefix
return|;
comment|// Parse digits
name|int
name|ndigits
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|getChar
argument_list|(
operator|&
name|dig
argument_list|)
condition|)
block|{
name|int
name|n
init|=
name|dig
operator|.
name|toLower
argument_list|()
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|'0'
operator|||
name|n
operator|==
literal|'1'
condition|)
block|{
name|val
operator|<<=
literal|1
expr_stmt|;
name|val
operator|+=
name|n
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|ungetChar
argument_list|(
name|dig
argument_list|)
expr_stmt|;
break|break;
block|}
name|ndigits
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ndigits
operator|==
literal|0
condition|)
block|{
comment|// Unwind the prefix and abort
name|ungetChar
argument_list|(
name|pf2
argument_list|)
expr_stmt|;
name|ungetChar
argument_list|(
name|pf1
argument_list|)
expr_stmt|;
return|return
name|npsMissingDigit
return|;
block|}
break|break;
block|}
case|case
literal|8
case|:
block|{
name|QChar
name|pf
decl_stmt|,
name|dig
decl_stmt|;
comment|// Parse prefix '0'
if|if
condition|(
operator|!
name|getChar
argument_list|(
operator|&
name|pf
argument_list|)
operator|||
name|pf
operator|!=
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
condition|)
return|return
name|npsInvalidPrefix
return|;
comment|// Parse digits
name|int
name|ndigits
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|getChar
argument_list|(
operator|&
name|dig
argument_list|)
condition|)
block|{
name|int
name|n
init|=
name|dig
operator|.
name|toLower
argument_list|()
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|'0'
operator|&&
name|n
operator|<=
literal|'7'
condition|)
block|{
name|val
operator|*=
literal|8
expr_stmt|;
name|val
operator|+=
name|n
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|ungetChar
argument_list|(
name|dig
argument_list|)
expr_stmt|;
break|break;
block|}
name|ndigits
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ndigits
operator|==
literal|0
condition|)
block|{
comment|// Unwind the prefix and abort
name|ungetChar
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
name|npsMissingDigit
return|;
block|}
break|break;
block|}
case|case
literal|10
case|:
block|{
comment|// Parse sign (or first digit)
name|QChar
name|sign
decl_stmt|;
name|int
name|ndigits
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|getChar
argument_list|(
operator|&
name|sign
argument_list|)
condition|)
return|return
name|npsMissingDigit
return|;
if|if
condition|(
name|sign
operator|!=
name|locale
operator|.
name|negativeSign
argument_list|()
operator|&&
name|sign
operator|!=
name|locale
operator|.
name|positiveSign
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|sign
operator|.
name|isDigit
argument_list|()
condition|)
block|{
name|ungetChar
argument_list|(
name|sign
argument_list|)
expr_stmt|;
return|return
name|npsMissingDigit
return|;
block|}
name|val
operator|+=
name|sign
operator|.
name|digitValue
argument_list|()
expr_stmt|;
name|ndigits
operator|++
expr_stmt|;
block|}
comment|// Parse digits
name|QChar
name|ch
decl_stmt|;
while|while
condition|(
name|getChar
argument_list|(
operator|&
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|ch
operator|.
name|isDigit
argument_list|()
condition|)
block|{
name|val
operator|*=
literal|10
expr_stmt|;
name|val
operator|+=
name|ch
operator|.
name|digitValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|locale
operator|!=
name|QLocale
operator|::
name|c
argument_list|()
operator|&&
name|ch
operator|==
name|locale
operator|.
name|groupSeparator
argument_list|()
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|ungetChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
name|ndigits
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ndigits
operator|==
literal|0
condition|)
return|return
name|npsMissingDigit
return|;
if|if
condition|(
name|sign
operator|==
name|locale
operator|.
name|negativeSign
argument_list|()
condition|)
block|{
name|qlonglong
name|ival
init|=
name|qlonglong
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|ival
operator|>
literal|0
condition|)
name|ival
operator|=
operator|-
name|ival
expr_stmt|;
name|val
operator|=
name|qulonglong
argument_list|(
name|ival
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|16
case|:
block|{
name|QChar
name|pf1
decl_stmt|,
name|pf2
decl_stmt|,
name|dig
decl_stmt|;
comment|// Parse prefix ' 0x'
if|if
condition|(
operator|!
name|getChar
argument_list|(
operator|&
name|pf1
argument_list|)
operator|||
name|pf1
operator|!=
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
condition|)
return|return
name|npsInvalidPrefix
return|;
if|if
condition|(
operator|!
name|getChar
argument_list|(
operator|&
name|pf2
argument_list|)
operator|||
name|pf2
operator|.
name|toLower
argument_list|()
operator|!=
name|QLatin1Char
argument_list|(
literal|'x'
argument_list|)
condition|)
return|return
name|npsInvalidPrefix
return|;
comment|// Parse digits
name|int
name|ndigits
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|getChar
argument_list|(
operator|&
name|dig
argument_list|)
condition|)
block|{
name|int
name|n
init|=
name|dig
operator|.
name|toLower
argument_list|()
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|'0'
operator|&&
name|n
operator|<=
literal|'9'
condition|)
block|{
name|val
operator|<<=
literal|4
expr_stmt|;
name|val
operator|+=
name|n
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>=
literal|'a'
operator|&&
name|n
operator|<=
literal|'f'
condition|)
block|{
name|val
operator|<<=
literal|4
expr_stmt|;
name|val
operator|+=
literal|10
operator|+
operator|(
name|n
operator|-
literal|'a'
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ungetChar
argument_list|(
name|dig
argument_list|)
expr_stmt|;
break|break;
block|}
name|ndigits
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ndigits
operator|==
literal|0
condition|)
block|{
return|return
name|npsMissingDigit
return|;
block|}
break|break;
block|}
default|default:
comment|// Unsupported integerBase
return|return
name|npsInvalidPrefix
return|;
block|}
if|if
condition|(
name|ret
condition|)
operator|*
name|ret
operator|=
name|val
expr_stmt|;
return|return
name|npsOk
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     (hihi) */
end_comment
begin_function
DECL|function|getReal
name|bool
name|QTextStreamPrivate
operator|::
name|getReal
parameter_list|(
name|double
modifier|*
name|f
parameter_list|)
block|{
comment|// We use a table-driven FSM to parse floating point numbers
comment|// strtod() cannot be used directly since we may be reading from a
comment|// QIODevice.
enum|enum
name|ParserState
block|{
name|Init
init|=
literal|0
block|,
name|Sign
init|=
literal|1
block|,
name|Mantissa
init|=
literal|2
block|,
name|Dot
init|=
literal|3
block|,
name|Abscissa
init|=
literal|4
block|,
name|ExpMark
init|=
literal|5
block|,
name|ExpSign
init|=
literal|6
block|,
name|Exponent
init|=
literal|7
block|,
name|Nan1
init|=
literal|8
block|,
name|Nan2
init|=
literal|9
block|,
name|Inf1
init|=
literal|10
block|,
name|Inf2
init|=
literal|11
block|,
name|NanInf
init|=
literal|12
block|,
name|Done
init|=
literal|13
block|}
enum|;
enum|enum
name|InputToken
block|{
name|None
init|=
literal|0
block|,
name|InputSign
init|=
literal|1
block|,
name|InputDigit
init|=
literal|2
block|,
name|InputDot
init|=
literal|3
block|,
name|InputExp
init|=
literal|4
block|,
name|InputI
init|=
literal|5
block|,
name|InputN
init|=
literal|6
block|,
name|InputF
init|=
literal|7
block|,
name|InputA
init|=
literal|8
block|,
name|InputT
init|=
literal|9
block|}
enum|;
specifier|static
specifier|const
name|uchar
name|table
index|[
literal|13
index|]
index|[
literal|10
index|]
init|=
block|{
comment|// None InputSign InputDigit InputDot InputExp InputI    InputN    InputF    InputA    InputT
block|{
literal|0
block|,
name|Sign
block|,
name|Mantissa
block|,
name|Dot
block|,
literal|0
block|,
name|Inf1
block|,
name|Nan1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 0  Init
block|{
literal|0
block|,
literal|0
block|,
name|Mantissa
block|,
name|Dot
block|,
literal|0
block|,
name|Inf1
block|,
name|Nan1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 1  Sign
block|{
name|Done
block|,
name|Done
block|,
name|Mantissa
block|,
name|Dot
block|,
name|ExpMark
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 2  Mantissa
block|{
literal|0
block|,
literal|0
block|,
name|Abscissa
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 3  Dot
block|{
name|Done
block|,
name|Done
block|,
name|Abscissa
block|,
name|Done
block|,
name|ExpMark
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 4  Abscissa
block|{
literal|0
block|,
name|ExpSign
block|,
name|Exponent
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 5  ExpMark
block|{
literal|0
block|,
literal|0
block|,
name|Exponent
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 6  ExpSign
block|{
name|Done
block|,
name|Done
block|,
name|Exponent
block|,
name|Done
block|,
name|Done
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 7  Exponent
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|Nan2
block|,
literal|0
block|}
block|,
comment|// 8  Nan1
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NanInf
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 9  Nan2
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|Inf2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 10 Inf1
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NanInf
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 11 Inf2
block|{
name|Done
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 11 NanInf
block|}
decl_stmt|;
name|ParserState
name|state
init|=
name|Init
decl_stmt|;
name|InputToken
name|input
init|=
name|None
decl_stmt|;
name|scan
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NotSpace
argument_list|)
expr_stmt|;
name|consumeLastToken
argument_list|()
expr_stmt|;
specifier|const
name|int
name|BufferSize
init|=
literal|128
decl_stmt|;
name|char
name|buf
index|[
name|BufferSize
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|QChar
name|c
decl_stmt|;
while|while
condition|(
name|getChar
argument_list|(
operator|&
name|c
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|c
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|input
operator|=
name|InputDigit
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
name|input
operator|=
name|InputI
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
name|input
operator|=
name|InputN
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|input
operator|=
name|InputF
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
name|input
operator|=
name|InputA
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
name|input
operator|=
name|InputT
expr_stmt|;
break|break;
default|default:
block|{
name|QChar
name|lc
init|=
name|c
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|lc
operator|==
name|locale
operator|.
name|decimalPoint
argument_list|()
operator|.
name|toLower
argument_list|()
condition|)
name|input
operator|=
name|InputDot
expr_stmt|;
elseif|else
if|if
condition|(
name|lc
operator|==
name|locale
operator|.
name|exponential
argument_list|()
operator|.
name|toLower
argument_list|()
condition|)
name|input
operator|=
name|InputExp
expr_stmt|;
elseif|else
if|if
condition|(
name|lc
operator|==
name|locale
operator|.
name|negativeSign
argument_list|()
operator|.
name|toLower
argument_list|()
operator|||
name|lc
operator|==
name|locale
operator|.
name|positiveSign
argument_list|()
operator|.
name|toLower
argument_list|()
condition|)
name|input
operator|=
name|InputSign
expr_stmt|;
elseif|else
if|if
condition|(
name|locale
operator|!=
name|QLocale
operator|::
name|c
argument_list|()
comment|// backward-compatibility
operator|&&
name|lc
operator|==
name|locale
operator|.
name|groupSeparator
argument_list|()
operator|.
name|toLower
argument_list|()
condition|)
name|input
operator|=
name|InputDigit
expr_stmt|;
comment|// well, it isn't a digit, but no one cares.
else|else
name|input
operator|=
name|None
expr_stmt|;
block|}
break|break;
block|}
name|state
operator|=
name|ParserState
argument_list|(
name|table
index|[
name|state
index|]
index|[
name|input
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|Init
operator|||
name|state
operator|==
name|Done
operator|||
name|i
operator|>
operator|(
name|BufferSize
operator|-
literal|5
operator|)
condition|)
block|{
name|ungetChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
operator|(
name|BufferSize
operator|-
literal|5
operator|)
condition|)
block|{
comment|// ignore rest of digits
while|while
condition|(
name|getChar
argument_list|(
operator|&
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|c
operator|.
name|isDigit
argument_list|()
condition|)
block|{
name|ungetChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
block|}
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|c
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|f
condition|)
return|return
literal|true
return|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|// backward-compatibility. Old implementation supported +nan/-nan
comment|// for some reason. QLocale only checks for lower-case
comment|// nan/+inf/-inf, so here we also check for uppercase and mixed
comment|// case versions.
if|if
condition|(
operator|!
name|qstricmp
argument_list|(
name|buf
argument_list|,
literal|"nan"
argument_list|)
operator|||
operator|!
name|qstricmp
argument_list|(
name|buf
argument_list|,
literal|"+nan"
argument_list|)
operator|||
operator|!
name|qstricmp
argument_list|(
name|buf
argument_list|,
literal|"-nan"
argument_list|)
condition|)
block|{
operator|*
name|f
operator|=
name|qSNaN
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|qstricmp
argument_list|(
name|buf
argument_list|,
literal|"+inf"
argument_list|)
operator|||
operator|!
name|qstricmp
argument_list|(
name|buf
argument_list|,
literal|"inf"
argument_list|)
condition|)
block|{
operator|*
name|f
operator|=
name|qInf
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|qstricmp
argument_list|(
name|buf
argument_list|,
literal|"-inf"
argument_list|)
condition|)
block|{
operator|*
name|f
operator|=
operator|-
name|qInf
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|bool
name|ok
decl_stmt|;
operator|*
name|f
operator|=
name|locale
operator|.
name|toDouble
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function
begin_comment
comment|/*!     Reads a character from the stream and stores it in \a c. Returns a     reference to the QTextStream, so several operators can be     nested. Example:      \snippet code/src_corelib_io_qtextstream.cpp 7      Whitespace is \e not skipped. */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|QChar
modifier|&
name|c
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|scan
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|QTextStreamPrivate
operator|::
name|NotSpace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|getChar
argument_list|(
operator|&
name|c
argument_list|)
condition|)
name|setStatus
argument_list|(
name|ReadPastEnd
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Reads a character from the stream and stores it in \a c. The     character from the stream is converted to ISO-5589-1 before it is     stored.      \sa QChar::toLatin1() */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|char
modifier|&
name|c
parameter_list|)
block|{
name|QChar
name|ch
decl_stmt|;
operator|*
name|this
operator|>>
name|ch
expr_stmt|;
name|c
operator|=
name|ch
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Reads an integer from the stream and stores it in \a i, then     returns a reference to the QTextStream. The number is cast to     the correct type before it is stored. If no number was detected on     the stream, \a i is set to 0.      By default, QTextStream will attempt to detect the base of the     number using the following rules:      \table     \header \li Prefix                \li Base     \row    \li "0b" or "0B"          \li 2 (binary)     \row    \li "0" followed by "0-7" \li 8 (octal)     \row    \li "0" otherwise         \li 10 (decimal)     \row    \li "0x" or "0X"          \li 16 (hexadecimal)     \row    \li "1" to "9"            \li 10 (decimal)     \endtable      By calling setIntegerBase(), you can specify the integer base     explicitly. This will disable the auto-detection, and speed up     QTextStream slightly.      Leading whitespace is skipped. */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|signed
name|short
modifier|&
name|i
parameter_list|)
block|{
name|IMPLEMENT_STREAM_RIGHT_INT_OPERATOR
argument_list|(
argument|signed short
argument_list|)
empty_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Stores the integer in the unsigned short \a i. */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|unsigned
name|short
modifier|&
name|i
parameter_list|)
block|{
name|IMPLEMENT_STREAM_RIGHT_INT_OPERATOR
argument_list|(
argument|unsigned short
argument_list|)
empty_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Stores the integer in the signed int \a i. */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|signed
name|int
modifier|&
name|i
parameter_list|)
block|{
name|IMPLEMENT_STREAM_RIGHT_INT_OPERATOR
argument_list|(
argument|signed int
argument_list|)
empty_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Stores the integer in the unsigned int \a i. */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|unsigned
name|int
modifier|&
name|i
parameter_list|)
block|{
name|IMPLEMENT_STREAM_RIGHT_INT_OPERATOR
argument_list|(
argument|unsigned int
argument_list|)
empty_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Stores the integer in the signed long \a i. */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|signed
name|long
modifier|&
name|i
parameter_list|)
block|{
name|IMPLEMENT_STREAM_RIGHT_INT_OPERATOR
argument_list|(
argument|signed long
argument_list|)
empty_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Stores the integer in the unsigned long \a i. */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|unsigned
name|long
modifier|&
name|i
parameter_list|)
block|{
name|IMPLEMENT_STREAM_RIGHT_INT_OPERATOR
argument_list|(
argument|unsigned long
argument_list|)
empty_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Stores the integer in the qlonglong \a i. */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|qlonglong
modifier|&
name|i
parameter_list|)
block|{
name|IMPLEMENT_STREAM_RIGHT_INT_OPERATOR
argument_list|(
name|qlonglong
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Stores the integer in the qulonglong \a i. */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|qulonglong
modifier|&
name|i
parameter_list|)
block|{
name|IMPLEMENT_STREAM_RIGHT_INT_OPERATOR
argument_list|(
name|qulonglong
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Reads a real number from the stream and stores it in \a f, then     returns a reference to the QTextStream. The number is cast to     the correct type. If no real number is detect on the stream, \a f     is set to 0.0.      As a special exception, QTextStream allows the strings "nan" and "inf" to     represent NAN and INF floats or doubles.      Leading whitespace is skipped. */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|float
modifier|&
name|f
parameter_list|)
block|{
name|IMPLEMENT_STREAM_RIGHT_REAL_OPERATOR
argument_list|(
name|float
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Stores the real number in the double \a f. */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|double
modifier|&
name|f
parameter_list|)
block|{
name|IMPLEMENT_STREAM_RIGHT_REAL_OPERATOR
argument_list|(
name|double
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Reads a word from the stream and stores it in \a str, then returns     a reference to the stream. Words are separated by whitespace     (i.e., all characters for which QChar::isSpace() returns true).      Leading whitespace is skipped. */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|str
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|scan
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|QTextStreamPrivate
operator|::
name|NotSpace
argument_list|)
expr_stmt|;
name|d
operator|->
name|consumeLastToken
argument_list|()
expr_stmt|;
specifier|const
name|QChar
modifier|*
name|ptr
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scan
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|,
literal|0
argument_list|,
name|QTextStreamPrivate
operator|::
name|Space
argument_list|)
condition|)
block|{
name|setStatus
argument_list|(
name|ReadPastEnd
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|str
operator|=
name|QString
argument_list|(
name|ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|d
operator|->
name|consumeLastToken
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Converts the word to ISO-8859-1, then stores it in \a array.      \sa QString::toLatin1() */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|QByteArray
modifier|&
name|array
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|array
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|scan
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|QTextStreamPrivate
operator|::
name|NotSpace
argument_list|)
expr_stmt|;
name|d
operator|->
name|consumeLastToken
argument_list|()
expr_stmt|;
specifier|const
name|QChar
modifier|*
name|ptr
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scan
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|,
literal|0
argument_list|,
name|QTextStreamPrivate
operator|::
name|Space
argument_list|)
condition|)
block|{
name|setStatus
argument_list|(
name|ReadPastEnd
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
name|array
operator|+=
name|ptr
index|[
name|i
index|]
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|d
operator|->
name|consumeLastToken
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Stores the word in \a c, terminated by a '\\0' character. If no word is     available, only the '\\0' character is stored.      Warning: Although convenient, this operator is dangerous and must     be used with care. QTextStream assumes that \a c points to a     buffer with enough space to hold the word. If the buffer is too     small, your application may crash.      If possible, use the QByteArray operator instead. */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|>>
parameter_list|(
name|char
modifier|*
name|c
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
operator|*
name|c
operator|=
literal|0
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|scan
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|QTextStreamPrivate
operator|::
name|NotSpace
argument_list|)
expr_stmt|;
name|d
operator|->
name|consumeLastToken
argument_list|()
expr_stmt|;
specifier|const
name|QChar
modifier|*
name|ptr
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scan
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|,
literal|0
argument_list|,
name|QTextStreamPrivate
operator|::
name|Space
argument_list|)
condition|)
block|{
name|setStatus
argument_list|(
name|ReadPastEnd
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
operator|*
name|c
operator|++
operator|=
name|ptr
index|[
name|i
index|]
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|->
name|consumeLastToken
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|putNumber
name|void
name|QTextStreamPrivate
operator|::
name|putNumber
parameter_list|(
name|qulonglong
name|number
parameter_list|,
name|bool
name|negative
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
name|unsigned
name|flags
init|=
literal|0
decl_stmt|;
specifier|const
name|QTextStream
operator|::
name|NumberFlags
name|numberFlags
init|=
name|params
operator|.
name|numberFlags
decl_stmt|;
if|if
condition|(
name|numberFlags
operator|&
name|QTextStream
operator|::
name|ShowBase
condition|)
name|flags
operator||=
name|QLocalePrivate
operator|::
name|ShowBase
expr_stmt|;
if|if
condition|(
name|numberFlags
operator|&
name|QTextStream
operator|::
name|ForceSign
condition|)
name|flags
operator||=
name|QLocalePrivate
operator|::
name|AlwaysShowSign
expr_stmt|;
if|if
condition|(
name|numberFlags
operator|&
name|QTextStream
operator|::
name|UppercaseBase
condition|)
name|flags
operator||=
name|QLocalePrivate
operator|::
name|UppercaseBase
expr_stmt|;
if|if
condition|(
name|numberFlags
operator|&
name|QTextStream
operator|::
name|UppercaseDigits
condition|)
name|flags
operator||=
name|QLocalePrivate
operator|::
name|CapitalEorX
expr_stmt|;
comment|// add thousands group separators. For backward compatibility we
comment|// don't add a group separator for C locale.
if|if
condition|(
name|locale
operator|!=
name|QLocale
operator|::
name|c
argument_list|()
condition|)
name|flags
operator||=
name|QLocalePrivate
operator|::
name|ThousandsGroup
expr_stmt|;
specifier|const
name|QLocalePrivate
modifier|*
name|dd
init|=
name|locale
operator|.
name|d
decl_stmt|;
name|int
name|base
init|=
name|params
operator|.
name|integerBase
condition|?
name|params
operator|.
name|integerBase
else|:
literal|10
decl_stmt|;
if|if
condition|(
name|negative
operator|&&
name|base
operator|==
literal|10
condition|)
block|{
name|result
operator|=
name|dd
operator|->
name|longLongToString
argument_list|(
operator|-
cast|static_cast
argument_list|<
name|qlonglong
argument_list|>
argument_list|(
name|number
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|negative
condition|)
block|{
comment|// Workaround for backward compatibility for writing negative
comment|// numbers in octal and hex:
comment|// QTextStream(result)<< showbase<< hex<< -1<< oct<< -1
comment|// should output: -0x1 -0b1
name|result
operator|=
name|dd
operator|->
name|unsLongLongToString
argument_list|(
name|number
argument_list|,
operator|-
literal|1
argument_list|,
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|result
operator|.
name|prepend
argument_list|(
name|locale
operator|.
name|negativeSign
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|dd
operator|->
name|unsLongLongToString
argument_list|(
name|number
argument_list|,
operator|-
literal|1
argument_list|,
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|// workaround for backward compatibility - in octal form with
comment|// ShowBase flag set zero should be written as '00'
if|if
condition|(
name|number
operator|==
literal|0
operator|&&
name|base
operator|==
literal|8
operator|&&
name|params
operator|.
name|numberFlags
operator|&
name|QTextStream
operator|::
name|ShowBase
operator|&&
name|result
operator|==
name|QLatin1String
argument_list|(
literal|"0"
argument_list|)
condition|)
block|{
name|result
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|putString
argument_list|(
name|result
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Writes the character \a c to the stream, then returns a reference     to the QTextStream.      \sa setFieldWidth() */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
name|QChar
name|c
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|putString
argument_list|(
name|QString
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Converts \a c from ASCII to a QChar, then writes it to the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|putString
argument_list|(
name|QString
argument_list|(
name|QChar
operator|::
name|fromLatin1
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Writes the integer number \a i to the stream, then returns a     reference to the QTextStream. By default, the number is stored in     decimal form, but you can also set the base by calling     setIntegerBase().      \sa setFieldWidth(), setNumberFlags() */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
name|signed
name|short
name|i
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|putNumber
argument_list|(
operator|(
name|qulonglong
operator|)
name|qAbs
argument_list|(
name|qlonglong
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|i
operator|<
literal|0
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes the unsigned short \a i to the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
name|unsigned
name|short
name|i
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|putNumber
argument_list|(
operator|(
name|qulonglong
operator|)
name|i
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes the signed int \a i to the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
name|signed
name|int
name|i
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|putNumber
argument_list|(
operator|(
name|qulonglong
operator|)
name|qAbs
argument_list|(
name|qlonglong
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|i
operator|<
literal|0
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes the unsigned int \a i to the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
name|unsigned
name|int
name|i
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|putNumber
argument_list|(
operator|(
name|qulonglong
operator|)
name|i
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes the signed long \a i to the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
name|signed
name|long
name|i
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|putNumber
argument_list|(
operator|(
name|qulonglong
operator|)
name|qAbs
argument_list|(
name|qlonglong
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|i
operator|<
literal|0
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes the unsigned long \a i to the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
name|unsigned
name|long
name|i
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|putNumber
argument_list|(
operator|(
name|qulonglong
operator|)
name|i
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes the qlonglong \a i to the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
name|qlonglong
name|i
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|putNumber
argument_list|(
operator|(
name|qulonglong
operator|)
name|qAbs
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
operator|<
literal|0
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes the qulonglong \a i to the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
name|qulonglong
name|i
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|putNumber
argument_list|(
name|i
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Writes the real number \a f to the stream, then returns a     reference to the QTextStream. By default, QTextStream stores it     using SmartNotation, with up to 6 digits of precision. You can     change the textual representation QTextStream will use for real     numbers by calling setRealNumberNotation(),     setRealNumberPrecision() and setNumberFlags().      \sa setFieldWidth(), setRealNumberNotation(),     setRealNumberPrecision(), setNumberFlags() */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
name|float
name|f
parameter_list|)
block|{
return|return
operator|*
name|this
operator|<<
name|double
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes the double \a f to the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
name|double
name|f
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|QLocalePrivate
operator|::
name|DoubleForm
name|form
init|=
name|QLocalePrivate
operator|::
name|DFDecimal
decl_stmt|;
switch|switch
condition|(
name|realNumberNotation
argument_list|()
condition|)
block|{
case|case
name|FixedNotation
case|:
name|form
operator|=
name|QLocalePrivate
operator|::
name|DFDecimal
expr_stmt|;
break|break;
case|case
name|ScientificNotation
case|:
name|form
operator|=
name|QLocalePrivate
operator|::
name|DFExponent
expr_stmt|;
break|break;
case|case
name|SmartNotation
case|:
name|form
operator|=
name|QLocalePrivate
operator|::
name|DFSignificantDigits
expr_stmt|;
break|break;
block|}
name|uint
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|numberFlags
argument_list|()
operator|&
name|ShowBase
condition|)
name|flags
operator||=
name|QLocalePrivate
operator|::
name|ShowBase
expr_stmt|;
if|if
condition|(
name|numberFlags
argument_list|()
operator|&
name|ForceSign
condition|)
name|flags
operator||=
name|QLocalePrivate
operator|::
name|AlwaysShowSign
expr_stmt|;
if|if
condition|(
name|numberFlags
argument_list|()
operator|&
name|UppercaseBase
condition|)
name|flags
operator||=
name|QLocalePrivate
operator|::
name|UppercaseBase
expr_stmt|;
if|if
condition|(
name|numberFlags
argument_list|()
operator|&
name|UppercaseDigits
condition|)
name|flags
operator||=
name|QLocalePrivate
operator|::
name|CapitalEorX
expr_stmt|;
if|if
condition|(
name|numberFlags
argument_list|()
operator|&
name|ForcePoint
condition|)
name|flags
operator||=
name|QLocalePrivate
operator|::
name|Alternate
expr_stmt|;
specifier|const
name|QLocalePrivate
modifier|*
name|dd
init|=
name|d
operator|->
name|locale
operator|.
name|d
decl_stmt|;
name|QString
name|num
init|=
name|dd
operator|->
name|doubleToString
argument_list|(
name|f
argument_list|,
name|d
operator|->
name|params
operator|.
name|realNumberPrecision
argument_list|,
name|form
argument_list|,
operator|-
literal|1
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|d
operator|->
name|putString
argument_list|(
name|num
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Writes the string \a string to the stream, and returns a reference     to the QTextStream. The string is first encoded using the assigned     codec (the default codec is QTextCodec::codecForLocale()) before     it is written to the stream.      \sa setFieldWidth(), setCodec() */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|putString
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes \a string to the stream, and returns a reference to the     QTextStream. The contents of \a string are converted with the     QString constructor that takes a QLatin1String as argument. */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
name|QLatin1String
name|string
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|putString
argument_list|(
name|QString
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes \a array to the stream. The contents of \a array are     converted with QString::fromUtf8(). */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|array
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|putString
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
name|array
operator|.
name|constData
argument_list|()
argument_list|,
name|array
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes the constant string pointed to by \a string to the stream. \a     string is assumed to be in ISO-8859-1 encoding. This operator     is convenient when working with constant string data. Example:      \snippet code/src_corelib_io_qtextstream.cpp 8      Warning: QTextStream assumes that \a string points to a string of     text, terminated by a '\\0' character. If there is no terminating     '\\0' character, your application may crash. */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|putString
argument_list|(
name|QLatin1String
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Writes \a ptr to the stream as a hexadecimal number with a base. */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|QTextStream
operator|::
name|operator
name|<<
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|CHECK_VALID_STREAM
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
specifier|const
name|int
name|oldBase
init|=
name|d
operator|->
name|params
operator|.
name|integerBase
decl_stmt|;
specifier|const
name|NumberFlags
name|oldFlags
init|=
name|d
operator|->
name|params
operator|.
name|numberFlags
decl_stmt|;
name|d
operator|->
name|params
operator|.
name|integerBase
operator|=
literal|16
expr_stmt|;
name|d
operator|->
name|params
operator|.
name|numberFlags
operator||=
name|ShowBase
expr_stmt|;
name|d
operator|->
name|putNumber
argument_list|(
cast|reinterpret_cast
argument_list|<
name|quintptr
argument_list|>
argument_list|(
name|ptr
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|params
operator|.
name|integerBase
operator|=
name|oldBase
expr_stmt|;
name|d
operator|->
name|params
operator|.
name|numberFlags
operator|=
name|oldFlags
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setIntegerBase(2) on \a stream and returns \a     stream.      \sa oct(), dec(), hex(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|bin
name|QTextStream
modifier|&
name|bin
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setIntegerBase
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setIntegerBase(8) on \a stream and returns \a     stream.      \sa bin(), dec(), hex(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|oct
name|QTextStream
modifier|&
name|oct
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setIntegerBase
argument_list|(
literal|8
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setIntegerBase(10) on \a stream and returns \a     stream.      \sa bin(), oct(), hex(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|dec
name|QTextStream
modifier|&
name|dec
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setIntegerBase
argument_list|(
literal|10
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setIntegerBase(16) on \a stream and returns \a     stream.      \note The hex modifier can only be used for writing to streams.     \sa bin(), oct(), dec(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|hex
name|QTextStream
modifier|&
name|hex
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setIntegerBase
argument_list|(
literal|16
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setNumberFlags(QTextStream::numberFlags() |     QTextStream::ShowBase) on \a stream and returns \a stream.      \sa noshowbase(), forcesign(), forcepoint(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|showbase
name|QTextStream
modifier|&
name|showbase
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setNumberFlags
argument_list|(
name|stream
operator|.
name|numberFlags
argument_list|()
operator||
name|QTextStream
operator|::
name|ShowBase
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setNumberFlags(QTextStream::numberFlags() |     QTextStream::ForceSign) on \a stream and returns \a stream.      \sa noforcesign(), forcepoint(), showbase(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|forcesign
name|QTextStream
modifier|&
name|forcesign
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setNumberFlags
argument_list|(
name|stream
operator|.
name|numberFlags
argument_list|()
operator||
name|QTextStream
operator|::
name|ForceSign
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setNumberFlags(QTextStream::numberFlags() |     QTextStream::ForcePoint) on \a stream and returns \a stream.      \sa noforcepoint(), forcesign(), showbase(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|forcepoint
name|QTextStream
modifier|&
name|forcepoint
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setNumberFlags
argument_list|(
name|stream
operator|.
name|numberFlags
argument_list|()
operator||
name|QTextStream
operator|::
name|ForcePoint
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setNumberFlags(QTextStream::numberFlags()&     ~QTextStream::ShowBase) on \a stream and returns \a stream.      \sa showbase(), noforcesign(), noforcepoint(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|noshowbase
name|QTextStream
modifier|&
name|noshowbase
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setNumberFlags
argument_list|(
name|stream
operator|.
name|numberFlags
argument_list|()
operator|&=
operator|~
name|QTextStream
operator|::
name|ShowBase
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setNumberFlags(QTextStream::numberFlags()&     ~QTextStream::ForceSign) on \a stream and returns \a stream.      \sa forcesign(), noforcepoint(), noshowbase(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|noforcesign
name|QTextStream
modifier|&
name|noforcesign
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setNumberFlags
argument_list|(
name|stream
operator|.
name|numberFlags
argument_list|()
operator|&=
operator|~
name|QTextStream
operator|::
name|ForceSign
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setNumberFlags(QTextStream::numberFlags()&     ~QTextStream::ForcePoint) on \a stream and returns \a stream.      \sa forcepoint(), noforcesign(), noshowbase(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|noforcepoint
name|QTextStream
modifier|&
name|noforcepoint
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setNumberFlags
argument_list|(
name|stream
operator|.
name|numberFlags
argument_list|()
operator|&=
operator|~
name|QTextStream
operator|::
name|ForcePoint
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setNumberFlags(QTextStream::numberFlags() |     QTextStream::UppercaseBase) on \a stream and returns \a stream.      \sa lowercasebase(), uppercasedigits(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|uppercasebase
name|QTextStream
modifier|&
name|uppercasebase
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setNumberFlags
argument_list|(
name|stream
operator|.
name|numberFlags
argument_list|()
operator||
name|QTextStream
operator|::
name|UppercaseBase
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setNumberFlags(QTextStream::numberFlags() |     QTextStream::UppercaseDigits) on \a stream and returns \a stream.      \sa lowercasedigits(), uppercasebase(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|uppercasedigits
name|QTextStream
modifier|&
name|uppercasedigits
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setNumberFlags
argument_list|(
name|stream
operator|.
name|numberFlags
argument_list|()
operator||
name|QTextStream
operator|::
name|UppercaseDigits
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setNumberFlags(QTextStream::numberFlags()&     ~QTextStream::UppercaseBase) on \a stream and returns \a stream.      \sa uppercasebase(), lowercasedigits(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|lowercasebase
name|QTextStream
modifier|&
name|lowercasebase
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setNumberFlags
argument_list|(
name|stream
operator|.
name|numberFlags
argument_list|()
operator|&
operator|~
name|QTextStream
operator|::
name|UppercaseBase
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setNumberFlags(QTextStream::numberFlags()&     ~QTextStream::UppercaseDigits) on \a stream and returns \a stream.      \sa uppercasedigits(), lowercasebase(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|lowercasedigits
name|QTextStream
modifier|&
name|lowercasedigits
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setNumberFlags
argument_list|(
name|stream
operator|.
name|numberFlags
argument_list|()
operator|&
operator|~
name|QTextStream
operator|::
name|UppercaseDigits
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setRealNumberNotation(QTextStream::FixedNotation)     on \a stream and returns \a stream.      \sa scientific(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|fixed
name|QTextStream
modifier|&
name|fixed
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setRealNumberNotation
argument_list|(
name|QTextStream
operator|::
name|FixedNotation
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setRealNumberNotation(QTextStream::ScientificNotation)     on \a stream and returns \a stream.      \sa fixed(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|scientific
name|QTextStream
modifier|&
name|scientific
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setRealNumberNotation
argument_list|(
name|QTextStream
operator|::
name|ScientificNotation
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setFieldAlignment(QTextStream::AlignLeft)     on \a stream and returns \a stream.      \sa right(), center(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|left
name|QTextStream
modifier|&
name|left
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setFieldAlignment
argument_list|(
name|QTextStream
operator|::
name|AlignLeft
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setFieldAlignment(QTextStream::AlignRight)     on \a stream and returns \a stream.      \sa left(), center(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|right
name|QTextStream
modifier|&
name|right
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setFieldAlignment
argument_list|(
name|QTextStream
operator|::
name|AlignRight
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::setFieldAlignment(QTextStream::AlignCenter)     on \a stream and returns \a stream.      \sa left(), right(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|center
name|QTextStream
modifier|&
name|center
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setFieldAlignment
argument_list|(
name|QTextStream
operator|::
name|AlignCenter
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Writes '\\n' to the \a stream and flushes the stream.      Equivalent to      \snippet code/src_corelib_io_qtextstream.cpp 9      Note: On Windows, all '\\n' characters are written as '\\r\\n' if     QTextStream's device or string is opened using the QIODevice::Text flag.      \sa flush(), reset(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|endl
name|QTextStream
modifier|&
name|endl
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
return|return
name|stream
operator|<<
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
operator|<<
name|flush
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::flush() on \a stream and returns \a stream.      \sa endl(), reset(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|flush
name|QTextStream
modifier|&
name|flush
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls QTextStream::reset() on \a stream and returns \a stream.      \sa flush(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|reset
name|QTextStream
modifier|&
name|reset
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTextStream      Calls skipWhiteSpace() on \a stream and returns \a stream.      \sa {QTextStream manipulators} */
end_comment
begin_function
DECL|function|ws
name|QTextStream
modifier|&
name|ws
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|skipWhiteSpace
argument_list|()
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextStreamManipulator qSetFieldWidth(int width)     \relates QTextStream      Equivalent to QTextStream::setFieldWidth(\a width). */
end_comment
begin_comment
comment|/*!     \fn QTextStreamManipulator qSetPadChar(QChar ch)     \relates QTextStream      Equivalent to QTextStream::setPadChar(\a ch). */
end_comment
begin_comment
comment|/*!     \fn QTextStreamManipulator qSetRealNumberPrecision(int precision)     \relates QTextStream      Equivalent to QTextStream::setRealNumberPrecision(\a precision). */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
end_ifndef
begin_comment
comment|/*!     \relates QTextStream      Toggles insertion of the Byte Order Mark on \a stream when QTextStream is     used with a UTF codec.      \sa QTextStream::setGenerateByteOrderMark(), {QTextStream manipulators} */
end_comment
begin_function
DECL|function|bom
name|QTextStream
modifier|&
name|bom
parameter_list|(
name|QTextStream
modifier|&
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|setGenerateByteOrderMark
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the codec for this stream to \a codec. The codec is used for     decoding any data that is read from the assigned device, and for     encoding any data that is written. By default,     QTextCodec::codecForLocale() is used, and automatic unicode     detection is enabled.      If QTextStream operates on a string, this function does nothing.      \warning If you call this function while the text stream is reading     from an open sequential socket, the internal buffer may still contain     text decoded using the old codec.      \sa codec(), setAutoDetectUnicode(), setLocale() */
end_comment
begin_function
DECL|function|setCodec
name|void
name|QTextStream
operator|::
name|setCodec
parameter_list|(
name|QTextCodec
modifier|*
name|codec
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|qint64
name|seekPos
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|readBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|device
operator|->
name|isSequential
argument_list|()
condition|)
block|{
name|seekPos
operator|=
name|pos
argument_list|()
expr_stmt|;
block|}
block|}
name|d
operator|->
name|codec
operator|=
name|codec
expr_stmt|;
if|if
condition|(
name|seekPos
operator|>=
literal|0
operator|&&
operator|!
name|d
operator|->
name|readBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|seek
argument_list|(
name|seekPos
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the codec for this stream to the QTextCodec for the encoding     specified by \a codecName. Common values for \c codecName include     "ISO 8859-1", "UTF-8", and "UTF-16". If the encoding isn't     recognized, nothing happens.      Example:      \snippet code/src_corelib_io_qtextstream.cpp 10      \sa QTextCodec::codecForName(), setLocale() */
end_comment
begin_function
DECL|function|setCodec
name|void
name|QTextStream
operator|::
name|setCodec
parameter_list|(
specifier|const
name|char
modifier|*
name|codecName
parameter_list|)
block|{
name|QTextCodec
modifier|*
name|codec
init|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|codecName
argument_list|)
decl_stmt|;
if|if
condition|(
name|codec
condition|)
name|setCodec
argument_list|(
name|codec
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the codec that is current assigned to the stream.      \sa setCodec(), setAutoDetectUnicode(), locale() */
end_comment
begin_function
DECL|function|codec
name|QTextCodec
modifier|*
name|QTextStream
operator|::
name|codec
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|codec
return|;
block|}
end_function
begin_comment
comment|/*!     If \a enabled is true, QTextStream will attempt to detect Unicode     encoding by peeking into the stream data to see if it can find the     UTF-16 or UTF-32 BOM (Byte Order Mark). If this mark is found, QTextStream     will replace the current codec with the UTF codec.      This function can be used together with setCodec(). It is common     to set the codec to UTF-8, and then enable UTF-16 detection.      \sa autoDetectUnicode(), setCodec() */
end_comment
begin_function
DECL|function|setAutoDetectUnicode
name|void
name|QTextStream
operator|::
name|setAutoDetectUnicode
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoDetectUnicode
operator|=
name|enabled
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if automatic Unicode detection is enabled, otherwise     returns false. Automatic Unicode detection is enabled by default.      \sa setAutoDetectUnicode(), setCodec() */
end_comment
begin_function
DECL|function|autoDetectUnicode
name|bool
name|QTextStream
operator|::
name|autoDetectUnicode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autoDetectUnicode
return|;
block|}
end_function
begin_comment
comment|/*!     If \a generate is true and a UTF codec is used, QTextStream will insert     the BOM (Byte Order Mark) before any data has been written to the     device. If \a generate is false, no BOM will be inserted. This function     must be called before any data is written. Otherwise, it does nothing.      \sa generateByteOrderMark(), bom() */
end_comment
begin_function
DECL|function|setGenerateByteOrderMark
name|void
name|QTextStream
operator|::
name|setGenerateByteOrderMark
parameter_list|(
name|bool
name|generate
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|d
operator|->
name|writeConverterState
operator|.
name|flags
operator|&=
operator|~
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
else|else
name|d
operator|->
name|writeConverterState
operator|.
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns true if QTextStream is set to generate the UTF BOM (Byte Order     Mark) when using a UTF codec; otherwise returns false. UTF BOM generation is     set to false by default.      \sa setGenerateByteOrderMark() */
end_comment
begin_function
DECL|function|generateByteOrderMark
name|bool
name|QTextStream
operator|::
name|generateByteOrderMark
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|writeConverterState
operator|.
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
operator|==
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \since 4.5      Sets the locale for this stream to \a locale. The specified locale is     used for conversions between numbers and their string representations.      The default locale is C and it is a special case - the thousands     group separator is not used for backward compatibility reasons.      \sa locale() */
end_comment
begin_function
DECL|function|setLocale
name|void
name|QTextStream
operator|::
name|setLocale
parameter_list|(
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextStream
argument_list|)
expr_stmt|;
name|d
operator|->
name|locale
operator|=
name|locale
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the locale for this stream. The default locale is C.      \sa setLocale() */
end_comment
begin_function
DECL|function|locale
name|QLocale
name|QTextStream
operator|::
name|locale
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextStream
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|locale
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
