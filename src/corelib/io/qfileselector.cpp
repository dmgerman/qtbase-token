begin_unit
begin_comment
comment|/*************************************************************************** ** ** Copyright (C) 2013 BlackBerry Limited. All rights reserved. ** Copyright (C) 2016 Intel Corporation. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qfileselector.h"
end_include
begin_include
include|#
directive|include
file|"qfileselector_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/QFile>
end_include
begin_include
include|#
directive|include
file|<QtCore/QDir>
end_include
begin_include
include|#
directive|include
file|<QtCore/QMutex>
end_include
begin_include
include|#
directive|include
file|<QtCore/QMutexLocker>
end_include
begin_include
include|#
directive|include
file|<QtCore/QUrl>
end_include
begin_include
include|#
directive|include
file|<QtCore/QFileInfo>
end_include
begin_include
include|#
directive|include
file|<QtCore/QLocale>
end_include
begin_include
include|#
directive|include
file|<QtCore/QDebug>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|//Environment variable to allow tooling full control of file selectors
DECL|variable|env_override
specifier|static
specifier|const
name|char
name|env_override
index|[]
init|=
literal|"QT_NO_BUILTIN_SELECTORS"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|selectorIndicator
specifier|static
specifier|const
name|ushort
name|selectorIndicator
init|=
literal|'+'
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|Q_GLOBAL_STATIC
argument_list|(
name|QFileSelectorSharedData
argument_list|,
name|sharedData
argument_list|)
expr_stmt|;
end_expr_stmt
begin_decl_stmt
DECL|variable|sharedDataMutex
specifier|static
name|QBasicMutex
name|sharedDataMutex
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QFileSelectorPrivate
name|QFileSelectorPrivate
operator|::
name|QFileSelectorPrivate
parameter_list|()
member_init_list|:
name|QObjectPrivate
argument_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     \class QFileSelector     \inmodule QtCore     \brief QFileSelector provides a convenient way of selecting file variants.     \since 5.2      QFileSelector is a convenience for selecting file variants based on platform or device     characteristics. This allows you to develop and deploy one codebase containing all the     different variants more easily in some circumstances, such as when the correct variant cannot     be determined during the deploy step.      \section1 Using QFileSelector      If you always use the same file you do not need to use QFileSelector.      Consider the following example usage, where you want to use different settings files on     different locales. You might select code between locales like this:      \code     QString defaultsBasePath = "data/";     QString defaultsPath = defaultsBasePath + "defaults.conf";     QString localizedPath = defaultsBasePath             + QString("%1/defaults.conf").arg(QLocale().name());     if (QFile::exists(localizedPath))         defaultsPath = localizedPath;     QFile defaults(defaultsPath);     \endcode      Similarly, if you want to pick a different data file based on target platform,     your code might look something like this:     \code     QString defaultsPath = "data/defaults.conf"; #if defined(Q_OS_ANDROID)     defaultsPath = "data/android/defaults.conf"; #elif defined(Q_OS_IOS)     defaultsPath = "data/ios/defaults.conf"; #endif     QFile defaults(defaultsPath);     \endcode      QFileSelector provides a convenient alternative to writing such boilerplate code, and in the     latter case it allows you to start using an platform-specific configuration without a recompile.     QFileSelector also allows for chaining of multiple selectors in a convenient way, for example     selecting a different file only on certain combinations of platform and locale. For example, to     select based on platform and/or locale, the code is as follows:      \code     QFileSelector selector;     QFile defaultsFile(selector.select("data/defaults.conf"));     \endcode      The files to be selected are placed in directories named with a \c'+' and a selector name. In the above     example you could have the platform configurations selected by placing them in the following locations:     \code     data/defaults.conf     data/+android/defaults.conf     data/+ios/+en_GB/defaults.conf     \endcode      To find selected files, QFileSelector looks in the same directory as the base file. If there are     any directories of the form +<selector> with an active selector, QFileSelector will prefer a file     with the same file name from that directory over the base file. These directories can be nested to     check against multiple selectors, for example:     \code     images/background.png     images/+android/+en_GB/background.png     \endcode     With those files available, you would select a different file on the android platform,     but only if the locale was en_GB.      QFileSelector will not attempt to select if the base file does not exist. For error handling in     the case no valid selectors are present, it is recommended to have a default or error-handling     file in the base file location even if you expect selectors to be present for all deployments.      In a future version, some may be marked as deploy-time static and be moved during the     deployment step as an optimization. As selectors come with a performance cost, it is     recommended to avoid their use in circumstances involving performance-critical code.      \section1 Adding Selectors      Selectors normally available are     \list     \li platform, any of the following strings which match the platform the application is running         on (list not exhaustive): android, ios, osx, darwin, mac, linux, wince, unix, windows.         On Linux, if it can be determined, the name of the distribution too, like debian,         fedora or opensuse.     \li locale, same as QLocale().name().     \endlist      Further selectors will be added from the \c QT_FILE_SELECTORS environment variable, which     when set should be a set of comma separated selectors. Note that this variable will only be     read once; selectors may not update if the variable changes while the application is running.     The initial set of selectors are evaluated only once, on first use.      You can also add extra selectors at runtime for custom behavior. These will be used in any     future calls to select(). If the extra selectors list has been changed, calls to select() will     use the new list and may return differently.      \section1 Conflict Resolution when Multiple Selectors Apply      When multiple selectors could be applied to the same file, the first matching selector is chosen.     The order selectors are checked in are:      \list 1     \li Selectors set via setExtraSelectors(), in the order they are in the list     \li Selectors in the \c QT_FILE_SELECTORS environment variable, from left to right     \li Locale     \li Platform     \endlist      Here is an example involving multiple selectors matching at the same time. It uses platform     selectors, plus an extra selector named "admin" is set by the application based on user     credentials. The example is sorted so that the lowest matching file would be chosen if all     selectors were present:      \code     images/background.png     images/+linux/background.png     images/+windows/background.png     images/+admin/background.png     images/+admin/+linux/background.png     \endcode      Because extra selectors are checked before platform the \c{+admin/background.png} will be chosen     on Windows when the admin selector is set, and \c{+windows/background.png} will be chosen on     Windows when the admin selector is not set.  On Linux, the \c{+admin/+linux/background.png} will be     chosen when admin is set, and the \c{+linux/background.png} when it is not.  */
end_comment
begin_comment
comment|/*!     Create a QFileSelector instance. This instance will have the same static selectors as other     QFileSelector instances, but its own set of extra selectors.      If supplied, it will have the given QObject \a parent. */
end_comment
begin_constructor
DECL|function|QFileSelector
name|QFileSelector
operator|::
name|QFileSelector
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|(
operator|new
name|QFileSelectorPrivate
argument_list|()
operator|)
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Destroys this selector instance. */
end_comment
begin_destructor
DECL|function|~QFileSelector
name|QFileSelector
operator|::
name|~
name|QFileSelector
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!    This function returns the selected version of the path, based on the conditions at runtime.    If no selectable files are present, returns the original \a filePath.     If the original file does not exist, the original \a filePath is returned. This means that you    must have a base file to fall back on, you cannot have only files in selectable sub-directories.     See the class overview for the selection algorithm. */
end_comment
begin_function
DECL|function|select
name|QString
name|QFileSelector
operator|::
name|select
parameter_list|(
specifier|const
name|QString
modifier|&
name|filePath
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileSelector
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|select
argument_list|(
name|filePath
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|isLocalScheme
specifier|static
name|bool
name|isLocalScheme
parameter_list|(
specifier|const
name|QString
modifier|&
name|file
parameter_list|)
block|{
name|bool
name|local
init|=
name|file
operator|==
name|QLatin1String
argument_list|(
literal|"qrc"
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_ANDROID
name|local
operator||=
name|file
operator|==
name|QLatin1String
argument_list|(
literal|"assets"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|local
return|;
block|}
end_function
begin_comment
comment|/*!    This is a convenience version of select operating on QUrl objects. If the scheme is not file or qrc,    \a filePath is returned immediately. Otherwise selection is applied to the path of \a filePath    and a QUrl is returned with the selected path and other QUrl parts the same as \a filePath.     See the class overview for the selection algorithm. */
end_comment
begin_function
DECL|function|select
name|QUrl
name|QFileSelector
operator|::
name|select
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|filePath
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileSelector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isLocalScheme
argument_list|(
name|filePath
operator|.
name|scheme
argument_list|()
argument_list|)
operator|&&
operator|!
name|filePath
operator|.
name|isLocalFile
argument_list|()
condition|)
return|return
name|filePath
return|;
name|QUrl
name|ret
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|isLocalScheme
argument_list|(
name|filePath
operator|.
name|scheme
argument_list|()
argument_list|)
condition|)
block|{
name|QLatin1String
name|scheme
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_ANDROID
comment|// use other scheme because ":" means "qrc" here
if|if
condition|(
name|filePath
operator|.
name|scheme
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"assets"
argument_list|)
condition|)
name|scheme
operator|=
name|QLatin1String
argument_list|(
literal|"assets:"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QString
name|equivalentPath
init|=
name|scheme
operator|+
name|filePath
operator|.
name|path
argument_list|()
decl_stmt|;
name|QString
name|selectedPath
init|=
name|d
operator|->
name|select
argument_list|(
name|equivalentPath
argument_list|)
decl_stmt|;
name|ret
operator|.
name|setPath
argument_list|(
name|selectedPath
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|scheme
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|QUrl
operator|::
name|fromLocalFile
argument_list|(
name|d
operator|->
name|select
argument_list|(
name|ret
operator|.
name|toLocalFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|selectionHelper
specifier|static
name|QString
name|selectionHelper
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|selectors
parameter_list|)
block|{
comment|/* selectionHelper does a depth-first search of possible selected files. Because there is strict        selector ordering in the API, we can stop checking as soon as we find the file in a directory        which does not contain any other valid selector directories.     */
name|Q_ASSERT
argument_list|(
name|path
operator|.
name|isEmpty
argument_list|()
operator|||
name|path
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|QString
modifier|&
name|s
range|:
name|selectors
control|)
block|{
name|QString
name|prospectiveBase
init|=
name|path
operator|+
name|QLatin1Char
argument_list|(
name|selectorIndicator
argument_list|)
operator|+
name|s
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|QStringList
name|remainingSelectors
init|=
name|selectors
decl_stmt|;
name|remainingSelectors
operator|.
name|removeAll
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QDir
argument_list|(
name|prospectiveBase
argument_list|)
operator|.
name|exists
argument_list|()
condition|)
continue|continue;
name|QString
name|prospectiveFile
init|=
name|selectionHelper
argument_list|(
name|prospectiveBase
argument_list|,
name|fileName
argument_list|,
name|remainingSelectors
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|prospectiveFile
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|prospectiveFile
return|;
block|}
comment|// If we reach here there were no successful files found at a lower level in this branch, so we
comment|// should check this level as a potential result.
if|if
condition|(
operator|!
name|QFile
operator|::
name|exists
argument_list|(
name|path
operator|+
name|fileName
argument_list|)
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|path
operator|+
name|fileName
return|;
block|}
end_function
begin_function
DECL|function|select
name|QString
name|QFileSelectorPrivate
operator|::
name|select
parameter_list|(
specifier|const
name|QString
modifier|&
name|filePath
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QFileSelector
argument_list|)
expr_stmt|;
name|QFileInfo
name|fi
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
comment|// If file doesn't exist, don't select
if|if
condition|(
operator|!
name|fi
operator|.
name|exists
argument_list|()
condition|)
return|return
name|filePath
return|;
name|QString
name|ret
init|=
name|selectionHelper
argument_list|(
name|fi
operator|.
name|path
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
name|QString
argument_list|()
else|:
name|fi
operator|.
name|path
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|fi
operator|.
name|fileName
argument_list|()
argument_list|,
name|q
operator|->
name|allSelectors
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|ret
return|;
return|return
name|filePath
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the list of extra selectors which have been added programmatically to this instance. */
end_comment
begin_function
DECL|function|extraSelectors
name|QStringList
name|QFileSelector
operator|::
name|extraSelectors
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileSelector
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|extras
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the \a list of extra selectors which have been added programmatically to this instance.      These selectors have priority over any which have been automatically picked up. */
end_comment
begin_function
DECL|function|setExtraSelectors
name|void
name|QFileSelector
operator|::
name|setExtraSelectors
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|list
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFileSelector
argument_list|)
expr_stmt|;
name|d
operator|->
name|extras
operator|=
name|list
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the complete, ordered list of selectors used by this instance */
end_comment
begin_function
DECL|function|allSelectors
name|QStringList
name|QFileSelector
operator|::
name|allSelectors
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileSelector
argument_list|)
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|sharedDataMutex
argument_list|)
decl_stmt|;
name|QFileSelectorPrivate
operator|::
name|updateSelectors
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|extras
operator|+
name|sharedData
operator|->
name|staticSelectors
return|;
block|}
end_function
begin_function
DECL|function|updateSelectors
name|void
name|QFileSelectorPrivate
operator|::
name|updateSelectors
parameter_list|()
block|{
if|if
condition|(
operator|!
name|sharedData
operator|->
name|staticSelectors
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|//Already loaded
name|QLatin1Char
name|pathSep
argument_list|(
literal|','
argument_list|)
decl_stmt|;
name|QStringList
name|envSelectors
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|qgetenv
argument_list|(
literal|"QT_FILE_SELECTORS"
argument_list|)
argument_list|)
operator|.
name|split
argument_list|(
name|pathSep
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
name|envSelectors
operator|.
name|count
argument_list|()
condition|)
name|sharedData
operator|->
name|staticSelectors
operator|<<
name|envSelectors
expr_stmt|;
if|if
condition|(
operator|!
name|qEnvironmentVariableIsEmpty
argument_list|(
name|env_override
argument_list|)
condition|)
return|return;
name|sharedData
operator|->
name|staticSelectors
operator|<<
name|sharedData
operator|->
name|preloadedStatics
expr_stmt|;
comment|//Potential for static selectors from other modules
comment|// TODO: Update on locale changed?
name|sharedData
operator|->
name|staticSelectors
operator|<<
name|QLocale
argument_list|()
operator|.
name|name
argument_list|()
expr_stmt|;
name|sharedData
operator|->
name|staticSelectors
operator|<<
name|platformSelectors
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|platformSelectors
name|QStringList
name|QFileSelectorPrivate
operator|::
name|platformSelectors
parameter_list|()
block|{
comment|// similar, but not identical to QSysInfo::osType
name|QStringList
name|ret
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
comment|// can't fall back to QSysInfo because we need both "winphone" and "winrt" for the Windows Phone case
name|ret
operator|<<
name|QStringLiteral
argument_list|(
literal|"windows"
argument_list|)
expr_stmt|;
name|ret
operator|<<
name|QSysInfo
operator|::
name|kernelType
argument_list|()
expr_stmt|;
comment|// "wince" and "winnt"
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
name|ret
operator|<<
name|QStringLiteral
argument_list|(
literal|"winrt"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINPHONE
argument_list|)
name|ret
operator|<<
name|QStringLiteral
argument_list|(
literal|"winphone"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|ret
operator|<<
name|QStringLiteral
argument_list|(
literal|"unix"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
comment|// we don't want "linux" for Android
name|ret
operator|<<
name|QSysInfo
operator|::
name|kernelType
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MAC
name|ret
operator|<<
name|QStringLiteral
argument_list|(
literal|"mac"
argument_list|)
expr_stmt|;
comment|// compatibility, since kernelType() is "darwin"
endif|#
directive|endif
endif|#
directive|endif
name|QString
name|productName
init|=
name|QSysInfo
operator|::
name|productType
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MACOS
if|if
condition|(
name|productName
operator|!=
name|QLatin1String
argument_list|(
literal|"osx"
argument_list|)
condition|)
name|ret
operator|<<
name|QStringLiteral
argument_list|(
literal|"osx"
argument_list|)
expr_stmt|;
comment|// compatibility
endif|#
directive|endif
if|if
condition|(
name|productName
operator|!=
name|QLatin1String
argument_list|(
literal|"unknown"
argument_list|)
condition|)
name|ret
operator|<<
name|productName
expr_stmt|;
comment|// "opensuse", "fedora", "macos", "ios", "android"
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|addStatics
name|void
name|QFileSelectorPrivate
operator|::
name|addStatics
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|statics
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|sharedDataMutex
argument_list|)
decl_stmt|;
name|sharedData
operator|->
name|preloadedStatics
operator|<<
name|statics
expr_stmt|;
name|sharedData
operator|->
name|staticSelectors
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qfileselector.cpp"
end_include
end_unit
