begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qfiledevice.h"
end_include
begin_include
include|#
directive|include
file|"qfiledevice_p.h"
end_include
begin_include
include|#
directive|include
file|"qfsfileengine_p.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
end_ifdef
begin_define
DECL|macro|tr
define|#
directive|define
name|tr
parameter_list|(
name|X
parameter_list|)
value|QString::fromLatin1(X)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|QFILE_WRITEBUFFER_SIZE
specifier|static
specifier|const
name|int
name|QFILE_WRITEBUFFER_SIZE
init|=
literal|16384
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QFileDevicePrivate
name|QFileDevicePrivate
operator|::
name|QFileDevicePrivate
parameter_list|()
member_init_list|:
name|fileEngine
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|writeBuffer
argument_list|(
name|QFILE_WRITEBUFFER_SIZE
argument_list|)
member_init_list|,
name|cachedSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|error
argument_list|(
name|QFile
operator|::
name|NoError
argument_list|)
member_init_list|,
name|lastWasWrite
argument_list|(
literal|false
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QFileDevicePrivate
name|QFileDevicePrivate
operator|::
name|~
name|QFileDevicePrivate
parameter_list|()
block|{
operator|delete
name|fileEngine
expr_stmt|;
name|fileEngine
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|engine
name|QAbstractFileEngine
modifier|*
name|QFileDevicePrivate
operator|::
name|engine
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|fileEngine
condition|)
name|fileEngine
operator|=
operator|new
name|QFSFileEngine
expr_stmt|;
return|return
name|fileEngine
return|;
block|}
end_function
begin_function
DECL|function|setError
name|void
name|QFileDevicePrivate
operator|::
name|setError
parameter_list|(
name|QFileDevice
operator|::
name|FileError
name|err
parameter_list|)
block|{
name|error
operator|=
name|err
expr_stmt|;
name|errorString
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setError
name|void
name|QFileDevicePrivate
operator|::
name|setError
parameter_list|(
name|QFileDevice
operator|::
name|FileError
name|err
parameter_list|,
specifier|const
name|QString
modifier|&
name|errStr
parameter_list|)
block|{
name|error
operator|=
name|err
expr_stmt|;
name|errorString
operator|=
name|errStr
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setError
name|void
name|QFileDevicePrivate
operator|::
name|setError
parameter_list|(
name|QFileDevice
operator|::
name|FileError
name|err
parameter_list|,
name|int
name|errNum
parameter_list|)
block|{
name|error
operator|=
name|err
expr_stmt|;
name|errorString
operator|=
name|qt_error_string
argument_list|(
name|errNum
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \enum QFileDevice::FileError      This enum describes the errors that may be returned by the error()     function.      \value NoError          No error occurred.     \value ReadError        An error occurred when reading from the file.     \value WriteError       An error occurred when writing to the file.     \value FatalError       A fatal error occurred.     \value ResourceError    Out of resources (e.g., too many open files, out of memory, etc.)     \value OpenError        The file could not be opened.     \value AbortError       The operation was aborted.     \value TimeOutError     A timeout occurred.     \value UnspecifiedError An unspecified error occurred.     \value RemoveError      The file could not be removed.     \value RenameError      The file could not be renamed.     \value PositionError    The position in the file could not be changed.     \value ResizeError      The file could not be resized.     \value PermissionsError The file could not be accessed.     \value CopyError        The file could not be copied. */
end_comment
begin_comment
comment|/*!     \enum QFileDevice::Permission      This enum is used by the permission() function to report the     permissions and ownership of a file. The values may be OR-ed     together to test multiple permissions and ownership values.      \value ReadOwner The file is readable by the owner of the file.     \value WriteOwner The file is writable by the owner of the file.     \value ExeOwner The file is executable by the owner of the file.     \value ReadUser The file is readable by the user.     \value WriteUser The file is writable by the user.     \value ExeUser The file is executable by the user.     \value ReadGroup The file is readable by the group.     \value WriteGroup The file is writable by the group.     \value ExeGroup The file is executable by the group.     \value ReadOther The file is readable by anyone.     \value WriteOther The file is writable by anyone.     \value ExeOther The file is executable by anyone.      \warning Because of differences in the platforms supported by Qt,     the semantics of ReadUser, WriteUser and ExeUser are     platform-dependent: On Unix, the rights of the owner of the file     are returned and on Windows the rights of the current user are     returned. This behavior might change in a future Qt version.      \note On NTFS file systems, ownership and permissions checking is     disabled by default for performance reasons. To enable it,     include the following line:      \snippet ntfsp.cpp 0      Permission checking is then turned on and off by incrementing and     decrementing \c qt_ntfs_permission_lookup by 1.      \snippet ntfsp.cpp 1 */
end_comment
begin_comment
comment|//************* QFileDevice
end_comment
begin_comment
comment|/*!     \class QFileDevice     \inmodule QtCore     \since 5.0      \brief The QFileDevice class provides an interface for reading from and writing to open files.      \ingroup io      \reentrant      QFileDevice is the base class for I/O devices that can read and write text and binary files     and \l{The Qt Resource System}{resources}. QFile offers the main functionality,     QFileDevice serves as a base class for sharing functionality with other file devices such     as QTemporaryFile, by providing all the operations that can be done on files that have     been opened by QFile or QTemporaryFile.      \sa QFile, QTemporaryFile */
end_comment
begin_comment
comment|/*!     \enum QFileDevice::FileHandleFlag      This enum is used when opening a file to specify additional     options which only apply to files and not to a generic     QIODevice.      \value AutoCloseHandle The file handle passed into open() should be     closed by close(), the default behavior is that close just flushes     the file and the application is responsible for closing the file handle.     When opening a file by name, this flag is ignored as Qt always owns the     file handle and must close it.     \value DontCloseHandle If not explicitly closed, the underlying file     handle is left open when the QFile object is destroyed.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
end_ifdef
begin_constructor
DECL|function|QFileDevice
name|QFileDevice
operator|::
name|QFileDevice
parameter_list|()
member_init_list|:
name|QIODevice
argument_list|(
operator|*
operator|new
name|QFileDevicePrivate
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QFileDevice
name|QFileDevice
operator|::
name|QFileDevice
parameter_list|(
name|QFileDevicePrivate
modifier|&
name|dd
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
name|dd
argument_list|)
block|{ }
end_constructor
begin_else
else|#
directive|else
end_else
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QFileDevice
name|QFileDevice
operator|::
name|QFileDevice
parameter_list|()
member_init_list|:
name|QIODevice
argument_list|(
operator|*
operator|new
name|QFileDevicePrivate
argument_list|,
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QFileDevice
name|QFileDevice
operator|::
name|QFileDevice
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
operator|*
operator|new
name|QFileDevicePrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QFileDevice
name|QFileDevice
operator|::
name|QFileDevice
parameter_list|(
name|QFileDevicePrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Destroys the file device, closing it if necessary. */
end_comment
begin_destructor
DECL|function|~QFileDevice
name|QFileDevice
operator|::
name|~
name|QFileDevice
parameter_list|()
block|{
name|close
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns \c true if the file can only be manipulated sequentially;     otherwise returns \c false.      Most files support random-access, but some special files may not.      \sa QIODevice::isSequential() */
end_comment
begin_function
DECL|function|isSequential
name|bool
name|QFileDevice
operator|::
name|isSequential
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileDevice
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fileEngine
operator|&&
name|d
operator|->
name|fileEngine
operator|->
name|isSequential
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the file handle of the file.    This is a small positive integer, suitable for use with C library   functions such as \c fdopen() and \c fcntl(). On systems that use file   descriptors for sockets (i.e. Unix systems, but not Windows) the handle   can be used with QSocketNotifier as well.    If the file is not open, or there is an error, handle() returns -1.    This function is not supported on Windows CE.    \sa QSocketNotifier */
end_comment
begin_function
DECL|function|handle
name|int
name|QFileDevice
operator|::
name|handle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileDevice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isOpen
argument_list|()
operator|||
operator|!
name|d
operator|->
name|fileEngine
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|d
operator|->
name|fileEngine
operator|->
name|handle
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the file.     The default implementation in QFileDevice returns a null string. */
end_comment
begin_function
DECL|function|fileName
name|QString
name|QFileDevice
operator|::
name|fileName
parameter_list|()
specifier|const
block|{
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|_qfile_writeData
specifier|static
specifier|inline
name|qint64
name|_qfile_writeData
parameter_list|(
name|QAbstractFileEngine
modifier|*
name|engine
parameter_list|,
name|QRingBuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|qint64
name|ret
init|=
name|engine
operator|->
name|write
argument_list|(
name|buffer
operator|->
name|readPointer
argument_list|()
argument_list|,
name|buffer
operator|->
name|nextDataBlockSize
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
name|buffer
operator|->
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     Flushes any buffered data to the file. Returns \c true if successful;     otherwise returns \c false. */
end_comment
begin_function
DECL|function|flush
name|bool
name|QFileDevice
operator|::
name|flush
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFileDevice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|fileEngine
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFileDevice::flush: No file engine. Is IODevice open?"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qint64
name|size
init|=
name|d
operator|->
name|writeBuffer
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|_qfile_writeData
argument_list|(
name|d
operator|->
name|fileEngine
argument_list|,
operator|&
name|d
operator|->
name|writeBuffer
argument_list|)
operator|!=
name|size
condition|)
block|{
name|QFileDevice
operator|::
name|FileError
name|err
init|=
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|QFileDevice
operator|::
name|UnspecifiedError
condition|)
name|err
operator|=
name|QFileDevice
operator|::
name|WriteError
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|fileEngine
operator|->
name|flush
argument_list|()
condition|)
block|{
name|QFileDevice
operator|::
name|FileError
name|err
init|=
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|QFileDevice
operator|::
name|UnspecifiedError
condition|)
name|err
operator|=
name|QFileDevice
operator|::
name|WriteError
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Calls QFileDevice::flush() and closes the file. Errors from flush are ignored.    \sa QIODevice::close() */
end_comment
begin_function
DECL|function|close
name|void
name|QFileDevice
operator|::
name|close
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFileDevice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isOpen
argument_list|()
condition|)
return|return;
name|bool
name|flushed
init|=
name|flush
argument_list|()
decl_stmt|;
name|QIODevice
operator|::
name|close
argument_list|()
expr_stmt|;
comment|// reset write buffer
name|d
operator|->
name|lastWasWrite
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|writeBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// keep earlier error from flush
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|->
name|close
argument_list|()
operator|&&
name|flushed
condition|)
name|unsetError
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|flushed
condition|)
name|d
operator|->
name|setError
argument_list|(
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|pos
name|qint64
name|QFileDevice
operator|::
name|pos
parameter_list|()
specifier|const
block|{
return|return
name|QIODevice
operator|::
name|pos
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns \c true if the end of the file has been reached; otherwise returns   false.    For regular empty files on Unix (e.g. those in \c /proc), this function   returns \c true, since the file system reports that the size of such a file is   0. Therefore, you should not depend on atEnd() when reading data from such a   file, but rather call read() until no more data can be read. */
end_comment
begin_function
DECL|function|atEnd
name|bool
name|QFileDevice
operator|::
name|atEnd
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileDevice
argument_list|)
expr_stmt|;
comment|// If there's buffered data left, we're not at the end.
if|if
condition|(
operator|!
name|d
operator|->
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|isOpen
argument_list|()
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|ensureFlushed
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// If the file engine knows best, say what it says.
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|->
name|supportsExtension
argument_list|(
name|QAbstractFileEngine
operator|::
name|AtEndExtension
argument_list|)
condition|)
block|{
comment|// Check if the file engine supports AtEndExtension, and if it does,
comment|// check if the file engine claims to be at the end.
return|return
name|d
operator|->
name|fileEngine
operator|->
name|atEnd
argument_list|()
return|;
block|}
comment|// if it looks like we are at the end, or if size is not cached,
comment|// fall through to bytesAvailable() to make sure.
if|if
condition|(
name|pos
argument_list|()
operator|<
name|d
operator|->
name|cachedSize
condition|)
return|return
literal|false
return|;
comment|// Fall back to checking how much is available (will stat files).
return|return
name|bytesAvailable
argument_list|()
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QFileDevice::seek(qint64 pos)      For random-access devices, this function sets the current position     to \a pos, returning true on success, or false if an error occurred.     For sequential devices, the default behavior is to do nothing and     return false.      Seeking beyond the end of a file:     If the position is beyond the end of a file, then seek() will not     immediately extend the file. If a write is performed at this position,     then the file will be extended. The content of the file between the     previous end of file and the newly written data is UNDEFINED and     varies between platforms and file systems. */
end_comment
begin_function
DECL|function|seek
name|bool
name|QFileDevice
operator|::
name|seek
parameter_list|(
name|qint64
name|off
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFileDevice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFileDevice::seek: IODevice is not open"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|ensureFlushed
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|fileEngine
operator|->
name|seek
argument_list|(
name|off
argument_list|)
operator|||
operator|!
name|QIODevice
operator|::
name|seek
argument_list|(
name|off
argument_list|)
condition|)
block|{
name|QFileDevice
operator|::
name|FileError
name|err
init|=
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|QFileDevice
operator|::
name|UnspecifiedError
condition|)
name|err
operator|=
name|QFileDevice
operator|::
name|PositionError
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|unsetError
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|readLineData
name|qint64
name|QFileDevice
operator|::
name|readLineData
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFileDevice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ensureFlushed
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|qint64
name|read
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|->
name|supportsExtension
argument_list|(
name|QAbstractFileEngine
operator|::
name|FastReadLineExtension
argument_list|)
condition|)
block|{
name|read
operator|=
name|d
operator|->
name|fileEngine
operator|->
name|readLine
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Fall back to QIODevice's readLine implementation if the engine
comment|// cannot do it faster.
name|read
operator|=
name|QIODevice
operator|::
name|readLineData
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
operator|<
name|maxlen
condition|)
block|{
comment|// failed to read all requested, may be at the end of file, stop caching size so that it's rechecked
name|d
operator|->
name|cachedSize
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|read
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|readData
name|qint64
name|QFileDevice
operator|::
name|readData
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFileDevice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return
literal|0
return|;
name|unsetError
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ensureFlushed
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
specifier|const
name|qint64
name|read
init|=
name|d
operator|->
name|fileEngine
operator|->
name|read
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|read
operator|<
literal|0
condition|)
block|{
name|QFileDevice
operator|::
name|FileError
name|err
init|=
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|QFileDevice
operator|::
name|UnspecifiedError
condition|)
name|err
operator|=
name|QFileDevice
operator|::
name|ReadError
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
operator|<
name|len
condition|)
block|{
comment|// failed to read all requested, may be at the end of file, stop caching size so that it's rechecked
name|d
operator|->
name|cachedSize
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|read
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|putCharHelper
name|bool
name|QFileDevicePrivate
operator|::
name|putCharHelper
parameter_list|(
name|char
name|c
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
return|return
name|QIODevicePrivate
operator|::
name|putCharHelper
argument_list|(
name|c
argument_list|)
return|;
else|#
directive|else
comment|// Cutoff for code that doesn't only touch the buffer.
name|qint64
name|writeBufferSize
init|=
name|writeBuffer
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|openMode
operator|&
name|QIODevice
operator|::
name|Unbuffered
operator|)
operator|||
name|writeBufferSize
operator|+
literal|1
operator|>=
name|QFILE_WRITEBUFFER_SIZE
ifdef|#
directive|ifdef
name|Q_OS_WIN
operator|||
operator|(
operator|(
name|openMode
operator|&
name|QIODevice
operator|::
name|Text
operator|)
operator|&&
name|c
operator|==
literal|'\n'
operator|&&
name|writeBufferSize
operator|+
literal|2
operator|>=
name|QFILE_WRITEBUFFER_SIZE
operator|)
endif|#
directive|endif
condition|)
block|{
return|return
name|QIODevicePrivate
operator|::
name|putCharHelper
argument_list|(
name|c
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|openMode
operator|&
name|QIODevice
operator|::
name|WriteOnly
operator|)
condition|)
block|{
if|if
condition|(
name|openMode
operator|==
name|QIODevice
operator|::
name|NotOpen
condition|)
name|qWarning
argument_list|(
literal|"QIODevice::putChar: Closed device"
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QIODevice::putChar: ReadOnly device"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Make sure the device is positioned correctly.
specifier|const
name|bool
name|sequential
init|=
name|isSequential
argument_list|()
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
name|devicePos
operator|&&
operator|!
name|sequential
operator|&&
operator|!
name|q_func
argument_list|()
operator|->
name|seek
argument_list|(
name|pos
argument_list|)
condition|)
return|return
literal|false
return|;
name|lastWasWrite
operator|=
literal|true
expr_stmt|;
name|int
name|len
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
operator|(
name|openMode
operator|&
name|QIODevice
operator|::
name|Text
operator|)
operator|&&
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|len
expr_stmt|;
operator|*
name|writeBuffer
operator|.
name|reserve
argument_list|(
literal|1
argument_list|)
operator|=
literal|'\r'
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Write to buffer.
operator|*
name|writeBuffer
operator|.
name|reserve
argument_list|(
literal|1
argument_list|)
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|sequential
condition|)
block|{
name|pos
operator|+=
name|len
expr_stmt|;
name|devicePos
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|buffer
operator|.
name|skip
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|writeData
name|qint64
name|QFileDevice
operator|::
name|writeData
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFileDevice
argument_list|)
expr_stmt|;
name|unsetError
argument_list|()
expr_stmt|;
name|d
operator|->
name|lastWasWrite
operator|=
literal|true
expr_stmt|;
name|bool
name|buffered
init|=
operator|!
operator|(
name|d
operator|->
name|openMode
operator|&
name|Unbuffered
operator|)
decl_stmt|;
comment|// Flush buffered data if this read will overflow.
if|if
condition|(
name|buffered
operator|&&
operator|(
name|d
operator|->
name|writeBuffer
operator|.
name|size
argument_list|()
operator|+
name|len
operator|)
operator|>
name|QFILE_WRITEBUFFER_SIZE
condition|)
block|{
if|if
condition|(
operator|!
name|flush
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|// Write directly to the engine if the block size is larger than
comment|// the write buffer size.
if|if
condition|(
operator|!
name|buffered
operator|||
name|len
operator|>
name|QFILE_WRITEBUFFER_SIZE
condition|)
block|{
specifier|const
name|qint64
name|ret
init|=
name|d
operator|->
name|fileEngine
operator|->
name|write
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|QFileDevice
operator|::
name|FileError
name|err
init|=
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|QFileDevice
operator|::
name|UnspecifiedError
condition|)
name|err
operator|=
name|QFileDevice
operator|::
name|WriteError
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|// Write to the buffer.
name|char
modifier|*
name|writePointer
init|=
name|d
operator|->
name|writeBuffer
operator|.
name|reserve
argument_list|(
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
operator|*
name|writePointer
operator|=
operator|*
name|data
expr_stmt|;
else|else
operator|::
name|memcpy
argument_list|(
name|writePointer
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the file error status.      The I/O device status returns an error code. For example, if open()     returns \c false, or a read/write operation returns -1, this function can     be called to find out the reason why the operation failed.      \sa unsetError() */
end_comment
begin_function
DECL|function|error
name|QFileDevice
operator|::
name|FileError
name|QFileDevice
operator|::
name|error
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileDevice
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|error
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the file's error to QFileDevice::NoError.      \sa error() */
end_comment
begin_function
DECL|function|unsetError
name|void
name|QFileDevice
operator|::
name|unsetError
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFileDevice
argument_list|)
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QFileDevice
operator|::
name|NoError
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the size of the file.    For regular empty files on Unix (e.g. those in \c /proc), this function   returns 0; the contents of such a file are generated on demand in response   to you calling read(). */
end_comment
begin_function
DECL|function|size
name|qint64
name|QFileDevice
operator|::
name|size
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileDevice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ensureFlushed
argument_list|()
condition|)
return|return
literal|0
return|;
name|d
operator|->
name|cachedSize
operator|=
name|d
operator|->
name|engine
argument_list|()
operator|->
name|size
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|cachedSize
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the file size (in bytes) \a sz. Returns \c true if the     resize succeeds; false otherwise. If \a sz is larger than the file     currently is, the new bytes will be set to 0; if \a sz is smaller, the     file is simply truncated.      \sa size() */
end_comment
begin_function
DECL|function|resize
name|bool
name|QFileDevice
operator|::
name|resize
parameter_list|(
name|qint64
name|sz
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFileDevice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ensureFlushed
argument_list|()
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|engine
argument_list|()
expr_stmt|;
if|if
condition|(
name|isOpen
argument_list|()
operator|&&
name|d
operator|->
name|fileEngine
operator|->
name|pos
argument_list|()
operator|>
name|sz
condition|)
name|seek
argument_list|(
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fileEngine
operator|->
name|setSize
argument_list|(
name|sz
argument_list|)
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
name|d
operator|->
name|cachedSize
operator|=
name|sz
expr_stmt|;
return|return
literal|true
return|;
block|}
name|d
operator|->
name|cachedSize
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|ResizeError
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the complete OR-ed together combination of     QFile::Permission for the file.      \sa setPermissions() */
end_comment
begin_function
DECL|function|permissions
name|QFile
operator|::
name|Permissions
name|QFileDevice
operator|::
name|permissions
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFileDevice
argument_list|)
expr_stmt|;
name|QAbstractFileEngine
operator|::
name|FileFlags
name|perms
init|=
name|d
operator|->
name|engine
argument_list|()
operator|->
name|fileFlags
argument_list|(
name|QAbstractFileEngine
operator|::
name|PermsMask
argument_list|)
operator|&
name|QAbstractFileEngine
operator|::
name|PermsMask
decl_stmt|;
return|return
name|QFile
operator|::
name|Permissions
argument_list|(
operator|(
name|int
operator|)
name|perms
argument_list|)
return|;
comment|//ewww
block|}
end_function
begin_comment
comment|/*!     Sets the permissions for the file to the \a permissions specified.     Returns \c true if successful, or \c false if the permissions cannot be     modified.      \warning This function does not manipulate ACLs, which may limit its     effectiveness.      \sa permissions() */
end_comment
begin_function
DECL|function|setPermissions
name|bool
name|QFileDevice
operator|::
name|setPermissions
parameter_list|(
name|Permissions
name|permissions
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFileDevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|engine
argument_list|()
operator|->
name|setPermissions
argument_list|(
name|permissions
argument_list|)
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|d
operator|->
name|setError
argument_list|(
name|QFile
operator|::
name|PermissionsError
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QFileDevice::MemoryMapFlags     \since 4.4      This enum describes special options that may be used by the map()     function.      \value NoOptions        No options.     \value MapPrivateOption The mapped memory will be private, so any     modifications will not be visible to other processes and will not     be written to disk.  Any such modifications will be lost when the     memory is unmapped.  It is unspecified whether modifications made     to the file made after the mapping is created will be visible through     the mapped memory.  This flag is not supported on Windows CE.     This enum value was introduced in Qt 5.4. */
end_comment
begin_comment
comment|/*!     Maps \a size bytes of the file into memory starting at \a offset.  A file     should be open for a map to succeed but the file does not need to stay     open after the memory has been mapped.  When the QFile is destroyed     or a new file is opened with this object, any maps that have not been     unmapped will automatically be unmapped.      The mapping will have the same open mode as the file (read and/or write),     except when using MapPrivateOption, in which case it is always possible     to write to the mapped memory.      Any mapping options can be passed through \a flags.      Returns a pointer to the memory or 0 if there is an error.      \note On Windows CE 5.0 the file will be closed before mapping occurs.      \sa unmap()  */
end_comment
begin_function
DECL|function|map
name|uchar
modifier|*
name|QFileDevice
operator|::
name|map
parameter_list|(
name|qint64
name|offset
parameter_list|,
name|qint64
name|size
parameter_list|,
name|MemoryMapFlags
name|flags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFileDevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|engine
argument_list|()
operator|&&
name|d
operator|->
name|fileEngine
operator|->
name|supportsExtension
argument_list|(
name|QAbstractFileEngine
operator|::
name|MapExtension
argument_list|)
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
name|uchar
modifier|*
name|address
init|=
name|d
operator|->
name|fileEngine
operator|->
name|map
argument_list|(
name|offset
argument_list|,
name|size
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
operator|==
literal|0
condition|)
name|d
operator|->
name|setError
argument_list|(
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|address
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Unmaps the memory \a address.      Returns \c true if the unmap succeeds; false otherwise.      \sa map()  */
end_comment
begin_function
DECL|function|unmap
name|bool
name|QFileDevice
operator|::
name|unmap
parameter_list|(
name|uchar
modifier|*
name|address
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFileDevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|engine
argument_list|()
operator|&&
name|d
operator|->
name|fileEngine
operator|->
name|supportsExtension
argument_list|(
name|QAbstractFileEngine
operator|::
name|UnMapExtension
argument_list|)
condition|)
block|{
name|unsetError
argument_list|()
expr_stmt|;
name|bool
name|success
init|=
name|d
operator|->
name|fileEngine
operator|->
name|unmap
argument_list|(
name|address
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
name|d
operator|->
name|setError
argument_list|(
name|d
operator|->
name|fileEngine
operator|->
name|error
argument_list|()
argument_list|,
name|d
operator|->
name|fileEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
name|d
operator|->
name|setError
argument_list|(
name|PermissionsError
argument_list|,
name|tr
argument_list|(
literal|"No file engine available or engine does not support UnMapExtension"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
