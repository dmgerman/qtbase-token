begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qplatformdefs.h>
end_include
begin_include
include|#
directive|include
file|"qfilesystemwatcher.h"
end_include
begin_include
include|#
directive|include
file|"qfilesystemwatcher_fsevents_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_FILESYSTEMWATCHER
end_ifndef
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<mach/mach.h>
end_include
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<CoreFoundation/CFRunLoop.h>
end_include
begin_include
include|#
directive|include
file|<CoreFoundation/CFUUID.h>
end_include
begin_include
include|#
directive|include
file|<CoreServices/CoreServices.h>
end_include
begin_include
include|#
directive|include
file|<AvailabilityMacros.h>
end_include
begin_include
include|#
directive|include
file|<private/qcore_mac_p.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
if|#
directive|if
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|>=
name|MAC_OS_X_VERSION_10_5
comment|// Static operator overloading so for the sake of some convieniece.
comment|// They only live in this compilation unit to avoid polluting Qt in general.
DECL|function|operator ==
specifier|static
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|struct
operator|::
name|timespec
modifier|&
name|left
parameter_list|,
specifier|const
name|struct
operator|::
name|timespec
modifier|&
name|right
parameter_list|)
block|{
return|return
name|left
operator|.
name|tv_sec
operator|==
name|right
operator|.
name|tv_sec
operator|&&
name|left
operator|.
name|tv_nsec
operator|==
name|right
operator|.
name|tv_nsec
return|;
block|}
end_function
begin_function
DECL|function|operator ==
specifier|static
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|struct
operator|::
name|stat64
modifier|&
name|left
parameter_list|,
specifier|const
name|struct
operator|::
name|stat64
modifier|&
name|right
parameter_list|)
block|{
return|return
name|left
operator|.
name|st_dev
operator|==
name|right
operator|.
name|st_dev
operator|&&
name|left
operator|.
name|st_mode
operator|==
name|right
operator|.
name|st_mode
operator|&&
name|left
operator|.
name|st_size
operator|==
name|right
operator|.
name|st_size
operator|&&
name|left
operator|.
name|st_ino
operator|==
name|right
operator|.
name|st_ino
operator|&&
name|left
operator|.
name|st_uid
operator|==
name|right
operator|.
name|st_uid
operator|&&
name|left
operator|.
name|st_gid
operator|==
name|right
operator|.
name|st_gid
operator|&&
name|left
operator|.
name|st_mtimespec
operator|==
name|right
operator|.
name|st_mtimespec
operator|&&
name|left
operator|.
name|st_ctimespec
operator|==
name|right
operator|.
name|st_ctimespec
operator|&&
name|left
operator|.
name|st_flags
operator|==
name|right
operator|.
name|st_flags
return|;
block|}
end_function
begin_function
DECL|function|operator !=
specifier|static
name|bool
name|operator
name|!=
parameter_list|(
specifier|const
name|struct
operator|::
name|stat64
modifier|&
name|left
parameter_list|,
specifier|const
name|struct
operator|::
name|stat64
modifier|&
name|right
parameter_list|)
block|{
return|return
operator|!
operator|(
name|operator
name|==
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|addPathToHash
specifier|static
name|void
name|addPathToHash
parameter_list|(
name|PathHash
modifier|&
name|pathHash
parameter_list|,
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QFileInfo
modifier|&
name|fileInfo
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|PathInfoList
modifier|&
name|list
init|=
name|pathHash
index|[
name|key
index|]
decl_stmt|;
name|list
operator|.
name|push_back
argument_list|(
name|PathInfo
argument_list|(
name|path
argument_list|,
name|fileInfo
operator|.
name|canonicalFilePath
argument_list|()
operator|.
name|normalized
argument_list|(
name|QString
operator|::
name|NormalizationForm_D
argument_list|)
operator|.
name|toUtf8
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pathHash
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|removePathFromHash
specifier|static
name|void
name|removePathFromHash
parameter_list|(
name|PathHash
modifier|&
name|pathHash
parameter_list|,
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|PathInfoList
modifier|&
name|list
init|=
name|pathHash
index|[
name|key
index|]
decl_stmt|;
comment|// We make the assumption that the list contains unique paths
name|PathInfoList
operator|::
name|iterator
name|End
init|=
name|list
operator|.
name|end
argument_list|()
decl_stmt|;
name|PathInfoList
operator|::
name|iterator
name|it
init|=
name|list
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|End
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|originalPath
operator|==
name|path
condition|)
block|{
name|list
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|it
expr_stmt|;
block|}
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
name|pathHash
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stopFSStream
specifier|static
name|void
name|stopFSStream
parameter_list|(
name|FSEventStreamRef
name|stream
parameter_list|)
block|{
if|if
condition|(
name|stream
condition|)
block|{
name|FSEventStreamStop
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FSEventStreamInvalidate
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|createFSStreamPath
specifier|static
name|QString
name|createFSStreamPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|absolutePath
parameter_list|)
block|{
comment|// The path returned has a trailing slash, so ensure that here.
name|QString
name|string
init|=
name|absolutePath
decl_stmt|;
name|string
operator|.
name|reserve
argument_list|(
name|string
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|string
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function
begin_function
DECL|function|cleanupFSStream
specifier|static
name|void
name|cleanupFSStream
parameter_list|(
name|FSEventStreamRef
name|stream
parameter_list|)
block|{
if|if
condition|(
name|stream
condition|)
name|FSEventStreamRelease
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|QtFSEventFlags
specifier|const
name|FSEventStreamCreateFlags
name|QtFSEventFlags
init|=
operator|(
name|kFSEventStreamCreateFlagUseCFTypes
operator||
name|kFSEventStreamCreateFlagNoDefer
comment|/* | kFSEventStreamCreateFlagWatchRoot*/
operator|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|Latency
specifier|const
name|CFTimeInterval
name|Latency
init|=
literal|0.033
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|Latency
comment|// This will do updates 30 times a second which is probably more than you need.
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|QFSEventsFileSystemWatcherEngine
name|QFSEventsFileSystemWatcherEngine
operator|::
name|QFSEventsFileSystemWatcherEngine
parameter_list|()
member_init_list|:
name|fsStream
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pathsToWatch
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|threadsRunLoop
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QFSEventsFileSystemWatcherEngine
name|QFSEventsFileSystemWatcherEngine
operator|::
name|~
name|QFSEventsFileSystemWatcherEngine
parameter_list|()
block|{
if|#
directive|if
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|>=
name|MAC_OS_X_VERSION_10_5
comment|// I assume that at this point, QFileSystemWatcher has already called stop
comment|// on me, so I don't need to invalidate or stop my stream, simply
comment|// release it.
name|cleanupFSStream
argument_list|(
name|fsStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathsToWatch
condition|)
name|CFRelease
argument_list|(
name|pathsToWatch
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_function
DECL|function|create
name|QFSEventsFileSystemWatcherEngine
modifier|*
name|QFSEventsFileSystemWatcherEngine
operator|::
name|create
parameter_list|()
block|{
return|return
operator|new
name|QFSEventsFileSystemWatcherEngine
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|addPaths
name|QStringList
name|QFSEventsFileSystemWatcherEngine
operator|::
name|addPaths
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|paths
parameter_list|,
name|QStringList
modifier|*
name|files
parameter_list|,
name|QStringList
modifier|*
name|directories
parameter_list|)
block|{
if|#
directive|if
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|>=
name|MAC_OS_X_VERSION_10_5
name|stop
argument_list|()
expr_stmt|;
name|wait
argument_list|()
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
name|QStringList
name|failedToAdd
decl_stmt|;
comment|// if we have a running FSStreamEvent, we have to kill it, we'll re-add the stream soon.
name|FSEventStreamEventId
name|idToCheck
decl_stmt|;
if|if
condition|(
name|fsStream
condition|)
block|{
name|idToCheck
operator|=
name|FSEventStreamGetLatestEventId
argument_list|(
name|fsStream
argument_list|)
expr_stmt|;
name|cleanupFSStream
argument_list|(
name|fsStream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idToCheck
operator|=
name|kFSEventStreamEventIdSinceNow
expr_stmt|;
block|}
comment|// Brain-dead approach, but works. FSEvents actually can already read sub-trees, but since it's
comment|// work to figure out if we are doing a double register, we just register it twice as FSEvents
comment|// seems smart enough to only deliver one event. We also duplicate directory entries in here
comment|// (e.g., if you watch five files in the same directory, you get that directory included in the
comment|// array 5 times). This stupidity also makes remove work correctly though. I'll freely admit
comment|// that we could make this a bit smarter. If you do, check the auto-tests, they should catch at
comment|// least a couple of the issues.
name|QCFType
argument_list|<
name|CFMutableArrayRef
argument_list|>
name|tmpArray
init|=
name|CFArrayCreateMutable
argument_list|(
name|kCFAllocatorDefault
argument_list|,
literal|0
argument_list|,
operator|&
name|kCFTypeArrayCallBacks
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
modifier|&
name|path
init|=
name|paths
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QFileInfo
name|fileInfo
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fileInfo
operator|.
name|exists
argument_list|()
condition|)
block|{
name|failedToAdd
operator|.
name|append
argument_list|(
name|path
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fileInfo
operator|.
name|isDir
argument_list|()
condition|)
block|{
if|if
condition|(
name|directories
operator|->
name|contains
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|failedToAdd
operator|.
name|append
argument_list|(
name|path
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|directories
operator|->
name|append
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|// Full file path for dirs.
name|QCFString
name|cfpath
argument_list|(
name|createFSStreamPath
argument_list|(
name|fileInfo
operator|.
name|canonicalFilePath
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|addPathToHash
argument_list|(
name|dirPathInfoHash
argument_list|,
name|cfpath
argument_list|,
name|fileInfo
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|CFArrayAppendValue
argument_list|(
name|tmpArray
argument_list|,
name|cfpath
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|files
operator|->
name|contains
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|failedToAdd
operator|.
name|append
argument_list|(
name|path
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|// Just the absolute path (minus it's filename) for files.
name|QCFString
name|cfpath
argument_list|(
name|createFSStreamPath
argument_list|(
name|fileInfo
operator|.
name|canonicalPath
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|files
operator|->
name|append
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|addPathToHash
argument_list|(
name|filePathInfoHash
argument_list|,
name|cfpath
argument_list|,
name|fileInfo
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|CFArrayAppendValue
argument_list|(
name|tmpArray
argument_list|,
name|cfpath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|pathsToWatch
operator|&&
name|failedToAdd
operator|.
name|size
argument_list|()
operator|==
name|paths
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|failedToAdd
return|;
block|}
if|if
condition|(
name|CFArrayGetCount
argument_list|(
name|tmpArray
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pathsToWatch
condition|)
block|{
name|CFArrayAppendArray
argument_list|(
name|tmpArray
argument_list|,
name|pathsToWatch
argument_list|,
name|CFRangeMake
argument_list|(
literal|0
argument_list|,
name|CFArrayGetCount
argument_list|(
name|pathsToWatch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CFRelease
argument_list|(
name|pathsToWatch
argument_list|)
expr_stmt|;
block|}
name|pathsToWatch
operator|=
name|CFArrayCreateCopy
argument_list|(
name|kCFAllocatorDefault
argument_list|,
name|tmpArray
argument_list|)
expr_stmt|;
block|}
name|FSEventStreamContext
name|context
init|=
block|{
literal|0
block|,
name|this
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|fsStream
operator|=
name|FSEventStreamCreate
argument_list|(
name|kCFAllocatorDefault
argument_list|,
name|QFSEventsFileSystemWatcherEngine
operator|::
name|fseventsCallback
argument_list|,
operator|&
name|context
argument_list|,
name|pathsToWatch
argument_list|,
name|idToCheck
argument_list|,
name|Latency
argument_list|,
name|QtFSEventFlags
argument_list|)
expr_stmt|;
name|warmUpFSEvents
argument_list|()
expr_stmt|;
return|return
name|failedToAdd
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|paths
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|files
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|directories
argument_list|)
expr_stmt|;
return|return
name|QStringList
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|warmUpFSEvents
name|void
name|QFSEventsFileSystemWatcherEngine
operator|::
name|warmUpFSEvents
parameter_list|()
block|{
if|#
directive|if
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|>=
name|MAC_OS_X_VERSION_10_5
comment|// This function assumes that the mutex has already been grabbed before calling it.
comment|// It exits with the mutex still locked (Q_ASSERT(mutex.isLocked()) ;-).
name|start
argument_list|()
expr_stmt|;
name|waitCondition
operator|.
name|wait
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|removePaths
name|QStringList
name|QFSEventsFileSystemWatcherEngine
operator|::
name|removePaths
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|paths
parameter_list|,
name|QStringList
modifier|*
name|files
parameter_list|,
name|QStringList
modifier|*
name|directories
parameter_list|)
block|{
if|#
directive|if
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|>=
name|MAC_OS_X_VERSION_10_5
name|stop
argument_list|()
expr_stmt|;
name|wait
argument_list|()
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
comment|// short circuit for smarties that call remove before add and we have nothing.
if|if
condition|(
name|pathsToWatch
operator|==
literal|0
condition|)
return|return
name|paths
return|;
name|QStringList
name|failedToRemove
decl_stmt|;
comment|// if we have a running FSStreamEvent, we have to stop it, we'll re-add the stream soon.
name|FSEventStreamEventId
name|idToCheck
decl_stmt|;
if|if
condition|(
name|fsStream
condition|)
block|{
name|idToCheck
operator|=
name|FSEventStreamGetLatestEventId
argument_list|(
name|fsStream
argument_list|)
expr_stmt|;
name|cleanupFSStream
argument_list|(
name|fsStream
argument_list|)
expr_stmt|;
name|fsStream
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|idToCheck
operator|=
name|kFSEventStreamEventIdSinceNow
expr_stmt|;
block|}
name|CFIndex
name|itemCount
init|=
name|CFArrayGetCount
argument_list|(
name|pathsToWatch
argument_list|)
decl_stmt|;
name|QCFType
argument_list|<
name|CFMutableArrayRef
argument_list|>
name|tmpArray
init|=
name|CFArrayCreateMutableCopy
argument_list|(
name|kCFAllocatorDefault
argument_list|,
name|itemCount
argument_list|,
name|pathsToWatch
argument_list|)
decl_stmt|;
name|CFRelease
argument_list|(
name|pathsToWatch
argument_list|)
expr_stmt|;
name|pathsToWatch
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// Get the itemCount at the beginning to avoid any overruns during the iteration.
name|itemCount
operator|=
name|CFArrayGetCount
argument_list|(
name|tmpArray
argument_list|)
expr_stmt|;
specifier|const
name|QString
modifier|&
name|path
init|=
name|paths
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QFileInfo
name|fi
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|QCFString
name|cfpath
argument_list|(
name|createFSStreamPath
argument_list|(
name|fi
operator|.
name|canonicalPath
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|CFIndex
name|index
init|=
name|CFArrayGetFirstIndexOfValue
argument_list|(
name|tmpArray
argument_list|,
name|CFRangeMake
argument_list|(
literal|0
argument_list|,
name|itemCount
argument_list|)
argument_list|,
name|cfpath
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|CFArrayRemoveValueAtIndex
argument_list|(
name|tmpArray
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|files
operator|->
name|removeAll
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|removePathFromHash
argument_list|(
name|filePathInfoHash
argument_list|,
name|cfpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Could be a directory we are watching instead.
name|QCFString
name|cfdirpath
argument_list|(
name|createFSStreamPath
argument_list|(
name|fi
operator|.
name|canonicalFilePath
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|index
operator|=
name|CFArrayGetFirstIndexOfValue
argument_list|(
name|tmpArray
argument_list|,
name|CFRangeMake
argument_list|(
literal|0
argument_list|,
name|itemCount
argument_list|)
argument_list|,
name|cfdirpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|CFArrayRemoveValueAtIndex
argument_list|(
name|tmpArray
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|directories
operator|->
name|removeAll
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|removePathFromHash
argument_list|(
name|dirPathInfoHash
argument_list|,
name|cfpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|failedToRemove
operator|.
name|append
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|itemCount
operator|=
name|CFArrayGetCount
argument_list|(
name|tmpArray
argument_list|)
expr_stmt|;
if|if
condition|(
name|itemCount
operator|!=
literal|0
condition|)
block|{
name|pathsToWatch
operator|=
name|CFArrayCreateCopy
argument_list|(
name|kCFAllocatorDefault
argument_list|,
name|tmpArray
argument_list|)
expr_stmt|;
name|FSEventStreamContext
name|context
init|=
block|{
literal|0
block|,
name|this
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|fsStream
operator|=
name|FSEventStreamCreate
argument_list|(
name|kCFAllocatorDefault
argument_list|,
name|QFSEventsFileSystemWatcherEngine
operator|::
name|fseventsCallback
argument_list|,
operator|&
name|context
argument_list|,
name|pathsToWatch
argument_list|,
name|idToCheck
argument_list|,
name|Latency
argument_list|,
name|QtFSEventFlags
argument_list|)
expr_stmt|;
name|warmUpFSEvents
argument_list|()
expr_stmt|;
block|}
return|return
name|failedToRemove
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|paths
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|files
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|directories
argument_list|)
expr_stmt|;
return|return
name|QStringList
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|>=
name|MAC_OS_X_VERSION_10_5
end_if
begin_function
DECL|function|updateList
name|void
name|QFSEventsFileSystemWatcherEngine
operator|::
name|updateList
parameter_list|(
name|PathInfoList
modifier|&
name|list
parameter_list|,
name|bool
name|directory
parameter_list|,
name|bool
name|emitSignals
parameter_list|)
block|{
name|PathInfoList
operator|::
name|iterator
name|End
init|=
name|list
operator|.
name|end
argument_list|()
decl_stmt|;
name|PathInfoList
operator|::
name|iterator
name|it
init|=
name|list
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|End
condition|)
block|{
name|struct
operator|::
name|stat64
name|newInfo
decl_stmt|;
if|if
condition|(
operator|::
name|stat64
argument_list|(
name|it
operator|->
name|absolutePath
argument_list|,
operator|&
name|newInfo
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|emitSignals
condition|)
block|{
if|if
condition|(
name|newInfo
operator|!=
name|it
operator|->
name|savedInfo
condition|)
block|{
name|it
operator|->
name|savedInfo
operator|=
name|newInfo
expr_stmt|;
if|if
condition|(
name|directory
condition|)
emit|emit
name|directoryChanged
argument_list|(
name|it
operator|->
name|originalPath
argument_list|,
literal|false
argument_list|)
emit|;
else|else
emit|emit
name|fileChanged
argument_list|(
name|it
operator|->
name|originalPath
argument_list|,
literal|false
argument_list|)
emit|;
block|}
block|}
else|else
block|{
name|it
operator|->
name|savedInfo
operator|=
name|newInfo
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
name|emitSignals
condition|)
block|{
if|if
condition|(
name|directory
condition|)
emit|emit
name|directoryChanged
argument_list|(
name|it
operator|->
name|originalPath
argument_list|,
literal|true
argument_list|)
emit|;
else|else
emit|emit
name|fileChanged
argument_list|(
name|it
operator|->
name|originalPath
argument_list|,
literal|true
argument_list|)
emit|;
block|}
name|it
operator|=
name|list
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"%s:%d:QFSEventsFileSystemWatcherEngine: stat error on %s:%s"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|qPrintable
argument_list|(
name|it
operator|->
name|originalPath
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|updateHash
name|void
name|QFSEventsFileSystemWatcherEngine
operator|::
name|updateHash
parameter_list|(
name|PathHash
modifier|&
name|pathHash
parameter_list|)
block|{
name|PathHash
operator|::
name|iterator
name|HashEnd
init|=
name|pathHash
operator|.
name|end
argument_list|()
decl_stmt|;
name|PathHash
operator|::
name|iterator
name|it
init|=
name|pathHash
operator|.
name|begin
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|IsDirectory
init|=
operator|(
operator|&
name|pathHash
operator|==
operator|&
name|dirPathInfoHash
operator|)
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|HashEnd
condition|)
block|{
name|updateList
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|,
name|IsDirectory
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|it
operator|=
name|pathHash
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
else|else
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|fseventsCallback
name|void
name|QFSEventsFileSystemWatcherEngine
operator|::
name|fseventsCallback
parameter_list|(
name|ConstFSEventStreamRef
parameter_list|,
name|void
modifier|*
name|clientCallBackInfo
parameter_list|,
name|size_t
name|numEvents
parameter_list|,
name|void
modifier|*
name|eventPaths
parameter_list|,
specifier|const
name|FSEventStreamEventFlags
name|eventFlags
index|[]
parameter_list|,
specifier|const
name|FSEventStreamEventId
index|[]
parameter_list|)
block|{
if|#
directive|if
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|>=
name|MAC_OS_X_VERSION_10_5
name|QFSEventsFileSystemWatcherEngine
modifier|*
name|watcher
init|=
cast|static_cast
argument_list|<
name|QFSEventsFileSystemWatcherEngine
operator|*
argument_list|>
argument_list|(
name|clientCallBackInfo
argument_list|)
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|watcher
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|CFArrayRef
name|paths
init|=
cast|static_cast
argument_list|<
name|CFArrayRef
argument_list|>
argument_list|(
name|eventPaths
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numEvents
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
name|path
init|=
name|QCFString
operator|::
name|toQString
argument_list|(
cast|static_cast
argument_list|<
name|CFStringRef
argument_list|>
argument_list|(
name|CFArrayGetValueAtIndex
argument_list|(
name|paths
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|FSEventStreamEventFlags
name|pathFlags
init|=
name|eventFlags
index|[
name|i
index|]
decl_stmt|;
comment|// There are several flags that may be passed, but we really don't care about them ATM.
comment|// Here they are and why we don't care.
comment|// kFSEventStreamEventFlagHistoryDone--(very unlikely to be gotten, but even then, not much changes).
comment|// kFSEventStreamEventFlagMustScanSubDirs--Likely means the data is very much out of date, we
comment|//            aren't coalescing our directories, so again not so much of an issue
comment|// kFSEventStreamEventFlagRootChanged | kFSEventStreamEventFlagMount | kFSEventStreamEventFlagUnmount--
comment|// These three flags indicate something has changed, but the stat will likely show this, so
comment|// there's not really much to worry about.
comment|// (btw, FSEvents is not the correct way of checking for mounts/unmounts,
comment|//  there are real CarbonCore events for that.)
name|Q_UNUSED
argument_list|(
name|pathFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|watcher
operator|->
name|filePathInfoHash
operator|.
name|contains
argument_list|(
name|path
argument_list|)
condition|)
name|watcher
operator|->
name|updateList
argument_list|(
name|watcher
operator|->
name|filePathInfoHash
index|[
name|path
index|]
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|watcher
operator|->
name|dirPathInfoHash
operator|.
name|contains
argument_list|(
name|path
argument_list|)
condition|)
name|watcher
operator|->
name|updateList
argument_list|(
name|watcher
operator|->
name|dirPathInfoHash
index|[
name|path
index|]
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|clientCallBackInfo
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|numEvents
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|eventPaths
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|eventFlags
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|stop
name|void
name|QFSEventsFileSystemWatcherEngine
operator|::
name|stop
parameter_list|()
block|{
if|#
directive|if
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|>=
name|MAC_OS_X_VERSION_10_5
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
name|stopFSStream
argument_list|(
name|fsStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|threadsRunLoop
condition|)
block|{
name|CFRunLoopStop
argument_list|(
name|threadsRunLoop
argument_list|)
expr_stmt|;
name|waitForStop
operator|.
name|wait
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|updateFiles
name|void
name|QFSEventsFileSystemWatcherEngine
operator|::
name|updateFiles
parameter_list|()
block|{
if|#
directive|if
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|>=
name|MAC_OS_X_VERSION_10_5
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
name|updateHash
argument_list|(
name|filePathInfoHash
argument_list|)
expr_stmt|;
name|updateHash
argument_list|(
name|dirPathInfoHash
argument_list|)
expr_stmt|;
if|if
condition|(
name|filePathInfoHash
operator|.
name|isEmpty
argument_list|()
operator|&&
name|dirPathInfoHash
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Everything disappeared before we got to start, don't bother.
if|#
directive|if
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|>=
name|MAC_OS_X_VERSION_10_5
comment|// Code duplicated from stop(), with the exception that we
comment|// don't wait on waitForStop here. Doing this will lead to
comment|// a deadlock since this function is called from the worker
comment|// thread. (waitForStop.wakeAll() is only called from the
comment|// end of run()).
name|stopFSStream
argument_list|(
name|fsStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|threadsRunLoop
condition|)
name|CFRunLoopStop
argument_list|(
name|threadsRunLoop
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cleanupFSStream
argument_list|(
name|fsStream
argument_list|)
expr_stmt|;
block|}
name|waitCondition
operator|.
name|wakeAll
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|run
name|void
name|QFSEventsFileSystemWatcherEngine
operator|::
name|run
parameter_list|()
block|{
if|#
directive|if
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|>=
name|MAC_OS_X_VERSION_10_5
name|threadsRunLoop
operator|=
name|CFRunLoopGetCurrent
argument_list|()
expr_stmt|;
name|FSEventStreamScheduleWithRunLoop
argument_list|(
name|fsStream
argument_list|,
name|threadsRunLoop
argument_list|,
name|kCFRunLoopDefaultMode
argument_list|)
expr_stmt|;
name|bool
name|startedOK
init|=
name|FSEventStreamStart
argument_list|(
name|fsStream
argument_list|)
decl_stmt|;
comment|// It's recommended by Apple that you only update the files after you've started
comment|// the stream, because otherwise you might miss an update in between starting it.
name|updateFiles
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_NO_DEBUG
name|Q_UNUSED
argument_list|(
name|startedOK
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_ASSERT
argument_list|(
name|startedOK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// If for some reason we called stop up above (and invalidated our stream), this call will return
comment|// immediately.
name|CFRunLoopRun
argument_list|()
expr_stmt|;
name|threadsRunLoop
operator|=
literal|0
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
name|waitForStop
operator|.
name|wakeAll
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_FILESYSTEMWATCHER
end_comment
end_unit
