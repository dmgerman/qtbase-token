begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QIODEVICE_DEBUG
end_comment
begin_include
include|#
directive|include
file|"qbytearray.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qiodevice_p.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QIODEVICE_DEBUG
end_ifdef
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
ifdef|#
directive|ifdef
name|QIODEVICE_DEBUG
DECL|function|debugBinaryString
name|void
name|debugBinaryString
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|input
parameter_list|)
block|{
name|QByteArray
name|tmp
decl_stmt|;
name|int
name|startOffset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|input
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|tmp
operator|+=
name|input
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|15
operator|||
name|i
operator|==
operator|(
name|input
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n%15d:"
argument_list|,
name|startOffset
argument_list|)
expr_stmt|;
name|startOffset
operator|+=
name|tmp
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|tmp
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|int
argument_list|(
name|uchar
argument_list|(
name|tmp
index|[
name|j
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|tmp
operator|.
name|size
argument_list|()
init|;
name|j
operator|<
literal|16
operator|+
literal|1
condition|;
operator|++
name|j
control|)
name|printf
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|tmp
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|isprint
argument_list|(
name|int
argument_list|(
name|uchar
argument_list|(
name|tmp
index|[
name|j
index|]
argument_list|)
argument_list|)
argument_list|)
condition|?
name|tmp
index|[
name|j
index|]
else|:
literal|'.'
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|debugBinaryString
name|void
name|debugBinaryString
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|debugBinaryString
argument_list|(
name|QByteArray
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Q_VOID
define|#
directive|define
name|Q_VOID
end_define
begin_define
DECL|macro|CHECK_MAXLEN
define|#
directive|define
name|CHECK_MAXLEN
parameter_list|(
name|function
parameter_list|,
name|returnType
parameter_list|)
define|\
value|do { \         if (maxSize< 0) { \             qWarning("QIODevice::"#function": Called with maxSize< 0"); \             return returnType; \         } \     } while (0)
end_define
begin_define
DECL|macro|CHECK_WRITABLE
define|#
directive|define
name|CHECK_WRITABLE
parameter_list|(
name|function
parameter_list|,
name|returnType
parameter_list|)
define|\
value|do { \        if ((d->openMode& WriteOnly) == 0) { \            if (d->openMode == NotOpen) \                return returnType; \            qWarning("QIODevice::"#function": ReadOnly device"); \            return returnType; \        } \    } while (0)
end_define
begin_define
DECL|macro|CHECK_READABLE
define|#
directive|define
name|CHECK_READABLE
parameter_list|(
name|function
parameter_list|,
name|returnType
parameter_list|)
define|\
value|do { \        if ((d->openMode& ReadOnly) == 0) { \            if (d->openMode == NotOpen) \                return returnType; \            qWarning("QIODevice::"#function": WriteOnly device"); \            return returnType; \        } \    } while (0)
end_define
begin_comment
comment|/*!     \internal  */
end_comment
begin_constructor
DECL|function|QIODevicePrivate
name|QIODevicePrivate
operator|::
name|QIODevicePrivate
parameter_list|()
member_init_list|:
name|openMode
argument_list|(
name|QIODevice
operator|::
name|NotOpen
argument_list|)
member_init_list|,
name|buffer
argument_list|(
name|QIODEVICE_BUFFERSIZE
argument_list|)
member_init_list|,
name|pos
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|devicePos
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|seqDumpPos
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pPos
argument_list|(
operator|&
name|pos
argument_list|)
member_init_list|,
name|pDevicePos
argument_list|(
operator|&
name|devicePos
argument_list|)
member_init_list|,
name|baseReadLineDataCalled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|firstRead
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|accessMode
argument_list|(
name|Unset
argument_list|)
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
member_init_list|,
name|q_ptr
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
block|{ }
end_constructor
begin_comment
comment|/*!     \internal  */
end_comment
begin_destructor
DECL|function|~QIODevicePrivate
name|QIODevicePrivate
operator|::
name|~
name|QIODevicePrivate
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \class QIODevice     \inmodule QtCore     \reentrant      \brief The QIODevice class is the base interface class of all I/O     devices in Qt.      \ingroup io      QIODevice provides both a common implementation and an abstract     interface for devices that support reading and writing of blocks     of data, such as QFile, QBuffer and QTcpSocket. QIODevice is     abstract and can not be instantiated, but it is common to use the     interface it defines to provide device-independent I/O features.     For example, Qt's XML classes operate on a QIODevice pointer,     allowing them to be used with various devices (such as files and     buffers).      Before accessing the device, open() must be called to set the     correct OpenMode (such as ReadOnly or ReadWrite). You can then     write to the device with write() or putChar(), and read by calling     either read(), readLine(), or readAll(). Call close() when you are     done with the device.      QIODevice distinguishes between two types of devices:     random-access devices and sequential devices.      \list     \li Random-access devices support seeking to arbitrary     positions using seek(). The current position in the file is     available by calling pos(). QFile and QBuffer are examples of     random-access devices.      \li Sequential devices don't support seeking to arbitrary     positions. The data must be read in one pass. The functions     pos() and size() don't work for sequential devices.     QTcpSocket and QProcess are examples of sequential devices.     \endlist      You can use isSequential() to determine the type of device.      QIODevice emits readyRead() when new data is available for     reading; for example, if new data has arrived on the network or if     additional data is appended to a file that you are reading     from. You can call bytesAvailable() to determine the number of     bytes that are currently available for reading. It's common to use     bytesAvailable() together with the readyRead() signal when     programming with asynchronous devices such as QTcpSocket, where     fragments of data can arrive at arbitrary points in     time. QIODevice emits the bytesWritten() signal every time a     payload of data has been written to the device. Use bytesToWrite()     to determine the current amount of data waiting to be written.      Certain subclasses of QIODevice, such as QTcpSocket and QProcess,     are asynchronous. This means that I/O functions such as write()     or read() always return immediately, while communication with the     device itself may happen when control goes back to the event loop.     QIODevice provides functions that allow you to force these     operations to be performed immediately, while blocking the     calling thread and without entering the event loop. This allows     QIODevice subclasses to be used without an event loop, or in     a separate thread:      \list     \li waitForReadyRead() - This function suspends operation in the     calling thread until new data is available for reading.      \li waitForBytesWritten() - This function suspends operation in the     calling thread until one payload of data has been written to the     device.      \li waitFor....() - Subclasses of QIODevice implement blocking     functions for device-specific operations. For example, QProcess     has a function called waitForStarted() which suspends operation in     the calling thread until the process has started.     \endlist      Calling these functions from the main, GUI thread, may cause your     user interface to freeze. Example:      \snippet code/src_corelib_io_qiodevice.cpp 0      By subclassing QIODevice, you can provide the same interface to     your own I/O devices. Subclasses of QIODevice are only required to     implement the protected readData() and writeData() functions.     QIODevice uses these functions to implement all its convenience     functions, such as getChar(), readLine() and write(). QIODevice     also handles access control for you, so you can safely assume that     the device is opened in write mode if writeData() is called.      Some subclasses, such as QFile and QTcpSocket, are implemented     using a memory buffer for intermediate storing of data. This     reduces the number of required device accessing calls, which are     often very slow. Buffering makes functions like getChar() and     putChar() fast, as they can operate on the memory buffer instead     of directly on the device itself. Certain I/O operations, however,     don't work well with a buffer. For example, if several users open     the same device and read it character by character, they may end     up reading the same data when they meant to read a separate chunk     each. For this reason, QIODevice allows you to bypass any     buffering by passing the Unbuffered flag to open(). When     subclassing QIODevice, remember to bypass any buffer you may use     when the device is open in Unbuffered mode.      \sa QBuffer, QFile, QTcpSocket */
end_comment
begin_comment
comment|/*!     \enum QIODevice::OpenModeFlag      This enum is used with open() to describe the mode in which a device     is opened. It is also returned by openMode().      \value NotOpen   The device is not open.     \value ReadOnly  The device is open for reading.     \value WriteOnly The device is open for writing.     \value ReadWrite The device is open for reading and writing.     \value Append    The device is opened in append mode, so that all data is                      written to the end of the file.     \value Truncate  If possible, the device is truncated before it is opened.                      All earlier contents of the device are lost.     \value Text      When reading, the end-of-line terminators are                      translated to '\\n'. When writing, the end-of-line                      terminators are translated to the local encoding, for                      example '\\r\\n' for Win32.     \value Unbuffered Any buffer in the device is bypassed.      Certain flags, such as \c Unbuffered and \c Truncate, are     meaningless when used with some subclasses. Some of these     restrictions are implied by the type of device that is represented     by a subclass. In other cases, the restriction may be due to the     implementation, or may be imposed by the underlying platform; for     example, QTcpSocket does not support \c Unbuffered mode, and     limitations in the native API prevent QFile from supporting \c     Unbuffered on Windows. */
end_comment
begin_comment
comment|/*!     \fn QIODevice::bytesWritten(qint64 bytes)      This signal is emitted every time a payload of data has been     written to the device. The \a bytes argument is set to the number     of bytes that were written in this payload.      bytesWritten() is not emitted recursively; if you reenter the event loop     or call waitForBytesWritten() inside a slot connected to the     bytesWritten() signal, the signal will not be reemitted (although     waitForBytesWritten() may still return true).      \sa readyRead() */
end_comment
begin_comment
comment|/*!     \fn QIODevice::readyRead()      This signal is emitted once every time new data is available for     reading from the device. It will only be emitted again once new     data is available, such as when a new payload of network data has     arrived on your network socket, or when a new block of data has     been appended to your device.      readyRead() is not emitted recursively; if you reenter the event loop or     call waitForReadyRead() inside a slot connected to the readyRead() signal,     the signal will not be reemitted (although waitForReadyRead() may still     return true).      Note for developers implementing classes derived from QIODevice:     you should always emit readyRead() when new data has arrived (do not     emit it only because there's data still to be read in your     buffers). Do not emit readyRead() in other conditions.      \sa bytesWritten() */
end_comment
begin_comment
comment|/*! \fn QIODevice::aboutToClose()      This signal is emitted when the device is about to close. Connect     this signal if you have operations that need to be performed     before the device closes (e.g., if you have data in a separate     buffer that needs to be written to the device). */
end_comment
begin_comment
comment|/*!     \fn QIODevice::readChannelFinished()     \since 4.4      This signal is emitted when the input (reading) stream is closed     in this device. It is emitted as soon as the closing is detected,     which means that there might still be data available for reading     with read().      \sa atEnd(), read() */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
end_ifdef
begin_constructor
DECL|function|QIODevice
name|QIODevice
operator|::
name|QIODevice
parameter_list|()
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QIODevicePrivate
argument_list|)
block|{
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QIODevice
name|QIODevice
operator|::
name|QIODevice
parameter_list|(
name|QIODevicePrivate
modifier|&
name|dd
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|&
name|dd
argument_list|)
block|{
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
block|}
end_constructor
begin_else
else|#
directive|else
end_else
begin_comment
comment|/*!     Constructs a QIODevice object. */
end_comment
begin_constructor
DECL|function|QIODevice
name|QIODevice
operator|::
name|QIODevice
parameter_list|()
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QIODevicePrivate
argument_list|,
literal|0
argument_list|)
block|{
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|QFile
modifier|*
name|file
init|=
name|qobject_cast
argument_list|<
name|QFile
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%p QIODevice::QIODevice(\"%s\") %s\n"
argument_list|,
name|this
argument_list|,
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|file
condition|?
name|file
operator|->
name|fileName
argument_list|()
else|:
name|QString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QIODevice object with the given \a parent. */
end_comment
begin_constructor
DECL|function|QIODevice
name|QIODevice
operator|::
name|QIODevice
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QIODevicePrivate
argument_list|,
name|parent
argument_list|)
block|{
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::QIODevice(%p \"%s\")\n"
argument_list|,
name|this
argument_list|,
name|parent
argument_list|,
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QIODevice
name|QIODevice
operator|::
name|QIODevice
parameter_list|(
name|QIODevicePrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   The destructor is virtual, and QIODevice is an abstract base   class. This destructor does not call close(), but the subclass   destructor might. If you are in doubt, call close() before   destroying the QIODevice. */
end_comment
begin_destructor
DECL|function|~QIODevice
name|QIODevice
operator|::
name|~
name|QIODevice
parameter_list|()
block|{
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::~QIODevice()\n"
argument_list|,
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_comment
comment|/*!     Returns true if this device is sequential; otherwise returns     false.      Sequential devices, as opposed to a random-access devices, have no     concept of a start, an end, a size, or a current position, and they     do not support seeking. You can only read from the device when it     reports that data is available. The most common example of a     sequential device is a network socket. On Unix, special files such     as /dev/zero and fifo pipes are sequential.      Regular files, on the other hand, do support random access. They     have both a size and a current position, and they also support     seeking backwards and forwards in the data stream. Regular files     are non-sequential.      \sa bytesAvailable() */
end_comment
begin_function
DECL|function|isSequential
name|bool
name|QIODevice
operator|::
name|isSequential
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the mode in which the device has been opened;     i.e. ReadOnly or WriteOnly.      \sa OpenMode */
end_comment
begin_function
DECL|function|openMode
name|QIODevice
operator|::
name|OpenMode
name|QIODevice
operator|::
name|openMode
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|openMode
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the OpenMode of the device to \a openMode. Call this     function to set the open mode if the flags change after the device     has been opened.      \sa openMode(), OpenMode */
end_comment
begin_function
DECL|function|setOpenMode
name|void
name|QIODevice
operator|::
name|setOpenMode
parameter_list|(
name|OpenMode
name|openMode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QIODevice
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::setOpenMode(0x%x)\n"
argument_list|,
name|this
argument_list|,
name|int
argument_list|(
name|openMode
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|openMode
operator|=
name|openMode
expr_stmt|;
name|d
operator|->
name|accessMode
operator|=
name|QIODevicePrivate
operator|::
name|Unset
expr_stmt|;
name|d
operator|->
name|firstRead
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|isReadable
argument_list|()
condition|)
name|d
operator|->
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If \a enabled is true, this function sets the \l Text flag on the device;     otherwise the \l Text flag is removed. This feature is useful for classes     that provide custom end-of-line handling on a QIODevice.      The IO device should be opened before calling this function.      \sa open(), setOpenMode()  */
end_comment
begin_function
DECL|function|setTextModeEnabled
name|void
name|QIODevice
operator|::
name|setTextModeEnabled
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QIODevice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isOpen
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QIODevice::setTextModeEnabled: The device is not open"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|enabled
condition|)
name|d
operator|->
name|openMode
operator||=
name|Text
expr_stmt|;
else|else
name|d
operator|->
name|openMode
operator|&=
operator|~
name|Text
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the \l Text flag is enabled; otherwise returns false.      \sa setTextModeEnabled() */
end_comment
begin_function
DECL|function|isTextModeEnabled
name|bool
name|QIODevice
operator|::
name|isTextModeEnabled
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|openMode
operator|&
name|Text
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the device is open; otherwise returns false. A     device is open if it can be read from and/or written to. By     default, this function returns false if openMode() returns     \c NotOpen.      \sa openMode(), OpenMode */
end_comment
begin_function
DECL|function|isOpen
name|bool
name|QIODevice
operator|::
name|isOpen
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|openMode
operator|!=
name|NotOpen
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if data can be read from the device; otherwise returns     false. Use bytesAvailable() to determine how many bytes can be read.      This is a convenience function which checks if the OpenMode of the     device contains the ReadOnly flag.      \sa openMode(), OpenMode */
end_comment
begin_function
DECL|function|isReadable
name|bool
name|QIODevice
operator|::
name|isReadable
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|openMode
argument_list|()
operator|&
name|ReadOnly
operator|)
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if data can be written to the device; otherwise returns     false.      This is a convenience function which checks if the OpenMode of the     device contains the WriteOnly flag.      \sa openMode(), OpenMode */
end_comment
begin_function
DECL|function|isWritable
name|bool
name|QIODevice
operator|::
name|isWritable
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|openMode
argument_list|()
operator|&
name|WriteOnly
operator|)
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Opens the device and sets its OpenMode to \a mode. Returns true if successful;     otherwise returns false. This function should be called from any     reimplementations of open() or other functions that open the device.      \sa openMode(), OpenMode */
end_comment
begin_function
DECL|function|open
name|bool
name|QIODevice
operator|::
name|open
parameter_list|(
name|OpenMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QIODevice
argument_list|)
expr_stmt|;
name|d
operator|->
name|openMode
operator|=
name|mode
expr_stmt|;
name|d
operator|->
name|pos
operator|=
operator|(
name|mode
operator|&
name|Append
operator|)
condition|?
name|size
argument_list|()
else|:
name|qint64
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|accessMode
operator|=
name|QIODevicePrivate
operator|::
name|Unset
expr_stmt|;
name|d
operator|->
name|firstRead
operator|=
literal|true
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::open(0x%x)\n"
argument_list|,
name|this
argument_list|,
name|quint32
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     First emits aboutToClose(), then closes the device and sets its     OpenMode to NotOpen. The error string is also reset.      \sa setOpenMode(), OpenMode */
end_comment
begin_function
DECL|function|close
name|void
name|QIODevice
operator|::
name|close
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QIODevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|openMode
operator|==
name|NotOpen
condition|)
return|return;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::close()\n"
argument_list|,
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
emit|emit
name|aboutToClose
argument_list|()
emit|;
endif|#
directive|endif
name|d
operator|->
name|openMode
operator|=
name|NotOpen
expr_stmt|;
name|d
operator|->
name|errorString
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|seqDumpPos
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|firstRead
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     For random-access devices, this function returns the position that     data is written to or read from. For sequential devices or closed     devices, where there is no concept of a "current position", 0 is     returned.      The current read/write position of the device is maintained internally by     QIODevice, so reimplementing this function is not necessary. When     subclassing QIODevice, use QIODevice::seek() to notify QIODevice about     changes in the device position.      \sa isSequential(), seek() */
end_comment
begin_function
DECL|function|pos
name|qint64
name|QIODevice
operator|::
name|pos
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QIODevice
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::pos() == %d\n"
argument_list|,
name|this
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|d
operator|->
name|pos
return|;
block|}
end_function
begin_comment
comment|/*!     For open random-access devices, this function returns the size of the     device. For open sequential devices, bytesAvailable() is returned.      If the device is closed, the size returned will not reflect the actual     size of the device.      \sa isSequential(), pos() */
end_comment
begin_function
DECL|function|size
name|qint64
name|QIODevice
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|isSequential
argument_list|()
condition|?
name|bytesAvailable
argument_list|()
else|:
name|qint64
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     For random-access devices, this function sets the current position     to \a pos, returning true on success, or false if an error occurred.     For sequential devices, the default behavior is to produce a warning     and return false.      When subclassing QIODevice, you must call QIODevice::seek() at the     start of your function to ensure integrity with QIODevice's     built-in buffer.      \sa pos(), isSequential() */
end_comment
begin_function
DECL|function|seek
name|bool
name|QIODevice
operator|::
name|seek
parameter_list|(
name|qint64
name|pos
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QIODevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isSequential
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QIODevice::seek: Cannot call seek on a sequential device"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|openMode
operator|==
name|NotOpen
condition|)
block|{
name|qWarning
argument_list|(
literal|"QIODevice::seek: The device is not open"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QIODevice::seek: Invalid pos: %d"
argument_list|,
name|int
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::seek(%d), before: d->pos = %d, d->buffer.size() = %d\n"
argument_list|,
name|this
argument_list|,
name|int
argument_list|(
name|pos
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|pos
argument_list|)
argument_list|,
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qint64
name|offset
init|=
name|pos
operator|-
name|d
operator|->
name|pos
decl_stmt|;
name|d
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
name|d
operator|->
name|devicePos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>=
name|qint64
argument_list|(
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
condition|)
comment|// When seeking backwards, an operation that is only allowed for
comment|// random-access devices, the buffer is cleared. The next read
comment|// operation will then refill the buffer. We can optimize this, if we
comment|// find that seeking backwards becomes a significant performance hit.
name|d
operator|->
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|buffer
operator|.
name|skip
argument_list|(
name|int
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p \tafter: d->pos == %d, d->buffer.size() == %d\n"
argument_list|,
name|this
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|pos
argument_list|)
argument_list|,
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the current read and write position is at the end     of the device (i.e. there is no more data available for reading on     the device); otherwise returns false.      For some devices, atEnd() can return true even though there is more data     to read. This special case only applies to devices that generate data in     direct response to you calling read() (e.g., \c /dev or \c /proc files on     Unix and Mac OS X, or console input / \c stdin on all platforms).      \sa bytesAvailable(), read(), isSequential() */
end_comment
begin_function
DECL|function|atEnd
name|bool
name|QIODevice
operator|::
name|atEnd
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QIODevice
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::atEnd() returns %s, d->openMode == %d, d->pos == %d\n"
argument_list|,
name|this
argument_list|,
operator|(
name|d
operator|->
name|openMode
operator|==
name|NotOpen
operator|||
name|d
operator|->
name|pos
operator|==
name|size
argument_list|()
operator|)
condition|?
literal|"true"
else|:
literal|"false"
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|openMode
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|d
operator|->
name|openMode
operator|==
name|NotOpen
operator|||
operator|(
name|d
operator|->
name|buffer
operator|.
name|isEmpty
argument_list|()
operator|&&
name|bytesAvailable
argument_list|()
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Seeks to the start of input for random-access devices. Returns     true on success; otherwise returns false (for example, if the     device is not open).      Note that when using a QTextStream on a QFile, calling reset() on     the QFile will not have the expected result because QTextStream     buffers the file. Use the QTextStream::seek() function instead.      \sa seek() */
end_comment
begin_function
DECL|function|reset
name|bool
name|QIODevice
operator|::
name|reset
parameter_list|()
block|{
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::reset()\n"
argument_list|,
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|seek
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of bytes that are available for reading. This     function is commonly used with sequential devices to determine the     number of bytes to allocate in a buffer before reading.      Subclasses that reimplement this function must call the base     implementation in order to include the size of QIODevices' buffer. Example:      \snippet code/src_corelib_io_qiodevice.cpp 1      \sa bytesToWrite(), readyRead(), isSequential() */
end_comment
begin_function
DECL|function|bytesAvailable
name|qint64
name|QIODevice
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QIODevice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isSequential
argument_list|()
condition|)
return|return
name|qMax
argument_list|(
name|size
argument_list|()
operator|-
name|d
operator|->
name|pos
argument_list|,
name|qint64
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     For buffered devices, this function returns the number of bytes     waiting to be written. For devices with no buffer, this function     returns 0.      \sa bytesAvailable(), bytesWritten(), isSequential() */
end_comment
begin_function
DECL|function|bytesToWrite
name|qint64
name|QIODevice
operator|::
name|bytesToWrite
parameter_list|()
specifier|const
block|{
return|return
name|qint64
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_CC_RVCT
end_ifdef
begin_comment
comment|// arm mode makes the 64-bit integer operations much faster in RVCT 2.2
end_comment
begin_pragma
pragma|#
directive|pragma
name|push
end_pragma
begin_pragma
pragma|#
directive|pragma
name|arm
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Reads at most \a maxSize bytes from the device into \a data, and     returns the number of bytes read. If an error occurs, such as when     attempting to read from a device opened in WriteOnly mode, this     function returns -1.      0 is returned when no more data is available for reading. However,     reading past the end of the stream is considered an error, so this     function returns -1 in those cases (that is, reading on a closed     socket or after a process has died).      \sa readData(), readLine(), write() */
end_comment
begin_function
DECL|function|read
name|qint64
name|QIODevice
operator|::
name|read
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QIODevice
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::read(%p, %d), d->pos = %d, d->buffer.size() = %d\n"
argument_list|,
name|this
argument_list|,
name|data
argument_list|,
name|int
argument_list|(
name|maxSize
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|pos
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Short circuit for getChar()
if|if
condition|(
name|maxSize
operator|==
literal|1
condition|)
block|{
name|int
name|chint
decl_stmt|;
while|while
condition|(
operator|(
name|chint
operator|=
name|d
operator|->
name|buffer
operator|.
name|getChar
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
operator|++
operator|(
operator|*
name|d
operator|->
name|pPos
operator|)
expr_stmt|;
name|char
name|c
init|=
name|char
argument_list|(
name|uchar
argument_list|(
name|chint
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|&&
operator|(
name|d
operator|->
name|openMode
operator|&
name|Text
operator|)
condition|)
continue|continue;
operator|*
name|data
operator|=
name|c
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p \tread 0x%hhx (%c) returning 1 (shortcut)\n"
argument_list|,
name|this
argument_list|,
name|int
argument_list|(
name|c
argument_list|)
argument_list|,
name|isprint
argument_list|(
name|c
argument_list|)
condition|?
name|c
else|:
literal|'?'
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|readData
argument_list|(
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|qint64
argument_list|(
literal|1
argument_list|)
return|;
block|}
block|}
name|CHECK_MAXLEN
argument_list|(
name|read
argument_list|,
name|qint64
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|qint64
name|readSoFar
init|=
literal|0
decl_stmt|;
name|bool
name|moreToRead
init|=
literal|true
decl_stmt|;
do|do
block|{
comment|// Try reading from the buffer.
name|int
name|lastReadChunkSize
init|=
name|d
operator|->
name|buffer
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastReadChunkSize
operator|>
literal|0
condition|)
block|{
operator|*
name|d
operator|->
name|pPos
operator|+=
name|lastReadChunkSize
expr_stmt|;
name|readSoFar
operator|+=
name|lastReadChunkSize
expr_stmt|;
comment|// fast exit when satisfied by buffer
if|if
condition|(
name|lastReadChunkSize
operator|==
name|maxSize
operator|&&
operator|!
operator|(
name|d
operator|->
name|openMode
operator|&
name|Text
operator|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|readData
argument_list|(
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|readSoFar
return|;
block|}
name|data
operator|+=
name|lastReadChunkSize
expr_stmt|;
name|maxSize
operator|-=
name|lastReadChunkSize
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p \treading %d bytes from buffer into position %d\n"
argument_list|,
name|this
argument_list|,
name|lastReadChunkSize
argument_list|,
name|int
argument_list|(
name|readSoFar
argument_list|)
operator|-
name|lastReadChunkSize
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|firstRead
condition|)
block|{
comment|// this is the first time the file has been read, check it's valid and set up pos pointers
comment|// for fast pos updates.
name|CHECK_READABLE
argument_list|(
name|read
argument_list|,
name|qint64
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|firstRead
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isSequential
argument_list|()
condition|)
block|{
name|d
operator|->
name|pPos
operator|=
operator|&
name|d
operator|->
name|seqDumpPos
expr_stmt|;
name|d
operator|->
name|pDevicePos
operator|=
operator|&
name|d
operator|->
name|seqDumpPos
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|maxSize
condition|)
return|return
name|readSoFar
return|;
if|if
condition|(
operator|(
name|d
operator|->
name|openMode
operator|&
name|Unbuffered
operator|)
operator|==
literal|0
operator|&&
name|maxSize
operator|<
name|QIODEVICE_BUFFERSIZE
condition|)
block|{
comment|// In buffered mode, we try to fill up the QIODevice buffer before
comment|// we do anything else.
comment|// buffer is empty at this point, try to fill it
name|int
name|bytesToBuffer
init|=
name|QIODEVICE_BUFFERSIZE
decl_stmt|;
name|char
modifier|*
name|writePointer
init|=
name|d
operator|->
name|buffer
operator|.
name|reserve
argument_list|(
name|bytesToBuffer
argument_list|)
decl_stmt|;
comment|// Make sure the device is positioned correctly.
if|if
condition|(
name|d
operator|->
name|pos
operator|!=
name|d
operator|->
name|devicePos
operator|&&
operator|!
name|d
operator|->
name|isSequential
argument_list|()
operator|&&
operator|!
name|seek
argument_list|(
name|d
operator|->
name|pos
argument_list|)
condition|)
return|return
name|readSoFar
condition|?
name|readSoFar
else|:
name|qint64
argument_list|(
operator|-
literal|1
argument_list|)
return|;
name|qint64
name|readFromDevice
init|=
name|readData
argument_list|(
name|writePointer
argument_list|,
name|bytesToBuffer
argument_list|)
decl_stmt|;
name|d
operator|->
name|buffer
operator|.
name|chop
argument_list|(
name|bytesToBuffer
operator|-
operator|(
name|readFromDevice
operator|<
literal|0
condition|?
literal|0
else|:
name|int
argument_list|(
name|readFromDevice
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readFromDevice
operator|>
literal|0
condition|)
block|{
operator|*
name|d
operator|->
name|pDevicePos
operator|+=
name|readFromDevice
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p \treading %d from device into buffer\n"
argument_list|,
name|this
argument_list|,
name|int
argument_list|(
name|readFromDevice
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lastReadChunkSize
operator|=
name|d
operator|->
name|buffer
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|maxSize
argument_list|)
expr_stmt|;
name|readSoFar
operator|+=
name|lastReadChunkSize
expr_stmt|;
name|data
operator|+=
name|lastReadChunkSize
expr_stmt|;
name|maxSize
operator|-=
name|lastReadChunkSize
expr_stmt|;
operator|*
name|d
operator|->
name|pPos
operator|+=
name|lastReadChunkSize
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p \treading %d bytes from buffer at position %d\n"
argument_list|,
name|this
argument_list|,
name|lastReadChunkSize
argument_list|,
name|int
argument_list|(
name|readSoFar
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
comment|// If we need more, try reading from the device.
if|if
condition|(
name|maxSize
operator|>
literal|0
condition|)
block|{
comment|// Make sure the device is positioned correctly.
if|if
condition|(
name|d
operator|->
name|pos
operator|!=
name|d
operator|->
name|devicePos
operator|&&
operator|!
name|d
operator|->
name|isSequential
argument_list|()
operator|&&
operator|!
name|seek
argument_list|(
name|d
operator|->
name|pos
argument_list|)
condition|)
return|return
name|readSoFar
condition|?
name|readSoFar
else|:
name|qint64
argument_list|(
operator|-
literal|1
argument_list|)
return|;
name|qint64
name|readFromDevice
init|=
name|readData
argument_list|(
name|data
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p \treading %d bytes from device (total %d)\n"
argument_list|,
name|this
argument_list|,
name|int
argument_list|(
name|readFromDevice
argument_list|)
argument_list|,
name|int
argument_list|(
name|readSoFar
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|readFromDevice
operator|==
operator|-
literal|1
operator|&&
name|readSoFar
operator|==
literal|0
condition|)
block|{
comment|// error and we haven't read anything: return immediately
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|readFromDevice
operator|>
literal|0
condition|)
block|{
name|lastReadChunkSize
operator|+=
name|int
argument_list|(
name|readFromDevice
argument_list|)
expr_stmt|;
name|readSoFar
operator|+=
name|readFromDevice
expr_stmt|;
name|data
operator|+=
name|readFromDevice
expr_stmt|;
name|maxSize
operator|-=
name|readFromDevice
expr_stmt|;
operator|*
name|d
operator|->
name|pPos
operator|+=
name|readFromDevice
expr_stmt|;
operator|*
name|d
operator|->
name|pDevicePos
operator|+=
name|readFromDevice
expr_stmt|;
block|}
block|}
comment|// Best attempt has been made to read data, don't try again except for text mode adjustment below
name|moreToRead
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|readSoFar
operator|&&
name|d
operator|->
name|openMode
operator|&
name|Text
condition|)
block|{
name|char
modifier|*
name|readPtr
init|=
name|data
operator|-
name|lastReadChunkSize
decl_stmt|;
specifier|const
name|char
modifier|*
name|endPtr
init|=
name|data
decl_stmt|;
if|if
condition|(
name|readPtr
operator|<
name|endPtr
condition|)
block|{
comment|// optimization to avoid initial self-assignment
while|while
condition|(
operator|*
name|readPtr
operator|!=
literal|'\r'
condition|)
block|{
if|if
condition|(
operator|++
name|readPtr
operator|==
name|endPtr
condition|)
return|return
name|readSoFar
return|;
block|}
name|char
modifier|*
name|writePtr
init|=
name|readPtr
decl_stmt|;
while|while
condition|(
name|readPtr
operator|<
name|endPtr
condition|)
block|{
name|char
name|ch
init|=
operator|*
name|readPtr
operator|++
decl_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\r'
condition|)
operator|*
name|writePtr
operator|++
operator|=
name|ch
expr_stmt|;
else|else
block|{
operator|--
name|readSoFar
expr_stmt|;
operator|--
name|data
expr_stmt|;
operator|++
name|maxSize
expr_stmt|;
block|}
block|}
comment|// Make sure we get more data if there is room for more. This
comment|// is very important for when someone seeks to the start of a
comment|// '\r\n' and reads one character - they should get the '\n'.
name|moreToRead
operator|=
operator|(
name|readPtr
operator|!=
name|writePtr
operator|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|moreToRead
condition|)
do|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p \treturning %d, d->pos == %d, d->buffer.size() == %d\n"
argument_list|,
name|this
argument_list|,
name|int
argument_list|(
name|readSoFar
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|pos
argument_list|)
argument_list|,
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|debugBinaryString
argument_list|(
name|data
operator|-
name|readSoFar
argument_list|,
name|readSoFar
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|readData
argument_list|(
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|readSoFar
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_CC_RVCT
end_ifdef
begin_pragma
pragma|#
directive|pragma
name|pop
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \overload      Reads at most \a maxSize bytes from the device, and returns the     data read as a QByteArray.      This function has no way of reporting errors; returning an empty     QByteArray() can mean either that no data was currently available     for reading, or that an error occurred. */
end_comment
begin_function
DECL|function|read
name|QByteArray
name|QIODevice
operator|::
name|read
parameter_list|(
name|qint64
name|maxSize
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QIODevice
argument_list|)
expr_stmt|;
name|QByteArray
name|result
decl_stmt|;
name|CHECK_MAXLEN
argument_list|(
name|read
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::read(%d), d->pos = %d, d->buffer.size() = %d\n"
argument_list|,
name|this
argument_list|,
name|int
argument_list|(
name|maxSize
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|pos
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|maxSize
operator|!=
name|qint64
argument_list|(
name|int
argument_list|(
name|maxSize
argument_list|)
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QIODevice::read: maxSize argument exceeds QByteArray size limit"
argument_list|)
expr_stmt|;
name|maxSize
operator|=
name|INT_MAX
expr_stmt|;
block|}
name|qint64
name|readBytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|maxSize
condition|)
block|{
name|result
operator|.
name|resize
argument_list|(
name|int
argument_list|(
name|maxSize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// If resize fails, read incrementally.
name|qint64
name|readResult
decl_stmt|;
do|do
block|{
name|result
operator|.
name|resize
argument_list|(
name|int
argument_list|(
name|qMin
argument_list|(
name|maxSize
argument_list|,
name|result
operator|.
name|size
argument_list|()
operator|+
name|QIODEVICE_BUFFERSIZE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|readResult
operator|=
name|read
argument_list|(
name|result
operator|.
name|data
argument_list|()
operator|+
name|readBytes
argument_list|,
name|result
operator|.
name|size
argument_list|()
operator|-
name|readBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|readResult
operator|>
literal|0
operator|||
name|readBytes
operator|==
literal|0
condition|)
name|readBytes
operator|+=
name|readResult
expr_stmt|;
block|}
do|while
condition|(
name|readResult
operator|==
name|QIODEVICE_BUFFERSIZE
condition|)
do|;
block|}
else|else
block|{
name|readBytes
operator|=
name|read
argument_list|(
name|result
operator|.
name|data
argument_list|()
argument_list|,
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|readBytes
operator|<=
literal|0
condition|)
name|result
operator|.
name|clear
argument_list|()
expr_stmt|;
else|else
name|result
operator|.
name|resize
argument_list|(
name|int
argument_list|(
name|readBytes
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Reads all available data from the device, and returns it as a     QByteArray.      This function has no way of reporting errors; returning an empty     QByteArray() can mean either that no data was currently available     for reading, or that an error occurred. */
end_comment
begin_function
DECL|function|readAll
name|QByteArray
name|QIODevice
operator|::
name|readAll
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QIODevice
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::readAll(), d->pos = %d, d->buffer.size() = %d\n"
argument_list|,
name|this
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|pos
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QByteArray
name|result
decl_stmt|;
name|qint64
name|readBytes
init|=
literal|0
decl_stmt|;
comment|// flush internal read buffer
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|openMode
operator|&
name|Text
operator|)
operator|&&
operator|!
name|d
operator|->
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|=
name|d
operator|->
name|buffer
operator|.
name|readAll
argument_list|()
expr_stmt|;
name|readBytes
operator|=
name|result
operator|.
name|size
argument_list|()
expr_stmt|;
name|d
operator|->
name|pos
operator|+=
name|readBytes
expr_stmt|;
block|}
name|qint64
name|theSize
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|isSequential
argument_list|()
operator|||
operator|(
name|theSize
operator|=
name|size
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|// Size is unknown, read incrementally.
name|qint64
name|readResult
decl_stmt|;
do|do
block|{
name|result
operator|.
name|resize
argument_list|(
name|result
operator|.
name|size
argument_list|()
operator|+
name|QIODEVICE_BUFFERSIZE
argument_list|)
expr_stmt|;
name|readResult
operator|=
name|read
argument_list|(
name|result
operator|.
name|data
argument_list|()
operator|+
name|readBytes
argument_list|,
name|result
operator|.
name|size
argument_list|()
operator|-
name|readBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|readResult
operator|>
literal|0
operator|||
name|readBytes
operator|==
literal|0
condition|)
name|readBytes
operator|+=
name|readResult
expr_stmt|;
block|}
do|while
condition|(
name|readResult
operator|>
literal|0
condition|)
do|;
block|}
else|else
block|{
comment|// Read it all in one go.
comment|// If resize fails, don't read anything.
name|result
operator|.
name|resize
argument_list|(
name|int
argument_list|(
name|readBytes
operator|+
name|theSize
operator|-
name|d
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|readBytes
operator|+=
name|read
argument_list|(
name|result
operator|.
name|data
argument_list|()
operator|+
name|readBytes
argument_list|,
name|result
operator|.
name|size
argument_list|()
operator|-
name|readBytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readBytes
operator|<=
literal|0
condition|)
name|result
operator|.
name|clear
argument_list|()
expr_stmt|;
else|else
name|result
operator|.
name|resize
argument_list|(
name|int
argument_list|(
name|readBytes
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_CC_RVCT
end_ifdef
begin_comment
comment|// arm mode makes the 64-bit integer operations much faster in RVCT 2.2
end_comment
begin_pragma
pragma|#
directive|pragma
name|push
end_pragma
begin_pragma
pragma|#
directive|pragma
name|arm
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     This function reads a line of ASCII characters from the device, up     to a maximum of \a maxSize - 1 bytes, stores the characters in \a     data, and returns the number of bytes read. If a line could not be     read but no error ocurred, this function returns 0. If an error     occurs, this function returns the length of what could be read, or     -1 if nothing was read.      A terminating '\\0' byte is always appended to \a data, so \a     maxSize must be larger than 1.      Data is read until either of the following conditions are met:      \list     \li The first '\\n' character is read.     \li \a maxSize - 1 bytes are read.     \li The end of the device data is detected.     \endlist      For example, the following code reads a line of characters from a     file:      \snippet code/src_corelib_io_qiodevice.cpp 2      The newline character ('\\n') is included in the buffer. If a     newline is not encountered before maxSize - 1 bytes are read, a     newline will not be inserted into the buffer. On windows newline     characters are replaced with '\\n'.      This function calls readLineData(), which is implemented using     repeated calls to getChar(). You can provide a more efficient     implementation by reimplementing readLineData() in your own     subclass.      \sa getChar(), read(), write() */
end_comment
begin_function
DECL|function|readLine
name|qint64
name|QIODevice
operator|::
name|readLine
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QIODevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxSize
operator|<
literal|2
condition|)
block|{
name|qWarning
argument_list|(
literal|"QIODevice::readLine: Called with maxSize< 2"
argument_list|)
expr_stmt|;
return|return
name|qint64
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::readLine(%p, %d), d->pos = %d, d->buffer.size() = %d\n"
argument_list|,
name|this
argument_list|,
name|data
argument_list|,
name|int
argument_list|(
name|maxSize
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|pos
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Leave room for a '\0'
operator|--
name|maxSize
expr_stmt|;
specifier|const
name|bool
name|sequential
init|=
name|d
operator|->
name|isSequential
argument_list|()
decl_stmt|;
name|qint64
name|readSoFar
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|readSoFar
operator|=
name|d
operator|->
name|buffer
operator|.
name|readLine
argument_list|(
name|data
argument_list|,
name|maxSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|readData
argument_list|(
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sequential
condition|)
name|d
operator|->
name|pos
operator|+=
name|readSoFar
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p \tread from buffer: %d bytes, last character read: %hhx\n"
argument_list|,
name|this
argument_list|,
name|int
argument_list|(
name|readSoFar
argument_list|)
argument_list|,
name|data
index|[
name|int
argument_list|(
name|readSoFar
argument_list|)
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|readSoFar
condition|)
name|debugBinaryString
argument_list|(
name|data
argument_list|,
name|int
argument_list|(
name|readSoFar
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|readSoFar
operator|&&
name|data
index|[
name|readSoFar
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|openMode
operator|&
name|Text
condition|)
block|{
comment|// QRingBuffer::readLine() isn't Text aware.
if|if
condition|(
name|readSoFar
operator|>
literal|1
operator|&&
name|data
index|[
name|readSoFar
operator|-
literal|2
index|]
operator|==
literal|'\r'
condition|)
block|{
operator|--
name|readSoFar
expr_stmt|;
name|data
index|[
name|readSoFar
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
name|data
index|[
name|readSoFar
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|readSoFar
return|;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|pos
operator|!=
name|d
operator|->
name|devicePos
operator|&&
operator|!
name|sequential
operator|&&
operator|!
name|seek
argument_list|(
name|d
operator|->
name|pos
argument_list|)
condition|)
return|return
name|qint64
argument_list|(
operator|-
literal|1
argument_list|)
return|;
name|d
operator|->
name|baseReadLineDataCalled
operator|=
literal|false
expr_stmt|;
name|qint64
name|readBytes
init|=
name|readLineData
argument_list|(
name|data
operator|+
name|readSoFar
argument_list|,
name|maxSize
operator|-
name|readSoFar
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p \tread from readLineData: %d bytes, readSoFar = %d bytes\n"
argument_list|,
name|this
argument_list|,
name|int
argument_list|(
name|readBytes
argument_list|)
argument_list|,
name|int
argument_list|(
name|readSoFar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readBytes
operator|>
literal|0
condition|)
block|{
name|debugBinaryString
argument_list|(
name|data
argument_list|,
name|int
argument_list|(
name|readSoFar
operator|+
name|readBytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|readBytes
operator|<
literal|0
condition|)
block|{
name|data
index|[
name|readSoFar
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|readSoFar
condition|?
name|readSoFar
else|:
operator|-
literal|1
return|;
block|}
name|readSoFar
operator|+=
name|readBytes
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|baseReadLineDataCalled
operator|&&
operator|!
name|sequential
condition|)
block|{
name|d
operator|->
name|pos
operator|+=
name|readBytes
expr_stmt|;
comment|// If the base implementation was not called, then we must
comment|// assume the device position is invalid and force a seek.
name|d
operator|->
name|devicePos
operator|=
name|qint64
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|data
index|[
name|readSoFar
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|openMode
operator|&
name|Text
condition|)
block|{
if|if
condition|(
name|readSoFar
operator|>
literal|1
operator|&&
name|data
index|[
name|readSoFar
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|data
index|[
name|readSoFar
operator|-
literal|2
index|]
operator|==
literal|'\r'
condition|)
block|{
name|data
index|[
name|readSoFar
operator|-
literal|2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|data
index|[
name|readSoFar
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|--
name|readSoFar
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p \treturning %d, d->pos = %d, d->buffer.size() = %d, size() = %d\n"
argument_list|,
name|this
argument_list|,
name|int
argument_list|(
name|readSoFar
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|pos
argument_list|)
argument_list|,
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|,
name|int
argument_list|(
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|debugBinaryString
argument_list|(
name|data
argument_list|,
name|int
argument_list|(
name|readSoFar
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|readSoFar
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Reads a line from the device, but no more than \a maxSize characters,     and returns the result as a QByteArray.      This function has no way of reporting errors; returning an empty     QByteArray() can mean either that no data was currently available     for reading, or that an error occurred. */
end_comment
begin_function
DECL|function|readLine
name|QByteArray
name|QIODevice
operator|::
name|readLine
parameter_list|(
name|qint64
name|maxSize
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QIODevice
argument_list|)
expr_stmt|;
name|QByteArray
name|result
decl_stmt|;
name|CHECK_MAXLEN
argument_list|(
name|readLine
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::readLine(%d), d->pos = %d, d->buffer.size() = %d\n"
argument_list|,
name|this
argument_list|,
name|int
argument_list|(
name|maxSize
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|pos
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|maxSize
operator|>
name|INT_MAX
condition|)
block|{
name|qWarning
argument_list|(
literal|"QIODevice::read: maxSize argument exceeds QByteArray size limit"
argument_list|)
expr_stmt|;
name|maxSize
operator|=
name|INT_MAX
expr_stmt|;
block|}
name|result
operator|.
name|resize
argument_list|(
name|int
argument_list|(
name|maxSize
argument_list|)
argument_list|)
expr_stmt|;
name|qint64
name|readBytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// If resize fails or maxSize == 0, read incrementally
if|if
condition|(
name|maxSize
operator|==
literal|0
condition|)
name|maxSize
operator|=
name|INT_MAX
expr_stmt|;
comment|// The first iteration needs to leave an extra byte for the terminating null
name|result
operator|.
name|resize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|qint64
name|readResult
decl_stmt|;
do|do
block|{
name|result
operator|.
name|resize
argument_list|(
name|int
argument_list|(
name|qMin
argument_list|(
name|maxSize
argument_list|,
name|result
operator|.
name|size
argument_list|()
operator|+
name|QIODEVICE_BUFFERSIZE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|readResult
operator|=
name|readLine
argument_list|(
name|result
operator|.
name|data
argument_list|()
operator|+
name|readBytes
argument_list|,
name|result
operator|.
name|size
argument_list|()
operator|-
name|readBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|readResult
operator|>
literal|0
operator|||
name|readBytes
operator|==
literal|0
condition|)
name|readBytes
operator|+=
name|readResult
expr_stmt|;
block|}
do|while
condition|(
name|readResult
operator|==
name|QIODEVICE_BUFFERSIZE
operator|&&
name|result
index|[
name|int
argument_list|(
name|readBytes
operator|-
literal|1
argument_list|)
index|]
operator|!=
literal|'\n'
condition|)
do|;
block|}
else|else
name|readBytes
operator|=
name|readLine
argument_list|(
name|result
operator|.
name|data
argument_list|()
argument_list|,
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|readBytes
operator|<=
literal|0
condition|)
name|result
operator|.
name|clear
argument_list|()
expr_stmt|;
else|else
name|result
operator|.
name|resize
argument_list|(
name|readBytes
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Reads up to \a maxSize characters into \a data and returns the     number of characters read.      This function is called by readLine(), and provides its base     implementation, using getChar(). Buffered devices can improve the     performance of readLine() by reimplementing this function.      readLine() appends a '\\0' byte to \a data; readLineData() does not     need to do this.      If you reimplement this function, be careful to return the correct     value: it should return the number of bytes read in this line,     including the terminating newline, or 0 if there is no line to be     read at this point. If an error occurs, it should return -1 if and     only if no bytes were read. Reading past EOF is considered an error. */
end_comment
begin_function
DECL|function|readLineData
name|qint64
name|QIODevice
operator|::
name|readLineData
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QIODevice
argument_list|)
expr_stmt|;
name|qint64
name|readSoFar
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|lastReadReturn
init|=
literal|0
decl_stmt|;
name|d
operator|->
name|baseReadLineDataCalled
operator|=
literal|true
expr_stmt|;
while|while
condition|(
name|readSoFar
operator|<
name|maxSize
operator|&&
operator|(
name|lastReadReturn
operator|=
name|read
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|1
condition|)
block|{
operator|*
name|data
operator|++
operator|=
name|c
expr_stmt|;
operator|++
name|readSoFar
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
block|}
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::readLineData(%p, %d), d->pos = %d, d->buffer.size() = %d, returns %d\n"
argument_list|,
name|this
argument_list|,
name|data
argument_list|,
name|int
argument_list|(
name|maxSize
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|pos
argument_list|)
argument_list|,
name|int
argument_list|(
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|readSoFar
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lastReadReturn
operator|!=
literal|1
operator|&&
name|readSoFar
operator|==
literal|0
condition|)
return|return
name|isSequential
argument_list|()
condition|?
name|lastReadReturn
else|:
operator|-
literal|1
return|;
return|return
name|readSoFar
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_CC_RVCT
end_ifdef
begin_pragma
pragma|#
directive|pragma
name|pop
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Returns true if a complete line of data can be read from the device;     otherwise returns false.      Note that unbuffered devices, which have no way of determining what     can be read, always return false.      This function is often called in conjunction with the readyRead()     signal.      Subclasses that reimplement this function must call the base     implementation in order to include the contents of the QIODevice's buffer. Example:      \snippet code/src_corelib_io_qiodevice.cpp 3      \sa readyRead(), readLine() */
end_comment
begin_function
DECL|function|canReadLine
name|bool
name|QIODevice
operator|::
name|canReadLine
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|buffer
operator|.
name|canReadLine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Writes at most \a maxSize bytes of data from \a data to the     device. Returns the number of bytes that were actually written, or     -1 if an error occurred.      \sa read(), writeData() */
end_comment
begin_function
DECL|function|write
name|qint64
name|QIODevice
operator|::
name|write
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QIODevice
argument_list|)
expr_stmt|;
name|CHECK_WRITABLE
argument_list|(
name|write
argument_list|,
name|qint64
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_MAXLEN
argument_list|(
name|write
argument_list|,
name|qint64
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|sequential
init|=
name|d
operator|->
name|isSequential
argument_list|()
decl_stmt|;
comment|// Make sure the device is positioned correctly.
if|if
condition|(
name|d
operator|->
name|pos
operator|!=
name|d
operator|->
name|devicePos
operator|&&
operator|!
name|sequential
operator|&&
operator|!
name|seek
argument_list|(
name|d
operator|->
name|pos
argument_list|)
condition|)
return|return
name|qint64
argument_list|(
operator|-
literal|1
argument_list|)
return|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
name|d
operator|->
name|openMode
operator|&
name|Text
condition|)
block|{
specifier|const
name|char
modifier|*
name|endOfData
init|=
name|data
operator|+
name|maxSize
decl_stmt|;
specifier|const
name|char
modifier|*
name|startOfBlock
init|=
name|data
decl_stmt|;
name|qint64
name|writtenSoFar
init|=
literal|0
decl_stmt|;
forever|forever
block|{
specifier|const
name|char
modifier|*
name|endOfBlock
init|=
name|startOfBlock
decl_stmt|;
while|while
condition|(
name|endOfBlock
operator|<
name|endOfData
operator|&&
operator|*
name|endOfBlock
operator|!=
literal|'\n'
condition|)
operator|++
name|endOfBlock
expr_stmt|;
name|qint64
name|blockSize
init|=
name|endOfBlock
operator|-
name|startOfBlock
decl_stmt|;
if|if
condition|(
name|blockSize
operator|>
literal|0
condition|)
block|{
name|qint64
name|ret
init|=
name|writeData
argument_list|(
name|startOfBlock
argument_list|,
name|blockSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|writtenSoFar
operator|&&
operator|!
name|sequential
condition|)
name|d
operator|->
name|buffer
operator|.
name|skip
argument_list|(
name|writtenSoFar
argument_list|)
expr_stmt|;
return|return
name|writtenSoFar
condition|?
name|writtenSoFar
else|:
name|ret
return|;
block|}
if|if
condition|(
operator|!
name|sequential
condition|)
block|{
name|d
operator|->
name|pos
operator|+=
name|ret
expr_stmt|;
name|d
operator|->
name|devicePos
operator|+=
name|ret
expr_stmt|;
block|}
name|writtenSoFar
operator|+=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|endOfBlock
operator|==
name|endOfData
condition|)
break|break;
name|qint64
name|ret
init|=
name|writeData
argument_list|(
literal|"\r\n"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|writtenSoFar
operator|&&
operator|!
name|sequential
condition|)
name|d
operator|->
name|buffer
operator|.
name|skip
argument_list|(
name|writtenSoFar
argument_list|)
expr_stmt|;
return|return
name|writtenSoFar
condition|?
name|writtenSoFar
else|:
name|ret
return|;
block|}
if|if
condition|(
operator|!
name|sequential
condition|)
block|{
name|d
operator|->
name|pos
operator|+=
name|ret
expr_stmt|;
name|d
operator|->
name|devicePos
operator|+=
name|ret
expr_stmt|;
block|}
operator|++
name|writtenSoFar
expr_stmt|;
name|startOfBlock
operator|=
name|endOfBlock
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|writtenSoFar
operator|&&
operator|!
name|sequential
condition|)
name|d
operator|->
name|buffer
operator|.
name|skip
argument_list|(
name|writtenSoFar
argument_list|)
expr_stmt|;
return|return
name|writtenSoFar
return|;
block|}
endif|#
directive|endif
name|qint64
name|written
init|=
name|writeData
argument_list|(
name|data
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|written
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|sequential
condition|)
block|{
name|d
operator|->
name|pos
operator|+=
name|written
expr_stmt|;
name|d
operator|->
name|devicePos
operator|+=
name|written
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|buffer
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|sequential
condition|)
name|d
operator|->
name|buffer
operator|.
name|skip
argument_list|(
name|written
argument_list|)
expr_stmt|;
block|}
return|return
name|written
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      \overload       Writes data from a zero-terminated string of 8-bit characters to the     device. Returns the number of bytes that were actually written, or     -1 if an error occurred. This is equivalent to     \code     ...     QIODevice::write(data, qstrlen(data));     ...     \endcode      \sa read(), writeData() */
end_comment
begin_function
DECL|function|write
name|qint64
name|QIODevice
operator|::
name|write
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
return|return
name|write
argument_list|(
name|data
argument_list|,
name|qstrlen
argument_list|(
name|data
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn qint64 QIODevice::write(const QByteArray&byteArray)      \overload      Writes the content of \a byteArray to the device. Returns the number of     bytes that were actually written, or -1 if an error occurred.      \sa read(), writeData() */
end_comment
begin_comment
comment|/*!     Puts the character \a c back into the device, and decrements the     current position unless the position is 0. This function is     usually called to "undo" a getChar() operation, such as when     writing a backtracking parser.      If \a c was not previously read from the device, the behavior is     undefined. */
end_comment
begin_function
DECL|function|ungetChar
name|void
name|QIODevice
operator|::
name|ungetChar
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QIODevice
argument_list|)
expr_stmt|;
name|CHECK_READABLE
argument_list|(
name|read
argument_list|,
name|Q_VOID
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QIODEVICE_DEBUG
name|printf
argument_list|(
literal|"%p QIODevice::ungetChar(0x%hhx '%c')\n"
argument_list|,
name|this
argument_list|,
name|c
argument_list|,
name|isprint
argument_list|(
name|c
argument_list|)
condition|?
name|c
else|:
literal|'?'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|buffer
operator|.
name|ungetChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isSequential
argument_list|()
condition|)
operator|--
name|d
operator|->
name|pos
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn bool QIODevice::putChar(char c)      Writes the character \a c to the device. Returns true on success;     otherwise returns false.      \sa write(), getChar(), ungetChar() */
end_comment
begin_function
DECL|function|putChar
name|bool
name|QIODevice
operator|::
name|putChar
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|putCharHelper
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|putCharHelper
name|bool
name|QIODevicePrivate
operator|::
name|putCharHelper
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|q_func
argument_list|()
operator|->
name|write
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|peek
name|qint64
name|QIODevicePrivate
operator|::
name|peek
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|)
block|{
name|qint64
name|readBytes
init|=
name|q_func
argument_list|()
operator|->
name|read
argument_list|(
name|data
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBytes
operator|<=
literal|0
condition|)
return|return
name|readBytes
return|;
name|buffer
operator|.
name|ungetBlock
argument_list|(
name|data
argument_list|,
name|readBytes
argument_list|)
expr_stmt|;
operator|*
name|pPos
operator|-=
name|readBytes
expr_stmt|;
return|return
name|readBytes
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|peek
name|QByteArray
name|QIODevicePrivate
operator|::
name|peek
parameter_list|(
name|qint64
name|maxSize
parameter_list|)
block|{
name|QByteArray
name|result
init|=
name|q_func
argument_list|()
operator|->
name|read
argument_list|(
name|maxSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|result
return|;
name|buffer
operator|.
name|ungetBlock
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|,
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|pPos
operator|-=
name|result
operator|.
name|size
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QIODevice::getChar(char *c)      Reads one character from the device and stores it in \a c. If \a c     is 0, the character is discarded. Returns true on success;     otherwise returns false.      \sa read(), putChar(), ungetChar() */
end_comment
begin_function
DECL|function|getChar
name|bool
name|QIODevice
operator|::
name|getChar
parameter_list|(
name|char
modifier|*
name|c
parameter_list|)
block|{
comment|// readability checked in read()
name|char
name|ch
decl_stmt|;
return|return
operator|(
literal|1
operator|==
name|read
argument_list|(
name|c
condition|?
name|c
else|:
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Reads at most \a maxSize bytes from the device into \a data, without side     effects (i.e., if you call read() after peek(), you will get the same     data).  Returns the number of bytes read. If an error occurs, such as     when attempting to peek a device opened in WriteOnly mode, this function     returns -1.      0 is returned when no more data is available for reading.      Example:      \snippet code/src_corelib_io_qiodevice.cpp 4      \sa read() */
end_comment
begin_function
DECL|function|peek
name|qint64
name|QIODevice
operator|::
name|peek
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|peek
argument_list|(
name|data
argument_list|,
name|maxSize
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1     \overload      Peeks at most \a maxSize bytes from the device, returning the data peeked     as a QByteArray.      Example:      \snippet code/src_corelib_io_qiodevice.cpp 5      This function has no way of reporting errors; returning an empty     QByteArray() can mean either that no data was currently available     for peeking, or that an error occurred.      \sa read() */
end_comment
begin_function
DECL|function|peek
name|QByteArray
name|QIODevice
operator|::
name|peek
parameter_list|(
name|qint64
name|maxSize
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|peek
argument_list|(
name|maxSize
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Blocks until new data is available for reading and the readyRead()     signal has been emitted, or until \a msecs milliseconds have     passed. If msecs is -1, this function will not time out.      Returns true if new data is available for reading; otherwise returns     false (if the operation timed out or if an error occurred).      This function can operate without an event loop. It is     useful when writing non-GUI applications and when performing     I/O operations in a non-GUI thread.      If called from within a slot connected to the readyRead() signal,     readyRead() will not be reemitted.      Reimplement this function to provide a blocking API for a custom     device. The default implementation does nothing, and returns false.      \warning Calling this function from the main (GUI) thread     might cause your user interface to freeze.      \sa waitForBytesWritten() */
end_comment
begin_function
DECL|function|waitForReadyRead
name|bool
name|QIODevice
operator|::
name|waitForReadyRead
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|msecs
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     For buffered devices, this function waits until a payload of     buffered written data has been written to the device and the     bytesWritten() signal has been emitted, or until \a msecs     milliseconds have passed. If msecs is -1, this function will     not time out. For unbuffered devices, it returns immediately.      Returns true if a payload of data was written to the device;     otherwise returns false (i.e. if the operation timed out, or if an     error occurred).      This function can operate without an event loop. It is     useful when writing non-GUI applications and when performing     I/O operations in a non-GUI thread.      If called from within a slot connected to the bytesWritten() signal,     bytesWritten() will not be reemitted.      Reimplement this function to provide a blocking API for a custom     device. The default implementation does nothing, and returns false.      \warning Calling this function from the main (GUI) thread     might cause your user interface to freeze.      \sa waitForReadyRead() */
end_comment
begin_function
DECL|function|waitForBytesWritten
name|bool
name|QIODevice
operator|::
name|waitForBytesWritten
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|msecs
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the human readable description of the last device error that     occurred to \a str.      \sa errorString() */
end_comment
begin_function
DECL|function|setErrorString
name|void
name|QIODevice
operator|::
name|setErrorString
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|errorString
operator|=
name|str
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a human-readable description of the last device error that     occurred.      \sa setErrorString() */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QIODevice
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QIODevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|errorString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
return|return
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QIODevice
argument_list|,
literal|"Unknown error"
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
name|tr
argument_list|(
literal|"Unknown error"
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
name|d
operator|->
name|errorString
return|;
block|}
end_function
begin_comment
comment|/*!     \fn qint64 QIODevice::readData(char *data, qint64 maxSize)      Reads up to \a maxSize bytes from the device into \a data, and     returns the number of bytes read or -1 if an error occurred.      If there are no bytes to be read and there can never be more bytes     available (examples include socket closed, pipe closed, sub-process     finished), this function returns -1.      This function is called by QIODevice. Reimplement this function     when creating a subclass of QIODevice.      When reimplementing this function it is important that this function     reads all the required data before returning. This is required in order     for QDataStream to be able to operate on the class. QDataStream assumes     all the requested information was read and therefore does not retry reading     if there was a problem.      This function will be called with maxSize 0 when the device is     buffered and the buffer was emptied by a call to read().      \sa read(), readLine(), writeData() */
end_comment
begin_comment
comment|/*!     \fn qint64 QIODevice::writeData(const char *data, qint64 maxSize)      Writes up to \a maxSize bytes from \a data to the device. Returns     the number of bytes written, or -1 if an error occurred.      This function is called by QIODevice. Reimplement this function     when creating a subclass of QIODevice.      When reimplementing this function it is important that this function     writes all the data available before returning. This is required in order     for QDataStream to be able to operate on the class. QDataStream assumes     all the information was written and therefore does not retry writing if     there was a problem.      \sa read(), write() */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
end_if
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
name|QIODevice
operator|::
name|OpenMode
name|modes
parameter_list|)
block|{
name|debug
operator|<<
literal|"OpenMode("
expr_stmt|;
name|QStringList
name|modeList
decl_stmt|;
if|if
condition|(
name|modes
operator|==
name|QIODevice
operator|::
name|NotOpen
condition|)
block|{
name|modeList
operator|<<
name|QLatin1String
argument_list|(
literal|"NotOpen"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|modes
operator|&
name|QIODevice
operator|::
name|ReadOnly
condition|)
name|modeList
operator|<<
name|QLatin1String
argument_list|(
literal|"ReadOnly"
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|QIODevice
operator|::
name|WriteOnly
condition|)
name|modeList
operator|<<
name|QLatin1String
argument_list|(
literal|"WriteOnly"
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|QIODevice
operator|::
name|Append
condition|)
name|modeList
operator|<<
name|QLatin1String
argument_list|(
literal|"Append"
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|QIODevice
operator|::
name|Truncate
condition|)
name|modeList
operator|<<
name|QLatin1String
argument_list|(
literal|"Truncate"
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|QIODevice
operator|::
name|Text
condition|)
name|modeList
operator|<<
name|QLatin1String
argument_list|(
literal|"Text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|QIODevice
operator|::
name|Unbuffered
condition|)
name|modeList
operator|<<
name|QLatin1String
argument_list|(
literal|"Unbuffered"
argument_list|)
expr_stmt|;
block|}
name|qSort
argument_list|(
name|modeList
argument_list|)
expr_stmt|;
name|debug
operator|<<
name|modeList
operator|.
name|join
argument_list|(
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
argument_list|)
expr_stmt|;
name|debug
operator|<<
literal|')'
expr_stmt|;
return|return
name|debug
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
