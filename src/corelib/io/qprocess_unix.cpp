begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QPROCESS_DEBUG
end_comment
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PROCESS
end_ifndef
begin_if
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
end_if
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_comment
comment|/*     Returns a human readable representation of the first \a len     characters in \a data. */
end_comment
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|qt_prettyDebug
specifier|static
name|QByteArray
name|qt_prettyDebug
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|maxSize
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
condition|)
return|return
literal|"(null)"
return|;
name|QByteArray
name|out
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|char
name|c
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|out
operator|+=
name|c
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|out
operator|+=
literal|"\\n"
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|out
operator|+=
literal|"\\r"
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|out
operator|+=
literal|"\\t"
expr_stmt|;
break|break;
default|default:
name|QString
name|tmp
decl_stmt|;
name|tmp
operator|.
name|sprintf
argument_list|(
literal|"\\%o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|out
operator|+=
name|tmp
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|<
name|maxSize
condition|)
name|out
operator|+=
literal|"..."
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_decl_stmt
name|QT_END_NAMESPACE
endif|#
directive|endif
include|#
directive|include
file|"qplatformdefs.h"
include|#
directive|include
file|"qprocess.h"
include|#
directive|include
file|"qprocess_p.h"
include|#
directive|include
file|"private/qcore_unix_p.h"
ifdef|#
directive|ifdef
name|Q_OS_MAC
include|#
directive|include
file|<private/qcore_mac_p.h>
endif|#
directive|endif
include|#
directive|include
file|<private/qcoreapplication_p.h>
include|#
directive|include
file|<private/qthread_p.h>
include|#
directive|include
file|<qfile.h>
include|#
directive|include
file|<qfileinfo.h>
include|#
directive|include
file|<qlist.h>
include|#
directive|include
file|<qhash.h>
include|#
directive|include
file|<qmutex.h>
include|#
directive|include
file|<qsemaphore.h>
include|#
directive|include
file|<qsocketnotifier.h>
include|#
directive|include
file|<qthread.h>
include|#
directive|include
file|<qelapsedtimer.h>
include|#
directive|include
file|<errno.h>
include|#
directive|include
file|<stdlib.h>
include|#
directive|include
file|<string.h>
ifdef|#
directive|ifdef
name|Q_OS_QNX
include|#
directive|include
file|"qvarlengtharray.h"
include|#
directive|include
file|<spawn.h>
include|#
directive|include
file|<sys/neutrino.h>
endif|#
directive|endif
name|QT_BEGIN_NAMESPACE
comment|// POSIX requires PIPE_BUF to be 512 or larger
comment|// so we will use 512
DECL|variable|errorBufferMax
specifier|static
specifier|const
name|int
name|errorBufferMax
init|=
literal|512
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qt_qprocess_deadChild_pipe
specifier|static
name|int
name|qt_qprocess_deadChild_pipe
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qt_sa_old_sigchld_handler
specifier|static
name|struct
name|sigaction
name|qt_sa_old_sigchld_handler
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_sa_sigchld_handler
specifier|static
name|void
name|qt_sa_sigchld_handler
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|qt_safe_write
argument_list|(
name|qt_qprocess_deadChild_pipe
index|[
literal|1
index|]
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** SIGCHLD\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// load it as volatile
name|void
function_decl|(
modifier|*
name|oldAction
function_decl|)
parameter_list|(
name|int
parameter_list|)
init|=
operator|(
operator|(
specifier|volatile
init|struct
name|sigaction
operator|*
init|)
ref_qualifier|&
name|qt_sa_old_sigchld_handler
block|)
function|->
name|sa_handler
function|;
end_function
begin_if
if|if
condition|(
name|oldAction
operator|&&
name|oldAction
operator|!=
name|SIG_IGN
condition|)
name|oldAction
argument_list|(
name|signum
argument_list|)
expr_stmt|;
end_if
begin_function
unit|}  static
DECL|function|add_fd
specifier|inline
name|void
name|add_fd
parameter_list|(
name|int
modifier|&
name|nfds
parameter_list|,
name|int
name|fd
parameter_list|,
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|FD_SET
argument_list|(
name|fd
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|)
operator|>
name|nfds
condition|)
name|nfds
operator|=
name|fd
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|QProcessInfo
struct|struct
name|QProcessInfo
block|{
DECL|member|process
name|QProcess
modifier|*
name|process
decl_stmt|;
DECL|member|deathPipe
name|int
name|deathPipe
decl_stmt|;
DECL|member|exitResult
name|int
name|exitResult
decl_stmt|;
DECL|member|pid
name|pid_t
name|pid
decl_stmt|;
DECL|member|serialNumber
name|int
name|serialNumber
decl_stmt|;
block|}
struct|;
end_struct
begin_class
DECL|class|QProcessManager
class|class
name|QProcessManager
super|:
specifier|public
name|QThread
block|{
name|Q_OBJECT
public|public:
name|QProcessManager
parameter_list|()
constructor_decl|;
name|~
name|QProcessManager
parameter_list|()
destructor_decl|;
name|void
name|run
parameter_list|()
function_decl|;
name|void
name|catchDeadChildren
parameter_list|()
function_decl|;
name|void
name|add
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|QProcess
modifier|*
name|process
parameter_list|)
function_decl|;
name|void
name|remove
parameter_list|(
name|QProcess
modifier|*
name|process
parameter_list|)
function_decl|;
name|void
name|lock
parameter_list|()
function_decl|;
name|void
name|unlock
parameter_list|()
function_decl|;
private|private:
DECL|member|mutex
name|QMutex
name|mutex
decl_stmt|;
DECL|member|children
name|QHash
argument_list|<
name|int
argument_list|,
name|QProcessInfo
modifier|*
argument_list|>
name|children
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|variable|processManagerInstance
specifier|static
name|QProcessManager
modifier|*
name|processManagerInstance
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|processManager
specifier|static
name|QProcessManager
modifier|*
name|processManager
parameter_list|()
block|{
comment|// The constructor of QProcessManager should be called only once
comment|// so we cannot use Q_GLOBAL_STATIC directly for QProcessManager
specifier|static
name|QBasicMutex
name|processManagerGlobalMutex
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|processManagerGlobalMutex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|processManagerInstance
condition|)
operator|new
name|QProcessManager
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|processManagerInstance
argument_list|)
expr_stmt|;
return|return
name|processManagerInstance
return|;
block|}
end_function
begin_constructor
DECL|function|QProcessManager
name|QProcessManager
operator|::
name|QProcessManager
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QProcessManager::QProcessManager()"
expr_stmt|;
endif|#
directive|endif
comment|// initialize the dead child pipe and make it non-blocking. in the
comment|// extremely unlikely event that the pipe fills up, we do not under any
comment|// circumstances want to block.
name|qt_safe_pipe
argument_list|(
name|qt_qprocess_deadChild_pipe
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
comment|// set up the SIGCHLD handler, which writes a single byte to the dead
comment|// child pipe every time a child dies.
name|struct
name|sigaction
name|action
decl_stmt|;
name|memset
argument_list|(
operator|&
name|action
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|action
argument_list|)
argument_list|)
expr_stmt|;
name|action
operator|.
name|sa_handler
operator|=
name|qt_sa_sigchld_handler
expr_stmt|;
name|action
operator|.
name|sa_flags
operator|=
name|SA_NOCLDSTOP
expr_stmt|;
operator|::
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|action
argument_list|,
operator|&
name|qt_sa_old_sigchld_handler
argument_list|)
expr_stmt|;
name|processManagerInstance
operator|=
name|this
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QProcessManager
name|QProcessManager
operator|::
name|~
name|QProcessManager
parameter_list|()
block|{
comment|// notify the thread that we're shutting down.
name|qt_safe_write
argument_list|(
name|qt_qprocess_deadChild_pipe
index|[
literal|1
index|]
argument_list|,
literal|"@"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|qt_qprocess_deadChild_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|wait
argument_list|()
expr_stmt|;
comment|// on certain unixes, closing the reading end of the pipe will cause
comment|// select in run() to block forever, rather than return with EBADF.
name|qt_safe_close
argument_list|(
name|qt_qprocess_deadChild_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|qt_qprocess_deadChild_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|qt_qprocess_deadChild_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|qDeleteAll
argument_list|(
name|children
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|children
operator|.
name|clear
argument_list|()
expr_stmt|;
name|struct
name|sigaction
name|currentAction
decl_stmt|;
operator|::
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
literal|0
argument_list|,
operator|&
name|currentAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentAction
operator|.
name|sa_handler
operator|==
name|qt_sa_sigchld_handler
condition|)
block|{
operator|::
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|qt_sa_old_sigchld_handler
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|processManagerInstance
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|run
name|void
name|QProcessManager
operator|::
name|run
parameter_list|()
block|{
forever|forever
block|{
name|fd_set
name|readset
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|qt_qprocess_deadChild_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readset
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QProcessManager::run() waiting for children to die"
expr_stmt|;
endif|#
directive|endif
comment|// block forever, or until activity is detected on the dead child
comment|// pipe. the only other peers are the SIGCHLD signal handler, and the
comment|// QProcessManager destructor.
name|int
name|nselect
init|=
name|select
argument_list|(
name|qt_qprocess_deadChild_pipe
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
operator|&
name|readset
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|nselect
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
break|break;
block|}
comment|// empty only one byte from the pipe, even though several SIGCHLD
comment|// signals may have been delivered in the meantime, to avoid race
comment|// conditions.
name|char
name|c
decl_stmt|;
if|if
condition|(
name|qt_safe_read
argument_list|(
name|qt_qprocess_deadChild_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
operator|||
name|c
operator|==
literal|'@'
condition|)
break|break;
comment|// catch any and all children that we can.
name|catchDeadChildren
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|catchDeadChildren
name|void
name|QProcessManager
operator|::
name|catchDeadChildren
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
comment|// try to catch all children whose pid we have registered, and whose
comment|// deathPipe is still valid (i.e, we have not already notified it).
name|QHash
argument_list|<
name|int
argument_list|,
name|QProcessInfo
modifier|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|children
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|children
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// notify all children that they may have died. they need to run
comment|// waitpid() in their own thread.
name|QProcessInfo
modifier|*
name|info
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|qt_safe_write
argument_list|(
name|info
operator|->
name|deathPipe
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QProcessManager::run() sending death notice to"
operator|<<
name|info
operator|->
name|process
expr_stmt|;
endif|#
directive|endif
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|idCounter
specifier|static
name|QBasicAtomicInt
name|idCounter
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|add
name|void
name|QProcessManager
operator|::
name|add
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|QProcess
modifier|*
name|process
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QProcessManager::add() adding pid"
operator|<<
name|pid
operator|<<
literal|"process"
operator|<<
name|process
expr_stmt|;
endif|#
directive|endif
comment|// insert a new info structure for this process
name|QProcessInfo
modifier|*
name|info
init|=
operator|new
name|QProcessInfo
decl_stmt|;
name|info
operator|->
name|process
operator|=
name|process
expr_stmt|;
name|info
operator|->
name|deathPipe
operator|=
name|process
operator|->
name|d_func
argument_list|()
operator|->
name|deathPipe
index|[
literal|1
index|]
expr_stmt|;
name|info
operator|->
name|exitResult
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|int
name|serial
init|=
name|idCounter
operator|.
name|fetchAndAddRelaxed
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|process
operator|->
name|d_func
argument_list|()
operator|->
name|serial
operator|=
name|serial
expr_stmt|;
name|children
operator|.
name|insert
argument_list|(
name|serial
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|remove
name|void
name|QProcessManager
operator|::
name|remove
parameter_list|(
name|QProcess
modifier|*
name|process
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
name|int
name|serial
init|=
name|process
operator|->
name|d_func
argument_list|()
operator|->
name|serial
decl_stmt|;
name|QProcessInfo
modifier|*
name|info
init|=
name|children
operator|.
name|take
argument_list|(
name|serial
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
if|if
condition|(
name|info
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"QProcessManager::remove() removing pid"
operator|<<
name|info
operator|->
name|pid
operator|<<
literal|"process"
operator|<<
name|info
operator|->
name|process
expr_stmt|;
endif|#
directive|endif
operator|delete
name|info
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lock
name|void
name|QProcessManager
operator|::
name|lock
parameter_list|()
block|{
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unlock
name|void
name|QProcessManager
operator|::
name|unlock
parameter_list|()
block|{
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_create_pipe
specifier|static
name|void
name|qt_create_pipe
parameter_list|(
name|int
modifier|*
name|pipe
parameter_list|)
block|{
if|if
condition|(
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|qt_safe_close
argument_list|(
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|qt_safe_close
argument_list|(
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|qt_safe_pipe
argument_list|(
name|pipe
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QProcessPrivate::createPipe: Cannot create pipe %p: %s"
argument_list|,
name|pipe
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|destroyPipe
name|void
name|QProcessPrivate
operator|::
name|destroyPipe
parameter_list|(
name|int
modifier|*
name|pipe
parameter_list|)
block|{
if|if
condition|(
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|qt_safe_close
argument_list|(
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|qt_safe_close
argument_list|(
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|destroyChannel
name|void
name|QProcessPrivate
operator|::
name|destroyChannel
parameter_list|(
name|Channel
modifier|*
name|channel
parameter_list|)
block|{
name|destroyPipe
argument_list|(
name|channel
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     Create the pipes to a QProcessPrivate::Channel.      This function must be called in order: stdin, stdout, stderr */
end_comment
begin_function
DECL|function|createChannel
name|bool
name|QProcessPrivate
operator|::
name|createChannel
parameter_list|(
name|Channel
modifier|&
name|channel
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|channel
operator|==
operator|&
name|stderrChannel
operator|&&
name|processChannelMode
operator|==
name|QProcess
operator|::
name|MergedChannels
condition|)
block|{
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|channel
operator|.
name|type
operator|==
name|Channel
operator|::
name|Normal
condition|)
block|{
comment|// we're piping this channel to our own process
name|qt_create_pipe
argument_list|(
name|channel
operator|.
name|pipe
argument_list|)
expr_stmt|;
comment|// create the socket notifiers
if|if
condition|(
name|threadData
operator|->
name|eventDispatcher
condition|)
block|{
if|if
condition|(
operator|&
name|channel
operator|==
operator|&
name|stdinChannel
condition|)
block|{
name|channel
operator|.
name|notifier
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|QSocketNotifier
operator|::
name|Write
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|channel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|channel
operator|.
name|notifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_canWrite
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|channel
operator|.
name|notifier
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|q
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|receiver
decl_stmt|;
if|if
condition|(
operator|&
name|channel
operator|==
operator|&
name|stdoutChannel
condition|)
name|receiver
operator|=
name|SLOT
argument_list|(
name|_q_canReadStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|receiver
operator|=
name|SLOT
argument_list|(
name|_q_canReadStandardError
argument_list|()
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|channel
operator|.
name|notifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|receiver
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|channel
operator|.
name|type
operator|==
name|Channel
operator|::
name|Redirect
condition|)
block|{
comment|// we're redirecting the channel to/from a file
name|QByteArray
name|fname
init|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|channel
operator|.
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
operator|&
name|channel
operator|==
operator|&
name|stdinChannel
condition|)
block|{
comment|// try to open in read-only mode
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
name|qt_safe_open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
return|return
literal|true
return|;
comment|// success
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Could not open input redirection for reading"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|mode
init|=
name|O_WRONLY
operator||
name|O_CREAT
decl_stmt|;
if|if
condition|(
name|channel
operator|.
name|append
condition|)
name|mode
operator||=
name|O_APPEND
expr_stmt|;
else|else
name|mode
operator||=
name|O_TRUNC
expr_stmt|;
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
name|qt_safe_open
argument_list|(
name|fname
argument_list|,
name|mode
argument_list|,
literal|0666
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
return|return
literal|true
return|;
comment|// success
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Could not open output redirection for writing"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// could not open file
name|processError
operator|=
name|QProcess
operator|::
name|FailedToStart
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
name|cleanup
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|Q_ASSERT_X
argument_list|(
name|channel
operator|.
name|process
argument_list|,
literal|"QProcess::start"
argument_list|,
literal|"Internal error"
argument_list|)
expr_stmt|;
name|Channel
modifier|*
name|source
decl_stmt|;
name|Channel
modifier|*
name|sink
decl_stmt|;
if|if
condition|(
name|channel
operator|.
name|type
operator|==
name|Channel
operator|::
name|PipeSource
condition|)
block|{
comment|// we are the source
name|source
operator|=
operator|&
name|channel
expr_stmt|;
name|sink
operator|=
operator|&
name|channel
operator|.
name|process
operator|->
name|stdinChannel
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|source
operator|==
operator|&
name|stdoutChannel
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|sink
operator|->
name|process
operator|==
name|this
operator|&&
name|sink
operator|->
name|type
operator|==
name|Channel
operator|::
name|PipeSink
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we are the sink;
name|source
operator|=
operator|&
name|channel
operator|.
name|process
operator|->
name|stdoutChannel
expr_stmt|;
name|sink
operator|=
operator|&
name|channel
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|sink
operator|==
operator|&
name|stdinChannel
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|source
operator|->
name|process
operator|==
name|this
operator|&&
name|source
operator|->
name|type
operator|==
name|Channel
operator|::
name|PipeSource
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|source
operator|->
name|pipe
index|[
literal|1
index|]
operator|!=
name|INVALID_Q_PIPE
operator|||
name|sink
operator|->
name|pipe
index|[
literal|0
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
comment|// already created, do nothing
return|return
literal|true
return|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|source
operator|->
name|pipe
index|[
literal|0
index|]
operator|==
name|INVALID_Q_PIPE
operator|&&
name|source
operator|->
name|pipe
index|[
literal|1
index|]
operator|==
name|INVALID_Q_PIPE
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|sink
operator|->
name|pipe
index|[
literal|0
index|]
operator|==
name|INVALID_Q_PIPE
operator|&&
name|sink
operator|->
name|pipe
index|[
literal|1
index|]
operator|==
name|INVALID_Q_PIPE
argument_list|)
expr_stmt|;
name|Q_PIPE
name|pipe
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|qt_create_pipe
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|sink
operator|->
name|pipe
index|[
literal|0
index|]
operator|=
name|pipe
index|[
literal|0
index|]
expr_stmt|;
name|source
operator|->
name|pipe
index|[
literal|1
index|]
operator|=
name|pipe
index|[
literal|1
index|]
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
end_function
begin_decl_stmt
name|QT_BEGIN_INCLUDE_NAMESPACE
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_IOS
argument_list|)
include|#
directive|include
file|<crt_externs.h>
DECL|macro|environ
define|#
directive|define
name|environ
value|(*_NSGetEnviron())
else|#
directive|else
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_END_INCLUDE_NAMESPACE
DECL|function|systemEnvironment
name|QProcessEnvironment
name|QProcessEnvironment
operator|::
name|systemEnvironment
parameter_list|()
block|{
name|QProcessEnvironment
name|env
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_IOS
argument_list|)
specifier|const
name|char
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
operator|(
name|entry
operator|=
name|environ
index|[
name|count
index|]
operator|)
condition|;
operator|++
name|count
control|)
block|{
specifier|const
name|char
modifier|*
name|equal
init|=
name|strchr
argument_list|(
name|entry
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|equal
condition|)
continue|continue;
name|QByteArray
name|name
argument_list|(
name|entry
argument_list|,
name|equal
operator|-
name|entry
argument_list|)
decl_stmt|;
name|QByteArray
name|value
argument_list|(
name|equal
operator|+
literal|1
argument_list|)
decl_stmt|;
name|env
operator|.
name|d
operator|->
name|hash
operator|.
name|insert
argument_list|(
name|QProcessEnvironmentPrivate
operator|::
name|Key
argument_list|(
name|name
argument_list|)
argument_list|,
name|QProcessEnvironmentPrivate
operator|::
name|Value
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|env
return|;
block|}
end_function
begin_function
DECL|function|_q_dupEnvironment
specifier|static
name|char
modifier|*
modifier|*
name|_q_dupEnvironment
parameter_list|(
specifier|const
name|QProcessEnvironmentPrivate
operator|::
name|Hash
modifier|&
name|environment
parameter_list|,
name|int
modifier|*
name|envc
parameter_list|)
block|{
operator|*
name|envc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|environment
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// if LD_LIBRARY_PATH exists in the current environment, but
comment|// not in the environment list passed by the programmer, then
comment|// copy it over.
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
specifier|static
specifier|const
name|char
name|libraryPath
index|[]
init|=
literal|"DYLD_LIBRARY_PATH"
decl_stmt|;
else|#
directive|else
specifier|static
specifier|const
name|char
name|libraryPath
index|[]
init|=
literal|"LD_LIBRARY_PATH"
decl_stmt|;
endif|#
directive|endif
specifier|const
name|QByteArray
name|envLibraryPath
init|=
name|qgetenv
argument_list|(
name|libraryPath
argument_list|)
decl_stmt|;
name|bool
name|needToAddLibraryPath
init|=
operator|!
name|envLibraryPath
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|environment
operator|.
name|contains
argument_list|(
name|QProcessEnvironmentPrivate
operator|::
name|Key
argument_list|(
name|QByteArray
argument_list|(
name|libraryPath
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
init|=
operator|new
name|char
operator|*
index|[
name|environment
operator|.
name|count
argument_list|()
operator|+
literal|2
index|]
decl_stmt|;
name|envp
index|[
name|environment
operator|.
name|count
argument_list|()
index|]
operator|=
literal|0
expr_stmt|;
name|envp
index|[
name|environment
operator|.
name|count
argument_list|()
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|QProcessEnvironmentPrivate
operator|::
name|Hash
operator|::
name|ConstIterator
name|it
init|=
name|environment
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|QProcessEnvironmentPrivate
operator|::
name|Hash
operator|::
name|ConstIterator
name|end
init|=
name|environment
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|QByteArray
name|key
init|=
name|it
operator|.
name|key
argument_list|()
operator|.
name|key
decl_stmt|;
name|QByteArray
name|value
init|=
name|it
operator|.
name|value
argument_list|()
operator|.
name|bytes
argument_list|()
decl_stmt|;
name|key
operator|.
name|reserve
argument_list|(
name|key
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|+
name|value
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|key
operator|.
name|append
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|envp
index|[
operator|(
operator|*
name|envc
operator|)
operator|++
index|]
operator|=
operator|::
name|strdup
argument_list|(
name|key
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needToAddLibraryPath
condition|)
name|envp
index|[
operator|(
operator|*
name|envc
operator|)
operator|++
index|]
operator|=
operator|::
name|strdup
argument_list|(
name|QByteArray
argument_list|(
name|QByteArray
argument_list|(
name|libraryPath
argument_list|)
operator|+
literal|'='
operator|+
name|envLibraryPath
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|envp
return|;
block|}
end_function
begin_function
DECL|function|startProcess
name|void
name|QProcessPrivate
operator|::
name|startProcess
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::startProcess()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|processManager
argument_list|()
operator|->
name|start
argument_list|()
expr_stmt|;
comment|// Initialize pipes
if|if
condition|(
operator|!
name|createChannel
argument_list|(
name|stdinChannel
argument_list|)
operator|||
operator|!
name|createChannel
argument_list|(
name|stdoutChannel
argument_list|)
operator|||
operator|!
name|createChannel
argument_list|(
name|stderrChannel
argument_list|)
condition|)
return|return;
name|qt_create_pipe
argument_list|(
name|childStartedPipe
argument_list|)
expr_stmt|;
name|qt_create_pipe
argument_list|(
name|deathPipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|threadData
operator|->
name|eventDispatcher
condition|)
block|{
name|startupSocketNotifier
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|startupSocketNotifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_startupNotification
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|deathNotifier
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|deathPipe
index|[
literal|0
index|]
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|deathNotifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_processDied
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Start the process (platform dependent)
name|q
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|Starting
argument_list|)
expr_stmt|;
comment|// Create argument list with right number of elements, and set the final
comment|// one to 0.
name|char
modifier|*
modifier|*
name|argv
init|=
operator|new
name|char
operator|*
index|[
name|arguments
operator|.
name|count
argument_list|()
operator|+
literal|2
index|]
decl_stmt|;
name|argv
index|[
name|arguments
operator|.
name|count
argument_list|()
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|// Encode the program name.
name|QByteArray
name|encodedProgramName
init|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|program
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MAC
comment|// allow invoking of .app bundles on the Mac.
name|QFileInfo
name|fileInfo
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
name|encodedProgramName
operator|.
name|endsWith
argument_list|(
literal|".app"
argument_list|)
operator|&&
name|fileInfo
operator|.
name|isDir
argument_list|()
condition|)
block|{
name|QCFType
argument_list|<
name|CFURLRef
argument_list|>
name|url
init|=
name|CFURLCreateWithFileSystemPath
argument_list|(
literal|0
argument_list|,
name|QCFString
argument_list|(
name|fileInfo
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
argument_list|,
name|kCFURLPOSIXPathStyle
argument_list|,
literal|true
argument_list|)
decl_stmt|;
block|{
comment|// CFBundle is not reentrant, since CFBundleCreate might return a reference
comment|// to a cached bundle object. Protect the bundle calls with a mutex lock.
specifier|static
name|QBasicMutex
name|cfbundleMutex
decl_stmt|;
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|cfbundleMutex
argument_list|)
decl_stmt|;
name|QCFType
argument_list|<
name|CFBundleRef
argument_list|>
name|bundle
init|=
name|CFBundleCreate
argument_list|(
literal|0
argument_list|,
name|url
argument_list|)
decl_stmt|;
name|url
operator|=
name|CFBundleCopyExecutableURL
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|url
condition|)
block|{
name|QCFString
name|str
init|=
name|CFURLCopyFileSystemPath
argument_list|(
name|url
argument_list|,
name|kCFURLPOSIXPathStyle
argument_list|)
decl_stmt|;
name|encodedProgramName
operator|+=
literal|"/Contents/MacOS/"
operator|+
name|QCFString
operator|::
name|toQString
argument_list|(
name|str
argument_list|)
operator|.
name|toUtf8
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// Add the program name to the argument list.
name|char
modifier|*
name|dupProgramName
init|=
operator|::
name|strdup
argument_list|(
name|encodedProgramName
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|dupProgramName
expr_stmt|;
comment|// Add every argument to the list
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|::
name|strdup
argument_list|(
name|QFile
operator|::
name|encodeName
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
comment|// Duplicate the environment.
name|int
name|envc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|environment
operator|.
name|d
operator|.
name|constData
argument_list|()
condition|)
name|envp
operator|=
name|_q_dupEnvironment
argument_list|(
name|environment
operator|.
name|d
operator|.
name|constData
argument_list|()
operator|->
name|hash
argument_list|,
operator|&
name|envc
argument_list|)
expr_stmt|;
comment|// Encode the working directory if it's non-empty, otherwise just pass 0.
specifier|const
name|char
modifier|*
name|workingDirPtr
init|=
literal|0
decl_stmt|;
name|QByteArray
name|encodedWorkingDirectory
decl_stmt|;
if|if
condition|(
operator|!
name|workingDirectory
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|encodedWorkingDirectory
operator|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|workingDirectory
argument_list|)
expr_stmt|;
name|workingDirPtr
operator|=
name|encodedWorkingDirectory
operator|.
name|constData
argument_list|()
expr_stmt|;
block|}
comment|// If the program does not specify a path, generate a list of possible
comment|// locations for the binary using the PATH environment variable.
name|char
modifier|*
modifier|*
name|path
init|=
literal|0
decl_stmt|;
name|int
name|pathc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|program
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
block|{
specifier|const
name|QString
name|pathEnv
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
operator|::
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pathEnv
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
name|pathEntries
init|=
name|pathEnv
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pathEntries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|pathc
operator|=
name|pathEntries
operator|.
name|size
argument_list|()
expr_stmt|;
name|path
operator|=
operator|new
name|char
operator|*
index|[
name|pathc
operator|+
literal|1
index|]
expr_stmt|;
name|path
index|[
name|pathc
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|pathEntries
operator|.
name|size
argument_list|()
condition|;
operator|++
name|k
control|)
block|{
name|QByteArray
name|tmp
init|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|pathEntries
operator|.
name|at
argument_list|(
name|k
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|.
name|endsWith
argument_list|(
literal|'/'
argument_list|)
condition|)
name|tmp
operator|+=
literal|'/'
expr_stmt|;
name|tmp
operator|+=
name|encodedProgramName
expr_stmt|;
name|path
index|[
name|k
index|]
operator|=
operator|::
name|strdup
argument_list|(
name|tmp
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Start the process manager, and fork off the child process.
name|processManager
argument_list|()
operator|->
name|lock
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
name|pid_t
name|childPid
init|=
name|spawnChild
argument_list|(
name|workingDirPtr
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
decl_stmt|;
else|#
directive|else
name|pid_t
name|childPid
init|=
name|fork
argument_list|()
decl_stmt|;
name|int
name|lastForkErrno
init|=
name|errno
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|childPid
operator|!=
literal|0
condition|)
block|{
comment|// Clean up duplicated memory.
name|free
argument_list|(
name|dupProgramName
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|arguments
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|envc
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|envp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pathc
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|argv
expr_stmt|;
operator|delete
index|[]
name|envp
expr_stmt|;
operator|delete
index|[]
name|path
expr_stmt|;
block|}
comment|// This is not a valid check under QNX, because the semantics are
comment|// different. While under other platforms where fork() may succeed and exec() can still fail,
comment|// causing the childPid to hold a valid value (and thus evaluating the
comment|// following if to false), and then signaling the error via
comment|// childStartedPipe, under QNX on the other hand, spawn() return value will be assigned
comment|// to childPid (which will be -1 in case of failure). This will force
comment|// QProcess to cleanup, instead of signaling the error via
comment|// childStartedPipe. Since it will invalidade the pipes, functions like
comment|// QProcess::waitForStarted() will fail, for childStartedPipe will be
comment|// '-1' and mess with the select() calls.
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
if|if
condition|(
name|childPid
operator|<
literal|0
condition|)
block|{
comment|// Cleanup, report error and return
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"fork failed: %s"
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
name|lastForkErrno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|processManager
argument_list|()
operator|->
name|unlock
argument_list|()
expr_stmt|;
name|q
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|NotRunning
argument_list|)
expr_stmt|;
name|processError
operator|=
name|QProcess
operator|::
name|FailedToStart
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Resource error (fork failure): %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|qt_error_string
argument_list|(
name|lastForkErrno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
name|cleanup
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Start the child.
if|if
condition|(
name|childPid
operator|==
literal|0
condition|)
block|{
name|execChild
argument_list|(
name|workingDirPtr
argument_list|,
name|path
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
operator|::
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Register the child. In the mean time, we can get a SIGCHLD, so we need
comment|// to keep the lock held to avoid a race to catch the child.
name|processManager
argument_list|()
operator|->
name|add
argument_list|(
name|childPid
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|pid
operator|=
name|Q_PID
argument_list|(
name|childPid
argument_list|)
expr_stmt|;
name|processManager
argument_list|()
operator|->
name|unlock
argument_list|()
expr_stmt|;
comment|// parent
comment|// close the ends we don't use and make all pipes non-blocking
operator|::
name|fcntl
argument_list|(
name|deathPipe
index|[
literal|0
index|]
argument_list|,
name|F_SETFL
argument_list|,
operator|::
name|fcntl
argument_list|(
name|deathPipe
index|[
literal|0
index|]
argument_list|,
name|F_GETFL
argument_list|)
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|childStartedPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|childStartedPipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|qt_safe_close
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
operator|::
name|fcntl
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|F_SETFL
argument_list|,
operator|::
name|fcntl
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|F_GETFL
argument_list|)
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|qt_safe_close
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|::
name|fcntl
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|F_SETFL
argument_list|,
operator|::
name|fcntl
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|F_GETFL
argument_list|)
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|qt_safe_close
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|::
name|fcntl
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|F_SETFL
argument_list|,
operator|::
name|fcntl
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|F_GETFL
argument_list|)
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
end_if
begin_function
DECL|function|doSpawn
specifier|static
name|pid_t
name|doSpawn
parameter_list|(
name|int
name|fd_count
parameter_list|,
name|int
name|fd_map
index|[]
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
modifier|*
name|envp
parameter_list|,
specifier|const
name|char
modifier|*
name|workingDir
parameter_list|,
name|bool
name|spawn_detached
parameter_list|)
block|{
comment|// A multi threaded QNX Process can't fork so we call spawn() instead.
name|struct
name|inheritance
name|inherit
decl_stmt|;
name|memset
argument_list|(
operator|&
name|inherit
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inherit
argument_list|)
argument_list|)
expr_stmt|;
name|inherit
operator|.
name|flags
operator||=
name|SPAWN_SETSID
expr_stmt|;
name|inherit
operator|.
name|flags
operator||=
name|SPAWN_CHECK_SCRIPT
expr_stmt|;
if|if
condition|(
name|spawn_detached
condition|)
name|inherit
operator|.
name|flags
operator||=
name|SPAWN_NOZOMBIE
expr_stmt|;
name|inherit
operator|.
name|flags
operator||=
name|SPAWN_SETSIGDEF
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|inherit
operator|.
name|sigdefault
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
comment|// reset the signal that we ignored
comment|// enter the working directory
specifier|const
name|char
modifier|*
name|oldWorkingDir
init|=
literal|0
decl_stmt|;
name|char
name|buff
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|workingDir
condition|)
block|{
comment|//we need to freeze everyone in order to avoid race conditions with //chdir().
if|if
condition|(
name|ThreadCtl
argument_list|(
name|_NTO_TCTL_THREADS_HOLD
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"ThreadCtl(): cannot hold threads: %s"
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|oldWorkingDir
operator|=
name|QT_GETCWD
argument_list|(
name|buff
argument_list|,
name|PATH_MAX
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|QT_CHDIR
argument_list|(
name|workingDir
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"ThreadCtl(): failed to chdir to %s"
argument_list|,
name|workingDir
argument_list|)
expr_stmt|;
block|}
name|pid_t
name|childPid
decl_stmt|;
name|EINTR_LOOP
argument_list|(
name|childPid
argument_list|,
operator|::
name|spawn
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|fd_count
argument_list|,
name|fd_map
argument_list|,
operator|&
name|inherit
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|childPid
operator|==
operator|-
literal|1
condition|)
block|{
name|inherit
operator|.
name|flags
operator||=
name|SPAWN_SEARCH_PATH
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|childPid
argument_list|,
operator|::
name|spawn
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|fd_count
argument_list|,
name|fd_map
argument_list|,
operator|&
name|inherit
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldWorkingDir
condition|)
block|{
if|if
condition|(
name|QT_CHDIR
argument_list|(
name|oldWorkingDir
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"ThreadCtl(): failed to chdir to %s"
argument_list|,
name|oldWorkingDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|ThreadCtl
argument_list|(
name|_NTO_TCTL_THREADS_CONT
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|qFatal
argument_list|(
literal|"ThreadCtl(): cannot resume threads: %s"
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|childPid
return|;
block|}
end_function
begin_function
DECL|function|spawnChild
name|pid_t
name|QProcessPrivate
operator|::
name|spawnChild
parameter_list|(
specifier|const
name|char
modifier|*
name|workingDir
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
modifier|*
name|envp
parameter_list|)
block|{
comment|// we need to manually fill in fd_map
comment|// to inherit the file descriptors from
comment|// the parent
specifier|const
name|int
name|fd_count
init|=
name|sysconf
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|int
argument_list|,
literal|1024
argument_list|>
name|fd_map
argument_list|(
name|fd_count
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|3
init|;
name|i
operator|<
name|fd_count
condition|;
operator|++
name|i
control|)
block|{
comment|// here we rely that fcntl returns -1 and
comment|// sets errno to EBADF
specifier|const
name|int
name|flags
init|=
operator|::
name|fcntl
argument_list|(
name|i
argument_list|,
name|F_GETFD
argument_list|)
decl_stmt|;
name|fd_map
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|flags
operator|>=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|FD_CLOEXEC
operator|)
operator|)
condition|?
name|i
else|:
name|SPAWN_FDCLOSED
expr_stmt|;
block|}
switch|switch
condition|(
name|processChannelMode
condition|)
block|{
case|case
name|QProcess
operator|::
name|ForwardedChannels
case|:
name|fd_map
index|[
literal|0
index|]
operator|=
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
expr_stmt|;
name|fd_map
index|[
literal|1
index|]
operator|=
name|QT_FILENO
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fd_map
index|[
literal|2
index|]
operator|=
name|QT_FILENO
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|QProcess
operator|::
name|MergedChannels
case|:
name|fd_map
index|[
literal|0
index|]
operator|=
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
expr_stmt|;
name|fd_map
index|[
literal|1
index|]
operator|=
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
expr_stmt|;
name|fd_map
index|[
literal|2
index|]
operator|=
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|QProcess
operator|::
name|SeparateChannels
case|:
name|fd_map
index|[
literal|0
index|]
operator|=
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
expr_stmt|;
name|fd_map
index|[
literal|1
index|]
operator|=
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
expr_stmt|;
name|fd_map
index|[
literal|2
index|]
operator|=
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
name|pid_t
name|childPid
init|=
name|doSpawn
argument_list|(
name|fd_count
argument_list|,
name|fd_map
operator|.
name|data
argument_list|()
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|,
name|workingDir
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|childPid
operator|==
operator|-
literal|1
condition|)
block|{
name|QString
name|error
init|=
name|qt_error_string
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|qt_safe_write
argument_list|(
name|childStartedPipe
index|[
literal|1
index|]
argument_list|,
name|error
operator|.
name|data
argument_list|()
argument_list|,
name|error
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|childStartedPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|childStartedPipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|childPid
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|execChild
name|void
name|QProcessPrivate
operator|::
name|execChild
parameter_list|(
specifier|const
name|char
modifier|*
name|workingDir
parameter_list|,
name|char
modifier|*
modifier|*
name|path
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
modifier|*
name|envp
parameter_list|)
block|{
operator|::
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|// reset the signal that we ignored
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
comment|// copy the stdin socket (without closing on exec)
name|qt_safe_dup2
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// copy the stdout and stderr if asked to
if|if
condition|(
name|processChannelMode
operator|!=
name|QProcess
operator|::
name|ForwardedChannels
condition|)
block|{
name|qt_safe_dup2
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// merge stdout and stderr if asked to
if|if
condition|(
name|processChannelMode
operator|==
name|QProcess
operator|::
name|MergedChannels
condition|)
block|{
name|qt_safe_dup2
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qt_safe_dup2
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|// make sure this fd is closed if execvp() succeeds
name|qt_safe_close
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// enter the working directory
if|if
condition|(
name|workingDir
condition|)
block|{
if|if
condition|(
name|QT_CHDIR
argument_list|(
name|workingDir
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"QProcessPrivate::execChild() failed to chdir to %s"
argument_list|,
name|workingDir
argument_list|)
expr_stmt|;
block|}
comment|// this is a virtual call, and it base behavior is to do nothing.
name|q
operator|->
name|setupChildProcess
argument_list|()
expr_stmt|;
comment|// execute the process
if|if
condition|(
operator|!
name|envp
condition|)
block|{
name|qt_safe_execvp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|path
condition|)
block|{
name|char
modifier|*
modifier|*
name|arg
init|=
name|path
decl_stmt|;
while|while
condition|(
operator|*
name|arg
condition|)
block|{
name|argv
index|[
literal|0
index|]
operator|=
operator|*
name|arg
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"QProcessPrivate::execChild() searching / starting %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qt_safe_execve
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
operator|++
name|arg
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"QProcessPrivate::execChild() starting %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qt_safe_execve
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
block|}
block|}
comment|// notify failure
name|QString
name|error
init|=
name|qt_error_string
argument_list|(
name|errno
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"QProcessPrivate::execChild() failed (%s), notifying parent process\n"
argument_list|,
name|qPrintable
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qt_safe_write
argument_list|(
name|childStartedPipe
index|[
literal|1
index|]
argument_list|,
name|error
operator|.
name|data
argument_list|()
argument_list|,
name|error
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|childStartedPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|childStartedPipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|processStarted
name|bool
name|QProcessPrivate
operator|::
name|processStarted
parameter_list|()
block|{
name|ushort
name|buf
index|[
name|errorBufferMax
index|]
decl_stmt|;
name|int
name|i
init|=
name|qt_safe_read
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|startupSocketNotifier
condition|)
block|{
name|startupSocketNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|startupSocketNotifier
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
name|startupSocketNotifier
operator|=
literal|0
expr_stmt|;
block|}
name|qt_safe_close
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|childStartedPipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::processStarted() == %s"
argument_list|,
name|i
operator|<=
literal|0
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// did we read an error message?
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|q_func
argument_list|()
operator|->
name|setErrorString
argument_list|(
name|QString
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|buf
argument_list|,
name|i
operator|/
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
operator|<=
literal|0
return|;
block|}
end_function
begin_function
DECL|function|bytesAvailableFromStdout
name|qint64
name|QProcessPrivate
operator|::
name|bytesAvailableFromStdout
parameter_list|()
specifier|const
block|{
name|int
name|nbytes
init|=
literal|0
decl_stmt|;
name|qint64
name|available
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|::
name|ioctl
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|FIONREAD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nbytes
argument_list|)
operator|>=
literal|0
condition|)
name|available
operator|=
operator|(
name|qint64
operator|)
name|nbytes
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::bytesAvailableFromStdout() == %lld"
argument_list|,
name|available
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|available
return|;
block|}
end_function
begin_function
DECL|function|bytesAvailableFromStderr
name|qint64
name|QProcessPrivate
operator|::
name|bytesAvailableFromStderr
parameter_list|()
specifier|const
block|{
name|int
name|nbytes
init|=
literal|0
decl_stmt|;
name|qint64
name|available
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|::
name|ioctl
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|FIONREAD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nbytes
argument_list|)
operator|>=
literal|0
condition|)
name|available
operator|=
operator|(
name|qint64
operator|)
name|nbytes
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::bytesAvailableFromStderr() == %lld"
argument_list|,
name|available
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|available
return|;
block|}
end_function
begin_function
DECL|function|readFromStdout
name|qint64
name|QProcessPrivate
operator|::
name|readFromStdout
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|qint64
name|bytesRead
init|=
name|qt_safe_read
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|data
argument_list|,
name|maxlen
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::readFromStdout(%p \"%s\", %lld) == %lld"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|bytesRead
argument_list|,
literal|16
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|maxlen
argument_list|,
name|bytesRead
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|bytesRead
return|;
block|}
end_function
begin_function
DECL|function|readFromStderr
name|qint64
name|QProcessPrivate
operator|::
name|readFromStderr
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|qint64
name|bytesRead
init|=
name|qt_safe_read
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|data
argument_list|,
name|maxlen
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::readFromStderr(%p \"%s\", %lld) == %lld"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|bytesRead
argument_list|,
literal|16
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|maxlen
argument_list|,
name|bytesRead
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|bytesRead
return|;
block|}
end_function
begin_function
DECL|function|writeToStdin
name|qint64
name|QProcessPrivate
operator|::
name|writeToStdin
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|qint64
name|written
init|=
name|qt_safe_write_nosignal
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|data
argument_list|,
name|maxlen
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::writeToStdin(%p \"%s\", %lld) == %lld"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|,
literal|16
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|maxlen
argument_list|,
name|written
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|==
operator|-
literal|1
condition|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::writeToStdin(), failed to write (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// If the O_NONBLOCK flag is set and If some data can be written without blocking
comment|// the process, write() will transfer what it can and return the number of bytes written.
comment|// Otherwise, it will return -1 and set errno to EAGAIN
if|if
condition|(
name|written
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
name|written
operator|=
literal|0
expr_stmt|;
return|return
name|written
return|;
block|}
end_function
begin_function
DECL|function|terminateProcess
name|void
name|QProcessPrivate
operator|::
name|terminateProcess
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::killProcess()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
condition|)
operator|::
name|kill
argument_list|(
name|pid_t
argument_list|(
name|pid
argument_list|)
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|killProcess
name|void
name|QProcessPrivate
operator|::
name|killProcess
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::killProcess()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
condition|)
operator|::
name|kill
argument_list|(
name|pid_t
argument_list|(
name|pid
argument_list|)
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|select_msecs
specifier|static
name|int
name|select_msecs
parameter_list|(
name|int
name|nfds
parameter_list|,
name|fd_set
modifier|*
name|fdread
parameter_list|,
name|fd_set
modifier|*
name|fdwrite
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
return|return
name|qt_safe_select
argument_list|(
name|nfds
argument_list|,
name|fdread
argument_list|,
name|fdwrite
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|timeout
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
name|timeout
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
return|return
name|qt_safe_select
argument_list|(
name|nfds
argument_list|,
name|fdread
argument_list|,
name|fdwrite
argument_list|,
literal|0
argument_list|,
operator|&
name|tv
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*    Returns the difference between msecs and elapsed. If msecs is -1,    however, -1 is returned. */
end_comment
begin_function
DECL|function|qt_timeout_value
specifier|static
name|int
name|qt_timeout_value
parameter_list|(
name|int
name|msecs
parameter_list|,
name|int
name|elapsed
parameter_list|)
block|{
if|if
condition|(
name|msecs
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|timeout
init|=
name|msecs
operator|-
name|elapsed
decl_stmt|;
return|return
name|timeout
operator|<
literal|0
condition|?
literal|0
else|:
name|timeout
return|;
block|}
end_function
begin_function
DECL|function|waitForStarted
name|bool
name|QProcessPrivate
operator|::
name|waitForStarted
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::waitForStarted(%d) waiting for child to start (fd = %d)"
argument_list|,
name|msecs
argument_list|,
name|childStartedPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fd_set
name|fds
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|select_msecs
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
literal|0
argument_list|,
name|msecs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|processError
operator|=
name|QProcess
operator|::
name|Timedout
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::waitForStarted(%d) == false (timed out)"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
name|bool
name|startedEmitted
init|=
name|_q_startupNotification
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::waitForStarted() == %s"
argument_list|,
name|startedEmitted
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|startedEmitted
return|;
block|}
end_function
begin_function
DECL|function|waitForReadyRead
name|bool
name|QProcessPrivate
operator|::
name|waitForReadyRead
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::waitForReadyRead(%d)"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
forever|forever
block|{
name|fd_set
name|fdread
decl_stmt|;
name|fd_set
name|fdwrite
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdread
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
name|int
name|nfds
init|=
name|deathPipe
index|[
literal|0
index|]
decl_stmt|;
name|FD_SET
argument_list|(
name|deathPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|processState
operator|==
name|QProcess
operator|::
name|Starting
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
operator|&&
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
name|int
name|timeout
init|=
name|qt_timeout_value
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
name|select_msecs
argument_list|(
name|nfds
operator|+
literal|1
argument_list|,
operator|&
name|fdread
argument_list|,
operator|&
name|fdwrite
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|processError
operator|=
name|QProcess
operator|::
name|Timedout
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|childStartedPipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|_q_startupNotification
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
name|bool
name|readyReadEmitted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
name|bool
name|canRead
init|=
name|_q_canReadStandardOutput
argument_list|()
decl_stmt|;
if|if
condition|(
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardOutput
operator|&&
name|canRead
condition|)
name|readyReadEmitted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
name|bool
name|canRead
init|=
name|_q_canReadStandardError
argument_list|()
decl_stmt|;
if|if
condition|(
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
operator|&&
name|canRead
condition|)
name|readyReadEmitted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|readyReadEmitted
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|fdwrite
argument_list|)
condition|)
name|_q_canWrite
argument_list|()
expr_stmt|;
if|if
condition|(
name|deathPipe
index|[
literal|0
index|]
operator|==
operator|-
literal|1
operator|||
name|FD_ISSET
argument_list|(
name|deathPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
if|if
condition|(
name|_q_processDied
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|waitForBytesWritten
name|bool
name|QProcessPrivate
operator|::
name|waitForBytesWritten
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::waitForBytesWritten(%d)"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fd_set
name|fdread
decl_stmt|;
name|fd_set
name|fdwrite
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdread
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
name|int
name|nfds
init|=
name|deathPipe
index|[
literal|0
index|]
decl_stmt|;
name|FD_SET
argument_list|(
name|deathPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|processState
operator|==
name|QProcess
operator|::
name|Starting
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
operator|&&
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
name|int
name|timeout
init|=
name|qt_timeout_value
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
name|select_msecs
argument_list|(
name|nfds
operator|+
literal|1
argument_list|,
operator|&
name|fdread
argument_list|,
operator|&
name|fdwrite
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|processError
operator|=
name|QProcess
operator|::
name|Timedout
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|childStartedPipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|_q_startupNotification
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|fdwrite
argument_list|)
condition|)
return|return
name|_q_canWrite
argument_list|()
return|;
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
name|_q_canReadStandardOutput
argument_list|()
expr_stmt|;
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
name|_q_canReadStandardError
argument_list|()
expr_stmt|;
if|if
condition|(
name|deathPipe
index|[
literal|0
index|]
operator|==
operator|-
literal|1
operator|||
name|FD_ISSET
argument_list|(
name|deathPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
if|if
condition|(
name|_q_processDied
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|waitForFinished
name|bool
name|QProcessPrivate
operator|::
name|waitForFinished
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::waitForFinished(%d)"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
forever|forever
block|{
name|fd_set
name|fdread
decl_stmt|;
name|fd_set
name|fdwrite
decl_stmt|;
name|int
name|nfds
init|=
operator|-
literal|1
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdread
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|processState
operator|==
name|QProcess
operator|::
name|Starting
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|processState
operator|==
name|QProcess
operator|::
name|Running
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|deathPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
operator|&&
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
name|int
name|timeout
init|=
name|qt_timeout_value
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
name|select_msecs
argument_list|(
name|nfds
operator|+
literal|1
argument_list|,
operator|&
name|fdread
argument_list|,
operator|&
name|fdwrite
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|processError
operator|=
name|QProcess
operator|::
name|Timedout
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|childStartedPipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|_q_startupNotification
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|fdwrite
argument_list|)
condition|)
name|_q_canWrite
argument_list|()
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
name|_q_canReadStandardOutput
argument_list|()
expr_stmt|;
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
name|_q_canReadStandardError
argument_list|()
expr_stmt|;
if|if
condition|(
name|deathPipe
index|[
literal|0
index|]
operator|==
operator|-
literal|1
operator|||
name|FD_ISSET
argument_list|(
name|deathPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
if|if
condition|(
name|_q_processDied
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|waitForWrite
name|bool
name|QProcessPrivate
operator|::
name|waitForWrite
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|fd_set
name|fdwrite
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
return|return
name|select_msecs
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|fdwrite
argument_list|,
name|msecs
operator|<
literal|0
condition|?
literal|0
else|:
name|msecs
argument_list|)
operator|==
literal|1
return|;
block|}
end_function
begin_function
DECL|function|findExitCode
name|void
name|QProcessPrivate
operator|::
name|findExitCode
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|processManager
argument_list|()
operator|->
name|remove
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|waitForDeadChild
name|bool
name|QProcessPrivate
operator|::
name|waitForDeadChild
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
comment|// read a byte from the death pipe
name|char
name|c
decl_stmt|;
name|qt_safe_read
argument_list|(
name|deathPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// check if our process is dead
name|int
name|exitStatus
decl_stmt|;
if|if
condition|(
name|qt_safe_waitpid
argument_list|(
name|pid_t
argument_list|(
name|pid
argument_list|)
argument_list|,
operator|&
name|exitStatus
argument_list|,
name|WNOHANG
argument_list|)
operator|>
literal|0
condition|)
block|{
name|processManager
argument_list|()
operator|->
name|remove
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|crashed
operator|=
operator|!
name|WIFEXITED
argument_list|(
name|exitStatus
argument_list|)
expr_stmt|;
name|exitCode
operator|=
name|WEXITSTATUS
argument_list|(
name|exitStatus
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QProcessPrivate::waitForDeadChild() dead with exitCode"
operator|<<
name|exitCode
operator|<<
literal|", crashed?"
operator|<<
name|crashed
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QProcessPrivate::waitForDeadChild() not dead!"
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|_q_notified
name|void
name|QProcessPrivate
operator|::
name|_q_notified
parameter_list|()
block|{ }
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
end_if
begin_function
DECL|function|startDetached
name|bool
name|QProcessPrivate
operator|::
name|startDetached
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|,
specifier|const
name|QString
modifier|&
name|workingDirectory
parameter_list|,
name|qint64
modifier|*
name|pid
parameter_list|)
block|{
specifier|const
name|int
name|fd_count
init|=
literal|3
decl_stmt|;
name|int
name|fd_map
index|[
name|fd_count
index|]
init|=
block|{
name|QT_FILENO
argument_list|(
name|stdin
argument_list|)
block|,
name|QT_FILENO
argument_list|(
name|stdout
argument_list|)
block|,
name|QT_FILENO
argument_list|(
argument|stderr
argument_list|)
block|}
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|enc_args
decl_stmt|;
name|enc_args
operator|.
name|append
argument_list|(
name|QFile
operator|::
name|encodeName
argument_list|(
name|program
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|enc_args
operator|.
name|append
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|int
name|argc
init|=
name|enc_args
operator|.
name|size
argument_list|()
decl_stmt|;
name|QScopedArrayPointer
argument_list|<
name|char
modifier|*
argument_list|>
name|raw_argv
argument_list|(
operator|new
name|char
operator|*
index|[
name|argc
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|raw_argv
index|[
name|i
index|]
operator|=
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|enc_args
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|raw_argv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
name|char
modifier|*
modifier|*
name|envp
init|=
literal|0
decl_stmt|;
comment|// inherit environment
comment|// Encode the working directory if it's non-empty, otherwise just pass 0.
specifier|const
name|char
modifier|*
name|workingDirPtr
init|=
literal|0
decl_stmt|;
name|QByteArray
name|encodedWorkingDirectory
decl_stmt|;
if|if
condition|(
operator|!
name|workingDirectory
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|encodedWorkingDirectory
operator|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|workingDirectory
argument_list|)
expr_stmt|;
name|workingDirPtr
operator|=
name|encodedWorkingDirectory
operator|.
name|constData
argument_list|()
expr_stmt|;
block|}
name|pid_t
name|childPid
init|=
name|doSpawn
argument_list|(
name|fd_count
argument_list|,
name|fd_map
argument_list|,
name|raw_argv
operator|.
name|data
argument_list|()
argument_list|,
name|envp
argument_list|,
name|workingDirPtr
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|pid
operator|&&
name|childPid
operator|!=
operator|-
literal|1
condition|)
operator|*
name|pid
operator|=
name|childPid
expr_stmt|;
return|return
name|childPid
operator|!=
operator|-
literal|1
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|startDetached
name|bool
name|QProcessPrivate
operator|::
name|startDetached
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|,
specifier|const
name|QString
modifier|&
name|workingDirectory
parameter_list|,
name|qint64
modifier|*
name|pid
parameter_list|)
block|{
name|processManager
argument_list|()
operator|->
name|start
argument_list|()
expr_stmt|;
name|QByteArray
name|encodedWorkingDirectory
init|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|workingDirectory
argument_list|)
decl_stmt|;
comment|// To catch the startup of the child
name|int
name|startedPipe
index|[
literal|2
index|]
decl_stmt|;
name|qt_safe_pipe
argument_list|(
name|startedPipe
argument_list|)
expr_stmt|;
comment|// To communicate the pid of the child
name|int
name|pidPipe
index|[
literal|2
index|]
decl_stmt|;
name|qt_safe_pipe
argument_list|(
name|pidPipe
argument_list|)
expr_stmt|;
name|pid_t
name|childPid
init|=
name|fork
argument_list|()
decl_stmt|;
if|if
condition|(
name|childPid
operator|==
literal|0
condition|)
block|{
name|struct
name|sigaction
name|noaction
decl_stmt|;
name|memset
argument_list|(
operator|&
name|noaction
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|noaction
argument_list|)
argument_list|)
expr_stmt|;
name|noaction
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
operator|::
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|noaction
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|::
name|setsid
argument_list|()
expr_stmt|;
name|qt_safe_close
argument_list|(
name|startedPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|pidPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pid_t
name|doubleForkPid
init|=
name|fork
argument_list|()
decl_stmt|;
if|if
condition|(
name|doubleForkPid
operator|==
literal|0
condition|)
block|{
name|qt_safe_close
argument_list|(
name|pidPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encodedWorkingDirectory
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|QT_CHDIR
argument_list|(
name|encodedWorkingDirectory
operator|.
name|constData
argument_list|()
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"QProcessPrivate::startDetached: failed to chdir to %s"
argument_list|,
name|encodedWorkingDirectory
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|char
modifier|*
modifier|*
name|argv
init|=
operator|new
name|char
operator|*
index|[
name|arguments
operator|.
name|size
argument_list|()
operator|+
literal|2
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|::
name|strdup
argument_list|(
name|QFile
operator|::
name|encodeName
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|argv
index|[
name|arguments
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|program
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
block|{
specifier|const
name|QString
name|path
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
operator|::
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
name|pathEntries
init|=
name|path
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|pathEntries
operator|.
name|size
argument_list|()
condition|;
operator|++
name|k
control|)
block|{
name|QByteArray
name|tmp
init|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|pathEntries
operator|.
name|at
argument_list|(
name|k
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|.
name|endsWith
argument_list|(
literal|'/'
argument_list|)
condition|)
name|tmp
operator|+=
literal|'/'
expr_stmt|;
name|tmp
operator|+=
name|QFile
operator|::
name|encodeName
argument_list|(
name|program
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|tmp
operator|.
name|data
argument_list|()
expr_stmt|;
name|qt_safe_execv
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|QByteArray
name|tmp
init|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|tmp
operator|.
name|data
argument_list|()
expr_stmt|;
name|qt_safe_execv
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
name|struct
name|sigaction
name|noaction
decl_stmt|;
name|memset
argument_list|(
operator|&
name|noaction
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|noaction
argument_list|)
argument_list|)
expr_stmt|;
name|noaction
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
operator|::
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|noaction
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// '\1' means execv failed
name|char
name|c
init|=
literal|'\1'
decl_stmt|;
name|qt_safe_write
argument_list|(
name|startedPipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|startedPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|::
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|doubleForkPid
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|sigaction
name|noaction
decl_stmt|;
name|memset
argument_list|(
operator|&
name|noaction
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|noaction
argument_list|)
argument_list|)
expr_stmt|;
name|noaction
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
operator|::
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|noaction
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// '\2' means internal error
name|char
name|c
init|=
literal|'\2'
decl_stmt|;
name|qt_safe_write
argument_list|(
name|startedPipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|qt_safe_close
argument_list|(
name|startedPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|qt_safe_write
argument_list|(
name|pidPipe
index|[
literal|1
index|]
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|doubleForkPid
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|QT_CHDIR
argument_list|(
literal|"/"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"QProcessPrivate::startDetached: failed to chdir to /"
argument_list|)
expr_stmt|;
operator|::
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|qt_safe_close
argument_list|(
name|startedPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|pidPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|childPid
operator|==
operator|-
literal|1
condition|)
block|{
name|qt_safe_close
argument_list|(
name|startedPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|pidPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|char
name|reply
init|=
literal|'\0'
decl_stmt|;
name|int
name|startResult
init|=
name|qt_safe_read
argument_list|(
name|startedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|reply
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
name|qt_safe_close
argument_list|(
name|startedPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|qt_safe_waitpid
argument_list|(
name|childPid
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bool
name|success
init|=
operator|(
name|startResult
operator|!=
operator|-
literal|1
operator|&&
name|reply
operator|==
literal|'\0'
operator|)
decl_stmt|;
if|if
condition|(
name|success
operator|&&
name|pid
condition|)
block|{
name|pid_t
name|actualPid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|qt_safe_read
argument_list|(
name|pidPipe
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|actualPid
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
condition|)
block|{
operator|*
name|pid
operator|=
name|actualPid
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pid
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|qt_safe_close
argument_list|(
name|pidPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|initializeProcessManager
name|void
name|QProcessPrivate
operator|::
name|initializeProcessManager
parameter_list|()
block|{
operator|(
name|void
operator|)
name|processManager
argument_list|()
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"qprocess_unix.moc"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PROCESS
end_comment
end_unit
