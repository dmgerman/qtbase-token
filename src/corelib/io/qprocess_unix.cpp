begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QPROCESS_DEBUG
end_comment
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PROCESS
end_ifndef
begin_if
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
end_if
begin_include
include|#
directive|include
file|"private/qtools_p.h"
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_comment
comment|/*     Returns a human readable representation of the first \a len     characters in \a data. */
end_comment
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|qt_prettyDebug
specifier|static
name|QByteArray
name|qt_prettyDebug
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|maxSize
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
condition|)
return|return
literal|"(null)"
return|;
name|QByteArray
name|out
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|char
name|c
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|out
operator|+=
name|c
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|out
operator|+=
literal|"\\n"
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|out
operator|+=
literal|"\\r"
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|out
operator|+=
literal|"\\t"
expr_stmt|;
break|break;
default|default:
block|{
specifier|const
name|char
name|buf
index|[]
init|=
block|{
literal|'\\'
block|,
name|QtMiscUtils
operator|::
name|toOct
argument_list|(
name|uchar
argument_list|(
name|c
argument_list|)
operator|/
literal|64
argument_list|)
block|,
name|QtMiscUtils
operator|::
name|toOct
argument_list|(
name|uchar
argument_list|(
name|c
argument_list|)
operator|%
literal|64
operator|/
literal|8
argument_list|)
block|,
name|QtMiscUtils
operator|::
name|toOct
argument_list|(
name|uchar
argument_list|(
name|c
argument_list|)
operator|%
literal|8
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|out
operator|+=
name|buf
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|len
operator|<
name|maxSize
condition|)
name|out
operator|+=
literal|"..."
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_decl_stmt
name|QT_END_NAMESPACE
endif|#
directive|endif
include|#
directive|include
file|"qplatformdefs.h"
include|#
directive|include
file|"qprocess.h"
include|#
directive|include
file|"qprocess_p.h"
include|#
directive|include
file|"private/qcore_unix_p.h"
ifdef|#
directive|ifdef
name|Q_OS_MAC
include|#
directive|include
file|<private/qcore_mac_p.h>
endif|#
directive|endif
include|#
directive|include
file|<private/qcoreapplication_p.h>
include|#
directive|include
file|<private/qthread_p.h>
include|#
directive|include
file|<qfile.h>
include|#
directive|include
file|<qfileinfo.h>
include|#
directive|include
file|<qlist.h>
include|#
directive|include
file|<qmutex.h>
include|#
directive|include
file|<qsemaphore.h>
include|#
directive|include
file|<qsocketnotifier.h>
include|#
directive|include
file|<qthread.h>
include|#
directive|include
file|<qelapsedtimer.h>
ifdef|#
directive|ifdef
name|Q_OS_QNX
include|#
directive|include
file|<sys/neutrino.h>
endif|#
directive|endif
include|#
directive|include
file|<errno.h>
include|#
directive|include
file|<stdlib.h>
include|#
directive|include
file|<string.h>
include|#
directive|include
file|<forkfd.h>
name|QT_BEGIN_NAMESPACE
comment|// POSIX requires PIPE_BUF to be 512 or larger
comment|// so we will use 512
DECL|variable|errorBufferMax
specifier|static
specifier|const
name|int
name|errorBufferMax
init|=
literal|512
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|add_fd
specifier|static
specifier|inline
name|void
name|add_fd
parameter_list|(
name|int
modifier|&
name|nfds
parameter_list|,
name|int
name|fd
parameter_list|,
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|FD_SET
argument_list|(
name|fd
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|)
operator|>
name|nfds
condition|)
name|nfds
operator|=
name|fd
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_create_pipe
specifier|static
name|int
name|qt_create_pipe
parameter_list|(
name|int
modifier|*
name|pipe
parameter_list|)
block|{
if|if
condition|(
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|qt_safe_close
argument_list|(
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|qt_safe_close
argument_list|(
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|int
name|pipe_ret
init|=
name|qt_safe_pipe
argument_list|(
name|pipe
argument_list|)
decl_stmt|;
if|if
condition|(
name|pipe_ret
operator|!=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QProcessPrivate::createPipe: Cannot create pipe %p: %s"
argument_list|,
name|pipe
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|pipe_ret
return|;
block|}
end_function
begin_function
DECL|function|destroyPipe
name|void
name|QProcessPrivate
operator|::
name|destroyPipe
parameter_list|(
name|int
modifier|*
name|pipe
parameter_list|)
block|{
if|if
condition|(
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|qt_safe_close
argument_list|(
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|qt_safe_close
argument_list|(
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|closeChannel
name|void
name|QProcessPrivate
operator|::
name|closeChannel
parameter_list|(
name|Channel
modifier|*
name|channel
parameter_list|)
block|{
name|destroyPipe
argument_list|(
name|channel
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     Create the pipes to a QProcessPrivate::Channel.      This function must be called in order: stdin, stdout, stderr */
end_comment
begin_function
DECL|function|openChannel
name|bool
name|QProcessPrivate
operator|::
name|openChannel
parameter_list|(
name|Channel
modifier|&
name|channel
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|channel
operator|==
operator|&
name|stderrChannel
operator|&&
name|processChannelMode
operator|==
name|QProcess
operator|::
name|MergedChannels
condition|)
block|{
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|channel
operator|.
name|type
operator|==
name|Channel
operator|::
name|Normal
condition|)
block|{
comment|// we're piping this channel to our own process
if|if
condition|(
name|qt_create_pipe
argument_list|(
name|channel
operator|.
name|pipe
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
comment|// create the socket notifiers
if|if
condition|(
name|threadData
operator|->
name|hasEventDispatcher
argument_list|()
condition|)
block|{
if|if
condition|(
operator|&
name|channel
operator|==
operator|&
name|stdinChannel
condition|)
block|{
name|channel
operator|.
name|notifier
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|QSocketNotifier
operator|::
name|Write
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|channel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|channel
operator|.
name|notifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_canWrite
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|channel
operator|.
name|notifier
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|q
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|receiver
decl_stmt|;
if|if
condition|(
operator|&
name|channel
operator|==
operator|&
name|stdoutChannel
condition|)
name|receiver
operator|=
name|SLOT
argument_list|(
name|_q_canReadStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|receiver
operator|=
name|SLOT
argument_list|(
name|_q_canReadStandardError
argument_list|()
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|channel
operator|.
name|notifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|receiver
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|channel
operator|.
name|type
operator|==
name|Channel
operator|::
name|Redirect
condition|)
block|{
comment|// we're redirecting the channel to/from a file
name|QByteArray
name|fname
init|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|channel
operator|.
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
operator|&
name|channel
operator|==
operator|&
name|stdinChannel
condition|)
block|{
comment|// try to open in read-only mode
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
name|qt_safe_open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
return|return
literal|true
return|;
comment|// success
name|setErrorAndEmit
argument_list|(
name|QProcess
operator|::
name|FailedToStart
argument_list|,
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Could not open input redirection for reading"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|mode
init|=
name|O_WRONLY
operator||
name|O_CREAT
decl_stmt|;
if|if
condition|(
name|channel
operator|.
name|append
condition|)
name|mode
operator||=
name|O_APPEND
expr_stmt|;
else|else
name|mode
operator||=
name|O_TRUNC
expr_stmt|;
name|channel
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
name|qt_safe_open
argument_list|(
name|fname
argument_list|,
name|mode
argument_list|,
literal|0666
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
return|return
literal|true
return|;
comment|// success
name|setErrorAndEmit
argument_list|(
name|QProcess
operator|::
name|FailedToStart
argument_list|,
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Could not open input redirection for reading"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cleanup
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|Q_ASSERT_X
argument_list|(
name|channel
operator|.
name|process
argument_list|,
literal|"QProcess::start"
argument_list|,
literal|"Internal error"
argument_list|)
expr_stmt|;
name|Channel
modifier|*
name|source
decl_stmt|;
name|Channel
modifier|*
name|sink
decl_stmt|;
if|if
condition|(
name|channel
operator|.
name|type
operator|==
name|Channel
operator|::
name|PipeSource
condition|)
block|{
comment|// we are the source
name|source
operator|=
operator|&
name|channel
expr_stmt|;
name|sink
operator|=
operator|&
name|channel
operator|.
name|process
operator|->
name|stdinChannel
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|source
operator|==
operator|&
name|stdoutChannel
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|sink
operator|->
name|process
operator|==
name|this
operator|&&
name|sink
operator|->
name|type
operator|==
name|Channel
operator|::
name|PipeSink
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we are the sink;
name|source
operator|=
operator|&
name|channel
operator|.
name|process
operator|->
name|stdoutChannel
expr_stmt|;
name|sink
operator|=
operator|&
name|channel
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|sink
operator|==
operator|&
name|stdinChannel
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|source
operator|->
name|process
operator|==
name|this
operator|&&
name|source
operator|->
name|type
operator|==
name|Channel
operator|::
name|PipeSource
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|source
operator|->
name|pipe
index|[
literal|1
index|]
operator|!=
name|INVALID_Q_PIPE
operator|||
name|sink
operator|->
name|pipe
index|[
literal|0
index|]
operator|!=
name|INVALID_Q_PIPE
condition|)
block|{
comment|// already created, do nothing
return|return
literal|true
return|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|source
operator|->
name|pipe
index|[
literal|0
index|]
operator|==
name|INVALID_Q_PIPE
operator|&&
name|source
operator|->
name|pipe
index|[
literal|1
index|]
operator|==
name|INVALID_Q_PIPE
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|sink
operator|->
name|pipe
index|[
literal|0
index|]
operator|==
name|INVALID_Q_PIPE
operator|&&
name|sink
operator|->
name|pipe
index|[
literal|1
index|]
operator|==
name|INVALID_Q_PIPE
argument_list|)
expr_stmt|;
name|Q_PIPE
name|pipe
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
if|if
condition|(
name|qt_create_pipe
argument_list|(
name|pipe
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
name|sink
operator|->
name|pipe
index|[
literal|0
index|]
operator|=
name|pipe
index|[
literal|0
index|]
expr_stmt|;
name|source
operator|->
name|pipe
index|[
literal|1
index|]
operator|=
name|pipe
index|[
literal|1
index|]
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
end_function
begin_decl_stmt
name|QT_BEGIN_INCLUDE_NAMESPACE
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MACX
argument_list|)
include|#
directive|include
file|<crt_externs.h>
DECL|macro|environ
define|#
directive|define
name|environ
value|(*_NSGetEnviron())
else|#
directive|else
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_END_INCLUDE_NAMESPACE
DECL|function|systemEnvironment
name|QProcessEnvironment
name|QProcessEnvironment
operator|::
name|systemEnvironment
parameter_list|()
block|{
name|QProcessEnvironment
name|env
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_IOS
argument_list|)
specifier|const
name|char
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
operator|(
name|entry
operator|=
name|environ
index|[
name|count
index|]
operator|)
condition|;
operator|++
name|count
control|)
block|{
specifier|const
name|char
modifier|*
name|equal
init|=
name|strchr
argument_list|(
name|entry
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|equal
condition|)
continue|continue;
name|QByteArray
name|name
argument_list|(
name|entry
argument_list|,
name|equal
operator|-
name|entry
argument_list|)
decl_stmt|;
name|QByteArray
name|value
argument_list|(
name|equal
operator|+
literal|1
argument_list|)
decl_stmt|;
name|env
operator|.
name|d
operator|->
name|hash
operator|.
name|insert
argument_list|(
name|QProcessEnvironmentPrivate
operator|::
name|Key
argument_list|(
name|name
argument_list|)
argument_list|,
name|QProcessEnvironmentPrivate
operator|::
name|Value
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|env
return|;
block|}
end_function
begin_function
DECL|function|_q_dupEnvironment
specifier|static
name|char
modifier|*
modifier|*
name|_q_dupEnvironment
parameter_list|(
specifier|const
name|QProcessEnvironmentPrivate
operator|::
name|Hash
modifier|&
name|environment
parameter_list|,
name|int
modifier|*
name|envc
parameter_list|)
block|{
operator|*
name|envc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|environment
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|char
modifier|*
modifier|*
name|envp
init|=
operator|new
name|char
operator|*
index|[
name|environment
operator|.
name|count
argument_list|()
operator|+
literal|2
index|]
decl_stmt|;
name|envp
index|[
name|environment
operator|.
name|count
argument_list|()
index|]
operator|=
literal|0
expr_stmt|;
name|envp
index|[
name|environment
operator|.
name|count
argument_list|()
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|QProcessEnvironmentPrivate
operator|::
name|Hash
operator|::
name|ConstIterator
name|it
init|=
name|environment
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|QProcessEnvironmentPrivate
operator|::
name|Hash
operator|::
name|ConstIterator
name|end
init|=
name|environment
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|QByteArray
name|key
init|=
name|it
operator|.
name|key
argument_list|()
operator|.
name|key
decl_stmt|;
name|QByteArray
name|value
init|=
name|it
operator|.
name|value
argument_list|()
operator|.
name|bytes
argument_list|()
decl_stmt|;
name|key
operator|.
name|reserve
argument_list|(
name|key
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|+
name|value
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|key
operator|.
name|append
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|envp
index|[
operator|(
operator|*
name|envc
operator|)
operator|++
index|]
operator|=
operator|::
name|strdup
argument_list|(
name|key
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|envp
return|;
block|}
end_function
begin_function
DECL|function|startProcess
name|void
name|QProcessPrivate
operator|::
name|startProcess
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::startProcess()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Initialize pipes
if|if
condition|(
operator|!
name|openChannel
argument_list|(
name|stdinChannel
argument_list|)
operator|||
operator|!
name|openChannel
argument_list|(
name|stdoutChannel
argument_list|)
operator|||
operator|!
name|openChannel
argument_list|(
name|stderrChannel
argument_list|)
operator|||
name|qt_create_pipe
argument_list|(
name|childStartedPipe
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|setErrorAndEmit
argument_list|(
name|QProcess
operator|::
name|FailedToStart
argument_list|,
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|threadData
operator|->
name|hasEventDispatcher
argument_list|()
condition|)
block|{
name|startupSocketNotifier
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|startupSocketNotifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_startupNotification
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Start the process (platform dependent)
name|q
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|Starting
argument_list|)
expr_stmt|;
comment|// Create argument list with right number of elements, and set the final
comment|// one to 0.
name|char
modifier|*
modifier|*
name|argv
init|=
operator|new
name|char
operator|*
index|[
name|arguments
operator|.
name|count
argument_list|()
operator|+
literal|2
index|]
decl_stmt|;
name|argv
index|[
name|arguments
operator|.
name|count
argument_list|()
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|// Encode the program name.
name|QByteArray
name|encodedProgramName
init|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|program
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MAC
comment|// allow invoking of .app bundles on the Mac.
name|QFileInfo
name|fileInfo
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
name|encodedProgramName
operator|.
name|endsWith
argument_list|(
literal|".app"
argument_list|)
operator|&&
name|fileInfo
operator|.
name|isDir
argument_list|()
condition|)
block|{
name|QCFType
argument_list|<
name|CFURLRef
argument_list|>
name|url
init|=
name|CFURLCreateWithFileSystemPath
argument_list|(
literal|0
argument_list|,
name|QCFString
argument_list|(
name|fileInfo
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
argument_list|,
name|kCFURLPOSIXPathStyle
argument_list|,
literal|true
argument_list|)
decl_stmt|;
block|{
comment|// CFBundle is not reentrant, since CFBundleCreate might return a reference
comment|// to a cached bundle object. Protect the bundle calls with a mutex lock.
specifier|static
name|QBasicMutex
name|cfbundleMutex
decl_stmt|;
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|cfbundleMutex
argument_list|)
decl_stmt|;
name|QCFType
argument_list|<
name|CFBundleRef
argument_list|>
name|bundle
init|=
name|CFBundleCreate
argument_list|(
literal|0
argument_list|,
name|url
argument_list|)
decl_stmt|;
name|url
operator|=
name|CFBundleCopyExecutableURL
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|url
condition|)
block|{
name|QCFString
name|str
init|=
name|CFURLCopyFileSystemPath
argument_list|(
name|url
argument_list|,
name|kCFURLPOSIXPathStyle
argument_list|)
decl_stmt|;
name|encodedProgramName
operator|+=
literal|"/Contents/MacOS/"
operator|+
name|QCFString
operator|::
name|toQString
argument_list|(
name|str
argument_list|)
operator|.
name|toUtf8
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// Add the program name to the argument list.
name|char
modifier|*
name|dupProgramName
init|=
operator|::
name|strdup
argument_list|(
name|encodedProgramName
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|dupProgramName
expr_stmt|;
comment|// Add every argument to the list
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|::
name|strdup
argument_list|(
name|QFile
operator|::
name|encodeName
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
comment|// Duplicate the environment.
name|int
name|envc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|environment
operator|.
name|d
operator|.
name|constData
argument_list|()
condition|)
block|{
name|QProcessEnvironmentPrivate
operator|::
name|MutexLocker
name|locker
argument_list|(
name|environment
operator|.
name|d
argument_list|)
decl_stmt|;
name|envp
operator|=
name|_q_dupEnvironment
argument_list|(
name|environment
operator|.
name|d
operator|.
name|constData
argument_list|()
operator|->
name|hash
argument_list|,
operator|&
name|envc
argument_list|)
expr_stmt|;
block|}
comment|// Encode the working directory if it's non-empty, otherwise just pass 0.
specifier|const
name|char
modifier|*
name|workingDirPtr
init|=
literal|0
decl_stmt|;
name|QByteArray
name|encodedWorkingDirectory
decl_stmt|;
if|if
condition|(
operator|!
name|workingDirectory
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|encodedWorkingDirectory
operator|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|workingDirectory
argument_list|)
expr_stmt|;
name|workingDirPtr
operator|=
name|encodedWorkingDirectory
operator|.
name|constData
argument_list|()
expr_stmt|;
block|}
comment|// If the program does not specify a path, generate a list of possible
comment|// locations for the binary using the PATH environment variable.
name|char
modifier|*
modifier|*
name|path
init|=
literal|0
decl_stmt|;
name|int
name|pathc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|program
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
block|{
specifier|const
name|QString
name|pathEnv
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pathEnv
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
name|pathEntries
init|=
name|pathEnv
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pathEntries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|pathc
operator|=
name|pathEntries
operator|.
name|size
argument_list|()
expr_stmt|;
name|path
operator|=
operator|new
name|char
operator|*
index|[
name|pathc
operator|+
literal|1
index|]
expr_stmt|;
name|path
index|[
name|pathc
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|pathEntries
operator|.
name|size
argument_list|()
condition|;
operator|++
name|k
control|)
block|{
name|QByteArray
name|tmp
init|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|pathEntries
operator|.
name|at
argument_list|(
name|k
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|.
name|endsWith
argument_list|(
literal|'/'
argument_list|)
condition|)
name|tmp
operator|+=
literal|'/'
expr_stmt|;
name|tmp
operator|+=
name|encodedProgramName
expr_stmt|;
name|path
index|[
name|k
index|]
operator|=
operator|::
name|strdup
argument_list|(
name|tmp
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Start the process manager, and fork off the child process.
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_USE_SPAWN
argument_list|)
name|pid_t
name|childPid
decl_stmt|;
name|forkfd
operator|=
name|spawnChild
argument_list|(
operator|&
name|childPid
argument_list|,
name|workingDirPtr
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
name|Q_ASSUME
argument_list|(
name|forkfd
operator|!=
name|FFD_CHILD_PROCESS
argument_list|)
expr_stmt|;
else|#
directive|else
name|pid_t
name|childPid
decl_stmt|;
name|forkfd
operator|=
operator|::
name|forkfd
argument_list|(
name|FFD_CLOEXEC
argument_list|,
operator|&
name|childPid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|lastForkErrno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|forkfd
operator|!=
name|FFD_CHILD_PROCESS
condition|)
block|{
comment|// Parent process.
comment|// Clean up duplicated memory.
name|free
argument_list|(
name|dupProgramName
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|arguments
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|envc
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|envp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pathc
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|argv
expr_stmt|;
operator|delete
index|[]
name|envp
expr_stmt|;
operator|delete
index|[]
name|path
expr_stmt|;
block|}
comment|// On QNX, if spawnChild failed, childPid will be -1 but forkfd is still 0.
comment|// This is intentional because we only want to handle failure to fork()
comment|// here, which is a rare occurrence. Handling of the failure to start is
comment|// done elsewhere.
if|if
condition|(
name|forkfd
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Cleanup, report error and return
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"fork failed: %s"
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
name|lastForkErrno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|NotRunning
argument_list|)
expr_stmt|;
name|setErrorAndEmit
argument_list|(
name|QProcess
operator|::
name|FailedToStart
argument_list|,
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Resource error (fork failure): %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|qt_error_string
argument_list|(
name|lastForkErrno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Start the child.
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QPROCESS_USE_SPAWN
argument_list|)
if|if
condition|(
name|forkfd
operator|==
name|FFD_CHILD_PROCESS
condition|)
block|{
name|execChild
argument_list|(
name|workingDirPtr
argument_list|,
name|path
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
operator|::
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pid
operator|=
name|Q_PID
argument_list|(
name|childPid
argument_list|)
expr_stmt|;
comment|// parent
comment|// close the ends we don't use and make all pipes non-blocking
name|qt_safe_close
argument_list|(
name|childStartedPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|childStartedPipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|qt_safe_close
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
operator|::
name|fcntl
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|F_SETFL
argument_list|,
operator|::
name|fcntl
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|F_GETFL
argument_list|)
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|qt_safe_close
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|::
name|fcntl
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|F_SETFL
argument_list|,
operator|::
name|fcntl
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|F_GETFL
argument_list|)
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|qt_safe_close
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|::
name|fcntl
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|F_SETFL
argument_list|,
operator|::
name|fcntl
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|F_GETFL
argument_list|)
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|threadData
operator|->
name|eventDispatcher
condition|)
block|{
name|deathNotifier
operator|=
operator|new
name|QSocketNotifier
argument_list|(
name|forkfd
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|deathNotifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_processDied
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_USE_SPAWN
argument_list|)
end_if
begin_function
DECL|function|doSpawn
specifier|static
name|int
name|doSpawn
parameter_list|(
name|pid_t
modifier|*
name|ppid
parameter_list|,
specifier|const
name|posix_spawn_file_actions_t
modifier|*
name|file_actions
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
modifier|*
name|envp
parameter_list|,
specifier|const
name|char
modifier|*
name|workingDir
parameter_list|,
name|bool
name|spawn_detached
parameter_list|)
block|{
comment|// A multi threaded QNX Process can't fork so we call spawnfd() instead.
name|posix_spawnattr_t
name|attr
decl_stmt|;
name|posix_spawnattr_init
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_QNX
name|posix_spawnattr_setxflags
argument_list|(
operator|&
name|attr
argument_list|,
name|POSIX_SPAWN_SETSIGDEF
operator||
name|POSIX_SPAWN_SETPGROUP
operator||
operator|(
name|spawn_detached
operator|*
name|POSIX_SPAWN_NOZOMBIE
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|posix_spawnattr_setflags
argument_list|(
operator|&
name|attr
argument_list|,
name|POSIX_SPAWN_SETSIGDEF
operator||
name|POSIX_SPAWN_SETPGROUP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|posix_spawnattr_setpgroup
argument_list|(
operator|&
name|attr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sigset_t
name|sigdefault
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sigdefault
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sigdefault
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
comment|// reset the signal that we ignored
name|posix_spawnattr_setsigdefault
argument_list|(
operator|&
name|attr
argument_list|,
operator|&
name|sigdefault
argument_list|)
expr_stmt|;
comment|// enter the working directory
specifier|const
name|char
modifier|*
name|oldWorkingDir
init|=
literal|0
decl_stmt|;
name|char
name|buff
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|workingDir
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_QNX
comment|//we need to freeze everyone in order to avoid race conditions with //chdir().
if|if
condition|(
name|ThreadCtl
argument_list|(
name|_NTO_TCTL_THREADS_HOLD
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"ThreadCtl(): cannot hold threads: %s"
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|oldWorkingDir
operator|=
name|QT_GETCWD
argument_list|(
name|buff
argument_list|,
name|PATH_MAX
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|QT_CHDIR
argument_list|(
name|workingDir
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"ThreadCtl(): failed to chdir to %s"
argument_list|,
name|workingDir
argument_list|)
expr_stmt|;
block|}
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|spawn_detached
condition|)
block|{
name|fd
operator|=
operator|::
name|posix_spawn
argument_list|(
name|ppid
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|file_actions
argument_list|,
operator|&
name|attr
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|fd
operator|=
operator|::
name|posix_spawnp
argument_list|(
name|ppid
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|file_actions
argument_list|,
operator|&
name|attr
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// use spawnfd
name|fd
operator|=
operator|::
name|spawnfd
argument_list|(
name|FFD_CLOEXEC
operator||
name|FFD_NONBLOCK
argument_list|,
name|ppid
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|file_actions
argument_list|,
operator|&
name|attr
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|fd
operator|=
operator|::
name|spawnfd
argument_list|(
name|FFD_CLOEXEC
operator||
name|FFD_NONBLOCK
operator||
name|FFD_SPAWN_SEARCH_PATH
argument_list|,
name|ppid
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|file_actions
argument_list|,
operator|&
name|attr
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldWorkingDir
condition|)
block|{
if|if
condition|(
name|QT_CHDIR
argument_list|(
name|oldWorkingDir
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"ThreadCtl(): failed to chdir to %s"
argument_list|,
name|oldWorkingDir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_QNX
if|if
condition|(
name|ThreadCtl
argument_list|(
name|_NTO_TCTL_THREADS_CONT
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|qFatal
argument_list|(
literal|"ThreadCtl(): cannot resume threads: %s"
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|posix_spawnattr_destroy
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function
begin_function
DECL|function|spawnChild
name|pid_t
name|QProcessPrivate
operator|::
name|spawnChild
parameter_list|(
name|pid_t
modifier|*
name|ppid
parameter_list|,
specifier|const
name|char
modifier|*
name|workingDir
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
modifier|*
name|envp
parameter_list|)
block|{
comment|// posix_spawn causes all file descriptors with FD_CLOEXEC to be closed automatically;
comment|// we only need to add the actions for our own pipes
name|posix_spawn_file_actions_t
name|file_actions
decl_stmt|;
name|posix_spawn_file_actions_init
argument_list|(
operator|&
name|file_actions
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_QNX
specifier|static
specifier|const
name|bool
name|OS_QNX
init|=
literal|true
decl_stmt|;
else|#
directive|else
specifier|static
specifier|const
name|bool
name|OS_QNX
init|=
literal|false
decl_stmt|;
endif|#
directive|endif
name|int
name|fdmax
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|processChannelMode
operator|==
name|QProcess
operator|::
name|MergedChannels
condition|)
block|{
comment|// managed stderr == stdout
name|posix_spawn_file_actions_adddup2
argument_list|(
operator|&
name|file_actions
argument_list|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|OS_QNX
condition|)
name|fdmax
operator|=
name|qMax
argument_list|(
name|fdmax
argument_list|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|processChannelMode
operator|!=
name|QProcess
operator|::
name|ForwardedChannels
operator|&&
name|processChannelMode
operator|!=
name|QProcess
operator|::
name|ForwardedErrorChannel
condition|)
block|{
comment|// managed stderr
name|posix_spawn_file_actions_adddup2
argument_list|(
operator|&
name|file_actions
argument_list|,
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|OS_QNX
condition|)
name|fdmax
operator|=
name|qMax
argument_list|(
name|fdmax
argument_list|,
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|posix_spawn_file_actions_addclose
argument_list|(
operator|&
name|file_actions
argument_list|,
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|processChannelMode
operator|!=
name|QProcess
operator|::
name|ForwardedChannels
operator|&&
name|processChannelMode
operator|!=
name|QProcess
operator|::
name|ForwardedOutputChannel
condition|)
block|{
comment|// managed stdout
name|posix_spawn_file_actions_adddup2
argument_list|(
operator|&
name|file_actions
argument_list|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|OS_QNX
condition|)
name|fdmax
operator|=
name|qMax
argument_list|(
name|fdmax
argument_list|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|posix_spawn_file_actions_addclose
argument_list|(
operator|&
name|file_actions
argument_list|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inputChannelMode
operator|==
name|QProcess
operator|::
name|ManagedInputChannel
condition|)
block|{
name|posix_spawn_file_actions_adddup2
argument_list|(
operator|&
name|file_actions
argument_list|,
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|OS_QNX
condition|)
name|fdmax
operator|=
name|qMax
argument_list|(
name|fdmax
argument_list|,
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|posix_spawn_file_actions_addclose
argument_list|(
operator|&
name|file_actions
argument_list|,
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Workaround: QNX's spawn implementation will actually dup all FD values
comment|// LESS than fdmax - regardless of the FD_CLOEEXEC flag. So we need to add
comment|// those to the list of files to close, otherwise dup will fail when some
comment|// other thread closes the FD.
for|for
control|(
name|int
name|i
init|=
literal|3
init|;
name|i
operator|<=
name|fdmax
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|::
name|fcntl
argument_list|(
name|i
argument_list|,
name|F_GETFD
argument_list|)
operator|&
name|FD_CLOEXEC
condition|)
name|posix_spawn_file_actions_addclose
argument_list|(
operator|&
name|file_actions
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|int
name|retval
init|=
name|doSpawn
argument_list|(
name|ppid
argument_list|,
operator|&
name|file_actions
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|,
name|workingDir
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
name|QString
name|error
init|=
name|qt_error_string
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|qt_safe_write
argument_list|(
name|childStartedPipe
index|[
literal|1
index|]
argument_list|,
name|error
operator|.
name|data
argument_list|()
argument_list|,
name|error
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|childStartedPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|childStartedPipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|posix_spawn_file_actions_destroy
argument_list|(
operator|&
name|file_actions
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|execChild
name|void
name|QProcessPrivate
operator|::
name|execChild
parameter_list|(
specifier|const
name|char
modifier|*
name|workingDir
parameter_list|,
name|char
modifier|*
modifier|*
name|path
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
modifier|*
name|envp
parameter_list|)
block|{
operator|::
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|// reset the signal that we ignored
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
comment|// copy the stdin socket if asked to (without closing on exec)
if|if
condition|(
name|inputChannelMode
operator|!=
name|QProcess
operator|::
name|ForwardedInputChannel
condition|)
name|qt_safe_dup2
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
name|STDIN_FILENO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// copy the stdout and stderr if asked to
if|if
condition|(
name|processChannelMode
operator|!=
name|QProcess
operator|::
name|ForwardedChannels
condition|)
block|{
if|if
condition|(
name|processChannelMode
operator|!=
name|QProcess
operator|::
name|ForwardedOutputChannel
condition|)
name|qt_safe_dup2
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// merge stdout and stderr if asked to
if|if
condition|(
name|processChannelMode
operator|==
name|QProcess
operator|::
name|MergedChannels
condition|)
block|{
name|qt_safe_dup2
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|STDERR_FILENO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|processChannelMode
operator|!=
name|QProcess
operator|::
name|ForwardedErrorChannel
condition|)
block|{
name|qt_safe_dup2
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|STDERR_FILENO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|// make sure this fd is closed if execvp() succeeds
name|qt_safe_close
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// enter the working directory
if|if
condition|(
name|workingDir
operator|&&
name|QT_CHDIR
argument_list|(
name|workingDir
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|// failed, stop the process
goto|goto
name|report_errno
goto|;
block|}
comment|// this is a virtual call, and it base behavior is to do nothing.
name|q
operator|->
name|setupChildProcess
argument_list|()
expr_stmt|;
comment|// execute the process
if|if
condition|(
operator|!
name|envp
condition|)
block|{
name|qt_safe_execvp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|path
condition|)
block|{
name|char
modifier|*
modifier|*
name|arg
init|=
name|path
decl_stmt|;
while|while
condition|(
operator|*
name|arg
condition|)
block|{
name|argv
index|[
literal|0
index|]
operator|=
operator|*
name|arg
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"QProcessPrivate::execChild() searching / starting %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qt_safe_execve
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
operator|++
name|arg
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"QProcessPrivate::execChild() starting %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qt_safe_execve
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
block|}
block|}
comment|// notify failure
name|report_errno
label|:
name|QString
name|error
init|=
name|qt_error_string
argument_list|(
name|errno
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"QProcessPrivate::execChild() failed (%s), notifying parent process\n"
argument_list|,
name|qPrintable
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qt_safe_write
argument_list|(
name|childStartedPipe
index|[
literal|1
index|]
argument_list|,
name|error
operator|.
name|data
argument_list|()
argument_list|,
name|error
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|childStartedPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|childStartedPipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|processStarted
name|bool
name|QProcessPrivate
operator|::
name|processStarted
parameter_list|()
block|{
name|ushort
name|buf
index|[
name|errorBufferMax
index|]
decl_stmt|;
name|int
name|i
init|=
name|qt_safe_read
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|startupSocketNotifier
condition|)
block|{
name|startupSocketNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|startupSocketNotifier
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
name|startupSocketNotifier
operator|=
literal|0
expr_stmt|;
block|}
name|qt_safe_close
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|childStartedPipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::processStarted() == %s"
argument_list|,
name|i
operator|<=
literal|0
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// did we read an error message?
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|q_func
argument_list|()
operator|->
name|setErrorString
argument_list|(
name|QString
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|buf
argument_list|,
name|i
operator|/
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
operator|<=
literal|0
return|;
block|}
end_function
begin_function
DECL|function|bytesAvailableInChannel
name|qint64
name|QProcessPrivate
operator|::
name|bytesAvailableInChannel
parameter_list|(
specifier|const
name|Channel
modifier|*
name|channel
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|channel
operator|->
name|pipe
index|[
literal|0
index|]
operator|!=
name|INVALID_Q_PIPE
argument_list|)
expr_stmt|;
name|int
name|nbytes
init|=
literal|0
decl_stmt|;
name|qint64
name|available
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|::
name|ioctl
argument_list|(
name|channel
operator|->
name|pipe
index|[
literal|0
index|]
argument_list|,
name|FIONREAD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nbytes
argument_list|)
operator|>=
literal|0
condition|)
name|available
operator|=
operator|(
name|qint64
operator|)
name|nbytes
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::bytesAvailableInChannel(%d) == %lld"
argument_list|,
name|int
argument_list|(
name|channel
operator|-
operator|&
name|stdinChannel
argument_list|)
argument_list|,
name|available
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|available
return|;
block|}
end_function
begin_function
DECL|function|readFromChannel
name|qint64
name|QProcessPrivate
operator|::
name|readFromChannel
parameter_list|(
specifier|const
name|Channel
modifier|*
name|channel
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|channel
operator|->
name|pipe
index|[
literal|0
index|]
operator|!=
name|INVALID_Q_PIPE
argument_list|)
expr_stmt|;
name|qint64
name|bytesRead
init|=
name|qt_safe_read
argument_list|(
name|channel
operator|->
name|pipe
index|[
literal|0
index|]
argument_list|,
name|data
argument_list|,
name|maxlen
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|qDebug
argument_list|(
literal|"QProcessPrivate::readFromChannel(%d, %p \"%s\", %lld) == %lld"
argument_list|,
name|int
argument_list|(
name|channel
operator|-
operator|&
name|stdinChannel
argument_list|)
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|bytesRead
argument_list|,
literal|16
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|maxlen
argument_list|,
name|bytesRead
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bytesRead
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
return|return
operator|-
literal|2
return|;
return|return
name|bytesRead
return|;
block|}
end_function
begin_function
DECL|function|writeToStdin
name|qint64
name|QProcessPrivate
operator|::
name|writeToStdin
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|qint64
name|written
init|=
name|qt_safe_write_nosignal
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|data
argument_list|,
name|maxlen
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::writeToStdin(%p \"%s\", %lld) == %lld"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|,
literal|16
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|maxlen
argument_list|,
name|written
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|==
operator|-
literal|1
condition|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::writeToStdin(), failed to write (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// If the O_NONBLOCK flag is set and If some data can be written without blocking
comment|// the process, write() will transfer what it can and return the number of bytes written.
comment|// Otherwise, it will return -1 and set errno to EAGAIN
if|if
condition|(
name|written
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
name|written
operator|=
literal|0
expr_stmt|;
return|return
name|written
return|;
block|}
end_function
begin_function
DECL|function|terminateProcess
name|void
name|QProcessPrivate
operator|::
name|terminateProcess
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::killProcess()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
condition|)
operator|::
name|kill
argument_list|(
name|pid_t
argument_list|(
name|pid
argument_list|)
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|killProcess
name|void
name|QProcessPrivate
operator|::
name|killProcess
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::killProcess()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
condition|)
operator|::
name|kill
argument_list|(
name|pid_t
argument_list|(
name|pid
argument_list|)
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|waitForStarted
name|bool
name|QProcessPrivate
operator|::
name|waitForStarted
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::waitForStarted(%d) waiting for child to start (fd = %d)"
argument_list|,
name|msecs
argument_list|,
name|childStartedPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fd_set
name|fds
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|qt_select_msecs
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
literal|0
argument_list|,
name|msecs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|setError
argument_list|(
name|QProcess
operator|::
name|Timedout
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::waitForStarted(%d) == false (timed out)"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
name|bool
name|startedEmitted
init|=
name|_q_startupNotification
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::waitForStarted() == %s"
argument_list|,
name|startedEmitted
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|startedEmitted
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_BLACKBERRY
end_ifdef
begin_function
DECL|function|defaultNotifiers
name|QList
argument_list|<
name|QSocketNotifier
modifier|*
argument_list|>
name|QProcessPrivate
operator|::
name|defaultNotifiers
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QSocketNotifier
modifier|*
argument_list|>
name|notifiers
decl_stmt|;
name|notifiers
operator|<<
name|stdoutChannel
operator|.
name|notifier
operator|<<
name|stderrChannel
operator|.
name|notifier
operator|<<
name|stdinChannel
operator|.
name|notifier
expr_stmt|;
return|return
name|notifiers
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_OS_BLACKBERRY
end_comment
begin_function
DECL|function|waitForReadyRead
name|bool
name|QProcessPrivate
operator|::
name|waitForReadyRead
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::waitForReadyRead(%d)"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_BLACKBERRY
name|QList
argument_list|<
name|QSocketNotifier
modifier|*
argument_list|>
name|notifiers
init|=
name|defaultNotifiers
argument_list|()
decl_stmt|;
endif|#
directive|endif
forever|forever
block|{
name|fd_set
name|fdread
decl_stmt|;
name|fd_set
name|fdwrite
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdread
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
name|int
name|nfds
init|=
name|forkfd
decl_stmt|;
name|FD_SET
argument_list|(
name|forkfd
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|processState
operator|==
name|QProcess
operator|::
name|Starting
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stdinChannel
operator|.
name|buffer
operator|.
name|isEmpty
argument_list|()
operator|&&
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
name|int
name|timeout
init|=
name|qt_subtract_from_timeout
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_BLACKBERRY
name|int
name|ret
init|=
name|bb_select
argument_list|(
name|notifiers
argument_list|,
name|nfds
operator|+
literal|1
argument_list|,
operator|&
name|fdread
argument_list|,
operator|&
name|fdwrite
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|ret
init|=
name|qt_select_msecs
argument_list|(
name|nfds
operator|+
literal|1
argument_list|,
operator|&
name|fdread
argument_list|,
operator|&
name|fdwrite
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|setError
argument_list|(
name|QProcess
operator|::
name|Timedout
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|childStartedPipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|_q_startupNotification
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
name|bool
name|readyReadEmitted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
name|bool
name|canRead
init|=
name|_q_canReadStandardOutput
argument_list|()
decl_stmt|;
if|if
condition|(
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardOutput
operator|&&
name|canRead
condition|)
name|readyReadEmitted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
name|bool
name|canRead
init|=
name|_q_canReadStandardError
argument_list|()
decl_stmt|;
if|if
condition|(
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
operator|&&
name|canRead
condition|)
name|readyReadEmitted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|readyReadEmitted
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|fdwrite
argument_list|)
condition|)
name|_q_canWrite
argument_list|()
expr_stmt|;
if|if
condition|(
name|forkfd
operator|==
operator|-
literal|1
operator|||
name|FD_ISSET
argument_list|(
name|forkfd
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
if|if
condition|(
name|_q_processDied
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|waitForBytesWritten
name|bool
name|QProcessPrivate
operator|::
name|waitForBytesWritten
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::waitForBytesWritten(%d)"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_BLACKBERRY
name|QList
argument_list|<
name|QSocketNotifier
modifier|*
argument_list|>
name|notifiers
init|=
name|defaultNotifiers
argument_list|()
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|!
name|stdinChannel
operator|.
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fd_set
name|fdread
decl_stmt|;
name|fd_set
name|fdwrite
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdread
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
name|int
name|nfds
init|=
name|forkfd
decl_stmt|;
name|FD_SET
argument_list|(
name|forkfd
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|processState
operator|==
name|QProcess
operator|::
name|Starting
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stdinChannel
operator|.
name|buffer
operator|.
name|isEmpty
argument_list|()
operator|&&
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
name|int
name|timeout
init|=
name|qt_subtract_from_timeout
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_BLACKBERRY
name|int
name|ret
init|=
name|bb_select
argument_list|(
name|notifiers
argument_list|,
name|nfds
operator|+
literal|1
argument_list|,
operator|&
name|fdread
argument_list|,
operator|&
name|fdwrite
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|ret
init|=
name|qt_select_msecs
argument_list|(
name|nfds
operator|+
literal|1
argument_list|,
operator|&
name|fdread
argument_list|,
operator|&
name|fdwrite
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|setError
argument_list|(
name|QProcess
operator|::
name|Timedout
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|childStartedPipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|_q_startupNotification
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|fdwrite
argument_list|)
condition|)
return|return
name|_q_canWrite
argument_list|()
return|;
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
name|_q_canReadStandardOutput
argument_list|()
expr_stmt|;
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
name|_q_canReadStandardError
argument_list|()
expr_stmt|;
if|if
condition|(
name|forkfd
operator|==
operator|-
literal|1
operator|||
name|FD_ISSET
argument_list|(
name|forkfd
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
if|if
condition|(
name|_q_processDied
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|waitForFinished
name|bool
name|QProcessPrivate
operator|::
name|waitForFinished
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QProcessPrivate::waitForFinished(%d)"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_BLACKBERRY
name|QList
argument_list|<
name|QSocketNotifier
modifier|*
argument_list|>
name|notifiers
init|=
name|defaultNotifiers
argument_list|()
decl_stmt|;
endif|#
directive|endif
forever|forever
block|{
name|fd_set
name|fdread
decl_stmt|;
name|fd_set
name|fdwrite
decl_stmt|;
name|int
name|nfds
init|=
operator|-
literal|1
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdread
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|processState
operator|==
name|QProcess
operator|::
name|Starting
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
name|processState
operator|==
name|QProcess
operator|::
name|Running
operator|&&
name|forkfd
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|forkfd
argument_list|,
operator|&
name|fdread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stdinChannel
operator|.
name|buffer
operator|.
name|isEmpty
argument_list|()
operator|&&
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|add_fd
argument_list|(
name|nfds
argument_list|,
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
name|int
name|timeout
init|=
name|qt_subtract_from_timeout
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_BLACKBERRY
name|int
name|ret
init|=
name|bb_select
argument_list|(
name|notifiers
argument_list|,
name|nfds
operator|+
literal|1
argument_list|,
operator|&
name|fdread
argument_list|,
operator|&
name|fdwrite
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|ret
init|=
name|qt_select_msecs
argument_list|(
name|nfds
operator|+
literal|1
argument_list|,
operator|&
name|fdread
argument_list|,
operator|&
name|fdwrite
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|setError
argument_list|(
name|QProcess
operator|::
name|Timedout
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|childStartedPipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|childStartedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|_q_startupNotification
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|fdwrite
argument_list|)
condition|)
name|_q_canWrite
argument_list|()
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stdoutChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
name|_q_canReadStandardOutput
argument_list|()
expr_stmt|;
if|if
condition|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|stderrChannel
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
name|_q_canReadStandardError
argument_list|()
expr_stmt|;
if|if
condition|(
name|forkfd
operator|==
operator|-
literal|1
operator|||
name|FD_ISSET
argument_list|(
name|forkfd
argument_list|,
operator|&
name|fdread
argument_list|)
condition|)
block|{
if|if
condition|(
name|_q_processDied
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|waitForWrite
name|bool
name|QProcessPrivate
operator|::
name|waitForWrite
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|fd_set
name|fdwrite
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|fdwrite
argument_list|)
expr_stmt|;
return|return
name|qt_select_msecs
argument_list|(
name|stdinChannel
operator|.
name|pipe
index|[
literal|1
index|]
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|fdwrite
argument_list|,
name|msecs
operator|<
literal|0
condition|?
literal|0
else|:
name|msecs
argument_list|)
operator|==
literal|1
return|;
block|}
end_function
begin_function
DECL|function|findExitCode
name|void
name|QProcessPrivate
operator|::
name|findExitCode
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|waitForDeadChild
name|bool
name|QProcessPrivate
operator|::
name|waitForDeadChild
parameter_list|()
block|{
if|if
condition|(
name|forkfd
operator|==
operator|-
literal|1
condition|)
return|return
literal|true
return|;
comment|// child has already exited
comment|// read the process information from our fd
name|forkfd_info
name|info
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|forkfd_wait
argument_list|(
name|forkfd
argument_list|,
operator|&
name|info
argument_list|,
name|Q_NULLPTR
argument_list|)
argument_list|)
expr_stmt|;
name|exitCode
operator|=
name|info
operator|.
name|status
expr_stmt|;
name|crashed
operator|=
name|info
operator|.
name|code
operator|!=
name|CLD_EXITED
expr_stmt|;
operator|delete
name|deathNotifier
expr_stmt|;
name|deathNotifier
operator|=
literal|0
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|forkfd_close
argument_list|(
name|forkfd
argument_list|)
argument_list|)
expr_stmt|;
name|forkfd
operator|=
operator|-
literal|1
expr_stmt|;
comment|// Child is dead, don't try to kill it anymore
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QProcessPrivate::waitForDeadChild() dead with exitCode"
operator|<<
name|exitCode
operator|<<
literal|", crashed?"
operator|<<
name|crashed
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QPROCESS_USE_SPAWN
argument_list|)
end_if
begin_function
DECL|function|startDetached
name|bool
name|QProcessPrivate
operator|::
name|startDetached
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|,
specifier|const
name|QString
modifier|&
name|workingDirectory
parameter_list|,
name|qint64
modifier|*
name|pid
parameter_list|)
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|enc_args
decl_stmt|;
name|enc_args
operator|.
name|append
argument_list|(
name|QFile
operator|::
name|encodeName
argument_list|(
name|program
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|enc_args
operator|.
name|append
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|int
name|argc
init|=
name|enc_args
operator|.
name|size
argument_list|()
decl_stmt|;
name|QScopedArrayPointer
argument_list|<
name|char
modifier|*
argument_list|>
name|raw_argv
argument_list|(
operator|new
name|char
operator|*
index|[
name|argc
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|raw_argv
index|[
name|i
index|]
operator|=
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|enc_args
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|raw_argv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
name|char
modifier|*
modifier|*
name|envp
init|=
literal|0
decl_stmt|;
comment|// inherit environment
comment|// Encode the working directory if it's non-empty, otherwise just pass 0.
specifier|const
name|char
modifier|*
name|workingDirPtr
init|=
literal|0
decl_stmt|;
name|QByteArray
name|encodedWorkingDirectory
decl_stmt|;
if|if
condition|(
operator|!
name|workingDirectory
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|encodedWorkingDirectory
operator|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|workingDirectory
argument_list|)
expr_stmt|;
name|workingDirPtr
operator|=
name|encodedWorkingDirectory
operator|.
name|constData
argument_list|()
expr_stmt|;
block|}
name|pid_t
name|childPid
decl_stmt|;
name|int
name|retval
init|=
name|doSpawn
argument_list|(
operator|&
name|childPid
argument_list|,
name|NULL
argument_list|,
name|raw_argv
operator|.
name|data
argument_list|()
argument_list|,
name|envp
argument_list|,
name|workingDirPtr
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|pid
operator|&&
name|retval
operator|!=
operator|-
literal|1
condition|)
operator|*
name|pid
operator|=
name|childPid
expr_stmt|;
return|return
name|retval
operator|!=
operator|-
literal|1
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|startDetached
name|bool
name|QProcessPrivate
operator|::
name|startDetached
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|,
specifier|const
name|QString
modifier|&
name|workingDirectory
parameter_list|,
name|qint64
modifier|*
name|pid
parameter_list|)
block|{
name|QByteArray
name|encodedWorkingDirectory
init|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|workingDirectory
argument_list|)
decl_stmt|;
comment|// To catch the startup of the child
name|int
name|startedPipe
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|qt_safe_pipe
argument_list|(
name|startedPipe
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
comment|// To communicate the pid of the child
name|int
name|pidPipe
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|qt_safe_pipe
argument_list|(
name|pidPipe
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|qt_safe_close
argument_list|(
name|startedPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|startedPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|pid_t
name|childPid
init|=
name|fork
argument_list|()
decl_stmt|;
if|if
condition|(
name|childPid
operator|==
literal|0
condition|)
block|{
name|struct
name|sigaction
name|noaction
decl_stmt|;
name|memset
argument_list|(
operator|&
name|noaction
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|noaction
argument_list|)
argument_list|)
expr_stmt|;
name|noaction
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
operator|::
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|noaction
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|::
name|setsid
argument_list|()
expr_stmt|;
name|qt_safe_close
argument_list|(
name|startedPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|pidPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pid_t
name|doubleForkPid
init|=
name|fork
argument_list|()
decl_stmt|;
if|if
condition|(
name|doubleForkPid
operator|==
literal|0
condition|)
block|{
name|qt_safe_close
argument_list|(
name|pidPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encodedWorkingDirectory
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|QT_CHDIR
argument_list|(
name|encodedWorkingDirectory
operator|.
name|constData
argument_list|()
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"QProcessPrivate::startDetached: failed to chdir to %s"
argument_list|,
name|encodedWorkingDirectory
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|char
modifier|*
modifier|*
name|argv
init|=
operator|new
name|char
operator|*
index|[
name|arguments
operator|.
name|size
argument_list|()
operator|+
literal|2
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|::
name|strdup
argument_list|(
name|QFile
operator|::
name|encodeName
argument_list|(
name|arguments
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|argv
index|[
name|arguments
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|program
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
block|{
specifier|const
name|QString
name|path
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
name|pathEntries
init|=
name|path
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|pathEntries
operator|.
name|size
argument_list|()
condition|;
operator|++
name|k
control|)
block|{
name|QByteArray
name|tmp
init|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|pathEntries
operator|.
name|at
argument_list|(
name|k
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|.
name|endsWith
argument_list|(
literal|'/'
argument_list|)
condition|)
name|tmp
operator|+=
literal|'/'
expr_stmt|;
name|tmp
operator|+=
name|QFile
operator|::
name|encodeName
argument_list|(
name|program
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|tmp
operator|.
name|data
argument_list|()
expr_stmt|;
name|qt_safe_execv
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|QByteArray
name|tmp
init|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|tmp
operator|.
name|data
argument_list|()
expr_stmt|;
name|qt_safe_execv
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
name|struct
name|sigaction
name|noaction
decl_stmt|;
name|memset
argument_list|(
operator|&
name|noaction
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|noaction
argument_list|)
argument_list|)
expr_stmt|;
name|noaction
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
operator|::
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|noaction
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// '\1' means execv failed
name|char
name|c
init|=
literal|'\1'
decl_stmt|;
name|qt_safe_write
argument_list|(
name|startedPipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|startedPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|::
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|doubleForkPid
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|sigaction
name|noaction
decl_stmt|;
name|memset
argument_list|(
operator|&
name|noaction
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|noaction
argument_list|)
argument_list|)
expr_stmt|;
name|noaction
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
operator|::
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|noaction
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// '\2' means internal error
name|char
name|c
init|=
literal|'\2'
decl_stmt|;
name|qt_safe_write
argument_list|(
name|startedPipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|qt_safe_close
argument_list|(
name|startedPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|qt_safe_write
argument_list|(
name|pidPipe
index|[
literal|1
index|]
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|doubleForkPid
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|QT_CHDIR
argument_list|(
literal|"/"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"QProcessPrivate::startDetached: failed to chdir to /"
argument_list|)
expr_stmt|;
operator|::
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|qt_safe_close
argument_list|(
name|startedPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|pidPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|childPid
operator|==
operator|-
literal|1
condition|)
block|{
name|qt_safe_close
argument_list|(
name|startedPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|pidPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|char
name|reply
init|=
literal|'\0'
decl_stmt|;
name|int
name|startResult
init|=
name|qt_safe_read
argument_list|(
name|startedPipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|reply
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
name|qt_safe_close
argument_list|(
name|startedPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|qt_safe_waitpid
argument_list|(
name|childPid
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bool
name|success
init|=
operator|(
name|startResult
operator|!=
operator|-
literal|1
operator|&&
name|reply
operator|==
literal|'\0'
operator|)
decl_stmt|;
if|if
condition|(
name|success
operator|&&
name|pid
condition|)
block|{
name|pid_t
name|actualPid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|qt_safe_read
argument_list|(
name|pidPipe
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|actualPid
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
condition|)
block|{
operator|*
name|pid
operator|=
name|actualPid
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pid
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|qt_safe_close
argument_list|(
name|pidPipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PROCESS
end_comment
end_unit
