begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Copyright (C) 2014 Intel Corporation. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_DEBUG
end_ifdef
begin_undef
DECL|macro|QT_NO_DEBUG
undef|#
directive|undef
name|QT_NO_DEBUG
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|qDebug
end_ifdef
begin_undef
DECL|macro|qDebug
undef|#
directive|undef
name|qDebug
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qmetaobject.h"
end_include
begin_include
include|#
directive|include
file|<private/qtextstream_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qtools_p.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_using
using|using
name|QtMiscUtils
operator|::
name|toHexUpper
using|;
end_using
begin_using
using|using
name|QtMiscUtils
operator|::
name|fromHex
using|;
end_using
begin_comment
comment|// This file is needed to force compilation of QDebug into the kernel library.
end_comment
begin_comment
comment|/*!     \class QDebug     \inmodule QtCore     \ingroup shared      \brief The QDebug class provides an output stream for debugging information.      QDebug is used whenever the developer needs to write out debugging or tracing     information to a device, file, string or console.      \section1 Basic Use      In the common case, it is useful to call the qDebug() function to obtain a     default QDebug object to use for writing debugging information.      \snippet qdebug/qdebugsnippet.cpp 1      This constructs a QDebug object using the constructor that accepts a QtMsgType     value of QtDebugMsg. Similarly, the qWarning(), qCritical() and qFatal()     functions also return QDebug objects for the corresponding message types.      The class also provides several constructors for other situations, including     a constructor that accepts a QFile or any other QIODevice subclass that is     used to write debugging information to files and other devices. The constructor     that accepts a QString is used to write to a string for display or serialization.      \section1 Formatting Options      QDebug formats output so that it's easily readable. It automatically adds spaces     between arguments, and adds quotes around QString, QByteArray, QChar arguments.      You can tweak these options through the space(), nospace() and quote(), noquote()     methods. Furthermore, \l{QTextStream manipulators} can be piped into a QDebug     stream.      QDebugStateSaver limits changes to the formatting to the current scope.     resetFormat() resets the options to the default ones.      \section1 Writing Custom Types to a Stream      Many standard types can be written to QDebug objects, and Qt provides support for     most Qt value types. To add support for custom types, you need to implement a     streaming operator, as in the following example:      \snippet qdebug/qdebugsnippet.cpp 0      This is described in the \l{Debugging Techniques} and     \l{Creating Custom Qt Types#Making the Type Printable}{Creating Custom Qt Types}     documents. */
end_comment
begin_comment
comment|/*!     \fn QDebug::QDebug(QIODevice *device)      Constructs a debug stream that writes to the given \a device. */
end_comment
begin_comment
comment|/*!     \fn QDebug::QDebug(QString *string)      Constructs a debug stream that writes to the given \a string. */
end_comment
begin_comment
comment|/*!     \fn QDebug::QDebug(QtMsgType type)      Constructs a debug stream that writes to the handler for the message type specified by \a type. */
end_comment
begin_comment
comment|/*!     \fn QDebug::QDebug(const QDebug&other)      Constructs a copy of the \a other debug stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator=(const QDebug&other)      Assigns the \a other debug stream to this stream and returns a reference to     this stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug::~QDebug()      Flushes any pending data to be written and destroys the debug stream. */
end_comment
begin_comment
comment|// Has been defined in the header / inlined before Qt 5.4
end_comment
begin_destructor
DECL|function|~QDebug
name|QDebug
operator|::
name|~
name|QDebug
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|--
name|stream
operator|->
name|ref
condition|)
block|{
if|if
condition|(
name|stream
operator|->
name|space
operator|&&
name|stream
operator|->
name|buffer
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
condition|)
name|stream
operator|->
name|buffer
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|message_output
condition|)
block|{
name|qt_message_output
argument_list|(
name|stream
operator|->
name|type
argument_list|,
name|stream
operator|->
name|context
argument_list|,
name|stream
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
operator|delete
name|stream
expr_stmt|;
block|}
block|}
end_destructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|putUcs4
name|void
name|QDebug
operator|::
name|putUcs4
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
name|maybeQuote
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucs4
operator|<
literal|0x20
condition|)
block|{
name|stream
operator|->
name|ts
operator|<<
name|hex
operator|<<
literal|"\\x"
operator|<<
name|ucs4
operator|<<
name|reset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ucs4
operator|<
literal|0x80
condition|)
block|{
name|stream
operator|->
name|ts
operator|<<
name|char
argument_list|(
name|ucs4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stream
operator|->
name|ts
operator|<<
name|hex
operator|<<
name|qSetPadChar
argument_list|(
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucs4
operator|<
literal|0x10000
condition|)
name|stream
operator|->
name|ts
operator|<<
name|qSetFieldWidth
argument_list|(
literal|4
argument_list|)
operator|<<
literal|"\\u"
expr_stmt|;
else|else
name|stream
operator|->
name|ts
operator|<<
name|qSetFieldWidth
argument_list|(
literal|8
argument_list|)
operator|<<
literal|"\\U"
expr_stmt|;
name|stream
operator|->
name|ts
operator|<<
name|ucs4
operator|<<
name|reset
expr_stmt|;
block|}
name|maybeQuote
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// These two functions return true if the character should be printed by QDebug.
end_comment
begin_comment
comment|// For QByteArray, this is technically identical to US-ASCII isprint();
end_comment
begin_comment
comment|// for QString, we use QChar::isPrint, which requires a full UCS-4 decode.
end_comment
begin_function
DECL|function|isPrintable
specifier|static
specifier|inline
name|bool
name|isPrintable
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
return|return
name|QChar
operator|::
name|isPrint
argument_list|(
name|ucs4
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|isPrintable
specifier|static
specifier|inline
name|bool
name|isPrintable
parameter_list|(
name|ushort
name|uc
parameter_list|)
block|{
return|return
name|QChar
operator|::
name|isPrint
argument_list|(
name|uc
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|isPrintable
specifier|static
specifier|inline
name|bool
name|isPrintable
parameter_list|(
name|uchar
name|c
parameter_list|)
block|{
return|return
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<
literal|0x7f
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|Char
parameter_list|>
DECL|function|putEscapedString
specifier|static
specifier|inline
name|void
name|putEscapedString
parameter_list|(
name|QTextStreamPrivate
modifier|*
name|d
parameter_list|,
specifier|const
name|Char
modifier|*
name|begin
parameter_list|,
name|int
name|length
parameter_list|,
name|bool
name|isUnicode
init|=
literal|true
parameter_list|)
block|{
name|QChar
name|quote
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|)
decl_stmt|;
name|d
operator|->
name|write
argument_list|(
operator|&
name|quote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bool
name|lastWasHexEscape
init|=
literal|false
decl_stmt|;
specifier|const
name|Char
modifier|*
name|end
init|=
name|begin
operator|+
name|length
decl_stmt|;
for|for
control|(
specifier|const
name|Char
modifier|*
name|p
init|=
name|begin
init|;
name|p
operator|!=
name|end
condition|;
operator|++
name|p
control|)
block|{
comment|// check if we need to insert "" to break an hex escape sequence
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|lastWasHexEscape
argument_list|)
condition|)
block|{
if|if
condition|(
name|fromHex
argument_list|(
operator|*
name|p
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// yes, insert it
name|QChar
name|quotes
index|[]
init|=
block|{
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
block|,
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
block|}
decl_stmt|;
name|d
operator|->
name|write
argument_list|(
name|quotes
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|lastWasHexEscape
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
sizeof|sizeof
argument_list|(
name|Char
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
condition|)
block|{
comment|// Surrogate characters are category Cs (Other_Surrogate), so isPrintable = false for them
name|int
name|runLength
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|+
name|runLength
operator|!=
name|end
operator|&&
name|isPrintable
argument_list|(
name|p
index|[
name|runLength
index|]
argument_list|)
operator|&&
name|p
index|[
name|runLength
index|]
operator|!=
literal|'\\'
operator|&&
name|p
index|[
name|runLength
index|]
operator|!=
literal|'"'
condition|)
operator|++
name|runLength
expr_stmt|;
if|if
condition|(
name|runLength
condition|)
block|{
name|d
operator|->
name|write
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|p
argument_list|)
argument_list|,
name|runLength
argument_list|)
expr_stmt|;
name|p
operator|+=
name|runLength
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|isPrintable
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'\\'
operator|&&
operator|*
name|p
operator|!=
literal|'"'
condition|)
block|{
name|QChar
name|c
init|=
name|QLatin1Char
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
name|d
operator|->
name|write
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// print as an escape sequence (maybe, see below for surrogate pairs)
name|int
name|buflen
init|=
literal|2
decl_stmt|;
name|ushort
name|buf
index|[
sizeof|sizeof
expr|"\\U12345678"
operator|-
literal|1
expr|]
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
name|buf
index|[
literal|1
index|]
operator|=
operator|*
name|p
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|buf
index|[
literal|1
index|]
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|buf
index|[
literal|1
index|]
operator|=
literal|'f'
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|buf
index|[
literal|1
index|]
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|buf
index|[
literal|1
index|]
operator|=
literal|'r'
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|buf
index|[
literal|1
index|]
operator|=
literal|'t'
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|isUnicode
condition|)
block|{
comment|// print as hex escape
name|buf
index|[
literal|1
index|]
operator|=
literal|'x'
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|toHexUpper
argument_list|(
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|toHexUpper
argument_list|(
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|buflen
operator|=
literal|4
expr_stmt|;
name|lastWasHexEscape
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
name|end
operator|&&
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|// properly-paired surrogates
name|uint
name|ucs4
init|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
operator|*
name|p
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|isPrintable
argument_list|(
name|ucs4
argument_list|)
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|buflen
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|1
index|]
operator|=
literal|'U'
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'0'
expr_stmt|;
comment|// toHexUpper(ucs4>> 32);
name|buf
index|[
literal|3
index|]
operator|=
literal|'0'
expr_stmt|;
comment|// toHexUpper(ucs4>> 28);
name|buf
index|[
literal|4
index|]
operator|=
name|toHexUpper
argument_list|(
name|ucs4
operator|>>
literal|20
argument_list|)
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|toHexUpper
argument_list|(
name|ucs4
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
name|toHexUpper
argument_list|(
name|ucs4
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
name|toHexUpper
argument_list|(
name|ucs4
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
name|toHexUpper
argument_list|(
name|ucs4
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|buf
index|[
literal|9
index|]
operator|=
name|toHexUpper
argument_list|(
name|ucs4
argument_list|)
expr_stmt|;
name|buflen
operator|=
literal|10
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
break|break;
block|}
comment|// improperly-paired surrogates, fall through
block|}
name|buf
index|[
literal|1
index|]
operator|=
literal|'u'
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|toHexUpper
argument_list|(
name|ushort
argument_list|(
operator|*
name|p
argument_list|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|toHexUpper
argument_list|(
name|ushort
argument_list|(
operator|*
name|p
argument_list|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|toHexUpper
argument_list|(
operator|*
name|p
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|toHexUpper
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|buflen
operator|=
literal|6
expr_stmt|;
block|}
name|d
operator|->
name|write
argument_list|(
cast|reinterpret_cast
argument_list|<
name|QChar
operator|*
argument_list|>
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|write
argument_list|(
operator|&
name|quote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Duplicated from QtTest::toPrettyUnicode(). */
end_comment
begin_function
DECL|function|putString
name|void
name|QDebug
operator|::
name|putString
parameter_list|(
specifier|const
name|QChar
modifier|*
name|begin
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|testFlag
argument_list|(
name|Stream
operator|::
name|NoQuotes
argument_list|)
condition|)
block|{
comment|// no quotes, write the string directly too (no pretty-printing)
comment|// this respects the QTextStream state, though
name|stream
operator|->
name|ts
operator|.
name|d_ptr
operator|->
name|putString
argument_list|(
name|begin
argument_list|,
name|int
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we'll reset the QTextStream formatting mechanisms, so save the state
name|QDebugStateSaver
name|saver
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|stream
operator|->
name|ts
operator|.
name|d_ptr
operator|->
name|params
operator|.
name|reset
argument_list|()
expr_stmt|;
name|putEscapedString
argument_list|(
name|stream
operator|->
name|ts
operator|.
name|d_ptr
operator|.
name|data
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|begin
argument_list|)
argument_list|,
name|int
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     Duplicated from QtTest::toPrettyCString(). */
end_comment
begin_function
DECL|function|putByteArray
name|void
name|QDebug
operator|::
name|putByteArray
parameter_list|(
specifier|const
name|char
modifier|*
name|begin
parameter_list|,
name|size_t
name|length
parameter_list|,
name|Latin1Content
name|content
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|testFlag
argument_list|(
name|Stream
operator|::
name|NoQuotes
argument_list|)
condition|)
block|{
comment|// no quotes, write the string directly too (no pretty-printing)
comment|// this respects the QTextStream state, though
name|QString
name|string
init|=
name|content
operator|==
name|ContainsLatin1
condition|?
name|QString
operator|::
name|fromLatin1
argument_list|(
name|begin
argument_list|,
name|int
argument_list|(
name|length
argument_list|)
argument_list|)
else|:
name|QString
operator|::
name|fromUtf8
argument_list|(
name|begin
argument_list|,
name|int
argument_list|(
name|length
argument_list|)
argument_list|)
decl_stmt|;
name|stream
operator|->
name|ts
operator|.
name|d_ptr
operator|->
name|putString
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we'll reset the QTextStream formatting mechanisms, so save the state
name|QDebugStateSaver
name|saver
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|stream
operator|->
name|ts
operator|.
name|d_ptr
operator|->
name|params
operator|.
name|reset
argument_list|()
expr_stmt|;
name|putEscapedString
argument_list|(
name|stream
operator|->
name|ts
operator|.
name|d_ptr
operator|.
name|data
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|begin
argument_list|)
argument_list|,
name|int
argument_list|(
name|length
argument_list|)
argument_list|,
name|content
operator|==
name|ContainsLatin1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QDebug::swap(QDebug&other)     \since 5.0      Swaps this debug stream instance with \a other. This function is     very fast and never fails. */
end_comment
begin_comment
comment|/*!     Resets the stream formatting options, bringing it back to its original constructed state.      \sa space(), quote()     \since 5.4 */
end_comment
begin_function
DECL|function|resetFormat
name|QDebug
modifier|&
name|QDebug
operator|::
name|resetFormat
parameter_list|()
block|{
name|stream
operator|->
name|ts
operator|.
name|reset
argument_list|()
expr_stmt|;
name|stream
operator|->
name|space
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|context
operator|.
name|version
operator|>
literal|1
condition|)
name|stream
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|setVerbosity
argument_list|(
name|Stream
operator|::
name|defaultVerbosity
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDebug&QDebug::space()      Writes a space character to the debug stream and returns a reference to     the stream.      The stream remembers that automatic insertion of spaces is     enabled for future writes.      \sa nospace(), maybeSpace() */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::nospace()      Disables automatic insertion of spaces and returns a reference to the stream.      \sa space(), maybeSpace() */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::maybeSpace()      Writes a space character to the debug stream, depending on the current     setting for automatic insertion of spaces, and returns a reference to the stream.      \sa space(), nospace() */
end_comment
begin_comment
comment|/*!     \fn bool QDebug::autoInsertSpaces() const      Returns \c true if this QDebug instance will automatically insert spaces     between writes.      \since 5.0      \sa QDebugStateSaver */
end_comment
begin_comment
comment|/*!     \fn void QDebug::setAutoInsertSpaces(bool b)      Enables automatic insertion of spaces between writes if \a b is true; otherwise     automatic insertion of spaces is disabled.      \since 5.0      \sa QDebugStateSaver */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::quote()     \since 5.4      Enables automatic insertion of quotation characters around QChar, QString and QByteArray     contents and returns a reference to the stream.      Quoting is enabled by default.      \sa noquote(), maybeQuote() */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::noquote()     \since 5.4      Disables automatic insertion of quotation characters around QChar, QString and QByteArray     contents and returns a reference to the stream.      When quoting is disabled, these types are printed without quotation     characters and without escaping of non-printable characters.      \sa quote(), maybeQuote() */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::maybeQuote(char c)     \since 5.4      Writes a character \a c to the debug stream, depending on the     current setting for automatic insertion of quotes, and returns a reference to the stream.      The default character is a double quote \c{"}.      \sa quote(), noquote() */
end_comment
begin_comment
comment|/*!     \fn int QDebug::verbosity() const     \since 5.6      Returns the verbosity of the debug stream.      Streaming operators can check the value to decide whether     verbose output is desired and print more information depending on the     level. Higher values indicate that more information is desired.      The allowed range is from 0 to 7. The default value is 2.      \sa setVerbosity() */
end_comment
begin_comment
comment|/*!     \fn void QDebug::setVerbosity(int verbosityLevel)     \since 5.6      Sets the verbosity of the stream to \a verbosityLevel.      The allowed range is from 0 to 7. The default value is 2.      \sa verbosity() */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(QChar t)      Writes the character, \a t, to the stream and returns a reference to the     stream. Normally, QDebug prints control characters and non-US-ASCII     characters as their C escape sequences or their Unicode value (\\u1234). To     print non-printable characters without transformation, enable the noquote()     functionality, but note that some QDebug backends may not be 8-bit clean     and may not be able to represent \c t. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(bool t)      Writes the boolean value, \a t, to the stream and returns a reference to the     stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(char t)      Writes the character, \a t, to the stream and returns a reference to the     stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(signed short i)      Writes the signed short integer, \a i, to the stream and returns a reference     to the stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(unsigned short i)      Writes then unsigned short integer, \a i, to the stream and returns a     reference to the stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(signed int i)      Writes the signed integer, \a i, to the stream and returns a reference     to the stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(unsigned int i)      Writes then unsigned integer, \a i, to the stream and returns a reference to     the stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(signed long l)      Writes the signed long integer, \a l, to the stream and returns a reference     to the stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(unsigned long l)      Writes then unsigned long integer, \a l, to the stream and returns a reference     to the stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(qint64 i)      Writes the signed 64-bit integer, \a i, to the stream and returns a reference     to the stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(quint64 i)      Writes then unsigned 64-bit integer, \a i, to the stream and returns a     reference to the stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(float f)      Writes the 32-bit floating point number, \a f, to the stream and returns a     reference to the stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(double f)      Writes the 64-bit floating point number, \a f, to the stream and returns a     reference to the stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(const char *s)      Writes the '\\0'-terminated string, \a s, to the stream and returns a     reference to the stream. The string is never quoted nor transformed to the     output, but note that some QDebug backends might not be 8-bit clean. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(const QString&s)      Writes the string, \a s, to the stream and returns a reference to the     stream. Normally, QDebug prints the string inside quotes and transforms     non-printable characters to their Unicode values (\\u1234).      To print non-printable characters without transformation, enable the     noquote() functionality. Note that some QDebug backends might not be 8-bit     clean.      Output examples:     \code         QString s;          s = "a";         qDebug().noquote()<< s;    // prints: a         qDebug()<< s;              // prints: "a"          s = "\"a\r\n\"";         qDebug()<< s;              // prints: "\"a\r\n\""          s = "\033";                 // escape character         qDebug()<< s;              // prints: "\u001B"          s = "\u00AD";               // SOFT HYPHEN         qDebug()<< s;              // prints: "\u00AD"          s = "\u00E1";               // LATIN SMALL LETTER A WITH ACUTE         qDebug()<< s;              // prints: "Ã¡"          s = "a\u0301";              // "a" followed by COMBINING ACUTE ACCENT         qDebug()<< s;              // prints: "aÌ";          s = "\u0430\u0301";         // CYRILLIC SMALL LETTER A followed by COMBINING ACUTE ACCENT         qDebug()<< s;              // prints: "Ð°Ì"     \endcode */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(const QStringRef&s)      Writes the string, \a s, to the stream and returns a reference to the     stream. Normally, QDebug prints the string inside quotes and transforms     non-printable characters to their Unicode values (\\u1234).      To print non-printable characters without transformation, enable the     noquote() functionality. Note that some QDebug backends might not be 8-bit     clean.      See the QString overload for examples. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(QLatin1String s)      Writes the string, \a s, to the stream and returns a reference to the     stream. Normally, QDebug prints the string inside quotes and transforms     non-printable characters to their Unicode values (\\u1234).      To print non-printable characters without transformation, enable the     noquote() functionality. Note that some QDebug backends might not be 8-bit     clean.      See the QString overload for examples. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(const QByteArray&b)      Writes the byte array, \a b, to the stream and returns a reference to the     stream. Normally, QDebug prints the array inside quotes and transforms     control or non-US-ASCII characters to their C escape sequences (\\xAB). This     way, the output is always 7-bit clean and the string can be copied from the     output and pasted back into C++ sources, if necessary.      To print non-printable characters without transformation, enable the     noquote() functionality. Note that some QDebug backends might not be 8-bit     clean.      Output examples:     \code         QByteArray ba;          ba = "a";         qDebug().noquote()<< ba;    // prints: a         qDebug()<< ba;              // prints: "a"          ba = "\"a\r\n\"";         qDebug()<< ba;              // prints: "\"a\r\n\""          ba = "\033";                 // escape character         qDebug()<< ba;              // prints: "\x1B"          ba = "\xC3\xA1";         qDebug()<< ba;              // prints: "\xC3\xA1"          ba = QByteArray("a\0b", 3);         qDebug()<< ba               // prints: "\a\x00""b"     \endcode      Note how QDebug needed to close and reopen the string in the way C and C++     languages concatenate string literals so that the letter 'b' is not     interpreted as part of the previous hexadecimal escape sequence. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(const void *p)      Writes a pointer, \a p, to the stream and returns a reference to the stream. */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(QTextStreamFunction f)     \internal */
end_comment
begin_comment
comment|/*!     \fn QDebug&QDebug::operator<<(QTextStreamManipulator m)     \internal */
end_comment
begin_comment
comment|/*!     \fn QDebug operator<<(QDebug stream, const QList<T>&list)     \relates QDebug      Writes the contents of \a list to \a stream. \c T needs to     support streaming into QDebug. */
end_comment
begin_comment
comment|/*!     \fn QDebug operator<<(QDebug stream, const std::list<T, Alloc>&list)     \relates QDebug     \since 5.7      Writes the contents of \a list to \a stream. \c T needs to     support streaming into QDebug. */
end_comment
begin_comment
comment|/*!     \fn QDebug operator<<(QDebug stream, const QVector<T>&vector)     \relates QDebug      Writes the contents of \a vector to \a stream. \c T needs to     support streaming into QDebug. */
end_comment
begin_comment
comment|/*!     \fn QDebug operator<<(QDebug stream, const std::vector<T, Alloc>&vector)     \relates QDebug     \since 5.7      Writes the contents of \a vector to \a stream. \c T needs to     support streaming into QDebug. */
end_comment
begin_comment
comment|/*!     \fn QDebug operator<<(QDebug stream, const QSet<T>&set)     \relates QDebug      Writes the contents of \a set to \a stream. \c T needs to     support streaming into QDebug. */
end_comment
begin_comment
comment|/*!     \fn QDebug operator<<(QDebug stream, const QMap<Key, T>&map)     \relates QDebug      Writes the contents of \a map to \a stream. Both \c Key and     \c T need to support streaming into QDebug. */
end_comment
begin_comment
comment|/*!     \fn QDebug operator<<(QDebug stream, const std::map<Key, T, Compare, Alloc>&map)     \relates QDebug     \since 5.7      Writes the contents of \a map to \a stream. Both \c Key and     \c T need to support streaming into QDebug. */
end_comment
begin_comment
comment|/*!     \fn QDebug operator<<(QDebug stream, const std::multimap<Key, T, Compare, Alloc>&map)     \relates QDebug     \since 5.7      Writes the contents of \a map to \a stream. Both \c Key and     \c T need to support streaming into QDebug. */
end_comment
begin_comment
comment|/*!     \fn QDebug operator<<(QDebug stream, const QHash<Key, T>&hash)     \relates QDebug      Writes the contents of \a hash to \a stream. Both \c Key and     \c T need to support streaming into QDebug. */
end_comment
begin_comment
comment|/*!     \fn QDebug operator<<(QDebug stream, const QPair<T1, T2>&pair)     \relates QDebug      Writes the contents of \a pair to \a stream. Both \c T1 and     \c T2 need to support streaming into QDebug. */
end_comment
begin_comment
comment|/*!     \fn QDebug operator<<(QDebug stream, const QFlags<T>&flag)     \relates QDebug     \since 4.7      Writes \a flag to \a stream. */
end_comment
begin_comment
comment|/*!     \class QDebugStateSaver     \inmodule QtCore     \brief Convenience class for custom QDebug operators      Saves the settings used by QDebug, and restores them upon destruction,     then calls \l {QDebug::maybeSpace()}{maybeSpace()}, to separate arguments with a space if     \l {QDebug::autoInsertSpaces()}{autoInsertSpaces()} was true at the time of constructing the QDebugStateSaver.      The automatic insertion of spaces between writes is one of the settings     that QDebugStateSaver stores for the duration of the current block.      The settings of the internal QTextStream are also saved and restored,     so that using<< hex in a QDebug operator doesn't affect other QDebug     operators.      \since 5.1 */
end_comment
begin_class
DECL|class|QDebugStateSaverPrivate
class|class
name|QDebugStateSaverPrivate
block|{
public|public:
DECL|function|QDebugStateSaverPrivate
name|QDebugStateSaverPrivate
parameter_list|(
name|QDebug
modifier|&
name|dbg
parameter_list|)
member_init_list|:
name|m_dbg
argument_list|(
name|dbg
argument_list|)
member_init_list|,
name|m_spaces
argument_list|(
name|dbg
operator|.
name|autoInsertSpaces
argument_list|()
argument_list|)
member_init_list|,
name|m_flags
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_streamParams
argument_list|(
name|dbg
operator|.
name|stream
operator|->
name|ts
operator|.
name|d_ptr
operator|->
name|params
argument_list|)
block|{
if|if
condition|(
name|m_dbg
operator|.
name|stream
operator|->
name|context
operator|.
name|version
operator|>
literal|1
condition|)
name|m_flags
operator|=
name|m_dbg
operator|.
name|stream
operator|->
name|flags
expr_stmt|;
block|}
DECL|function|restoreState
name|void
name|restoreState
parameter_list|()
block|{
specifier|const
name|bool
name|currentSpaces
init|=
name|m_dbg
operator|.
name|autoInsertSpaces
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentSpaces
operator|&&
operator|!
name|m_spaces
condition|)
if|if
condition|(
name|m_dbg
operator|.
name|stream
operator|->
name|buffer
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
condition|)
name|m_dbg
operator|.
name|stream
operator|->
name|buffer
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|m_dbg
operator|.
name|setAutoInsertSpaces
argument_list|(
name|m_spaces
argument_list|)
expr_stmt|;
name|m_dbg
operator|.
name|stream
operator|->
name|ts
operator|.
name|d_ptr
operator|->
name|params
operator|=
name|m_streamParams
expr_stmt|;
if|if
condition|(
name|m_dbg
operator|.
name|stream
operator|->
name|context
operator|.
name|version
operator|>
literal|1
condition|)
name|m_dbg
operator|.
name|stream
operator|->
name|flags
operator|=
name|m_flags
expr_stmt|;
if|if
condition|(
operator|!
name|currentSpaces
operator|&&
name|m_spaces
condition|)
name|m_dbg
operator|.
name|stream
operator|->
name|ts
operator|<<
literal|' '
expr_stmt|;
block|}
DECL|member|m_dbg
name|QDebug
modifier|&
name|m_dbg
decl_stmt|;
comment|// QDebug state
DECL|member|m_spaces
specifier|const
name|bool
name|m_spaces
decl_stmt|;
DECL|member|m_flags
name|int
name|m_flags
decl_stmt|;
comment|// QTextStream state
DECL|member|m_streamParams
specifier|const
name|QTextStreamPrivate
operator|::
name|Params
name|m_streamParams
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Creates a QDebugStateSaver instance, which saves the settings     currently used by \a dbg.      \sa QDebug::setAutoInsertSpaces(), QDebug::autoInsertSpaces() */
end_comment
begin_constructor
DECL|function|QDebugStateSaver
name|QDebugStateSaver
operator|::
name|QDebugStateSaver
parameter_list|(
name|QDebug
modifier|&
name|dbg
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QDebugStateSaverPrivate
argument_list|(
name|dbg
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys a QDebugStateSaver instance, which restores the settings     used when the QDebugStateSaver instance was created.      \sa QDebug::setAutoInsertSpaces(), QDebug::autoInsertSpaces() */
end_comment
begin_destructor
DECL|function|~QDebugStateSaver
name|QDebugStateSaver
operator|::
name|~
name|QDebugStateSaver
parameter_list|()
block|{
name|d
operator|->
name|restoreState
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|qt_QMetaEnum_debugOperator
name|QDebug
name|qt_QMetaEnum_debugOperator
parameter_list|(
name|QDebug
modifier|&
name|dbg
parameter_list|,
name|int
name|value
parameter_list|,
specifier|const
name|QMetaObject
modifier|*
name|meta
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|QDebugStateSaver
name|saver
argument_list|(
name|dbg
argument_list|)
decl_stmt|;
name|QMetaEnum
name|me
init|=
name|meta
operator|->
name|enumerator
argument_list|(
name|meta
operator|->
name|indexOfEnumerator
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
init|=
name|me
operator|.
name|valueToKey
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
name|meta
operator|->
name|className
argument_list|()
operator|<<
literal|"::"
operator|<<
name|name
operator|<<
literal|'('
expr_stmt|;
if|if
condition|(
name|key
condition|)
name|dbg
operator|<<
name|key
expr_stmt|;
else|else
name|dbg
operator|<<
name|value
expr_stmt|;
name|dbg
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_function
DECL|function|qt_QMetaEnum_flagDebugOperator
name|QDebug
name|qt_QMetaEnum_flagDebugOperator
parameter_list|(
name|QDebug
modifier|&
name|debug
parameter_list|,
name|quint64
name|value
parameter_list|,
specifier|const
name|QMetaObject
modifier|*
name|meta
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|QDebugStateSaver
name|saver
argument_list|(
name|debug
argument_list|)
decl_stmt|;
name|debug
operator|.
name|resetFormat
argument_list|()
expr_stmt|;
name|debug
operator|.
name|noquote
argument_list|()
expr_stmt|;
name|debug
operator|.
name|nospace
argument_list|()
expr_stmt|;
name|debug
operator|<<
literal|"QFlags<"
expr_stmt|;
specifier|const
name|QMetaEnum
name|me
init|=
name|meta
operator|->
name|enumerator
argument_list|(
name|meta
operator|->
name|indexOfEnumerator
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
specifier|const
name|char
modifier|*
name|scope
init|=
name|me
operator|.
name|scope
argument_list|()
condition|)
name|debug
operator|<<
name|scope
operator|<<
literal|"::"
expr_stmt|;
name|debug
operator|<<
name|me
operator|.
name|name
argument_list|()
operator|<<
literal|">("
operator|<<
name|me
operator|.
name|valueToKeys
argument_list|(
name|value
argument_list|)
operator|<<
literal|')'
expr_stmt|;
return|return
name|debug
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !QT_NO_QOBJECT
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
