begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 David Faure<faure+bluesystems@kde.org> ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia. For licensing terms and ** conditions see http://qt.digia.com/licensing. For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights. These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qlockfile.h"
end_include
begin_include
include|#
directive|include
file|"qlockfile_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qthread.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qelapsedtimer.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdatetime.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QLockFile     \inmodule QtCore     \brief The QLockFile class provides locking between processes using a file.     \since 5.1      A lock file can be used to prevent multiple processes from accessing concurrently     the same resource. For instance, a configuration file on disk, or a socket, a port,     a region of shared memory...      Serialization is only guaranteed if all processes that access the shared resource     use QLockFile, with the same file path.      QLockFile supports two use cases:     to protect a resource for a short-term operation (e.g. verifying if a configuration     file has changed before saving new settings), and for long-lived protection of a     resource (e.g. a document opened by a user in an editor) for an indefinite amount of time.      When protecting for a short-term operation, it is acceptable to call lock() and wait     until any running operation finishes.     When protecting a resource over a long time, however, the application should always     call setStaleLockTime(0) and then tryLock() with a short timeout, in order to     warn the user that the resource is locked.      If the process holding the lock crashes, the lock file stays on disk and can prevent     any other process from accessing the shared resource, ever. For this reason, QLockFile     tries to detect such a "stale" lock file, based on the process ID written into the file,     and (in case that process ID got reused meanwhile), on the last modification time of     the lock file (30s by default, for the use case of a short-lived operation).     If the lock file is found to be stale, it will be deleted.      For the use case of protecting a resource over a long time, you should therefore call     setStaleLockTime(0), and when tryLock() returns LockFailedError, inform the user     that the document is locked, possibly using getLockInfo() for more details. */
end_comment
begin_comment
comment|/*!     \enum QLockFile::LockError      This enum describes the result of the last call to lock() or tryLock().      \value NoError The lock was acquired successfully.     \value LockFailedError The lock could not be acquired because another process holds it.     \value PermissionError The lock file could not be created, for lack of permissions                            in the parent directory.     \value UnknownError Another error happened, for instance a full partition                         prevented writing out the lock file. */
end_comment
begin_comment
comment|/*!     Constructs a new lock file object.     The object is created in an unlocked state.     When calling lock() or tryLock(), a lock file named \a fileName will be created,     if it doesn't already exist.      \sa lock(), unlock() */
end_comment
begin_constructor
DECL|function|QLockFile
name|QLockFile
operator|::
name|QLockFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QLockFilePrivate
argument_list|(
name|fileName
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the lock file object.     If the lock was acquired, this will release the lock, by deleting the lock file. */
end_comment
begin_destructor
DECL|function|~QLockFile
name|QLockFile
operator|::
name|~
name|QLockFile
parameter_list|()
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Sets \a staleLockTime to be the time in milliseconds after which     a lock file is considered stale.     The default value is 30000, i.e. 30 seconds.     If your application typically keeps the file locked for more than 30 seconds     (for instance while saving megabytes of data for 2 minutes), you should set     a bigger value using setStaleLockTime().      The value of \a staleLockTime is used by lock() and tryLock() in order     to determine when an existing lock file is considered stale, i.e. left over     by a crashed process. This is useful for the case where the PID got reused     meanwhile, so the only way to detect a stale lock file is by the fact that     it has been around for a long time.      \sa staleLockTime() */
end_comment
begin_function
DECL|function|setStaleLockTime
name|void
name|QLockFile
operator|::
name|setStaleLockTime
parameter_list|(
name|int
name|staleLockTime
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLockFile
argument_list|)
expr_stmt|;
name|d
operator|->
name|staleLockTime
operator|=
name|staleLockTime
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the time in milliseconds after which     a lock file is considered stale.      \sa setStaleLockTime() */
end_comment
begin_function
DECL|function|staleLockTime
name|int
name|QLockFile
operator|::
name|staleLockTime
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLockFile
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|staleLockTime
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the lock was acquired by this QLockFile instance,     otherwise returns \c false.      \sa lock(), unlock(), tryLock() */
end_comment
begin_function
DECL|function|isLocked
name|bool
name|QLockFile
operator|::
name|isLocked
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLockFile
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|isLocked
return|;
block|}
end_function
begin_comment
comment|/*!     Creates the lock file.      If another process (or another thread) has created the lock file already,     this function will block until that process (or thread) releases it.      Calling this function multiple times on the same lock from the same     thread without unlocking first is not allowed. This function will     \e dead-lock when the file is locked recursively.      Returns \c true if the lock was acquired, false if it could not be acquired     due to an unrecoverable error, such as no permissions in the parent directory.      \sa unlock(), tryLock() */
end_comment
begin_function
DECL|function|lock
name|bool
name|QLockFile
operator|::
name|lock
parameter_list|()
block|{
return|return
name|tryLock
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Attempts to create the lock file. This function returns \c true if the     lock was obtained; otherwise it returns \c false. If another process (or     another thread) has created the lock file already, this function will     wait for at most \a timeout milliseconds for the lock file to become     available.      Note: Passing a negative number as the \a timeout is equivalent to     calling lock(), i.e. this function will wait forever until the lock     file can be locked if \a timeout is negative.      If the lock was obtained, it must be released with unlock()     before another process (or thread) can successfully lock it.      Calling this function multiple times on the same lock from the same     thread without unlocking first is not allowed, this function will     \e always return false when attempting to lock the file recursively.      \sa lock(), unlock() */
end_comment
begin_function
DECL|function|tryLock
name|bool
name|QLockFile
operator|::
name|tryLock
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLockFile
argument_list|)
expr_stmt|;
name|QElapsedTimer
name|timer
decl_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
name|timer
operator|.
name|start
argument_list|()
expr_stmt|;
name|int
name|sleepTime
init|=
literal|100
decl_stmt|;
forever|forever
block|{
name|d
operator|->
name|lockError
operator|=
name|d
operator|->
name|tryLock_sys
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|lockError
condition|)
block|{
case|case
name|NoError
case|:
name|d
operator|->
name|isLocked
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
case|case
name|PermissionError
case|:
case|case
name|UnknownError
case|:
return|return
literal|false
return|;
case|case
name|LockFailedError
case|:
if|if
condition|(
operator|!
name|d
operator|->
name|isLocked
operator|&&
name|d
operator|->
name|isApparentlyStale
argument_list|()
condition|)
block|{
comment|// Stale lock from another thread/process
comment|// Ensure two processes don't remove it at the same time
name|QLockFile
name|rmlock
argument_list|(
name|d
operator|->
name|fileName
operator|+
name|QStringLiteral
argument_list|(
literal|".rmlock"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rmlock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|isApparentlyStale
argument_list|()
operator|&&
name|d
operator|->
name|removeStaleLock
argument_list|()
condition|)
continue|continue;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
operator|||
operator|(
name|timeout
operator|>
literal|0
operator|&&
name|timer
operator|.
name|hasExpired
argument_list|(
name|timeout
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
name|QThread
operator|::
name|msleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleepTime
operator|<
literal|5
operator|*
literal|1000
condition|)
name|sleepTime
operator|*=
literal|2
expr_stmt|;
block|}
comment|// not reached
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QLockFile::unlock()     Releases the lock, by deleting the lock file.      Calling unlock() without locking the file first, does nothing.      \sa lock(), tryLock() */
end_comment
begin_comment
comment|/*!     Retrieves information about the current owner of the lock file.      If tryLock() returns \c false, and error() returns LockFailedError,     this function can be called to find out more information about the existing     lock file:     \list     \li the PID of the application (returned in \a pid)     \li the \a hostname it's running on (useful in case of networked filesystems),     \li the name of the application which created it (returned in \a appname),     \endlist      Note that tryLock() automatically deleted the file if there is no     running application with this PID, so LockFailedError can only happen if there is     an application with this PID (it could be unrelated though).      This can be used to inform users about the existing lock file and give them     the choice to delete it. After removing the file using removeStaleLockFile(),     the application can call tryLock() again.      This function returns \c true if the information could be successfully retrieved, false     if the lock file doesn't exist or doesn't contain the expected data.     This can happen if the lock file was deleted between the time where tryLock() failed     and the call to this function. Simply call tryLock() again if this happens. */
end_comment
begin_function
DECL|function|getLockInfo
name|bool
name|QLockFile
operator|::
name|getLockInfo
parameter_list|(
name|qint64
modifier|*
name|pid
parameter_list|,
name|QString
modifier|*
name|hostname
parameter_list|,
name|QString
modifier|*
name|appname
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLockFile
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|getLockInfo
argument_list|(
name|pid
argument_list|,
name|hostname
argument_list|,
name|appname
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getLockInfo
name|bool
name|QLockFilePrivate
operator|::
name|getLockInfo
parameter_list|(
name|qint64
modifier|*
name|pid
parameter_list|,
name|QString
modifier|*
name|hostname
parameter_list|,
name|QString
modifier|*
name|appname
parameter_list|)
specifier|const
block|{
name|QFile
name|reader
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reader
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
return|return
literal|false
return|;
name|QByteArray
name|pidLine
init|=
name|reader
operator|.
name|readLine
argument_list|()
decl_stmt|;
name|pidLine
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|QByteArray
name|appNameLine
init|=
name|reader
operator|.
name|readLine
argument_list|()
decl_stmt|;
name|appNameLine
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|QByteArray
name|hostNameLine
init|=
name|reader
operator|.
name|readLine
argument_list|()
decl_stmt|;
name|hostNameLine
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pidLine
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|qint64
name|thePid
init|=
name|pidLine
operator|.
name|toLongLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|pid
condition|)
operator|*
name|pid
operator|=
name|thePid
expr_stmt|;
if|if
condition|(
name|appname
condition|)
operator|*
name|appname
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|appNameLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
condition|)
operator|*
name|hostname
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|hostNameLine
argument_list|)
expr_stmt|;
return|return
name|thePid
operator|>
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Attempts to forcefully remove an existing lock file.      Calling this is not recommended when protecting a short-lived operation: QLockFile     already takes care of removing lock files after they are older than staleLockTime().      This method should only be called when protecting a resource for a long time, i.e.     with staleLockTime(0), and after tryLock() returned LockFailedError, and the user     agreed on removing the lock file.      Returns \c true on success, false if the lock file couldn't be removed. This happens     on Windows, when the application owning the lock is still running. */
end_comment
begin_function
DECL|function|removeStaleLockFile
name|bool
name|QLockFile
operator|::
name|removeStaleLockFile
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLockFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isLocked
condition|)
block|{
name|qWarning
argument_list|(
literal|"removeStaleLockFile can only be called when not holding the lock"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|removeStaleLock
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the lock file error status.      If tryLock() returns \c false, this function can be called to find out     the reason why the locking failed. */
end_comment
begin_function
DECL|function|error
name|QLockFile
operator|::
name|LockError
name|QLockFile
operator|::
name|error
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLockFile
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|lockError
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
