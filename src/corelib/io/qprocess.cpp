begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QPROCESS_DEBUG
end_comment
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_if
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
end_if
begin_include
include|#
directive|include
file|<qstring.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*     Returns a human readable representation of the first \a len     characters in \a data. */
DECL|function|qt_prettyDebug
specifier|static
name|QByteArray
name|qt_prettyDebug
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|maxSize
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
condition|)
return|return
literal|"(null)"
return|;
name|QByteArray
name|out
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
operator|&&
name|i
operator|<
name|maxSize
condition|;
operator|++
name|i
control|)
block|{
name|char
name|c
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|out
operator|+=
name|c
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|out
operator|+=
literal|"\\n"
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|out
operator|+=
literal|"\\r"
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|out
operator|+=
literal|"\\t"
expr_stmt|;
break|break;
default|default:
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
name|qsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"\\%3o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|out
operator|+=
name|QByteArray
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|<
name|maxSize
condition|)
name|out
operator|+=
literal|"..."
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
name|QT_END_NAMESPACE
endif|#
directive|endif
include|#
directive|include
file|"qprocess.h"
include|#
directive|include
file|"qprocess_p.h"
include|#
directive|include
file|<qbytearray.h>
include|#
directive|include
file|<qelapsedtimer.h>
include|#
directive|include
file|<qcoreapplication.h>
include|#
directive|include
file|<qsocketnotifier.h>
include|#
directive|include
file|<qtimer.h>
ifdef|#
directive|ifdef
name|Q_OS_WIN
include|#
directive|include
file|<qwineventnotifier.h>
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_PROCESS
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QProcessEnvironment     \inmodule QtCore      \brief The QProcessEnvironment class holds the environment variables that     can be passed to a program.      \ingroup io     \ingroup misc     \ingroup shared     \mainclass     \reentrant     \since 4.6      A process's environment is composed of a set of key=value pairs known as     environment variables. The QProcessEnvironment class wraps that concept     and allows easy manipulation of those variables. It's meant to be used     along with QProcess, to set the environment for child processes. It     cannot be used to change the current process's environment.      The environment of the calling process can be obtained using     QProcessEnvironment::systemEnvironment().      On Unix systems, the variable names are case-sensitive. For that reason,     this class will not touch the names of the variables. Note as well that     Unix environment allows both variable names and contents to contain arbitrary     binary data (except for the NUL character), but this is not supported by     QProcessEnvironment. This class only supports names and values that are     encodable by the current locale settings (see QTextCodec::codecForLocale).      On Windows, the variable names are case-insensitive. Therefore,     QProcessEnvironment will always uppercase the names and do case-insensitive     comparisons.      On Windows CE, the concept of environment does not exist. This class will     keep the values set for compatibility with other platforms, but the values     set will have no effect on the processes being created.      \sa QProcess, QProcess::systemEnvironment(), QProcess::setProcessEnvironment() */
DECL|function|toList
name|QStringList
name|QProcessEnvironmentPrivate
operator|::
name|toList
parameter_list|()
specifier|const
block|{
name|QStringList
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|hash
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Hash
operator|::
name|ConstIterator
name|it
init|=
name|hash
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|hash
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|QString
name|data
init|=
name|nameToString
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|value
init|=
name|valueToString
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
name|data
operator|.
name|reserve
argument_list|(
name|data
operator|.
name|length
argument_list|()
operator|+
name|value
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|data
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|append
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|result
operator|<<
name|data
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|fromList
name|QProcessEnvironment
name|QProcessEnvironmentPrivate
operator|::
name|fromList
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|list
parameter_list|)
block|{
name|QProcessEnvironment
name|env
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|it
init|=
name|list
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|list
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|int
name|pos
init|=
name|it
operator|->
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|1
condition|)
continue|continue;
name|QString
name|value
init|=
name|it
operator|->
name|mid
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
decl_stmt|;
name|QString
name|name
init|=
operator|*
name|it
decl_stmt|;
name|name
operator|.
name|truncate
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|env
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|env
return|;
block|}
end_function
begin_function
DECL|function|keys
name|QStringList
name|QProcessEnvironmentPrivate
operator|::
name|keys
parameter_list|()
specifier|const
block|{
name|QStringList
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|hash
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Hash
operator|::
name|ConstIterator
name|it
init|=
name|hash
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|hash
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|result
operator|<<
name|nameToString
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|insert
name|void
name|QProcessEnvironmentPrivate
operator|::
name|insert
parameter_list|(
specifier|const
name|QProcessEnvironmentPrivate
modifier|&
name|other
parameter_list|)
block|{
name|Hash
operator|::
name|ConstIterator
name|it
init|=
name|other
operator|.
name|hash
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|other
operator|.
name|hash
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|hash
operator|.
name|insert
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|QHash
argument_list|<
name|QString
argument_list|,
name|Key
argument_list|>
operator|::
name|ConstIterator
name|nit
init|=
name|other
operator|.
name|nameMap
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|nend
init|=
name|other
operator|.
name|nameMap
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|nit
operator|!=
name|nend
condition|;
operator|++
name|nit
control|)
name|nameMap
operator|.
name|insert
argument_list|(
name|nit
operator|.
name|key
argument_list|()
argument_list|,
name|nit
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Creates a new QProcessEnvironment object. This constructor creates an     empty environment. If set on a QProcess, this will cause the current     environment variables to be removed. */
end_comment
begin_constructor
DECL|function|QProcessEnvironment
name|QProcessEnvironment
operator|::
name|QProcessEnvironment
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Frees the resources associated with this QProcessEnvironment object. */
end_comment
begin_destructor
DECL|function|~QProcessEnvironment
name|QProcessEnvironment
operator|::
name|~
name|QProcessEnvironment
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Creates a QProcessEnvironment object that is a copy of \a other. */
end_comment
begin_constructor
DECL|function|QProcessEnvironment
name|QProcessEnvironment
operator|::
name|QProcessEnvironment
parameter_list|(
specifier|const
name|QProcessEnvironment
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Copies the contents of the \a other QProcessEnvironment object into this     one. */
end_comment
begin_function
DECL|function|operator =
name|QProcessEnvironment
modifier|&
name|QProcessEnvironment
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QProcessEnvironment
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QProcessEnvironment::swap(QProcessEnvironment&other)     \since 5.0      Swaps this process environment instance with \a other. This     function is very fast and never fails. */
end_comment
begin_comment
comment|/*!     \fn bool QProcessEnvironment::operator !=(const QProcessEnvironment&other) const      Returns true if this and the \a other QProcessEnvironment objects are different.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns true if this and the \a other QProcessEnvironment objects are equal.      Two QProcessEnvironment objects are considered equal if they have the same     set of key=value pairs. The comparison of keys is done case-sensitive on     platforms where the environment is case-sensitive.      \sa operator!=(), contains() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QProcessEnvironment
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QProcessEnvironment
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|==
name|other
operator|.
name|d
operator|||
operator|(
name|d
operator|&&
name|other
operator|.
name|d
operator|&&
name|d
operator|->
name|hash
operator|==
name|other
operator|.
name|d
operator|->
name|hash
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this QProcessEnvironment object is empty: that is     there are no key=value pairs set.      \sa clear(), systemEnvironment(), insert() */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QProcessEnvironment
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|hash
operator|.
name|isEmpty
argument_list|()
else|:
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Removes all key=value pairs from this QProcessEnvironment object, making     it empty.      \sa isEmpty(), systemEnvironment() */
end_comment
begin_function
DECL|function|clear
name|void
name|QProcessEnvironment
operator|::
name|clear
parameter_list|()
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|hash
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Unix: Don't clear d->nameMap, as the environment is likely to be
comment|// re-populated with the same keys again.
block|}
end_function
begin_comment
comment|/*!     Returns true if the environment variable of name \a name is found in     this QProcessEnvironment object.      On Windows, variable names are case-insensitive, so the key is converted     to uppercase before searching. On other systems, names are case-sensitive     so no trasformation is applied.      \sa insert(), value() */
end_comment
begin_function
DECL|function|contains
name|bool
name|QProcessEnvironment
operator|::
name|contains
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|hash
operator|.
name|contains
argument_list|(
name|d
operator|->
name|prepareName
argument_list|(
name|name
argument_list|)
argument_list|)
else|:
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts the environment variable of name \a name and contents \a value     into this QProcessEnvironment object. If that variable already existed,     it is replaced by the new value.      On Windows, variable names are case-insensitive, so this function always     uppercases the variable name before inserting. On other systems, names     are case-sensitive, so no transformation is applied.      On most systems, inserting a variable with no contents will have the     same effect for applications as if the variable had not been set at all.     However, to guarantee that there are no incompatibilities, to remove a     variable, please use the remove() function.      \sa contains(), remove(), value() */
end_comment
begin_function
DECL|function|insert
name|void
name|QProcessEnvironment
operator|::
name|insert
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
comment|// d detaches from null
name|d
operator|->
name|hash
operator|.
name|insert
argument_list|(
name|d
operator|->
name|prepareName
argument_list|(
name|name
argument_list|)
argument_list|,
name|d
operator|->
name|prepareValue
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes the environment variable identified by \a name from this     QProcessEnvironment object. If that variable did not exist before,     nothing happens.      On Windows, variable names are case-insensitive, so the key is converted     to uppercase before searching. On other systems, names are case-sensitive     so no trasformation is applied.      \sa contains(), insert(), value() */
end_comment
begin_function
DECL|function|remove
name|void
name|QProcessEnvironment
operator|::
name|remove
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|hash
operator|.
name|remove
argument_list|(
name|d
operator|->
name|prepareName
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Searches this QProcessEnvironment object for a variable identified by     \a name and returns its value. If the variable is not found in this object,     then \a defaultValue is returned instead.      On Windows, variable names are case-insensitive, so the key is converted     to uppercase before searching. On other systems, names are case-sensitive     so no trasformation is applied.      \sa contains(), insert(), remove() */
end_comment
begin_function
DECL|function|value
name|QString
name|QProcessEnvironment
operator|::
name|value
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|defaultValue
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|defaultValue
return|;
name|QProcessEnvironmentPrivate
operator|::
name|Hash
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|hash
operator|.
name|constFind
argument_list|(
name|d
operator|->
name|prepareName
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|d
operator|->
name|hash
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|defaultValue
return|;
return|return
name|d
operator|->
name|valueToString
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Converts this QProcessEnvironment object into a list of strings, one for     each environment variable that is set. The environment variable's name     and its value are separated by an equal character ('=').      The QStringList contents returned by this function are suitable for use     with the QProcess::setEnvironment function. However, it is recommended     to use QProcess::setProcessEnvironment instead since that will avoid     unnecessary copying of the data.      \sa systemEnvironment(), QProcess::systemEnvironment(), QProcess::environment(),         QProcess::setEnvironment() */
end_comment
begin_function
DECL|function|toStringList
name|QStringList
name|QProcessEnvironment
operator|::
name|toStringList
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|toList
argument_list|()
else|:
name|QStringList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns a list containing all the variable names in this QProcessEnvironment     object. */
end_comment
begin_function
DECL|function|keys
name|QStringList
name|QProcessEnvironment
operator|::
name|keys
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|keys
argument_list|()
else|:
name|QStringList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.8      Inserts the contents of \a e in this QProcessEnvironment object. Variables in     this object that also exist in \a e will be overwritten. */
end_comment
begin_function
DECL|function|insert
name|void
name|QProcessEnvironment
operator|::
name|insert
parameter_list|(
specifier|const
name|QProcessEnvironment
modifier|&
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|e
operator|.
name|d
condition|)
return|return;
comment|// d detaches from null
name|d
operator|->
name|insert
argument_list|(
operator|*
name|e
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clear
name|void
name|QProcessPrivate
operator|::
name|Channel
operator|::
name|clear
parameter_list|()
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PipeSource
case|:
name|Q_ASSERT
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|process
operator|->
name|stdinChannel
operator|.
name|type
operator|=
name|Normal
expr_stmt|;
name|process
operator|->
name|stdinChannel
operator|.
name|process
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PipeSink
case|:
name|Q_ASSERT
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|process
operator|->
name|stdoutChannel
operator|.
name|type
operator|=
name|Normal
expr_stmt|;
name|process
operator|->
name|stdoutChannel
operator|.
name|process
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|Normal
expr_stmt|;
name|file
operator|.
name|clear
argument_list|()
expr_stmt|;
name|process
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn bool QProcessPrivate::startDetached(const QString&program, const QStringList&arguments, const QString&workingDirectory, qint64 *pid)  \internal  */
end_comment
begin_comment
comment|/*!     \class QProcess     \inmodule QtCore      \brief The QProcess class is used to start external programs and     to communicate with them.      \ingroup io      \reentrant      \section1 Running a Process      To start a process, pass the name and command line arguments of     the program you want to run as arguments to start(). Arguments     are supplied as individual strings in a QStringList.      Alternatively, you can set the program to run with setProgram()     and setArguments(), and then call start() or open().      For example, the following code snippet runs the analog clock     example in the Fusion style on X11 platforms by passing strings     containing "-style" and "fusion" as two items in the list of     arguments:      \snippet qprocess/qprocess-simpleexecution.cpp 0     \dots     \snippet qprocess/qprocess-simpleexecution.cpp 1     \snippet qprocess/qprocess-simpleexecution.cpp 2      QProcess then enters the \l Starting state, and when the program     has started, QProcess enters the \l Running state and emits     started().      QProcess allows you to treat a process as a sequential I/O     device. You can write to and read from the process just as you     would access a network connection using QTcpSocket. You can then     write to the process's standard input by calling write(), and     read the standard output by calling read(), readLine(), and     getChar(). Because it inherits QIODevice, QProcess can also be     used as an input source for QXmlReader, or for generating data to     be uploaded using QNetworkAccessManager.      \note On Windows CE, reading and writing to a process     is not supported.      When the process exits, QProcess reenters the \l NotRunning state     (the initial state), and emits finished().      The finished() signal provides the exit code and exit status of     the process as arguments, and you can also call exitCode() to     obtain the exit code of the last process that finished, and     exitStatus() to obtain its exit status. If an error occurs at     any point in time, QProcess will emit the error() signal. You     can also call error() to find the type of error that occurred     last, and state() to find the current process state.      \section1 Communicating via Channels      Processes have two predefined output channels: The standard     output channel (\c stdout) supplies regular console output, and     the standard error channel (\c stderr) usually supplies the     errors that are printed by the process. These channels represent     two separate streams of data. You can toggle between them by     calling setReadChannel(). QProcess emits readyRead() when data is     available on the current read channel. It also emits     readyReadStandardOutput() when new standard output data is     available, and when new standard error data is available,     readyReadStandardError() is emitted. Instead of calling read(),     readLine(), or getChar(), you can explicitly read all data from     either of the two channels by calling readAllStandardOutput() or     readAllStandardError().      The terminology for the channels can be misleading. Be aware that     the process's output channels correspond to QProcess's     \e read channels, whereas the process's input channels correspond     to QProcess's \e write channels. This is because what we read     using QProcess is the process's output, and what we write becomes     the process's input.      QProcess can merge the two output channels, so that standard     output and standard error data from the running process both use     the standard output channel. Call setProcessChannelMode() with     MergedChannels before starting the process to activative     this feature. You also have the option of forwarding the output of     the running process to the calling, main process, by passing     ForwardedChannels as the argument.      Certain processes need special environment settings in order to     operate. You can set environment variables for your process by     calling setEnvironment(). To set a working directory, call     setWorkingDirectory(). By default, processes are run in the     current working directory of the calling process.      \note On QNX, setting the working directory may cause all     application threads, with the exception of the QProcess caller     thread, to temporarily freeze during the spawning process,     owing to a limitation in the operating system.      \section1 Synchronous Process API      QProcess provides a set of functions which allow it to be used     without an event loop, by suspending the calling thread until     certain signals are emitted:      \list     \li waitForStarted() blocks until the process has started.      \li waitForReadyRead() blocks until new data is     available for reading on the current read channel.      \li waitForBytesWritten() blocks until one payload of     data has been written to the process.      \li waitForFinished() blocks until the process has finished.     \endlist      Calling these functions from the main thread (the thread that     calls QApplication::exec()) may cause your user interface to     freeze.      The following example runs \c gzip to compress the string "Qt     rocks!", without an event loop:      \snippet process/process.cpp 0      \section1 Notes for Windows Users      Some Windows commands (for example, \c dir) are not provided by     separate applications, but by the command interpreter itself.     If you attempt to use QProcess to execute these commands directly,     it won't work. One possible solution is to execute the command     interpreter itself (\c{cmd.exe} on some Windows systems), and ask     the interpreter to execute the desired command.      \sa QBuffer, QFile, QTcpSocket */
end_comment
begin_comment
comment|/*!     \enum QProcess::ProcessChannel      This enum describes the process channels used by the running process.     Pass one of these values to setReadChannel() to set the     current read channel of QProcess.      \value StandardOutput The standard output (stdout) of the running            process.      \value StandardError The standard error (stderr) of the running            process.      \sa setReadChannel() */
end_comment
begin_comment
comment|/*!     \enum QProcess::ProcessChannelMode      This enum describes the process channel modes of QProcess. Pass     one of these values to setProcessChannelMode() to set the     current read channel mode.      \value SeparateChannels QProcess manages the output of the     running process, keeping standard output and standard error data     in separate internal buffers. You can select the QProcess's     current read channel by calling setReadChannel(). This is the     default channel mode of QProcess.      \value MergedChannels QProcess merges the output of the running     process into the standard output channel (\c stdout). The     standard error channel (\c stderr) will not receive any data. The     standard output and standard error data of the running process     are interleaved.      \value ForwardedChannels QProcess forwards the output of the     running process onto the main process. Anything the child process     writes to its standard output and standard error will be written     to the standard output and standard error of the main process.      \note Windows intentionally suppresses output from GUI-only     applications to inherited consoles.     This does \e not apply to output redirected to files or pipes.     To forward the output of GUI-only applications on the console     nonetheless, you must use SeparateChannels and do the forwarding     yourself by reading the output and writing it to the appropriate     output channels.      \sa setProcessChannelMode() */
end_comment
begin_comment
comment|/*!     \enum QProcess::ProcessError      This enum describes the different types of errors that are     reported by QProcess.      \value FailedToStart The process failed to start. Either the     invoked program is missing, or you may have insufficient     permissions to invoke the program.      \value Crashed The process crashed some time after starting     successfully.      \value Timedout The last waitFor...() function timed out. The     state of QProcess is unchanged, and you can try calling     waitFor...() again.      \value WriteError An error occurred when attempting to write to the     process. For example, the process may not be running, or it may     have closed its input channel.      \value ReadError An error occurred when attempting to read from     the process. For example, the process may not be running.      \value UnknownError An unknown error occurred. This is the default     return value of error().      \sa error() */
end_comment
begin_comment
comment|/*!     \enum QProcess::ProcessState      This enum describes the different states of QProcess.      \value NotRunning The process is not running.      \value Starting The process is starting, but the program has not     yet been invoked.      \value Running The process is running and is ready for reading and     writing.      \sa state() */
end_comment
begin_comment
comment|/*!     \enum QProcess::ExitStatus      This enum describes the different exit statuses of QProcess.      \value NormalExit The process exited normally.      \value CrashExit The process crashed.      \sa exitStatus() */
end_comment
begin_comment
comment|/*!     \fn void QProcess::error(QProcess::ProcessError error)      This signal is emitted when an error occurs with the process. The     specified \a error describes the type of error that occurred. */
end_comment
begin_comment
comment|/*!     \fn void QProcess::started()      This signal is emitted by QProcess when the process has started,     and state() returns \l Running. */
end_comment
begin_comment
comment|/*!     \fn void QProcess::stateChanged(QProcess::ProcessState newState)      This signal is emitted whenever the state of QProcess changes. The     \a newState argument is the state QProcess changed to. */
end_comment
begin_comment
comment|/*!     \fn void QProcess::finished(int exitCode)     \obsolete     \overload      Use finished(int exitCode, QProcess::ExitStatus status) instead. */
end_comment
begin_comment
comment|/*!     \fn void QProcess::finished(int exitCode, QProcess::ExitStatus exitStatus)      This signal is emitted when the process finishes. \a exitCode is the exit     code of the process, and \a exitStatus is the exit status.  After the     process has finished, the buffers in QProcess are still intact. You can     still read any data that the process may have written before it finished.      \sa exitStatus() */
end_comment
begin_comment
comment|/*!     \fn void QProcess::readyReadStandardOutput()      This signal is emitted when the process has made new data     available through its standard output channel (\c stdout). It is     emitted regardless of the current \l{readChannel()}{read channel}.      \sa readAllStandardOutput(), readChannel() */
end_comment
begin_comment
comment|/*!     \fn void QProcess::readyReadStandardError()      This signal is emitted when the process has made new data     available through its standard error channel (\c stderr). It is     emitted regardless of the current \l{readChannel()}{read     channel}.      \sa readAllStandardError(), readChannel() */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QProcessPrivate
name|QProcessPrivate
operator|::
name|QProcessPrivate
parameter_list|()
block|{
name|processChannel
operator|=
name|QProcess
operator|::
name|StandardOutput
expr_stmt|;
name|processChannelMode
operator|=
name|QProcess
operator|::
name|SeparateChannels
expr_stmt|;
name|processError
operator|=
name|QProcess
operator|::
name|UnknownError
expr_stmt|;
name|processState
operator|=
name|QProcess
operator|::
name|NotRunning
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
name|sequenceNumber
operator|=
literal|0
expr_stmt|;
name|exitCode
operator|=
literal|0
expr_stmt|;
name|exitStatus
operator|=
name|QProcess
operator|::
name|NormalExit
expr_stmt|;
name|startupSocketNotifier
operator|=
literal|0
expr_stmt|;
name|deathNotifier
operator|=
literal|0
expr_stmt|;
name|childStartedPipe
index|[
literal|0
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
name|childStartedPipe
index|[
literal|1
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
name|deathPipe
index|[
literal|0
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
name|deathPipe
index|[
literal|1
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
name|exitCode
operator|=
literal|0
expr_stmt|;
name|crashed
operator|=
literal|false
expr_stmt|;
name|dying
operator|=
literal|false
expr_stmt|;
name|emittedReadyRead
operator|=
literal|false
expr_stmt|;
name|emittedBytesWritten
operator|=
literal|false
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|notifier
operator|=
literal|0
expr_stmt|;
name|stdoutReader
operator|=
literal|0
expr_stmt|;
name|stderrReader
operator|=
literal|0
expr_stmt|;
name|pipeWriter
operator|=
literal|0
expr_stmt|;
name|processFinishedNotifier
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|// Q_OS_WIN
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|serial
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_destructor
DECL|function|~QProcessPrivate
name|QProcessPrivate
operator|::
name|~
name|QProcessPrivate
parameter_list|()
block|{
if|if
condition|(
name|stdinChannel
operator|.
name|process
condition|)
name|stdinChannel
operator|.
name|process
operator|->
name|stdoutChannel
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|process
condition|)
name|stdoutChannel
operator|.
name|process
operator|->
name|stdinChannel
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|cleanup
name|void
name|QProcessPrivate
operator|::
name|cleanup
parameter_list|()
block|{
name|q_func
argument_list|()
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|NotRunning
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
name|pid
condition|)
block|{
name|CloseHandle
argument_list|(
name|pid
operator|->
name|hThread
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|)
expr_stmt|;
operator|delete
name|pid
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|processFinishedNotifier
condition|)
block|{
name|processFinishedNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|qDeleteInEventHandler
argument_list|(
name|processFinishedNotifier
argument_list|)
expr_stmt|;
name|processFinishedNotifier
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|pid
operator|=
literal|0
expr_stmt|;
name|sequenceNumber
operator|=
literal|0
expr_stmt|;
name|dying
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|notifier
condition|)
block|{
name|stdoutChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|qDeleteInEventHandler
argument_list|(
name|stdoutChannel
operator|.
name|notifier
argument_list|)
expr_stmt|;
name|stdoutChannel
operator|.
name|notifier
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|stderrChannel
operator|.
name|notifier
condition|)
block|{
name|stderrChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|qDeleteInEventHandler
argument_list|(
name|stderrChannel
operator|.
name|notifier
argument_list|)
expr_stmt|;
name|stderrChannel
operator|.
name|notifier
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|stdinChannel
operator|.
name|notifier
condition|)
block|{
name|stdinChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|qDeleteInEventHandler
argument_list|(
name|stdinChannel
operator|.
name|notifier
argument_list|)
expr_stmt|;
name|stdinChannel
operator|.
name|notifier
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|startupSocketNotifier
condition|)
block|{
name|startupSocketNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|qDeleteInEventHandler
argument_list|(
name|startupSocketNotifier
argument_list|)
expr_stmt|;
name|startupSocketNotifier
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|deathNotifier
condition|)
block|{
name|deathNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|qDeleteInEventHandler
argument_list|(
name|deathNotifier
argument_list|)
expr_stmt|;
name|deathNotifier
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
name|notifier
condition|)
block|{
name|qDeleteInEventHandler
argument_list|(
name|notifier
argument_list|)
expr_stmt|;
name|notifier
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|destroyChannel
argument_list|(
operator|&
name|stdoutChannel
argument_list|)
expr_stmt|;
name|destroyChannel
argument_list|(
operator|&
name|stderrChannel
argument_list|)
expr_stmt|;
name|destroyChannel
argument_list|(
operator|&
name|stdinChannel
argument_list|)
expr_stmt|;
name|destroyPipe
argument_list|(
name|childStartedPipe
argument_list|)
expr_stmt|;
name|destroyPipe
argument_list|(
name|deathPipe
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|serial
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_canReadStandardOutput
name|bool
name|QProcessPrivate
operator|::
name|_q_canReadStandardOutput
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|qint64
name|available
init|=
name|bytesAvailableFromStdout
argument_list|()
decl_stmt|;
if|if
condition|(
name|available
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stdoutChannel
operator|.
name|notifier
condition|)
name|stdoutChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|destroyChannel
argument_list|(
operator|&
name|stdoutChannel
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::canReadStandardOutput(), 0 bytes available"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
name|char
modifier|*
name|ptr
init|=
name|outputReadBuffer
operator|.
name|reserve
argument_list|(
name|available
argument_list|)
decl_stmt|;
name|qint64
name|readBytes
init|=
name|readFromStdout
argument_list|(
name|ptr
argument_list|,
name|available
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBytes
operator|==
operator|-
literal|1
condition|)
block|{
name|processError
operator|=
name|QProcess
operator|::
name|ReadError
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Error reading from process"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::canReadStandardOutput(), failed to read from the process"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::canReadStandardOutput(), read %d bytes from the process' output"
argument_list|,
name|int
argument_list|(
name|readBytes
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stdoutChannel
operator|.
name|closed
condition|)
block|{
name|outputReadBuffer
operator|.
name|chop
argument_list|(
name|readBytes
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|outputReadBuffer
operator|.
name|chop
argument_list|(
name|available
operator|-
name|readBytes
argument_list|)
expr_stmt|;
name|bool
name|didRead
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|readBytes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stdoutChannel
operator|.
name|notifier
condition|)
name|stdoutChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardOutput
condition|)
block|{
name|didRead
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|emittedReadyRead
condition|)
block|{
name|emittedReadyRead
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|readyRead
argument_list|()
emit|;
name|emittedReadyRead
operator|=
literal|false
expr_stmt|;
block|}
block|}
emit|emit
name|q
operator|->
name|readyReadStandardOutput
argument_list|(
name|QProcess
operator|::
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
return|return
name|didRead
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_canReadStandardError
name|bool
name|QProcessPrivate
operator|::
name|_q_canReadStandardError
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|qint64
name|available
init|=
name|bytesAvailableFromStderr
argument_list|()
decl_stmt|;
if|if
condition|(
name|available
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stderrChannel
operator|.
name|notifier
condition|)
name|stderrChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|destroyChannel
argument_list|(
operator|&
name|stderrChannel
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|char
modifier|*
name|ptr
init|=
name|errorReadBuffer
operator|.
name|reserve
argument_list|(
name|available
argument_list|)
decl_stmt|;
name|qint64
name|readBytes
init|=
name|readFromStderr
argument_list|(
name|ptr
argument_list|,
name|available
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBytes
operator|==
operator|-
literal|1
condition|)
block|{
name|processError
operator|=
name|QProcess
operator|::
name|ReadError
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Error reading from process"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|stderrChannel
operator|.
name|closed
condition|)
block|{
name|errorReadBuffer
operator|.
name|chop
argument_list|(
name|readBytes
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|errorReadBuffer
operator|.
name|chop
argument_list|(
name|available
operator|-
name|readBytes
argument_list|)
expr_stmt|;
name|bool
name|didRead
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|readBytes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stderrChannel
operator|.
name|notifier
condition|)
name|stderrChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
condition|)
block|{
name|didRead
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|emittedReadyRead
condition|)
block|{
name|emittedReadyRead
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|readyRead
argument_list|()
emit|;
name|emittedReadyRead
operator|=
literal|false
expr_stmt|;
block|}
block|}
emit|emit
name|q
operator|->
name|readyReadStandardError
argument_list|(
name|QProcess
operator|::
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
return|return
name|didRead
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_canWrite
name|bool
name|QProcessPrivate
operator|::
name|_q_canWrite
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdinChannel
operator|.
name|notifier
condition|)
name|stdinChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::canWrite(), not writing anything (empty write buffer)."
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
name|qint64
name|written
init|=
name|writeToStdin
argument_list|(
name|writeBuffer
operator|.
name|readPointer
argument_list|()
argument_list|,
name|writeBuffer
operator|.
name|nextDataBlockSize
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|written
operator|<
literal|0
condition|)
block|{
name|destroyChannel
argument_list|(
operator|&
name|stdinChannel
argument_list|)
expr_stmt|;
name|processError
operator|=
name|QProcess
operator|::
name|WriteError
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Error writing to process"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::canWrite(), wrote %d bytes to the process input"
argument_list|,
name|int
argument_list|(
name|written
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|written
operator|!=
literal|0
condition|)
block|{
name|writeBuffer
operator|.
name|free
argument_list|(
name|written
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|emittedBytesWritten
condition|)
block|{
name|emittedBytesWritten
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|bytesWritten
argument_list|(
name|written
argument_list|)
emit|;
name|emittedBytesWritten
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stdinChannel
operator|.
name|notifier
operator|&&
operator|!
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|stdinChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
operator|&&
name|stdinChannel
operator|.
name|closed
condition|)
name|closeWriteChannel
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_processDied
name|bool
name|QProcessPrivate
operator|::
name|_q_processDied
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::_q_processDied()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_UNIX
if|if
condition|(
operator|!
name|waitForDeadChild
argument_list|()
condition|)
return|return
literal|false
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
name|processFinishedNotifier
condition|)
name|processFinishedNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// the process may have died before it got a chance to report that it was
comment|// either running or stopped, so we will call _q_startupNotification() and
comment|// give it a chance to emit started() or error(FailedToStart).
if|if
condition|(
name|processState
operator|==
name|QProcess
operator|::
name|Starting
condition|)
block|{
if|if
condition|(
operator|!
name|_q_startupNotification
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
if|if
condition|(
name|dying
condition|)
block|{
comment|// at this point we know the process is dead. prevent
comment|// reentering this slot recursively by calling waitForFinished()
comment|// or opening a dialog inside slots connected to the readyRead
comment|// signals emitted below.
return|return
literal|true
return|;
block|}
name|dying
operator|=
literal|true
expr_stmt|;
comment|// in case there is data in the pipe line and this slot by chance
comment|// got called before the read notifications, call these two slots
comment|// so the data is made available before the process dies.
name|_q_canReadStandardOutput
argument_list|()
expr_stmt|;
name|_q_canReadStandardError
argument_list|()
expr_stmt|;
name|findExitCode
argument_list|()
expr_stmt|;
if|if
condition|(
name|crashed
condition|)
block|{
name|exitStatus
operator|=
name|QProcess
operator|::
name|CrashExit
expr_stmt|;
name|processError
operator|=
name|QProcess
operator|::
name|Crashed
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process crashed"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
block|}
name|bool
name|wasRunning
init|=
operator|(
name|processState
operator|==
name|QProcess
operator|::
name|Running
operator|)
decl_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
name|wasRunning
condition|)
block|{
comment|// we received EOF now:
emit|emit
name|q
operator|->
name|readChannelFinished
argument_list|()
emit|;
comment|// in the future:
comment|//emit q->standardOutputClosed();
comment|//emit q->standardErrorClosed();
emit|emit
name|q
operator|->
name|finished
argument_list|(
name|exitCode
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|finished
argument_list|(
name|exitCode
argument_list|,
name|exitStatus
argument_list|)
emit|;
block|}
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::_q_processDied() process is dead"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_startupNotification
name|bool
name|QProcessPrivate
operator|::
name|_q_startupNotification
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::startupNotification()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|startupSocketNotifier
condition|)
name|startupSocketNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|processStarted
argument_list|()
condition|)
block|{
name|q
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|Running
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|started
argument_list|(
name|QProcess
operator|::
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
return|return
literal|true
return|;
block|}
name|q
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|NotRunning
argument_list|)
expr_stmt|;
name|processError
operator|=
name|QProcess
operator|::
name|FailedToStart
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
ifdef|#
directive|ifdef
name|Q_OS_UNIX
comment|// make sure the process manager removes this entry
name|waitForDeadChild
argument_list|()
expr_stmt|;
name|findExitCode
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cleanup
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|closeWriteChannel
name|void
name|QProcessPrivate
operator|::
name|closeWriteChannel
parameter_list|()
block|{
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::closeWriteChannel()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stdinChannel
operator|.
name|notifier
condition|)
block|{
specifier|extern
name|void
name|qDeleteInEventHandler
argument_list|(
name|QObject
operator|*
name|o
argument_list|)
decl_stmt|;
name|stdinChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdinChannel
operator|.
name|notifier
condition|)
block|{
name|qDeleteInEventHandler
argument_list|(
name|stdinChannel
operator|.
name|notifier
argument_list|)
expr_stmt|;
name|stdinChannel
operator|.
name|notifier
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// ### Find a better fix, feeding the process little by little
comment|// instead.
name|flushPipeWriter
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|destroyChannel
argument_list|(
operator|&
name|stdinChannel
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs a QProcess object with the given \a parent. */
end_comment
begin_constructor
DECL|function|QProcess
name|QProcess
operator|::
name|QProcess
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
operator|*
operator|new
name|QProcessPrivate
argument_list|,
name|parent
argument_list|)
block|{
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::QProcess(%p)"
argument_list|,
name|parent
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_comment
comment|/*!     Destructs the QProcess object, i.e., killing the process.      Note that this function will not return until the process is     terminated. */
end_comment
begin_destructor
DECL|function|~QProcess
name|QProcess
operator|::
name|~
name|QProcess
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|!=
name|NotRunning
condition|)
block|{
name|qWarning
argument_list|()
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QProcess: Destroyed while process ("
operator|<<
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|program
argument_list|()
argument_list|)
operator|<<
literal|") is still running."
expr_stmt|;
name|kill
argument_list|()
expr_stmt|;
name|waitForFinished
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Q_OS_UNIX
comment|// make sure the process manager removes this entry
name|d
operator|->
name|findExitCode
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \obsolete     Returns the read channel mode of the QProcess. This function is     equivalent to processChannelMode()      \sa processChannelMode() */
end_comment
begin_function
DECL|function|readChannelMode
name|QProcess
operator|::
name|ProcessChannelMode
name|QProcess
operator|::
name|readChannelMode
parameter_list|()
specifier|const
block|{
return|return
name|processChannelMode
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use setProcessChannelMode(\a mode) instead.      \sa setProcessChannelMode() */
end_comment
begin_function
DECL|function|setReadChannelMode
name|void
name|QProcess
operator|::
name|setReadChannelMode
parameter_list|(
name|ProcessChannelMode
name|mode
parameter_list|)
block|{
name|setProcessChannelMode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the channel mode of the QProcess standard output and     standard error channels.      \sa setProcessChannelMode(), ProcessChannelMode, setReadChannel() */
end_comment
begin_function
DECL|function|processChannelMode
name|QProcess
operator|::
name|ProcessChannelMode
name|QProcess
operator|::
name|processChannelMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|processChannelMode
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets the channel mode of the QProcess standard output and standard     error channels to the \a mode specified.     This mode will be used the next time start() is called. For example:      \snippet code/src_corelib_io_qprocess.cpp 0      \sa processChannelMode(), ProcessChannelMode, setReadChannel() */
end_comment
begin_function
DECL|function|setProcessChannelMode
name|void
name|QProcess
operator|::
name|setProcessChannelMode
parameter_list|(
name|ProcessChannelMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|processChannelMode
operator|=
name|mode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current read channel of the QProcess.      \sa setReadChannel() */
end_comment
begin_function
DECL|function|readChannel
name|QProcess
operator|::
name|ProcessChannel
name|QProcess
operator|::
name|readChannel
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|processChannel
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the current read channel of the QProcess to the given \a     channel. The current input channel is used by the functions     read(), readAll(), readLine(), and getChar(). It also determines     which channel triggers QProcess to emit readyRead().      \sa readChannel() */
end_comment
begin_function
DECL|function|setReadChannel
name|void
name|QProcess
operator|::
name|setReadChannel
parameter_list|(
name|ProcessChannel
name|channel
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processChannel
operator|!=
name|channel
condition|)
block|{
name|QByteArray
name|buf
init|=
name|d
operator|->
name|buffer
operator|.
name|readAll
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardOutput
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|buf
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|d
operator|->
name|outputReadBuffer
operator|.
name|ungetChar
argument_list|(
name|buf
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
name|buf
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|d
operator|->
name|errorReadBuffer
operator|.
name|ungetChar
argument_list|(
name|buf
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|processChannel
operator|=
name|channel
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Closes the read channel \a channel. After calling this function,     QProcess will no longer receive data on the channel. Any data that     has already been received is still available for reading.      Call this function to save memory, if you are not interested in     the output of the process.      \sa closeWriteChannel(), setReadChannel() */
end_comment
begin_function
DECL|function|closeReadChannel
name|void
name|QProcess
operator|::
name|closeReadChannel
parameter_list|(
name|ProcessChannel
name|channel
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|StandardOutput
condition|)
name|d
operator|->
name|stdoutChannel
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
else|else
name|d
operator|->
name|stderrChannel
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Schedules the write channel of QProcess to be closed. The channel     will close once all data has been written to the process. After     calling this function, any attempts to write to the process will     fail.      Closing the write channel is necessary for programs that read     input data until the channel has been closed. For example, the     program "more" is used to display text data in a console on both     Unix and Windows. But it will not display the text data until     QProcess's write channel has been closed. Example:      \snippet code/src_corelib_io_qprocess.cpp 1      The write channel is implicitly opened when start() is called.      \sa closeReadChannel() */
end_comment
begin_function
DECL|function|closeWriteChannel
name|void
name|QProcess
operator|::
name|closeWriteChannel
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|stdinChannel
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
comment|// closing
if|if
condition|(
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|closeWriteChannel
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Redirects the process' standard input to the file indicated by \a     fileName. When an input redirection is in place, the QProcess     object will be in read-only mode (calling write() will result in     error).      If the file \a fileName does not exist at the moment start() is     called or is not readable, starting the process will fail.      Calling setStandardInputFile() after the process has started has no     effect.      \sa setStandardOutputFile(), setStandardErrorFile(),         setStandardOutputProcess() */
end_comment
begin_function
DECL|function|setStandardInputFile
name|void
name|QProcess
operator|::
name|setStandardInputFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|stdinChannel
operator|=
name|fileName
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Redirects the process' standard output to the file \a     fileName. When the redirection is in place, the standard output     read channel is closed: reading from it using read() will always     fail, as will readAllStandardOutput().      If the file \a fileName doesn't exist at the moment start() is     called, it will be created. If it cannot be created, the starting     will fail.      If the file exists and \a mode is QIODevice::Truncate, the file     will be truncated. Otherwise (if \a mode is QIODevice::Append),     the file will be appended to.      Calling setStandardOutputFile() after the process has started has     no effect.      \sa setStandardInputFile(), setStandardErrorFile(),         setStandardOutputProcess() */
end_comment
begin_function
DECL|function|setStandardOutputFile
name|void
name|QProcess
operator|::
name|setStandardOutputFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|OpenMode
name|mode
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|mode
operator|==
name|Append
operator|||
name|mode
operator|==
name|Truncate
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|stdoutChannel
operator|=
name|fileName
expr_stmt|;
name|d
operator|->
name|stdoutChannel
operator|.
name|append
operator|=
name|mode
operator|==
name|Append
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Redirects the process' standard error to the file \a     fileName. When the redirection is in place, the standard error     read channel is closed: reading from it using read() will always     fail, as will readAllStandardError(). The file will be appended to     if \a mode is Append, otherwise, it will be truncated.      See setStandardOutputFile() for more information on how the file     is opened.      Note: if setProcessChannelMode() was called with an argument of     QProcess::MergedChannels, this function has no effect.      \sa setStandardInputFile(), setStandardOutputFile(),         setStandardOutputProcess() */
end_comment
begin_function
DECL|function|setStandardErrorFile
name|void
name|QProcess
operator|::
name|setStandardErrorFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|OpenMode
name|mode
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|mode
operator|==
name|Append
operator|||
name|mode
operator|==
name|Truncate
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|stderrChannel
operator|=
name|fileName
expr_stmt|;
name|d
operator|->
name|stderrChannel
operator|.
name|append
operator|=
name|mode
operator|==
name|Append
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Pipes the standard output stream of this process to the \a     destination process' standard input.      The following shell command:     \snippet code/src_corelib_io_qprocess.cpp 2      Can be accomplished with QProcesses with the following code:     \snippet code/src_corelib_io_qprocess.cpp 3 */
end_comment
begin_function
DECL|function|setStandardOutputProcess
name|void
name|QProcess
operator|::
name|setStandardOutputProcess
parameter_list|(
name|QProcess
modifier|*
name|destination
parameter_list|)
block|{
name|QProcessPrivate
modifier|*
name|dfrom
init|=
name|d_func
argument_list|()
decl_stmt|;
name|QProcessPrivate
modifier|*
name|dto
init|=
name|destination
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|dfrom
operator|->
name|stdoutChannel
operator|.
name|pipeTo
argument_list|(
name|dto
argument_list|)
expr_stmt|;
name|dto
operator|->
name|stdinChannel
operator|.
name|pipeFrom
argument_list|(
name|dfrom
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_comment
comment|/*!     \since 4.7      Returns the additional native command line arguments for the program.      \note This function is available only on the Windows platform.      \sa setNativeArguments() */
end_comment
begin_function
DECL|function|nativeArguments
name|QString
name|QProcess
operator|::
name|nativeArguments
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeArguments
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7     \overload      Sets additional native command line \a arguments for the program.      On operating systems where the system API for passing command line     \a arguments to a subprocess natively uses a single string, one can     conceive command lines which cannot be passed via QProcess's portable     list-based API. In such cases this function must be used to set a     string which is \e appended to the string composed from the usual     argument list, with a delimiting space.      \note This function is available only on the Windows platform.      \sa nativeArguments() */
end_comment
begin_function
DECL|function|setNativeArguments
name|void
name|QProcess
operator|::
name|setNativeArguments
parameter_list|(
specifier|const
name|QString
modifier|&
name|arguments
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|nativeArguments
operator|=
name|arguments
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     If QProcess has been assigned a working directory, this function returns     the working directory that the QProcess will enter before the program has     started. Otherwise, (i.e., no directory has been assigned,) an empty     string is returned, and QProcess will use the application's current     working directory instead.      \sa setWorkingDirectory() */
end_comment
begin_function
DECL|function|workingDirectory
name|QString
name|QProcess
operator|::
name|workingDirectory
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|workingDirectory
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the working directory to \a dir. QProcess will start the     process in this directory. The default behavior is to start the     process in the working directory of the calling process.      \note On QNX, this may cause all application threads to     temporarily freeze.      \sa workingDirectory(), start() */
end_comment
begin_function
DECL|function|setWorkingDirectory
name|void
name|QProcess
operator|::
name|setWorkingDirectory
parameter_list|(
specifier|const
name|QString
modifier|&
name|dir
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|workingDirectory
operator|=
name|dir
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the native process identifier for the running process, if     available.  If no process is currently running, 0 is returned. */
end_comment
begin_function
DECL|function|pid
name|Q_PID
name|QProcess
operator|::
name|pid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|pid
return|;
block|}
end_function
begin_comment
comment|/*! \reimp      This function operates on the current read channel.      \sa readChannel(), setReadChannel() */
end_comment
begin_function
DECL|function|canReadLine
name|bool
name|QProcess
operator|::
name|canReadLine
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
specifier|const
name|QRingBuffer
modifier|*
name|readBuffer
init|=
operator|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
operator|)
condition|?
operator|&
name|d
operator|->
name|errorReadBuffer
else|:
operator|&
name|d
operator|->
name|outputReadBuffer
decl_stmt|;
return|return
name|readBuffer
operator|->
name|canReadLine
argument_list|()
operator|||
name|QIODevice
operator|::
name|canReadLine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Closes all communication with the process and kills it. After calling this     function, QProcess will no longer emit readyRead(), and data can no     longer be read or written. */
end_comment
begin_function
DECL|function|close
name|void
name|QProcess
operator|::
name|close
parameter_list|()
block|{
emit|emit
name|aboutToClose
argument_list|()
emit|;
while|while
condition|(
name|waitForBytesWritten
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
empty_stmt|;
name|kill
argument_list|()
expr_stmt|;
name|waitForFinished
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QIODevice
operator|::
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp     Returns true if the process is not running, and no more data is available    for reading; otherwise returns false. */
end_comment
begin_function
DECL|function|atEnd
name|bool
name|QProcess
operator|::
name|atEnd
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
specifier|const
name|QRingBuffer
modifier|*
name|readBuffer
init|=
operator|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
operator|)
condition|?
operator|&
name|d
operator|->
name|errorReadBuffer
else|:
operator|&
name|d
operator|->
name|outputReadBuffer
decl_stmt|;
return|return
name|QIODevice
operator|::
name|atEnd
argument_list|()
operator|&&
operator|(
operator|!
name|isOpen
argument_list|()
operator|||
name|readBuffer
operator|->
name|isEmpty
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|isSequential
name|bool
name|QProcess
operator|::
name|isSequential
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|bytesAvailable
name|qint64
name|QProcess
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
specifier|const
name|QRingBuffer
modifier|*
name|readBuffer
init|=
operator|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
operator|)
condition|?
operator|&
name|d
operator|->
name|errorReadBuffer
else|:
operator|&
name|d
operator|->
name|outputReadBuffer
decl_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::bytesAvailable() == %i (%s)"
argument_list|,
name|readBuffer
operator|->
name|size
argument_list|()
argument_list|,
operator|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
operator|)
condition|?
literal|"stderr"
else|:
literal|"stdout"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|readBuffer
operator|->
name|size
argument_list|()
operator|+
name|QIODevice
operator|::
name|bytesAvailable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|bytesToWrite
name|qint64
name|QProcess
operator|::
name|bytesToWrite
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
name|qint64
name|size
init|=
name|d
operator|->
name|writeBuffer
operator|.
name|size
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|size
operator|+=
name|d
operator|->
name|pipeWriterBytesToWrite
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|size
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the type of error that occurred last.      \sa state() */
end_comment
begin_function
DECL|function|error
name|QProcess
operator|::
name|ProcessError
name|QProcess
operator|::
name|error
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|processError
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current state of the process.      \sa stateChanged(), error() */
end_comment
begin_function
DECL|function|state
name|QProcess
operator|::
name|ProcessState
name|QProcess
operator|::
name|state
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|processState
return|;
block|}
end_function
begin_comment
comment|/*!     \deprecated     Sets the environment that QProcess will use when starting a process to the     \a environment specified which consists of a list of key=value pairs.      For example, the following code adds the \c{C:\\BIN} directory to the list of     executable paths (\c{PATHS}) on Windows:      \snippet qprocess-environment/main.cpp 0      \note This function is less efficient than the setProcessEnvironment()     function.      \sa environment(), setProcessEnvironment(), systemEnvironment() */
end_comment
begin_function
DECL|function|setEnvironment
name|void
name|QProcess
operator|::
name|setEnvironment
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|environment
parameter_list|)
block|{
name|setProcessEnvironment
argument_list|(
name|QProcessEnvironmentPrivate
operator|::
name|fromList
argument_list|(
name|environment
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \deprecated     Returns the environment that QProcess will use when starting a     process, or an empty QStringList if no environment has been set     using setEnvironment() or setEnvironmentHash(). If no environment     has been set, the environment of the calling process will be used.      \note The environment settings are ignored on Windows CE,     as there is no concept of an environment.      \sa processEnvironment(), setEnvironment(), systemEnvironment() */
end_comment
begin_function
DECL|function|environment
name|QStringList
name|QProcess
operator|::
name|environment
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|environment
operator|.
name|toStringList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Sets the environment that QProcess will use when starting a process to the     \a environment object.      For example, the following code adds the \c{C:\\BIN} directory to the list of     executable paths (\c{PATHS}) on Windows and sets \c{TMPDIR}:      \snippet qprocess-environment/main.cpp 1      Note how, on Windows, environment variable names are case-insensitive.      \sa processEnvironment(), QProcessEnvironment::systemEnvironment(), setEnvironment() */
end_comment
begin_function
DECL|function|setProcessEnvironment
name|void
name|QProcess
operator|::
name|setProcessEnvironment
parameter_list|(
specifier|const
name|QProcessEnvironment
modifier|&
name|environment
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|environment
operator|=
name|environment
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Returns the environment that QProcess will use when starting a     process, or an empty object if no environment has been set using     setEnvironment() or setProcessEnvironment(). If no environment has     been set, the environment of the calling process will be used.      \note The environment settings are ignored on Windows CE,     as there is no concept of an environment.      \sa setProcessEnvironment(), setEnvironment(), QProcessEnvironment::isEmpty() */
end_comment
begin_function
DECL|function|processEnvironment
name|QProcessEnvironment
name|QProcess
operator|::
name|processEnvironment
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|environment
return|;
block|}
end_function
begin_comment
comment|/*!     Blocks until the process has started and the started() signal has     been emitted, or until \a msecs milliseconds have passed.      Returns true if the process was started successfully; otherwise     returns false (if the operation timed out or if an error     occurred).      This function can operate without an event loop. It is     useful when writing non-GUI applications and when performing     I/O operations in a non-GUI thread.      \warning Calling this function from the main (GUI) thread     might cause your user interface to freeze.      If msecs is -1, this function will not time out.      \sa started(), waitForReadyRead(), waitForBytesWritten(), waitForFinished() */
end_comment
begin_function
DECL|function|waitForStarted
name|bool
name|QProcess
operator|::
name|waitForStarted
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|Running
condition|)
return|return
literal|true
return|;
return|return
name|d
operator|->
name|waitForStarted
argument_list|(
name|msecs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|waitForReadyRead
name|bool
name|QProcess
operator|::
name|waitForReadyRead
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|NotRunning
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardOutput
operator|&&
name|d
operator|->
name|stdoutChannel
operator|.
name|closed
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
operator|&&
name|d
operator|->
name|stderrChannel
operator|.
name|closed
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|waitForReadyRead
argument_list|(
name|msecs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|waitForBytesWritten
name|bool
name|QProcess
operator|::
name|waitForBytesWritten
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|NotRunning
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|Starting
condition|)
block|{
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
name|bool
name|started
init|=
name|waitForStarted
argument_list|(
name|msecs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|started
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|msecs
operator|!=
operator|-
literal|1
condition|)
name|msecs
operator|-=
name|stopWatch
operator|.
name|elapsed
argument_list|()
expr_stmt|;
block|}
return|return
name|d
operator|->
name|waitForBytesWritten
argument_list|(
name|msecs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Blocks until the process has finished and the finished() signal     has been emitted, or until \a msecs milliseconds have passed.      Returns true if the process finished; otherwise returns false (if     the operation timed out, if an error occurred, or if this QProcess     is already finished).      This function can operate without an event loop. It is     useful when writing non-GUI applications and when performing     I/O operations in a non-GUI thread.      \warning Calling this function from the main (GUI) thread     might cause your user interface to freeze.      If msecs is -1, this function will not time out.      \sa finished(), waitForStarted(), waitForReadyRead(), waitForBytesWritten() */
end_comment
begin_function
DECL|function|waitForFinished
name|bool
name|QProcess
operator|::
name|waitForFinished
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|NotRunning
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|Starting
condition|)
block|{
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
name|bool
name|started
init|=
name|waitForStarted
argument_list|(
name|msecs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|started
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|msecs
operator|!=
operator|-
literal|1
condition|)
name|msecs
operator|-=
name|stopWatch
operator|.
name|elapsed
argument_list|()
expr_stmt|;
block|}
return|return
name|d
operator|->
name|waitForFinished
argument_list|(
name|msecs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the current state of the QProcess to the \a state specified.      \sa state() */
end_comment
begin_function
DECL|function|setProcessState
name|void
name|QProcess
operator|::
name|setProcessState
parameter_list|(
name|ProcessState
name|state
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|==
name|state
condition|)
return|return;
name|d
operator|->
name|processState
operator|=
name|state
expr_stmt|;
emit|emit
name|stateChanged
argument_list|(
name|state
argument_list|,
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!   This function is called in the child process context just before the     program is executed on Unix or Mac OS X (i.e., after \e fork(), but before     \e execve()). Reimplement this function to do last minute initialization     of the child process. Example:      \snippet code/src_corelib_io_qprocess.cpp 4      You cannot exit the process (by calling exit(), for instance) from     this function. If you need to stop the program before it starts     execution, your workaround is to emit finished() and then call     exit().      \warning This function is called by QProcess on Unix and Mac OS X     only. On Windows and QNX, it is not called. */
end_comment
begin_function
DECL|function|setupChildProcess
name|void
name|QProcess
operator|::
name|setupChildProcess
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|readData
name|qint64
name|QProcess
operator|::
name|readData
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|maxlen
condition|)
return|return
literal|0
return|;
name|QRingBuffer
modifier|*
name|readBuffer
init|=
operator|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
operator|)
condition|?
operator|&
name|d
operator|->
name|errorReadBuffer
else|:
operator|&
name|d
operator|->
name|outputReadBuffer
decl_stmt|;
if|if
condition|(
name|maxlen
operator|==
literal|1
operator|&&
operator|!
name|readBuffer
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|c
init|=
name|readBuffer
operator|->
name|getChar
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::readData(%p \"%s\", %d) == -1"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|maxlen
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|data
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::readData(%p \"%s\", %d) == 1"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|maxlen
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
name|qint64
name|bytesToRead
init|=
name|qint64
argument_list|(
name|qMin
argument_list|(
name|readBuffer
operator|->
name|size
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|maxlen
argument_list|)
argument_list|)
decl_stmt|;
name|qint64
name|readSoFar
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|readSoFar
operator|<
name|bytesToRead
condition|)
block|{
specifier|const
name|char
modifier|*
name|ptr
init|=
name|readBuffer
operator|->
name|readPointer
argument_list|()
decl_stmt|;
name|int
name|bytesToReadFromThisBlock
init|=
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|bytesToRead
operator|-
name|readSoFar
argument_list|,
name|readBuffer
operator|->
name|nextDataBlockSize
argument_list|()
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
name|readSoFar
argument_list|,
name|ptr
argument_list|,
name|bytesToReadFromThisBlock
argument_list|)
expr_stmt|;
name|readSoFar
operator|+=
name|bytesToReadFromThisBlock
expr_stmt|;
name|readBuffer
operator|->
name|free
argument_list|(
name|bytesToReadFromThisBlock
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::readData(%p \"%s\", %lld) == %lld"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|readSoFar
argument_list|,
literal|16
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|maxlen
argument_list|,
name|readSoFar
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|readSoFar
operator|&&
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|NotRunning
condition|)
return|return
operator|-
literal|1
return|;
comment|// EOF
return|return
name|readSoFar
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|writeData
name|qint64
name|QProcess
operator|::
name|writeData
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|Q_UNUSED
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|d
operator|->
name|processError
operator|=
name|QProcess
operator|::
name|WriteError
expr_stmt|;
name|setErrorString
argument_list|(
name|tr
argument_list|(
literal|"Error writing to process"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|error
argument_list|(
name|d
operator|->
name|processError
argument_list|)
emit|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|stdinChannel
operator|.
name|closed
condition|)
block|{
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::writeData(%p \"%s\", %lld) == 0 (write channel closing)"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
literal|16
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|d
operator|->
name|writeBuffer
operator|.
name|putChar
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|stdinChannel
operator|.
name|notifier
condition|)
name|d
operator|->
name|stdinChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::writeData(%p \"%s\", %lld) == 1 (written to buffer)"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
literal|16
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
name|char
modifier|*
name|dest
init|=
name|d
operator|->
name|writeBuffer
operator|.
name|reserve
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|stdinChannel
operator|.
name|notifier
condition|)
name|d
operator|->
name|stdinChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::writeData(%p \"%s\", %lld) == %lld (written to buffer)"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
literal|16
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|len
return|;
block|}
end_function
begin_comment
comment|/*!     Regardless of the current read channel, this function returns all     data available from the standard output of the process as a     QByteArray.      \sa readyReadStandardOutput(), readAllStandardError(), readChannel(), setReadChannel() */
end_comment
begin_function
DECL|function|readAllStandardOutput
name|QByteArray
name|QProcess
operator|::
name|readAllStandardOutput
parameter_list|()
block|{
name|ProcessChannel
name|tmp
init|=
name|readChannel
argument_list|()
decl_stmt|;
name|setReadChannel
argument_list|(
name|StandardOutput
argument_list|)
expr_stmt|;
name|QByteArray
name|data
init|=
name|readAll
argument_list|()
decl_stmt|;
name|setReadChannel
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_comment
comment|/*!     Regardless of the current read channel, this function returns all     data available from the standard error of the process as a     QByteArray.      \sa readyReadStandardError(), readAllStandardOutput(), readChannel(), setReadChannel() */
end_comment
begin_function
DECL|function|readAllStandardError
name|QByteArray
name|QProcess
operator|::
name|readAllStandardError
parameter_list|()
block|{
name|ProcessChannel
name|tmp
init|=
name|readChannel
argument_list|()
decl_stmt|;
name|setReadChannel
argument_list|(
name|StandardError
argument_list|)
expr_stmt|;
name|QByteArray
name|data
init|=
name|readAll
argument_list|()
decl_stmt|;
name|setReadChannel
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_comment
comment|/*!     Starts the given \a program in a new process, if none is already     running, passing the command line arguments in \a arguments. The OpenMode     is set to \a mode.      The QProcess object will immediately enter the Starting state. If the     process starts successfully, QProcess will emit started(); otherwise,     error() will be emitted. If the QProcess object is already running a     process, a warning may be printed at the console, and the existing     process will continue running.      \note Processes are started asynchronously, which means the started()     and error() signals may be delayed. Call waitForStarted() to make     sure the process has started (or has failed to start) and those signals     have been emitted.      \note No further splitting of the arguments is performed.      \b{Windows:} Arguments that contain spaces are wrapped in quotes.      \sa pid(), started(), waitForStarted() */
end_comment
begin_function
DECL|function|start
name|void
name|QProcess
operator|::
name|start
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|,
name|OpenMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|!=
name|NotRunning
condition|)
block|{
name|qWarning
argument_list|(
literal|"QProcess::start: Process is already running"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|program
operator|=
name|program
expr_stmt|;
name|d
operator|->
name|arguments
operator|=
name|arguments
expr_stmt|;
name|open
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.1     \overload      Starts the program set by setProgram() with arguments set by setArguments().     The OpenMode is set to \a mode.      This method is a convenient alias to open().      \sa open(), setProgram(), setArguments()  */
end_comment
begin_function
DECL|function|start
name|void
name|QProcess
operator|::
name|start
parameter_list|(
name|OpenMode
name|mode
parameter_list|)
block|{
name|open
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Starts the program set by setProgram() in a new process, if none is already     running, passing the command line arguments set by setArguments(). The OpenMode     is set to \a mode.      The QProcess object will immediately enter the Starting state. If the     process starts successfully, QProcess will emit started(); otherwise,     error() will be emitted. If the QProcess object is already running a     process, a warning may be printed at the console, the function will return false,     and the existing process will continue running.      \note Processes are started asynchronously, which means the started()     and error() signals may be delayed. Call waitForStarted() to make     sure the process has started (or has failed to start) and those signals     have been emitted. In this regard, a true return value merly means the process     was correcty initialized, not that the program was actually started.  */
end_comment
begin_function
DECL|function|open
name|bool
name|QProcess
operator|::
name|open
parameter_list|(
name|OpenMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|!=
name|NotRunning
condition|)
block|{
name|qWarning
argument_list|(
literal|"QProcess::start: Process is already running"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|program
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QProcess::start: program not set"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QProcess::start("
operator|<<
name|program
operator|<<
literal|','
operator|<<
name|arguments
operator|<<
literal|','
operator|<<
name|mode
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|outputReadBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|errorReadBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|stdinChannel
operator|.
name|type
operator|!=
name|QProcessPrivate
operator|::
name|Channel
operator|::
name|Normal
condition|)
name|mode
operator|&=
operator|~
name|WriteOnly
expr_stmt|;
comment|// not open for writing
if|if
condition|(
name|d
operator|->
name|stdoutChannel
operator|.
name|type
operator|!=
name|QProcessPrivate
operator|::
name|Channel
operator|::
name|Normal
operator|&&
operator|(
name|d
operator|->
name|stderrChannel
operator|.
name|type
operator|!=
name|QProcessPrivate
operator|::
name|Channel
operator|::
name|Normal
operator|||
name|d
operator|->
name|processChannelMode
operator|==
name|MergedChannels
operator|)
condition|)
name|mode
operator|&=
operator|~
name|ReadOnly
expr_stmt|;
comment|// not open for reading
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|mode
operator|=
name|Unbuffered
expr_stmt|;
name|QIODevice
operator|::
name|open
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|d
operator|->
name|stdinChannel
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|stdoutChannel
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|stderrChannel
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|exitCode
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|exitStatus
operator|=
name|NormalExit
expr_stmt|;
name|d
operator|->
name|processError
operator|=
name|QProcess
operator|::
name|UnknownError
expr_stmt|;
name|d
operator|->
name|errorString
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|startProcess
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|parseCombinedArgString
specifier|static
name|QStringList
name|parseCombinedArgString
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|)
block|{
name|QStringList
name|args
decl_stmt|;
name|QString
name|tmp
decl_stmt|;
name|int
name|quoteCount
init|=
literal|0
decl_stmt|;
name|bool
name|inQuote
init|=
literal|false
decl_stmt|;
comment|// handle quoting. tokens can be surrounded by double quotes
comment|// "hello world". three consecutive double quotes represent
comment|// the quote character itself.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|program
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|program
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
condition|)
block|{
operator|++
name|quoteCount
expr_stmt|;
if|if
condition|(
name|quoteCount
operator|==
literal|3
condition|)
block|{
comment|// third consecutive quote
name|quoteCount
operator|=
literal|0
expr_stmt|;
name|tmp
operator|+=
name|program
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|quoteCount
condition|)
block|{
if|if
condition|(
name|quoteCount
operator|==
literal|1
condition|)
name|inQuote
operator|=
operator|!
name|inQuote
expr_stmt|;
name|quoteCount
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inQuote
operator|&&
name|program
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|tmp
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|args
operator|+=
name|tmp
expr_stmt|;
name|tmp
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|tmp
operator|+=
name|program
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|tmp
operator|.
name|isEmpty
argument_list|()
condition|)
name|args
operator|+=
name|tmp
expr_stmt|;
return|return
name|args
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Starts the command \a command in a new process, if one is not already     running. \a command is a single string of text containing both the     program name and its arguments. The arguments are separated by one or     more spaces. For example:      \snippet code/src_corelib_io_qprocess.cpp 5      The \a command string can also contain quotes, to ensure that arguments     containing spaces are correctly supplied to the new process. For example:      \snippet code/src_corelib_io_qprocess.cpp 6      If the QProcess object is already running a process, a warning may be     printed at the console, and the existing process will continue running.      Note that, on Windows, quotes need to be both escaped and quoted.     For example, the above code would be specified in the following     way to ensure that \c{"My Documents"} is used as the argument to     the \c dir executable:      \snippet code/src_corelib_io_qprocess.cpp 7      The OpenMode is set to \a mode. */
end_comment
begin_function
DECL|function|start
name|void
name|QProcess
operator|::
name|start
parameter_list|(
specifier|const
name|QString
modifier|&
name|command
parameter_list|,
name|OpenMode
name|mode
parameter_list|)
block|{
name|QStringList
name|args
init|=
name|parseCombinedArgString
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|processError
operator|=
name|QProcess
operator|::
name|FailedToStart
expr_stmt|;
name|setErrorString
argument_list|(
name|tr
argument_list|(
literal|"No program defined"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|error
argument_list|(
name|d
operator|->
name|processError
argument_list|)
emit|;
return|return;
block|}
name|QString
name|prog
init|=
name|args
operator|.
name|first
argument_list|()
decl_stmt|;
name|args
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|start
argument_list|(
name|prog
argument_list|,
name|args
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the program the process was last started with.      \sa start() */
end_comment
begin_function
DECL|function|program
name|QString
name|QProcess
operator|::
name|program
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|program
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.1      Set the \a program to use when starting the process.     That function must be call before open()      \sa start(), setArguments(), program() */
end_comment
begin_function
DECL|function|setProgram
name|void
name|QProcess
operator|::
name|setProgram
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|!=
name|NotRunning
condition|)
block|{
name|qWarning
argument_list|(
literal|"QProcess::setProgram: Process is already running"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|program
operator|=
name|program
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the command line arguments the process was last started with.      \sa start() */
end_comment
begin_function
DECL|function|arguments
name|QStringList
name|QProcess
operator|::
name|arguments
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|arguments
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.1      Set the \a arguments to pass to the called program when starting the process.     That function must be call before  open()      \sa start(), setProgram(), arguments() */
end_comment
begin_function
DECL|function|setArguments
name|void
name|QProcess
operator|::
name|setArguments
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|!=
name|NotRunning
condition|)
block|{
name|qWarning
argument_list|(
literal|"QProcess::setProgram: Process is already running"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|arguments
operator|=
name|arguments
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Attempts to terminate the process.      The process may not exit as a result of calling this function (it is given     the chance to prompt the user for any unsaved files, etc).      On Windows, terminate() posts a WM_CLOSE message to all toplevel windows     of the process and then to the main thread of the process itself. On Unix     and Mac OS X the SIGTERM signal is sent.      Console applications on Windows that do not run an event loop, or whose     event loop does not handle the WM_CLOSE message, can only be terminated by     calling kill().      \sa kill() */
end_comment
begin_function
DECL|function|terminate
name|void
name|QProcess
operator|::
name|terminate
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|terminateProcess
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Kills the current process, causing it to exit immediately.      On Windows, kill() uses TerminateProcess, and on Unix and Mac OS X, the     SIGKILL signal is sent to the process.      \sa terminate() */
end_comment
begin_function
DECL|function|kill
name|void
name|QProcess
operator|::
name|kill
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|killProcess
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the exit code of the last process that finished. */
end_comment
begin_function
DECL|function|exitCode
name|int
name|QProcess
operator|::
name|exitCode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|exitCode
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the exit status of the last process that finished.      On Windows, if the process was terminated with TerminateProcess()     from another application this function will still return NormalExit     unless the exit code is less than 0. */
end_comment
begin_function
DECL|function|exitStatus
name|QProcess
operator|::
name|ExitStatus
name|QProcess
operator|::
name|exitStatus
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|exitStatus
return|;
block|}
end_function
begin_comment
comment|/*!     Starts the program \a program with the arguments \a arguments in a     new process, waits for it to finish, and then returns the exit     code of the process. Any data the new process writes to the     console is forwarded to the calling process.      The environment and working directory are inherited from the calling     process.      On Windows, arguments that contain spaces are wrapped in quotes.      If the process cannot be started, -2 is returned. If the process     crashes, -1 is returned. Otherwise, the process' exit code is     returned. */
end_comment
begin_function
DECL|function|execute
name|int
name|QProcess
operator|::
name|execute
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|)
block|{
name|QProcess
name|process
decl_stmt|;
name|process
operator|.
name|setReadChannelMode
argument_list|(
name|ForwardedChannels
argument_list|)
expr_stmt|;
name|process
operator|.
name|start
argument_list|(
name|program
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|process
operator|.
name|waitForFinished
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
return|return
name|process
operator|.
name|exitStatus
argument_list|()
operator|==
name|QProcess
operator|::
name|NormalExit
condition|?
name|process
operator|.
name|exitCode
argument_list|()
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Starts the program \a program in a new process. \a program is a     single string of text containing both the program name and its     arguments. The arguments are separated by one or more spaces. */
end_comment
begin_function
DECL|function|execute
name|int
name|QProcess
operator|::
name|execute
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|)
block|{
name|QProcess
name|process
decl_stmt|;
name|process
operator|.
name|setReadChannelMode
argument_list|(
name|ForwardedChannels
argument_list|)
expr_stmt|;
name|process
operator|.
name|start
argument_list|(
name|program
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|process
operator|.
name|waitForFinished
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
return|return
name|process
operator|.
name|exitStatus
argument_list|()
operator|==
name|QProcess
operator|::
name|NormalExit
condition|?
name|process
operator|.
name|exitCode
argument_list|()
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Starts the program \a program with the arguments \a arguments in a     new process, and detaches from it. Returns true on success;     otherwise returns false. If the calling process exits, the     detached process will continue to live.      Note that arguments that contain spaces are not passed to the     process as separate arguments.      \b{Unix:} The started process will run in its own session and act     like a daemon.      \b{Windows:} Arguments that contain spaces are wrapped in quotes.     The started process will run as a regular standalone process.      The process will be started in the directory \a workingDirectory.      \note On QNX, this may cause all application threads to     temporarily freeze.      If the function is successful then *\a pid is set to the process     identifier of the started process. */
end_comment
begin_function
DECL|function|startDetached
name|bool
name|QProcess
operator|::
name|startDetached
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|,
specifier|const
name|QString
modifier|&
name|workingDirectory
parameter_list|,
name|qint64
modifier|*
name|pid
parameter_list|)
block|{
return|return
name|QProcessPrivate
operator|::
name|startDetached
argument_list|(
name|program
argument_list|,
name|arguments
argument_list|,
name|workingDirectory
argument_list|,
name|pid
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Starts the program \a program with the given \a arguments in a     new process, and detaches from it. Returns true on success;     otherwise returns false. If the calling process exits, the     detached process will continue to live.      \note Arguments that contain spaces are not passed to the     process as separate arguments.      \b{Unix:} The started process will run in its own session and act     like a daemon.      \b{Windows:} Arguments that contain spaces are wrapped in quotes.     The started process will run as a regular standalone process. */
end_comment
begin_function
DECL|function|startDetached
name|bool
name|QProcess
operator|::
name|startDetached
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|)
block|{
return|return
name|QProcessPrivate
operator|::
name|startDetached
argument_list|(
name|program
argument_list|,
name|arguments
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Starts the program \a program in a new process. \a program is a     single string of text containing both the program name and its     arguments. The arguments are separated by one or more spaces.      The \a program string can also contain quotes, to ensure that arguments     containing spaces are correctly supplied to the new process. */
end_comment
begin_function
DECL|function|startDetached
name|bool
name|QProcess
operator|::
name|startDetached
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|)
block|{
name|QStringList
name|args
init|=
name|parseCombinedArgString
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QString
name|prog
init|=
name|args
operator|.
name|first
argument_list|()
decl_stmt|;
name|args
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
return|return
name|QProcessPrivate
operator|::
name|startDetached
argument_list|(
name|prog
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
name|QT_BEGIN_INCLUDE_NAMESPACE
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_IOS
argument_list|)
include|#
directive|include
file|<crt_externs.h>
DECL|macro|environ
define|#
directive|define
name|environ
value|(*_NSGetEnviron())
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_IOS
argument_list|)
specifier|static
name|char
modifier|*
name|qt_empty_environ
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_define
define|#
directive|define
name|environ
value|qt_empty_environ
end_define
begin_elif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_elif
begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_END_INCLUDE_NAMESPACE
comment|/*!     \since 4.1      Returns the environment of the calling process as a list of     key=value pairs. Example:      \snippet code/src_corelib_io_qprocess.cpp 8      This function does not cache the system environment. Therefore, it's     possible to obtain an updated version of the environment if low-level C     library functions like \tt setenv ot \tt putenv have been called.      However, note that repeated calls to this function will recreate the     list of environment variables, which is a non-trivial operation.      \note For new code, it is recommended to use QProcessEnvironment::systemEnvironment()      \sa QProcessEnvironment::systemEnvironment(), environment(), setEnvironment() */
DECL|function|systemEnvironment
name|QStringList
name|QProcess
operator|::
name|systemEnvironment
parameter_list|()
block|{
name|QStringList
name|tmp
decl_stmt|;
name|char
modifier|*
name|entry
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|environ
index|[
name|count
operator|++
index|]
operator|)
condition|)
name|tmp
operator|<<
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QProcessEnvironment QProcessEnvironment::systemEnvironment()      \since 4.6      \brief The systemEnvironment function returns the environment of     the calling process.      It is returned as a QProcessEnvironment. This function does not     cache the system environment. Therefore, it's possible to obtain     an updated version of the environment if low-level C library     functions like \tt setenv ot \tt putenv have been called.      However, note that repeated calls to this function will recreate the     QProcessEnvironment object, which is a non-trivial operation.      \sa QProcess::systemEnvironment() */
end_comment
begin_comment
comment|/*!     \typedef Q_PID     \relates QProcess      Typedef for the identifiers used to represent processes on the underlying     platform. On Unix, this corresponds to \l qint64; on Windows, it     corresponds to \c{_PROCESS_INFORMATION*}.      \sa QProcess::pid() */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qprocess.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PROCESS
end_comment
end_unit
