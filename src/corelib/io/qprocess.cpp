begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Copyright (C) 2016 Intel Corporation. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QPROCESS_DEBUG
end_comment
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_include
include|#
directive|include
file|<qtimer.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
end_if
begin_include
include|#
directive|include
file|<qstring.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*     Returns a human readable representation of the first \a len     characters in \a data. */
DECL|function|qt_prettyDebug
specifier|static
name|QByteArray
name|qt_prettyDebug
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|maxSize
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
condition|)
return|return
literal|"(null)"
return|;
name|QByteArray
name|out
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
operator|&&
name|i
operator|<
name|maxSize
condition|;
operator|++
name|i
control|)
block|{
name|char
name|c
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|out
operator|+=
name|c
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|out
operator|+=
literal|"\\n"
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|out
operator|+=
literal|"\\r"
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|out
operator|+=
literal|"\\t"
expr_stmt|;
break|break;
default|default:
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
name|qsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"\\%3o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|out
operator|+=
name|QByteArray
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|<
name|maxSize
condition|)
name|out
operator|+=
literal|"..."
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
name|QT_END_NAMESPACE
endif|#
directive|endif
include|#
directive|include
file|"qprocess.h"
include|#
directive|include
file|"qprocess_p.h"
include|#
directive|include
file|<qbytearray.h>
include|#
directive|include
file|<qelapsedtimer.h>
include|#
directive|include
file|<qcoreapplication.h>
include|#
directive|include
file|<qsocketnotifier.h>
include|#
directive|include
file|<qtimer.h>
ifdef|#
directive|ifdef
name|Q_OS_WIN
include|#
directive|include
file|<qwineventnotifier.h>
else|#
directive|else
include|#
directive|include
file|<private/qcore_unix_p.h>
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_PROCESS
name|QT_BEGIN_NAMESPACE
comment|/*!     \since 5.6      \macro QT_NO_PROCESS_COMBINED_ARGUMENT_START     \relates QProcess      Disables the QProcess::start() overload taking a single string.     In most cases where it is used, the user intends for the first argument     to be treated atomically as per the other overload.      \sa QProcess::start() */
comment|/*!     \class QProcessEnvironment     \inmodule QtCore      \brief The QProcessEnvironment class holds the environment variables that     can be passed to a program.      \ingroup io     \ingroup misc     \ingroup shared     \reentrant     \since 4.6      A process's environment is composed of a set of key=value pairs known as     environment variables. The QProcessEnvironment class wraps that concept     and allows easy manipulation of those variables. It's meant to be used     along with QProcess, to set the environment for child processes. It     cannot be used to change the current process's environment.      The environment of the calling process can be obtained using     QProcessEnvironment::systemEnvironment().      On Unix systems, the variable names are case-sensitive. Note that the     Unix environment allows both variable names and contents to contain arbitrary     binary data (except for the NUL character). QProcessEnvironment will preserve     such variables, but does not support manipulating variables whose names or     values cannot be encoded by the current locale settings (see     QTextCodec::codecForLocale).      On Windows, the variable names are case-insensitive, but case-preserving.     QProcessEnvironment behaves accordingly.      On Windows CE, the concept of environment does not exist. This class will     keep the values set for compatibility with other platforms, but the values     set will have no effect on the processes being created.      \sa QProcess, QProcess::systemEnvironment(), QProcess::setProcessEnvironment() */
DECL|function|toList
name|QStringList
name|QProcessEnvironmentPrivate
operator|::
name|toList
parameter_list|()
specifier|const
block|{
name|QStringList
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|hash
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Hash
operator|::
name|const_iterator
name|it
init|=
name|hash
operator|.
name|cbegin
argument_list|()
init|,
name|end
init|=
name|hash
operator|.
name|cend
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|result
operator|<<
name|nameToString
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
operator|+
name|valueToString
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|fromList
name|QProcessEnvironment
name|QProcessEnvironmentPrivate
operator|::
name|fromList
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|list
parameter_list|)
block|{
name|QProcessEnvironment
name|env
decl_stmt|;
name|QStringList
operator|::
name|ConstIterator
name|it
init|=
name|list
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|list
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|int
name|pos
init|=
name|it
operator|->
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'='
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|1
condition|)
continue|continue;
name|QString
name|value
init|=
name|it
operator|->
name|mid
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
decl_stmt|;
name|QString
name|name
init|=
operator|*
name|it
decl_stmt|;
name|name
operator|.
name|truncate
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|env
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|env
return|;
block|}
end_function
begin_function
DECL|function|keys
name|QStringList
name|QProcessEnvironmentPrivate
operator|::
name|keys
parameter_list|()
specifier|const
block|{
name|QStringList
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|hash
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Hash
operator|::
name|ConstIterator
name|it
init|=
name|hash
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|hash
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|result
operator|<<
name|nameToString
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|insert
name|void
name|QProcessEnvironmentPrivate
operator|::
name|insert
parameter_list|(
specifier|const
name|QProcessEnvironmentPrivate
modifier|&
name|other
parameter_list|)
block|{
name|Hash
operator|::
name|ConstIterator
name|it
init|=
name|other
operator|.
name|hash
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|other
operator|.
name|hash
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|hash
operator|.
name|insert
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|QHash
argument_list|<
name|QString
argument_list|,
name|Key
argument_list|>
operator|::
name|ConstIterator
name|nit
init|=
name|other
operator|.
name|nameMap
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|nend
init|=
name|other
operator|.
name|nameMap
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|nit
operator|!=
name|nend
condition|;
operator|++
name|nit
control|)
name|nameMap
operator|.
name|insert
argument_list|(
name|nit
operator|.
name|key
argument_list|()
argument_list|,
name|nit
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Creates a new QProcessEnvironment object. This constructor creates an     empty environment. If set on a QProcess, this will cause the current     environment variables to be removed. */
end_comment
begin_constructor
DECL|function|QProcessEnvironment
name|QProcessEnvironment
operator|::
name|QProcessEnvironment
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Frees the resources associated with this QProcessEnvironment object. */
end_comment
begin_destructor
DECL|function|~QProcessEnvironment
name|QProcessEnvironment
operator|::
name|~
name|QProcessEnvironment
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Creates a QProcessEnvironment object that is a copy of \a other. */
end_comment
begin_constructor
DECL|function|QProcessEnvironment
name|QProcessEnvironment
operator|::
name|QProcessEnvironment
parameter_list|(
specifier|const
name|QProcessEnvironment
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Copies the contents of the \a other QProcessEnvironment object into this     one. */
end_comment
begin_function
DECL|function|operator =
name|QProcessEnvironment
modifier|&
name|QProcessEnvironment
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QProcessEnvironment
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QProcessEnvironment::swap(QProcessEnvironment&other)     \since 5.0      Swaps this process environment instance with \a other. This     function is very fast and never fails. */
end_comment
begin_comment
comment|/*!     \fn bool QProcessEnvironment::operator !=(const QProcessEnvironment&other) const      Returns \c true if this and the \a other QProcessEnvironment objects are different.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns \c true if this and the \a other QProcessEnvironment objects are equal.      Two QProcessEnvironment objects are considered equal if they have the same     set of key=value pairs. The comparison of keys is done case-sensitive on     platforms where the environment is case-sensitive.      \sa operator!=(), contains() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QProcessEnvironment
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QProcessEnvironment
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|==
name|other
operator|.
name|d
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|d
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|d
condition|)
block|{
name|QProcessEnvironmentPrivate
operator|::
name|OrderedMutexLocker
name|locker
argument_list|(
name|d
argument_list|,
name|other
operator|.
name|d
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|hash
operator|==
name|other
operator|.
name|d
operator|->
name|hash
return|;
block|}
else|else
block|{
return|return
name|isEmpty
argument_list|()
return|;
block|}
block|}
else|else
block|{
return|return
name|other
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this QProcessEnvironment object is empty: that is     there are no key=value pairs set.      \sa clear(), systemEnvironment(), insert() */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QProcessEnvironment
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
comment|// Needs no locking, as no hash nodes are accessed
return|return
name|d
condition|?
name|d
operator|->
name|hash
operator|.
name|isEmpty
argument_list|()
else|:
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Removes all key=value pairs from this QProcessEnvironment object, making     it empty.      \sa isEmpty(), systemEnvironment() */
end_comment
begin_function
DECL|function|clear
name|void
name|QProcessEnvironment
operator|::
name|clear
parameter_list|()
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|hash
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Unix: Don't clear d->nameMap, as the environment is likely to be
comment|// re-populated with the same keys again.
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the environment variable of name \a name is found in     this QProcessEnvironment object.       \sa insert(), value() */
end_comment
begin_function
DECL|function|contains
name|bool
name|QProcessEnvironment
operator|::
name|contains
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
name|QProcessEnvironmentPrivate
operator|::
name|MutexLocker
name|locker
argument_list|(
name|d
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|hash
operator|.
name|contains
argument_list|(
name|d
operator|->
name|prepareName
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts the environment variable of name \a name and contents \a value     into this QProcessEnvironment object. If that variable already existed,     it is replaced by the new value.      On most systems, inserting a variable with no contents will have the     same effect for applications as if the variable had not been set at all.     However, to guarantee that there are no incompatibilities, to remove a     variable, please use the remove() function.      \sa contains(), remove(), value() */
end_comment
begin_function
DECL|function|insert
name|void
name|QProcessEnvironment
operator|::
name|insert
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
comment|// our re-impl of detach() detaches from null
name|d
operator|.
name|detach
argument_list|()
expr_stmt|;
comment|// detach before prepareName()
name|d
operator|->
name|hash
operator|.
name|insert
argument_list|(
name|d
operator|->
name|prepareName
argument_list|(
name|name
argument_list|)
argument_list|,
name|d
operator|->
name|prepareValue
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes the environment variable identified by \a name from this     QProcessEnvironment object. If that variable did not exist before,     nothing happens.       \sa contains(), insert(), value() */
end_comment
begin_function
DECL|function|remove
name|void
name|QProcessEnvironment
operator|::
name|remove
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|d
condition|)
block|{
name|d
operator|.
name|detach
argument_list|()
expr_stmt|;
comment|// detach before prepareName()
name|d
operator|->
name|hash
operator|.
name|remove
argument_list|(
name|d
operator|->
name|prepareName
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Searches this QProcessEnvironment object for a variable identified by     \a name and returns its value. If the variable is not found in this object,     then \a defaultValue is returned instead.      \sa contains(), insert(), remove() */
end_comment
begin_function
DECL|function|value
name|QString
name|QProcessEnvironment
operator|::
name|value
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|defaultValue
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|defaultValue
return|;
name|QProcessEnvironmentPrivate
operator|::
name|MutexLocker
name|locker
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|QProcessEnvironmentPrivate
operator|::
name|Hash
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|hash
operator|.
name|constFind
argument_list|(
name|d
operator|->
name|prepareName
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|d
operator|->
name|hash
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|defaultValue
return|;
return|return
name|d
operator|->
name|valueToString
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Converts this QProcessEnvironment object into a list of strings, one for     each environment variable that is set. The environment variable's name     and its value are separated by an equal character ('=').      The QStringList contents returned by this function are suitable for     presentation.     Use with the QProcess::setEnvironment function is not recommended due to     potential encoding problems under Unix, and worse performance.      \sa systemEnvironment(), QProcess::systemEnvironment(),         QProcess::setProcessEnvironment() */
end_comment
begin_function
DECL|function|toStringList
name|QStringList
name|QProcessEnvironment
operator|::
name|toStringList
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QStringList
argument_list|()
return|;
name|QProcessEnvironmentPrivate
operator|::
name|MutexLocker
name|locker
argument_list|(
name|d
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|toList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns a list containing all the variable names in this QProcessEnvironment     object. */
end_comment
begin_function
DECL|function|keys
name|QStringList
name|QProcessEnvironment
operator|::
name|keys
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QStringList
argument_list|()
return|;
name|QProcessEnvironmentPrivate
operator|::
name|MutexLocker
name|locker
argument_list|(
name|d
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|keys
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.8      Inserts the contents of \a e in this QProcessEnvironment object. Variables in     this object that also exist in \a e will be overwritten. */
end_comment
begin_function
DECL|function|insert
name|void
name|QProcessEnvironment
operator|::
name|insert
parameter_list|(
specifier|const
name|QProcessEnvironment
modifier|&
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|e
operator|.
name|d
condition|)
return|return;
comment|// our re-impl of detach() detaches from null
name|QProcessEnvironmentPrivate
operator|::
name|MutexLocker
name|locker
argument_list|(
name|e
operator|.
name|d
argument_list|)
decl_stmt|;
name|d
operator|->
name|insert
argument_list|(
operator|*
name|e
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clear
name|void
name|QProcessPrivate
operator|::
name|Channel
operator|::
name|clear
parameter_list|()
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PipeSource
case|:
name|Q_ASSERT
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|process
operator|->
name|stdinChannel
operator|.
name|type
operator|=
name|Normal
expr_stmt|;
name|process
operator|->
name|stdinChannel
operator|.
name|process
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PipeSink
case|:
name|Q_ASSERT
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|process
operator|->
name|stdoutChannel
operator|.
name|type
operator|=
name|Normal
expr_stmt|;
name|process
operator|->
name|stdoutChannel
operator|.
name|process
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|Normal
expr_stmt|;
name|file
operator|.
name|clear
argument_list|()
expr_stmt|;
name|process
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn bool QProcessPrivate::startDetached(const QString&program, const QStringList&arguments, const QString&workingDirectory, qint64 *pid)  \internal  */
end_comment
begin_comment
comment|/*!     \class QProcess     \inmodule QtCore      \brief The QProcess class is used to start external programs and     to communicate with them.      \ingroup io      \reentrant      \section1 Running a Process      To start a process, pass the name and command line arguments of     the program you want to run as arguments to start(). Arguments     are supplied as individual strings in a QStringList.      Alternatively, you can set the program to run with setProgram()     and setArguments(), and then call start() or open().      For example, the following code snippet runs the analog clock     example in the Fusion style on X11 platforms by passing strings     containing "-style" and "fusion" as two items in the list of     arguments:      \snippet qprocess/qprocess-simpleexecution.cpp 0     \dots     \snippet qprocess/qprocess-simpleexecution.cpp 1     \snippet qprocess/qprocess-simpleexecution.cpp 2      QProcess then enters the \l Starting state, and when the program     has started, QProcess enters the \l Running state and emits     started().      QProcess allows you to treat a process as a sequential I/O     device. You can write to and read from the process just as you     would access a network connection using QTcpSocket. You can then     write to the process's standard input by calling write(), and     read the standard output by calling read(), readLine(), and     getChar(). Because it inherits QIODevice, QProcess can also be     used as an input source for QXmlReader, or for generating data to     be uploaded using QNetworkAccessManager.      \note On Windows CE, reading and writing to a process     is not supported.      When the process exits, QProcess reenters the \l NotRunning state     (the initial state), and emits finished().      The finished() signal provides the exit code and exit status of     the process as arguments, and you can also call exitCode() to     obtain the exit code of the last process that finished, and     exitStatus() to obtain its exit status. If an error occurs at     any point in time, QProcess will emit the errorOccurred() signal.     You can also call error() to find the type of error that occurred     last, and state() to find the current process state.      \section1 Communicating via Channels      Processes have two predefined output channels: The standard     output channel (\c stdout) supplies regular console output, and     the standard error channel (\c stderr) usually supplies the     errors that are printed by the process. These channels represent     two separate streams of data. You can toggle between them by     calling setReadChannel(). QProcess emits readyRead() when data is     available on the current read channel. It also emits     readyReadStandardOutput() when new standard output data is     available, and when new standard error data is available,     readyReadStandardError() is emitted. Instead of calling read(),     readLine(), or getChar(), you can explicitly read all data from     either of the two channels by calling readAllStandardOutput() or     readAllStandardError().      The terminology for the channels can be misleading. Be aware that     the process's output channels correspond to QProcess's     \e read channels, whereas the process's input channels correspond     to QProcess's \e write channels. This is because what we read     using QProcess is the process's output, and what we write becomes     the process's input.      QProcess can merge the two output channels, so that standard     output and standard error data from the running process both use     the standard output channel. Call setProcessChannelMode() with     MergedChannels before starting the process to activate     this feature. You also have the option of forwarding the output of     the running process to the calling, main process, by passing     ForwardedChannels as the argument. It is also possible to forward     only one of the output channels - typically one would use     ForwardedErrorChannel, but ForwardedOutputChannel also exists.     Note that using channel forwarding is typically a bad idea in GUI     applications - you should present errors graphically instead.      Certain processes need special environment settings in order to     operate. You can set environment variables for your process by     calling setProcessEnvironment(). To set a working directory, call     setWorkingDirectory(). By default, processes are run in the     current working directory of the calling process.      The positioning and the screen Z-order of windows belonging to     GUI applications started with QProcess are controlled by     the underlying windowing system. For Qt 5 applications, the     positioning can be specified using the \c{-qwindowgeometry}     command line option; X11 applications generally accept a     \c{-geometry} command line option.      \note On QNX, setting the working directory may cause all     application threads, with the exception of the QProcess caller     thread, to temporarily freeze during the spawning process,     owing to a limitation in the operating system.      \section1 Synchronous Process API      QProcess provides a set of functions which allow it to be used     without an event loop, by suspending the calling thread until     certain signals are emitted:      \list     \li waitForStarted() blocks until the process has started.      \li waitForReadyRead() blocks until new data is     available for reading on the current read channel.      \li waitForBytesWritten() blocks until one payload of     data has been written to the process.      \li waitForFinished() blocks until the process has finished.     \endlist      Calling these functions from the main thread (the thread that     calls QApplication::exec()) may cause your user interface to     freeze.      The following example runs \c gzip to compress the string "Qt     rocks!", without an event loop:      \snippet process/process.cpp 0      \section1 Notes for Windows Users      Some Windows commands (for example, \c dir) are not provided by     separate applications, but by the command interpreter itself.     If you attempt to use QProcess to execute these commands directly,     it won't work. One possible solution is to execute the command     interpreter itself (\c{cmd.exe} on some Windows systems), and ask     the interpreter to execute the desired command.      \sa QBuffer, QFile, QTcpSocket */
end_comment
begin_comment
comment|/*!     \enum QProcess::ProcessChannel      This enum describes the process channels used by the running process.     Pass one of these values to setReadChannel() to set the     current read channel of QProcess.      \value StandardOutput The standard output (stdout) of the running            process.      \value StandardError The standard error (stderr) of the running            process.      \sa setReadChannel() */
end_comment
begin_comment
comment|/*!     \enum QProcess::ProcessChannelMode      This enum describes the process output channel modes of QProcess.     Pass one of these values to setProcessChannelMode() to set the     current read channel mode.      \value SeparateChannels QProcess manages the output of the     running process, keeping standard output and standard error data     in separate internal buffers. You can select the QProcess's     current read channel by calling setReadChannel(). This is the     default channel mode of QProcess.      \value MergedChannels QProcess merges the output of the running     process into the standard output channel (\c stdout). The     standard error channel (\c stderr) will not receive any data. The     standard output and standard error data of the running process     are interleaved.      \value ForwardedChannels QProcess forwards the output of the     running process onto the main process. Anything the child process     writes to its standard output and standard error will be written     to the standard output and standard error of the main process.      \value ForwardedErrorChannel QProcess manages the standard output     of the running process, but forwards its standard error onto the     main process. This reflects the typical use of command line tools     as filters, where the standard output is redirected to another     process or a file, while standard error is printed to the console     for diagnostic purposes.     (This value was introduced in Qt 5.2.)      \value ForwardedOutputChannel Complementary to ForwardedErrorChannel.     (This value was introduced in Qt 5.2.)      \note Windows intentionally suppresses output from GUI-only     applications to inherited consoles.     This does \e not apply to output redirected to files or pipes.     To forward the output of GUI-only applications on the console     nonetheless, you must use SeparateChannels and do the forwarding     yourself by reading the output and writing it to the appropriate     output channels.      \sa setProcessChannelMode() */
end_comment
begin_comment
comment|/*!     \enum QProcess::InputChannelMode     \since 5.2      This enum describes the process input channel modes of QProcess.     Pass one of these values to setInputChannelMode() to set the     current write channel mode.      \value ManagedInputChannel QProcess manages the input of the running     process. This is the default input channel mode of QProcess.      \value ForwardedInputChannel QProcess forwards the input of the main     process onto the running process. The child process reads its standard     input from the same source as the main process.     Note that the main process must not try to read its standard input     while the child process is running.      \sa setInputChannelMode() */
end_comment
begin_comment
comment|/*!     \enum QProcess::ProcessError      This enum describes the different types of errors that are     reported by QProcess.      \value FailedToStart The process failed to start. Either the     invoked program is missing, or you may have insufficient     permissions to invoke the program.      \value Crashed The process crashed some time after starting     successfully.      \value Timedout The last waitFor...() function timed out. The     state of QProcess is unchanged, and you can try calling     waitFor...() again.      \value WriteError An error occurred when attempting to write to the     process. For example, the process may not be running, or it may     have closed its input channel.      \value ReadError An error occurred when attempting to read from     the process. For example, the process may not be running.      \value UnknownError An unknown error occurred. This is the default     return value of error().      \sa error() */
end_comment
begin_comment
comment|/*!     \enum QProcess::ProcessState      This enum describes the different states of QProcess.      \value NotRunning The process is not running.      \value Starting The process is starting, but the program has not     yet been invoked.      \value Running The process is running and is ready for reading and     writing.      \sa state() */
end_comment
begin_comment
comment|/*!     \enum QProcess::ExitStatus      This enum describes the different exit statuses of QProcess.      \value NormalExit The process exited normally.      \value CrashExit The process crashed.      \sa exitStatus() */
end_comment
begin_comment
comment|/*!     \typedef QProcess::CreateProcessArgumentModifier     \note This typedef is only available on desktop Windows and Windows CE.      On Windows, QProcess uses the Win32 API function \c CreateProcess to     start child processes. While QProcess provides a comfortable way to start     processes without worrying about platform     details, it is in some cases desirable to fine-tune the parameters that are     passed to \c CreateProcess. This is done by defining a     \c CreateProcessArgumentModifier function and passing it to     \c setCreateProcessArgumentsModifier.      A \c CreateProcessArgumentModifier function takes one parameter: a pointer     to a \c CreateProcessArguments struct. The members of this struct will be     passed to \c CreateProcess after the \c CreateProcessArgumentModifier     function is called.      The following example demonstrates how to pass custom flags to     \c CreateProcess.     When starting a console process B from a console process A, QProcess will     reuse the console window of process A for process B by default. In this     example, a new console window with a custom color scheme is created for the     child process B instead.      \snippet qprocess/qprocess-createprocessargumentsmodifier.cpp 0      \sa QProcess::CreateProcessArguments     \sa setCreateProcessArgumentsModifier() */
end_comment
begin_comment
comment|/*!     \class QProcess::CreateProcessArguments     \note This struct is only available on the Windows platform.      This struct is a representation of all parameters of the Windows API     function \c CreateProcess. It is used as parameter for     \c CreateProcessArgumentModifier functions.      \sa QProcess::CreateProcessArgumentModifier */
end_comment
begin_comment
comment|/*!     \fn void QProcess::error(QProcess::ProcessError error)     \obsolete      Use errorOccurred() instead. */
end_comment
begin_comment
comment|/*!     \fn void QProcess::errorOccurred(QProcess::ProcessError error)     \since 5.6      This signal is emitted when an error occurs with the process. The     specified \a error describes the type of error that occurred. */
end_comment
begin_comment
comment|/*!     \fn void QProcess::started()      This signal is emitted by QProcess when the process has started,     and state() returns \l Running. */
end_comment
begin_comment
comment|/*!     \fn void QProcess::stateChanged(QProcess::ProcessState newState)      This signal is emitted whenever the state of QProcess changes. The     \a newState argument is the state QProcess changed to. */
end_comment
begin_comment
comment|/*!     \fn void QProcess::finished(int exitCode)     \obsolete     \overload      Use finished(int exitCode, QProcess::ExitStatus status) instead. */
end_comment
begin_comment
comment|/*!     \fn void QProcess::finished(int exitCode, QProcess::ExitStatus exitStatus)      This signal is emitted when the process finishes. \a exitCode is the exit     code of the process (only valid for normal exits), and \a exitStatus is     the exit status.     After the process has finished, the buffers in QProcess are still intact.     You can still read any data that the process may have written before it     finished.      \sa exitStatus() */
end_comment
begin_comment
comment|/*!     \fn void QProcess::readyReadStandardOutput()      This signal is emitted when the process has made new data     available through its standard output channel (\c stdout). It is     emitted regardless of the current \l{readChannel()}{read channel}.      \sa readAllStandardOutput(), readChannel() */
end_comment
begin_comment
comment|/*!     \fn void QProcess::readyReadStandardError()      This signal is emitted when the process has made new data     available through its standard error channel (\c stderr). It is     emitted regardless of the current \l{readChannel()}{read     channel}.      \sa readAllStandardError(), readChannel() */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QProcessPrivate
name|QProcessPrivate
operator|::
name|QProcessPrivate
parameter_list|()
block|{
name|processChannel
operator|=
name|QProcess
operator|::
name|StandardOutput
expr_stmt|;
name|processChannelMode
operator|=
name|QProcess
operator|::
name|SeparateChannels
expr_stmt|;
name|inputChannelMode
operator|=
name|QProcess
operator|::
name|ManagedInputChannel
expr_stmt|;
name|processError
operator|=
name|QProcess
operator|::
name|UnknownError
expr_stmt|;
name|processState
operator|=
name|QProcess
operator|::
name|NotRunning
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
name|sequenceNumber
operator|=
literal|0
expr_stmt|;
name|exitCode
operator|=
literal|0
expr_stmt|;
name|exitStatus
operator|=
name|QProcess
operator|::
name|NormalExit
expr_stmt|;
name|startupSocketNotifier
operator|=
literal|0
expr_stmt|;
name|deathNotifier
operator|=
literal|0
expr_stmt|;
name|childStartedPipe
index|[
literal|0
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
name|childStartedPipe
index|[
literal|1
index|]
operator|=
name|INVALID_Q_PIPE
expr_stmt|;
name|forkfd
operator|=
operator|-
literal|1
expr_stmt|;
name|crashed
operator|=
literal|false
expr_stmt|;
name|dying
operator|=
literal|false
expr_stmt|;
name|emittedReadyRead
operator|=
literal|false
expr_stmt|;
name|emittedBytesWritten
operator|=
literal|false
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|stdinWriteTrigger
operator|=
literal|0
expr_stmt|;
name|processFinishedNotifier
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|// Q_OS_WIN
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_destructor
DECL|function|~QProcessPrivate
name|QProcessPrivate
operator|::
name|~
name|QProcessPrivate
parameter_list|()
block|{
if|if
condition|(
name|stdinChannel
operator|.
name|process
condition|)
name|stdinChannel
operator|.
name|process
operator|->
name|stdoutChannel
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|process
condition|)
name|stdoutChannel
operator|.
name|process
operator|->
name|stdinChannel
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|cleanup
name|void
name|QProcessPrivate
operator|::
name|cleanup
parameter_list|()
block|{
name|q_func
argument_list|()
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|NotRunning
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
name|pid
condition|)
block|{
name|CloseHandle
argument_list|(
name|pid
operator|->
name|hThread
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|pid
operator|->
name|hProcess
argument_list|)
expr_stmt|;
operator|delete
name|pid
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|stdinWriteTrigger
condition|)
block|{
operator|delete
name|stdinWriteTrigger
expr_stmt|;
name|stdinWriteTrigger
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|processFinishedNotifier
condition|)
block|{
operator|delete
name|processFinishedNotifier
expr_stmt|;
name|processFinishedNotifier
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|pid
operator|=
literal|0
expr_stmt|;
name|sequenceNumber
operator|=
literal|0
expr_stmt|;
name|dying
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|stdoutChannel
operator|.
name|notifier
condition|)
block|{
operator|delete
name|stdoutChannel
operator|.
name|notifier
expr_stmt|;
name|stdoutChannel
operator|.
name|notifier
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|stderrChannel
operator|.
name|notifier
condition|)
block|{
operator|delete
name|stderrChannel
operator|.
name|notifier
expr_stmt|;
name|stderrChannel
operator|.
name|notifier
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|stdinChannel
operator|.
name|notifier
condition|)
block|{
operator|delete
name|stdinChannel
operator|.
name|notifier
expr_stmt|;
name|stdinChannel
operator|.
name|notifier
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|startupSocketNotifier
condition|)
block|{
operator|delete
name|startupSocketNotifier
expr_stmt|;
name|startupSocketNotifier
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|deathNotifier
condition|)
block|{
operator|delete
name|deathNotifier
expr_stmt|;
name|deathNotifier
operator|=
literal|0
expr_stmt|;
block|}
name|closeChannel
argument_list|(
operator|&
name|stdoutChannel
argument_list|)
expr_stmt|;
name|closeChannel
argument_list|(
operator|&
name|stderrChannel
argument_list|)
expr_stmt|;
name|closeChannel
argument_list|(
operator|&
name|stdinChannel
argument_list|)
expr_stmt|;
name|destroyPipe
argument_list|(
name|childStartedPipe
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_UNIX
if|if
condition|(
name|forkfd
operator|!=
operator|-
literal|1
condition|)
name|qt_safe_close
argument_list|(
name|forkfd
argument_list|)
expr_stmt|;
name|forkfd
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setError
name|void
name|QProcessPrivate
operator|::
name|setError
parameter_list|(
name|QProcess
operator|::
name|ProcessError
name|error
parameter_list|,
specifier|const
name|QString
modifier|&
name|description
parameter_list|)
block|{
name|processError
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|description
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|QProcess
operator|::
name|FailedToStart
case|:
name|errorString
operator|=
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process failed to start"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QProcess
operator|::
name|Crashed
case|:
name|errorString
operator|=
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process crashed"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QProcess
operator|::
name|Timedout
case|:
name|errorString
operator|=
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process operation timed out"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QProcess
operator|::
name|ReadError
case|:
name|errorString
operator|=
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Error reading from process"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QProcess
operator|::
name|WriteError
case|:
name|errorString
operator|=
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Error writing to process"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QProcess
operator|::
name|UnknownError
case|:
name|errorString
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|errorString
operator|=
name|description
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setErrorAndEmit
name|void
name|QProcessPrivate
operator|::
name|setErrorAndEmit
parameter_list|(
name|QProcess
operator|::
name|ProcessError
name|error
parameter_list|,
specifier|const
name|QString
modifier|&
name|description
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|error
operator|!=
name|QProcess
operator|::
name|UnknownError
argument_list|)
expr_stmt|;
name|setError
argument_list|(
name|error
argument_list|,
name|description
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|errorOccurred
argument_list|(
name|processError
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|processError
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal     Returns true if we emitted readyRead(). */
end_comment
begin_function
DECL|function|tryReadFromChannel
name|bool
name|QProcessPrivate
operator|::
name|tryReadFromChannel
parameter_list|(
name|Channel
modifier|*
name|channel
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|->
name|pipe
index|[
literal|0
index|]
operator|==
name|INVALID_Q_PIPE
condition|)
return|return
literal|false
return|;
name|qint64
name|available
init|=
name|bytesAvailableInChannel
argument_list|(
name|channel
argument_list|)
decl_stmt|;
if|if
condition|(
name|available
operator|==
literal|0
condition|)
name|available
operator|=
literal|1
expr_stmt|;
comment|// always try to read at least one byte
name|char
modifier|*
name|ptr
init|=
name|channel
operator|->
name|buffer
operator|.
name|reserve
argument_list|(
name|available
argument_list|)
decl_stmt|;
name|qint64
name|readBytes
init|=
name|readFromChannel
argument_list|(
name|channel
argument_list|,
name|ptr
argument_list|,
name|available
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBytes
operator|<=
literal|0
condition|)
name|channel
operator|->
name|buffer
operator|.
name|chop
argument_list|(
name|available
argument_list|)
expr_stmt|;
if|if
condition|(
name|readBytes
operator|==
operator|-
literal|2
condition|)
block|{
comment|// EWOULDBLOCK
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readBytes
operator|==
operator|-
literal|1
condition|)
block|{
name|setErrorAndEmit
argument_list|(
name|QProcess
operator|::
name|ReadError
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::tryReadFromChannel(%d), failed to read from the process"
argument_list|,
name|channel
operator|-
operator|&
name|stdinChannel
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readBytes
operator|==
literal|0
condition|)
block|{
comment|// EOF
if|if
condition|(
name|channel
operator|->
name|notifier
condition|)
name|channel
operator|->
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|closeChannel
argument_list|(
name|channel
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::tryReadFromChannel(%d), 0 bytes available"
argument_list|,
name|channel
operator|-
operator|&
name|stdinChannel
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::tryReadFromChannel(%d), read %d bytes from the process' output"
argument_list|,
argument|channel -&stdinChannel             int(readBytes)
argument_list|)
empty_stmt|;
endif|#
directive|endif
if|if
condition|(
name|channel
operator|->
name|closed
condition|)
block|{
name|channel
operator|->
name|buffer
operator|.
name|chop
argument_list|(
name|readBytes
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|channel
operator|->
name|buffer
operator|.
name|chop
argument_list|(
name|available
operator|-
name|readBytes
argument_list|)
expr_stmt|;
name|bool
name|didRead
init|=
literal|false
decl_stmt|;
name|bool
name|isStdout
init|=
name|channel
operator|==
operator|&
name|stdoutChannel
decl_stmt|;
if|if
condition|(
name|readBytes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|channel
operator|->
name|notifier
condition|)
name|channel
operator|->
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardOutput
operator|)
operator|==
name|isStdout
condition|)
block|{
name|didRead
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|emittedReadyRead
condition|)
block|{
name|emittedReadyRead
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|readyRead
argument_list|()
emit|;
name|emittedReadyRead
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isStdout
condition|)
emit|emit
name|q
operator|->
name|readyReadStandardOutput
argument_list|(
name|QProcess
operator|::
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
else|else
emit|emit
name|q
operator|->
name|readyReadStandardError
argument_list|(
name|QProcess
operator|::
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
return|return
name|didRead
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_canReadStandardOutput
name|bool
name|QProcessPrivate
operator|::
name|_q_canReadStandardOutput
parameter_list|()
block|{
return|return
name|tryReadFromChannel
argument_list|(
operator|&
name|stdoutChannel
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_canReadStandardError
name|bool
name|QProcessPrivate
operator|::
name|_q_canReadStandardError
parameter_list|()
block|{
return|return
name|tryReadFromChannel
argument_list|(
operator|&
name|stderrChannel
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_canWrite
name|bool
name|QProcessPrivate
operator|::
name|_q_canWrite
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdinChannel
operator|.
name|notifier
condition|)
name|stdinChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdinChannel
operator|.
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::canWrite(), not writing anything (empty write buffer)."
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
name|qint64
name|written
init|=
name|writeToStdin
argument_list|(
name|stdinChannel
operator|.
name|buffer
operator|.
name|readPointer
argument_list|()
argument_list|,
name|stdinChannel
operator|.
name|buffer
operator|.
name|nextDataBlockSize
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|written
operator|<
literal|0
condition|)
block|{
name|closeChannel
argument_list|(
operator|&
name|stdinChannel
argument_list|)
expr_stmt|;
name|setErrorAndEmit
argument_list|(
name|QProcess
operator|::
name|WriteError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::canWrite(), wrote %d bytes to the process input"
argument_list|,
name|int
argument_list|(
name|written
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|written
operator|!=
literal|0
condition|)
block|{
name|stdinChannel
operator|.
name|buffer
operator|.
name|free
argument_list|(
name|written
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|emittedBytesWritten
condition|)
block|{
name|emittedBytesWritten
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|bytesWritten
argument_list|(
name|written
argument_list|)
emit|;
name|emittedBytesWritten
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stdinChannel
operator|.
name|notifier
operator|&&
operator|!
name|stdinChannel
operator|.
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|stdinChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdinChannel
operator|.
name|buffer
operator|.
name|isEmpty
argument_list|()
operator|&&
name|stdinChannel
operator|.
name|closed
condition|)
name|closeWriteChannel
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_processDied
name|bool
name|QProcessPrivate
operator|::
name|_q_processDied
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::_q_processDied()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_UNIX
if|if
condition|(
operator|!
name|waitForDeadChild
argument_list|()
condition|)
return|return
literal|false
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
name|processFinishedNotifier
condition|)
name|processFinishedNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|drainOutputPipes
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// the process may have died before it got a chance to report that it was
comment|// either running or stopped, so we will call _q_startupNotification() and
comment|// give it a chance to emit started() or errorOccurred(FailedToStart).
if|if
condition|(
name|processState
operator|==
name|QProcess
operator|::
name|Starting
condition|)
block|{
if|if
condition|(
operator|!
name|_q_startupNotification
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
if|if
condition|(
name|dying
condition|)
block|{
comment|// at this point we know the process is dead. prevent
comment|// reentering this slot recursively by calling waitForFinished()
comment|// or opening a dialog inside slots connected to the readyRead
comment|// signals emitted below.
return|return
literal|true
return|;
block|}
name|dying
operator|=
literal|true
expr_stmt|;
comment|// in case there is data in the pipe line and this slot by chance
comment|// got called before the read notifications, call these two slots
comment|// so the data is made available before the process dies.
name|_q_canReadStandardOutput
argument_list|()
expr_stmt|;
name|_q_canReadStandardError
argument_list|()
expr_stmt|;
name|findExitCode
argument_list|()
expr_stmt|;
if|if
condition|(
name|crashed
condition|)
block|{
name|exitStatus
operator|=
name|QProcess
operator|::
name|CrashExit
expr_stmt|;
name|setErrorAndEmit
argument_list|(
name|QProcess
operator|::
name|Crashed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QPROCESS_USE_SPAWN
comment|// if we're using posix_spawn, waitForStarted always succeeds.
comment|// POSIX documents that the sub-process launched by posix_spawn will exit with code
comment|// 127 if anything prevents the target program from starting.
comment|// http://pubs.opengroup.org/onlinepubs/009695399/functions/posix_spawn.html
if|if
condition|(
name|exitStatus
operator|==
name|QProcess
operator|::
name|NormalExit
operator|&&
name|exitCode
operator|==
literal|127
condition|)
block|{
name|setError
argument_list|(
name|QProcess
operator|::
name|FailedToStart
argument_list|,
name|QProcess
operator|::
name|tr
argument_list|(
literal|"Process failed to start (spawned process exited with code 127)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|bool
name|wasRunning
init|=
operator|(
name|processState
operator|==
name|QProcess
operator|::
name|Running
operator|)
decl_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
name|wasRunning
condition|)
block|{
comment|// we received EOF now:
emit|emit
name|q
operator|->
name|readChannelFinished
argument_list|()
emit|;
comment|// in the future:
comment|//emit q->standardOutputClosed();
comment|//emit q->standardErrorClosed();
emit|emit
name|q
operator|->
name|finished
argument_list|(
name|exitCode
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|finished
argument_list|(
name|exitCode
argument_list|,
name|exitStatus
argument_list|)
emit|;
block|}
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::_q_processDied() process is dead"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_startupNotification
name|bool
name|QProcessPrivate
operator|::
name|_q_startupNotification
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::startupNotification()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|startupSocketNotifier
condition|)
name|startupSocketNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|QString
name|errorMessage
decl_stmt|;
if|if
condition|(
name|processStarted
argument_list|(
operator|&
name|errorMessage
argument_list|)
condition|)
block|{
name|q
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|Running
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|started
argument_list|(
name|QProcess
operator|::
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
return|return
literal|true
return|;
block|}
name|q
operator|->
name|setProcessState
argument_list|(
name|QProcess
operator|::
name|NotRunning
argument_list|)
expr_stmt|;
name|setErrorAndEmit
argument_list|(
name|QProcess
operator|::
name|FailedToStart
argument_list|,
name|errorMessage
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_UNIX
comment|// make sure the process manager removes this entry
name|waitForDeadChild
argument_list|()
expr_stmt|;
name|findExitCode
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cleanup
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|closeWriteChannel
name|void
name|QProcessPrivate
operator|::
name|closeWriteChannel
parameter_list|()
block|{
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcessPrivate::closeWriteChannel()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stdinChannel
operator|.
name|notifier
condition|)
block|{
operator|delete
name|stdinChannel
operator|.
name|notifier
expr_stmt|;
name|stdinChannel
operator|.
name|notifier
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// ### Find a better fix, feeding the process little by little
comment|// instead.
name|flushPipeWriter
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|closeChannel
argument_list|(
operator|&
name|stdinChannel
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs a QProcess object with the given \a parent. */
end_comment
begin_constructor
DECL|function|QProcess
name|QProcess
operator|::
name|QProcess
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
operator|*
operator|new
name|QProcessPrivate
argument_list|,
name|parent
argument_list|)
block|{
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::QProcess(%p)"
argument_list|,
name|parent
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_comment
comment|/*!     Destructs the QProcess object, i.e., killing the process.      Note that this function will not return until the process is     terminated. */
end_comment
begin_destructor
DECL|function|~QProcess
name|QProcess
operator|::
name|~
name|QProcess
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|!=
name|NotRunning
condition|)
block|{
name|qWarning
argument_list|()
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QProcess: Destroyed while process ("
operator|<<
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|program
argument_list|()
argument_list|)
operator|<<
literal|") is still running."
expr_stmt|;
name|kill
argument_list|()
expr_stmt|;
name|waitForFinished
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Q_OS_UNIX
comment|// make sure the process manager removes this entry
name|d
operator|->
name|findExitCode
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \obsolete     Returns the read channel mode of the QProcess. This function is     equivalent to processChannelMode()      \sa processChannelMode() */
end_comment
begin_function
DECL|function|readChannelMode
name|QProcess
operator|::
name|ProcessChannelMode
name|QProcess
operator|::
name|readChannelMode
parameter_list|()
specifier|const
block|{
return|return
name|processChannelMode
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use setProcessChannelMode(\a mode) instead.      \sa setProcessChannelMode() */
end_comment
begin_function
DECL|function|setReadChannelMode
name|void
name|QProcess
operator|::
name|setReadChannelMode
parameter_list|(
name|ProcessChannelMode
name|mode
parameter_list|)
block|{
name|setProcessChannelMode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the channel mode of the QProcess standard output and     standard error channels.      \sa setProcessChannelMode(), ProcessChannelMode, setReadChannel() */
end_comment
begin_function
DECL|function|processChannelMode
name|QProcess
operator|::
name|ProcessChannelMode
name|QProcess
operator|::
name|processChannelMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|processChannelMode
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets the channel mode of the QProcess standard output and standard     error channels to the \a mode specified.     This mode will be used the next time start() is called. For example:      \snippet code/src_corelib_io_qprocess.cpp 0      \sa processChannelMode(), ProcessChannelMode, setReadChannel() */
end_comment
begin_function
DECL|function|setProcessChannelMode
name|void
name|QProcess
operator|::
name|setProcessChannelMode
parameter_list|(
name|ProcessChannelMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|processChannelMode
operator|=
name|mode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2      Returns the channel mode of the QProcess standard input channel.      \sa setInputChannelMode(), InputChannelMode */
end_comment
begin_function
DECL|function|inputChannelMode
name|QProcess
operator|::
name|InputChannelMode
name|QProcess
operator|::
name|inputChannelMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|inputChannelMode
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2      Sets the channel mode of the QProcess standard input     channel to the \a mode specified.     This mode will be used the next time start() is called.      \sa inputChannelMode(), InputChannelMode */
end_comment
begin_function
DECL|function|setInputChannelMode
name|void
name|QProcess
operator|::
name|setInputChannelMode
parameter_list|(
name|InputChannelMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|inputChannelMode
operator|=
name|mode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current read channel of the QProcess.      \sa setReadChannel() */
end_comment
begin_function
DECL|function|readChannel
name|QProcess
operator|::
name|ProcessChannel
name|QProcess
operator|::
name|readChannel
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|processChannel
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the current read channel of the QProcess to the given \a     channel. The current input channel is used by the functions     read(), readAll(), readLine(), and getChar(). It also determines     which channel triggers QProcess to emit readyRead().      \sa readChannel() */
end_comment
begin_function
DECL|function|setReadChannel
name|void
name|QProcess
operator|::
name|setReadChannel
parameter_list|(
name|ProcessChannel
name|channel
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|transactionStarted
condition|)
block|{
name|qWarning
argument_list|(
literal|"QProcess::setReadChannel: Failed due to the active read transaction"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|processChannel
operator|!=
name|channel
condition|)
block|{
name|QRingBuffer
modifier|*
name|buffer
init|=
operator|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardOutput
operator|)
condition|?
operator|&
name|d
operator|->
name|stdoutChannel
operator|.
name|buffer
else|:
operator|&
name|d
operator|->
name|stderrChannel
operator|.
name|buffer
decl_stmt|;
name|d
operator|->
name|buffer
operator|.
name|read
argument_list|(
name|buffer
operator|->
name|reserveFront
argument_list|(
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|processChannel
operator|=
name|channel
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Closes the read channel \a channel. After calling this function,     QProcess will no longer receive data on the channel. Any data that     has already been received is still available for reading.      Call this function to save memory, if you are not interested in     the output of the process.      \sa closeWriteChannel(), setReadChannel() */
end_comment
begin_function
DECL|function|closeReadChannel
name|void
name|QProcess
operator|::
name|closeReadChannel
parameter_list|(
name|ProcessChannel
name|channel
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|StandardOutput
condition|)
name|d
operator|->
name|stdoutChannel
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
else|else
name|d
operator|->
name|stderrChannel
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Schedules the write channel of QProcess to be closed. The channel     will close once all data has been written to the process. After     calling this function, any attempts to write to the process will     fail.      Closing the write channel is necessary for programs that read     input data until the channel has been closed. For example, the     program "more" is used to display text data in a console on both     Unix and Windows. But it will not display the text data until     QProcess's write channel has been closed. Example:      \snippet code/src_corelib_io_qprocess.cpp 1      The write channel is implicitly opened when start() is called.      \sa closeReadChannel() */
end_comment
begin_function
DECL|function|closeWriteChannel
name|void
name|QProcess
operator|::
name|closeWriteChannel
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|stdinChannel
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
comment|// closing
if|if
condition|(
name|d
operator|->
name|stdinChannel
operator|.
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|closeWriteChannel
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Redirects the process' standard input to the file indicated by \a     fileName. When an input redirection is in place, the QProcess     object will be in read-only mode (calling write() will result in     error).      To make the process read EOF right away, pass nullDevice() here.     This is cleaner than using closeWriteChannel() before writing any     data, because it can be set up prior to starting the process.      If the file \a fileName does not exist at the moment start() is     called or is not readable, starting the process will fail.      Calling setStandardInputFile() after the process has started has no     effect.      \sa setStandardOutputFile(), setStandardErrorFile(),         setStandardOutputProcess() */
end_comment
begin_function
DECL|function|setStandardInputFile
name|void
name|QProcess
operator|::
name|setStandardInputFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|stdinChannel
operator|=
name|fileName
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Redirects the process' standard output to the file \a     fileName. When the redirection is in place, the standard output     read channel is closed: reading from it using read() will always     fail, as will readAllStandardOutput().      To discard all standard output from the process, pass nullDevice()     here. This is more efficient than simply never reading the standard     output, as no QProcess buffers are filled.      If the file \a fileName doesn't exist at the moment start() is     called, it will be created. If it cannot be created, the starting     will fail.      If the file exists and \a mode is QIODevice::Truncate, the file     will be truncated. Otherwise (if \a mode is QIODevice::Append),     the file will be appended to.      Calling setStandardOutputFile() after the process has started has     no effect.      \sa setStandardInputFile(), setStandardErrorFile(),         setStandardOutputProcess() */
end_comment
begin_function
DECL|function|setStandardOutputFile
name|void
name|QProcess
operator|::
name|setStandardOutputFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|OpenMode
name|mode
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|mode
operator|==
name|Append
operator|||
name|mode
operator|==
name|Truncate
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|stdoutChannel
operator|=
name|fileName
expr_stmt|;
name|d
operator|->
name|stdoutChannel
operator|.
name|append
operator|=
name|mode
operator|==
name|Append
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Redirects the process' standard error to the file \a     fileName. When the redirection is in place, the standard error     read channel is closed: reading from it using read() will always     fail, as will readAllStandardError(). The file will be appended to     if \a mode is Append, otherwise, it will be truncated.      See setStandardOutputFile() for more information on how the file     is opened.      Note: if setProcessChannelMode() was called with an argument of     QProcess::MergedChannels, this function has no effect.      \sa setStandardInputFile(), setStandardOutputFile(),         setStandardOutputProcess() */
end_comment
begin_function
DECL|function|setStandardErrorFile
name|void
name|QProcess
operator|::
name|setStandardErrorFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|OpenMode
name|mode
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|mode
operator|==
name|Append
operator|||
name|mode
operator|==
name|Truncate
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|stderrChannel
operator|=
name|fileName
expr_stmt|;
name|d
operator|->
name|stderrChannel
operator|.
name|append
operator|=
name|mode
operator|==
name|Append
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Pipes the standard output stream of this process to the \a     destination process' standard input.      The following shell command:     \snippet code/src_corelib_io_qprocess.cpp 2      Can be accomplished with QProcess with the following code:     \snippet code/src_corelib_io_qprocess.cpp 3 */
end_comment
begin_function
DECL|function|setStandardOutputProcess
name|void
name|QProcess
operator|::
name|setStandardOutputProcess
parameter_list|(
name|QProcess
modifier|*
name|destination
parameter_list|)
block|{
name|QProcessPrivate
modifier|*
name|dfrom
init|=
name|d_func
argument_list|()
decl_stmt|;
name|QProcessPrivate
modifier|*
name|dto
init|=
name|destination
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|dfrom
operator|->
name|stdoutChannel
operator|.
name|pipeTo
argument_list|(
name|dto
argument_list|)
expr_stmt|;
name|dto
operator|->
name|stdinChannel
operator|.
name|pipeFrom
argument_list|(
name|dfrom
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_comment
comment|/*!     \since 4.7      Returns the additional native command line arguments for the program.      \note This function is available only on the Windows platform.      \sa setNativeArguments() */
end_comment
begin_function
DECL|function|nativeArguments
name|QString
name|QProcess
operator|::
name|nativeArguments
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeArguments
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7     \overload      Sets additional native command line \a arguments for the program.      On operating systems where the system API for passing command line     \a arguments to a subprocess natively uses a single string, one can     conceive command lines which cannot be passed via QProcess's portable     list-based API. In such cases this function must be used to set a     string which is \e appended to the string composed from the usual     argument list, with a delimiting space.      \note This function is available only on the Windows platform.      \sa nativeArguments() */
end_comment
begin_function
DECL|function|setNativeArguments
name|void
name|QProcess
operator|::
name|setNativeArguments
parameter_list|(
specifier|const
name|QString
modifier|&
name|arguments
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|nativeArguments
operator|=
name|arguments
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.7      Returns a previously set \c CreateProcess modifier function.      \note This function is available only on the Windows platform.      \sa setCreateProcessArgumentsModifier()     \sa QProcess::CreateProcessArgumentModifier */
end_comment
begin_function
DECL|function|createProcessArgumentsModifier
name|QProcess
operator|::
name|CreateProcessArgumentModifier
name|QProcess
operator|::
name|createProcessArgumentsModifier
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|modifyCreateProcessArgs
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.7      Sets the \a modifier for the \c CreateProcess Win32 API call.     Pass \c QProcess::CreateProcessArgumentModifier() to remove a previously set one.      \note This function is available only on the Windows platform and requires     C++11.      \sa QProcess::CreateProcessArgumentModifier */
end_comment
begin_function
DECL|function|setCreateProcessArgumentsModifier
name|void
name|QProcess
operator|::
name|setCreateProcessArgumentsModifier
parameter_list|(
name|CreateProcessArgumentModifier
name|modifier
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|modifyCreateProcessArgs
operator|=
name|modifier
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     If QProcess has been assigned a working directory, this function returns     the working directory that the QProcess will enter before the program has     started. Otherwise, (i.e., no directory has been assigned,) an empty     string is returned, and QProcess will use the application's current     working directory instead.      \sa setWorkingDirectory() */
end_comment
begin_function
DECL|function|workingDirectory
name|QString
name|QProcess
operator|::
name|workingDirectory
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|workingDirectory
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the working directory to \a dir. QProcess will start the     process in this directory. The default behavior is to start the     process in the working directory of the calling process.      \note On QNX, this may cause all application threads to     temporarily freeze.      \sa workingDirectory(), start() */
end_comment
begin_function
DECL|function|setWorkingDirectory
name|void
name|QProcess
operator|::
name|setWorkingDirectory
parameter_list|(
specifier|const
name|QString
modifier|&
name|dir
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|workingDirectory
operator|=
name|dir
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \deprecated     Use processId() instead.      Returns the native process identifier for the running process, if     available.  If no process is currently running, \c 0 is returned.      \note Unlike \l processId(), pid() returns an integer on Unix and a pointer on Windows.      \sa Q_PID, processId() */
end_comment
begin_function
DECL|function|pid
name|Q_PID
name|QProcess
operator|::
name|pid
parameter_list|()
specifier|const
comment|// ### Qt 6 remove or rename this method to processInformation()
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|pid
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.3      Returns the native process identifier for the running process, if     available. If no process is currently running, \c 0 is returned.  */
end_comment
begin_function
DECL|function|processId
name|qint64
name|QProcess
operator|::
name|processId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
return|return
name|d
operator|->
name|pid
condition|?
name|d
operator|->
name|pid
operator|->
name|dwProcessId
else|:
literal|0
return|;
else|#
directive|else
return|return
name|d
operator|->
name|pid
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*! \reimp      This function operates on the current read channel.      \sa readChannel(), setReadChannel() */
end_comment
begin_function
DECL|function|canReadLine
name|bool
name|QProcess
operator|::
name|canReadLine
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
specifier|const
name|QRingBuffer
modifier|*
name|readBuffer
init|=
operator|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
operator|)
condition|?
operator|&
name|d
operator|->
name|stderrChannel
operator|.
name|buffer
else|:
operator|&
name|d
operator|->
name|stdoutChannel
operator|.
name|buffer
decl_stmt|;
return|return
name|readBuffer
operator|->
name|canReadLine
argument_list|()
operator|||
name|QIODevice
operator|::
name|canReadLine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Closes all communication with the process and kills it. After calling this     function, QProcess will no longer emit readyRead(), and data can no     longer be read or written. */
end_comment
begin_function
DECL|function|close
name|void
name|QProcess
operator|::
name|close
parameter_list|()
block|{
emit|emit
name|aboutToClose
argument_list|()
emit|;
while|while
condition|(
name|waitForBytesWritten
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
empty_stmt|;
name|kill
argument_list|()
expr_stmt|;
name|waitForFinished
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QIODevice
operator|::
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp     Returns \c true if the process is not running, and no more data is available    for reading; otherwise returns \c false. */
end_comment
begin_function
DECL|function|atEnd
name|bool
name|QProcess
operator|::
name|atEnd
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
specifier|const
name|QRingBuffer
modifier|*
name|readBuffer
init|=
operator|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
operator|)
condition|?
operator|&
name|d
operator|->
name|stderrChannel
operator|.
name|buffer
else|:
operator|&
name|d
operator|->
name|stdoutChannel
operator|.
name|buffer
decl_stmt|;
return|return
name|QIODevice
operator|::
name|atEnd
argument_list|()
operator|&&
operator|(
operator|!
name|isOpen
argument_list|()
operator|||
name|readBuffer
operator|->
name|isEmpty
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|isSequential
name|bool
name|QProcess
operator|::
name|isSequential
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|bytesAvailable
name|qint64
name|QProcess
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
specifier|const
name|QRingBuffer
modifier|*
name|readBuffer
init|=
operator|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
operator|)
condition|?
operator|&
name|d
operator|->
name|stderrChannel
operator|.
name|buffer
else|:
operator|&
name|d
operator|->
name|stdoutChannel
operator|.
name|buffer
decl_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::bytesAvailable() == %i (%s)"
argument_list|,
name|readBuffer
operator|->
name|size
argument_list|()
argument_list|,
operator|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
operator|)
condition|?
literal|"stderr"
else|:
literal|"stdout"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|readBuffer
operator|->
name|size
argument_list|()
operator|+
name|QIODevice
operator|::
name|bytesAvailable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|bytesToWrite
name|qint64
name|QProcess
operator|::
name|bytesToWrite
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
name|qint64
name|size
init|=
name|d
operator|->
name|stdinChannel
operator|.
name|buffer
operator|.
name|size
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|size
operator|+=
name|d
operator|->
name|pipeWriterBytesToWrite
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|size
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the type of error that occurred last.      \sa state() */
end_comment
begin_function
DECL|function|error
name|QProcess
operator|::
name|ProcessError
name|QProcess
operator|::
name|error
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|processError
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current state of the process.      \sa stateChanged(), error() */
end_comment
begin_function
DECL|function|state
name|QProcess
operator|::
name|ProcessState
name|QProcess
operator|::
name|state
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|processState
return|;
block|}
end_function
begin_comment
comment|/*!     \deprecated     Sets the environment that QProcess will pass to the child process.     The parameter \a environment is a list of key=value pairs.      For example, the following code adds the environment variable \c{TMPDIR}:      \snippet qprocess-environment/main.cpp 0      \note This function is less efficient than the setProcessEnvironment()     function.      \sa environment(), setProcessEnvironment(), systemEnvironment() */
end_comment
begin_function
DECL|function|setEnvironment
name|void
name|QProcess
operator|::
name|setEnvironment
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|environment
parameter_list|)
block|{
name|setProcessEnvironment
argument_list|(
name|QProcessEnvironmentPrivate
operator|::
name|fromList
argument_list|(
name|environment
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \deprecated     Returns the environment that QProcess will pass to its child     process, or an empty QStringList if no environment has been set     using setEnvironment(). If no environment has been set, the     environment of the calling process will be used.      \note The environment settings are ignored on Windows CE,     as there is no concept of an environment.      \sa processEnvironment(), setEnvironment(), systemEnvironment() */
end_comment
begin_function
DECL|function|environment
name|QStringList
name|QProcess
operator|::
name|environment
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|environment
operator|.
name|toStringList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Sets the \a environment that QProcess will pass to the child process.      For example, the following code adds the environment variable \c{TMPDIR}:      \snippet qprocess-environment/main.cpp 1      Note how, on Windows, environment variable names are case-insensitive.      \sa processEnvironment(), QProcessEnvironment::systemEnvironment(), setEnvironment() */
end_comment
begin_function
DECL|function|setProcessEnvironment
name|void
name|QProcess
operator|::
name|setProcessEnvironment
parameter_list|(
specifier|const
name|QProcessEnvironment
modifier|&
name|environment
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|environment
operator|=
name|environment
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Returns the environment that QProcess will pass to its child     process, or an empty object if no environment has been set using     setEnvironment() or setProcessEnvironment(). If no environment has     been set, the environment of the calling process will be used.      \note The environment settings are ignored on Windows CE,     as there is no concept of an environment.      \sa setProcessEnvironment(), setEnvironment(), QProcessEnvironment::isEmpty() */
end_comment
begin_function
DECL|function|processEnvironment
name|QProcessEnvironment
name|QProcess
operator|::
name|processEnvironment
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|environment
return|;
block|}
end_function
begin_comment
comment|/*!     Blocks until the process has started and the started() signal has     been emitted, or until \a msecs milliseconds have passed.      Returns \c true if the process was started successfully; otherwise     returns \c false (if the operation timed out or if an error     occurred).      This function can operate without an event loop. It is     useful when writing non-GUI applications and when performing     I/O operations in a non-GUI thread.      \warning Calling this function from the main (GUI) thread     might cause your user interface to freeze.      If msecs is -1, this function will not time out.      \note On some UNIX operating systems, this function may return true but     the process may later report a QProcess::FailedToStart error.      \sa started(), waitForReadyRead(), waitForBytesWritten(), waitForFinished() */
end_comment
begin_function
DECL|function|waitForStarted
name|bool
name|QProcess
operator|::
name|waitForStarted
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|Starting
condition|)
return|return
name|d
operator|->
name|waitForStarted
argument_list|(
name|msecs
argument_list|)
return|;
return|return
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|Running
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|waitForReadyRead
name|bool
name|QProcess
operator|::
name|waitForReadyRead
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|NotRunning
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardOutput
operator|&&
name|d
operator|->
name|stdoutChannel
operator|.
name|closed
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
operator|&&
name|d
operator|->
name|stderrChannel
operator|.
name|closed
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|waitForReadyRead
argument_list|(
name|msecs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|waitForBytesWritten
name|bool
name|QProcess
operator|::
name|waitForBytesWritten
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|NotRunning
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|Starting
condition|)
block|{
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
name|bool
name|started
init|=
name|waitForStarted
argument_list|(
name|msecs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|started
condition|)
return|return
literal|false
return|;
name|msecs
operator|=
name|qt_subtract_from_timeout
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|d
operator|->
name|waitForBytesWritten
argument_list|(
name|msecs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Blocks until the process has finished and the finished() signal     has been emitted, or until \a msecs milliseconds have passed.      Returns \c true if the process finished; otherwise returns \c false (if     the operation timed out, if an error occurred, or if this QProcess     is already finished).      This function can operate without an event loop. It is     useful when writing non-GUI applications and when performing     I/O operations in a non-GUI thread.      \warning Calling this function from the main (GUI) thread     might cause your user interface to freeze.      If msecs is -1, this function will not time out.      \sa finished(), waitForStarted(), waitForReadyRead(), waitForBytesWritten() */
end_comment
begin_function
DECL|function|waitForFinished
name|bool
name|QProcess
operator|::
name|waitForFinished
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|NotRunning
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|Starting
condition|)
block|{
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
name|bool
name|started
init|=
name|waitForStarted
argument_list|(
name|msecs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|started
condition|)
return|return
literal|false
return|;
name|msecs
operator|=
name|qt_subtract_from_timeout
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|d
operator|->
name|waitForFinished
argument_list|(
name|msecs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the current state of the QProcess to the \a state specified.      \sa state() */
end_comment
begin_function
DECL|function|setProcessState
name|void
name|QProcess
operator|::
name|setProcessState
parameter_list|(
name|ProcessState
name|state
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|==
name|state
condition|)
return|return;
name|d
operator|->
name|processState
operator|=
name|state
expr_stmt|;
emit|emit
name|stateChanged
argument_list|(
name|state
argument_list|,
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!   This function is called in the child process context just before the     program is executed on Unix or OS X (i.e., after \c fork(), but before     \c execve()). Reimplement this function to do last minute initialization     of the child process. Example:      \snippet code/src_corelib_io_qprocess.cpp 4      You cannot exit the process (by calling exit(), for instance) from     this function. If you need to stop the program before it starts     execution, your workaround is to emit finished() and then call     exit().      \warning This function is called by QProcess on Unix and OS X     only. On Windows and QNX, it is not called. */
end_comment
begin_function
DECL|function|setupChildProcess
name|void
name|QProcess
operator|::
name|setupChildProcess
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|readData
name|qint64
name|QProcess
operator|::
name|readData
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|maxlen
condition|)
return|return
literal|0
return|;
name|QRingBuffer
modifier|*
name|readBuffer
init|=
operator|(
name|d
operator|->
name|processChannel
operator|==
name|QProcess
operator|::
name|StandardError
operator|)
condition|?
operator|&
name|d
operator|->
name|stderrChannel
operator|.
name|buffer
else|:
operator|&
name|d
operator|->
name|stdoutChannel
operator|.
name|buffer
decl_stmt|;
if|if
condition|(
name|maxlen
operator|==
literal|1
operator|&&
operator|!
name|readBuffer
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|c
init|=
name|readBuffer
operator|->
name|getChar
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::readData(%p \"%s\", %d) == -1"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|maxlen
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|data
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::readData(%p \"%s\", %d) == 1"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|maxlen
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
name|qint64
name|bytesToRead
init|=
name|qMin
argument_list|(
name|readBuffer
operator|->
name|size
argument_list|()
argument_list|,
name|maxlen
argument_list|)
decl_stmt|;
name|qint64
name|readSoFar
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|readSoFar
operator|<
name|bytesToRead
condition|)
block|{
specifier|const
name|char
modifier|*
name|ptr
init|=
name|readBuffer
operator|->
name|readPointer
argument_list|()
decl_stmt|;
name|qint64
name|bytesToReadFromThisBlock
init|=
name|qMin
argument_list|(
name|bytesToRead
operator|-
name|readSoFar
argument_list|,
name|readBuffer
operator|->
name|nextDataBlockSize
argument_list|()
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
name|readSoFar
argument_list|,
name|ptr
argument_list|,
name|bytesToReadFromThisBlock
argument_list|)
expr_stmt|;
name|readSoFar
operator|+=
name|bytesToReadFromThisBlock
expr_stmt|;
name|readBuffer
operator|->
name|free
argument_list|(
name|bytesToReadFromThisBlock
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::readData(%p \"%s\", %lld) == %lld"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|readSoFar
argument_list|,
literal|16
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|maxlen
argument_list|,
name|readSoFar
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|readSoFar
operator|&&
name|d
operator|->
name|processState
operator|==
name|QProcess
operator|::
name|NotRunning
condition|)
return|return
operator|-
literal|1
return|;
comment|// EOF
return|return
name|readSoFar
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|writeData
name|qint64
name|QProcess
operator|::
name|writeData
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|Q_UNUSED
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|d
operator|->
name|setErrorAndEmit
argument_list|(
name|QProcess
operator|::
name|WriteError
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|stdinChannel
operator|.
name|closed
condition|)
block|{
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::writeData(%p \"%s\", %lld) == 0 (write channel closing)"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
literal|16
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
if|if
condition|(
operator|!
name|d
operator|->
name|stdinWriteTrigger
condition|)
block|{
name|d
operator|->
name|stdinWriteTrigger
operator|=
operator|new
name|QTimer
expr_stmt|;
name|d
operator|->
name|stdinWriteTrigger
operator|->
name|setSingleShot
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QObjectPrivate
operator|::
name|connect
argument_list|(
name|d
operator|->
name|stdinWriteTrigger
argument_list|,
operator|&
name|QTimer
operator|::
name|timeout
argument_list|,
name|d
argument_list|,
operator|&
name|QProcessPrivate
operator|::
name|_q_canWrite
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|d
operator|->
name|stdinChannel
operator|.
name|buffer
operator|.
name|putChar
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
operator|!
name|d
operator|->
name|stdinWriteTrigger
operator|->
name|isActive
argument_list|()
condition|)
name|d
operator|->
name|stdinWriteTrigger
operator|->
name|start
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|d
operator|->
name|stdinChannel
operator|.
name|notifier
condition|)
name|d
operator|->
name|stdinChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::writeData(%p \"%s\", %lld) == 1 (written to buffer)"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
literal|16
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
name|char
modifier|*
name|dest
init|=
name|d
operator|->
name|stdinChannel
operator|.
name|buffer
operator|.
name|reserve
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
operator|!
name|d
operator|->
name|stdinWriteTrigger
operator|->
name|isActive
argument_list|()
condition|)
name|d
operator|->
name|stdinWriteTrigger
operator|->
name|start
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|d
operator|->
name|stdinChannel
operator|.
name|notifier
condition|)
name|d
operator|->
name|stdinChannel
operator|.
name|notifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|(
literal|"QProcess::writeData(%p \"%s\", %lld) == %lld (written to buffer)"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
literal|16
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|len
return|;
block|}
end_function
begin_comment
comment|/*!     Regardless of the current read channel, this function returns all     data available from the standard output of the process as a     QByteArray.      \sa readyReadStandardOutput(), readAllStandardError(), readChannel(), setReadChannel() */
end_comment
begin_function
DECL|function|readAllStandardOutput
name|QByteArray
name|QProcess
operator|::
name|readAllStandardOutput
parameter_list|()
block|{
name|ProcessChannel
name|tmp
init|=
name|readChannel
argument_list|()
decl_stmt|;
name|setReadChannel
argument_list|(
name|StandardOutput
argument_list|)
expr_stmt|;
name|QByteArray
name|data
init|=
name|readAll
argument_list|()
decl_stmt|;
name|setReadChannel
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_comment
comment|/*!     Regardless of the current read channel, this function returns all     data available from the standard error of the process as a     QByteArray.      \sa readyReadStandardError(), readAllStandardOutput(), readChannel(), setReadChannel() */
end_comment
begin_function
DECL|function|readAllStandardError
name|QByteArray
name|QProcess
operator|::
name|readAllStandardError
parameter_list|()
block|{
name|ProcessChannel
name|tmp
init|=
name|readChannel
argument_list|()
decl_stmt|;
name|setReadChannel
argument_list|(
name|StandardError
argument_list|)
expr_stmt|;
name|QByteArray
name|data
init|=
name|readAll
argument_list|()
decl_stmt|;
name|setReadChannel
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_comment
comment|/*!     Starts the given \a program in a new process, passing the command line     arguments in \a arguments.      The QProcess object will immediately enter the Starting state. If the     process starts successfully, QProcess will emit started(); otherwise,     errorOccurred() will be emitted.      \note Processes are started asynchronously, which means the started()     and errorOccurred() signals may be delayed. Call waitForStarted() to make     sure the process has started (or has failed to start) and those signals     have been emitted.      \note No further splitting of the arguments is performed.      \b{Windows:} The arguments are quoted and joined into a command line     that is compatible with the \c CommandLineToArgvW() Windows function.     For programs that have different command line quoting requirements,     you need to use setNativeArguments(). One notable program that does     not follow the \c CommandLineToArgvW() rules is cmd.exe and, by     consequence, all batch scripts.      The OpenMode is set to \a mode.      If the QProcess object is already running a process, a warning may be     printed at the console, and the existing process will continue running     unaffected.      \sa processId(), started(), waitForStarted(), setNativeArguments() */
end_comment
begin_function
DECL|function|start
name|void
name|QProcess
operator|::
name|start
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|,
name|OpenMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|!=
name|NotRunning
condition|)
block|{
name|qWarning
argument_list|(
literal|"QProcess::start: Process is already running"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|program
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|processError
operator|=
name|QProcess
operator|::
name|FailedToStart
expr_stmt|;
name|setErrorString
argument_list|(
name|tr
argument_list|(
literal|"No program defined"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|error
argument_list|(
name|d
operator|->
name|processError
argument_list|)
emit|;
return|return;
block|}
name|d
operator|->
name|program
operator|=
name|program
expr_stmt|;
name|d
operator|->
name|arguments
operator|=
name|arguments
expr_stmt|;
name|d
operator|->
name|start
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.1     \overload      Starts the program set by setProgram() with arguments set by setArguments().     The OpenMode is set to \a mode.      \sa open(), setProgram(), setArguments()  */
end_comment
begin_function
DECL|function|start
name|void
name|QProcess
operator|::
name|start
parameter_list|(
name|OpenMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|!=
name|NotRunning
condition|)
block|{
name|qWarning
argument_list|(
literal|"QProcess::start: Process is already running"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|program
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|processError
operator|=
name|QProcess
operator|::
name|FailedToStart
expr_stmt|;
name|setErrorString
argument_list|(
name|tr
argument_list|(
literal|"No program defined"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|error
argument_list|(
name|d
operator|->
name|processError
argument_list|)
emit|;
return|return;
block|}
name|d
operator|->
name|start
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Starts the program set by setProgram() with arguments set by setArguments().     The OpenMode is set to \a mode.      This method is an alias for start(), and exists only to fully implement     the interface defined by QIODevice.      \sa start(), setProgram(), setArguments() */
end_comment
begin_function
DECL|function|open
name|bool
name|QProcess
operator|::
name|open
parameter_list|(
name|OpenMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|!=
name|NotRunning
condition|)
block|{
name|qWarning
argument_list|(
literal|"QProcess::start: Process is already running"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|program
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QProcess::start: program not set"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|start
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|start
name|void
name|QProcessPrivate
operator|::
name|start
parameter_list|(
name|QIODevice
operator|::
name|OpenMode
name|mode
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|QPROCESS_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QProcess::start("
operator|<<
name|program
operator|<<
literal|','
operator|<<
name|arguments
operator|<<
literal|','
operator|<<
name|mode
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|stdinChannel
operator|.
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|stdoutChannel
operator|.
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|stderrChannel
operator|.
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|stdinChannel
operator|.
name|type
operator|!=
name|QProcessPrivate
operator|::
name|Channel
operator|::
name|Normal
condition|)
name|mode
operator|&=
operator|~
name|QIODevice
operator|::
name|WriteOnly
expr_stmt|;
comment|// not open for writing
if|if
condition|(
name|stdoutChannel
operator|.
name|type
operator|!=
name|QProcessPrivate
operator|::
name|Channel
operator|::
name|Normal
operator|&&
operator|(
name|stderrChannel
operator|.
name|type
operator|!=
name|QProcessPrivate
operator|::
name|Channel
operator|::
name|Normal
operator|||
name|processChannelMode
operator|==
name|QProcess
operator|::
name|MergedChannels
operator|)
condition|)
name|mode
operator|&=
operator|~
name|QIODevice
operator|::
name|ReadOnly
expr_stmt|;
comment|// not open for reading
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|mode
operator|=
name|QIODevice
operator|::
name|Unbuffered
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_WINCE
if|if
condition|(
operator|(
name|mode
operator|&
name|QIODevice
operator|::
name|ReadOnly
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stdoutChannel
operator|.
name|type
operator|==
name|QProcessPrivate
operator|::
name|Channel
operator|::
name|Normal
condition|)
name|q
operator|->
name|setStandardOutputFile
argument_list|(
name|q
operator|->
name|nullDevice
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderrChannel
operator|.
name|type
operator|==
name|QProcessPrivate
operator|::
name|Channel
operator|::
name|Normal
operator|&&
name|processChannelMode
operator|!=
name|QProcess
operator|::
name|MergedChannels
condition|)
name|q
operator|->
name|setStandardErrorFile
argument_list|(
name|q
operator|->
name|nullDevice
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|q
operator|->
name|QIODevice
operator|::
name|open
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|stdinChannel
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
name|stdoutChannel
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
name|stderrChannel
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
name|exitCode
operator|=
literal|0
expr_stmt|;
name|exitStatus
operator|=
name|QProcess
operator|::
name|NormalExit
expr_stmt|;
name|processError
operator|=
name|QProcess
operator|::
name|UnknownError
expr_stmt|;
name|errorString
operator|.
name|clear
argument_list|()
expr_stmt|;
name|startProcess
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseCombinedArgString
specifier|static
name|QStringList
name|parseCombinedArgString
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|)
block|{
name|QStringList
name|args
decl_stmt|;
name|QString
name|tmp
decl_stmt|;
name|int
name|quoteCount
init|=
literal|0
decl_stmt|;
name|bool
name|inQuote
init|=
literal|false
decl_stmt|;
comment|// handle quoting. tokens can be surrounded by double quotes
comment|// "hello world". three consecutive double quotes represent
comment|// the quote character itself.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|program
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|program
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
condition|)
block|{
operator|++
name|quoteCount
expr_stmt|;
if|if
condition|(
name|quoteCount
operator|==
literal|3
condition|)
block|{
comment|// third consecutive quote
name|quoteCount
operator|=
literal|0
expr_stmt|;
name|tmp
operator|+=
name|program
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|quoteCount
condition|)
block|{
if|if
condition|(
name|quoteCount
operator|==
literal|1
condition|)
name|inQuote
operator|=
operator|!
name|inQuote
expr_stmt|;
name|quoteCount
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inQuote
operator|&&
name|program
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|tmp
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|args
operator|+=
name|tmp
expr_stmt|;
name|tmp
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|tmp
operator|+=
name|program
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|tmp
operator|.
name|isEmpty
argument_list|()
condition|)
name|args
operator|+=
name|tmp
expr_stmt|;
return|return
name|args
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Starts the command \a command in a new process.     The OpenMode is set to \a mode.      \a command is a single string of text containing both the program name     and its arguments. The arguments are separated by one or more spaces.     For example:      \snippet code/src_corelib_io_qprocess.cpp 5      Arguments containing spaces must be quoted to be correctly supplied to     the new process. For example:      \snippet code/src_corelib_io_qprocess.cpp 6      Literal quotes in the \a command string are represented by triple quotes.     For example:      \snippet code/src_corelib_io_qprocess.cpp 7      After the \a command string has been split and unquoted, this function     behaves like the overload which takes the arguments as a string list.      You can disable this overload by defining \c     QT_NO_PROCESS_COMBINED_ARGUMENT_START when you compile your applications.     This can be useful if you want to ensure that you are not splitting arguments     unintentionally, for example. In virtually all cases, using the other overload     is the preferred method.      On operating systems where the system API for passing command line     arguments to a subprocess natively uses a single string (Windows), one can     conceive command lines which cannot be passed via QProcess's portable     list-based API. In these rare cases you need to use setProgram() and     setNativeArguments() instead of this function.  */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_PROCESS_COMBINED_ARGUMENT_START
argument_list|)
end_if
begin_function
DECL|function|start
name|void
name|QProcess
operator|::
name|start
parameter_list|(
specifier|const
name|QString
modifier|&
name|command
parameter_list|,
name|OpenMode
name|mode
parameter_list|)
block|{
name|QStringList
name|args
init|=
name|parseCombinedArgString
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|setErrorAndEmit
argument_list|(
name|QProcess
operator|::
name|FailedToStart
argument_list|,
name|tr
argument_list|(
literal|"No program defined"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|QString
name|prog
init|=
name|args
operator|.
name|first
argument_list|()
decl_stmt|;
name|args
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|start
argument_list|(
name|prog
argument_list|,
name|args
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \since 5.0      Returns the program the process was last started with.      \sa start() */
end_comment
begin_function
DECL|function|program
name|QString
name|QProcess
operator|::
name|program
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|program
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.1      Set the \a program to use when starting the process.     This function must be called before start().      \sa start(), setArguments(), program() */
end_comment
begin_function
DECL|function|setProgram
name|void
name|QProcess
operator|::
name|setProgram
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|!=
name|NotRunning
condition|)
block|{
name|qWarning
argument_list|(
literal|"QProcess::setProgram: Process is already running"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|program
operator|=
name|program
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Returns the command line arguments the process was last started with.      \sa start() */
end_comment
begin_function
DECL|function|arguments
name|QStringList
name|QProcess
operator|::
name|arguments
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|arguments
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.1      Set the \a arguments to pass to the called program when starting the process.     This function must be called before start().      \sa start(), setProgram(), arguments() */
end_comment
begin_function
DECL|function|setArguments
name|void
name|QProcess
operator|::
name|setArguments
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|processState
operator|!=
name|NotRunning
condition|)
block|{
name|qWarning
argument_list|(
literal|"QProcess::setProgram: Process is already running"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|arguments
operator|=
name|arguments
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Attempts to terminate the process.      The process may not exit as a result of calling this function (it is given     the chance to prompt the user for any unsaved files, etc).      On Windows, terminate() posts a WM_CLOSE message to all top-level windows     of the process and then to the main thread of the process itself. On Unix     and OS X the \c SIGTERM signal is sent.      Console applications on Windows that do not run an event loop, or whose     event loop does not handle the WM_CLOSE message, can only be terminated by     calling kill().      \sa kill() */
end_comment
begin_function
DECL|function|terminate
name|void
name|QProcess
operator|::
name|terminate
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|terminateProcess
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Kills the current process, causing it to exit immediately.      On Windows, kill() uses TerminateProcess, and on Unix and OS X, the     SIGKILL signal is sent to the process.      \sa terminate() */
end_comment
begin_function
DECL|function|kill
name|void
name|QProcess
operator|::
name|kill
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QProcess
argument_list|)
expr_stmt|;
name|d
operator|->
name|killProcess
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the exit code of the last process that finished.      This value is not valid unless exitStatus() returns NormalExit. */
end_comment
begin_function
DECL|function|exitCode
name|int
name|QProcess
operator|::
name|exitCode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|exitCode
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the exit status of the last process that finished.      On Windows, if the process was terminated with TerminateProcess() from     another application, this function will still return NormalExit     unless the exit code is less than 0. */
end_comment
begin_function
DECL|function|exitStatus
name|QProcess
operator|::
name|ExitStatus
name|QProcess
operator|::
name|exitStatus
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QProcess
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|exitStatus
return|;
block|}
end_function
begin_comment
comment|/*!     Starts the program \a program with the arguments \a arguments in a     new process, waits for it to finish, and then returns the exit     code of the process. Any data the new process writes to the     console is forwarded to the calling process.      The environment and working directory are inherited from the calling     process.      Argument handling is identical to the respective start() overload.      If the process cannot be started, -2 is returned. If the process     crashes, -1 is returned. Otherwise, the process' exit code is     returned.      \sa start() */
end_comment
begin_function
DECL|function|execute
name|int
name|QProcess
operator|::
name|execute
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|)
block|{
name|QProcess
name|process
decl_stmt|;
name|process
operator|.
name|setReadChannelMode
argument_list|(
name|ForwardedChannels
argument_list|)
expr_stmt|;
name|process
operator|.
name|start
argument_list|(
name|program
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|process
operator|.
name|waitForFinished
argument_list|(
operator|-
literal|1
argument_list|)
operator|||
name|process
operator|.
name|error
argument_list|()
operator|==
name|FailedToStart
condition|)
return|return
operator|-
literal|2
return|;
return|return
name|process
operator|.
name|exitStatus
argument_list|()
operator|==
name|QProcess
operator|::
name|NormalExit
condition|?
name|process
operator|.
name|exitCode
argument_list|()
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Starts the program \a command in a new process, waits for it to finish,     and then returns the exit code.      Argument handling is identical to the respective start() overload.      After the \a command string has been split and unquoted, this function     behaves like the overload which takes the arguments as a string list.      \sa start() */
end_comment
begin_function
DECL|function|execute
name|int
name|QProcess
operator|::
name|execute
parameter_list|(
specifier|const
name|QString
modifier|&
name|command
parameter_list|)
block|{
name|QProcess
name|process
decl_stmt|;
name|process
operator|.
name|setReadChannelMode
argument_list|(
name|ForwardedChannels
argument_list|)
expr_stmt|;
name|process
operator|.
name|start
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|process
operator|.
name|waitForFinished
argument_list|(
operator|-
literal|1
argument_list|)
operator|||
name|process
operator|.
name|error
argument_list|()
operator|==
name|FailedToStart
condition|)
return|return
operator|-
literal|2
return|;
return|return
name|process
operator|.
name|exitStatus
argument_list|()
operator|==
name|QProcess
operator|::
name|NormalExit
condition|?
name|process
operator|.
name|exitCode
argument_list|()
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Starts the program \a program with the arguments \a arguments in a     new process, and detaches from it. Returns \c true on success;     otherwise returns \c false. If the calling process exits, the     detached process will continue to run unaffected.      Argument handling is identical to the respective start() overload.      \b{Unix:} The started process will run in its own session and act     like a daemon.      The process will be started in the directory \a workingDirectory.     If \a workingDirectory is empty, the working directory is inherited     from the calling process.      \note On QNX, this may cause all application threads to     temporarily freeze.      If the function is successful then *\a pid is set to the process     identifier of the started process.      \sa start() */
end_comment
begin_function
DECL|function|startDetached
name|bool
name|QProcess
operator|::
name|startDetached
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|,
specifier|const
name|QString
modifier|&
name|workingDirectory
parameter_list|,
name|qint64
modifier|*
name|pid
parameter_list|)
block|{
return|return
name|QProcessPrivate
operator|::
name|startDetached
argument_list|(
name|program
argument_list|,
name|arguments
argument_list|,
name|workingDirectory
argument_list|,
name|pid
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|startDetached
name|bool
name|QProcess
operator|::
name|startDetached
parameter_list|(
specifier|const
name|QString
modifier|&
name|program
parameter_list|,
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|)
block|{
return|return
name|QProcessPrivate
operator|::
name|startDetached
argument_list|(
name|program
argument_list|,
name|arguments
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Starts the command \a command in a new process, and detaches from it.     Returns \c true on success; otherwise returns \c false.      Argument handling is identical to the respective start() overload.      After the \a command string has been split and unquoted, this function     behaves like the overload which takes the arguments as a string list.      \sa start() */
end_comment
begin_function
DECL|function|startDetached
name|bool
name|QProcess
operator|::
name|startDetached
parameter_list|(
specifier|const
name|QString
modifier|&
name|command
parameter_list|)
block|{
name|QStringList
name|args
init|=
name|parseCombinedArgString
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QString
name|prog
init|=
name|args
operator|.
name|first
argument_list|()
decl_stmt|;
name|args
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
return|return
name|QProcessPrivate
operator|::
name|startDetached
argument_list|(
name|prog
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
name|QT_BEGIN_INCLUDE_NAMESPACE
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MACX
argument_list|)
include|#
directive|include
file|<crt_externs.h>
DECL|macro|environ
define|#
directive|define
name|environ
value|(*_NSGetEnviron())
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_IOS
argument_list|)
specifier|static
name|char
modifier|*
name|qt_empty_environ
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_define
define|#
directive|define
name|environ
value|qt_empty_environ
end_define
begin_elif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_elif
begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_END_INCLUDE_NAMESPACE
comment|/*!     \since 4.1      Returns the environment of the calling process as a list of     key=value pairs. Example:      \snippet code/src_corelib_io_qprocess.cpp 8      This function does not cache the system environment. Therefore, it's     possible to obtain an updated version of the environment if low-level C     library functions like \tt setenv or \tt putenv have been called.      However, note that repeated calls to this function will recreate the     list of environment variables, which is a non-trivial operation.      \note For new code, it is recommended to use QProcessEnvironment::systemEnvironment()      \sa QProcessEnvironment::systemEnvironment(), setProcessEnvironment() */
DECL|function|systemEnvironment
name|QStringList
name|QProcess
operator|::
name|systemEnvironment
parameter_list|()
block|{
name|QStringList
name|tmp
decl_stmt|;
name|char
modifier|*
name|entry
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|environ
index|[
name|count
operator|++
index|]
operator|)
condition|)
name|tmp
operator|<<
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QProcessEnvironment QProcessEnvironment::systemEnvironment()      \since 4.6      \brief The systemEnvironment function returns the environment of     the calling process.      It is returned as a QProcessEnvironment. This function does not     cache the system environment. Therefore, it's possible to obtain     an updated version of the environment if low-level C library     functions like \tt setenv or \tt putenv have been called.      However, note that repeated calls to this function will recreate the     QProcessEnvironment object, which is a non-trivial operation.      \sa QProcess::systemEnvironment() */
end_comment
begin_comment
comment|/*!     \since 5.2      \brief The null device of the operating system.      The returned file path uses native directory separators.      \sa QProcess::setStandardInputFile(), QProcess::setStandardOutputFile(),         QProcess::setStandardErrorFile() */
end_comment
begin_function
DECL|function|nullDevice
name|QString
name|QProcess
operator|::
name|nullDevice
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_OS_WIN
return|return
name|QStringLiteral
argument_list|(
literal|"\\\\.\\NUL"
argument_list|)
return|;
else|#
directive|else
return|return
name|QStringLiteral
argument_list|(
literal|"/dev/null"
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \typedef Q_PID     \relates QProcess      Typedef for the identifiers used to represent processes on the underlying     platform. On Unix, this corresponds to \l qint64; on Windows, it     corresponds to \c{_PROCESS_INFORMATION*}.      \sa QProcess::pid() */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qprocess.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PROCESS
end_comment
end_unit
