begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qurl_p.h"
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|_HEXDIG
specifier|static
name|bool
name|QT_FASTCALL
name|_HEXDIG
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
name|char
name|ch
init|=
operator|*
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
operator|)
condition|)
block|{
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// pct-encoded = "%" HEXDIG HEXDIG
end_comment
begin_function
DECL|function|_pctEncoded
specifier|static
name|bool
name|QT_FASTCALL
name|_pctEncoded
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ptrBackup
init|=
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|ptr
operator|!=
literal|'%'
condition|)
return|return
literal|false
return|;
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|_HEXDIG
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|_HEXDIG
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|// gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"
end_comment
begin_endif
unit|static bool QT_FASTCALL _genDelims(const char **ptr, char *c) {     char ch = **ptr;     switch (ch) {     case ':': case '/': case '?': case '#':     case '[': case ']': case '@':         *c = ch;         ++(*ptr);         return true;     default:         return false;     } }
endif|#
directive|endif
end_endif
begin_comment
comment|// sub-delims  = "!" / "$" / "&" / "'" / "(" / ")"
end_comment
begin_comment
comment|//             / "*" / "+" / "," / ";" / "="
end_comment
begin_function
DECL|function|_subDelims
specifier|static
name|bool
name|QT_FASTCALL
name|_subDelims
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
name|char
name|ch
init|=
operator|*
operator|*
name|ptr
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'$'
case|:
case|case
literal|'&'
case|:
case|case
literal|'\''
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
case|case
literal|'='
case|:
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|// unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"
end_comment
begin_function
DECL|function|_unreserved
specifier|static
name|bool
name|QT_FASTCALL
name|_unreserved
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
name|char
name|ch
init|=
operator|*
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'.'
operator|||
name|ch
operator|==
literal|'_'
operator|||
name|ch
operator|==
literal|'~'
condition|)
block|{
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
end_comment
begin_function
DECL|function|_scheme
specifier|static
name|bool
name|QT_FASTCALL
name|_scheme
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|QUrlParseData
modifier|*
name|parseData
parameter_list|)
block|{
name|bool
name|first
init|=
literal|true
decl_stmt|;
name|bool
name|isSchemeValid
init|=
literal|true
decl_stmt|;
name|parseData
operator|->
name|scheme
operator|=
operator|*
name|ptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|ch
init|=
operator|*
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
operator|)
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
name|ch
operator|==
literal|'+'
operator|||
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|isSchemeValid
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|ptr
operator|!=
literal|':'
condition|)
block|{
name|isSchemeValid
operator|=
literal|true
expr_stmt|;
operator|*
name|ptr
operator|=
name|parseData
operator|->
name|scheme
expr_stmt|;
block|}
else|else
block|{
name|parseData
operator|->
name|schemeLength
operator|=
operator|*
name|ptr
operator|-
name|parseData
operator|->
name|scheme
expr_stmt|;
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
comment|// skip ':'
block|}
return|return
name|isSchemeValid
return|;
block|}
end_function
begin_comment
comment|// IPvFuture  = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
end_comment
begin_function
DECL|function|_IPvFuture
specifier|static
name|bool
name|QT_FASTCALL
name|_IPvFuture
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
operator|*
operator|*
name|ptr
operator|!=
literal|'v'
condition|)
return|return
literal|false
return|;
specifier|const
name|char
modifier|*
name|ptrBackup
init|=
operator|*
name|ptr
decl_stmt|;
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|_HEXDIG
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
while|while
condition|(
name|_HEXDIG
argument_list|(
name|ptr
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
operator|*
operator|*
name|ptr
operator|!=
literal|'.'
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|_unreserved
argument_list|(
name|ptr
argument_list|)
operator|&&
operator|!
name|_subDelims
argument_list|(
name|ptr
argument_list|)
operator|&&
operator|*
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|++
operator|)
operator|!=
literal|':'
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
while|while
condition|(
name|_unreserved
argument_list|(
name|ptr
argument_list|)
operator|||
name|_subDelims
argument_list|(
name|ptr
argument_list|)
operator|||
operator|*
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|++
operator|)
operator|==
literal|':'
condition|)
empty_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// h16         = 1*4HEXDIG
end_comment
begin_comment
comment|//             ; 16 bits of address represented in hexadecimal
end_comment
begin_function
DECL|function|_h16
specifier|static
name|bool
name|QT_FASTCALL
name|_h16
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|_HEXDIG
argument_list|(
name|ptr
argument_list|)
condition|)
break|break;
block|}
return|return
operator|(
name|i
operator|!=
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|// dec-octet   = DIGIT                 ; 0-9
end_comment
begin_comment
comment|//             / %x31-39 DIGIT         ; 10-99
end_comment
begin_comment
comment|//             / "1" 2DIGIT            ; 100-199
end_comment
begin_comment
comment|//             / "2" %x30-34 DIGIT     ; 200-249
end_comment
begin_comment
comment|//             / "25" %x30-35          ; 250-255
end_comment
begin_function
DECL|function|_decOctet
specifier|static
name|bool
name|QT_FASTCALL
name|_decOctet
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ptrBackup
init|=
operator|*
name|ptr
decl_stmt|;
name|char
name|c1
init|=
operator|*
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
name|c1
argument_list|<
literal|'0'
operator|||
name|c1
argument_list|>
literal|'9'
condition|)
return|return
literal|false
return|;
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'0'
condition|)
return|return
literal|true
return|;
name|char
name|c2
init|=
operator|*
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
name|c2
argument_list|<
literal|'0'
operator|||
name|c2
argument_list|>
literal|'9'
condition|)
return|return
literal|true
return|;
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
name|char
name|c3
init|=
operator|*
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
name|c3
argument_list|<
literal|'0'
operator|||
name|c3
argument_list|>
literal|'9'
condition|)
return|return
literal|true
return|;
comment|// If there is a three digit number larger than 255, reject the
comment|// whole token.
if|if
condition|(
name|c1
operator|>=
literal|'2'
operator|&&
name|c2
operator|>=
literal|'5'
operator|&&
name|c3
operator|>
literal|'5'
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
end_comment
begin_function
DECL|function|_IPv4Address
specifier|static
name|bool
name|QT_FASTCALL
name|_IPv4Address
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ptrBackup
init|=
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|_decOctet
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|char
name|ch
init|=
operator|*
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'.'
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|_decOctet
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// ls32        = ( h16 ":" h16 ) / IPv4address
end_comment
begin_comment
comment|//             ; least-significant 32 bits of address
end_comment
begin_function
DECL|function|_ls32
specifier|static
name|bool
name|QT_FASTCALL
name|_ls32
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ptrBackup
init|=
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
name|_h16
argument_list|(
name|ptr
argument_list|)
operator|&&
operator|*
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|++
operator|)
operator|==
literal|':'
operator|&&
name|_h16
argument_list|(
name|ptr
argument_list|)
condition|)
return|return
literal|true
return|;
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
name|_IPv4Address
argument_list|(
name|ptr
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// IPv6address =                            6( h16 ":" ) ls32 // case 1
end_comment
begin_comment
comment|//             /                       "::" 5( h16 ":" ) ls32 // case 2
end_comment
begin_comment
comment|//             / [               h16 ] "::" 4( h16 ":" ) ls32 // case 3
end_comment
begin_comment
comment|//             / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32 // case 4
end_comment
begin_comment
comment|//             / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32 // case 5
end_comment
begin_comment
comment|//             / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32 // case 6
end_comment
begin_comment
comment|//             / [ *4( h16 ":" ) h16 ] "::"              ls32 // case 7
end_comment
begin_comment
comment|//             / [ *5( h16 ":" ) h16 ] "::"              h16  // case 8
end_comment
begin_comment
comment|//             / [ *6( h16 ":" ) h16 ] "::"                   // case 9
end_comment
begin_function
DECL|function|_IPv6Address
specifier|static
name|bool
name|QT_FASTCALL
name|_IPv6Address
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ptrBackup
init|=
operator|*
name|ptr
decl_stmt|;
comment|// count of (h16 ":") to the left of and including ::
name|int
name|leftHexColons
init|=
literal|0
decl_stmt|;
comment|// count of (h16 ":") to the right of ::
name|int
name|rightHexColons
init|=
literal|0
decl_stmt|;
comment|// first count the number of (h16 ":") on the left of ::
while|while
condition|(
name|_h16
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
comment|// an h16 not followed by a colon is considered an
comment|// error.
if|if
condition|(
operator|*
operator|*
name|ptr
operator|!=
literal|':'
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
operator|++
name|leftHexColons
expr_stmt|;
comment|// check for case 1, the only time when there can be no ::
if|if
condition|(
name|leftHexColons
operator|==
literal|6
operator|&&
name|_ls32
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|// check for case 2 where the address starts with a :
if|if
condition|(
name|leftHexColons
operator|==
literal|0
operator|&&
operator|*
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|++
operator|)
operator|!=
literal|':'
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// check for the second colon in ::
if|if
condition|(
operator|*
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|++
operator|)
operator|!=
literal|':'
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|canBeCase
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|ls32WasRead
init|=
literal|false
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmpBackup
init|=
operator|*
name|ptr
decl_stmt|;
comment|// count the number of (h16 ":") on the right of ::
for|for
control|(
init|;
condition|;
control|)
block|{
name|tmpBackup
operator|=
operator|*
name|ptr
expr_stmt|;
if|if
condition|(
operator|!
name|_h16
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|_ls32
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|rightHexColons
operator|!=
literal|0
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// the address ended with :: (case 9)
comment|// only valid if 1<= leftHexColons<= 7
name|canBeCase
operator|=
literal|9
expr_stmt|;
block|}
else|else
block|{
name|ls32WasRead
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
operator|++
name|rightHexColons
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|ptr
operator|!=
literal|':'
condition|)
block|{
comment|// no colon could mean that what was read as an h16
comment|// was in fact the first part of an ls32. we backtrack
comment|// and retry.
specifier|const
name|char
modifier|*
name|pb
init|=
operator|*
name|ptr
decl_stmt|;
operator|*
name|ptr
operator|=
name|tmpBackup
expr_stmt|;
if|if
condition|(
name|_ls32
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|ls32WasRead
operator|=
literal|true
expr_stmt|;
operator|--
name|rightHexColons
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptr
operator|=
name|pb
expr_stmt|;
comment|// address ends with only 1 h16 after :: (case 8)
if|if
condition|(
name|rightHexColons
operator|==
literal|1
condition|)
name|canBeCase
operator|=
literal|8
expr_stmt|;
block|}
break|break;
block|}
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
block|}
comment|// determine which case it is based on the number of rightHexColons
if|if
condition|(
name|canBeCase
operator|==
operator|-
literal|1
condition|)
block|{
comment|// check if a ls32 was read. If it wasn't and rightHexColons>= 2 then the
comment|// last 2 HexColons are in fact a ls32
if|if
condition|(
operator|!
name|ls32WasRead
operator|&&
name|rightHexColons
operator|>=
literal|2
condition|)
name|rightHexColons
operator|-=
literal|2
expr_stmt|;
name|canBeCase
operator|=
literal|7
operator|-
name|rightHexColons
expr_stmt|;
block|}
comment|// based on the case we need to check that the number of leftHexColons is valid
if|if
condition|(
name|leftHexColons
operator|>
operator|(
name|canBeCase
operator|-
literal|2
operator|)
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
end_comment
begin_function
DECL|function|_IPLiteral
specifier|static
name|bool
name|QT_FASTCALL
name|_IPLiteral
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ptrBackup
init|=
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|ptr
operator|!=
literal|'['
condition|)
return|return
literal|false
return|;
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|_IPv6Address
argument_list|(
name|ptr
argument_list|)
operator|&&
operator|!
name|_IPvFuture
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|*
operator|*
name|ptr
operator|!=
literal|']'
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// reg-name    = *( unreserved / pct-encoded / sub-delims )
end_comment
begin_function
DECL|function|_regName
specifier|static
name|void
name|QT_FASTCALL
name|_regName
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|_unreserved
argument_list|(
name|ptr
argument_list|)
operator|&&
operator|!
name|_subDelims
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|_pctEncoded
argument_list|(
name|ptr
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|// host        = IP-literal / IPv4address / reg-name
end_comment
begin_function
DECL|function|_host
specifier|static
name|void
name|QT_FASTCALL
name|_host
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|QUrlParseData
modifier|*
name|parseData
parameter_list|)
block|{
name|parseData
operator|->
name|host
operator|=
operator|*
name|ptr
expr_stmt|;
if|if
condition|(
operator|!
name|_IPLiteral
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|_IPv4Address
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|char
name|ch
init|=
operator|*
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
name|ch
operator|&&
name|ch
operator|!=
literal|':'
operator|&&
name|ch
operator|!=
literal|'/'
condition|)
block|{
comment|// reset
operator|*
name|ptr
operator|=
name|parseData
operator|->
name|host
expr_stmt|;
name|_regName
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|_regName
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
name|parseData
operator|->
name|hostLength
operator|=
operator|*
name|ptr
operator|-
name|parseData
operator|->
name|host
expr_stmt|;
block|}
end_function
begin_comment
comment|// userinfo    = *( unreserved / pct-encoded / sub-delims / ":" )
end_comment
begin_function
DECL|function|_userInfo
specifier|static
name|void
name|QT_FASTCALL
name|_userInfo
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|QUrlParseData
modifier|*
name|parseData
parameter_list|)
block|{
name|parseData
operator|->
name|userInfo
operator|=
operator|*
name|ptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|_unreserved
argument_list|(
name|ptr
argument_list|)
operator|||
name|_subDelims
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_pctEncoded
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|ptr
operator|==
literal|':'
condition|)
block|{
name|parseData
operator|->
name|userInfoDelimIndex
operator|=
operator|*
name|ptr
operator|-
name|parseData
operator|->
name|userInfo
expr_stmt|;
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|*
operator|*
name|ptr
operator|!=
literal|'@'
condition|)
block|{
operator|*
name|ptr
operator|=
name|parseData
operator|->
name|userInfo
expr_stmt|;
name|parseData
operator|->
name|userInfoDelimIndex
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|parseData
operator|->
name|userInfoLength
operator|=
operator|*
name|ptr
operator|-
name|parseData
operator|->
name|userInfo
expr_stmt|;
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// port        = *DIGIT
end_comment
begin_function
DECL|function|_port
specifier|static
name|void
name|QT_FASTCALL
name|_port
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|port
parameter_list|)
block|{
name|bool
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|ptrBackup
init|=
operator|*
name|ptr
decl_stmt|;
name|char
name|ch
init|=
operator|*
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|ch
argument_list|<
literal|'0'
operator|||
name|ch
argument_list|>
literal|'9'
condition|)
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
operator|*
name|port
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|port
operator|*=
literal|10
expr_stmt|;
operator|*
name|port
operator|+=
name|ch
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// authority   = [ userinfo "@" ] host [ ":" port ]
end_comment
begin_function
DECL|function|_authority
specifier|static
name|void
name|QT_FASTCALL
name|_authority
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|QUrlParseData
modifier|*
name|parseData
parameter_list|)
block|{
name|_userInfo
argument_list|(
name|ptr
argument_list|,
name|parseData
argument_list|)
expr_stmt|;
name|_host
argument_list|(
name|ptr
argument_list|,
name|parseData
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|ptr
operator|!=
literal|':'
condition|)
return|return;
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
name|_port
argument_list|(
name|ptr
argument_list|,
operator|&
name|parseData
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
end_comment
begin_function
DECL|function|_pchar
specifier|static
name|bool
name|QT_FASTCALL
name|_pchar
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
name|char
name|c
init|=
operator|*
operator|(
operator|*
name|ptr
operator|)
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'$'
case|:
case|case
literal|'&'
case|:
case|case
literal|'\''
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
case|case
literal|'='
case|:
case|case
literal|':'
case|:
case|case
literal|'@'
case|:
case|case
literal|'-'
case|:
case|case
literal|'.'
case|:
case|case
literal|'_'
case|:
case|case
literal|'~'
case|:
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
return|return
literal|true
return|;
default|default:
break|break;
block|}
empty_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|_pctEncoded
argument_list|(
name|ptr
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// segment       = *pchar
end_comment
begin_function
DECL|function|_segmentNZ
specifier|static
name|bool
name|QT_FASTCALL
name|_segmentNZ
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|_pchar
argument_list|(
name|ptr
argument_list|)
condition|)
return|return
literal|false
return|;
while|while
condition|(
name|_pchar
argument_list|(
name|ptr
argument_list|)
condition|)
empty_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// path-abempty  = *( "/" segment )
end_comment
begin_function
DECL|function|_pathAbEmpty
specifier|static
name|void
name|QT_FASTCALL
name|_pathAbEmpty
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|ptr
operator|!=
literal|'/'
condition|)
break|break;
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
while|while
condition|(
name|_pchar
argument_list|(
name|ptr
argument_list|)
condition|)
empty_stmt|;
block|}
block|}
end_function
begin_comment
comment|// path-abs      = "/" [ segment-nz *( "/" segment ) ]
end_comment
begin_function
DECL|function|_pathAbs
specifier|static
name|bool
name|QT_FASTCALL
name|_pathAbs
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
comment|// **ptr == '/' already checked in caller
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
comment|// we might be able to unnest this to gain some performance.
if|if
condition|(
operator|!
name|_segmentNZ
argument_list|(
name|ptr
argument_list|)
condition|)
return|return
literal|true
return|;
name|_pathAbEmpty
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// path-rootless = segment-nz *( "/" segment )
end_comment
begin_function
DECL|function|_pathRootless
specifier|static
name|bool
name|QT_FASTCALL
name|_pathRootless
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
comment|// we might be able to unnest this to gain some performance.
if|if
condition|(
operator|!
name|_segmentNZ
argument_list|(
name|ptr
argument_list|)
condition|)
return|return
literal|false
return|;
name|_pathAbEmpty
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// hier-part   = "//" authority path-abempty
end_comment
begin_comment
comment|//             / path-abs
end_comment
begin_comment
comment|//             / path-rootless
end_comment
begin_comment
comment|//             / path-empty
end_comment
begin_function
DECL|function|_hierPart
specifier|static
name|void
name|QT_FASTCALL
name|_hierPart
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|QUrlParseData
modifier|*
name|parseData
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ptrBackup
init|=
operator|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|pathStart
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|++
operator|)
operator|==
literal|'/'
operator|&&
operator|*
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|++
operator|)
operator|==
literal|'/'
condition|)
block|{
name|_authority
argument_list|(
name|ptr
argument_list|,
name|parseData
argument_list|)
expr_stmt|;
name|pathStart
operator|=
operator|*
name|ptr
expr_stmt|;
name|_pathAbEmpty
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptr
operator|=
name|ptrBackup
expr_stmt|;
name|pathStart
operator|=
operator|*
name|ptr
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|ptr
operator|==
literal|'/'
condition|)
name|_pathAbs
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
else|else
name|_pathRootless
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|parseData
operator|->
name|path
operator|=
name|pathStart
expr_stmt|;
name|parseData
operator|->
name|pathLength
operator|=
operator|*
name|ptr
operator|-
name|pathStart
expr_stmt|;
block|}
end_function
begin_comment
comment|// query       = *( pchar / "/" / "?" )
end_comment
begin_function
DECL|function|_query
specifier|static
name|void
name|QT_FASTCALL
name|_query
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|QUrlParseData
modifier|*
name|parseData
parameter_list|)
block|{
name|parseData
operator|->
name|query
operator|=
operator|*
name|ptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|_pchar
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|ptr
operator|==
literal|'/'
operator|||
operator|*
operator|*
name|ptr
operator|==
literal|'?'
condition|)
block|{
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|parseData
operator|->
name|queryLength
operator|=
operator|*
name|ptr
operator|-
name|parseData
operator|->
name|query
expr_stmt|;
block|}
end_function
begin_comment
comment|// fragment    = *( pchar / "/" / "?" )
end_comment
begin_function
DECL|function|_fragment
specifier|static
name|void
name|QT_FASTCALL
name|_fragment
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|QUrlParseData
modifier|*
name|parseData
parameter_list|)
block|{
name|parseData
operator|->
name|fragment
operator|=
operator|*
name|ptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|_pchar
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|ptr
operator|==
literal|'/'
operator|||
operator|*
operator|*
name|ptr
operator|==
literal|'?'
operator|||
operator|*
operator|*
name|ptr
operator|==
literal|'#'
condition|)
block|{
operator|++
operator|(
operator|*
name|ptr
operator|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|parseData
operator|->
name|fragmentLength
operator|=
operator|*
name|ptr
operator|-
name|parseData
operator|->
name|fragment
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_urlParse
name|bool
name|qt_urlParse
parameter_list|(
specifier|const
name|char
modifier|*
name|pptr
parameter_list|,
name|QUrlParseData
modifier|&
name|parseData
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|ptr
init|=
operator|&
name|pptr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QURL_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QUrlPrivate::parse(), parsing \"%s\""
argument_list|,
name|pptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// optional scheme
name|bool
name|isSchemeValid
init|=
name|_scheme
argument_list|(
name|ptr
argument_list|,
operator|&
name|parseData
argument_list|)
decl_stmt|;
if|if
condition|(
name|isSchemeValid
operator|==
literal|false
condition|)
block|{
name|char
name|ch
init|=
operator|*
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|++
operator|)
decl_stmt|;
name|parseData
operator|.
name|errorInfo
operator|->
name|setParams
argument_list|(
operator|*
name|ptr
argument_list|,
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|"unexpected URL scheme"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QURL_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QUrlPrivate::parse(), unrecognized: %c%s"
argument_list|,
name|ch
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
comment|// hierpart
name|_hierPart
argument_list|(
name|ptr
argument_list|,
operator|&
name|parseData
argument_list|)
expr_stmt|;
comment|// optional query
name|char
name|ch
init|=
operator|*
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'?'
condition|)
block|{
name|_query
argument_list|(
name|ptr
argument_list|,
operator|&
name|parseData
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|++
operator|)
expr_stmt|;
block|}
comment|// optional fragment
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|_fragment
argument_list|(
name|ptr
argument_list|,
operator|&
name|parseData
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|!=
literal|'\0'
condition|)
block|{
name|parseData
operator|.
name|errorInfo
operator|->
name|setParams
argument_list|(
operator|*
name|ptr
argument_list|,
name|QT_TRANSLATE_NOOP
argument_list|(
name|QUrl
argument_list|,
literal|"expected end of URL"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QURL_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QUrlPrivate::parse(), unrecognized: %c%s"
argument_list|,
name|ch
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|qt_isValidUrlIP
name|bool
name|qt_isValidUrlIP
parameter_list|(
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
comment|// returns true if it matches IP-Literal or IPv4Address
comment|// see _host above
return|return
operator|(
name|_IPLiteral
argument_list|(
operator|&
name|ptr
argument_list|)
operator|||
name|_IPv4Address
argument_list|(
operator|&
name|ptr
argument_list|)
operator|)
operator|&&
operator|!
operator|*
name|ptr
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
