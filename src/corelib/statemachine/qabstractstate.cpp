begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qabstractstate.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STATEMACHINE
end_ifndef
begin_include
include|#
directive|include
file|"qabstractstate_p.h"
end_include
begin_include
include|#
directive|include
file|"qstate.h"
end_include
begin_include
include|#
directive|include
file|"qstate_p.h"
end_include
begin_include
include|#
directive|include
file|"qstatemachine.h"
end_include
begin_include
include|#
directive|include
file|"qstatemachine_p.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!   \class QAbstractState   \inmodule QtCore    \brief The QAbstractState class is the base class of states of a QStateMachine.    \since 4.6   \ingroup statemachine    The QAbstractState class is the abstract base class of states that are part   of a QStateMachine. It defines the interface that all state objects have in   common. QAbstractState is part of \l{The State Machine Framework}.    The entered() signal is emitted when the state has been entered. The   exited() signal is emitted when the state has been exited.    The parentState() function returns the state's parent state. The machine()   function returns the state machine that the state is part of.    \section1 Subclassing    The onEntry() function is called when the state is entered; reimplement this   function to perform custom processing when the state is entered.    The onExit() function is called when the state is exited; reimplement this   function to perform custom processing when the state is exited. */
end_comment
begin_comment
comment|/*!     \property QAbstractState::active     \since 5.4      \brief the active property of this state. A state is active between     entered() and exited() signals. */
end_comment
begin_constructor
DECL|function|QAbstractStatePrivate
name|QAbstractStatePrivate
operator|::
name|QAbstractStatePrivate
parameter_list|(
name|StateType
name|type
parameter_list|)
member_init_list|:
name|stateType
argument_list|(
name|type
argument_list|)
member_init_list|,
name|isMachine
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|active
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|parentState
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|get
name|QAbstractStatePrivate
modifier|*
name|QAbstractStatePrivate
operator|::
name|get
parameter_list|(
name|QAbstractState
modifier|*
name|q
parameter_list|)
block|{
return|return
name|q
operator|->
name|d_func
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|get
specifier|const
name|QAbstractStatePrivate
modifier|*
name|QAbstractStatePrivate
operator|::
name|get
parameter_list|(
specifier|const
name|QAbstractState
modifier|*
name|q
parameter_list|)
block|{
return|return
name|q
operator|->
name|d_func
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|machine
name|QStateMachine
modifier|*
name|QAbstractStatePrivate
operator|::
name|machine
parameter_list|()
specifier|const
block|{
name|QObject
modifier|*
name|par
init|=
name|parent
decl_stmt|;
while|while
condition|(
name|par
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|QStateMachine
modifier|*
name|mach
init|=
name|qobject_cast
argument_list|<
name|QStateMachine
operator|*
argument_list|>
argument_list|(
name|par
argument_list|)
condition|)
return|return
name|mach
return|;
name|par
operator|=
name|par
operator|->
name|parent
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|callOnEntry
name|void
name|QAbstractStatePrivate
operator|::
name|callOnEntry
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractState
argument_list|)
expr_stmt|;
name|q
operator|->
name|onEntry
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|callOnExit
name|void
name|QAbstractStatePrivate
operator|::
name|callOnExit
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractState
argument_list|)
expr_stmt|;
name|q
operator|->
name|onExit
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitEntered
name|void
name|QAbstractStatePrivate
operator|::
name|emitEntered
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractState
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|entered
argument_list|(
name|QAbstractState
operator|::
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
if|if
condition|(
operator|!
name|active
condition|)
block|{
name|active
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|activeChanged
argument_list|(
literal|true
argument_list|)
emit|;
block|}
block|}
end_function
begin_function
DECL|function|emitExited
name|void
name|QAbstractStatePrivate
operator|::
name|emitExited
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractState
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
condition|)
block|{
name|active
operator|=
literal|false
expr_stmt|;
emit|emit
name|q
operator|->
name|activeChanged
argument_list|(
literal|false
argument_list|)
emit|;
block|}
emit|emit
name|q
operator|->
name|exited
argument_list|(
name|QAbstractState
operator|::
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!   Constructs a new state with the given \a parent state. */
end_comment
begin_constructor
DECL|function|QAbstractState
name|QAbstractState
operator|::
name|QAbstractState
parameter_list|(
name|QState
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QAbstractStatePrivate
argument_list|(
name|QAbstractStatePrivate
operator|::
name|AbstractState
argument_list|)
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   \internal */
end_comment
begin_constructor
DECL|function|QAbstractState
name|QAbstractState
operator|::
name|QAbstractState
parameter_list|(
name|QAbstractStatePrivate
modifier|&
name|dd
parameter_list|,
name|QState
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Destroys this state. */
end_comment
begin_destructor
DECL|function|~QAbstractState
name|QAbstractState
operator|::
name|~
name|QAbstractState
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!   Returns this state's parent state, or 0 if the state has no parent state. */
end_comment
begin_function
DECL|function|parentState
name|QState
modifier|*
name|QAbstractState
operator|::
name|parentState
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractState
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|parentState
operator|!=
name|parent
argument_list|()
condition|)
name|d
operator|->
name|parentState
operator|=
name|qobject_cast
argument_list|<
name|QState
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|parentState
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the state machine that this state is part of, or 0 if the state is   not part of a state machine. */
end_comment
begin_function
DECL|function|machine
name|QStateMachine
modifier|*
name|QAbstractState
operator|::
name|machine
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractState
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|machine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns whether this state is active.    \sa activeChanged(bool), entered(), exited() */
end_comment
begin_function
DECL|function|active
name|bool
name|QAbstractState
operator|::
name|active
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractState
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|active
return|;
block|}
end_function
begin_comment
comment|/*!   \fn QAbstractState::onExit(QEvent *event)    This function is called when the state is exited. The given \a event is what   caused the state to be exited. Reimplement this function to perform custom   processing when the state is exited. */
end_comment
begin_comment
comment|/*!   \fn QAbstractState::onEntry(QEvent *event)    This function is called when the state is entered. The given \a event is   what caused the state to be entered. Reimplement this function to perform   custom processing when the state is entered. */
end_comment
begin_comment
comment|/*!   \fn QAbstractState::entered()    This signal is emitted when the state has been entered (after onEntry() has   been called). */
end_comment
begin_comment
comment|/*!   \fn QAbstractState::exited()    This signal is emitted when the state has been exited (after onExit() has   been called). */
end_comment
begin_comment
comment|/*!   \fn QAbstractState::activeChanged(bool active)   \since 5.4    This signal is emitted when the active property is changed.    \sa QAbstractState::active, entered(), exited() */
end_comment
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QAbstractState
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
return|return
name|QObject
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_STATEMACHINE
end_comment
end_unit
