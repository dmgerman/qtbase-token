begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qstatemachine.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STATEMACHINE
end_ifndef
begin_include
include|#
directive|include
file|"qstate.h"
end_include
begin_include
include|#
directive|include
file|"qstate_p.h"
end_include
begin_include
include|#
directive|include
file|"qstatemachine_p.h"
end_include
begin_include
include|#
directive|include
file|"qabstracttransition.h"
end_include
begin_include
include|#
directive|include
file|"qabstracttransition_p.h"
end_include
begin_include
include|#
directive|include
file|"qsignaltransition.h"
end_include
begin_include
include|#
directive|include
file|"qsignaltransition_p.h"
end_include
begin_include
include|#
directive|include
file|"qsignaleventgenerator_p.h"
end_include
begin_include
include|#
directive|include
file|"qabstractstate.h"
end_include
begin_include
include|#
directive|include
file|"qabstractstate_p.h"
end_include
begin_include
include|#
directive|include
file|"qfinalstate.h"
end_include
begin_include
include|#
directive|include
file|"qhistorystate.h"
end_include
begin_include
include|#
directive|include
file|"qhistorystate_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qobject_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qthread_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STATEMACHINE_EVENTFILTER
end_ifndef
begin_include
include|#
directive|include
file|"qeventtransition.h"
end_include
begin_include
include|#
directive|include
file|"qeventtransition_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
end_ifndef
begin_include
include|#
directive|include
file|"qpropertyanimation.h"
end_include
begin_include
include|#
directive|include
file|"qanimationgroup.h"
end_include
begin_include
include|#
directive|include
file|<private/qvariantanimation_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<QtCore/qmetaobject.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QStateMachine     \inmodule QtCore     \reentrant      \brief The QStateMachine class provides a hierarchical finite state machine.      \since 4.6     \ingroup statemachine      QStateMachine is based on the concepts and notation of     \l{http://www.wisdom.weizmann.ac.il/~dharel/SCANNED.PAPERS/Statecharts.pdf}{Statecharts}.     QStateMachine is part of \l{The State Machine Framework}.      A state machine manages a set of states (classes that inherit from     QAbstractState) and transitions (descendants of     QAbstractTransition) between those states; these states and     transitions define a state graph. Once a state graph has been     built, the state machine can execute it. QStateMachine's     execution algorithm is based on the \l{http://www.w3.org/TR/scxml/}{State Chart XML (SCXML)}     algorithm. The framework's \l{The State Machine     Framework}{overview} gives several state graphs and the code to     build them.      Use the addState() function to add a top-level state to the state machine.     States are removed with the removeState() function. Removing states while     the machine is running is discouraged.      Before the machine can be started, the \l{initialState}{initial     state} must be set. The initial state is the state that the     machine enters when started. You can then start() the state     machine. The started() signal is emitted when the initial state is     entered.      The machine is event driven and keeps its own event loop. Events     are posted to the machine through postEvent(). Note that this     means that it executes asynchronously, and that it will not     progress without a running event loop. You will normally not have     to post events to the machine directly as Qt's transitions, e.g.,     QEventTransition and its subclasses, handle this. But for custom     transitions triggered by events, postEvent() is useful.      The state machine processes events and takes transitions until a     top-level final state is entered; the state machine then emits the     finished() signal. You can also stop() the state machine     explicitly. The stopped() signal is emitted in this case.      The following snippet shows a state machine that will finish when a button     is clicked:      \snippet code/src_corelib_statemachine_qstatemachine.cpp simple state machine      This code example uses QState, which inherits QAbstractState. The     QState class provides a state that you can use to set properties     and invoke methods on \l{QObject}s when the state is entered or     exited. It also contains convenience functions for adding     transitions, e.g., \l{QSignalTransition}s as in this example. See     the QState class description for further details.      If an error is encountered, the machine will look for an     \l{errorState}{error state}, and if one is available, it will     enter this state. The types of errors possible are described by the     \l{QStateMachine::}{Error} enum. After the error state is entered,     the type of the error can be retrieved with error(). The execution     of the state graph will not stop when the error state is entered. If     no error state applies to the erroneous state, the machine will stop     executing and an error message will be printed to the console.      \sa QAbstractState, QAbstractTransition, QState, {The State Machine Framework} */
end_comment
begin_comment
comment|/*!     \property QStateMachine::errorString      \brief the error string of this state machine */
end_comment
begin_comment
comment|/*!     \property QStateMachine::globalRestorePolicy      \brief the restore policy for states of this state machine.      The default value of this property is     QState::DontRestoreProperties. */
end_comment
begin_comment
comment|/*!     \property QStateMachine::running     \since 5.4      \brief the running state of this state machine      \sa start(), stop(), started(), stopped(), runningChanged() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
end_ifndef
begin_comment
comment|/*!     \property QStateMachine::animated      \brief whether animations are enabled      The default value of this property is \c true.      \sa QAbstractTransition::addAnimation() */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// #define QSTATEMACHINE_DEBUG
end_comment
begin_comment
comment|// #define QSTATEMACHINE_RESTORE_PROPERTIES_DEBUG
end_comment
begin_struct
DECL|struct|CalculationCache
struct|struct
name|CalculationCache
block|{
DECL|struct|TransitionInfo
struct|struct
name|TransitionInfo
block|{
DECL|member|effectiveTargetStates
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|effectiveTargetStates
decl_stmt|;
DECL|member|exitSet
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|exitSet
decl_stmt|;
DECL|member|transitionDomain
name|QAbstractState
modifier|*
name|transitionDomain
decl_stmt|;
DECL|member|effectiveTargetStatesIsKnown
name|bool
name|effectiveTargetStatesIsKnown
range|:
literal|1
decl_stmt|;
DECL|member|exitSetIsKnown
name|bool
name|exitSetIsKnown
range|:
literal|1
decl_stmt|;
DECL|member|transitionDomainIsKnown
name|bool
name|transitionDomainIsKnown
range|:
literal|1
decl_stmt|;
DECL|function|TransitionInfo
name|TransitionInfo
parameter_list|()
member_init_list|:
name|transitionDomain
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|effectiveTargetStatesIsKnown
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|exitSetIsKnown
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|transitionDomainIsKnown
argument_list|(
literal|false
argument_list|)
block|{}
block|}
struct|;
DECL|typedef|TransitionInfoCache
typedef|typedef
name|QHash
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|,
name|TransitionInfo
argument_list|>
name|TransitionInfoCache
typedef|;
DECL|member|cache
name|TransitionInfoCache
name|cache
decl_stmt|;
DECL|function|effectiveTargetStates
name|bool
name|effectiveTargetStates
parameter_list|(
name|QAbstractTransition
modifier|*
name|t
parameter_list|,
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|*
name|targets
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|targets
argument_list|)
expr_stmt|;
name|TransitionInfoCache
operator|::
name|const_iterator
name|cacheIt
init|=
name|cache
operator|.
name|find
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|cacheIt
operator|==
name|cache
operator|.
name|end
argument_list|()
operator|||
operator|!
name|cacheIt
operator|->
name|effectiveTargetStatesIsKnown
condition|)
return|return
literal|false
return|;
operator|*
name|targets
operator|=
name|cacheIt
operator|->
name|effectiveTargetStates
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|insert
name|void
name|insert
parameter_list|(
name|QAbstractTransition
modifier|*
name|t
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|targets
parameter_list|)
block|{
name|TransitionInfoCache
operator|::
name|iterator
name|cacheIt
init|=
name|cache
operator|.
name|find
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|TransitionInfo
modifier|&
name|ti
init|=
name|cacheIt
operator|==
name|cache
operator|.
name|end
argument_list|()
condition|?
operator|*
name|cache
operator|.
name|insert
argument_list|(
name|t
argument_list|,
name|TransitionInfo
argument_list|()
argument_list|)
else|:
operator|*
name|cacheIt
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|ti
operator|.
name|effectiveTargetStatesIsKnown
argument_list|)
expr_stmt|;
name|ti
operator|.
name|effectiveTargetStates
operator|=
name|targets
expr_stmt|;
name|ti
operator|.
name|effectiveTargetStatesIsKnown
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|exitSet
name|bool
name|exitSet
parameter_list|(
name|QAbstractTransition
modifier|*
name|t
parameter_list|,
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|*
name|exits
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|exits
argument_list|)
expr_stmt|;
name|TransitionInfoCache
operator|::
name|const_iterator
name|cacheIt
init|=
name|cache
operator|.
name|find
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|cacheIt
operator|==
name|cache
operator|.
name|end
argument_list|()
operator|||
operator|!
name|cacheIt
operator|->
name|exitSetIsKnown
condition|)
return|return
literal|false
return|;
operator|*
name|exits
operator|=
name|cacheIt
operator|->
name|exitSet
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|insert
name|void
name|insert
parameter_list|(
name|QAbstractTransition
modifier|*
name|t
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|exits
parameter_list|)
block|{
name|TransitionInfoCache
operator|::
name|iterator
name|cacheIt
init|=
name|cache
operator|.
name|find
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|TransitionInfo
modifier|&
name|ti
init|=
name|cacheIt
operator|==
name|cache
operator|.
name|end
argument_list|()
condition|?
operator|*
name|cache
operator|.
name|insert
argument_list|(
name|t
argument_list|,
name|TransitionInfo
argument_list|()
argument_list|)
else|:
operator|*
name|cacheIt
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|ti
operator|.
name|exitSetIsKnown
argument_list|)
expr_stmt|;
name|ti
operator|.
name|exitSet
operator|=
name|exits
expr_stmt|;
name|ti
operator|.
name|exitSetIsKnown
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|transitionDomain
name|bool
name|transitionDomain
parameter_list|(
name|QAbstractTransition
modifier|*
name|t
parameter_list|,
name|QAbstractState
modifier|*
modifier|*
name|domain
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|TransitionInfoCache
operator|::
name|const_iterator
name|cacheIt
init|=
name|cache
operator|.
name|find
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|cacheIt
operator|==
name|cache
operator|.
name|end
argument_list|()
operator|||
operator|!
name|cacheIt
operator|->
name|transitionDomainIsKnown
condition|)
return|return
literal|false
return|;
operator|*
name|domain
operator|=
name|cacheIt
operator|->
name|transitionDomain
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|insert
name|void
name|insert
parameter_list|(
name|QAbstractTransition
modifier|*
name|t
parameter_list|,
name|QAbstractState
modifier|*
name|domain
parameter_list|)
block|{
name|TransitionInfoCache
operator|::
name|iterator
name|cacheIt
init|=
name|cache
operator|.
name|find
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|TransitionInfo
modifier|&
name|ti
init|=
name|cacheIt
operator|==
name|cache
operator|.
name|end
argument_list|()
condition|?
operator|*
name|cache
operator|.
name|insert
argument_list|(
name|t
argument_list|,
name|TransitionInfo
argument_list|()
argument_list|)
else|:
operator|*
name|cacheIt
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|ti
operator|.
name|transitionDomainIsKnown
argument_list|)
expr_stmt|;
name|ti
operator|.
name|transitionDomain
operator|=
name|domain
expr_stmt|;
name|ti
operator|.
name|transitionDomainIsKnown
operator|=
literal|true
expr_stmt|;
block|}
block|}
struct|;
end_struct
begin_comment
comment|/* The function as described in http://www.w3.org/TR/2014/WD-scxml-20140529/ :  function isDescendant(state1, state2)  Returns 'true' if state1 is a descendant of state2 (a child, or a child of a child, or a child of a child of a child, etc.) Otherwise returns 'false'. */
end_comment
begin_function
DECL|function|isDescendant
specifier|static
specifier|inline
name|bool
name|isDescendant
parameter_list|(
specifier|const
name|QAbstractState
modifier|*
name|state1
parameter_list|,
specifier|const
name|QAbstractState
modifier|*
name|state2
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|state1
operator|!=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|QAbstractState
modifier|*
name|it
init|=
name|state1
operator|->
name|parentState
argument_list|()
init|;
name|it
operator|!=
literal|0
condition|;
name|it
operator|=
name|it
operator|->
name|parentState
argument_list|()
control|)
block|{
if|if
condition|(
name|it
operator|==
name|state2
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|containsDecendantOf
specifier|static
name|bool
name|containsDecendantOf
parameter_list|(
specifier|const
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|states
parameter_list|,
specifier|const
name|QAbstractState
modifier|*
name|node
parameter_list|)
block|{
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|s
decl|,
name|states
control|)
if|if
condition|(
name|isDescendant
argument_list|(
name|s
argument_list|,
name|node
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|descendantDepth
specifier|static
name|int
name|descendantDepth
parameter_list|(
specifier|const
name|QAbstractState
modifier|*
name|state
parameter_list|,
specifier|const
name|QAbstractState
modifier|*
name|ancestor
parameter_list|)
block|{
name|int
name|depth
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|const
name|QAbstractState
modifier|*
name|it
init|=
name|state
init|;
name|it
operator|!=
literal|0
condition|;
name|it
operator|=
name|it
operator|->
name|parentState
argument_list|()
control|)
block|{
if|if
condition|(
name|it
operator|==
name|ancestor
condition|)
break|break;
operator|++
name|depth
expr_stmt|;
block|}
return|return
name|depth
return|;
block|}
end_function
begin_comment
comment|/* The function as described in http://www.w3.org/TR/2014/WD-scxml-20140529/ :  function getProperAncestors(state1, state2)  If state2 is null, returns the set of all ancestors of state1 in ancestry order (state1's parent followed by the parent's parent, etc. up to an including the<scxml> element). If state2 is non-null, returns in ancestry order the set of all ancestors of state1, up to but not including state2. (A "proper ancestor" of a state is its parent, or the parent's parent, or the parent's parent's parent, etc.))If state2 is state1's parent, or equal to state1, or a descendant of state1, this returns the empty set. */
end_comment
begin_function
DECL|function|getProperAncestors
specifier|static
name|QVector
argument_list|<
name|QState
modifier|*
argument_list|>
name|getProperAncestors
parameter_list|(
specifier|const
name|QAbstractState
modifier|*
name|state
parameter_list|,
specifier|const
name|QAbstractState
modifier|*
name|upperBound
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|state
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QState
modifier|*
argument_list|>
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|QState
modifier|*
name|it
init|=
name|state
operator|->
name|parentState
argument_list|()
init|;
name|it
operator|&&
name|it
operator|!=
name|upperBound
condition|;
name|it
operator|=
name|it
operator|->
name|parentState
argument_list|()
control|)
block|{
name|result
operator|.
name|append
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/* The function as described in http://www.w3.org/TR/2014/WD-scxml-20140529/ :  function getEffectiveTargetStates(transition)  Returns the states that will be the target when 'transition' is taken, dereferencing any history states.  function getEffectiveTargetStates(transition)     targets = new OrderedSet()     for s in transition.target         if isHistoryState(s):             if historyValue[s.id]:                 targets.union(historyValue[s.id])             else:                 targets.union(getEffectiveTargetStates(s.transition))         else:             targets.add(s)     return targets */
end_comment
begin_function
DECL|function|getEffectiveTargetStates
specifier|static
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|getEffectiveTargetStates
parameter_list|(
name|QAbstractTransition
modifier|*
name|transition
parameter_list|,
name|CalculationCache
modifier|*
name|cache
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|targetsList
decl_stmt|;
if|if
condition|(
name|cache
operator|->
name|effectiveTargetStates
argument_list|(
name|transition
argument_list|,
operator|&
name|targetsList
argument_list|)
condition|)
return|return
name|targetsList
return|;
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|targets
decl_stmt|;
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|s
decl|,
name|transition
operator|->
name|targetStates
argument_list|()
control|)
block|{
if|if
condition|(
name|QHistoryState
modifier|*
name|historyState
init|=
name|QStateMachinePrivate
operator|::
name|toHistoryState
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|historyConfiguration
init|=
name|QHistoryStatePrivate
operator|::
name|get
argument_list|(
name|historyState
argument_list|)
operator|->
name|configuration
decl_stmt|;
if|if
condition|(
operator|!
name|historyConfiguration
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// There is a saved history, so apply that.
name|targets
operator|.
name|unite
argument_list|(
name|historyConfiguration
operator|.
name|toSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QAbstractTransition
modifier|*
name|defaultTransition
init|=
name|historyState
operator|->
name|defaultTransition
argument_list|()
condition|)
block|{
comment|// No saved history, take all default transition targets.
name|targets
operator|.
name|unite
argument_list|(
name|defaultTransition
operator|->
name|targetStates
argument_list|()
operator|.
name|toSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Woops, we found a history state without a default state. That's not valid!
name|QStateMachinePrivate
modifier|*
name|m
init|=
name|QStateMachinePrivate
operator|::
name|get
argument_list|(
name|historyState
operator|->
name|machine
argument_list|()
argument_list|)
decl_stmt|;
name|m
operator|->
name|setError
argument_list|(
name|QStateMachine
operator|::
name|NoDefaultStateInHistoryStateError
argument_list|,
name|historyState
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|targets
operator|.
name|insert
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|targetsList
operator|=
name|targets
operator|.
name|toList
argument_list|()
expr_stmt|;
name|cache
operator|->
name|insert
argument_list|(
name|transition
argument_list|,
name|targetsList
argument_list|)
expr_stmt|;
return|return
name|targetsList
return|;
block|}
end_function
begin_constructor
DECL|function|QStateMachinePrivate
name|QStateMachinePrivate
operator|::
name|QStateMachinePrivate
parameter_list|()
block|{
name|isMachine
operator|=
literal|true
expr_stmt|;
name|state
operator|=
name|NotRunning
expr_stmt|;
name|processing
operator|=
literal|false
expr_stmt|;
name|processingScheduled
operator|=
literal|false
expr_stmt|;
name|stop
operator|=
literal|false
expr_stmt|;
name|stopProcessingReason
operator|=
name|EventQueueEmpty
expr_stmt|;
name|error
operator|=
name|QStateMachine
operator|::
name|NoError
expr_stmt|;
name|globalRestorePolicy
operator|=
name|QState
operator|::
name|DontRestoreProperties
expr_stmt|;
name|signalEventGenerator
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
name|animated
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_destructor
DECL|function|~QStateMachinePrivate
name|QStateMachinePrivate
operator|::
name|~
name|QStateMachinePrivate
parameter_list|()
block|{
name|qDeleteAll
argument_list|(
name|internalEventQueue
argument_list|)
expr_stmt|;
name|qDeleteAll
argument_list|(
name|externalEventQueue
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|rootState
name|QState
modifier|*
name|QStateMachinePrivate
operator|::
name|rootState
parameter_list|()
specifier|const
block|{
return|return
cast|const_cast
argument_list|<
name|QStateMachine
operator|*
argument_list|>
argument_list|(
name|q_func
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|cloneEvent
specifier|static
name|QEvent
modifier|*
name|cloneEvent
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|None
case|:
return|return
operator|new
name|QEvent
argument_list|(
operator|*
name|e
argument_list|)
return|;
case|case
name|QEvent
operator|::
name|Timer
case|:
return|return
operator|new
name|QTimerEvent
argument_list|(
operator|*
cast|static_cast
argument_list|<
name|QTimerEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
argument_list|)
return|;
default|default:
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"cloneEvent()"
argument_list|,
literal|"not implemented"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|qt_kernel_statemachine_handler
specifier|const
name|QStateMachinePrivate
operator|::
name|Handler
name|qt_kernel_statemachine_handler
init|=
block|{
name|cloneEvent
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|handler
specifier|const
name|QStateMachinePrivate
operator|::
name|Handler
modifier|*
name|QStateMachinePrivate
operator|::
name|handler
init|=
operator|&
name|qt_kernel_statemachine_handler
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qcoreStateMachineHandler
name|Q_CORE_EXPORT
specifier|const
name|QStateMachinePrivate
operator|::
name|Handler
modifier|*
name|qcoreStateMachineHandler
parameter_list|()
block|{
return|return
operator|&
name|qt_kernel_statemachine_handler
return|;
block|}
end_function
begin_function
DECL|function|indexOfDescendant
specifier|static
name|int
name|indexOfDescendant
parameter_list|(
name|QState
modifier|*
name|s
parameter_list|,
name|QAbstractState
modifier|*
name|desc
parameter_list|)
block|{
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|childStates
init|=
name|QStatePrivate
operator|::
name|get
argument_list|(
name|s
argument_list|)
operator|->
name|childStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childStates
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractState
modifier|*
name|c
init|=
name|childStates
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|desc
operator|)
operator|||
name|isDescendant
argument_list|(
name|desc
argument_list|,
name|c
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|transitionStateEntryLessThan
name|bool
name|QStateMachinePrivate
operator|::
name|transitionStateEntryLessThan
parameter_list|(
name|QAbstractTransition
modifier|*
name|t1
parameter_list|,
name|QAbstractTransition
modifier|*
name|t2
parameter_list|)
block|{
name|QState
modifier|*
name|s1
init|=
name|t1
operator|->
name|sourceState
argument_list|()
decl_stmt|,
modifier|*
name|s2
init|=
name|t2
operator|->
name|sourceState
argument_list|()
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|s2
condition|)
block|{
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
name|transitions
init|=
name|QStatePrivate
operator|::
name|get
argument_list|(
name|s1
argument_list|)
operator|->
name|transitions
argument_list|()
decl_stmt|;
return|return
name|transitions
operator|.
name|indexOf
argument_list|(
name|t1
argument_list|)
operator|<
name|transitions
operator|.
name|indexOf
argument_list|(
name|t2
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isDescendant
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|isDescendant
argument_list|(
name|s2
argument_list|,
name|s1
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|s1
operator|->
name|machine
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QStateMachinePrivate
modifier|*
name|mach
init|=
name|QStateMachinePrivate
operator|::
name|get
argument_list|(
name|s1
operator|->
name|machine
argument_list|()
argument_list|)
decl_stmt|;
name|QState
modifier|*
name|lca
init|=
name|mach
operator|->
name|findLCA
argument_list|(
name|QList
argument_list|<
name|QAbstractState
operator|*
argument_list|>
argument_list|()
operator|<<
name|s1
operator|<<
name|s2
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|lca
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|int
name|s1Depth
init|=
name|descendantDepth
argument_list|(
name|s1
argument_list|,
name|lca
argument_list|)
decl_stmt|;
name|int
name|s2Depth
init|=
name|descendantDepth
argument_list|(
name|s2
argument_list|,
name|lca
argument_list|)
decl_stmt|;
if|if
condition|(
name|s1Depth
operator|==
name|s2Depth
condition|)
return|return
operator|(
name|indexOfDescendant
argument_list|(
name|lca
argument_list|,
name|s1
argument_list|)
operator|<
name|indexOfDescendant
argument_list|(
name|lca
argument_list|,
name|s2
argument_list|)
operator|)
return|;
else|else
return|return
name|s1Depth
operator|>
name|s2Depth
return|;
block|}
block|}
end_function
begin_function
DECL|function|stateEntryLessThan
name|bool
name|QStateMachinePrivate
operator|::
name|stateEntryLessThan
parameter_list|(
name|QAbstractState
modifier|*
name|s1
parameter_list|,
name|QAbstractState
modifier|*
name|s2
parameter_list|)
block|{
if|if
condition|(
name|s1
operator|->
name|parent
argument_list|()
operator|==
name|s2
operator|->
name|parent
argument_list|()
condition|)
block|{
return|return
name|s1
operator|->
name|parent
argument_list|()
operator|->
name|children
argument_list|()
operator|.
name|indexOf
argument_list|(
name|s1
argument_list|)
operator|<
name|s2
operator|->
name|parent
argument_list|()
operator|->
name|children
argument_list|()
operator|.
name|indexOf
argument_list|(
name|s2
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isDescendant
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|isDescendant
argument_list|(
name|s2
argument_list|,
name|s1
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|s1
operator|->
name|machine
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QStateMachinePrivate
modifier|*
name|mach
init|=
name|QStateMachinePrivate
operator|::
name|get
argument_list|(
name|s1
operator|->
name|machine
argument_list|()
argument_list|)
decl_stmt|;
name|QState
modifier|*
name|lca
init|=
name|mach
operator|->
name|findLCA
argument_list|(
name|QList
argument_list|<
name|QAbstractState
operator|*
argument_list|>
argument_list|()
operator|<<
name|s1
operator|<<
name|s2
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|lca
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|indexOfDescendant
argument_list|(
name|lca
argument_list|,
name|s1
argument_list|)
operator|<
name|indexOfDescendant
argument_list|(
name|lca
argument_list|,
name|s2
argument_list|)
operator|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|stateExitLessThan
name|bool
name|QStateMachinePrivate
operator|::
name|stateExitLessThan
parameter_list|(
name|QAbstractState
modifier|*
name|s1
parameter_list|,
name|QAbstractState
modifier|*
name|s2
parameter_list|)
block|{
if|if
condition|(
name|s1
operator|->
name|parent
argument_list|()
operator|==
name|s2
operator|->
name|parent
argument_list|()
condition|)
block|{
return|return
name|s2
operator|->
name|parent
argument_list|()
operator|->
name|children
argument_list|()
operator|.
name|indexOf
argument_list|(
name|s2
argument_list|)
operator|<
name|s1
operator|->
name|parent
argument_list|()
operator|->
name|children
argument_list|()
operator|.
name|indexOf
argument_list|(
name|s1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isDescendant
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|isDescendant
argument_list|(
name|s2
argument_list|,
name|s1
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|s1
operator|->
name|machine
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QStateMachinePrivate
modifier|*
name|mach
init|=
name|QStateMachinePrivate
operator|::
name|get
argument_list|(
name|s1
operator|->
name|machine
argument_list|()
argument_list|)
decl_stmt|;
name|QState
modifier|*
name|lca
init|=
name|mach
operator|->
name|findLCA
argument_list|(
name|QList
argument_list|<
name|QAbstractState
operator|*
argument_list|>
argument_list|()
operator|<<
name|s1
operator|<<
name|s2
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|lca
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|indexOfDescendant
argument_list|(
name|lca
argument_list|,
name|s2
argument_list|)
operator|<
name|indexOfDescendant
argument_list|(
name|lca
argument_list|,
name|s1
argument_list|)
operator|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|findLCA
name|QState
modifier|*
name|QStateMachinePrivate
operator|::
name|findLCA
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|states
parameter_list|,
name|bool
name|onlyCompound
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|states
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|QVector
argument_list|<
name|QState
modifier|*
argument_list|>
name|ancestors
init|=
name|getProperAncestors
argument_list|(
name|states
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rootState
argument_list|()
operator|->
name|parentState
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ancestors
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QState
modifier|*
name|anc
init|=
name|ancestors
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|onlyCompound
operator|&&
operator|!
name|isCompound
argument_list|(
name|anc
argument_list|)
condition|)
continue|continue;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|states
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
operator|(
name|j
operator|>
literal|0
operator|)
operator|&&
name|ok
condition|;
operator|--
name|j
control|)
block|{
specifier|const
name|QAbstractState
modifier|*
name|s
init|=
name|states
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isDescendant
argument_list|(
name|s
argument_list|,
name|anc
argument_list|)
condition|)
name|ok
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
return|return
name|anc
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|findLCCA
name|QState
modifier|*
name|QStateMachinePrivate
operator|::
name|findLCCA
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|states
parameter_list|)
specifier|const
block|{
return|return
name|findLCA
argument_list|(
name|states
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|selectTransitions
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
name|QStateMachinePrivate
operator|::
name|selectTransitions
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
name|CalculationCache
modifier|*
name|cache
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|Q_Q
argument_list|(
specifier|const
name|QStateMachine
argument_list|)
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|configuration_sorted
decl_stmt|;
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|s
decl|,
name|configuration
control|)
block|{
if|if
condition|(
name|isAtomic
argument_list|(
name|s
argument_list|)
condition|)
name|configuration_sorted
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|std
operator|::
name|sort
argument_list|(
name|configuration_sorted
operator|.
name|begin
argument_list|()
argument_list|,
name|configuration_sorted
operator|.
name|end
argument_list|()
argument_list|,
name|stateEntryLessThan
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
name|enabledTransitions
decl_stmt|;
cast|const_cast
argument_list|<
name|QStateMachine
operator|*
argument_list|>
argument_list|(
name|q
argument_list|)
operator|->
name|beginSelectTransitions
argument_list|(
name|event
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|state
decl|,
name|configuration_sorted
control|)
block|{
name|QVector
argument_list|<
name|QState
modifier|*
argument_list|>
name|lst
init|=
name|getProperAncestors
argument_list|(
name|state
argument_list|,
name|Q_NULLPTR
argument_list|)
decl_stmt|;
if|if
condition|(
name|QState
modifier|*
name|grp
init|=
name|toStandardState
argument_list|(
name|state
argument_list|)
condition|)
name|lst
operator|.
name|prepend
argument_list|(
name|grp
argument_list|)
expr_stmt|;
name|bool
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
operator|(
name|j
operator|<
name|lst
operator|.
name|size
argument_list|()
operator|)
operator|&&
operator|!
name|found
condition|;
operator|++
name|j
control|)
block|{
name|QState
modifier|*
name|s
init|=
name|lst
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
name|transitions
init|=
name|QStatePrivate
operator|::
name|get
argument_list|(
name|s
argument_list|)
operator|->
name|transitions
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|transitions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|k
control|)
block|{
name|QAbstractTransition
modifier|*
name|t
init|=
name|transitions
operator|.
name|at
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|QAbstractTransitionPrivate
operator|::
name|get
argument_list|(
name|t
argument_list|)
operator|->
name|callEventTest
argument_list|(
name|event
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": selecting transition"
operator|<<
name|t
expr_stmt|;
endif|#
directive|endif
name|enabledTransitions
operator|.
name|append
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|enabledTransitions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|removeConflictingTransitions
argument_list|(
name|enabledTransitions
argument_list|,
name|cache
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": enabled transitions after removing conflicts:"
operator|<<
name|enabledTransitions
expr_stmt|;
endif|#
directive|endif
block|}
cast|const_cast
argument_list|<
name|QStateMachine
operator|*
argument_list|>
argument_list|(
name|q
argument_list|)
operator|->
name|endSelectTransitions
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return
name|enabledTransitions
return|;
block|}
end_function
begin_comment
comment|/* The function as described in http://www.w3.org/TR/2014/WD-scxml-20140529/ :  function removeConflictingTransitions(enabledTransitions):     filteredTransitions = new OrderedSet()  // toList sorts the transitions in the order of the states that selected them     for t1 in enabledTransitions.toList():         t1Preempted = false;         transitionsToRemove = new OrderedSet()         for t2 in filteredTransitions.toList():             if computeExitSet([t1]).hasIntersection(computeExitSet([t2])):                 if isDescendant(t1.source, t2.source):                     transitionsToRemove.add(t2)                 else:                     t1Preempted = true                     break         if not t1Preempted:             for t3 in transitionsToRemove.toList():                 filteredTransitions.delete(t3)             filteredTransitions.add(t1)      return filteredTransitions  Note: the implementation below does not build the transitionsToRemove, but removes them in-place. */
end_comment
begin_function
DECL|function|removeConflictingTransitions
name|void
name|QStateMachinePrivate
operator|::
name|removeConflictingTransitions
parameter_list|(
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
modifier|&
name|enabledTransitions
parameter_list|,
name|CalculationCache
modifier|*
name|cache
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabledTransitions
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
return|return;
comment|// There is no transition to conflict with.
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
name|filteredTransitions
decl_stmt|;
name|filteredTransitions
operator|.
name|reserve
argument_list|(
name|enabledTransitions
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|enabledTransitions
operator|.
name|begin
argument_list|()
argument_list|,
name|enabledTransitions
operator|.
name|end
argument_list|()
argument_list|,
name|transitionStateEntryLessThan
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QAbstractTransition
modifier|*
name|t1
decl|,
name|enabledTransitions
control|)
block|{
name|bool
name|t1Preempted
init|=
literal|false
decl_stmt|;
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|exitSetT1
init|=
name|computeExitSet_Unordered
argument_list|(
name|t1
argument_list|,
name|cache
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
operator|::
name|iterator
name|t2It
init|=
name|filteredTransitions
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|t2It
operator|!=
name|filteredTransitions
operator|.
name|end
argument_list|()
condition|)
block|{
name|QAbstractTransition
modifier|*
name|t2
init|=
operator|*
name|t2It
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
block|{
comment|// Special case: someone added the same transition object to a state twice. In this
comment|// case, t2 (which is already in the list) "preempts" t1.
name|t1Preempted
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|exitSetT2
init|=
name|computeExitSet_Unordered
argument_list|(
name|t2
argument_list|,
name|cache
argument_list|)
decl_stmt|;
if|if
condition|(
name|exitSetT1
operator|.
name|intersect
argument_list|(
name|exitSetT2
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No conflict, no cry. Next patient please.
operator|++
name|t2It
expr_stmt|;
block|}
else|else
block|{
comment|// Houston, we have a conflict. Check which transition can be removed.
if|if
condition|(
name|isDescendant
argument_list|(
name|t1
operator|->
name|sourceState
argument_list|()
argument_list|,
name|t2
operator|->
name|sourceState
argument_list|()
argument_list|)
condition|)
block|{
comment|// t1 preempts t2, so we can remove t2
name|t2It
operator|=
name|filteredTransitions
operator|.
name|erase
argument_list|(
name|t2It
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// t2 preempts t1, so there's no use in looking further and we don't need to add
comment|// t1 to the list.
name|t1Preempted
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|t1Preempted
condition|)
name|filteredTransitions
operator|.
name|append
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
name|enabledTransitions
operator|=
name|filteredTransitions
expr_stmt|;
block|}
end_function
begin_function
DECL|function|microstep
name|void
name|QStateMachinePrivate
operator|::
name|microstep
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
modifier|&
name|enabledTransitions
parameter_list|,
name|CalculationCache
modifier|*
name|cache
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|cache
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": begin microstep( enabledTransitions:"
operator|<<
name|enabledTransitions
operator|<<
literal|')'
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": configuration before exiting states:"
operator|<<
name|configuration
expr_stmt|;
endif|#
directive|endif
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|exitedStates
init|=
name|computeExitSet
argument_list|(
name|enabledTransitions
argument_list|,
name|cache
argument_list|)
decl_stmt|;
name|QHash
argument_list|<
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
name|pendingRestorables
init|=
name|computePendingRestorables
argument_list|(
name|exitedStates
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|statesForDefaultEntry
decl_stmt|;
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|enteredStates
init|=
name|computeEntrySet
argument_list|(
name|enabledTransitions
argument_list|,
name|statesForDefaultEntry
argument_list|,
name|cache
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": computed exit set:"
operator|<<
name|exitedStates
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": computed entry set:"
operator|<<
name|enteredStates
expr_stmt|;
endif|#
directive|endif
name|QHash
argument_list|<
name|QAbstractState
modifier|*
argument_list|,
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
argument_list|>
name|assignmentsForEnteredStates
init|=
name|computePropertyAssignments
argument_list|(
name|enteredStates
argument_list|,
name|pendingRestorables
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pendingRestorables
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Add "implicit" assignments for restored properties to the first
comment|// (outermost) entered state
name|Q_ASSERT
argument_list|(
operator|!
name|enteredStates
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|QAbstractState
modifier|*
name|s
init|=
name|enteredStates
operator|.
name|first
argument_list|()
decl_stmt|;
name|assignmentsForEnteredStates
index|[
name|s
index|]
operator|<<
name|restorablesToPropertyList
argument_list|(
name|pendingRestorables
argument_list|)
expr_stmt|;
block|}
name|exitStates
argument_list|(
name|event
argument_list|,
name|exitedStates
argument_list|,
name|assignmentsForEnteredStates
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": configuration after exiting states:"
operator|<<
name|configuration
expr_stmt|;
endif|#
directive|endif
name|executeTransitionContent
argument_list|(
name|event
argument_list|,
name|enabledTransitions
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
name|selectedAnimations
init|=
name|selectAnimations
argument_list|(
name|enabledTransitions
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|enterStates
argument_list|(
name|event
argument_list|,
name|exitedStates
argument_list|,
name|enteredStates
argument_list|,
name|statesForDefaultEntry
argument_list|,
name|assignmentsForEnteredStates
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
argument_list|,
name|selectedAnimations
endif|#
directive|endif
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": configuration after entering states:"
operator|<<
name|configuration
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": end microstep"
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* The function as described in http://www.w3.org/TR/2014/WD-scxml-20140529/ :  procedure computeExitSet(enabledTransitions)  For each transition t in enabledTransitions, if t is targetless then do nothing, else compute the transition's domain. (This will be the source state in the case of internal transitions) or the least common compound ancestor state of the source state and target states of t (in the case of external transitions. Add to the statesToExit set all states in the configuration that are descendants of the domain.  function computeExitSet(transitions)    statesToExit = new OrderedSet      for t in transitions:        if (t.target):           domain = getTransitionDomain(t)           for s in configuration:              if isDescendant(s,domain):                statesToExit.add(s)    return statesToExit */
end_comment
begin_function
DECL|function|computeExitSet
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|QStateMachinePrivate
operator|::
name|computeExitSet
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
modifier|&
name|enabledTransitions
parameter_list|,
name|CalculationCache
modifier|*
name|cache
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|statesToExit_sorted
init|=
name|computeExitSet_Unordered
argument_list|(
name|enabledTransitions
argument_list|,
name|cache
argument_list|)
operator|.
name|toList
argument_list|()
decl_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|statesToExit_sorted
operator|.
name|begin
argument_list|()
argument_list|,
name|statesToExit_sorted
operator|.
name|end
argument_list|()
argument_list|,
name|stateExitLessThan
argument_list|)
expr_stmt|;
return|return
name|statesToExit_sorted
return|;
block|}
end_function
begin_function
DECL|function|computeExitSet_Unordered
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|QStateMachinePrivate
operator|::
name|computeExitSet_Unordered
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
modifier|&
name|enabledTransitions
parameter_list|,
name|CalculationCache
modifier|*
name|cache
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|statesToExit
decl_stmt|;
foreach|foreach
control|(
name|QAbstractTransition
modifier|*
name|t
decl|,
name|enabledTransitions
control|)
name|statesToExit
operator|.
name|unite
argument_list|(
name|computeExitSet_Unordered
argument_list|(
name|t
argument_list|,
name|cache
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|statesToExit
return|;
block|}
end_function
begin_function
DECL|function|computeExitSet_Unordered
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|QStateMachinePrivate
operator|::
name|computeExitSet_Unordered
parameter_list|(
name|QAbstractTransition
modifier|*
name|t
parameter_list|,
name|CalculationCache
modifier|*
name|cache
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|statesToExit
decl_stmt|;
if|if
condition|(
name|cache
operator|->
name|exitSet
argument_list|(
name|t
argument_list|,
operator|&
name|statesToExit
argument_list|)
condition|)
return|return
name|statesToExit
return|;
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|effectiveTargetStates
init|=
name|getEffectiveTargetStates
argument_list|(
name|t
argument_list|,
name|cache
argument_list|)
decl_stmt|;
name|QAbstractState
modifier|*
name|domain
init|=
name|getTransitionDomain
argument_list|(
name|t
argument_list|,
name|effectiveTargetStates
argument_list|,
name|cache
argument_list|)
decl_stmt|;
if|if
condition|(
name|domain
operator|==
name|Q_NULLPTR
operator|&&
operator|!
name|t
operator|->
name|targetStates
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// So we didn't find the least common ancestor for the source and target states of the
comment|// transition. If there were not target states, that would be fine: then the transition
comment|// will fire any events or signals, but not exit the state.
comment|//
comment|// However, there are target states, so it's either a node without a parent (or parent's
comment|// parent, etc), or the state belongs to a different state machine. Either way, this
comment|// makes the state machine invalid.
if|if
condition|(
name|error
operator|==
name|QStateMachine
operator|::
name|NoError
condition|)
name|setError
argument_list|(
name|QStateMachine
operator|::
name|NoCommonAncestorForTransitionError
argument_list|,
name|t
operator|->
name|sourceState
argument_list|()
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|lst
init|=
name|pendingErrorStates
operator|.
name|toList
argument_list|()
decl_stmt|;
name|lst
operator|.
name|prepend
argument_list|(
name|t
operator|->
name|sourceState
argument_list|()
argument_list|)
expr_stmt|;
name|domain
operator|=
name|findLCCA
argument_list|(
name|lst
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|domain
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|s
decl|,
name|configuration
control|)
block|{
if|if
condition|(
name|isDescendant
argument_list|(
name|s
argument_list|,
name|domain
argument_list|)
condition|)
name|statesToExit
operator|.
name|insert
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|cache
operator|->
name|insert
argument_list|(
name|t
argument_list|,
name|statesToExit
argument_list|)
expr_stmt|;
return|return
name|statesToExit
return|;
block|}
end_function
begin_function
DECL|function|exitStates
name|void
name|QStateMachinePrivate
operator|::
name|exitStates
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|statesToExit_sorted
parameter_list|,
specifier|const
name|QHash
argument_list|<
name|QAbstractState
modifier|*
argument_list|,
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
argument_list|>
modifier|&
name|assignmentsForEnteredStates
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|statesToExit_sorted
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractState
modifier|*
name|s
init|=
name|statesToExit_sorted
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|QState
modifier|*
name|grp
init|=
name|toStandardState
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|QList
argument_list|<
name|QHistoryState
modifier|*
argument_list|>
name|hlst
init|=
name|QStatePrivate
operator|::
name|get
argument_list|(
name|grp
argument_list|)
operator|->
name|historyStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|hlst
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|QHistoryState
modifier|*
name|h
init|=
name|hlst
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|QHistoryStatePrivate
operator|::
name|get
argument_list|(
name|h
argument_list|)
operator|->
name|configuration
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|configuration
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|configuration
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QAbstractState
modifier|*
name|s0
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|QHistoryStatePrivate
operator|::
name|get
argument_list|(
name|h
argument_list|)
operator|->
name|historyType
operator|==
name|QHistoryState
operator|::
name|DeepHistory
condition|)
block|{
if|if
condition|(
name|isAtomic
argument_list|(
name|s0
argument_list|)
operator|&&
name|isDescendant
argument_list|(
name|s0
argument_list|,
name|s
argument_list|)
condition|)
name|QHistoryStatePrivate
operator|::
name|get
argument_list|(
name|h
argument_list|)
operator|->
name|configuration
operator|.
name|append
argument_list|(
name|s0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s0
operator|->
name|parentState
argument_list|()
operator|==
name|s
condition|)
block|{
name|QHistoryStatePrivate
operator|::
name|get
argument_list|(
name|h
argument_list|)
operator|->
name|configuration
operator|.
name|append
argument_list|(
name|s0
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": recorded"
operator|<<
operator|(
operator|(
name|QHistoryStatePrivate
operator|::
name|get
argument_list|(
name|h
argument_list|)
operator|->
name|historyType
operator|==
name|QHistoryState
operator|::
name|DeepHistory
operator|)
condition|?
literal|"deep"
else|:
literal|"shallow"
operator|)
operator|<<
literal|"history for"
operator|<<
name|s
operator|<<
literal|"in"
operator|<<
name|h
operator|<<
literal|':'
operator|<<
name|QHistoryStatePrivate
operator|::
name|get
argument_list|(
name|h
argument_list|)
operator|->
name|configuration
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|statesToExit_sorted
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractState
modifier|*
name|s
init|=
name|statesToExit_sorted
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": exiting"
operator|<<
name|s
expr_stmt|;
endif|#
directive|endif
name|QAbstractStatePrivate
operator|::
name|get
argument_list|(
name|s
argument_list|)
operator|->
name|callOnExit
argument_list|(
name|event
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
name|terminateActiveAnimations
argument_list|(
name|s
argument_list|,
name|assignmentsForEnteredStates
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|assignmentsForEnteredStates
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|configuration
operator|.
name|remove
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|QAbstractStatePrivate
operator|::
name|get
argument_list|(
name|s
argument_list|)
operator|->
name|emitExited
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|executeTransitionContent
name|void
name|QStateMachinePrivate
operator|::
name|executeTransitionContent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
modifier|&
name|enabledTransitions
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|enabledTransitions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractTransition
modifier|*
name|t
init|=
name|enabledTransitions
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": triggering"
operator|<<
name|t
expr_stmt|;
endif|#
directive|endif
name|QAbstractTransitionPrivate
operator|::
name|get
argument_list|(
name|t
argument_list|)
operator|->
name|callOnTransition
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|QAbstractTransitionPrivate
operator|::
name|get
argument_list|(
name|t
argument_list|)
operator|->
name|emitTriggered
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|computeEntrySet
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|QStateMachinePrivate
operator|::
name|computeEntrySet
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
modifier|&
name|enabledTransitions
parameter_list|,
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|statesForDefaultEntry
parameter_list|,
name|CalculationCache
modifier|*
name|cache
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|statesToEnter
decl_stmt|;
if|if
condition|(
name|pendingErrorStates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
name|QAbstractTransition
modifier|*
name|t
decl|,
name|enabledTransitions
control|)
block|{
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|s
decl|,
name|t
operator|->
name|targetStates
argument_list|()
control|)
block|{
name|addDescendantStatesToEnter
argument_list|(
name|s
argument_list|,
name|statesToEnter
argument_list|,
name|statesForDefaultEntry
argument_list|)
expr_stmt|;
block|}
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|effectiveTargetStates
init|=
name|getEffectiveTargetStates
argument_list|(
name|t
argument_list|,
name|cache
argument_list|)
decl_stmt|;
name|QAbstractState
modifier|*
name|ancestor
init|=
name|getTransitionDomain
argument_list|(
name|t
argument_list|,
name|effectiveTargetStates
argument_list|,
name|cache
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|s
decl|,
name|effectiveTargetStates
control|)
block|{
name|addAncestorStatesToEnter
argument_list|(
name|s
argument_list|,
name|ancestor
argument_list|,
name|statesToEnter
argument_list|,
name|statesForDefaultEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Did an error occur while selecting transitions? Then we enter the error state.
if|if
condition|(
operator|!
name|pendingErrorStates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|statesToEnter
operator|.
name|clear
argument_list|()
expr_stmt|;
name|statesToEnter
operator|=
name|pendingErrorStates
expr_stmt|;
name|statesForDefaultEntry
operator|=
name|pendingErrorStatesForDefaultEntry
expr_stmt|;
name|pendingErrorStates
operator|.
name|clear
argument_list|()
expr_stmt|;
name|pendingErrorStatesForDefaultEntry
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|statesToEnter_sorted
init|=
name|statesToEnter
operator|.
name|toList
argument_list|()
decl_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|statesToEnter_sorted
operator|.
name|begin
argument_list|()
argument_list|,
name|statesToEnter_sorted
operator|.
name|end
argument_list|()
argument_list|,
name|stateEntryLessThan
argument_list|)
expr_stmt|;
return|return
name|statesToEnter_sorted
return|;
block|}
end_function
begin_comment
comment|/* The algorithm as described in http://www.w3.org/TR/2014/WD-scxml-20140529/ :  function getTransitionDomain(transition)  Return the compound state such that 1) all states that are exited or entered as a result of taking 'transition' are descendants of it 2) no descendant of it has this property.  function getTransitionDomain(t)   tstates = getEffectiveTargetStates(t)   if not tstates:       return null   elif t.type == "internal" and isCompoundState(t.source) and tstates.every(lambda s: isDescendant(s,t.source)):       return t.source   else:       return findLCCA([t.source].append(tstates)) */
end_comment
begin_function
DECL|function|getTransitionDomain
name|QAbstractState
modifier|*
name|QStateMachinePrivate
operator|::
name|getTransitionDomain
parameter_list|(
name|QAbstractTransition
modifier|*
name|t
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|effectiveTargetStates
parameter_list|,
name|CalculationCache
modifier|*
name|cache
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|effectiveTargetStates
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|QAbstractState
modifier|*
name|domain
init|=
name|Q_NULLPTR
decl_stmt|;
if|if
condition|(
name|cache
operator|->
name|transitionDomain
argument_list|(
name|t
argument_list|,
operator|&
name|domain
argument_list|)
condition|)
return|return
name|domain
return|;
if|if
condition|(
name|t
operator|->
name|transitionType
argument_list|()
operator|==
name|QAbstractTransition
operator|::
name|InternalTransition
condition|)
block|{
if|if
condition|(
name|QState
modifier|*
name|tSource
init|=
name|t
operator|->
name|sourceState
argument_list|()
condition|)
block|{
if|if
condition|(
name|isCompound
argument_list|(
name|tSource
argument_list|)
condition|)
block|{
name|bool
name|allDescendants
init|=
literal|true
decl_stmt|;
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|s
decl|,
name|effectiveTargetStates
control|)
block|{
if|if
condition|(
operator|!
name|isDescendant
argument_list|(
name|s
argument_list|,
name|tSource
argument_list|)
condition|)
block|{
name|allDescendants
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|allDescendants
condition|)
return|return
name|tSource
return|;
block|}
block|}
block|}
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|states
argument_list|(
name|effectiveTargetStates
argument_list|)
decl_stmt|;
if|if
condition|(
name|QAbstractState
modifier|*
name|src
init|=
name|t
operator|->
name|sourceState
argument_list|()
condition|)
name|states
operator|.
name|prepend
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|domain
operator|=
name|findLCCA
argument_list|(
name|states
argument_list|)
expr_stmt|;
name|cache
operator|->
name|insert
argument_list|(
name|t
argument_list|,
name|domain
argument_list|)
expr_stmt|;
return|return
name|domain
return|;
block|}
end_function
begin_function
DECL|function|enterStates
name|void
name|QStateMachinePrivate
operator|::
name|enterStates
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|exitedStates_sorted
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|statesToEnter_sorted
parameter_list|,
specifier|const
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|statesForDefaultEntry
parameter_list|,
name|QHash
argument_list|<
name|QAbstractState
modifier|*
argument_list|,
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
argument_list|>
modifier|&
name|propertyAssignmentsForState
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
modifier|&
name|selectedAnimations
endif|#
directive|endif
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|statesToEnter_sorted
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractState
modifier|*
name|s
init|=
name|statesToEnter_sorted
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": entering"
operator|<<
name|s
expr_stmt|;
endif|#
directive|endif
name|configuration
operator|.
name|insert
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|registerTransitions
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
name|initializeAnimations
argument_list|(
name|s
argument_list|,
name|selectedAnimations
argument_list|,
name|exitedStates_sorted
argument_list|,
name|propertyAssignmentsForState
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Immediately set the properties that are not animated.
block|{
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
name|assignments
init|=
name|propertyAssignmentsForState
operator|.
name|value
argument_list|(
name|s
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|assignments
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPropertyAssignment
modifier|&
name|assn
init|=
name|assignments
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|globalRestorePolicy
operator|==
name|QState
operator|::
name|RestoreProperties
condition|)
block|{
if|if
condition|(
name|assn
operator|.
name|explicitlySet
condition|)
block|{
if|if
condition|(
operator|!
name|hasRestorable
argument_list|(
name|s
argument_list|,
name|assn
operator|.
name|object
argument_list|,
name|assn
operator|.
name|propertyName
argument_list|)
condition|)
block|{
name|QVariant
name|value
init|=
name|savedValueForRestorable
argument_list|(
name|exitedStates_sorted
argument_list|,
name|assn
operator|.
name|object
argument_list|,
name|assn
operator|.
name|propertyName
argument_list|)
decl_stmt|;
name|unregisterRestorables
argument_list|(
name|exitedStates_sorted
argument_list|,
name|assn
operator|.
name|object
argument_list|,
name|assn
operator|.
name|propertyName
argument_list|)
expr_stmt|;
name|registerRestorable
argument_list|(
name|s
argument_list|,
name|assn
operator|.
name|object
argument_list|,
name|assn
operator|.
name|propertyName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// The property is being restored, hence no need to
comment|// save the current value. Discard any saved values in
comment|// exited states, since those are now stale.
name|unregisterRestorables
argument_list|(
name|exitedStates_sorted
argument_list|,
name|assn
operator|.
name|object
argument_list|,
name|assn
operator|.
name|propertyName
argument_list|)
expr_stmt|;
block|}
block|}
name|assn
operator|.
name|write
argument_list|()
expr_stmt|;
block|}
block|}
name|QAbstractStatePrivate
operator|::
name|get
argument_list|(
name|s
argument_list|)
operator|->
name|callOnEntry
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|QAbstractStatePrivate
operator|::
name|get
argument_list|(
name|s
argument_list|)
operator|->
name|emitEntered
argument_list|()
expr_stmt|;
comment|// FIXME:
comment|// See the "initial transitions" comment in addDescendantStatesToEnter first, then implement:
comment|//        if (statesForDefaultEntry.contains(s)) {
comment|//            // ### executeContent(s.initial.transition.children())
comment|//        }
name|Q_UNUSED
argument_list|(
name|statesForDefaultEntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|QHistoryState
modifier|*
name|h
init|=
name|toHistoryState
argument_list|(
name|s
argument_list|)
condition|)
name|QAbstractTransitionPrivate
operator|::
name|get
argument_list|(
name|h
operator|->
name|defaultTransition
argument_list|()
argument_list|)
operator|->
name|callOnTransition
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|// Emit propertiesAssigned signal if the state has no animated properties.
block|{
name|QState
modifier|*
name|ss
init|=
name|toStandardState
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|ss
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
operator|&&
operator|!
name|animationsForState
operator|.
name|contains
argument_list|(
name|s
argument_list|)
endif|#
directive|endif
condition|)
name|QStatePrivate
operator|::
name|get
argument_list|(
name|ss
argument_list|)
operator|->
name|emitPropertiesAssigned
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isFinal
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|QState
modifier|*
name|parent
init|=
name|s
operator|->
name|parentState
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
if|if
condition|(
name|parent
operator|!=
name|rootState
argument_list|()
condition|)
block|{
name|QFinalState
modifier|*
name|finalState
init|=
name|qobject_cast
argument_list|<
name|QFinalState
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|finalState
argument_list|)
expr_stmt|;
name|emitStateFinished
argument_list|(
name|parent
argument_list|,
name|finalState
argument_list|)
expr_stmt|;
block|}
name|QState
modifier|*
name|grandparent
init|=
name|parent
operator|->
name|parentState
argument_list|()
decl_stmt|;
if|if
condition|(
name|grandparent
operator|&&
name|isParallel
argument_list|(
name|grandparent
argument_list|)
condition|)
block|{
name|bool
name|allChildStatesFinal
init|=
literal|true
decl_stmt|;
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|childStates
init|=
name|QStatePrivate
operator|::
name|get
argument_list|(
name|grandparent
argument_list|)
operator|->
name|childStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|childStates
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|QAbstractState
modifier|*
name|cs
init|=
name|childStates
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isInFinalState
argument_list|(
name|cs
argument_list|)
condition|)
block|{
name|allChildStatesFinal
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|allChildStatesFinal
operator|&&
operator|(
name|grandparent
operator|!=
name|rootState
argument_list|()
operator|)
condition|)
block|{
name|QFinalState
modifier|*
name|finalState
init|=
name|qobject_cast
argument_list|<
name|QFinalState
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|finalState
argument_list|)
expr_stmt|;
name|emitStateFinished
argument_list|(
name|grandparent
argument_list|,
name|finalState
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|{
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|configuration
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|configuration
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|isFinal
argument_list|(
operator|*
name|it
argument_list|)
condition|)
block|{
name|QState
modifier|*
name|parent
init|=
operator|(
operator|*
name|it
operator|)
operator|->
name|parentState
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|parent
operator|==
name|rootState
argument_list|()
operator|)
operator|&&
operator|(
name|rootState
argument_list|()
operator|->
name|childMode
argument_list|()
operator|==
name|QState
operator|::
name|ExclusiveStates
operator|)
operator|)
operator|||
operator|(
operator|(
name|parent
operator|->
name|parentState
argument_list|()
operator|==
name|rootState
argument_list|()
operator|)
operator|&&
operator|(
name|rootState
argument_list|()
operator|->
name|childMode
argument_list|()
operator|==
name|QState
operator|::
name|ParallelStates
operator|)
operator|&&
name|isInFinalState
argument_list|(
name|rootState
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|processing
operator|=
literal|false
expr_stmt|;
name|stopProcessingReason
operator|=
name|Finished
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|//    qDebug()<< "configuration:"<< configuration.toList();
block|}
end_function
begin_comment
comment|/* The algorithm as described in http://www.w3.org/TR/2014/WD-scxml-20140529/ has a bug. See  * QTBUG-44963 for details. The algorithm here is as described in  * http://www.w3.org/Voice/2013/scxml-irp/SCXML.htm as of Friday March 13, 2015.  procedure addDescendantStatesToEnter(state,statesToEnter,statesForDefaultEntry, defaultHistoryContent):     if isHistoryState(state):         if historyValue[state.id]:             for s in historyValue[state.id]:                 addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent)             for s in historyValue[state.id]:                 addAncestorStatesToEnter(s, state.parent, statesToEnter, statesForDefaultEntry, defaultHistoryContent)         else:             defaultHistoryContent[state.parent.id] = state.transition.content             for s in state.transition.target:                 addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent)             for s in state.transition.target:                 addAncestorStatesToEnter(s, state.parent, statesToEnter, statesForDefaultEntry, defaultHistoryContent)     else:         statesToEnter.add(state)         if isCompoundState(state):             statesForDefaultEntry.add(state)             for s in state.initial.transition.target:                 addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent)             for s in state.initial.transition.target:                 addAncestorStatesToEnter(s, state, statesToEnter, statesForDefaultEntry, defaultHistoryContent)         else:             if isParallelState(state):                 for child in getChildStates(state):                     if not statesToEnter.some(lambda s: isDescendant(s,child)):                         addDescendantStatesToEnter(child,statesToEnter,statesForDefaultEntry, defaultHistoryContent) */
end_comment
begin_function
DECL|function|addDescendantStatesToEnter
name|void
name|QStateMachinePrivate
operator|::
name|addDescendantStatesToEnter
parameter_list|(
name|QAbstractState
modifier|*
name|state
parameter_list|,
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|statesToEnter
parameter_list|,
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|statesForDefaultEntry
parameter_list|)
block|{
if|if
condition|(
name|QHistoryState
modifier|*
name|h
init|=
name|toHistoryState
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|historyConfiguration
init|=
name|QHistoryStatePrivate
operator|::
name|get
argument_list|(
name|h
argument_list|)
operator|->
name|configuration
decl_stmt|;
if|if
condition|(
operator|!
name|historyConfiguration
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|s
decl|,
name|historyConfiguration
control|)
name|addDescendantStatesToEnter
argument_list|(
name|s
argument_list|,
name|statesToEnter
argument_list|,
name|statesForDefaultEntry
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|s
decl|,
name|historyConfiguration
control|)
name|addAncestorStatesToEnter
argument_list|(
name|s
argument_list|,
name|state
operator|->
name|parentState
argument_list|()
argument_list|,
name|statesToEnter
argument_list|,
name|statesForDefaultEntry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": restoring"
operator|<<
operator|(
operator|(
name|QHistoryStatePrivate
operator|::
name|get
argument_list|(
name|h
argument_list|)
operator|->
name|historyType
operator|==
name|QHistoryState
operator|::
name|DeepHistory
operator|)
condition|?
literal|"deep"
else|:
literal|"shallow"
operator|)
operator|<<
literal|"history from"
operator|<<
name|state
operator|<<
literal|':'
operator|<<
name|historyConfiguration
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|defaultHistoryContent
decl_stmt|;
if|if
condition|(
name|QAbstractTransition
modifier|*
name|t
init|=
name|QHistoryStatePrivate
operator|::
name|get
argument_list|(
name|h
argument_list|)
operator|->
name|defaultTransition
condition|)
name|defaultHistoryContent
operator|=
name|t
operator|->
name|targetStates
argument_list|()
expr_stmt|;
if|if
condition|(
name|defaultHistoryContent
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|setError
argument_list|(
name|QStateMachine
operator|::
name|NoDefaultStateInHistoryStateError
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|s
decl|,
name|defaultHistoryContent
control|)
name|addDescendantStatesToEnter
argument_list|(
name|s
argument_list|,
name|statesToEnter
argument_list|,
name|statesForDefaultEntry
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|s
decl|,
name|defaultHistoryContent
control|)
name|addAncestorStatesToEnter
argument_list|(
name|s
argument_list|,
name|state
operator|->
name|parentState
argument_list|()
argument_list|,
name|statesToEnter
argument_list|,
name|statesForDefaultEntry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": initial history targets for"
operator|<<
name|state
operator|<<
literal|':'
operator|<<
name|defaultHistoryContent
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|state
operator|==
name|rootState
argument_list|()
condition|)
block|{
comment|// Error has already been set by exitStates().
name|Q_ASSERT
argument_list|(
name|error
operator|!=
name|QStateMachine
operator|::
name|NoError
argument_list|)
expr_stmt|;
return|return;
block|}
name|statesToEnter
operator|.
name|insert
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|isCompound
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|statesForDefaultEntry
operator|.
name|insert
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|QAbstractState
modifier|*
name|initial
init|=
name|toStandardState
argument_list|(
name|state
argument_list|)
operator|->
name|initialState
argument_list|()
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|initial
operator|->
name|machine
argument_list|()
operator|==
name|q_func
argument_list|()
argument_list|)
expr_stmt|;
comment|// FIXME:
comment|// Qt does not support initial transitions (which is a problem for parallel states).
comment|// The way it simulates this for other states, is by having a single initial state.
comment|// See also the FIXME in enterStates.
name|statesForDefaultEntry
operator|.
name|insert
argument_list|(
name|initial
argument_list|)
expr_stmt|;
name|addDescendantStatesToEnter
argument_list|(
name|initial
argument_list|,
name|statesToEnter
argument_list|,
name|statesForDefaultEntry
argument_list|)
expr_stmt|;
name|addAncestorStatesToEnter
argument_list|(
name|initial
argument_list|,
name|state
argument_list|,
name|statesToEnter
argument_list|,
name|statesForDefaultEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setError
argument_list|(
name|QStateMachine
operator|::
name|NoInitialStateError
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|isParallel
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|QState
modifier|*
name|grp
init|=
name|toStandardState
argument_list|(
name|state
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|child
decl|,
name|QStatePrivate
operator|::
name|get
argument_list|(
name|grp
argument_list|)
operator|->
name|childStates
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|containsDecendantOf
argument_list|(
name|statesToEnter
argument_list|,
name|child
argument_list|)
condition|)
name|addDescendantStatesToEnter
argument_list|(
name|child
argument_list|,
name|statesToEnter
argument_list|,
name|statesForDefaultEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/* The algorithm as described in http://www.w3.org/TR/2014/WD-scxml-20140529/ :  procedure addAncestorStatesToEnter(state, ancestor, statesToEnter, statesForDefaultEntry, defaultHistoryContent)    for anc in getProperAncestors(state,ancestor):        statesToEnter.add(anc)        if isParallelState(anc):            for child in getChildStates(anc):                if not statesToEnter.some(lambda s: isDescendant(s,child)):                   addDescendantStatesToEnter(child,statesToEnter,statesForDefaultEntry, defaultHistoryContent) */
end_comment
begin_function
DECL|function|addAncestorStatesToEnter
name|void
name|QStateMachinePrivate
operator|::
name|addAncestorStatesToEnter
parameter_list|(
name|QAbstractState
modifier|*
name|s
parameter_list|,
name|QAbstractState
modifier|*
name|ancestor
parameter_list|,
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|statesToEnter
parameter_list|,
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|statesForDefaultEntry
parameter_list|)
block|{
foreach|foreach
control|(
name|QState
modifier|*
name|anc
decl|,
name|getProperAncestors
argument_list|(
name|s
argument_list|,
name|ancestor
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|anc
operator|->
name|parentState
argument_list|()
condition|)
continue|continue;
name|statesToEnter
operator|.
name|insert
argument_list|(
name|anc
argument_list|)
expr_stmt|;
if|if
condition|(
name|isParallel
argument_list|(
name|anc
argument_list|)
condition|)
block|{
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|child
decl|,
name|QStatePrivate
operator|::
name|get
argument_list|(
name|anc
argument_list|)
operator|->
name|childStates
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|containsDecendantOf
argument_list|(
name|statesToEnter
argument_list|,
name|child
argument_list|)
condition|)
name|addDescendantStatesToEnter
argument_list|(
name|child
argument_list|,
name|statesToEnter
argument_list|,
name|statesForDefaultEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|isFinal
name|bool
name|QStateMachinePrivate
operator|::
name|isFinal
parameter_list|(
specifier|const
name|QAbstractState
modifier|*
name|s
parameter_list|)
block|{
return|return
name|s
operator|&&
operator|(
name|QAbstractStatePrivate
operator|::
name|get
argument_list|(
name|s
argument_list|)
operator|->
name|stateType
operator|==
name|QAbstractStatePrivate
operator|::
name|FinalState
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isParallel
name|bool
name|QStateMachinePrivate
operator|::
name|isParallel
parameter_list|(
specifier|const
name|QAbstractState
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|QState
modifier|*
name|ss
init|=
name|toStandardState
argument_list|(
name|s
argument_list|)
decl_stmt|;
return|return
name|ss
operator|&&
operator|(
name|QStatePrivate
operator|::
name|get
argument_list|(
name|ss
argument_list|)
operator|->
name|childMode
operator|==
name|QState
operator|::
name|ParallelStates
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isCompound
name|bool
name|QStateMachinePrivate
operator|::
name|isCompound
parameter_list|(
specifier|const
name|QAbstractState
modifier|*
name|s
parameter_list|)
specifier|const
block|{
specifier|const
name|QState
modifier|*
name|group
init|=
name|toStandardState
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|group
condition|)
return|return
literal|false
return|;
name|bool
name|isMachine
init|=
name|QStatePrivate
operator|::
name|get
argument_list|(
name|group
argument_list|)
operator|->
name|isMachine
decl_stmt|;
comment|// Don't treat the machine as compound if it's a sub-state of this machine
if|if
condition|(
name|isMachine
operator|&&
operator|(
name|group
operator|!=
name|rootState
argument_list|()
operator|)
condition|)
return|return
literal|false
return|;
return|return
operator|(
operator|!
name|isParallel
argument_list|(
name|group
argument_list|)
operator|&&
operator|!
name|QStatePrivate
operator|::
name|get
argument_list|(
name|group
argument_list|)
operator|->
name|childStates
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isAtomic
name|bool
name|QStateMachinePrivate
operator|::
name|isAtomic
parameter_list|(
specifier|const
name|QAbstractState
modifier|*
name|s
parameter_list|)
specifier|const
block|{
specifier|const
name|QState
modifier|*
name|ss
init|=
name|toStandardState
argument_list|(
name|s
argument_list|)
decl_stmt|;
return|return
operator|(
name|ss
operator|&&
name|QStatePrivate
operator|::
name|get
argument_list|(
name|ss
argument_list|)
operator|->
name|childStates
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
name|isFinal
argument_list|(
name|s
argument_list|)
comment|// Treat the machine as atomic if it's a sub-state of this machine
operator|||
operator|(
name|ss
operator|&&
name|QStatePrivate
operator|::
name|get
argument_list|(
name|ss
argument_list|)
operator|->
name|isMachine
operator|&&
operator|(
name|ss
operator|!=
name|rootState
argument_list|()
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|toStandardState
name|QState
modifier|*
name|QStateMachinePrivate
operator|::
name|toStandardState
parameter_list|(
name|QAbstractState
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|&&
operator|(
name|QAbstractStatePrivate
operator|::
name|get
argument_list|(
name|state
argument_list|)
operator|->
name|stateType
operator|==
name|QAbstractStatePrivate
operator|::
name|StandardState
operator|)
condition|)
return|return
cast|static_cast
argument_list|<
name|QState
operator|*
argument_list|>
argument_list|(
name|state
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|toStandardState
specifier|const
name|QState
modifier|*
name|QStateMachinePrivate
operator|::
name|toStandardState
parameter_list|(
specifier|const
name|QAbstractState
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|&&
operator|(
name|QAbstractStatePrivate
operator|::
name|get
argument_list|(
name|state
argument_list|)
operator|->
name|stateType
operator|==
name|QAbstractStatePrivate
operator|::
name|StandardState
operator|)
condition|)
return|return
cast|static_cast
argument_list|<
specifier|const
name|QState
operator|*
argument_list|>
argument_list|(
name|state
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|toFinalState
name|QFinalState
modifier|*
name|QStateMachinePrivate
operator|::
name|toFinalState
parameter_list|(
name|QAbstractState
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|&&
operator|(
name|QAbstractStatePrivate
operator|::
name|get
argument_list|(
name|state
argument_list|)
operator|->
name|stateType
operator|==
name|QAbstractStatePrivate
operator|::
name|FinalState
operator|)
condition|)
return|return
cast|static_cast
argument_list|<
name|QFinalState
operator|*
argument_list|>
argument_list|(
name|state
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|toHistoryState
name|QHistoryState
modifier|*
name|QStateMachinePrivate
operator|::
name|toHistoryState
parameter_list|(
name|QAbstractState
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|&&
operator|(
name|QAbstractStatePrivate
operator|::
name|get
argument_list|(
name|state
argument_list|)
operator|->
name|stateType
operator|==
name|QAbstractStatePrivate
operator|::
name|HistoryState
operator|)
condition|)
return|return
cast|static_cast
argument_list|<
name|QHistoryState
operator|*
argument_list|>
argument_list|(
name|state
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|isInFinalState
name|bool
name|QStateMachinePrivate
operator|::
name|isInFinalState
parameter_list|(
name|QAbstractState
modifier|*
name|s
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isCompound
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|QState
modifier|*
name|grp
init|=
name|toStandardState
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|lst
init|=
name|QStatePrivate
operator|::
name|get
argument_list|(
name|grp
argument_list|)
operator|->
name|childStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lst
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractState
modifier|*
name|cs
init|=
name|lst
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|isFinal
argument_list|(
name|cs
argument_list|)
operator|&&
name|configuration
operator|.
name|contains
argument_list|(
name|cs
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|isParallel
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|QState
modifier|*
name|grp
init|=
name|toStandardState
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|lst
init|=
name|QStatePrivate
operator|::
name|get
argument_list|(
name|grp
argument_list|)
operator|->
name|childStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lst
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractState
modifier|*
name|cs
init|=
name|lst
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isInFinalState
argument_list|(
name|cs
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
else|else
return|return
literal|false
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PROPERTIES
end_ifndef
begin_comment
comment|/*!   \internal   Returns \c true if the given state has saved the value of the given property,   otherwise returns \c false. */
end_comment
begin_function
DECL|function|hasRestorable
name|bool
name|QStateMachinePrivate
operator|::
name|hasRestorable
parameter_list|(
name|QAbstractState
modifier|*
name|state
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|propertyName
parameter_list|)
specifier|const
block|{
name|RestorableId
name|id
argument_list|(
name|object
argument_list|,
name|propertyName
argument_list|)
decl_stmt|;
return|return
name|registeredRestorablesForState
operator|.
name|value
argument_list|(
name|state
argument_list|)
operator|.
name|contains
argument_list|(
name|id
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Returns the value to save for the property identified by \a id.   If an exited state (member of \a exitedStates_sorted) has saved a value for   the property, the saved value from the last (outermost) state that will be   exited is returned (in practice carrying the saved value on to the next   state). Otherwise, the current value of the property is returned. */
end_comment
begin_function
DECL|function|savedValueForRestorable
name|QVariant
name|QStateMachinePrivate
operator|::
name|savedValueForRestorable
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|exitedStates_sorted
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|propertyName
parameter_list|)
specifier|const
block|{
ifdef|#
directive|ifdef
name|QSTATEMACHINE_RESTORE_PROPERTIES_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": savedValueForRestorable("
operator|<<
name|exitedStates_sorted
operator|<<
name|object
operator|<<
name|propertyName
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
name|exitedStates_sorted
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QAbstractState
modifier|*
name|s
init|=
name|exitedStates_sorted
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QHash
argument_list|<
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
name|restorables
init|=
name|registeredRestorablesForState
operator|.
name|value
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|QHash
argument_list|<
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|restorables
operator|.
name|constFind
argument_list|(
name|RestorableId
argument_list|(
name|object
argument_list|,
name|propertyName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|restorables
operator|.
name|constEnd
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|QSTATEMACHINE_RESTORE_PROPERTIES_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|":   using"
operator|<<
name|it
operator|.
name|value
argument_list|()
operator|<<
literal|"from"
operator|<<
name|s
expr_stmt|;
endif|#
directive|endif
return|return
name|it
operator|.
name|value
argument_list|()
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|QSTATEMACHINE_RESTORE_PROPERTIES_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|":   falling back to current value"
expr_stmt|;
endif|#
directive|endif
return|return
name|object
operator|->
name|property
argument_list|(
name|propertyName
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|registerRestorable
name|void
name|QStateMachinePrivate
operator|::
name|registerRestorable
parameter_list|(
name|QAbstractState
modifier|*
name|state
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|propertyName
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QSTATEMACHINE_RESTORE_PROPERTIES_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": registerRestorable("
operator|<<
name|state
operator|<<
name|object
operator|<<
name|propertyName
operator|<<
name|value
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|RestorableId
name|id
argument_list|(
name|object
argument_list|,
name|propertyName
argument_list|)
decl_stmt|;
name|QHash
argument_list|<
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
modifier|&
name|restorables
init|=
name|registeredRestorablesForState
index|[
name|state
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|restorables
operator|.
name|contains
argument_list|(
name|id
argument_list|)
condition|)
name|restorables
operator|.
name|insert
argument_list|(
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_RESTORE_PROPERTIES_DEBUG
else|else
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|":   (already registered)"
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|unregisterRestorables
name|void
name|QStateMachinePrivate
operator|::
name|unregisterRestorables
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|states
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|propertyName
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QSTATEMACHINE_RESTORE_PROPERTIES_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": unregisterRestorables("
operator|<<
name|states
operator|<<
name|object
operator|<<
name|propertyName
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|RestorableId
name|id
argument_list|(
name|object
argument_list|,
name|propertyName
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|states
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractState
modifier|*
name|s
init|=
name|states
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QHash
argument_list|<
name|QAbstractState
modifier|*
argument_list|,
name|QHash
argument_list|<
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
argument_list|>
operator|::
name|iterator
name|it
decl_stmt|;
name|it
operator|=
name|registeredRestorablesForState
operator|.
name|find
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|==
name|registeredRestorablesForState
operator|.
name|end
argument_list|()
condition|)
continue|continue;
name|QHash
argument_list|<
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
modifier|&
name|restorables
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|QHash
argument_list|<
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
operator|::
name|iterator
name|it2
decl_stmt|;
name|it2
operator|=
name|restorables
operator|.
name|find
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|it2
operator|==
name|restorables
operator|.
name|end
argument_list|()
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_RESTORE_PROPERTIES_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|":   unregistered for"
operator|<<
name|s
expr_stmt|;
endif|#
directive|endif
name|restorables
operator|.
name|erase
argument_list|(
name|it2
argument_list|)
expr_stmt|;
if|if
condition|(
name|restorables
operator|.
name|isEmpty
argument_list|()
condition|)
name|registeredRestorablesForState
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|restorablesToPropertyList
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
name|QStateMachinePrivate
operator|::
name|restorablesToPropertyList
parameter_list|(
specifier|const
name|QHash
argument_list|<
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
modifier|&
name|restorables
parameter_list|)
specifier|const
block|{
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
name|result
decl_stmt|;
name|QHash
argument_list|<
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|restorables
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|restorables
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|RestorableId
modifier|&
name|id
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|id
operator|.
name|object
argument_list|()
condition|)
block|{
comment|// Property object was deleted
continue|continue;
block|}
ifdef|#
directive|ifdef
name|QSTATEMACHINE_RESTORE_PROPERTIES_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": restoring"
operator|<<
name|id
operator|.
name|object
argument_list|()
operator|<<
name|id
operator|.
name|proertyName
argument_list|()
operator|<<
literal|"to"
operator|<<
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|result
operator|.
name|append
argument_list|(
name|QPropertyAssignment
argument_list|(
name|id
operator|.
name|object
argument_list|()
argument_list|,
name|id
operator|.
name|propertyName
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|,
comment|/*explicitlySet=*/
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Computes the set of properties whose values should be restored given that   the states \a statesToExit_sorted will be exited.    If a particular (object, propertyName) pair occurs more than once (i.e.,   because nested states are being exited), the value from the last (outermost)   exited state takes precedence.    The result of this function must be filtered according to the explicit   property assignments (QState::assignProperty()) of the entered states   before the property restoration is actually performed; i.e., if an entered   state assigns to a property that would otherwise be restored, that property   should not be restored after all, but the saved value from the exited state   should be remembered by the entered state (see registerRestorable()). */
end_comment
begin_function
DECL|function|computePendingRestorables
name|QHash
argument_list|<
name|QStateMachinePrivate
operator|::
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
name|QStateMachinePrivate
operator|::
name|computePendingRestorables
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|statesToExit_sorted
parameter_list|)
specifier|const
block|{
name|QHash
argument_list|<
name|QStateMachinePrivate
operator|::
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
name|restorables
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|statesToExit_sorted
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QAbstractState
modifier|*
name|s
init|=
name|statesToExit_sorted
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QHash
argument_list|<
name|QStateMachinePrivate
operator|::
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
name|rs
init|=
name|registeredRestorablesForState
operator|.
name|value
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|QHash
argument_list|<
name|QStateMachinePrivate
operator|::
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|rs
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|rs
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|!
name|restorables
operator|.
name|contains
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
condition|)
name|restorables
operator|.
name|insert
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|restorables
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Computes the ordered sets of property assignments for the states to be   entered, \a statesToEnter_sorted. Also filters \a pendingRestorables (removes   properties that should not be restored because they are assigned by an   entered state). */
end_comment
begin_function
DECL|function|computePropertyAssignments
name|QHash
argument_list|<
name|QAbstractState
modifier|*
argument_list|,
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
argument_list|>
name|QStateMachinePrivate
operator|::
name|computePropertyAssignments
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|statesToEnter_sorted
parameter_list|,
name|QHash
argument_list|<
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
modifier|&
name|pendingRestorables
parameter_list|)
specifier|const
block|{
name|QHash
argument_list|<
name|QAbstractState
modifier|*
argument_list|,
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
argument_list|>
name|assignmentsForState
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|statesToEnter_sorted
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QState
modifier|*
name|s
init|=
name|toStandardState
argument_list|(
name|statesToEnter_sorted
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
continue|continue;
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
modifier|&
name|assignments
init|=
name|QStatePrivate
operator|::
name|get
argument_list|(
name|s
argument_list|)
operator|->
name|propertyAssignments
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|assignments
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|QPropertyAssignment
modifier|&
name|assn
init|=
name|assignments
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|assn
operator|.
name|objectDeleted
argument_list|()
condition|)
block|{
name|assignments
operator|.
name|removeAt
argument_list|(
name|j
operator|--
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pendingRestorables
operator|.
name|remove
argument_list|(
name|RestorableId
argument_list|(
name|assn
operator|.
name|object
argument_list|,
name|assn
operator|.
name|propertyName
argument_list|)
argument_list|)
expr_stmt|;
name|assignmentsForState
index|[
name|s
index|]
operator|.
name|append
argument_list|(
name|assn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|assignmentsForState
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PROPERTIES
end_comment
begin_function
DECL|function|findErrorState
name|QAbstractState
modifier|*
name|QStateMachinePrivate
operator|::
name|findErrorState
parameter_list|(
name|QAbstractState
modifier|*
name|context
parameter_list|)
block|{
comment|// Find error state recursively in parent hierarchy if not set explicitly for context state
name|QAbstractState
modifier|*
name|errorState
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|context
operator|!=
literal|0
condition|)
block|{
name|QState
modifier|*
name|s
init|=
name|toStandardState
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
name|errorState
operator|=
name|s
operator|->
name|errorState
argument_list|()
expr_stmt|;
if|if
condition|(
name|errorState
operator|==
literal|0
condition|)
name|errorState
operator|=
name|findErrorState
argument_list|(
name|context
operator|->
name|parentState
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|errorState
return|;
block|}
end_function
begin_function
DECL|function|setError
name|void
name|QStateMachinePrivate
operator|::
name|setError
parameter_list|(
name|QStateMachine
operator|::
name|Error
name|errorCode
parameter_list|,
name|QAbstractState
modifier|*
name|currentContext
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|error
operator|=
name|errorCode
expr_stmt|;
switch|switch
condition|(
name|errorCode
condition|)
block|{
case|case
name|QStateMachine
operator|::
name|NoInitialStateError
case|:
name|Q_ASSERT
argument_list|(
name|currentContext
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|errorString
operator|=
name|QStateMachine
operator|::
name|tr
argument_list|(
literal|"Missing initial state in compound state '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|currentContext
operator|->
name|objectName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QStateMachine
operator|::
name|NoDefaultStateInHistoryStateError
case|:
name|Q_ASSERT
argument_list|(
name|currentContext
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|errorString
operator|=
name|QStateMachine
operator|::
name|tr
argument_list|(
literal|"Missing default state in history state '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|currentContext
operator|->
name|objectName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QStateMachine
operator|::
name|NoCommonAncestorForTransitionError
case|:
name|Q_ASSERT
argument_list|(
name|currentContext
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|errorString
operator|=
name|QStateMachine
operator|::
name|tr
argument_list|(
literal|"No common ancestor for targets and source of transition from state '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|currentContext
operator|->
name|objectName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errorString
operator|=
name|QStateMachine
operator|::
name|tr
argument_list|(
literal|"Unknown error"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|pendingErrorStates
operator|.
name|clear
argument_list|()
expr_stmt|;
name|pendingErrorStatesForDefaultEntry
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QAbstractState
modifier|*
name|currentErrorState
init|=
name|findErrorState
argument_list|(
name|currentContext
argument_list|)
decl_stmt|;
comment|// Avoid infinite loop if the error state itself has an error
if|if
condition|(
name|currentContext
operator|==
name|currentErrorState
condition|)
name|currentErrorState
operator|=
literal|0
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|currentErrorState
operator|!=
name|rootState
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentErrorState
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": entering error state"
operator|<<
name|currentErrorState
operator|<<
literal|"from"
operator|<<
name|currentContext
expr_stmt|;
endif|#
directive|endif
name|pendingErrorStates
operator|.
name|insert
argument_list|(
name|currentErrorState
argument_list|)
expr_stmt|;
name|addDescendantStatesToEnter
argument_list|(
name|currentErrorState
argument_list|,
name|pendingErrorStates
argument_list|,
name|pendingErrorStatesForDefaultEntry
argument_list|)
expr_stmt|;
name|addAncestorStatesToEnter
argument_list|(
name|currentErrorState
argument_list|,
name|rootState
argument_list|()
argument_list|,
name|pendingErrorStates
argument_list|,
name|pendingErrorStatesForDefaultEntry
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|s
decl|,
name|configuration
control|)
name|pendingErrorStates
operator|.
name|remove
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Unrecoverable error detected in running state machine: %s"
argument_list|,
name|qPrintable
argument_list|(
name|errorString
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
end_ifndef
begin_function
name|QPair
argument_list|<
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
argument_list|,
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
argument_list|>
DECL|function|initializeAnimation
name|QStateMachinePrivate
operator|::
name|initializeAnimation
parameter_list|(
name|QAbstractAnimation
modifier|*
name|abstractAnimation
parameter_list|,
specifier|const
name|QPropertyAssignment
modifier|&
name|prop
parameter_list|)
block|{
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
name|handledAnimations
decl_stmt|;
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
name|localResetEndValues
decl_stmt|;
name|QAnimationGroup
modifier|*
name|group
init|=
name|qobject_cast
argument_list|<
name|QAnimationGroup
operator|*
argument_list|>
argument_list|(
name|abstractAnimation
argument_list|)
decl_stmt|;
if|if
condition|(
name|group
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|group
operator|->
name|animationCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractAnimation
modifier|*
name|animationChild
init|=
name|group
operator|->
name|animationAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QPair
argument_list|<
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
argument_list|,
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
argument_list|>
name|ret
decl_stmt|;
name|ret
operator|=
name|initializeAnimation
argument_list|(
name|animationChild
argument_list|,
name|prop
argument_list|)
expr_stmt|;
name|handledAnimations
operator|<<
name|ret
operator|.
name|first
expr_stmt|;
name|localResetEndValues
operator|<<
name|ret
operator|.
name|second
expr_stmt|;
block|}
block|}
else|else
block|{
name|QPropertyAnimation
modifier|*
name|animation
init|=
name|qobject_cast
argument_list|<
name|QPropertyAnimation
operator|*
argument_list|>
argument_list|(
name|abstractAnimation
argument_list|)
decl_stmt|;
if|if
condition|(
name|animation
operator|!=
literal|0
operator|&&
name|prop
operator|.
name|object
operator|==
name|animation
operator|->
name|targetObject
argument_list|()
operator|&&
name|prop
operator|.
name|propertyName
operator|==
name|animation
operator|->
name|propertyName
argument_list|()
condition|)
block|{
comment|// Only change end value if it is undefined
if|if
condition|(
operator|!
name|animation
operator|->
name|endValue
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|animation
operator|->
name|setEndValue
argument_list|(
name|prop
operator|.
name|value
argument_list|)
expr_stmt|;
name|localResetEndValues
operator|.
name|append
argument_list|(
name|animation
argument_list|)
expr_stmt|;
block|}
name|handledAnimations
operator|.
name|append
argument_list|(
name|animation
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|qMakePair
argument_list|(
name|handledAnimations
argument_list|,
name|localResetEndValues
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|_q_animationFinished
name|void
name|QStateMachinePrivate
operator|::
name|_q_animationFinished
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|QAbstractAnimation
modifier|*
name|anim
init|=
name|qobject_cast
argument_list|<
name|QAbstractAnimation
operator|*
argument_list|>
argument_list|(
name|q
operator|->
name|sender
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|anim
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|anim
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_animationFinished
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resetAnimationEndValues
operator|.
name|contains
argument_list|(
name|anim
argument_list|)
condition|)
block|{
name|qobject_cast
argument_list|<
name|QVariantAnimation
operator|*
argument_list|>
argument_list|(
name|anim
argument_list|)
operator|->
name|setEndValue
argument_list|(
name|QVariant
argument_list|()
argument_list|)
expr_stmt|;
comment|// ### generalize
name|resetAnimationEndValues
operator|.
name|remove
argument_list|(
name|anim
argument_list|)
expr_stmt|;
block|}
name|QAbstractState
modifier|*
name|state
init|=
name|stateForAnimation
operator|.
name|take
argument_list|(
name|anim
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|state
operator|!=
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_PROPERTIES
comment|// Set the final property value.
name|QPropertyAssignment
name|assn
init|=
name|propertyForAnimation
operator|.
name|take
argument_list|(
name|anim
argument_list|)
decl_stmt|;
name|assn
operator|.
name|write
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|assn
operator|.
name|explicitlySet
condition|)
name|unregisterRestorables
argument_list|(
name|QList
argument_list|<
name|QAbstractState
operator|*
argument_list|>
argument_list|()
operator|<<
name|state
argument_list|,
name|assn
operator|.
name|object
argument_list|,
name|assn
operator|.
name|propertyName
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QHash
argument_list|<
name|QAbstractState
modifier|*
argument_list|,
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
argument_list|>
operator|::
name|iterator
name|it
decl_stmt|;
name|it
operator|=
name|animationsForState
operator|.
name|find
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|it
operator|!=
name|animationsForState
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
modifier|&
name|animations
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|animations
operator|.
name|removeOne
argument_list|(
name|anim
argument_list|)
expr_stmt|;
if|if
condition|(
name|animations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|animationsForState
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|QStatePrivate
operator|::
name|get
argument_list|(
name|toStandardState
argument_list|(
name|state
argument_list|)
argument_list|)
operator|->
name|emitPropertiesAssigned
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|selectAnimations
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
name|QStateMachinePrivate
operator|::
name|selectAnimations
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
modifier|&
name|transitionList
parameter_list|)
specifier|const
block|{
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
name|selectedAnimations
decl_stmt|;
if|if
condition|(
name|animated
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|transitionList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractTransition
modifier|*
name|transition
init|=
name|transitionList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|selectedAnimations
operator|<<
name|transition
operator|->
name|animations
argument_list|()
expr_stmt|;
name|selectedAnimations
operator|<<
name|defaultAnimationsForSource
operator|.
name|values
argument_list|(
name|transition
operator|->
name|sourceState
argument_list|()
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|targetStates
init|=
name|transition
operator|->
name|targetStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|targetStates
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
name|selectedAnimations
operator|<<
name|defaultAnimationsForTarget
operator|.
name|values
argument_list|(
name|targetStates
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|selectedAnimations
operator|<<
name|defaultAnimations
expr_stmt|;
block|}
return|return
name|selectedAnimations
return|;
block|}
end_function
begin_function
DECL|function|terminateActiveAnimations
name|void
name|QStateMachinePrivate
operator|::
name|terminateActiveAnimations
parameter_list|(
name|QAbstractState
modifier|*
name|state
parameter_list|,
specifier|const
name|QHash
argument_list|<
name|QAbstractState
modifier|*
argument_list|,
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
argument_list|>
modifier|&
name|assignmentsForEnteredStates
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
name|animations
init|=
name|animationsForState
operator|.
name|take
argument_list|(
name|state
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|animations
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractAnimation
modifier|*
name|anim
init|=
name|animations
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|anim
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_animationFinished
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|stateForAnimation
operator|.
name|remove
argument_list|(
name|anim
argument_list|)
expr_stmt|;
comment|// Stop the (top-level) animation.
comment|// ### Stopping nested animation has weird behavior.
name|QAbstractAnimation
modifier|*
name|topLevelAnim
init|=
name|anim
decl_stmt|;
while|while
condition|(
name|QAnimationGroup
modifier|*
name|group
init|=
name|topLevelAnim
operator|->
name|group
argument_list|()
condition|)
name|topLevelAnim
operator|=
name|group
expr_stmt|;
name|topLevelAnim
operator|->
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|resetAnimationEndValues
operator|.
name|contains
argument_list|(
name|anim
argument_list|)
condition|)
block|{
name|qobject_cast
argument_list|<
name|QVariantAnimation
operator|*
argument_list|>
argument_list|(
name|anim
argument_list|)
operator|->
name|setEndValue
argument_list|(
name|QVariant
argument_list|()
argument_list|)
expr_stmt|;
comment|// ### generalize
name|resetAnimationEndValues
operator|.
name|remove
argument_list|(
name|anim
argument_list|)
expr_stmt|;
block|}
name|QPropertyAssignment
name|assn
init|=
name|propertyForAnimation
operator|.
name|take
argument_list|(
name|anim
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|assn
operator|.
name|object
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// If there is no property assignment that sets this property,
comment|// set the property to its target value.
name|bool
name|found
init|=
literal|false
decl_stmt|;
name|QHash
argument_list|<
name|QAbstractState
modifier|*
argument_list|,
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|assignmentsForEnteredStates
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|assignmentsForEnteredStates
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
modifier|&
name|assignments
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|assignments
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|assignments
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|hasTarget
argument_list|(
name|assn
operator|.
name|object
argument_list|,
name|assn
operator|.
name|propertyName
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|assn
operator|.
name|write
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|assn
operator|.
name|explicitlySet
condition|)
name|unregisterRestorables
argument_list|(
name|QList
argument_list|<
name|QAbstractState
operator|*
argument_list|>
argument_list|()
operator|<<
name|state
argument_list|,
name|assn
operator|.
name|object
argument_list|,
name|assn
operator|.
name|propertyName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|initializeAnimations
name|void
name|QStateMachinePrivate
operator|::
name|initializeAnimations
parameter_list|(
name|QAbstractState
modifier|*
name|state
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
modifier|&
name|selectedAnimations
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|exitedStates_sorted
parameter_list|,
name|QHash
argument_list|<
name|QAbstractState
modifier|*
argument_list|,
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
argument_list|>
modifier|&
name|assignmentsForEnteredStates
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|assignmentsForEnteredStates
operator|.
name|contains
argument_list|(
name|state
argument_list|)
condition|)
return|return;
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
modifier|&
name|assignments
init|=
name|assignmentsForEnteredStates
index|[
name|state
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selectedAnimations
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractAnimation
modifier|*
name|anim
init|=
name|selectedAnimations
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
operator|::
name|iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|assignments
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|assignments
operator|.
name|end
argument_list|()
condition|;
control|)
block|{
name|QPair
argument_list|<
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
argument_list|,
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
argument_list|>
name|ret
decl_stmt|;
specifier|const
name|QPropertyAssignment
modifier|&
name|assn
init|=
operator|*
name|it
decl_stmt|;
name|ret
operator|=
name|initializeAnimation
argument_list|(
name|anim
argument_list|,
name|assn
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
name|handlers
init|=
name|ret
operator|.
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|handlers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|handlers
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|QAbstractAnimation
modifier|*
name|a
init|=
name|handlers
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|propertyForAnimation
operator|.
name|insert
argument_list|(
name|a
argument_list|,
name|assn
argument_list|)
expr_stmt|;
name|stateForAnimation
operator|.
name|insert
argument_list|(
name|a
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|animationsForState
index|[
name|state
index|]
operator|.
name|append
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|// ### connect to just the top-level animation?
name|QObject
operator|::
name|connect
argument_list|(
name|a
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_animationFinished
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|UniqueConnection
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|globalRestorePolicy
operator|==
name|QState
operator|::
name|RestoreProperties
operator|)
operator|&&
operator|!
name|hasRestorable
argument_list|(
name|state
argument_list|,
name|assn
operator|.
name|object
argument_list|,
name|assn
operator|.
name|propertyName
argument_list|)
condition|)
block|{
name|QVariant
name|value
init|=
name|savedValueForRestorable
argument_list|(
name|exitedStates_sorted
argument_list|,
name|assn
operator|.
name|object
argument_list|,
name|assn
operator|.
name|propertyName
argument_list|)
decl_stmt|;
name|unregisterRestorables
argument_list|(
name|exitedStates_sorted
argument_list|,
name|assn
operator|.
name|object
argument_list|,
name|assn
operator|.
name|propertyName
argument_list|)
expr_stmt|;
name|registerRestorable
argument_list|(
name|state
argument_list|,
name|assn
operator|.
name|object
argument_list|,
name|assn
operator|.
name|propertyName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|it
operator|=
name|assignments
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|it
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|ret
operator|.
name|second
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
name|resetAnimationEndValues
operator|.
name|insert
argument_list|(
name|ret
operator|.
name|second
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// We require that at least one animation is valid.
comment|// ### generalize
name|QList
argument_list|<
name|QVariantAnimation
modifier|*
argument_list|>
name|variantAnims
init|=
name|anim
operator|->
name|findChildren
argument_list|<
name|QVariantAnimation
operator|*
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|QVariantAnimation
modifier|*
name|va
init|=
name|qobject_cast
argument_list|<
name|QVariantAnimation
operator|*
argument_list|>
argument_list|(
name|anim
argument_list|)
condition|)
name|variantAnims
operator|.
name|append
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|bool
name|hasValidEndValue
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|variantAnims
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|variantAnims
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|->
name|endValue
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|hasValidEndValue
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|hasValidEndValue
condition|)
block|{
if|if
condition|(
name|anim
operator|->
name|state
argument_list|()
operator|==
name|QAbstractAnimation
operator|::
name|Running
condition|)
block|{
comment|// The animation is still running. This can happen if the
comment|// animation is a group, and one of its children just finished,
comment|// and that caused a state to emit its propertiesAssigned() signal, and
comment|// that triggered a transition in the machine.
comment|// Just stop the animation so it is correctly restarted again.
name|anim
operator|->
name|stop
argument_list|()
expr_stmt|;
block|}
name|anim
operator|->
name|start
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|assignments
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|assignmentsForEnteredStates
operator|.
name|remove
argument_list|(
name|state
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !QT_NO_ANIMATION
end_comment
begin_function
DECL|function|createInitialTransition
name|QAbstractTransition
modifier|*
name|QStateMachinePrivate
operator|::
name|createInitialTransition
parameter_list|()
specifier|const
block|{
class|class
name|InitialTransition
super|:
specifier|public
name|QAbstractTransition
block|{
public|public:
name|InitialTransition
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
modifier|&
name|targets
parameter_list|)
member_init_list|:
name|QAbstractTransition
argument_list|()
block|{
name|setTargetStates
argument_list|(
name|targets
argument_list|)
expr_stmt|;
block|}
protected|protected:
specifier|virtual
name|bool
name|eventTest
parameter_list|(
name|QEvent
modifier|*
parameter_list|)
name|Q_DECL_OVERRIDE
block|{
return|return
literal|true
return|;
block|}
specifier|virtual
name|void
name|onTransition
parameter_list|(
name|QEvent
modifier|*
parameter_list|)
name|Q_DECL_OVERRIDE
block|{}
block|}
class|;
name|QState
modifier|*
name|root
init|=
name|rootState
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|root
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|targets
decl_stmt|;
switch|switch
condition|(
name|root
operator|->
name|childMode
argument_list|()
condition|)
block|{
case|case
name|QState
operator|::
name|ExclusiveStates
case|:
name|targets
operator|.
name|append
argument_list|(
name|root
operator|->
name|initialState
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QState
operator|::
name|ParallelStates
case|:
name|targets
operator|=
name|QStatePrivate
operator|::
name|get
argument_list|(
name|root
argument_list|)
operator|->
name|childStates
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|new
name|InitialTransition
argument_list|(
name|targets
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|clearHistory
name|void
name|QStateMachinePrivate
operator|::
name|clearHistory
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QHistoryState
modifier|*
argument_list|>
name|historyStates
init|=
name|q
operator|->
name|findChildren
argument_list|<
name|QHistoryState
operator|*
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|historyStates
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QHistoryState
modifier|*
name|h
init|=
name|historyStates
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QHistoryStatePrivate
operator|::
name|get
argument_list|(
name|h
argument_list|)
operator|->
name|configuration
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \internal    Registers all signal transitions whose sender object lives in another thread.    Normally, signal transitions are lazily registered (when a state becomes   active). But if the sender is in a different thread, the transition must be   registered early to keep the state machine from "dropping" signals; e.g.,   a second (transition-bound) signal could be emitted on the sender thread   before the state machine gets to process the first signal. */
end_comment
begin_function
DECL|function|registerMultiThreadedSignalTransitions
name|void
name|QStateMachinePrivate
operator|::
name|registerMultiThreadedSignalTransitions
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QSignalTransition
modifier|*
argument_list|>
name|transitions
init|=
name|rootState
argument_list|()
operator|->
name|findChildren
argument_list|<
name|QSignalTransition
operator|*
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|transitions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSignalTransition
modifier|*
name|t
init|=
name|transitions
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|machine
argument_list|()
operator|==
name|q
operator|)
operator|&&
name|t
operator|->
name|senderObject
argument_list|()
operator|&&
operator|(
name|t
operator|->
name|senderObject
argument_list|()
operator|->
name|thread
argument_list|()
operator|!=
name|q
operator|->
name|thread
argument_list|()
operator|)
condition|)
name|registerSignalTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_start
name|void
name|QStateMachinePrivate
operator|::
name|_q_start
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|state
operator|==
name|Starting
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QAbstractState
modifier|*
name|state
decl|,
name|configuration
control|)
block|{
name|QAbstractStatePrivate
modifier|*
name|abstractStatePrivate
init|=
name|QAbstractStatePrivate
operator|::
name|get
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|abstractStatePrivate
operator|->
name|active
operator|=
literal|false
expr_stmt|;
emit|emit
name|state
operator|->
name|activeChanged
argument_list|(
literal|false
argument_list|)
emit|;
block|}
name|configuration
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qDeleteAll
argument_list|(
name|internalEventQueue
argument_list|)
expr_stmt|;
name|internalEventQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qDeleteAll
argument_list|(
name|externalEventQueue
argument_list|)
expr_stmt|;
name|externalEventQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|clearHistory
argument_list|()
expr_stmt|;
name|registerMultiThreadedSignalTransitions
argument_list|()
expr_stmt|;
name|startupHook
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": starting"
expr_stmt|;
endif|#
directive|endif
name|state
operator|=
name|Running
expr_stmt|;
name|processingScheduled
operator|=
literal|true
expr_stmt|;
comment|// we call _q_process() below
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
name|transitions
decl_stmt|;
name|CalculationCache
name|calculationCache
decl_stmt|;
name|QAbstractTransition
modifier|*
name|initialTransition
init|=
name|createInitialTransition
argument_list|()
decl_stmt|;
name|transitions
operator|.
name|append
argument_list|(
name|initialTransition
argument_list|)
expr_stmt|;
name|QEvent
name|nullEvent
argument_list|(
name|QEvent
operator|::
name|None
argument_list|)
decl_stmt|;
name|executeTransitionContent
argument_list|(
operator|&
name|nullEvent
argument_list|,
name|transitions
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|exitedStates
init|=
name|QList
argument_list|<
name|QAbstractState
operator|*
argument_list|>
argument_list|()
decl_stmt|;
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|statesForDefaultEntry
decl_stmt|;
name|QList
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|enteredStates
init|=
name|computeEntrySet
argument_list|(
name|transitions
argument_list|,
name|statesForDefaultEntry
argument_list|,
operator|&
name|calculationCache
argument_list|)
decl_stmt|;
name|QHash
argument_list|<
name|RestorableId
argument_list|,
name|QVariant
argument_list|>
name|pendingRestorables
decl_stmt|;
name|QHash
argument_list|<
name|QAbstractState
modifier|*
argument_list|,
name|QVector
argument_list|<
name|QPropertyAssignment
argument_list|>
argument_list|>
name|assignmentsForEnteredStates
init|=
name|computePropertyAssignments
argument_list|(
name|enteredStates
argument_list|,
name|pendingRestorables
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
name|selectedAnimations
init|=
name|selectAnimations
argument_list|(
name|transitions
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|// enterStates() will set stopProcessingReason to Finished if a final
comment|// state is entered.
name|stopProcessingReason
operator|=
name|EventQueueEmpty
expr_stmt|;
name|enterStates
argument_list|(
operator|&
name|nullEvent
argument_list|,
name|exitedStates
argument_list|,
name|enteredStates
argument_list|,
name|statesForDefaultEntry
argument_list|,
name|assignmentsForEnteredStates
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
argument_list|,
name|selectedAnimations
endif|#
directive|endif
argument_list|)
expr_stmt|;
operator|delete
name|initialTransition
expr_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": initial configuration:"
operator|<<
name|configuration
expr_stmt|;
endif|#
directive|endif
emit|emit
name|q
operator|->
name|started
argument_list|(
name|QStateMachine
operator|::
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|runningChanged
argument_list|(
literal|true
argument_list|)
emit|;
if|if
condition|(
name|stopProcessingReason
operator|==
name|Finished
condition|)
block|{
comment|// The state machine immediately reached a final state.
name|processingScheduled
operator|=
literal|false
expr_stmt|;
name|state
operator|=
name|NotRunning
expr_stmt|;
name|unregisterAllTransitions
argument_list|()
expr_stmt|;
name|emitFinished
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|runningChanged
argument_list|(
literal|false
argument_list|)
emit|;
name|exitInterpreter
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|_q_process
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_process
name|void
name|QStateMachinePrivate
operator|::
name|_q_process
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|state
operator|==
name|Running
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|processing
argument_list|)
expr_stmt|;
name|processing
operator|=
literal|true
expr_stmt|;
name|processingScheduled
operator|=
literal|false
expr_stmt|;
name|beginMacrostep
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": starting the event processing loop"
expr_stmt|;
endif|#
directive|endif
name|bool
name|didChange
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|processing
condition|)
block|{
if|if
condition|(
name|stop
condition|)
block|{
name|processing
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
name|enabledTransitions
decl_stmt|;
name|CalculationCache
name|calculationCache
decl_stmt|;
name|QEvent
modifier|*
name|e
init|=
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|None
argument_list|)
decl_stmt|;
name|enabledTransitions
operator|=
name|selectTransitions
argument_list|(
name|e
argument_list|,
operator|&
name|calculationCache
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabledTransitions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|delete
name|e
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|enabledTransitions
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|(
name|e
operator|=
name|dequeueInternalEvent
argument_list|()
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": dequeued internal event"
operator|<<
name|e
operator|<<
literal|"of type"
operator|<<
name|e
operator|->
name|type
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|enabledTransitions
operator|=
name|selectTransitions
argument_list|(
name|e
argument_list|,
operator|&
name|calculationCache
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabledTransitions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|delete
name|e
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
block|}
block|}
while|while
condition|(
name|enabledTransitions
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|(
name|e
operator|=
name|dequeueExternalEvent
argument_list|()
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": dequeued external event"
operator|<<
name|e
operator|<<
literal|"of type"
operator|<<
name|e
operator|->
name|type
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|enabledTransitions
operator|=
name|selectTransitions
argument_list|(
name|e
argument_list|,
operator|&
name|calculationCache
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabledTransitions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|delete
name|e
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|enabledTransitions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|processing
operator|=
literal|false
expr_stmt|;
name|stopProcessingReason
operator|=
name|EventQueueEmpty
expr_stmt|;
name|noMicrostep
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": no transitions enabled"
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|didChange
operator|=
literal|true
expr_stmt|;
name|q
operator|->
name|beginMicrostep
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|microstep
argument_list|(
name|e
argument_list|,
name|enabledTransitions
argument_list|,
operator|&
name|calculationCache
argument_list|)
expr_stmt|;
name|q
operator|->
name|endMicrostep
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
operator|delete
name|e
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": finished the event processing loop"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stop
condition|)
block|{
name|stop
operator|=
literal|false
expr_stmt|;
name|stopProcessingReason
operator|=
name|Stopped
expr_stmt|;
block|}
switch|switch
condition|(
name|stopProcessingReason
condition|)
block|{
case|case
name|EventQueueEmpty
case|:
name|processedPendingEvents
argument_list|(
name|didChange
argument_list|)
expr_stmt|;
break|break;
case|case
name|Finished
case|:
name|state
operator|=
name|NotRunning
expr_stmt|;
name|cancelAllDelayedEvents
argument_list|()
expr_stmt|;
name|unregisterAllTransitions
argument_list|()
expr_stmt|;
name|emitFinished
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|runningChanged
argument_list|(
literal|false
argument_list|)
emit|;
break|break;
case|case
name|Stopped
case|:
name|state
operator|=
name|NotRunning
expr_stmt|;
name|cancelAllDelayedEvents
argument_list|()
expr_stmt|;
name|unregisterAllTransitions
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|stopped
argument_list|(
name|QStateMachine
operator|::
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|runningChanged
argument_list|(
literal|false
argument_list|)
emit|;
break|break;
block|}
name|endMacrostep
argument_list|(
name|didChange
argument_list|)
expr_stmt|;
if|if
condition|(
name|stopProcessingReason
operator|==
name|Finished
condition|)
name|exitInterpreter
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_startDelayedEventTimer
name|void
name|QStateMachinePrivate
operator|::
name|_q_startDelayedEventTimer
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|delayedEventsMutex
argument_list|)
decl_stmt|;
name|QHash
argument_list|<
name|int
argument_list|,
name|DelayedEvent
argument_list|>
operator|::
name|iterator
name|it
init|=
name|delayedEvents
operator|.
name|find
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|delayedEvents
operator|.
name|end
argument_list|()
condition|)
block|{
name|DelayedEvent
modifier|&
name|e
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|e
operator|.
name|timerId
argument_list|)
expr_stmt|;
name|e
operator|.
name|timerId
operator|=
name|q
operator|->
name|startTimer
argument_list|(
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|.
name|timerId
condition|)
block|{
name|qWarning
argument_list|(
literal|"QStateMachine::postDelayedEvent: failed to start timer (id=%d, delay=%d)"
argument_list|,
name|id
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|delayedEvents
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|delayedEventIdFreeList
operator|.
name|release
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|timerIdToDelayedEventId
operator|.
name|insert
argument_list|(
name|e
operator|.
name|timerId
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// It's been cancelled already
name|delayedEventIdFreeList
operator|.
name|release
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_killDelayedEventTimer
name|void
name|QStateMachinePrivate
operator|::
name|_q_killDelayedEventTimer
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|timerId
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|q
operator|->
name|killTimer
argument_list|(
name|timerId
argument_list|)
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|delayedEventsMutex
argument_list|)
decl_stmt|;
name|delayedEventIdFreeList
operator|.
name|release
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|postInternalEvent
name|void
name|QStateMachinePrivate
operator|::
name|postInternalEvent
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|internalEventMutex
argument_list|)
decl_stmt|;
name|internalEventQueue
operator|.
name|append
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|postExternalEvent
name|void
name|QStateMachinePrivate
operator|::
name|postExternalEvent
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|externalEventMutex
argument_list|)
decl_stmt|;
name|externalEventQueue
operator|.
name|append
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dequeueInternalEvent
name|QEvent
modifier|*
name|QStateMachinePrivate
operator|::
name|dequeueInternalEvent
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|internalEventMutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|internalEventQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|internalEventQueue
operator|.
name|takeFirst
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|dequeueExternalEvent
name|QEvent
modifier|*
name|QStateMachinePrivate
operator|::
name|dequeueExternalEvent
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|externalEventMutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|externalEventQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|externalEventQueue
operator|.
name|takeFirst
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|isInternalEventQueueEmpty
name|bool
name|QStateMachinePrivate
operator|::
name|isInternalEventQueueEmpty
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|internalEventMutex
argument_list|)
decl_stmt|;
return|return
name|internalEventQueue
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|isExternalEventQueueEmpty
name|bool
name|QStateMachinePrivate
operator|::
name|isExternalEventQueueEmpty
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|externalEventMutex
argument_list|)
decl_stmt|;
return|return
name|externalEventQueue
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|processEvents
name|void
name|QStateMachinePrivate
operator|::
name|processEvents
parameter_list|(
name|EventProcessingMode
name|processingMode
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|!=
name|Running
operator|)
operator|||
name|processing
operator|||
name|processingScheduled
condition|)
return|return;
switch|switch
condition|(
name|processingMode
condition|)
block|{
case|case
name|DirectProcessing
case|:
if|if
condition|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|q
operator|->
name|thread
argument_list|()
condition|)
block|{
name|_q_process
argument_list|()
expr_stmt|;
break|break;
block|}
comment|// fallthrough -- processing must be done in the machine thread
case|case
name|QueuedProcessing
case|:
name|processingScheduled
operator|=
literal|true
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_process"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|cancelAllDelayedEvents
name|void
name|QStateMachinePrivate
operator|::
name|cancelAllDelayedEvents
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|delayedEventsMutex
argument_list|)
decl_stmt|;
name|QHash
argument_list|<
name|int
argument_list|,
name|DelayedEvent
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|delayedEvents
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|delayedEvents
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|DelayedEvent
modifier|&
name|e
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|timerId
condition|)
block|{
name|timerIdToDelayedEventId
operator|.
name|remove
argument_list|(
name|e
operator|.
name|timerId
argument_list|)
expr_stmt|;
name|q
operator|->
name|killTimer
argument_list|(
name|e
operator|.
name|timerId
argument_list|)
expr_stmt|;
name|delayedEventIdFreeList
operator|.
name|release
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Cancellation will be detected in pending _q_startDelayedEventTimer() call
block|}
operator|delete
name|e
operator|.
name|event
expr_stmt|;
block|}
name|delayedEvents
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   This function is called when the state machine is performing no   microstep because no transition is enabled (i.e. an event is ignored).    The default implementation does nothing. */
end_comment
begin_function
DECL|function|noMicrostep
name|void
name|QStateMachinePrivate
operator|::
name|noMicrostep
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*   This function is called when the state machine has reached a stable   state (no pending events), and has not finished yet.   For each event the state machine receives it is guaranteed that   1) beginMacrostep is called   2) selectTransition is called at least once   3) begin/endMicrostep is called at least once or noMicrostep is called      at least once (possibly both, but at least one)   4) the state machine either enters an infinite loop, or stops (runningChanged(false),      and either finished or stopped are emitted), or processedPendingEvents() is called.   5) if the machine is not in an infinite loop endMacrostep is called   6) when the machine is finished and all processing (like signal emission) is done,      exitInterpreter() is called. (This is the same name as the SCXML specification uses.)    didChange is set to true if at least one microstep was performed, it is possible   that the machine returned to exactly the same state as before, but some transitions   were triggered.    The default implementation does nothing. */
end_comment
begin_function
DECL|function|processedPendingEvents
name|void
name|QStateMachinePrivate
operator|::
name|processedPendingEvents
parameter_list|(
name|bool
name|didChange
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|didChange
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|beginMacrostep
name|void
name|QStateMachinePrivate
operator|::
name|beginMacrostep
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|endMacrostep
name|void
name|QStateMachinePrivate
operator|::
name|endMacrostep
parameter_list|(
name|bool
name|didChange
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|didChange
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|exitInterpreter
name|void
name|QStateMachinePrivate
operator|::
name|exitInterpreter
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|emitStateFinished
name|void
name|QStateMachinePrivate
operator|::
name|emitStateFinished
parameter_list|(
name|QState
modifier|*
name|forState
parameter_list|,
name|QFinalState
modifier|*
name|guiltyState
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|guiltyState
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|guiltyState
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": emitting finished signal for"
operator|<<
name|forState
expr_stmt|;
endif|#
directive|endif
name|QStatePrivate
operator|::
name|get
argument_list|(
name|forState
argument_list|)
operator|->
name|emitFinished
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|startupHook
name|void
name|QStateMachinePrivate
operator|::
name|startupHook
parameter_list|()
block|{ }
end_function
begin_namespace
DECL|namespace|_QStateMachine_Internal
namespace|namespace
name|_QStateMachine_Internal
block|{
DECL|class|GoToStateTransition
class|class
name|GoToStateTransition
super|:
specifier|public
name|QAbstractTransition
block|{
name|Q_OBJECT
public|public:
DECL|function|GoToStateTransition
name|GoToStateTransition
parameter_list|(
name|QAbstractState
modifier|*
name|target
parameter_list|)
member_init_list|:
name|QAbstractTransition
argument_list|()
block|{
name|setTargetState
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
protected|protected:
name|void
name|onTransition
parameter_list|(
name|QEvent
modifier|*
parameter_list|)
name|Q_DECL_OVERRIDE
block|{
name|deleteLater
argument_list|()
expr_stmt|;
block|}
name|bool
name|eventTest
parameter_list|(
name|QEvent
modifier|*
parameter_list|)
name|Q_DECL_OVERRIDE
block|{
return|return
literal|true
return|;
block|}
block|}
class|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_comment
comment|// mingw compiler tries to export QObject::findChild<GoToStateTransition>(),
end_comment
begin_comment
comment|// which doesn't work if its in an anonymous namespace.
end_comment
begin_using
using|using
namespace|namespace
name|_QStateMachine_Internal
namespace|;
end_using
begin_comment
comment|/*!   \internal    Causes this state machine to unconditionally transition to the given   \a targetState.    Provides a backdoor for using the state machine "imperatively"; i.e.  rather   than defining explicit transitions, you drive the machine's execution by   calling this function. It breaks the whole integrity of the   transition-driven model, but is provided for pragmatic reasons. */
end_comment
begin_function
DECL|function|goToState
name|void
name|QStateMachinePrivate
operator|::
name|goToState
parameter_list|(
name|QAbstractState
modifier|*
name|targetState
parameter_list|)
block|{
if|if
condition|(
operator|!
name|targetState
condition|)
block|{
name|qWarning
argument_list|(
literal|"QStateMachine::goToState(): cannot go to null state"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|configuration
operator|.
name|contains
argument_list|(
name|targetState
argument_list|)
condition|)
return|return;
name|Q_ASSERT
argument_list|(
name|state
operator|==
name|Running
argument_list|)
expr_stmt|;
name|QState
modifier|*
name|sourceState
init|=
literal|0
decl_stmt|;
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|configuration
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|configuration
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|sourceState
operator|=
name|toStandardState
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceState
operator|!=
literal|0
condition|)
break|break;
block|}
name|Q_ASSERT
argument_list|(
name|sourceState
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// Reuse previous GoToStateTransition in case of several calls to
comment|// goToState() in a row.
name|GoToStateTransition
modifier|*
name|trans
init|=
name|sourceState
operator|->
name|findChild
argument_list|<
name|GoToStateTransition
operator|*
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|trans
condition|)
block|{
name|trans
operator|=
operator|new
name|GoToStateTransition
argument_list|(
name|targetState
argument_list|)
expr_stmt|;
name|sourceState
operator|->
name|addTransition
argument_list|(
name|trans
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trans
operator|->
name|setTargetState
argument_list|(
name|targetState
argument_list|)
expr_stmt|;
block|}
name|processEvents
argument_list|(
name|QueuedProcessing
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|registerTransitions
name|void
name|QStateMachinePrivate
operator|::
name|registerTransitions
parameter_list|(
name|QAbstractState
modifier|*
name|state
parameter_list|)
block|{
name|QState
modifier|*
name|group
init|=
name|toStandardState
argument_list|(
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|group
condition|)
return|return;
name|QList
argument_list|<
name|QAbstractTransition
modifier|*
argument_list|>
name|transitions
init|=
name|QStatePrivate
operator|::
name|get
argument_list|(
name|group
argument_list|)
operator|->
name|transitions
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|transitions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractTransition
modifier|*
name|t
init|=
name|transitions
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|registerTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|maybeRegisterTransition
name|void
name|QStateMachinePrivate
operator|::
name|maybeRegisterTransition
parameter_list|(
name|QAbstractTransition
modifier|*
name|transition
parameter_list|)
block|{
if|if
condition|(
name|QSignalTransition
modifier|*
name|st
init|=
name|qobject_cast
argument_list|<
name|QSignalTransition
operator|*
argument_list|>
argument_list|(
name|transition
argument_list|)
condition|)
block|{
name|maybeRegisterSignalTransition
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_STATEMACHINE_EVENTFILTER
elseif|else
if|if
condition|(
name|QEventTransition
modifier|*
name|et
init|=
name|qobject_cast
argument_list|<
name|QEventTransition
operator|*
argument_list|>
argument_list|(
name|transition
argument_list|)
condition|)
block|{
name|maybeRegisterEventTransition
argument_list|(
name|et
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|registerTransition
name|void
name|QStateMachinePrivate
operator|::
name|registerTransition
parameter_list|(
name|QAbstractTransition
modifier|*
name|transition
parameter_list|)
block|{
if|if
condition|(
name|QSignalTransition
modifier|*
name|st
init|=
name|qobject_cast
argument_list|<
name|QSignalTransition
operator|*
argument_list|>
argument_list|(
name|transition
argument_list|)
condition|)
block|{
name|registerSignalTransition
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_STATEMACHINE_EVENTFILTER
elseif|else
if|if
condition|(
name|QEventTransition
modifier|*
name|oet
init|=
name|qobject_cast
argument_list|<
name|QEventTransition
operator|*
argument_list|>
argument_list|(
name|transition
argument_list|)
condition|)
block|{
name|registerEventTransition
argument_list|(
name|oet
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|unregisterTransition
name|void
name|QStateMachinePrivate
operator|::
name|unregisterTransition
parameter_list|(
name|QAbstractTransition
modifier|*
name|transition
parameter_list|)
block|{
if|if
condition|(
name|QSignalTransition
modifier|*
name|st
init|=
name|qobject_cast
argument_list|<
name|QSignalTransition
operator|*
argument_list|>
argument_list|(
name|transition
argument_list|)
condition|)
block|{
name|unregisterSignalTransition
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_STATEMACHINE_EVENTFILTER
elseif|else
if|if
condition|(
name|QEventTransition
modifier|*
name|oet
init|=
name|qobject_cast
argument_list|<
name|QEventTransition
operator|*
argument_list|>
argument_list|(
name|transition
argument_list|)
condition|)
block|{
name|unregisterEventTransition
argument_list|(
name|oet
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|maybeRegisterSignalTransition
name|void
name|QStateMachinePrivate
operator|::
name|maybeRegisterSignalTransition
parameter_list|(
name|QSignalTransition
modifier|*
name|transition
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|==
name|Running
operator|)
operator|&&
operator|(
name|configuration
operator|.
name|contains
argument_list|(
name|transition
operator|->
name|sourceState
argument_list|()
argument_list|)
operator|||
operator|(
name|transition
operator|->
name|senderObject
argument_list|()
operator|&&
operator|(
name|transition
operator|->
name|senderObject
argument_list|()
operator|->
name|thread
argument_list|()
operator|!=
name|q
operator|->
name|thread
argument_list|()
operator|)
operator|)
operator|)
condition|)
block|{
name|registerSignalTransition
argument_list|(
name|transition
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|registerSignalTransition
name|void
name|QStateMachinePrivate
operator|::
name|registerSignalTransition
parameter_list|(
name|QSignalTransition
modifier|*
name|transition
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
if|if
condition|(
name|QSignalTransitionPrivate
operator|::
name|get
argument_list|(
name|transition
argument_list|)
operator|->
name|signalIndex
operator|!=
operator|-
literal|1
condition|)
return|return;
comment|// already registered
specifier|const
name|QObject
modifier|*
name|sender
init|=
name|QSignalTransitionPrivate
operator|::
name|get
argument_list|(
name|transition
argument_list|)
operator|->
name|sender
decl_stmt|;
if|if
condition|(
operator|!
name|sender
condition|)
return|return;
name|QByteArray
name|signal
init|=
name|QSignalTransitionPrivate
operator|::
name|get
argument_list|(
name|transition
argument_list|)
operator|->
name|signal
decl_stmt|;
if|if
condition|(
name|signal
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|signal
operator|.
name|startsWith
argument_list|(
literal|'0'
operator|+
name|QSIGNAL_CODE
argument_list|)
condition|)
name|signal
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|meta
init|=
name|sender
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|int
name|signalIndex
init|=
name|meta
operator|->
name|indexOfSignal
argument_list|(
name|signal
argument_list|)
decl_stmt|;
name|int
name|originalSignalIndex
init|=
name|signalIndex
decl_stmt|;
if|if
condition|(
name|signalIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|signalIndex
operator|=
name|meta
operator|->
name|indexOfSignal
argument_list|(
name|QMetaObject
operator|::
name|normalizedSignature
argument_list|(
name|signal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|signalIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSignalTransition: no such signal: %s::%s"
argument_list|,
name|meta
operator|->
name|className
argument_list|()
argument_list|,
name|signal
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|originalSignalIndex
operator|=
name|signalIndex
expr_stmt|;
block|}
comment|// The signal index we actually want to connect to is the one
comment|// that is going to be sent, i.e. the non-cloned original index.
while|while
condition|(
name|meta
operator|->
name|method
argument_list|(
name|signalIndex
argument_list|)
operator|.
name|attributes
argument_list|()
operator|&
name|QMetaMethod
operator|::
name|Cloned
condition|)
operator|--
name|signalIndex
expr_stmt|;
name|connectionsMutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|connectedSignalIndexes
init|=
name|connections
index|[
name|sender
index|]
decl_stmt|;
if|if
condition|(
name|connectedSignalIndexes
operator|.
name|size
argument_list|()
operator|<=
name|signalIndex
condition|)
name|connectedSignalIndexes
operator|.
name|resize
argument_list|(
name|signalIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|connectedSignalIndexes
operator|.
name|at
argument_list|(
name|signalIndex
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|signalEventGenerator
condition|)
name|signalEventGenerator
operator|=
operator|new
name|QSignalEventGenerator
argument_list|(
name|q
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|int
name|generatorMethodOffset
init|=
name|QSignalEventGenerator
operator|::
name|staticMetaObject
operator|.
name|methodOffset
argument_list|()
decl_stmt|;
name|bool
name|ok
init|=
name|QMetaObject
operator|::
name|connect
argument_list|(
name|sender
argument_list|,
name|signalIndex
argument_list|,
name|signalEventGenerator
argument_list|,
name|generatorMethodOffset
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": FAILED to add signal transition from"
operator|<<
name|transition
operator|->
name|sourceState
argument_list|()
operator|<<
literal|": ( sender ="
operator|<<
name|sender
operator|<<
literal|", signal ="
operator|<<
name|signal
operator|<<
literal|", targets ="
operator|<<
name|transition
operator|->
name|targetStates
argument_list|()
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
block|}
operator|++
name|connectedSignalIndexes
index|[
name|signalIndex
index|]
expr_stmt|;
name|connectionsMutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QSignalTransitionPrivate
operator|::
name|get
argument_list|(
name|transition
argument_list|)
operator|->
name|signalIndex
operator|=
name|signalIndex
expr_stmt|;
name|QSignalTransitionPrivate
operator|::
name|get
argument_list|(
name|transition
argument_list|)
operator|->
name|originalSignalIndex
operator|=
name|originalSignalIndex
expr_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": added signal transition from"
operator|<<
name|transition
operator|->
name|sourceState
argument_list|()
operator|<<
literal|": ( sender ="
operator|<<
name|sender
operator|<<
literal|", signal ="
operator|<<
name|signal
operator|<<
literal|", targets ="
operator|<<
name|transition
operator|->
name|targetStates
argument_list|()
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|unregisterSignalTransition
name|void
name|QStateMachinePrivate
operator|::
name|unregisterSignalTransition
parameter_list|(
name|QSignalTransition
modifier|*
name|transition
parameter_list|)
block|{
name|int
name|signalIndex
init|=
name|QSignalTransitionPrivate
operator|::
name|get
argument_list|(
name|transition
argument_list|)
operator|->
name|signalIndex
decl_stmt|;
if|if
condition|(
name|signalIndex
operator|==
operator|-
literal|1
condition|)
return|return;
comment|// not registered
specifier|const
name|QObject
modifier|*
name|sender
init|=
name|QSignalTransitionPrivate
operator|::
name|get
argument_list|(
name|transition
argument_list|)
operator|->
name|sender
decl_stmt|;
name|QSignalTransitionPrivate
operator|::
name|get
argument_list|(
name|transition
argument_list|)
operator|->
name|signalIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|connectionsMutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|connectedSignalIndexes
init|=
name|connections
index|[
name|sender
index|]
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|connectedSignalIndexes
operator|.
name|size
argument_list|()
operator|>
name|signalIndex
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|connectedSignalIndexes
operator|.
name|at
argument_list|(
name|signalIndex
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|connectedSignalIndexes
index|[
name|signalIndex
index|]
operator|==
literal|0
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|signalEventGenerator
operator|!=
literal|0
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|int
name|generatorMethodOffset
init|=
name|QSignalEventGenerator
operator|::
name|staticMetaObject
operator|.
name|methodOffset
argument_list|()
decl_stmt|;
name|QMetaObject
operator|::
name|disconnect
argument_list|(
name|sender
argument_list|,
name|signalIndex
argument_list|,
name|signalEventGenerator
argument_list|,
name|generatorMethodOffset
argument_list|)
expr_stmt|;
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|connectedSignalIndexes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|sum
operator|+=
name|connectedSignalIndexes
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum
operator|==
literal|0
condition|)
name|connections
operator|.
name|remove
argument_list|(
name|sender
argument_list|)
expr_stmt|;
block|}
name|connectionsMutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unregisterAllTransitions
name|void
name|QStateMachinePrivate
operator|::
name|unregisterAllTransitions
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
block|{
name|QList
argument_list|<
name|QSignalTransition
modifier|*
argument_list|>
name|transitions
init|=
name|rootState
argument_list|()
operator|->
name|findChildren
argument_list|<
name|QSignalTransition
operator|*
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|transitions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSignalTransition
modifier|*
name|t
init|=
name|transitions
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|machine
argument_list|()
operator|==
name|q
condition|)
name|unregisterSignalTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|QList
argument_list|<
name|QEventTransition
modifier|*
argument_list|>
name|transitions
init|=
name|rootState
argument_list|()
operator|->
name|findChildren
argument_list|<
name|QEventTransition
operator|*
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|transitions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QEventTransition
modifier|*
name|t
init|=
name|transitions
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|machine
argument_list|()
operator|==
name|q
condition|)
name|unregisterEventTransition
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STATEMACHINE_EVENTFILTER
end_ifndef
begin_function
DECL|function|maybeRegisterEventTransition
name|void
name|QStateMachinePrivate
operator|::
name|maybeRegisterEventTransition
parameter_list|(
name|QEventTransition
modifier|*
name|transition
parameter_list|)
block|{
if|if
condition|(
operator|(
name|state
operator|==
name|Running
operator|)
operator|&&
name|configuration
operator|.
name|contains
argument_list|(
name|transition
operator|->
name|sourceState
argument_list|()
argument_list|)
condition|)
name|registerEventTransition
argument_list|(
name|transition
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|registerEventTransition
name|void
name|QStateMachinePrivate
operator|::
name|registerEventTransition
parameter_list|(
name|QEventTransition
modifier|*
name|transition
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
if|if
condition|(
name|QEventTransitionPrivate
operator|::
name|get
argument_list|(
name|transition
argument_list|)
operator|->
name|registered
condition|)
return|return;
if|if
condition|(
name|transition
operator|->
name|eventType
argument_list|()
operator|>=
name|QEvent
operator|::
name|User
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject event transitions are not supported for custom types"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QObject
modifier|*
name|object
init|=
name|QEventTransitionPrivate
operator|::
name|get
argument_list|(
name|transition
argument_list|)
operator|->
name|object
decl_stmt|;
if|if
condition|(
operator|!
name|object
condition|)
return|return;
name|QObjectPrivate
modifier|*
name|od
init|=
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|od
operator|->
name|extraData
operator|||
operator|!
name|od
operator|->
name|extraData
operator|->
name|eventFilters
operator|.
name|contains
argument_list|(
name|q
argument_list|)
condition|)
name|object
operator|->
name|installEventFilter
argument_list|(
name|q
argument_list|)
expr_stmt|;
operator|++
name|qobjectEvents
index|[
name|object
index|]
index|[
name|transition
operator|->
name|eventType
argument_list|()
index|]
expr_stmt|;
name|QEventTransitionPrivate
operator|::
name|get
argument_list|(
name|transition
argument_list|)
operator|->
name|registered
operator|=
literal|true
expr_stmt|;
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|": added event transition from"
operator|<<
name|transition
operator|->
name|sourceState
argument_list|()
operator|<<
literal|": ( object ="
operator|<<
name|object
operator|<<
literal|", event ="
operator|<<
name|transition
operator|->
name|eventType
argument_list|()
operator|<<
literal|", targets ="
operator|<<
name|transition
operator|->
name|targetStates
argument_list|()
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|unregisterEventTransition
name|void
name|QStateMachinePrivate
operator|::
name|unregisterEventTransition
parameter_list|(
name|QEventTransition
modifier|*
name|transition
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QEventTransitionPrivate
operator|::
name|get
argument_list|(
name|transition
argument_list|)
operator|->
name|registered
condition|)
return|return;
name|QObject
modifier|*
name|object
init|=
name|QEventTransitionPrivate
operator|::
name|get
argument_list|(
name|transition
argument_list|)
operator|->
name|object
decl_stmt|;
name|QHash
argument_list|<
name|QEvent
operator|::
name|Type
argument_list|,
name|int
argument_list|>
modifier|&
name|events
init|=
name|qobjectEvents
index|[
name|object
index|]
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|events
operator|.
name|value
argument_list|(
name|transition
operator|->
name|eventType
argument_list|()
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|events
index|[
name|transition
operator|->
name|eventType
argument_list|()
index|]
operator|==
literal|0
condition|)
block|{
name|events
operator|.
name|remove
argument_list|(
name|transition
operator|->
name|eventType
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|QHash
argument_list|<
name|QEvent
operator|::
name|Type
argument_list|,
name|int
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|events
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|events
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|sum
operator|+=
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
if|if
condition|(
name|sum
operator|==
literal|0
condition|)
block|{
name|qobjectEvents
operator|.
name|remove
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|->
name|removeEventFilter
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
name|QEventTransitionPrivate
operator|::
name|get
argument_list|(
name|transition
argument_list|)
operator|->
name|registered
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleFilteredEvent
name|void
name|QStateMachinePrivate
operator|::
name|handleFilteredEvent
parameter_list|(
name|QObject
modifier|*
name|watched
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|qobjectEvents
operator|.
name|value
argument_list|(
name|watched
argument_list|)
operator|.
name|contains
argument_list|(
name|event
operator|->
name|type
argument_list|()
argument_list|)
condition|)
block|{
name|postInternalEvent
argument_list|(
operator|new
name|QStateMachine
operator|::
name|WrappedEvent
argument_list|(
name|watched
argument_list|,
name|handler
operator|->
name|cloneEvent
argument_list|(
name|event
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|processEvents
argument_list|(
name|DirectProcessing
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|handleTransitionSignal
name|void
name|QStateMachinePrivate
operator|::
name|handleTransitionSignal
parameter_list|(
name|QObject
modifier|*
name|sender
parameter_list|,
name|int
name|signalIndex
parameter_list|,
name|void
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|connectionsMutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|connections
index|[
name|sender
index|]
operator|.
name|at
argument_list|(
name|signalIndex
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|connectionsMutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
endif|#
directive|endif
specifier|const
name|QMetaObject
modifier|*
name|meta
init|=
name|sender
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|QMetaMethod
name|method
init|=
name|meta
operator|->
name|method
argument_list|(
name|signalIndex
argument_list|)
decl_stmt|;
name|int
name|argc
init|=
name|method
operator|.
name|parameterCount
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QVariant
argument_list|>
name|vargs
decl_stmt|;
name|vargs
operator|.
name|reserve
argument_list|(
name|argc
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|int
name|type
init|=
name|method
operator|.
name|parameterType
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|vargs
operator|.
name|append
argument_list|(
name|QVariant
argument_list|(
name|type
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|q_func
argument_list|()
operator|<<
literal|": sending signal event ( sender ="
operator|<<
name|sender
operator|<<
literal|", signal ="
operator|<<
name|method
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|postInternalEvent
argument_list|(
operator|new
name|QStateMachine
operator|::
name|SignalEvent
argument_list|(
name|sender
argument_list|,
name|signalIndex
argument_list|,
name|vargs
argument_list|)
argument_list|)
expr_stmt|;
name|processEvents
argument_list|(
name|DirectProcessing
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Constructs a new state machine with the given \a parent. */
end_comment
begin_constructor
DECL|function|QStateMachine
name|QStateMachine
operator|::
name|QStateMachine
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QState
argument_list|(
operator|*
operator|new
name|QStateMachinePrivate
argument_list|,
comment|/*parentState=*/
literal|0
argument_list|)
block|{
comment|// Can't pass the parent to the QState constructor, as it expects a QState
comment|// But this works as expected regardless of whether parent is a QState or not
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   \since 5.0    Constructs a new state machine with the given \a childMode   and \a parent. */
end_comment
begin_constructor
DECL|function|QStateMachine
name|QStateMachine
operator|::
name|QStateMachine
parameter_list|(
name|QState
operator|::
name|ChildMode
name|childMode
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QState
argument_list|(
operator|*
operator|new
name|QStateMachinePrivate
argument_list|,
comment|/*parentState=*/
literal|0
argument_list|)
block|{
name|Q_D
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|d
operator|->
name|childMode
operator|=
name|childMode
expr_stmt|;
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|// See comment in constructor above
block|}
end_constructor
begin_comment
comment|/*!   \internal */
end_comment
begin_constructor
DECL|function|QStateMachine
name|QStateMachine
operator|::
name|QStateMachine
parameter_list|(
name|QStateMachinePrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QState
argument_list|(
name|dd
argument_list|,
comment|/*parentState=*/
literal|0
argument_list|)
block|{
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Destroys this state machine. */
end_comment
begin_destructor
DECL|function|~QStateMachine
name|QStateMachine
operator|::
name|~
name|QStateMachine
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!   \enum QStateMachine::EventPriority    This enum type specifies the priority of an event posted to the state   machine using postEvent().    Events of high priority are processed before events of normal priority.    \value NormalPriority The event has normal priority.   \value HighPriority The event has high priority. */
end_comment
begin_comment
comment|/*! \enum QStateMachine::Error      This enum type defines errors that can occur in the state machine at run time. When the state     machine encounters an unrecoverable error at run time, it will set the error code returned     by error(), the error message returned by errorString(), and enter an error state based on     the context of the error.      \value NoError No error has occurred.     \value NoInitialStateError The machine has entered a QState with children which does not have an            initial state set. The context of this error is the state which is missing an initial            state.     \value NoDefaultStateInHistoryStateError The machine has entered a QHistoryState which does not have            a default state set. The context of this error is the QHistoryState which is missing a            default state.     \value NoCommonAncestorForTransitionError The machine has selected a transition whose source            and targets are not part of the same tree of states, and thus are not part of the same            state machine. Commonly, this could mean that one of the states has not been given            any parent or added to any machine. The context of this error is the source state of            the transition.      \sa setErrorState() */
end_comment
begin_comment
comment|/*!   Returns the error code of the last error that occurred in the state machine. */
end_comment
begin_function
DECL|function|error
name|QStateMachine
operator|::
name|Error
name|QStateMachine
operator|::
name|error
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QStateMachine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|error
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the error string of the last error that occurred in the state machine. */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QStateMachine
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QStateMachine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|errorString
return|;
block|}
end_function
begin_comment
comment|/*!   Clears the error string and error code of the state machine. */
end_comment
begin_function
DECL|function|clearError
name|void
name|QStateMachine
operator|::
name|clearError
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|d
operator|->
name|errorString
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|error
operator|=
name|NoError
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!    Returns the restore policy of the state machine.     \sa setGlobalRestorePolicy() */
end_comment
begin_function
DECL|function|globalRestorePolicy
name|QState
operator|::
name|RestorePolicy
name|QStateMachine
operator|::
name|globalRestorePolicy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QStateMachine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|globalRestorePolicy
return|;
block|}
end_function
begin_comment
comment|/*!    Sets the restore policy of the state machine to \a restorePolicy. The default    restore policy is QState::DontRestoreProperties.     \sa globalRestorePolicy() */
end_comment
begin_function
DECL|function|setGlobalRestorePolicy
name|void
name|QStateMachine
operator|::
name|setGlobalRestorePolicy
parameter_list|(
name|QState
operator|::
name|RestorePolicy
name|restorePolicy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|d
operator|->
name|globalRestorePolicy
operator|=
name|restorePolicy
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Adds the given \a state to this state machine. The state becomes a top-level   state.    If the state is already in a different machine, it will first be removed   from its old machine, and then added to this machine.    \sa removeState(), setInitialState() */
end_comment
begin_function
DECL|function|addState
name|void
name|QStateMachine
operator|::
name|addState
parameter_list|(
name|QAbstractState
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
operator|!
name|state
condition|)
block|{
name|qWarning
argument_list|(
literal|"QStateMachine::addState: cannot add null state"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|QAbstractStatePrivate
operator|::
name|get
argument_list|(
name|state
argument_list|)
operator|->
name|machine
argument_list|()
operator|==
name|this
condition|)
block|{
name|qWarning
argument_list|(
literal|"QStateMachine::addState: state has already been added to this machine"
argument_list|)
expr_stmt|;
return|return;
block|}
name|state
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Removes the given \a state from this state machine.  The state machine   releases ownership of the state.    \sa addState() */
end_comment
begin_function
DECL|function|removeState
name|void
name|QStateMachine
operator|::
name|removeState
parameter_list|(
name|QAbstractState
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
operator|!
name|state
condition|)
block|{
name|qWarning
argument_list|(
literal|"QStateMachine::removeState: cannot remove null state"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|QAbstractStatePrivate
operator|::
name|get
argument_list|(
name|state
argument_list|)
operator|->
name|machine
argument_list|()
operator|!=
name|this
condition|)
block|{
name|qWarning
argument_list|(
literal|"QStateMachine::removeState: state %p's machine (%p)"
literal|" is different from this machine (%p)"
argument_list|,
name|state
argument_list|,
name|QAbstractStatePrivate
operator|::
name|get
argument_list|(
name|state
argument_list|)
operator|->
name|machine
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
name|state
operator|->
name|setParent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isRunning
name|bool
name|QStateMachine
operator|::
name|isRunning
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QStateMachine
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|state
operator|==
name|QStateMachinePrivate
operator|::
name|Running
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Starts this state machine.  The machine will reset its configuration and   transition to the initial state.  When a final top-level state (QFinalState)   is entered, the machine will emit the finished() signal.    \note A state machine will not run without a running event loop, such as   the main application event loop started with QCoreApplication::exec() or   QApplication::exec().    \sa started(), finished(), stop(), initialState(), setRunning() */
end_comment
begin_function
DECL|function|start
name|void
name|QStateMachine
operator|::
name|start
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|childMode
argument_list|()
operator|==
name|QState
operator|::
name|ExclusiveStates
operator|)
operator|&&
operator|(
name|initialState
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QStateMachine::start: No initial state set for machine. Refusing to start."
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|d
operator|->
name|state
condition|)
block|{
case|case
name|QStateMachinePrivate
operator|::
name|NotRunning
case|:
name|d
operator|->
name|state
operator|=
name|QStateMachinePrivate
operator|::
name|Starting
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_start"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
break|break;
case|case
name|QStateMachinePrivate
operator|::
name|Starting
case|:
break|break;
case|case
name|QStateMachinePrivate
operator|::
name|Running
case|:
name|qWarning
argument_list|(
literal|"QStateMachine::start(): already running"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!   Stops this state machine. The state machine will stop processing events and   then emit the stopped() signal.    \sa stopped(), start(), setRunning() */
end_comment
begin_function
DECL|function|stop
name|void
name|QStateMachine
operator|::
name|stop
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|state
condition|)
block|{
case|case
name|QStateMachinePrivate
operator|::
name|NotRunning
case|:
break|break;
case|case
name|QStateMachinePrivate
operator|::
name|Starting
case|:
comment|// the machine will exit as soon as it enters the event processing loop
name|d
operator|->
name|stop
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|QStateMachinePrivate
operator|::
name|Running
case|:
name|d
operator|->
name|stop
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|processEvents
argument_list|(
name|QStateMachinePrivate
operator|::
name|QueuedProcessing
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|setRunning
name|void
name|QStateMachine
operator|::
name|setRunning
parameter_list|(
name|bool
name|running
parameter_list|)
block|{
if|if
condition|(
name|running
condition|)
name|start
argument_list|()
expr_stmt|;
else|else
name|stop
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \threadsafe    Posts the given \a event of the given \a priority for processing by this   state machine.    This function returns immediately. The event is added to the state machine's   event queue. Events are processed in the order posted. The state machine   takes ownership of the event and deletes it once it has been processed.    You can only post events when the state machine is running or when it is starting up.    \sa postDelayedEvent() */
end_comment
begin_function
DECL|function|postEvent
name|void
name|QStateMachine
operator|::
name|postEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
name|EventPriority
name|priority
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|state
condition|)
block|{
case|case
name|QStateMachinePrivate
operator|::
name|Running
case|:
case|case
name|QStateMachinePrivate
operator|::
name|Starting
case|:
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QStateMachine::postEvent: cannot post event when the state machine is not running"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|event
condition|)
block|{
name|qWarning
argument_list|(
literal|"QStateMachine::postEvent: cannot post null event"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|": posting event"
operator|<<
name|event
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|priority
condition|)
block|{
case|case
name|NormalPriority
case|:
name|d
operator|->
name|postExternalEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|HighPriority
case|:
name|d
operator|->
name|postInternalEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
name|d
operator|->
name|processEvents
argument_list|(
name|QStateMachinePrivate
operator|::
name|QueuedProcessing
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \threadsafe    Posts the given \a event for processing by this state machine, with the   given \a delay in milliseconds. Returns an identifier associated with the   delayed event, or -1 if the event could not be posted.    This function returns immediately. When the delay has expired, the event   will be added to the state machine's event queue for processing. The state   machine takes ownership of the event and deletes it once it has been   processed.    You can only post events when the state machine is running.    \sa cancelDelayedEvent(), postEvent() */
end_comment
begin_function
DECL|function|postDelayedEvent
name|int
name|QStateMachine
operator|::
name|postDelayedEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|QStateMachinePrivate
operator|::
name|Running
condition|)
block|{
name|qWarning
argument_list|(
literal|"QStateMachine::postDelayedEvent: cannot post event when the state machine is not running"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|event
condition|)
block|{
name|qWarning
argument_list|(
literal|"QStateMachine::postDelayedEvent: cannot post null event"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|delay
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QStateMachine::postDelayedEvent: delay cannot be negative"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|QSTATEMACHINE_DEBUG
name|qDebug
argument_list|()
operator|<<
name|this
operator|<<
literal|": posting event"
operator|<<
name|event
operator|<<
literal|"with delay"
operator|<<
name|delay
expr_stmt|;
endif|#
directive|endif
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|d
operator|->
name|delayedEventsMutex
argument_list|)
decl_stmt|;
name|int
name|id
init|=
name|d
operator|->
name|delayedEventIdFreeList
operator|.
name|next
argument_list|()
decl_stmt|;
name|bool
name|inMachineThread
init|=
operator|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|thread
argument_list|()
operator|)
decl_stmt|;
name|int
name|timerId
init|=
name|inMachineThread
condition|?
name|startTimer
argument_list|(
name|delay
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|inMachineThread
operator|&&
operator|!
name|timerId
condition|)
block|{
name|qWarning
argument_list|(
literal|"QStateMachine::postDelayedEvent: failed to start timer with interval %d"
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|d
operator|->
name|delayedEventIdFreeList
operator|.
name|release
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|QStateMachinePrivate
operator|::
name|DelayedEvent
name|delayedEvent
argument_list|(
name|event
argument_list|,
name|timerId
argument_list|)
decl_stmt|;
name|d
operator|->
name|delayedEvents
operator|.
name|insert
argument_list|(
name|id
argument_list|,
name|delayedEvent
argument_list|)
expr_stmt|;
if|if
condition|(
name|timerId
condition|)
block|{
name|d
operator|->
name|timerIdToDelayedEventId
operator|.
name|insert
argument_list|(
name|timerId
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|inMachineThread
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_startDelayedEventTimer"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|,
name|Q_ARG
argument_list|(
name|int
argument_list|,
name|id
argument_list|)
argument_list|,
name|Q_ARG
argument_list|(
name|int
argument_list|,
name|delay
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|id
return|;
block|}
end_function
begin_comment
comment|/*!   \threadsafe    Cancels the delayed event identified by the given \a id. The id should be a   value returned by a call to postDelayedEvent(). Returns \c true if the event   was successfully cancelled, otherwise returns \c false.    \sa postDelayedEvent() */
end_comment
begin_function
DECL|function|cancelDelayedEvent
name|bool
name|QStateMachine
operator|::
name|cancelDelayedEvent
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|QStateMachinePrivate
operator|::
name|Running
condition|)
block|{
name|qWarning
argument_list|(
literal|"QStateMachine::cancelDelayedEvent: the machine is not running"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|d
operator|->
name|delayedEventsMutex
argument_list|)
decl_stmt|;
name|QStateMachinePrivate
operator|::
name|DelayedEvent
name|e
init|=
name|d
operator|->
name|delayedEvents
operator|.
name|take
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|e
operator|.
name|event
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|e
operator|.
name|timerId
condition|)
block|{
name|d
operator|->
name|timerIdToDelayedEventId
operator|.
name|remove
argument_list|(
name|e
operator|.
name|timerId
argument_list|)
expr_stmt|;
name|bool
name|inMachineThread
init|=
operator|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|thread
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|inMachineThread
condition|)
block|{
name|killTimer
argument_list|(
name|e
operator|.
name|timerId
argument_list|)
expr_stmt|;
name|d
operator|->
name|delayedEventIdFreeList
operator|.
name|release
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_killDelayedEventTimer"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|,
name|Q_ARG
argument_list|(
name|int
argument_list|,
name|id
argument_list|)
argument_list|,
name|Q_ARG
argument_list|(
name|int
argument_list|,
name|e
operator|.
name|timerId
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Cancellation will be detected in pending _q_startDelayedEventTimer() call
block|}
operator|delete
name|e
operator|.
name|event
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!    Returns the maximal consistent set of states (including parallel and final    states) that this state machine is currently in. If a state \c s is in the    configuration, it is always the case that the parent of \c s is also in    c. Note, however, that the machine itself is not an explicit member of the    configuration. */
end_comment
begin_function
DECL|function|configuration
name|QSet
argument_list|<
name|QAbstractState
modifier|*
argument_list|>
name|QStateMachine
operator|::
name|configuration
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QStateMachine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|configuration
return|;
block|}
end_function
begin_comment
comment|/*!   \fn QStateMachine::started()    This signal is emitted when the state machine has entered its initial state   (QStateMachine::initialState).    \sa QStateMachine::finished(), QStateMachine::start() */
end_comment
begin_comment
comment|/*!   \fn QStateMachine::stopped()    This signal is emitted when the state machine has stopped.    \sa QStateMachine::stop(), QStateMachine::finished() */
end_comment
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QStateMachine
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Timer
condition|)
block|{
name|QTimerEvent
modifier|*
name|te
init|=
cast|static_cast
argument_list|<
name|QTimerEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|te
operator|->
name|timerId
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|QStateMachinePrivate
operator|::
name|Running
condition|)
block|{
comment|// This event has been cancelled already
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|d
operator|->
name|delayedEventsMutex
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|d
operator|->
name|timerIdToDelayedEventId
operator|.
name|contains
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|d
operator|->
name|delayedEventsMutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|int
name|id
init|=
name|d
operator|->
name|timerIdToDelayedEventId
operator|.
name|take
argument_list|(
name|tid
argument_list|)
decl_stmt|;
name|QStateMachinePrivate
operator|::
name|DelayedEvent
name|ee
init|=
name|d
operator|->
name|delayedEvents
operator|.
name|take
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|ee
operator|.
name|event
operator|!=
literal|0
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|ee
operator|.
name|timerId
operator|==
name|tid
argument_list|)
expr_stmt|;
name|killTimer
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|d
operator|->
name|delayedEventIdFreeList
operator|.
name|release
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|d
operator|->
name|delayedEventsMutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|d
operator|->
name|postExternalEvent
argument_list|(
name|ee
operator|.
name|event
argument_list|)
expr_stmt|;
name|d
operator|->
name|processEvents
argument_list|(
name|QStateMachinePrivate
operator|::
name|DirectProcessing
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|d
operator|->
name|delayedEventsMutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|QState
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STATEMACHINE_EVENTFILTER
end_ifndef
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|eventFilter
name|bool
name|QStateMachine
operator|::
name|eventFilter
parameter_list|(
name|QObject
modifier|*
name|watched
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|d
operator|->
name|handleFilteredEvent
argument_list|(
name|watched
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   \internal    This function is called when the state machine is about to select   transitions based on the given \a event.    The default implementation does nothing. */
end_comment
begin_function
DECL|function|beginSelectTransitions
name|void
name|QStateMachine
operator|::
name|beginSelectTransitions
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal    This function is called when the state machine has finished selecting   transitions based on the given \a event.    The default implementation does nothing. */
end_comment
begin_function
DECL|function|endSelectTransitions
name|void
name|QStateMachine
operator|::
name|endSelectTransitions
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal    This function is called when the state machine is about to do a microstep.    The default implementation does nothing. */
end_comment
begin_function
DECL|function|beginMicrostep
name|void
name|QStateMachine
operator|::
name|beginMicrostep
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal    This function is called when the state machine has finished doing a   microstep.    The default implementation does nothing. */
end_comment
begin_function
DECL|function|endMicrostep
name|void
name|QStateMachine
operator|::
name|endMicrostep
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \reimp     This function will call start() to start the state machine. */
end_comment
begin_function
DECL|function|onEntry
name|void
name|QStateMachine
operator|::
name|onEntry
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|start
argument_list|()
expr_stmt|;
name|QState
operator|::
name|onEntry
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \reimp     This function will call stop() to stop the state machine and     subsequently emit the stopped() signal. */
end_comment
begin_function
DECL|function|onExit
name|void
name|QStateMachine
operator|::
name|onExit
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|stop
argument_list|()
expr_stmt|;
name|QState
operator|::
name|onExit
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
end_ifndef
begin_comment
comment|/*!   Returns whether animations are enabled for this state machine. */
end_comment
begin_function
DECL|function|isAnimated
name|bool
name|QStateMachine
operator|::
name|isAnimated
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QStateMachine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|animated
return|;
block|}
end_function
begin_comment
comment|/*!   Sets whether animations are \a enabled for this state machine. */
end_comment
begin_function
DECL|function|setAnimated
name|void
name|QStateMachine
operator|::
name|setAnimated
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|d
operator|->
name|animated
operator|=
name|enabled
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds a default \a animation to be considered for any transition. */
end_comment
begin_function
DECL|function|addDefaultAnimation
name|void
name|QStateMachine
operator|::
name|addDefaultAnimation
parameter_list|(
name|QAbstractAnimation
modifier|*
name|animation
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|d
operator|->
name|defaultAnimations
operator|.
name|append
argument_list|(
name|animation
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the list of default animations that will be considered for any transition. */
end_comment
begin_function
DECL|function|defaultAnimations
name|QList
argument_list|<
name|QAbstractAnimation
modifier|*
argument_list|>
name|QStateMachine
operator|::
name|defaultAnimations
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QStateMachine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|defaultAnimations
return|;
block|}
end_function
begin_comment
comment|/*!     Removes \a animation from the list of default animations. */
end_comment
begin_function
DECL|function|removeDefaultAnimation
name|void
name|QStateMachine
operator|::
name|removeDefaultAnimation
parameter_list|(
name|QAbstractAnimation
modifier|*
name|animation
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QStateMachine
argument_list|)
expr_stmt|;
name|d
operator|->
name|defaultAnimations
operator|.
name|removeAll
argument_list|(
name|animation
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_ANIMATION
end_comment
begin_comment
comment|// Begin moc-generated code -- modify carefully (check "HAND EDIT" parts)!
end_comment
begin_struct
DECL|struct|qt_meta_stringdata_QSignalEventGenerator_t
struct|struct
name|qt_meta_stringdata_QSignalEventGenerator_t
block|{
DECL|member|data
name|QByteArrayData
name|data
index|[
literal|3
index|]
decl_stmt|;
DECL|member|stringdata
name|char
name|stringdata
index|[
literal|32
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|QT_MOC_LITERAL
define|#
directive|define
name|QT_MOC_LITERAL
parameter_list|(
name|idx
parameter_list|,
name|ofs
parameter_list|,
name|len
parameter_list|)
define|\
value|Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \         offsetof(qt_meta_stringdata_QSignalEventGenerator_t, stringdata) + ofs \         - idx * sizeof(QByteArrayData) \     )
end_define
begin_decl_stmt
DECL|variable|qt_meta_stringdata_QSignalEventGenerator
specifier|static
specifier|const
name|qt_meta_stringdata_QSignalEventGenerator_t
name|qt_meta_stringdata_QSignalEventGenerator
init|=
block|{
block|{
name|QT_MOC_LITERAL
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|21
argument_list|)
block|,
name|QT_MOC_LITERAL
argument_list|(
literal|1
argument_list|,
literal|22
argument_list|,
literal|7
argument_list|)
block|,
name|QT_MOC_LITERAL
argument_list|(
literal|2
argument_list|,
literal|30
argument_list|,
literal|0
argument_list|)
block|}
block|,
literal|"QSignalEventGenerator\0execute\0\0"
block|}
decl_stmt|;
end_decl_stmt
begin_undef
DECL|macro|QT_MOC_LITERAL
undef|#
directive|undef
name|QT_MOC_LITERAL
end_undef
begin_decl_stmt
DECL|variable|qt_meta_data_QSignalEventGenerator
specifier|static
specifier|const
name|uint
name|qt_meta_data_QSignalEventGenerator
index|[]
init|=
block|{
comment|// content:
literal|7
block|,
comment|// revision
literal|0
block|,
comment|// classname
literal|0
block|,
literal|0
block|,
comment|// classinfo
literal|1
block|,
literal|14
block|,
comment|// methods
literal|0
block|,
literal|0
block|,
comment|// properties
literal|0
block|,
literal|0
block|,
comment|// enums/sets
literal|0
block|,
literal|0
block|,
comment|// constructors
literal|0
block|,
comment|// flags
literal|0
block|,
comment|// signalCount
comment|// slots: name, argc, parameters, tag, flags
literal|1
block|,
literal|0
block|,
literal|19
block|,
literal|2
block|,
literal|0x0a
block|,
comment|// slots: parameters
name|QMetaType
operator|::
name|Void
block|,
literal|0
comment|// eod
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_static_metacall
name|void
name|QSignalEventGenerator
operator|::
name|qt_static_metacall
parameter_list|(
name|QObject
modifier|*
name|_o
parameter_list|,
name|QMetaObject
operator|::
name|Call
name|_c
parameter_list|,
name|int
name|_id
parameter_list|,
name|void
modifier|*
modifier|*
name|_a
parameter_list|)
block|{
if|if
condition|(
name|_c
operator|==
name|QMetaObject
operator|::
name|InvokeMetaMethod
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|staticMetaObject
operator|.
name|cast
argument_list|(
name|_o
argument_list|)
argument_list|)
expr_stmt|;
name|QSignalEventGenerator
modifier|*
name|_t
init|=
cast|static_cast
argument_list|<
name|QSignalEventGenerator
operator|*
argument_list|>
argument_list|(
name|_o
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|_id
condition|)
block|{
case|case
literal|0
case|:
name|_t
operator|->
name|execute
argument_list|(
name|_a
argument_list|)
expr_stmt|;
break|break;
comment|// HAND EDIT: add the _a parameter
default|default:
empty_stmt|;
block|}
block|}
name|Q_UNUSED
argument_list|(
name|_a
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|member|staticMetaObject
specifier|const
name|QMetaObject
name|QSignalEventGenerator
operator|::
name|staticMetaObject
init|=
block|{
block|{
operator|&
name|QObject
operator|::
name|staticMetaObject
block|,
name|qt_meta_stringdata_QSignalEventGenerator
operator|.
name|data
block|,
name|qt_meta_data_QSignalEventGenerator
block|,
name|qt_static_metacall
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|metaObject
specifier|const
name|QMetaObject
modifier|*
name|QSignalEventGenerator
operator|::
name|metaObject
parameter_list|()
specifier|const
block|{
return|return
operator|&
name|staticMetaObject
return|;
block|}
end_function
begin_function
DECL|function|qt_metacast
name|void
modifier|*
name|QSignalEventGenerator
operator|::
name|qt_metacast
parameter_list|(
specifier|const
name|char
modifier|*
name|_clname
parameter_list|)
block|{
if|if
condition|(
operator|!
name|_clname
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|_clname
argument_list|,
name|qt_meta_stringdata_QSignalEventGenerator
operator|.
name|stringdata
argument_list|)
condition|)
return|return
cast|static_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|QSignalEventGenerator
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|)
return|;
return|return
name|QObject
operator|::
name|qt_metacast
argument_list|(
name|_clname
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qt_metacall
name|int
name|QSignalEventGenerator
operator|::
name|qt_metacall
parameter_list|(
name|QMetaObject
operator|::
name|Call
name|_c
parameter_list|,
name|int
name|_id
parameter_list|,
name|void
modifier|*
modifier|*
name|_a
parameter_list|)
block|{
name|_id
operator|=
name|QObject
operator|::
name|qt_metacall
argument_list|(
name|_c
argument_list|,
name|_id
argument_list|,
name|_a
argument_list|)
expr_stmt|;
if|if
condition|(
name|_id
operator|<
literal|0
condition|)
return|return
name|_id
return|;
if|if
condition|(
name|_c
operator|==
name|QMetaObject
operator|::
name|InvokeMetaMethod
condition|)
block|{
if|if
condition|(
name|_id
operator|<
literal|1
condition|)
name|qt_static_metacall
argument_list|(
name|this
argument_list|,
name|_c
argument_list|,
name|_id
argument_list|,
name|_a
argument_list|)
expr_stmt|;
name|_id
operator|-=
literal|1
expr_stmt|;
block|}
return|return
name|_id
return|;
block|}
end_function
begin_comment
comment|// End moc-generated code
end_comment
begin_function
DECL|function|execute
name|void
name|QSignalEventGenerator
operator|::
name|execute
parameter_list|(
name|void
modifier|*
modifier|*
name|_a
parameter_list|)
block|{
name|int
name|signalIndex
init|=
name|senderSignalIndex
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|signalIndex
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|QStateMachine
modifier|*
name|machine
init|=
name|qobject_cast
argument_list|<
name|QStateMachine
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|()
argument_list|)
decl_stmt|;
name|QStateMachinePrivate
operator|::
name|get
argument_list|(
name|machine
argument_list|)
operator|->
name|handleTransitionSignal
argument_list|(
name|sender
argument_list|()
argument_list|,
name|signalIndex
argument_list|,
name|_a
argument_list|)
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QSignalEventGenerator
name|QSignalEventGenerator
operator|::
name|QSignalEventGenerator
parameter_list|(
name|QStateMachine
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   \class QStateMachine::SignalEvent   \inmodule QtCore    \brief The SignalEvent class represents a Qt signal event.    \since 4.6   \ingroup statemachine    A signal event is generated by a QStateMachine in response to a Qt   signal. The QSignalTransition class provides a transition associated with a   signal event. QStateMachine::SignalEvent is part of \l{The State Machine Framework}.    The sender() function returns the object that generated the signal. The   signalIndex() function returns the index of the signal. The arguments()   function returns the arguments of the signal.    \sa QSignalTransition */
end_comment
begin_comment
comment|/*!   \internal    Constructs a new SignalEvent object with the given \a sender, \a   signalIndex and \a arguments. */
end_comment
begin_constructor
DECL|function|SignalEvent
name|QStateMachine
operator|::
name|SignalEvent
operator|::
name|SignalEvent
parameter_list|(
name|QObject
modifier|*
name|sender
parameter_list|,
name|int
name|signalIndex
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|arguments
parameter_list|)
member_init_list|:
name|QEvent
argument_list|(
name|QEvent
operator|::
name|StateMachineSignal
argument_list|)
member_init_list|,
name|m_sender
argument_list|(
name|sender
argument_list|)
member_init_list|,
name|m_signalIndex
argument_list|(
name|signalIndex
argument_list|)
member_init_list|,
name|m_arguments
argument_list|(
name|arguments
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Destroys this SignalEvent. */
end_comment
begin_destructor
DECL|function|~SignalEvent
name|QStateMachine
operator|::
name|SignalEvent
operator|::
name|~
name|SignalEvent
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!   \fn QStateMachine::SignalEvent::sender() const    Returns the object that emitted the signal.    \sa QObject::sender() */
end_comment
begin_comment
comment|/*!   \fn QStateMachine::SignalEvent::signalIndex() const    Returns the index of the signal.    \sa QMetaObject::indexOfSignal(), QMetaObject::method() */
end_comment
begin_comment
comment|/*!   \fn QStateMachine::SignalEvent::arguments() const    Returns the arguments of the signal. */
end_comment
begin_comment
comment|/*!   \class QStateMachine::WrappedEvent   \inmodule QtCore    \brief The WrappedEvent class inherits QEvent and holds a clone of an event associated with a QObject.    \since 4.6   \ingroup statemachine    A wrapped event is generated by a QStateMachine in response to a Qt   event. The QEventTransition class provides a transition associated with a   such an event. QStateMachine::WrappedEvent is part of \l{The State Machine   Framework}.    The object() function returns the object that generated the event. The   event() function returns a clone of the original event.    \sa QEventTransition */
end_comment
begin_comment
comment|/*!   \internal    Constructs a new WrappedEvent object with the given \a object   and \a event.    The WrappedEvent object takes ownership of \a event. */
end_comment
begin_constructor
DECL|function|WrappedEvent
name|QStateMachine
operator|::
name|WrappedEvent
operator|::
name|WrappedEvent
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
member_init_list|:
name|QEvent
argument_list|(
name|QEvent
operator|::
name|StateMachineWrapped
argument_list|)
member_init_list|,
name|m_object
argument_list|(
name|object
argument_list|)
member_init_list|,
name|m_event
argument_list|(
name|event
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Destroys this WrappedEvent. */
end_comment
begin_destructor
DECL|function|~WrappedEvent
name|QStateMachine
operator|::
name|WrappedEvent
operator|::
name|~
name|WrappedEvent
parameter_list|()
block|{
operator|delete
name|m_event
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   \fn QStateMachine::WrappedEvent::object() const    Returns the object that the event is associated with. */
end_comment
begin_comment
comment|/*!   \fn QStateMachine::WrappedEvent::event() const    Returns a clone of the original event. */
end_comment
begin_comment
comment|/*!   \fn QStateMachine::runningChanged(bool running)   \since 5.4    This signal is emitted when the running property is changed with \a running as argument.    \sa QStateMachine::running */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"qstatemachine.moc"
end_include
begin_include
include|#
directive|include
file|"moc_qstatemachine.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_STATEMACHINE
end_comment
end_unit
