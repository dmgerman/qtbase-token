begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qitemselectionmodel.h"
end_include
begin_include
include|#
directive|include
file|<private/qitemselectionmodel_p.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ITEMVIEWS
end_ifndef
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QItemSelectionRange     \inmodule QtCore      \brief The QItemSelectionRange class manages information about a     range of selected items in a model.      \ingroup model-view      A QItemSelectionRange contains information about a range of     selected items in a model. A range of items is a contiguous array     of model items, extending to cover a number of adjacent rows and     columns with a common parent item; this can be visualized as a     two-dimensional block of cells in a table. A selection range has a     top(), left() a bottom(), right() and a parent().      The QItemSelectionRange class is one of the \l{Model/View Classes}     and is part of Qt's \l{Model/View Programming}{model/view framework}.      The model items contained in the selection range can be obtained     using the indexes() function. Use QItemSelectionModel::selectedIndexes()     to get a list of all selected items for a view.      You can determine whether a given model item lies within a     particular range by using the contains() function. Ranges can also     be compared using the overloaded operators for equality and     inequality, and the intersects() function allows you to determine     whether two ranges overlap.      \sa {Model/View Programming}, QAbstractItemModel, QItemSelection,         QItemSelectionModel */
comment|/*!     \fn QItemSelectionRange::QItemSelectionRange()      Constructs an empty selection range. */
comment|/*!     \fn QItemSelectionRange::QItemSelectionRange(const QItemSelectionRange&other)      Copy constructor. Constructs a new selection range with the same contents     as the \a other range given.  */
comment|/*!     \fn QItemSelectionRange::QItemSelectionRange(const QModelIndex&topLeft, const QModelIndex&bottomRight)      Constructs a new selection range containing only the index specified     by the \a topLeft and the index \a bottomRight.  */
comment|/*!     \fn QItemSelectionRange::QItemSelectionRange(const QModelIndex&index)      Constructs a new selection range containing only the model item specified     by the model index \a index. */
comment|/*!     \fn int QItemSelectionRange::top() const      Returns the row index corresponding to the uppermost selected row in the     selection range.  */
comment|/*!     \fn int QItemSelectionRange::left() const      Returns the column index corresponding to the leftmost selected column in the     selection range. */
comment|/*!     \fn int QItemSelectionRange::bottom() const      Returns the row index corresponding to the lowermost selected row in the     selection range.  */
comment|/*!     \fn int QItemSelectionRange::right() const      Returns the column index corresponding to the rightmost selected column in     the selection range.  */
comment|/*!     \fn int QItemSelectionRange::width() const      Returns the number of selected columns in the selection range.  */
comment|/*!     \fn int QItemSelectionRange::height() const      Returns the number of selected rows in the selection range.  */
comment|/*!     \fn const QAbstractItemModel *QItemSelectionRange::model() const      Returns the model that the items in the selection range belong to. */
comment|/*!     \fn QModelIndex QItemSelectionRange::topLeft() const      Returns the index for the item located at the top-left corner of     the selection range.      \sa top(), left(), bottomRight() */
comment|/*!     \fn QModelIndex QItemSelectionRange::bottomRight() const      Returns the index for the item located at the bottom-right corner     of the selection range.      \sa bottom(), right(), topLeft() */
comment|/*!     \fn QModelIndex QItemSelectionRange::parent() const      Returns the parent model item index of the items in the selection range.  */
comment|/*!     \fn bool QItemSelectionRange::contains(const QModelIndex&index) const      Returns true if the model item specified by the \a index lies within the     range of selected items; otherwise returns false. */
comment|/*!     \fn bool QItemSelectionRange::contains(int row, int column,                                            const QModelIndex&parentIndex) const     \overload      Returns true if the model item specified by (\a row, \a column)     and with \a parentIndex as the parent item lies within the range     of selected items; otherwise returns false. */
comment|/*!     \fn bool QItemSelectionRange::intersects(const QItemSelectionRange&other) const      Returns true if this selection range intersects (overlaps with) the \a other     range given; otherwise returns false.  */
DECL|function|intersects
name|bool
name|QItemSelectionRange
operator|::
name|intersects
parameter_list|(
specifier|const
name|QItemSelectionRange
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|isValid
argument_list|()
operator|&&
name|other
operator|.
name|isValid
argument_list|()
operator|&&
name|parent
argument_list|()
operator|==
name|other
operator|.
name|parent
argument_list|()
operator|&&
name|model
argument_list|()
operator|==
name|other
operator|.
name|model
argument_list|()
operator|&&
operator|(
operator|(
name|top
argument_list|()
operator|<=
name|other
operator|.
name|top
argument_list|()
operator|&&
name|bottom
argument_list|()
operator|>=
name|other
operator|.
name|top
argument_list|()
operator|)
operator|||
operator|(
name|top
argument_list|()
operator|>=
name|other
operator|.
name|top
argument_list|()
operator|&&
name|top
argument_list|()
operator|<=
name|other
operator|.
name|bottom
argument_list|()
operator|)
operator|)
operator|&&
operator|(
operator|(
name|left
argument_list|()
operator|<=
name|other
operator|.
name|left
argument_list|()
operator|&&
name|right
argument_list|()
operator|>=
name|other
operator|.
name|left
argument_list|()
operator|)
operator|||
operator|(
name|left
argument_list|()
operator|>=
name|other
operator|.
name|left
argument_list|()
operator|&&
name|left
argument_list|()
operator|<=
name|other
operator|.
name|right
argument_list|()
operator|)
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QItemSelectionRange QItemSelectionRange::intersect(const QItemSelectionRange&other) const     \obsolete      Use intersected(\a other) instead. */
end_comment
begin_comment
comment|/*!     \fn QItemSelectionRange QItemSelectionRange::intersected(const QItemSelectionRange&other) const     \since 4.2      Returns a new selection range containing only the items that are found in     both the selection range and the \a other selection range. */
end_comment
begin_function
DECL|function|intersected
name|QItemSelectionRange
name|QItemSelectionRange
operator|::
name|intersected
parameter_list|(
specifier|const
name|QItemSelectionRange
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|model
argument_list|()
operator|==
name|other
operator|.
name|model
argument_list|()
operator|&&
name|parent
argument_list|()
operator|==
name|other
operator|.
name|parent
argument_list|()
condition|)
block|{
name|QModelIndex
name|topLeft
init|=
name|model
argument_list|()
operator|->
name|index
argument_list|(
name|qMax
argument_list|(
name|top
argument_list|()
argument_list|,
name|other
operator|.
name|top
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|left
argument_list|()
argument_list|,
name|other
operator|.
name|left
argument_list|()
argument_list|)
argument_list|,
name|other
operator|.
name|parent
argument_list|()
argument_list|)
decl_stmt|;
name|QModelIndex
name|bottomRight
init|=
name|model
argument_list|()
operator|->
name|index
argument_list|(
name|qMin
argument_list|(
name|bottom
argument_list|()
argument_list|,
name|other
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|right
argument_list|()
argument_list|,
name|other
operator|.
name|right
argument_list|()
argument_list|)
argument_list|,
name|other
operator|.
name|parent
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|QItemSelectionRange
argument_list|(
name|topLeft
argument_list|,
name|bottomRight
argument_list|)
return|;
block|}
return|return
name|QItemSelectionRange
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QItemSelectionRange::operator==(const QItemSelectionRange&other) const      Returns true if the selection range is exactly the same as the \a other     range given; otherwise returns false.  */
end_comment
begin_comment
comment|/*!     \fn bool QItemSelectionRange::operator!=(const QItemSelectionRange&other) const      Returns true if the selection range differs from the \a other range given;     otherwise returns false.  */
end_comment
begin_comment
comment|/*!     \fn bool QItemSelectionRange::operator<(const QItemSelectionRange&other) const      Returns true if the selection range is less than the \a other     range given; otherwise returns false.      The less than calculation is not directly useful to developers - the way that ranges     with different parents compare is not defined. This operator only exists so that the     class can be used with QMap.  */
end_comment
begin_comment
comment|/*!     \fn bool QItemSelectionRange::isValid() const      Returns true if the selection range is valid; otherwise returns false.  */
end_comment
begin_comment
comment|/*   \internal    utility function for getting the indexes from a range   it avoid concatenating list and works on one  */
end_comment
begin_function
template|template
parameter_list|<
name|typename
name|ModelIndexContainer
parameter_list|>
DECL|function|indexesFromRange
specifier|static
name|void
name|indexesFromRange
parameter_list|(
specifier|const
name|QItemSelectionRange
modifier|&
name|range
parameter_list|,
name|ModelIndexContainer
modifier|&
name|result
parameter_list|)
block|{
if|if
condition|(
name|range
operator|.
name|isValid
argument_list|()
operator|&&
name|range
operator|.
name|model
argument_list|()
condition|)
block|{
specifier|const
name|QModelIndex
name|topLeft
init|=
name|range
operator|.
name|topLeft
argument_list|()
decl_stmt|;
specifier|const
name|int
name|bottom
init|=
name|range
operator|.
name|bottom
argument_list|()
decl_stmt|;
specifier|const
name|int
name|right
init|=
name|range
operator|.
name|right
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|row
init|=
name|topLeft
operator|.
name|row
argument_list|()
init|;
name|row
operator|<=
name|bottom
condition|;
operator|++
name|row
control|)
block|{
specifier|const
name|QModelIndex
name|columnLeader
init|=
name|topLeft
operator|.
name|sibling
argument_list|(
name|row
argument_list|,
name|topLeft
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|column
init|=
name|topLeft
operator|.
name|column
argument_list|()
init|;
name|column
operator|<=
name|right
condition|;
operator|++
name|column
control|)
block|{
name|QModelIndex
name|index
init|=
name|columnLeader
operator|.
name|sibling
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|ItemFlags
name|flags
init|=
name|range
operator|.
name|model
argument_list|()
operator|->
name|flags
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsSelectable
operator|)
operator|&&
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsEnabled
operator|)
condition|)
name|result
operator|.
name|push_back
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns true if the selection range contains no selectable item     \since 4.7 */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QItemSelectionRange
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|model
argument_list|()
condition|)
return|return
literal|true
return|;
for|for
control|(
name|int
name|column
init|=
name|left
argument_list|()
init|;
name|column
operator|<=
name|right
argument_list|()
condition|;
operator|++
name|column
control|)
block|{
for|for
control|(
name|int
name|row
init|=
name|top
argument_list|()
init|;
name|row
operator|<=
name|bottom
argument_list|()
condition|;
operator|++
name|row
control|)
block|{
name|QModelIndex
name|index
init|=
name|model
argument_list|()
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|parent
argument_list|()
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|ItemFlags
name|flags
init|=
name|model
argument_list|()
operator|->
name|flags
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsSelectable
operator|)
operator|&&
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsEnabled
operator|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the list of model index items stored in the selection. */
end_comment
begin_function
DECL|function|indexes
name|QModelIndexList
name|QItemSelectionRange
operator|::
name|indexes
parameter_list|()
specifier|const
block|{
name|QModelIndexList
name|result
decl_stmt|;
name|indexesFromRange
argument_list|(
operator|*
name|this
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \class QItemSelection     \inmodule QtCore      \brief The QItemSelection class manages information about selected items in a model.      \ingroup model-view      A QItemSelection describes the items in a model that have been     selected by the user. A QItemSelection is basically a list of     selection ranges, see QItemSelectionRange. It provides functions for     creating and manipulating selections, and selecting a range of items     from a model.      The QItemSelection class is one of the \l{Model/View Classes}     and is part of Qt's \l{Model/View Programming}{model/view framework}.      An item selection can be constructed and initialized to contain a     range of items from an existing model. The following example constructs     a selection that contains a range of items from the given \c model,     beginning at the \c topLeft, and ending at the \c bottomRight.      \snippet code/src_gui_itemviews_qitemselectionmodel.cpp 0      An empty item selection can be constructed, and later populated as     required. So, if the model is going to be unavailable when we construct     the item selection, we can rewrite the above code in the following way:      \snippet code/src_gui_itemviews_qitemselectionmodel.cpp 1      QItemSelection saves memory, and avoids unnecessary work, by working with     selection ranges rather than recording the model item index for each     item in the selection. Generally, an instance of this class will contain     a list of non-overlapping selection ranges.      Use merge() to merge one item selection into another without making     overlapping ranges. Use split() to split one selection range into     smaller ranges based on a another selection range.      \sa {Model/View Programming}, QItemSelectionModel */
end_comment
begin_comment
comment|/*!     \fn QItemSelection::QItemSelection()      Constructs an empty selection. */
end_comment
begin_comment
comment|/*!     Constructs an item selection that extends from the top-left model item,     specified by the \a topLeft index, to the bottom-right item, specified     by \a bottomRight. */
end_comment
begin_constructor
DECL|function|QItemSelection
name|QItemSelection
operator|::
name|QItemSelection
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|bottomRight
parameter_list|)
block|{
name|select
argument_list|(
name|topLeft
argument_list|,
name|bottomRight
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Adds the items in the range that extends from the top-left model     item, specified by the \a topLeft index, to the bottom-right item,     specified by \a bottomRight to the list.      \note \a topLeft and \a bottomRight must have the same parent. */
end_comment
begin_function
DECL|function|select
name|void
name|QItemSelection
operator|::
name|select
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|bottomRight
parameter_list|)
block|{
if|if
condition|(
operator|!
name|topLeft
operator|.
name|isValid
argument_list|()
operator|||
operator|!
name|bottomRight
operator|.
name|isValid
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|(
name|topLeft
operator|.
name|model
argument_list|()
operator|!=
name|bottomRight
operator|.
name|model
argument_list|()
operator|)
operator|||
name|topLeft
operator|.
name|parent
argument_list|()
operator|!=
name|bottomRight
operator|.
name|parent
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"Can't select indexes from different model or with different parents"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|topLeft
operator|.
name|row
argument_list|()
operator|>
name|bottomRight
operator|.
name|row
argument_list|()
operator|||
name|topLeft
operator|.
name|column
argument_list|()
operator|>
name|bottomRight
operator|.
name|column
argument_list|()
condition|)
block|{
name|int
name|top
init|=
name|qMin
argument_list|(
name|topLeft
operator|.
name|row
argument_list|()
argument_list|,
name|bottomRight
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|bottom
init|=
name|qMax
argument_list|(
name|topLeft
operator|.
name|row
argument_list|()
argument_list|,
name|bottomRight
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|left
init|=
name|qMin
argument_list|(
name|topLeft
operator|.
name|column
argument_list|()
argument_list|,
name|bottomRight
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|right
init|=
name|qMax
argument_list|(
name|topLeft
operator|.
name|column
argument_list|()
argument_list|,
name|bottomRight
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
name|QModelIndex
name|tl
init|=
name|topLeft
operator|.
name|sibling
argument_list|(
name|top
argument_list|,
name|left
argument_list|)
decl_stmt|;
name|QModelIndex
name|br
init|=
name|bottomRight
operator|.
name|sibling
argument_list|(
name|bottom
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|topLeft
argument_list|,
name|bottomRight
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the selection contains the given \a index; otherwise     returns false. */
end_comment
begin_function
DECL|function|contains
name|bool
name|QItemSelection
operator|::
name|contains
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|index
operator|.
name|flags
argument_list|()
operator|&
name|Qt
operator|::
name|ItemIsSelectable
condition|)
block|{
name|QList
argument_list|<
name|QItemSelectionRange
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|begin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|contains
argument_list|(
name|index
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of model indexes that correspond to the selected items. */
end_comment
begin_function
DECL|function|indexes
name|QModelIndexList
name|QItemSelection
operator|::
name|indexes
parameter_list|()
specifier|const
block|{
name|QModelIndexList
name|result
decl_stmt|;
name|QList
argument_list|<
name|QItemSelectionRange
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|begin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
name|indexesFromRange
argument_list|(
operator|*
name|it
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|qSelectionPersistentindexes
specifier|static
name|QVector
argument_list|<
name|QPersistentModelIndex
argument_list|>
name|qSelectionPersistentindexes
parameter_list|(
specifier|const
name|QItemSelection
modifier|&
name|sel
parameter_list|)
block|{
name|QVector
argument_list|<
name|QPersistentModelIndex
argument_list|>
name|result
decl_stmt|;
name|QList
argument_list|<
name|QItemSelectionRange
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|sel
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|sel
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|indexesFromRange
argument_list|(
operator|*
name|it
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Merges the \a other selection with this QItemSelection using the     \a command given. This method guarantees that no ranges are overlapping.      Note that only QItemSelectionModel::Select,     QItemSelectionModel::Deselect, and QItemSelectionModel::Toggle are     supported.      \sa split() */
end_comment
begin_function
DECL|function|merge
name|void
name|QItemSelection
operator|::
name|merge
parameter_list|(
specifier|const
name|QItemSelection
modifier|&
name|other
parameter_list|,
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|command
parameter_list|)
block|{
if|if
condition|(
name|other
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
operator|(
name|command
operator|&
name|QItemSelectionModel
operator|::
name|Select
operator|||
name|command
operator|&
name|QItemSelectionModel
operator|::
name|Deselect
operator|||
name|command
operator|&
name|QItemSelectionModel
operator|::
name|Toggle
operator|)
condition|)
return|return;
name|QItemSelection
name|newSelection
init|=
name|other
decl_stmt|;
comment|// Collect intersections
name|QItemSelection
name|intersections
decl_stmt|;
name|QItemSelection
operator|::
name|iterator
name|it
init|=
name|newSelection
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|newSelection
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|it
operator|)
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|it
operator|=
name|newSelection
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|count
argument_list|()
condition|;
operator|++
name|t
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|intersects
argument_list|(
name|at
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|intersections
operator|.
name|append
argument_list|(
name|at
argument_list|(
name|t
argument_list|)
operator|.
name|intersected
argument_list|(
operator|*
name|it
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|it
expr_stmt|;
block|}
comment|//  Split the old (and new) ranges using the intersections
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|intersections
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// for each intersection
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|count
argument_list|()
condition|;
control|)
block|{
comment|// splitt each old range
if|if
condition|(
name|at
argument_list|(
name|t
argument_list|)
operator|.
name|intersects
argument_list|(
name|intersections
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|split
argument_list|(
name|at
argument_list|(
name|t
argument_list|)
argument_list|,
name|intersections
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|removeAt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|t
expr_stmt|;
block|}
block|}
comment|// only split newSelection if Toggle is specified
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
operator|(
name|command
operator|&
name|QItemSelectionModel
operator|::
name|Toggle
operator|)
operator|&&
name|n
operator|<
name|newSelection
operator|.
name|count
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|newSelection
operator|.
name|at
argument_list|(
name|n
argument_list|)
operator|.
name|intersects
argument_list|(
name|intersections
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|split
argument_list|(
name|newSelection
operator|.
name|at
argument_list|(
name|n
argument_list|)
argument_list|,
name|intersections
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|newSelection
argument_list|)
expr_stmt|;
name|newSelection
operator|.
name|removeAt
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|n
expr_stmt|;
block|}
block|}
block|}
comment|// do not add newSelection for Deselect
if|if
condition|(
operator|!
operator|(
name|command
operator|&
name|QItemSelectionModel
operator|::
name|Deselect
operator|)
condition|)
name|operator
name|+=
parameter_list|(
name|newSelection
parameter_list|)
function_decl|;
block|}
end_function
begin_comment
comment|/*!     Splits the selection \a range using the selection \a other range.     Removes all items in \a other from \a range and puts the result in \a result.     This can be compared with the semantics of the \e subtract operation of a set.     \sa merge() */
end_comment
begin_function
DECL|function|split
name|void
name|QItemSelection
operator|::
name|split
parameter_list|(
specifier|const
name|QItemSelectionRange
modifier|&
name|range
parameter_list|,
specifier|const
name|QItemSelectionRange
modifier|&
name|other
parameter_list|,
name|QItemSelection
modifier|*
name|result
parameter_list|)
block|{
if|if
condition|(
name|range
operator|.
name|parent
argument_list|()
operator|!=
name|other
operator|.
name|parent
argument_list|()
operator|||
name|range
operator|.
name|model
argument_list|()
operator|!=
name|other
operator|.
name|model
argument_list|()
condition|)
return|return;
name|QModelIndex
name|parent
init|=
name|other
operator|.
name|parent
argument_list|()
decl_stmt|;
name|int
name|top
init|=
name|range
operator|.
name|top
argument_list|()
decl_stmt|;
name|int
name|left
init|=
name|range
operator|.
name|left
argument_list|()
decl_stmt|;
name|int
name|bottom
init|=
name|range
operator|.
name|bottom
argument_list|()
decl_stmt|;
name|int
name|right
init|=
name|range
operator|.
name|right
argument_list|()
decl_stmt|;
name|int
name|other_top
init|=
name|other
operator|.
name|top
argument_list|()
decl_stmt|;
name|int
name|other_left
init|=
name|other
operator|.
name|left
argument_list|()
decl_stmt|;
name|int
name|other_bottom
init|=
name|other
operator|.
name|bottom
argument_list|()
decl_stmt|;
name|int
name|other_right
init|=
name|other
operator|.
name|right
argument_list|()
decl_stmt|;
specifier|const
name|QAbstractItemModel
modifier|*
name|model
init|=
name|range
operator|.
name|model
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|model
argument_list|)
expr_stmt|;
if|if
condition|(
name|other_top
operator|>
name|top
condition|)
block|{
name|QModelIndex
name|tl
init|=
name|model
operator|->
name|index
argument_list|(
name|top
argument_list|,
name|left
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|QModelIndex
name|br
init|=
name|model
operator|->
name|index
argument_list|(
name|other_top
operator|-
literal|1
argument_list|,
name|right
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|result
operator|->
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
argument_list|)
expr_stmt|;
name|top
operator|=
name|other_top
expr_stmt|;
block|}
if|if
condition|(
name|other_bottom
operator|<
name|bottom
condition|)
block|{
name|QModelIndex
name|tl
init|=
name|model
operator|->
name|index
argument_list|(
name|other_bottom
operator|+
literal|1
argument_list|,
name|left
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|QModelIndex
name|br
init|=
name|model
operator|->
name|index
argument_list|(
name|bottom
argument_list|,
name|right
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|result
operator|->
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
argument_list|)
expr_stmt|;
name|bottom
operator|=
name|other_bottom
expr_stmt|;
block|}
if|if
condition|(
name|other_left
operator|>
name|left
condition|)
block|{
name|QModelIndex
name|tl
init|=
name|model
operator|->
name|index
argument_list|(
name|top
argument_list|,
name|left
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|QModelIndex
name|br
init|=
name|model
operator|->
name|index
argument_list|(
name|bottom
argument_list|,
name|other_left
operator|-
literal|1
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|result
operator|->
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
argument_list|)
expr_stmt|;
name|left
operator|=
name|other_left
expr_stmt|;
block|}
if|if
condition|(
name|other_right
operator|<
name|right
condition|)
block|{
name|QModelIndex
name|tl
init|=
name|model
operator|->
name|index
argument_list|(
name|top
argument_list|,
name|other_right
operator|+
literal|1
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|QModelIndex
name|br
init|=
name|model
operator|->
name|index
argument_list|(
name|bottom
argument_list|,
name|right
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|result
operator|->
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
argument_list|)
expr_stmt|;
name|right
operator|=
name|other_right
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|initModel
name|void
name|QItemSelectionModelPrivate
operator|::
name|initModel
parameter_list|(
name|QAbstractItemModel
modifier|*
name|model
parameter_list|)
block|{
name|this
operator|->
name|model
operator|=
name|model
expr_stmt|;
if|if
condition|(
name|model
condition|)
block|{
name|Q_Q
argument_list|(
name|QItemSelectionModel
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_rowsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_columnsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsAboutToBeInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_rowsAboutToBeInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsAboutToBeInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_columnsAboutToBeInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsAboutToBeMoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|QModelIndex
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_layoutAboutToBeChanged
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsAboutToBeMoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|QModelIndex
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_layoutAboutToBeChanged
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsMoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|QModelIndex
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_layoutChanged
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsMoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|QModelIndex
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_layoutChanged
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|layoutAboutToBeChanged
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_layoutAboutToBeChanged
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|layoutChanged
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_layoutChanged
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      returns a QItemSelection where all ranges have been expanded to:     Rows: left: 0 and right: columnCount()-1     Columns: top: 0 and bottom: rowCount()-1 */
end_comment
begin_function
DECL|function|expandSelection
name|QItemSelection
name|QItemSelectionModelPrivate
operator|::
name|expandSelection
parameter_list|(
specifier|const
name|QItemSelection
modifier|&
name|selection
parameter_list|,
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|command
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|selection
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
operator|(
operator|(
name|command
operator|&
name|QItemSelectionModel
operator|::
name|Rows
operator|)
operator|||
operator|(
name|command
operator|&
name|QItemSelectionModel
operator|::
name|Columns
operator|)
operator|)
condition|)
return|return
name|selection
return|;
name|QItemSelection
name|expanded
decl_stmt|;
if|if
condition|(
name|command
operator|&
name|QItemSelectionModel
operator|::
name|Rows
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selection
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QModelIndex
name|parent
init|=
name|selection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|parent
argument_list|()
decl_stmt|;
name|int
name|colCount
init|=
name|model
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|QModelIndex
name|tl
init|=
name|model
operator|->
name|index
argument_list|(
name|selection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|top
argument_list|()
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|QModelIndex
name|br
init|=
name|model
operator|->
name|index
argument_list|(
name|selection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|bottom
argument_list|()
argument_list|,
name|colCount
operator|-
literal|1
argument_list|,
name|parent
argument_list|)
decl_stmt|;
comment|//we need to merge because the same row could have already been inserted
name|expanded
operator|.
name|merge
argument_list|(
name|QItemSelection
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
argument_list|,
name|QItemSelectionModel
operator|::
name|Select
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|command
operator|&
name|QItemSelectionModel
operator|::
name|Columns
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selection
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QModelIndex
name|parent
init|=
name|selection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|parent
argument_list|()
decl_stmt|;
name|int
name|rowCount
init|=
name|model
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|QModelIndex
name|tl
init|=
name|model
operator|->
name|index
argument_list|(
literal|0
argument_list|,
name|selection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|left
argument_list|()
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|QModelIndex
name|br
init|=
name|model
operator|->
name|index
argument_list|(
name|rowCount
operator|-
literal|1
argument_list|,
name|selection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|right
argument_list|()
argument_list|,
name|parent
argument_list|)
decl_stmt|;
comment|//we need to merge because the same column could have already been inserted
name|expanded
operator|.
name|merge
argument_list|(
name|QItemSelection
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
argument_list|,
name|QItemSelectionModel
operator|::
name|Select
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|expanded
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_rowsAboutToBeRemoved
name|void
name|QItemSelectionModelPrivate
operator|::
name|_q_rowsAboutToBeRemoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QItemSelectionModel
argument_list|)
expr_stmt|;
name|finalize
argument_list|()
expr_stmt|;
comment|// update current index
if|if
condition|(
name|currentIndex
operator|.
name|isValid
argument_list|()
operator|&&
name|parent
operator|==
name|currentIndex
operator|.
name|parent
argument_list|()
operator|&&
name|currentIndex
operator|.
name|row
argument_list|()
operator|>=
name|start
operator|&&
name|currentIndex
operator|.
name|row
argument_list|()
operator|<=
name|end
condition|)
block|{
name|QModelIndex
name|old
init|=
name|currentIndex
decl_stmt|;
if|if
condition|(
name|start
operator|>
literal|0
condition|)
comment|// there are rows left above the change
name|currentIndex
operator|=
name|model
operator|->
name|index
argument_list|(
name|start
operator|-
literal|1
argument_list|,
name|old
operator|.
name|column
argument_list|()
argument_list|,
name|parent
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|model
operator|&&
name|end
operator|<
name|model
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|-
literal|1
condition|)
comment|// there are rows left below the change
name|currentIndex
operator|=
name|model
operator|->
name|index
argument_list|(
name|end
operator|+
literal|1
argument_list|,
name|old
operator|.
name|column
argument_list|()
argument_list|,
name|parent
argument_list|)
expr_stmt|;
else|else
comment|// there are no rows left in the table
name|currentIndex
operator|=
name|QModelIndex
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|currentChanged
argument_list|(
name|currentIndex
argument_list|,
name|old
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|currentRowChanged
argument_list|(
name|currentIndex
argument_list|,
name|old
argument_list|)
emit|;
if|if
condition|(
name|currentIndex
operator|.
name|column
argument_list|()
operator|!=
name|old
operator|.
name|column
argument_list|()
condition|)
emit|emit
name|q
operator|->
name|currentColumnChanged
argument_list|(
name|currentIndex
argument_list|,
name|old
argument_list|)
emit|;
block|}
name|QItemSelection
name|deselected
decl_stmt|;
name|QItemSelection
name|newParts
decl_stmt|;
name|QItemSelection
operator|::
name|iterator
name|it
init|=
name|ranges
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|ranges
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|topLeft
argument_list|()
operator|.
name|parent
argument_list|()
operator|!=
name|parent
condition|)
block|{
comment|// Check parents until reaching root or contained in range
name|QModelIndex
name|itParent
init|=
name|it
operator|->
name|topLeft
argument_list|()
operator|.
name|parent
argument_list|()
decl_stmt|;
while|while
condition|(
name|itParent
operator|.
name|isValid
argument_list|()
operator|&&
name|itParent
operator|.
name|parent
argument_list|()
operator|!=
name|parent
condition|)
name|itParent
operator|=
name|itParent
operator|.
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|itParent
operator|.
name|isValid
argument_list|()
operator|&&
name|start
operator|<=
name|itParent
operator|.
name|row
argument_list|()
operator|&&
name|itParent
operator|.
name|row
argument_list|()
operator|<=
name|end
condition|)
block|{
name|deselected
operator|.
name|append
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
name|it
operator|=
name|ranges
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|it
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|start
operator|<=
name|it
operator|->
name|bottom
argument_list|()
operator|&&
name|it
operator|->
name|bottom
argument_list|()
operator|<=
name|end
comment|// Full inclusion
operator|&&
name|start
operator|<=
name|it
operator|->
name|top
argument_list|()
operator|&&
name|it
operator|->
name|top
argument_list|()
operator|<=
name|end
condition|)
block|{
name|deselected
operator|.
name|append
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
name|it
operator|=
name|ranges
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|start
operator|<=
name|it
operator|->
name|top
argument_list|()
operator|&&
name|it
operator|->
name|top
argument_list|()
operator|<=
name|end
condition|)
block|{
comment|// Top intersection
name|deselected
operator|.
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|it
operator|->
name|topLeft
argument_list|()
argument_list|,
name|model
operator|->
name|index
argument_list|(
name|end
argument_list|,
name|it
operator|->
name|left
argument_list|()
argument_list|,
name|it
operator|->
name|parent
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|it
operator|=
name|QItemSelectionRange
argument_list|(
name|model
operator|->
name|index
argument_list|(
name|end
operator|+
literal|1
argument_list|,
name|it
operator|->
name|left
argument_list|()
argument_list|,
name|it
operator|->
name|parent
argument_list|()
argument_list|)
argument_list|,
name|it
operator|->
name|bottomRight
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|start
operator|<=
name|it
operator|->
name|bottom
argument_list|()
operator|&&
name|it
operator|->
name|bottom
argument_list|()
operator|<=
name|end
condition|)
block|{
comment|// Bottom intersection
name|deselected
operator|.
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|model
operator|->
name|index
argument_list|(
name|start
argument_list|,
name|it
operator|->
name|right
argument_list|()
argument_list|,
name|it
operator|->
name|parent
argument_list|()
argument_list|)
argument_list|,
name|it
operator|->
name|bottomRight
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|it
operator|=
name|QItemSelectionRange
argument_list|(
name|it
operator|->
name|topLeft
argument_list|()
argument_list|,
name|model
operator|->
name|index
argument_list|(
name|start
operator|-
literal|1
argument_list|,
name|it
operator|->
name|right
argument_list|()
argument_list|,
name|it
operator|->
name|parent
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|it
operator|->
name|top
argument_list|()
operator|<
name|start
operator|&&
name|end
operator|<
name|it
operator|->
name|bottom
argument_list|()
condition|)
block|{
comment|// Middle intersection
comment|// If the parent contains (1, 2, 3, 4, 5, 6, 7, 8) and [3, 4, 5, 6] is selected,
comment|// and [4, 5] is removed, we need to split [3, 4, 5, 6] into [3], [4, 5] and [6].
comment|// [4, 5] is appended to deselected, and [3] and [6] remain part of the selection
comment|// in ranges.
specifier|const
name|QItemSelectionRange
name|removedRange
argument_list|(
name|model
operator|->
name|index
argument_list|(
name|start
argument_list|,
name|it
operator|->
name|right
argument_list|()
argument_list|,
name|it
operator|->
name|parent
argument_list|()
argument_list|)
argument_list|,
name|model
operator|->
name|index
argument_list|(
name|end
argument_list|,
name|it
operator|->
name|left
argument_list|()
argument_list|,
name|it
operator|->
name|parent
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|deselected
operator|.
name|append
argument_list|(
name|removedRange
argument_list|)
expr_stmt|;
name|QItemSelection
operator|::
name|split
argument_list|(
operator|*
name|it
argument_list|,
name|removedRange
argument_list|,
operator|&
name|newParts
argument_list|)
expr_stmt|;
name|it
operator|=
name|ranges
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
else|else
operator|++
name|it
expr_stmt|;
block|}
name|ranges
operator|.
name|append
argument_list|(
name|newParts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|deselected
operator|.
name|isEmpty
argument_list|()
condition|)
emit|emit
name|q
operator|->
name|selectionChanged
argument_list|(
name|QItemSelection
argument_list|()
argument_list|,
name|deselected
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_columnsAboutToBeRemoved
name|void
name|QItemSelectionModelPrivate
operator|::
name|_q_columnsAboutToBeRemoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QItemSelectionModel
argument_list|)
expr_stmt|;
comment|// update current index
if|if
condition|(
name|currentIndex
operator|.
name|isValid
argument_list|()
operator|&&
name|parent
operator|==
name|currentIndex
operator|.
name|parent
argument_list|()
operator|&&
name|currentIndex
operator|.
name|column
argument_list|()
operator|>=
name|start
operator|&&
name|currentIndex
operator|.
name|column
argument_list|()
operator|<=
name|end
condition|)
block|{
name|QModelIndex
name|old
init|=
name|currentIndex
decl_stmt|;
if|if
condition|(
name|start
operator|>
literal|0
condition|)
comment|// there are columns to the left of the change
name|currentIndex
operator|=
name|model
operator|->
name|index
argument_list|(
name|old
operator|.
name|row
argument_list|()
argument_list|,
name|start
operator|-
literal|1
argument_list|,
name|parent
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|model
operator|&&
name|end
operator|<
name|model
operator|->
name|columnCount
argument_list|()
operator|-
literal|1
condition|)
comment|// there are columns to the right of the change
name|currentIndex
operator|=
name|model
operator|->
name|index
argument_list|(
name|old
operator|.
name|row
argument_list|()
argument_list|,
name|end
operator|+
literal|1
argument_list|,
name|parent
argument_list|)
expr_stmt|;
else|else
comment|// there are no columns left in the table
name|currentIndex
operator|=
name|QModelIndex
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|currentChanged
argument_list|(
name|currentIndex
argument_list|,
name|old
argument_list|)
emit|;
if|if
condition|(
name|currentIndex
operator|.
name|row
argument_list|()
operator|!=
name|old
operator|.
name|row
argument_list|()
condition|)
emit|emit
name|q
operator|->
name|currentRowChanged
argument_list|(
name|currentIndex
argument_list|,
name|old
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|currentColumnChanged
argument_list|(
name|currentIndex
argument_list|,
name|old
argument_list|)
emit|;
block|}
comment|// update selections
name|QModelIndex
name|tl
init|=
name|model
operator|->
name|index
argument_list|(
literal|0
argument_list|,
name|start
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|QModelIndex
name|br
init|=
name|model
operator|->
name|index
argument_list|(
name|model
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|-
literal|1
argument_list|,
name|end
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|q
operator|->
name|select
argument_list|(
name|QItemSelection
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
argument_list|,
name|QItemSelectionModel
operator|::
name|Deselect
argument_list|)
expr_stmt|;
name|finalize
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Split selection ranges if columns are about to be inserted in the middle. */
end_comment
begin_function
DECL|function|_q_columnsAboutToBeInserted
name|void
name|QItemSelectionModelPrivate
operator|::
name|_q_columnsAboutToBeInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|finalize
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QItemSelectionRange
argument_list|>
name|split
decl_stmt|;
name|QList
argument_list|<
name|QItemSelectionRange
argument_list|>
operator|::
name|iterator
name|it
init|=
name|ranges
operator|.
name|begin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|ranges
operator|.
name|end
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
operator|*
name|it
operator|)
operator|.
name|parent
argument_list|()
operator|==
name|parent
operator|&&
operator|(
operator|*
name|it
operator|)
operator|.
name|left
argument_list|()
operator|<
name|start
operator|&&
operator|(
operator|*
name|it
operator|)
operator|.
name|right
argument_list|()
operator|>=
name|start
condition|)
block|{
name|QModelIndex
name|bottomMiddle
init|=
name|model
operator|->
name|index
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|bottom
argument_list|()
argument_list|,
name|start
operator|-
literal|1
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|parent
argument_list|()
argument_list|)
decl_stmt|;
name|QItemSelectionRange
name|left
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|topLeft
argument_list|()
argument_list|,
name|bottomMiddle
argument_list|)
decl_stmt|;
name|QModelIndex
name|topMiddle
init|=
name|model
operator|->
name|index
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|top
argument_list|()
argument_list|,
name|start
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|parent
argument_list|()
argument_list|)
decl_stmt|;
name|QItemSelectionRange
name|right
argument_list|(
name|topMiddle
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|bottomRight
argument_list|()
argument_list|)
decl_stmt|;
name|it
operator|=
name|ranges
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|split
operator|.
name|append
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|split
operator|.
name|append
argument_list|(
name|right
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|it
expr_stmt|;
block|}
block|}
name|ranges
operator|+=
name|split
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Split selection ranges if rows are about to be inserted in the middle. */
end_comment
begin_function
DECL|function|_q_rowsAboutToBeInserted
name|void
name|QItemSelectionModelPrivate
operator|::
name|_q_rowsAboutToBeInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|finalize
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QItemSelectionRange
argument_list|>
name|split
decl_stmt|;
name|QList
argument_list|<
name|QItemSelectionRange
argument_list|>
operator|::
name|iterator
name|it
init|=
name|ranges
operator|.
name|begin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|ranges
operator|.
name|end
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
operator|*
name|it
operator|)
operator|.
name|parent
argument_list|()
operator|==
name|parent
operator|&&
operator|(
operator|*
name|it
operator|)
operator|.
name|top
argument_list|()
operator|<
name|start
operator|&&
operator|(
operator|*
name|it
operator|)
operator|.
name|bottom
argument_list|()
operator|>=
name|start
condition|)
block|{
name|QModelIndex
name|middleRight
init|=
name|model
operator|->
name|index
argument_list|(
name|start
operator|-
literal|1
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|right
argument_list|()
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|parent
argument_list|()
argument_list|)
decl_stmt|;
name|QItemSelectionRange
name|top
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|topLeft
argument_list|()
argument_list|,
name|middleRight
argument_list|)
decl_stmt|;
name|QModelIndex
name|middleLeft
init|=
name|model
operator|->
name|index
argument_list|(
name|start
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|left
argument_list|()
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|parent
argument_list|()
argument_list|)
decl_stmt|;
name|QItemSelectionRange
name|bottom
argument_list|(
name|middleLeft
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|bottomRight
argument_list|()
argument_list|)
decl_stmt|;
name|it
operator|=
name|ranges
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|split
operator|.
name|append
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|split
operator|.
name|append
argument_list|(
name|bottom
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|it
expr_stmt|;
block|}
block|}
name|ranges
operator|+=
name|split
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Split selection into individual (persistent) indexes. This is done in     preparation for the layoutChanged() signal, where the indexes can be     merged again. */
end_comment
begin_function
DECL|function|_q_layoutAboutToBeChanged
name|void
name|QItemSelectionModelPrivate
operator|::
name|_q_layoutAboutToBeChanged
parameter_list|()
block|{
name|savedPersistentIndexes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|savedPersistentCurrentIndexes
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// optimization for when all indexes are selected
comment|// (only if there is lots of items (1000) because this is not entirely correct)
if|if
condition|(
name|ranges
operator|.
name|isEmpty
argument_list|()
operator|&&
name|currentSelection
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
name|QItemSelectionRange
name|range
init|=
name|currentSelection
operator|.
name|first
argument_list|()
decl_stmt|;
name|QModelIndex
name|parent
init|=
name|range
operator|.
name|parent
argument_list|()
decl_stmt|;
name|tableRowCount
operator|=
name|model
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|tableColCount
operator|=
name|model
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|tableRowCount
operator|*
name|tableColCount
operator|>
literal|1000
operator|&&
name|range
operator|.
name|top
argument_list|()
operator|==
literal|0
operator|&&
name|range
operator|.
name|left
argument_list|()
operator|==
literal|0
operator|&&
name|range
operator|.
name|bottom
argument_list|()
operator|==
name|tableRowCount
operator|-
literal|1
operator|&&
name|range
operator|.
name|right
argument_list|()
operator|==
name|tableColCount
operator|-
literal|1
condition|)
block|{
name|tableSelected
operator|=
literal|true
expr_stmt|;
name|tableParent
operator|=
name|parent
expr_stmt|;
return|return;
block|}
block|}
name|tableSelected
operator|=
literal|false
expr_stmt|;
name|savedPersistentIndexes
operator|=
name|qSelectionPersistentindexes
argument_list|(
name|ranges
argument_list|)
expr_stmt|;
name|savedPersistentCurrentIndexes
operator|=
name|qSelectionPersistentindexes
argument_list|(
name|currentSelection
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Merges \a indexes into an item selection made up of ranges.     Assumes that the indexes are sorted. */
end_comment
begin_function
DECL|function|mergeIndexes
specifier|static
name|QItemSelection
name|mergeIndexes
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|QPersistentModelIndex
argument_list|>
modifier|&
name|indexes
parameter_list|)
block|{
name|QItemSelection
name|colSpans
decl_stmt|;
comment|// merge columns
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|indexes
operator|.
name|count
argument_list|()
condition|)
block|{
specifier|const
name|QPersistentModelIndex
modifier|&
name|tl
init|=
name|indexes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tl
operator|.
name|isValid
argument_list|()
condition|)
block|{
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
name|QPersistentModelIndex
name|br
init|=
name|tl
decl_stmt|;
name|QModelIndex
name|brParent
init|=
name|br
operator|.
name|parent
argument_list|()
decl_stmt|;
name|int
name|brRow
init|=
name|br
operator|.
name|row
argument_list|()
decl_stmt|;
name|int
name|brColumn
init|=
name|br
operator|.
name|column
argument_list|()
decl_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|indexes
operator|.
name|count
argument_list|()
condition|)
block|{
specifier|const
name|QPersistentModelIndex
modifier|&
name|next
init|=
name|indexes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|next
operator|.
name|isValid
argument_list|()
condition|)
continue|continue;
specifier|const
name|QModelIndex
name|nextParent
init|=
name|next
operator|.
name|parent
argument_list|()
decl_stmt|;
specifier|const
name|int
name|nextRow
init|=
name|next
operator|.
name|row
argument_list|()
decl_stmt|;
specifier|const
name|int
name|nextColumn
init|=
name|next
operator|.
name|column
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|nextParent
operator|==
name|brParent
operator|)
operator|&&
operator|(
name|nextRow
operator|==
name|brRow
operator|)
operator|&&
operator|(
name|nextColumn
operator|==
name|brColumn
operator|+
literal|1
operator|)
condition|)
block|{
name|br
operator|=
name|next
expr_stmt|;
name|brParent
operator|=
name|nextParent
expr_stmt|;
name|brRow
operator|=
name|nextRow
expr_stmt|;
name|brColumn
operator|=
name|nextColumn
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|colSpans
operator|.
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// merge rows
name|QItemSelection
name|rowSpans
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|colSpans
operator|.
name|count
argument_list|()
condition|)
block|{
name|QModelIndex
name|tl
init|=
name|colSpans
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|QModelIndex
name|br
init|=
name|colSpans
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|bottomRight
argument_list|()
decl_stmt|;
name|QModelIndex
name|prevTl
init|=
name|tl
decl_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|colSpans
operator|.
name|count
argument_list|()
condition|)
block|{
name|QModelIndex
name|nextTl
init|=
name|colSpans
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|QModelIndex
name|nextBr
init|=
name|colSpans
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|bottomRight
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextTl
operator|.
name|parent
argument_list|()
operator|!=
name|tl
operator|.
name|parent
argument_list|()
condition|)
break|break;
comment|// we can't merge selection ranges from different parents
if|if
condition|(
operator|(
name|nextTl
operator|.
name|column
argument_list|()
operator|==
name|prevTl
operator|.
name|column
argument_list|()
operator|)
operator|&&
operator|(
name|nextBr
operator|.
name|column
argument_list|()
operator|==
name|br
operator|.
name|column
argument_list|()
operator|)
operator|&&
operator|(
name|nextTl
operator|.
name|row
argument_list|()
operator|==
name|prevTl
operator|.
name|row
argument_list|()
operator|+
literal|1
operator|)
operator|&&
operator|(
name|nextBr
operator|.
name|row
argument_list|()
operator|==
name|br
operator|.
name|row
argument_list|()
operator|+
literal|1
operator|)
condition|)
block|{
name|br
operator|=
name|nextBr
expr_stmt|;
name|prevTl
operator|=
name|nextTl
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|rowSpans
operator|.
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rowSpans
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Merge the selected indexes into selection ranges again. */
end_comment
begin_function
DECL|function|_q_layoutChanged
name|void
name|QItemSelectionModelPrivate
operator|::
name|_q_layoutChanged
parameter_list|()
block|{
comment|// special case for when all indexes are selected
if|if
condition|(
name|tableSelected
operator|&&
name|tableColCount
operator|==
name|model
operator|->
name|columnCount
argument_list|(
name|tableParent
argument_list|)
operator|&&
name|tableRowCount
operator|==
name|model
operator|->
name|rowCount
argument_list|(
name|tableParent
argument_list|)
condition|)
block|{
name|ranges
operator|.
name|clear
argument_list|()
expr_stmt|;
name|currentSelection
operator|.
name|clear
argument_list|()
expr_stmt|;
name|int
name|bottom
init|=
name|tableRowCount
operator|-
literal|1
decl_stmt|;
name|int
name|right
init|=
name|tableColCount
operator|-
literal|1
decl_stmt|;
name|QModelIndex
name|tl
init|=
name|model
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|tableParent
argument_list|)
decl_stmt|;
name|QModelIndex
name|br
init|=
name|model
operator|->
name|index
argument_list|(
name|bottom
argument_list|,
name|right
argument_list|,
name|tableParent
argument_list|)
decl_stmt|;
name|currentSelection
operator|<<
name|QItemSelectionRange
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|tableParent
operator|=
name|QModelIndex
argument_list|()
expr_stmt|;
name|tableSelected
operator|=
literal|false
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|savedPersistentCurrentIndexes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|savedPersistentIndexes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// either the selection was actually empty, or we
comment|// didn't get the layoutAboutToBeChanged() signal
return|return;
block|}
comment|// clear the "old" selection
name|ranges
operator|.
name|clear
argument_list|()
expr_stmt|;
name|currentSelection
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// sort the "new" selection, as preparation for merging
name|qStableSort
argument_list|(
name|savedPersistentIndexes
operator|.
name|begin
argument_list|()
argument_list|,
name|savedPersistentIndexes
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|qStableSort
argument_list|(
name|savedPersistentCurrentIndexes
operator|.
name|begin
argument_list|()
argument_list|,
name|savedPersistentCurrentIndexes
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// update the selection by merging the individual indexes
name|ranges
operator|=
name|mergeIndexes
argument_list|(
name|savedPersistentIndexes
argument_list|)
expr_stmt|;
name|currentSelection
operator|=
name|mergeIndexes
argument_list|(
name|savedPersistentCurrentIndexes
argument_list|)
expr_stmt|;
comment|// release the persistent indexes
name|savedPersistentIndexes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|savedPersistentCurrentIndexes
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QItemSelectionModel     \inmodule QtCore      \brief The QItemSelectionModel class keeps track of a view's selected items.      \ingroup model-view      A QItemSelectionModel keeps track of the selected items in a view, or     in several views onto the same model. It also keeps track of the     currently selected item in a view.      The QItemSelectionModel class is one of the \l{Model/View Classes}     and is part of Qt's \l{Model/View Programming}{model/view framework}.      The selected items are stored using ranges. Whenever you want to     modify the selected items use select() and provide either a     QItemSelection, or a QModelIndex and a QItemSelectionModel::SelectionFlag.      The QItemSelectionModel takes a two layer approach to selection     management, dealing with both selected items that have been committed     and items that are part of the current selection. The current     selected items are part of the current interactive selection (for     example with rubber-band selection or keyboard-shift selections).      To update the currently selected items, use the bitwise OR of     QItemSelectionModel::Current and any of the other SelectionFlags.     If you omit the QItemSelectionModel::Current command, a new current     selection will be created, and the previous one added to the whole     selection. All functions operate on both layers; for example,     selectedItems() will return items from both layers.      \sa {Model/View Programming}, QAbstractItemModel, {Chart Example} */
end_comment
begin_comment
comment|/*!     Constructs a selection model that operates on the specified item \a model. */
end_comment
begin_constructor
DECL|function|QItemSelectionModel
name|QItemSelectionModel
operator|::
name|QItemSelectionModel
parameter_list|(
name|QAbstractItemModel
modifier|*
name|model
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QItemSelectionModelPrivate
argument_list|,
name|model
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|initModel
argument_list|(
name|model
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a selection model that operates on the specified item \a model with \a parent. */
end_comment
begin_constructor
DECL|function|QItemSelectionModel
name|QItemSelectionModel
operator|::
name|QItemSelectionModel
parameter_list|(
name|QAbstractItemModel
modifier|*
name|model
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QItemSelectionModelPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|initModel
argument_list|(
name|model
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QItemSelectionModel
name|QItemSelectionModel
operator|::
name|QItemSelectionModel
parameter_list|(
name|QItemSelectionModelPrivate
modifier|&
name|dd
parameter_list|,
name|QAbstractItemModel
modifier|*
name|model
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
name|model
argument_list|)
block|{
name|dd
operator|.
name|initModel
argument_list|(
name|model
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the selection model. */
end_comment
begin_destructor
DECL|function|~QItemSelectionModel
name|QItemSelectionModel
operator|::
name|~
name|QItemSelectionModel
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Selects the model item \a index using the specified \a command, and emits     selectionChanged().      \sa QItemSelectionModel::SelectionFlags */
end_comment
begin_function
DECL|function|select
name|void
name|QItemSelectionModel
operator|::
name|select
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|command
parameter_list|)
block|{
name|QItemSelection
name|selection
argument_list|(
name|index
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|select
argument_list|(
name|selection
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QItemSelectionModel::currentChanged(const QModelIndex&current, const QModelIndex&previous)      This signal is emitted whenever the current item changes. The \a previous     model item index is replaced by the \a current index as the selection's     current item.      Note that this signal will not be emitted when the item model is reset.      \sa currentIndex(), setCurrentIndex(), selectionChanged() */
end_comment
begin_comment
comment|/*!     \fn void QItemSelectionModel::currentColumnChanged(const QModelIndex&current, const QModelIndex&previous)      This signal is emitted if the \a current item changes and its column is     different to the column of the \a previous current item.      Note that this signal will not be emitted when the item model is reset.      \sa currentChanged(), currentRowChanged(), currentIndex(), setCurrentIndex() */
end_comment
begin_comment
comment|/*!     \fn void QItemSelectionModel::currentRowChanged(const QModelIndex&current, const QModelIndex&previous)      This signal is emitted if the \a current item changes and its row is     different to the row of the \a previous current item.      Note that this signal will not be emitted when the item model is reset.      \sa currentChanged(), currentColumnChanged(), currentIndex(), setCurrentIndex() */
end_comment
begin_comment
comment|/*!     \fn void QItemSelectionModel::selectionChanged(const QItemSelection&selected, const QItemSelection&deselected)      This signal is emitted whenever the selection changes. The change in the     selection is represented as an item selection of \a deselected items and     an item selection of \a selected items.      Note the that the current index changes independently from the selection.     Also note that this signal will not be emitted when the item model is reset.      \sa select(), currentChanged() */
end_comment
begin_comment
comment|/*!     \enum QItemSelectionModel::SelectionFlag      This enum describes the way the selection model will be updated.      \value NoUpdate       No selection will be made.     \value Clear          The complete selection will be cleared.     \value Select         All specified indexes will be selected.     \value Deselect       All specified indexes will be deselected.     \value Toggle         All specified indexes will be selected or                           deselected depending on their current state.     \value Current        The current selection will be updated.     \value Rows           All indexes will be expanded to span rows.     \value Columns        All indexes will be expanded to span columns.     \value SelectCurrent  A combination of Select and Current, provided for                           convenience.     \value ToggleCurrent  A combination of Toggle and Current, provided for                           convenience.     \value ClearAndSelect A combination of Clear and Select, provided for                           convenience. */
end_comment
begin_comment
comment|/*!     Selects the item \a selection using the specified \a command, and emits     selectionChanged().      \sa QItemSelectionModel::SelectionFlag */
end_comment
begin_function
DECL|function|select
name|void
name|QItemSelectionModel
operator|::
name|select
parameter_list|(
specifier|const
name|QItemSelection
modifier|&
name|selection
parameter_list|,
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|command
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QItemSelectionModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|NoUpdate
condition|)
return|return;
comment|// store old selection
name|QItemSelection
name|sel
init|=
name|selection
decl_stmt|;
comment|// If d->ranges is non-empty when the source model is reset the persistent indexes
comment|// it contains will be invalid. We can't clear them in a modelReset slot because that might already
comment|// be too late if another model observer is connected to the same modelReset slot and is invoked first
comment|// it might call select() on this selection model before any such QItemSelectionModelPrivate::_q_modelReset() slot
comment|// is invoked, so it would not be cleared yet. We clear it invalid ranges in it here.
name|QItemSelection
operator|::
name|iterator
name|it
init|=
name|d
operator|->
name|ranges
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|ranges
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|it
operator|->
name|isValid
argument_list|()
condition|)
name|it
operator|=
name|d
operator|->
name|ranges
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
else|else
operator|++
name|it
expr_stmt|;
block|}
name|QItemSelection
name|old
init|=
name|d
operator|->
name|ranges
decl_stmt|;
name|old
operator|.
name|merge
argument_list|(
name|d
operator|->
name|currentSelection
argument_list|,
name|d
operator|->
name|currentCommand
argument_list|)
expr_stmt|;
comment|// expand selection according to SelectionBehavior
if|if
condition|(
name|command
operator|&
name|Rows
operator|||
name|command
operator|&
name|Columns
condition|)
name|sel
operator|=
name|d
operator|->
name|expandSelection
argument_list|(
name|sel
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|// clear ranges and currentSelection
if|if
condition|(
name|command
operator|&
name|Clear
condition|)
block|{
name|d
operator|->
name|ranges
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|currentSelection
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// merge and clear currentSelection if Current was not set (ie. start new currentSelection)
if|if
condition|(
operator|!
operator|(
name|command
operator|&
name|Current
operator|)
condition|)
name|d
operator|->
name|finalize
argument_list|()
expr_stmt|;
comment|// update currentSelection
if|if
condition|(
name|command
operator|&
name|Toggle
operator|||
name|command
operator|&
name|Select
operator|||
name|command
operator|&
name|Deselect
condition|)
block|{
name|d
operator|->
name|currentCommand
operator|=
name|command
expr_stmt|;
name|d
operator|->
name|currentSelection
operator|=
name|sel
expr_stmt|;
block|}
comment|// generate new selection, compare with old and emit selectionChanged()
name|QItemSelection
name|newSelection
init|=
name|d
operator|->
name|ranges
decl_stmt|;
name|newSelection
operator|.
name|merge
argument_list|(
name|d
operator|->
name|currentSelection
argument_list|,
name|d
operator|->
name|currentCommand
argument_list|)
expr_stmt|;
name|emitSelectionChanged
argument_list|(
name|newSelection
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Clears the selection model. Emits selectionChanged() and currentChanged(). */
end_comment
begin_function
DECL|function|clear
name|void
name|QItemSelectionModel
operator|::
name|clear
parameter_list|()
block|{
name|clearSelection
argument_list|()
expr_stmt|;
name|clearCurrentIndex
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Clears the current index. Emits currentChanged().  */
end_comment
begin_function
DECL|function|clearCurrentIndex
name|void
name|QItemSelectionModel
operator|::
name|clearCurrentIndex
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QItemSelectionModel
argument_list|)
expr_stmt|;
name|QModelIndex
name|previous
init|=
name|d
operator|->
name|currentIndex
decl_stmt|;
name|d
operator|->
name|currentIndex
operator|=
name|QModelIndex
argument_list|()
expr_stmt|;
if|if
condition|(
name|previous
operator|.
name|isValid
argument_list|()
condition|)
block|{
emit|emit
name|currentChanged
argument_list|(
name|d
operator|->
name|currentIndex
argument_list|,
name|previous
argument_list|)
emit|;
emit|emit
name|currentRowChanged
argument_list|(
name|d
operator|->
name|currentIndex
argument_list|,
name|previous
argument_list|)
emit|;
emit|emit
name|currentColumnChanged
argument_list|(
name|d
operator|->
name|currentIndex
argument_list|,
name|previous
argument_list|)
emit|;
block|}
block|}
end_function
begin_comment
comment|/*!     Clears the selection model. Does not emit any signals. */
end_comment
begin_function
DECL|function|reset
name|void
name|QItemSelectionModel
operator|::
name|reset
parameter_list|()
block|{
name|bool
name|block
init|=
name|blockSignals
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|blockSignals
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     Clears the selection in the selection model. Emits selectionChanged(). */
end_comment
begin_function
DECL|function|clearSelection
name|void
name|QItemSelectionModel
operator|::
name|clearSelection
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QItemSelectionModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|ranges
operator|.
name|count
argument_list|()
operator|==
literal|0
operator|&&
name|d
operator|->
name|currentSelection
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|select
argument_list|(
name|QItemSelection
argument_list|()
argument_list|,
name|Clear
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the model item \a index to be the current item, and emits     currentChanged(). The current item is used for keyboard navigation and     focus indication; it is independent of any selected items, although a     selected item can also be the current item.      Depending on the specified \a command, the \a index can also become part     of the current selection.     \sa select() */
end_comment
begin_function
DECL|function|setCurrentIndex
name|void
name|QItemSelectionModel
operator|::
name|setCurrentIndex
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|command
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QItemSelectionModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|d
operator|->
name|currentIndex
condition|)
block|{
if|if
condition|(
name|command
operator|!=
name|NoUpdate
condition|)
name|select
argument_list|(
name|index
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|// select item
return|return;
block|}
name|QPersistentModelIndex
name|previous
init|=
name|d
operator|->
name|currentIndex
decl_stmt|;
name|d
operator|->
name|currentIndex
operator|=
name|index
expr_stmt|;
comment|// set current before emitting selection changed below
if|if
condition|(
name|command
operator|!=
name|NoUpdate
condition|)
name|select
argument_list|(
name|d
operator|->
name|currentIndex
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|// select item
emit|emit
name|currentChanged
argument_list|(
name|d
operator|->
name|currentIndex
argument_list|,
name|previous
argument_list|)
emit|;
if|if
condition|(
name|d
operator|->
name|currentIndex
operator|.
name|row
argument_list|()
operator|!=
name|previous
operator|.
name|row
argument_list|()
operator|||
name|d
operator|->
name|currentIndex
operator|.
name|parent
argument_list|()
operator|!=
name|previous
operator|.
name|parent
argument_list|()
condition|)
emit|emit
name|currentRowChanged
argument_list|(
name|d
operator|->
name|currentIndex
argument_list|,
name|previous
argument_list|)
emit|;
if|if
condition|(
name|d
operator|->
name|currentIndex
operator|.
name|column
argument_list|()
operator|!=
name|previous
operator|.
name|column
argument_list|()
operator|||
name|d
operator|->
name|currentIndex
operator|.
name|parent
argument_list|()
operator|!=
name|previous
operator|.
name|parent
argument_list|()
condition|)
emit|emit
name|currentColumnChanged
argument_list|(
name|d
operator|->
name|currentIndex
argument_list|,
name|previous
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     Returns the model item index for the current item, or an invalid index     if there is no current item. */
end_comment
begin_function
DECL|function|currentIndex
name|QModelIndex
name|QItemSelectionModel
operator|::
name|currentIndex
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
name|QModelIndex
argument_list|>
argument_list|(
name|d_func
argument_list|()
operator|->
name|currentIndex
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the given model item \a index is selected. */
end_comment
begin_function
DECL|function|isSelected
name|bool
name|QItemSelectionModel
operator|::
name|isSelected
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QItemSelectionModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|model
operator|!=
name|index
operator|.
name|model
argument_list|()
operator|||
operator|!
name|index
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|bool
name|selected
init|=
literal|false
decl_stmt|;
comment|//  search model ranges
name|QList
argument_list|<
name|QItemSelectionRange
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|d
operator|->
name|ranges
operator|.
name|begin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|d
operator|->
name|ranges
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
operator|*
name|it
operator|)
operator|.
name|contains
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|selected
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// check  currentSelection
if|if
condition|(
name|d
operator|->
name|currentSelection
operator|.
name|count
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|currentCommand
operator|&
name|Deselect
operator|)
operator|&&
name|selected
condition|)
name|selected
operator|=
operator|!
name|d
operator|->
name|currentSelection
operator|.
name|contains
argument_list|(
name|index
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|currentCommand
operator|&
name|Toggle
condition|)
name|selected
operator|^=
name|d
operator|->
name|currentSelection
operator|.
name|contains
argument_list|(
name|index
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|d
operator|->
name|currentCommand
operator|&
name|Select
operator|)
operator|&&
operator|!
name|selected
condition|)
name|selected
operator|=
name|d
operator|->
name|currentSelection
operator|.
name|contains
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|selected
condition|)
block|{
name|Qt
operator|::
name|ItemFlags
name|flags
init|=
name|d
operator|->
name|model
operator|->
name|flags
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsSelectable
operator|)
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if all items are selected in the \a row with the given     \a parent.      Note that this function is usually faster than calling isSelected()     on all items in the same row and that unselectable items are     ignored. */
end_comment
begin_function
DECL|function|isRowSelected
name|bool
name|QItemSelectionModel
operator|::
name|isRowSelected
parameter_list|(
name|int
name|row
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QItemSelectionModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|model
operator|!=
name|parent
operator|.
name|model
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// return false if row exist in currentSelection (Deselect)
if|if
condition|(
name|d
operator|->
name|currentCommand
operator|&
name|Deselect
operator|&&
name|d
operator|->
name|currentSelection
operator|.
name|count
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|currentSelection
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|d
operator|->
name|currentSelection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|parent
argument_list|()
operator|==
name|parent
operator|&&
name|row
operator|>=
name|d
operator|->
name|currentSelection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|top
argument_list|()
operator|&&
name|row
operator|<=
name|d
operator|->
name|currentSelection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|bottom
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
block|}
comment|// return false if ranges in both currentSelection and ranges
comment|// intersect and have the same row contained
if|if
condition|(
name|d
operator|->
name|currentCommand
operator|&
name|Toggle
operator|&&
name|d
operator|->
name|currentSelection
operator|.
name|count
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|currentSelection
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|d
operator|->
name|currentSelection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|top
argument_list|()
operator|<=
name|row
operator|&&
name|d
operator|->
name|currentSelection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|bottom
argument_list|()
operator|>=
name|row
condition|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|ranges
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|d
operator|->
name|ranges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|top
argument_list|()
operator|<=
name|row
operator|&&
name|d
operator|->
name|ranges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|bottom
argument_list|()
operator|>=
name|row
operator|&&
name|d
operator|->
name|currentSelection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|intersected
argument_list|(
name|d
operator|->
name|ranges
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
comment|// add ranges and currentSelection and check through them all
name|QList
argument_list|<
name|QItemSelectionRange
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|;
name|QList
argument_list|<
name|QItemSelectionRange
argument_list|>
name|joined
init|=
name|d
operator|->
name|ranges
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|currentSelection
operator|.
name|count
argument_list|()
condition|)
name|joined
operator|+=
name|d
operator|->
name|currentSelection
expr_stmt|;
name|int
name|colCount
init|=
name|d
operator|->
name|model
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|column
init|=
literal|0
init|;
name|column
operator|<
name|colCount
condition|;
operator|++
name|column
control|)
block|{
for|for
control|(
name|it
operator|=
name|joined
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|joined
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|contains
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|parent
argument_list|)
condition|)
block|{
name|bool
name|selectable
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|column
init|;
operator|!
name|selectable
operator|&&
name|i
operator|<=
operator|(
operator|*
name|it
operator|)
operator|.
name|right
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Qt
operator|::
name|ItemFlags
name|flags
init|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|i
argument_list|,
name|parent
argument_list|)
operator|.
name|flags
argument_list|()
decl_stmt|;
name|selectable
operator|=
name|flags
operator|&
name|Qt
operator|::
name|ItemIsSelectable
expr_stmt|;
block|}
if|if
condition|(
name|selectable
condition|)
block|{
name|column
operator|=
name|qMax
argument_list|(
name|column
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|right
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|it
operator|==
name|joined
operator|.
name|constEnd
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
return|return
name|colCount
operator|>
literal|0
return|;
comment|// no columns means no selected items
block|}
end_function
begin_comment
comment|/*!     Returns true if all items are selected in the \a column with the given     \a parent.      Note that this function is usually faster than calling isSelected()     on all items in the same column and that unselectable items are     ignored. */
end_comment
begin_function
DECL|function|isColumnSelected
name|bool
name|QItemSelectionModel
operator|::
name|isColumnSelected
parameter_list|(
name|int
name|column
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QItemSelectionModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|model
operator|!=
name|parent
operator|.
name|model
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// return false if column exist in currentSelection (Deselect)
if|if
condition|(
name|d
operator|->
name|currentCommand
operator|&
name|Deselect
operator|&&
name|d
operator|->
name|currentSelection
operator|.
name|count
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|currentSelection
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|d
operator|->
name|currentSelection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|parent
argument_list|()
operator|==
name|parent
operator|&&
name|column
operator|>=
name|d
operator|->
name|currentSelection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|left
argument_list|()
operator|&&
name|column
operator|<=
name|d
operator|->
name|currentSelection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|right
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
block|}
comment|// return false if ranges in both currentSelection and the selection model
comment|// intersect and have the same column contained
if|if
condition|(
name|d
operator|->
name|currentCommand
operator|&
name|Toggle
operator|&&
name|d
operator|->
name|currentSelection
operator|.
name|count
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|currentSelection
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|d
operator|->
name|currentSelection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|left
argument_list|()
operator|<=
name|column
operator|&&
name|d
operator|->
name|currentSelection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|right
argument_list|()
operator|>=
name|column
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|ranges
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|d
operator|->
name|ranges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|left
argument_list|()
operator|<=
name|column
operator|&&
name|d
operator|->
name|ranges
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|right
argument_list|()
operator|>=
name|column
operator|&&
name|d
operator|->
name|currentSelection
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|intersected
argument_list|(
name|d
operator|->
name|ranges
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
operator|.
name|isValid
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
block|}
comment|// add ranges and currentSelection and check through them all
name|QList
argument_list|<
name|QItemSelectionRange
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|;
name|QList
argument_list|<
name|QItemSelectionRange
argument_list|>
name|joined
init|=
name|d
operator|->
name|ranges
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|currentSelection
operator|.
name|count
argument_list|()
condition|)
name|joined
operator|+=
name|d
operator|->
name|currentSelection
expr_stmt|;
name|int
name|rowCount
init|=
name|d
operator|->
name|model
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|rowCount
condition|;
operator|++
name|row
control|)
block|{
for|for
control|(
name|it
operator|=
name|joined
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|joined
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|contains
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|parent
argument_list|)
condition|)
block|{
name|Qt
operator|::
name|ItemFlags
name|flags
init|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|parent
argument_list|)
operator|.
name|flags
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsSelectable
operator|)
operator|&&
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsEnabled
operator|)
condition|)
block|{
name|row
operator|=
name|qMax
argument_list|(
name|row
argument_list|,
operator|(
operator|*
name|it
operator|)
operator|.
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|it
operator|==
name|joined
operator|.
name|constEnd
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
return|return
name|rowCount
operator|>
literal|0
return|;
comment|// no rows means no selected items
block|}
end_function
begin_comment
comment|/*!     Returns true if there are any items selected in the \a row with the given     \a parent. */
end_comment
begin_function
DECL|function|rowIntersectsSelection
name|bool
name|QItemSelectionModel
operator|::
name|rowIntersectsSelection
parameter_list|(
name|int
name|row
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QItemSelectionModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|model
operator|!=
name|parent
operator|.
name|model
argument_list|()
condition|)
return|return
literal|false
return|;
name|QItemSelection
name|sel
init|=
name|d
operator|->
name|ranges
decl_stmt|;
name|sel
operator|.
name|merge
argument_list|(
name|d
operator|->
name|currentSelection
argument_list|,
name|d
operator|->
name|currentCommand
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sel
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QItemSelectionRange
name|range
init|=
name|sel
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|parent
argument_list|()
operator|!=
name|parent
condition|)
return|return
literal|false
return|;
name|int
name|top
init|=
name|range
operator|.
name|top
argument_list|()
decl_stmt|;
name|int
name|bottom
init|=
name|range
operator|.
name|bottom
argument_list|()
decl_stmt|;
name|int
name|left
init|=
name|range
operator|.
name|left
argument_list|()
decl_stmt|;
name|int
name|right
init|=
name|range
operator|.
name|right
argument_list|()
decl_stmt|;
if|if
condition|(
name|top
operator|<=
name|row
operator|&&
name|bottom
operator|>=
name|row
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
name|left
init|;
name|j
operator|<=
name|right
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|Qt
operator|::
name|ItemFlags
name|flags
init|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|j
argument_list|,
name|parent
argument_list|)
operator|.
name|flags
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsSelectable
operator|)
operator|&&
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsEnabled
operator|)
condition|)
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if there are any items selected in the \a column with the given     \a parent. */
end_comment
begin_function
DECL|function|columnIntersectsSelection
name|bool
name|QItemSelectionModel
operator|::
name|columnIntersectsSelection
parameter_list|(
name|int
name|column
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QItemSelectionModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|model
operator|!=
name|parent
operator|.
name|model
argument_list|()
condition|)
return|return
literal|false
return|;
name|QItemSelection
name|sel
init|=
name|d
operator|->
name|ranges
decl_stmt|;
name|sel
operator|.
name|merge
argument_list|(
name|d
operator|->
name|currentSelection
argument_list|,
name|d
operator|->
name|currentCommand
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sel
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|left
init|=
name|sel
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|left
argument_list|()
decl_stmt|;
name|int
name|right
init|=
name|sel
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|right
argument_list|()
decl_stmt|;
name|int
name|top
init|=
name|sel
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|top
argument_list|()
decl_stmt|;
name|int
name|bottom
init|=
name|sel
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|bottom
argument_list|()
decl_stmt|;
if|if
condition|(
name|left
operator|<=
name|column
operator|&&
name|right
operator|>=
name|column
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
name|top
init|;
name|j
operator|<=
name|bottom
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|Qt
operator|::
name|ItemFlags
name|flags
init|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|j
argument_list|,
name|column
argument_list|,
name|parent
argument_list|)
operator|.
name|flags
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsSelectable
operator|)
operator|&&
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsEnabled
operator|)
condition|)
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns true if the selection model contains any selection ranges;     otherwise returns false. */
end_comment
begin_function
DECL|function|hasSelection
name|bool
name|QItemSelectionModel
operator|::
name|hasSelection
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QItemSelectionModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|currentCommand
operator|&
operator|(
name|Toggle
operator||
name|Deselect
operator|)
condition|)
block|{
name|QItemSelection
name|sel
init|=
name|d
operator|->
name|ranges
decl_stmt|;
name|sel
operator|.
name|merge
argument_list|(
name|d
operator|->
name|currentSelection
argument_list|,
name|d
operator|->
name|currentCommand
argument_list|)
expr_stmt|;
return|return
operator|!
name|sel
operator|.
name|isEmpty
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|!
operator|(
name|d
operator|->
name|ranges
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|currentSelection
operator|.
name|isEmpty
argument_list|()
operator|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns a list of all selected model item indexes. The list contains no     duplicates, and is not sorted. */
end_comment
begin_function
DECL|function|selectedIndexes
name|QModelIndexList
name|QItemSelectionModel
operator|::
name|selectedIndexes
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QItemSelectionModel
argument_list|)
expr_stmt|;
name|QItemSelection
name|selected
init|=
name|d
operator|->
name|ranges
decl_stmt|;
name|selected
operator|.
name|merge
argument_list|(
name|d
operator|->
name|currentSelection
argument_list|,
name|d
operator|->
name|currentCommand
argument_list|)
expr_stmt|;
return|return
name|selected
operator|.
name|indexes
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     Returns the indexes in the given \a column for the rows where all columns are selected.      \sa selectedIndexes(), selectedColumns() */
end_comment
begin_function
DECL|function|selectedRows
name|QModelIndexList
name|QItemSelectionModel
operator|::
name|selectedRows
parameter_list|(
name|int
name|column
parameter_list|)
specifier|const
block|{
name|QModelIndexList
name|indexes
decl_stmt|;
comment|//the QSet contains pairs of parent modelIndex
comment|//and row number
name|QSet
argument_list|<
name|QPair
argument_list|<
name|QModelIndex
argument_list|,
name|int
argument_list|>
argument_list|>
name|rowsSeen
decl_stmt|;
specifier|const
name|QItemSelection
name|ranges
init|=
name|selection
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ranges
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QItemSelectionRange
modifier|&
name|range
init|=
name|ranges
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QModelIndex
name|parent
init|=
name|range
operator|.
name|parent
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|row
init|=
name|range
operator|.
name|top
argument_list|()
init|;
name|row
operator|<=
name|range
operator|.
name|bottom
argument_list|()
condition|;
name|row
operator|++
control|)
block|{
name|QPair
argument_list|<
name|QModelIndex
argument_list|,
name|int
argument_list|>
name|rowDef
init|=
name|qMakePair
argument_list|(
name|parent
argument_list|,
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rowsSeen
operator|.
name|contains
argument_list|(
name|rowDef
argument_list|)
condition|)
block|{
name|rowsSeen
operator|<<
name|rowDef
expr_stmt|;
if|if
condition|(
name|isRowSelected
argument_list|(
name|row
argument_list|,
name|parent
argument_list|)
condition|)
block|{
name|indexes
operator|.
name|append
argument_list|(
name|model
argument_list|()
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|indexes
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     Returns the indexes in the given \a row for columns where all rows are selected.      \sa selectedIndexes(), selectedRows() */
end_comment
begin_function
DECL|function|selectedColumns
name|QModelIndexList
name|QItemSelectionModel
operator|::
name|selectedColumns
parameter_list|(
name|int
name|row
parameter_list|)
specifier|const
block|{
name|QModelIndexList
name|indexes
decl_stmt|;
comment|//the QSet contains pairs of parent modelIndex
comment|//and column number
name|QSet
argument_list|<
name|QPair
argument_list|<
name|QModelIndex
argument_list|,
name|int
argument_list|>
argument_list|>
name|columnsSeen
decl_stmt|;
specifier|const
name|QItemSelection
name|ranges
init|=
name|selection
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ranges
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QItemSelectionRange
modifier|&
name|range
init|=
name|ranges
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QModelIndex
name|parent
init|=
name|range
operator|.
name|parent
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|column
init|=
name|range
operator|.
name|left
argument_list|()
init|;
name|column
operator|<=
name|range
operator|.
name|right
argument_list|()
condition|;
name|column
operator|++
control|)
block|{
name|QPair
argument_list|<
name|QModelIndex
argument_list|,
name|int
argument_list|>
name|columnDef
init|=
name|qMakePair
argument_list|(
name|parent
argument_list|,
name|column
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|columnsSeen
operator|.
name|contains
argument_list|(
name|columnDef
argument_list|)
condition|)
block|{
name|columnsSeen
operator|<<
name|columnDef
expr_stmt|;
if|if
condition|(
name|isColumnSelected
argument_list|(
name|column
argument_list|,
name|parent
argument_list|)
condition|)
block|{
name|indexes
operator|.
name|append
argument_list|(
name|model
argument_list|()
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|indexes
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the selection ranges stored in the selection model. */
end_comment
begin_function
DECL|function|selection
specifier|const
name|QItemSelection
name|QItemSelectionModel
operator|::
name|selection
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QItemSelectionModel
argument_list|)
expr_stmt|;
name|QItemSelection
name|selected
init|=
name|d
operator|->
name|ranges
decl_stmt|;
name|selected
operator|.
name|merge
argument_list|(
name|d
operator|->
name|currentSelection
argument_list|,
name|d
operator|->
name|currentCommand
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// make sure we have no invalid ranges
comment|// ###  should probably be handled more generic somewhere else
while|while
condition|(
name|i
operator|<
name|selected
operator|.
name|count
argument_list|()
condition|)
block|{
if|if
condition|(
name|selected
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isValid
argument_list|()
condition|)
operator|++
name|i
expr_stmt|;
else|else
operator|(
name|selected
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
name|selected
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the item model operated on by the selection model. */
end_comment
begin_function
DECL|function|model
specifier|const
name|QAbstractItemModel
modifier|*
name|QItemSelectionModel
operator|::
name|model
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|model
return|;
block|}
end_function
begin_comment
comment|/*!     Compares the two selections \a newSelection and \a oldSelection     and emits selectionChanged() with the deselected and selected items. */
end_comment
begin_function
DECL|function|emitSelectionChanged
name|void
name|QItemSelectionModel
operator|::
name|emitSelectionChanged
parameter_list|(
specifier|const
name|QItemSelection
modifier|&
name|newSelection
parameter_list|,
specifier|const
name|QItemSelection
modifier|&
name|oldSelection
parameter_list|)
block|{
comment|// if both selections are empty or equal we return
if|if
condition|(
operator|(
name|oldSelection
operator|.
name|isEmpty
argument_list|()
operator|&&
name|newSelection
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
name|oldSelection
operator|==
name|newSelection
condition|)
return|return;
comment|// if either selection is empty we do not need to compare
if|if
condition|(
name|oldSelection
operator|.
name|isEmpty
argument_list|()
operator|||
name|newSelection
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
emit|emit
name|selectionChanged
argument_list|(
name|newSelection
argument_list|,
name|oldSelection
argument_list|)
emit|;
return|return;
block|}
name|QItemSelection
name|deselected
init|=
name|oldSelection
decl_stmt|;
name|QItemSelection
name|selected
init|=
name|newSelection
decl_stmt|;
comment|// remove equal ranges
name|bool
name|advance
decl_stmt|;
for|for
control|(
name|int
name|o
init|=
literal|0
init|;
name|o
operator|<
name|deselected
operator|.
name|count
argument_list|()
condition|;
operator|++
name|o
control|)
block|{
name|advance
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|selected
operator|.
name|count
argument_list|()
operator|&&
name|o
operator|<
name|deselected
operator|.
name|count
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|deselected
operator|.
name|at
argument_list|(
name|o
argument_list|)
operator|==
name|selected
operator|.
name|at
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|deselected
operator|.
name|removeAt
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|selected
operator|.
name|removeAt
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|advance
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
operator|++
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|advance
condition|)
operator|++
name|o
expr_stmt|;
block|}
comment|// find intersections
name|QItemSelection
name|intersections
decl_stmt|;
for|for
control|(
name|int
name|o
init|=
literal|0
init|;
name|o
operator|<
name|deselected
operator|.
name|count
argument_list|()
condition|;
operator|++
name|o
control|)
block|{
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|selected
operator|.
name|count
argument_list|()
condition|;
operator|++
name|s
control|)
block|{
if|if
condition|(
name|deselected
operator|.
name|at
argument_list|(
name|o
argument_list|)
operator|.
name|intersects
argument_list|(
name|selected
operator|.
name|at
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
name|intersections
operator|.
name|append
argument_list|(
name|deselected
operator|.
name|at
argument_list|(
name|o
argument_list|)
operator|.
name|intersected
argument_list|(
name|selected
operator|.
name|at
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// compare remaining ranges with intersections and split them to find deselected and selected
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|intersections
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// split deselected
for|for
control|(
name|int
name|o
init|=
literal|0
init|;
name|o
operator|<
name|deselected
operator|.
name|count
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|deselected
operator|.
name|at
argument_list|(
name|o
argument_list|)
operator|.
name|intersects
argument_list|(
name|intersections
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|QItemSelection
operator|::
name|split
argument_list|(
name|deselected
operator|.
name|at
argument_list|(
name|o
argument_list|)
argument_list|,
name|intersections
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|deselected
argument_list|)
expr_stmt|;
name|deselected
operator|.
name|removeAt
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|o
expr_stmt|;
block|}
block|}
comment|// split selected
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|selected
operator|.
name|count
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|selected
operator|.
name|at
argument_list|(
name|s
argument_list|)
operator|.
name|intersects
argument_list|(
name|intersections
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|QItemSelection
operator|::
name|split
argument_list|(
name|selected
operator|.
name|at
argument_list|(
name|s
argument_list|)
argument_list|,
name|intersections
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|selected
argument_list|)
expr_stmt|;
name|selected
operator|.
name|removeAt
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|s
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|selected
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|deselected
operator|.
name|isEmpty
argument_list|()
condition|)
emit|emit
name|selectionChanged
argument_list|(
name|selected
argument_list|,
name|deselected
argument_list|)
emit|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QItemSelectionRange
modifier|&
name|range
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QItemSelectionRange("
operator|<<
name|range
operator|.
name|topLeft
argument_list|()
operator|<<
literal|','
operator|<<
name|range
operator|.
name|bottomRight
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qitemselectionmodel.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_ITEMVIEWS
end_comment
end_unit
