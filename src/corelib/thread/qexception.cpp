begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qexception.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qshareddata.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QFUTURE
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_EXCEPTIONS
end_ifndef
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!      \class QException     \inmodule QtCore     \brief The QException class provides a base class for exceptions that can transferred across threads.     \since 5.0      Qt Concurrent supports throwing and catching exceptions across thread     boundaries, provided that the exception inherit from QException     and implement two helper functions:      \snippet code/src_corelib_thread_qexception.cpp 0      QException subclasses must be thrown by value and     caught by reference:      \snippet code/src_corelib_thread_qexception.cpp 1      If you throw an exception that is not a subclass of QException,     the Qt functions will throw a QUnhandledException     in the receiver thread.      When using QFuture, transferred exceptions will be thrown when calling the following functions:     \list     \li QFuture::waitForFinished()     \li QFuture::result()     \li QFuture::resultAt()     \li QFuture::results()     \endlist */
comment|/*!     \fn QException::raise() const     In your QException subclass, reimplement raise() like this:      \snippet code/src_corelib_thread_qexception.cpp 2 */
comment|/*!     \fn QException::clone() const     In your QException subclass, reimplement clone() like this:      \snippet code/src_corelib_thread_qexception.cpp 3 */
comment|/*!      \class QUnhandledException     \inmodule QtCore      \brief The UnhandledException class represents an unhandled exception in a worker thread.     \since 5.0      If a worker thread throws an exception that is not a subclass of QException,     the Qt functions will throw a QUnhandledException     on the receiver thread side.      Inheriting from this class is not supported. */
comment|/*!     \fn QUnhandledException::raise() const     \internal */
comment|/*!     \fn QUnhandledException::clone() const     \internal */
DECL|function|raise
name|void
name|QException
operator|::
name|raise
parameter_list|()
specifier|const
block|{
name|QException
name|e
init|=
operator|*
name|this
decl_stmt|;
throw|throw
name|e
throw|;
block|}
end_function
begin_function
DECL|function|clone
name|QException
modifier|*
name|QException
operator|::
name|clone
parameter_list|()
specifier|const
block|{
return|return
operator|new
name|QException
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|raise
name|void
name|QUnhandledException
operator|::
name|raise
parameter_list|()
specifier|const
block|{
name|QUnhandledException
name|e
init|=
operator|*
name|this
decl_stmt|;
throw|throw
name|e
throw|;
block|}
end_function
begin_function
DECL|function|clone
name|QUnhandledException
modifier|*
name|QUnhandledException
operator|::
name|clone
parameter_list|()
specifier|const
block|{
return|return
operator|new
name|QUnhandledException
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|Q_QDOC
end_ifndef
begin_namespace
DECL|namespace|QtPrivate
namespace|namespace
name|QtPrivate
block|{
DECL|class|Base
class|class
name|Base
super|:
specifier|public
name|QSharedData
block|{
public|public:
DECL|function|Base
name|Base
parameter_list|(
name|QException
modifier|*
name|exception
parameter_list|)
member_init_list|:
name|exception
argument_list|(
name|exception
argument_list|)
member_init_list|,
name|hasThrown
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|function|~Base
name|~
name|Base
parameter_list|()
block|{
operator|delete
name|exception
expr_stmt|;
block|}
DECL|member|exception
name|QException
modifier|*
name|exception
decl_stmt|;
DECL|member|hasThrown
name|bool
name|hasThrown
decl_stmt|;
block|}
class|;
DECL|function|ExceptionHolder
name|ExceptionHolder
operator|::
name|ExceptionHolder
parameter_list|(
name|QException
modifier|*
name|exception
parameter_list|)
member_init_list|:
name|base
argument_list|(
operator|new
name|Base
argument_list|(
name|exception
argument_list|)
argument_list|)
block|{}
DECL|function|ExceptionHolder
name|ExceptionHolder
operator|::
name|ExceptionHolder
parameter_list|(
specifier|const
name|ExceptionHolder
modifier|&
name|other
parameter_list|)
member_init_list|:
name|base
argument_list|(
name|other
operator|.
name|base
argument_list|)
block|{}
DECL|function|operator =
name|void
name|ExceptionHolder
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|ExceptionHolder
modifier|&
name|other
parameter_list|)
block|{
name|base
operator|=
name|other
operator|.
name|base
expr_stmt|;
block|}
DECL|function|~ExceptionHolder
name|ExceptionHolder
operator|::
name|~
name|ExceptionHolder
parameter_list|()
block|{}
DECL|function|exception
name|QException
modifier|*
name|ExceptionHolder
operator|::
name|exception
parameter_list|()
specifier|const
block|{
return|return
name|base
operator|->
name|exception
return|;
block|}
DECL|function|setException
name|void
name|ExceptionStore
operator|::
name|setException
parameter_list|(
specifier|const
name|QException
modifier|&
name|e
parameter_list|)
block|{
if|if
condition|(
name|hasException
argument_list|()
operator|==
literal|false
condition|)
name|exceptionHolder
operator|=
name|ExceptionHolder
argument_list|(
name|e
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|hasException
name|bool
name|ExceptionStore
operator|::
name|hasException
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|exceptionHolder
operator|.
name|exception
argument_list|()
operator|!=
literal|0
operator|)
return|;
block|}
DECL|function|exception
name|ExceptionHolder
name|ExceptionStore
operator|::
name|exception
parameter_list|()
block|{
return|return
name|exceptionHolder
return|;
block|}
DECL|function|throwPossibleException
name|void
name|ExceptionStore
operator|::
name|throwPossibleException
parameter_list|()
block|{
if|if
condition|(
name|hasException
argument_list|()
condition|)
block|{
name|exceptionHolder
operator|.
name|base
operator|->
name|hasThrown
operator|=
literal|true
expr_stmt|;
name|exceptionHolder
operator|.
name|exception
argument_list|()
operator|->
name|raise
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|hasThrown
name|bool
name|ExceptionStore
operator|::
name|hasThrown
parameter_list|()
specifier|const
block|{
return|return
name|exceptionHolder
operator|.
name|base
operator|->
name|hasThrown
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace QtPrivate
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//Q_QDOC
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_EXCEPTIONS
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QFUTURE
end_comment
end_unit
