begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|<private/qcoreapplication_p.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
end_if
begin_include
include|#
directive|include
file|<private/qeventdispatcher_blackberry_p.h>
end_include
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_GLIB
argument_list|)
end_if
begin_include
include|#
directive|include
file|"../kernel/qeventdispatcher_glib_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<private/qeventdispatcher_unix_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qthreadstorage.h"
end_include
begin_include
include|#
directive|include
file|"qthread_p.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|<sched.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_BSD4
end_ifdef
begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_VXWORKS
end_ifdef
begin_if
if|#
directive|if
operator|(
name|_WRS_VXWORKS_MAJOR
operator|>
literal|6
operator|)
operator|||
operator|(
operator|(
name|_WRS_VXWORKS_MAJOR
operator|==
literal|6
operator|)
operator|&&
operator|(
name|_WRS_VXWORKS_MINOR
operator|>=
literal|6
operator|)
operator|)
end_if
begin_include
include|#
directive|include
file|<vxCpuLib.h>
end_include
begin_include
include|#
directive|include
file|<cpuset.h>
end_include
begin_define
DECL|macro|QT_VXWORKS_HAS_CPUSET
define|#
directive|define
name|QT_VXWORKS_HAS_CPUSET
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_HPUX
end_ifdef
begin_include
include|#
directive|include
file|<sys/pstat.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|qDebug
end_ifdef
begin_define
DECL|macro|old_qDebug
define|#
directive|define
name|old_qDebug
value|qDebug
end_define
begin_undef
DECL|macro|qDebug
undef|#
directive|undef
name|qDebug
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_IOS
end_ifndef
begin_include
include|#
directive|include
file|<CoreServices/CoreServices.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//Q_OS_IOS
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|old_qDebug
end_ifdef
begin_undef
DECL|macro|qDebug
undef|#
directive|undef
name|qDebug
end_undef
begin_define
DECL|macro|qDebug
define|#
directive|define
name|qDebug
value|QT_NO_QDEBUG_MACRO
end_define
begin_undef
DECL|macro|old_qDebug
undef|#
directive|undef
name|old_qDebug
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_LINUXBASE
argument_list|)
end_if
begin_include
include|#
directive|include
file|<sys/prctl.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCHED_IDLE
argument_list|)
end_if
begin_comment
comment|// from linux/sched.h
end_comment
begin_define
DECL|macro|SCHED_IDLE
define|#
directive|define
name|SCHED_IDLE
value|5
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|Q_OS_OPENBSD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_PRIORITY_SCHEDULING
argument_list|)
operator|&&
operator|(
name|_POSIX_THREAD_PRIORITY_SCHEDULING
operator|-
literal|0
operator|>=
literal|0
operator|)
end_if
begin_define
DECL|macro|QT_HAS_THREAD_PRIORITY_SCHEDULING
define|#
directive|define
name|QT_HAS_THREAD_PRIORITY_SCHEDULING
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
ifndef|#
directive|ifndef
name|QT_NO_THREAD
DECL|enumerator|ThreadPriorityResetFlag
name|enum
type|{
name|ThreadPriorityResetFlag
init|=
literal|0x80000000
end_decl_stmt
begin_if
unit|};
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_LINUXBASE
argument_list|)
end_if
begin_comment
comment|/* LSB doesn't have __thread, https://lsbbugs.linuxfoundation.org/show_bug.cgi?id=993 */
end_comment
begin_define
DECL|macro|HAVE_TLS
define|#
directive|define
name|HAVE_TLS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_XLC
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_SUN
argument_list|)
end_if
begin_define
DECL|macro|HAVE_TLS
define|#
directive|define
name|HAVE_TLS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TLS
end_ifdef
begin_decl_stmt
DECL|variable|currentThreadData
specifier|static
name|__thread
name|QThreadData
modifier|*
name|currentThreadData
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|current_thread_data_once
specifier|static
name|pthread_once_t
name|current_thread_data_once
init|=
name|PTHREAD_ONCE_INIT
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|current_thread_data_key
specifier|static
name|pthread_key_t
name|current_thread_data_key
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|destroy_current_thread_data
specifier|static
name|void
name|destroy_current_thread_data
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
comment|// Calling setspecific(..., 0) sets the value to 0 for ALL threads.
comment|// The 'set to 1' workaround adds a bit of an overhead though,
comment|// since this function is called twice now.
if|if
condition|(
name|p
operator|==
operator|(
name|void
operator|*
operator|)
literal|1
condition|)
return|return;
endif|#
directive|endif
comment|// POSIX says the value in our key is set to zero before calling
comment|// this destructor function, so we need to set it back to the
comment|// right value...
name|pthread_setspecific
argument_list|(
name|current_thread_data_key
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|QThreadData
modifier|*
name|data
init|=
cast|static_cast
argument_list|<
name|QThreadData
operator|*
argument_list|>
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|isAdopted
condition|)
block|{
name|QThread
modifier|*
name|thread
init|=
name|data
operator|->
name|thread
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|QThreadPrivate
modifier|*
name|thread_p
init|=
cast|static_cast
argument_list|<
name|QThreadPrivate
operator|*
argument_list|>
argument_list|(
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|thread
argument_list|)
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|thread_p
operator|->
name|finished
argument_list|)
expr_stmt|;
name|thread_p
operator|->
name|finish
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
name|data
operator|->
name|deref
argument_list|()
expr_stmt|;
comment|// ... but we must reset it to zero before returning so we aren't
comment|// called again (POSIX allows implementations to call destructor
comment|// functions repeatedly until all values are zero)
name|pthread_setspecific
argument_list|(
name|current_thread_data_key
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
literal|0
block|)
function|;
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
unit|}  static
DECL|function|create_current_thread_data_key
name|void
name|create_current_thread_data_key
parameter_list|()
block|{
name|pthread_key_create
argument_list|(
operator|&
name|current_thread_data_key
argument_list|,
name|destroy_current_thread_data
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|destroy_current_thread_data_key
specifier|static
name|void
name|destroy_current_thread_data_key
parameter_list|()
block|{
name|pthread_once
argument_list|(
operator|&
name|current_thread_data_once
argument_list|,
name|create_current_thread_data_key
argument_list|)
expr_stmt|;
name|pthread_key_delete
argument_list|(
name|current_thread_data_key
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|Q_DESTRUCTOR_FUNCTION
argument_list|(
argument|destroy_current_thread_data_key
argument_list|)
end_macro
begin_comment
comment|// Utility functions for getting, setting and clearing thread specific data.
end_comment
begin_function
DECL|function|get_thread_data
specifier|static
name|QThreadData
modifier|*
name|get_thread_data
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|HAVE_TLS
return|return
name|currentThreadData
return|;
else|#
directive|else
name|pthread_once
argument_list|(
operator|&
name|current_thread_data_once
argument_list|,
name|create_current_thread_data_key
argument_list|)
expr_stmt|;
return|return
cast|reinterpret_cast
argument_list|<
name|QThreadData
operator|*
argument_list|>
argument_list|(
name|pthread_getspecific
argument_list|(
name|current_thread_data_key
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|set_thread_data
specifier|static
name|void
name|set_thread_data
parameter_list|(
name|QThreadData
modifier|*
name|data
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TLS
name|currentThreadData
operator|=
name|data
expr_stmt|;
endif|#
directive|endif
name|pthread_once
argument_list|(
operator|&
name|current_thread_data_once
argument_list|,
name|create_current_thread_data_key
argument_list|)
expr_stmt|;
name|pthread_setspecific
argument_list|(
name|current_thread_data_key
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clear_thread_data
specifier|static
name|void
name|clear_thread_data
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|HAVE_TLS
name|currentThreadData
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|pthread_setspecific
argument_list|(
name|current_thread_data_key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|current
name|QThreadData
modifier|*
name|QThreadData
operator|::
name|current
parameter_list|()
block|{
name|QThreadData
modifier|*
name|data
init|=
name|get_thread_data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|data
operator|=
operator|new
name|QThreadData
expr_stmt|;
name|QT_TRY
block|{
name|set_thread_data
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|thread
operator|=
operator|new
name|QAdoptedThread
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
name|clear_thread_data
argument_list|()
expr_stmt|;
name|data
operator|->
name|deref
argument_list|()
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
name|data
operator|->
name|deref
argument_list|()
expr_stmt|;
name|data
operator|->
name|isAdopted
operator|=
literal|true
expr_stmt|;
name|data
operator|->
name|threadId
operator|=
operator|(
name|Qt
operator|::
name|HANDLE
operator|)
name|pthread_self
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|theMainThread
condition|)
name|QCoreApplicationPrivate
operator|::
name|theMainThread
operator|=
name|data
operator|->
name|thread
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|QAdoptedThread
operator|::
name|init
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QThread
argument_list|)
expr_stmt|;
name|d
operator|->
name|thread_id
operator|=
name|pthread_self
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*    QThreadPrivate */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_C_CALLBACKS
argument_list|)
end_if
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
DECL|typedef|QtThreadCallback
typedef|typedef
name|void
modifier|*
function_decl|(
modifier|*
name|QtThreadCallback
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|Q_C_CALLBACKS
argument_list|)
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_THREAD
end_comment
begin_function
DECL|function|createEventDispatcher
name|void
name|QThreadPrivate
operator|::
name|createEventDispatcher
parameter_list|(
name|QThreadData
modifier|*
name|data
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
name|data
operator|->
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherBlackberry
expr_stmt|;
else|#
directive|else
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_GLIB
argument_list|)
if|if
condition|(
name|qEnvironmentVariableIsEmpty
argument_list|(
literal|"QT_NO_GLIB"
argument_list|)
operator|&&
name|qEnvironmentVariableIsEmpty
argument_list|(
literal|"QT_NO_THREADED_GLIB"
argument_list|)
operator|&&
name|QEventDispatcherGlib
operator|::
name|versionSupported
argument_list|()
condition|)
name|data
operator|->
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherGlib
expr_stmt|;
else|else
endif|#
directive|endif
name|data
operator|->
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherUNIX
expr_stmt|;
endif|#
directive|endif
name|data
operator|->
name|eventDispatcher
operator|->
name|startingUp
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_THREAD
end_ifndef
begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
operator|)
end_if
begin_function
DECL|function|setCurrentThreadName
specifier|static
name|void
name|setCurrentThreadName
parameter_list|(
name|pthread_t
name|threadId
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_LINUXBASE
argument_list|)
name|Q_UNUSED
argument_list|(
name|threadId
argument_list|)
expr_stmt|;
name|prctl
argument_list|(
name|PR_SET_NAME
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
name|Q_UNUSED
argument_list|(
name|threadId
argument_list|)
expr_stmt|;
name|pthread_setname_np
argument_list|(
name|name
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
name|pthread_setname_np
argument_list|(
name|threadId
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|start
name|void
modifier|*
name|QThreadPrivate
operator|::
name|start
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_LINUX_ANDROID
argument_list|)
name|pthread_setcancelstate
argument_list|(
name|PTHREAD_CANCEL_DISABLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pthread_cleanup_push
argument_list|(
name|QThreadPrivate
operator|::
name|finish
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|QThread
modifier|*
name|thr
init|=
cast|reinterpret_cast
argument_list|<
name|QThread
operator|*
argument_list|>
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|get2
argument_list|(
name|thr
argument_list|)
decl_stmt|;
comment|// do we need to reset the thread priority?
if|if
condition|(
name|int
argument_list|(
name|thr
operator|->
name|d_func
argument_list|()
operator|->
name|priority
argument_list|)
operator|&
name|ThreadPriorityResetFlag
condition|)
block|{
name|thr
operator|->
name|setPriority
argument_list|(
name|QThread
operator|::
name|Priority
argument_list|(
name|thr
operator|->
name|d_func
argument_list|()
operator|->
name|priority
operator|&
operator|~
name|ThreadPriorityResetFlag
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|data
operator|->
name|threadId
operator|=
operator|(
name|Qt
operator|::
name|HANDLE
operator|)
name|pthread_self
argument_list|()
expr_stmt|;
name|set_thread_data
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|ref
argument_list|()
expr_stmt|;
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|thr
operator|->
name|d_func
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|data
operator|->
name|quitNow
operator|=
name|thr
operator|->
name|d_func
argument_list|()
operator|->
name|exited
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|eventDispatcher
condition|)
comment|// custom event dispatcher set?
name|data
operator|->
name|eventDispatcher
operator|->
name|startingUp
argument_list|()
expr_stmt|;
else|else
name|createEventDispatcher
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
operator|)
comment|// sets the name of the current thread.
name|QString
name|objectName
init|=
name|thr
operator|->
name|objectName
argument_list|()
decl_stmt|;
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|objectName
operator|.
name|isEmpty
argument_list|()
argument_list|)
condition|)
name|setCurrentThreadName
argument_list|(
name|thr
operator|->
name|d_func
argument_list|()
operator|->
name|thread_id
argument_list|,
name|thr
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|setCurrentThreadName
argument_list|(
name|thr
operator|->
name|d_func
argument_list|()
operator|->
name|thread_id
argument_list|,
name|objectName
operator|.
name|toLocal8Bit
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|thr
operator|->
name|started
argument_list|()
emit|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_LINUX_ANDROID
argument_list|)
name|pthread_setcancelstate
argument_list|(
name|PTHREAD_CANCEL_ENABLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_testcancel
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|thr
operator|->
name|run
argument_list|()
expr_stmt|;
name|pthread_cleanup_pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|finish
name|void
name|QThreadPrivate
operator|::
name|finish
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|QThread
modifier|*
name|thr
init|=
cast|reinterpret_cast
argument_list|<
name|QThread
operator|*
argument_list|>
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|QThreadPrivate
modifier|*
name|d
init|=
name|thr
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|d
operator|->
name|isInFinish
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|priority
operator|=
name|QThread
operator|::
name|InheritPriority
expr_stmt|;
name|void
modifier|*
name|data
init|=
operator|&
name|d
operator|->
name|data
operator|->
name|tls
decl_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
emit|emit
name|thr
operator|->
name|finished
argument_list|()
emit|;
name|QCoreApplication
operator|::
name|sendPostedEvents
argument_list|(
literal|0
argument_list|,
name|QEvent
operator|::
name|DeferredDelete
argument_list|)
expr_stmt|;
name|QThreadStorageData
operator|::
name|finish
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|locker
operator|.
name|relock
argument_list|()
expr_stmt|;
name|QAbstractEventDispatcher
modifier|*
name|eventDispatcher
init|=
name|d
operator|->
name|data
operator|->
name|eventDispatcher
decl_stmt|;
if|if
condition|(
name|eventDispatcher
condition|)
block|{
name|d
operator|->
name|data
operator|->
name|eventDispatcher
operator|=
literal|0
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|eventDispatcher
operator|->
name|closingDown
argument_list|()
expr_stmt|;
operator|delete
name|eventDispatcher
expr_stmt|;
name|locker
operator|.
name|relock
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|thread_id
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|running
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|finished
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|isInFinish
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|thread_done
operator|.
name|wakeAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/**************************************************************************  ** QThread  *************************************************************************/
end_comment
begin_function
name|Qt
operator|::
name|HANDLE
name|QThread
operator|::
name|currentThreadId
parameter_list|()
name|Q_DECL_NOTHROW
block|{
comment|// requires a C cast here otherwise we run into trouble on AIX
return|return
operator|(
name|Qt
operator|::
name|HANDLE
operator|)
name|pthread_self
argument_list|()
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_LINUXBASE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_SC_NPROCESSORS_ONLN
argument_list|)
end_if
begin_comment
comment|// LSB doesn't define _SC_NPROCESSORS_ONLN.
end_comment
begin_define
DECL|macro|_SC_NPROCESSORS_ONLN
define|#
directive|define
name|_SC_NPROCESSORS_ONLN
value|84
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|int
name|QThread
operator|::
name|idealThreadCount
parameter_list|()
name|Q_DECL_NOTHROW
block|{
name|int
name|cores
init|=
operator|-
literal|1
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_IOS
argument_list|)
comment|// Mac OS X
name|cores
operator|=
name|MPProcessorsScheduled
argument_list|()
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
comment|// HP-UX
name|struct
name|pst_dynamic
name|psd
decl_stmt|;
if|if
condition|(
name|pstat_getdynamic
argument_list|(
operator|&
name|psd
argument_list|,
sizeof|sizeof
argument_list|(
name|psd
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"pstat_getdynamic"
argument_list|)
expr_stmt|;
name|cores
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cores
operator|=
operator|(
name|int
operator|)
name|psd
operator|.
name|psd_proc_cnt
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_BSD4
argument_list|)
comment|// FreeBSD, OpenBSD, NetBSD, BSD/OS
name|size_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|cores
argument_list|)
decl_stmt|;
name|int
name|mib
index|[
literal|2
index|]
decl_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_HW
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|HW_NCPU
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
operator|&
name|cores
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"sysctl"
argument_list|)
expr_stmt|;
name|cores
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_IRIX
argument_list|)
comment|// IRIX
name|cores
operator|=
operator|(
name|int
operator|)
name|sysconf
argument_list|(
name|_SC_NPROC_ONLN
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_INTEGRITY
argument_list|)
comment|// as of aug 2008 Integrity only supports one single core CPU
name|cores
operator|=
literal|1
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
comment|// VxWorks
if|#
directive|if
name|defined
argument_list|(
name|QT_VXWORKS_HAS_CPUSET
argument_list|)
name|cpuset_t
name|cpus
init|=
name|vxCpuEnabledGet
argument_list|()
decl_stmt|;
name|cores
operator|=
literal|0
expr_stmt|;
comment|// 128 cores should be enough for everyone ;)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|128
operator|&&
operator|!
name|CPUSET_ISZERO
argument_list|(
name|cpus
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|CPUSET_ISSET
argument_list|(
name|cpus
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|CPUSET_CLR
argument_list|(
name|cpus
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cores
operator|++
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|// as of aug 2008 VxWorks< 6.6 only supports one single core CPU
name|cores
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|// the rest: Linux, Solaris, AIX, Tru64
name|cores
operator|=
operator|(
name|int
operator|)
name|sysconf
argument_list|(
name|_SC_NPROCESSORS_ONLN
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|cores
return|;
block|}
end_function
begin_function
DECL|function|yieldCurrentThread
name|void
name|QThread
operator|::
name|yieldCurrentThread
parameter_list|()
block|{
name|sched_yield
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|makeTimespec
specifier|static
name|timespec
name|makeTimespec
parameter_list|(
name|time_t
name|secs
parameter_list|,
name|long
name|nsecs
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
name|ts
operator|.
name|tv_sec
operator|=
name|secs
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
name|nsecs
expr_stmt|;
return|return
name|ts
return|;
block|}
end_function
begin_function
DECL|function|sleep
name|void
name|QThread
operator|::
name|sleep
parameter_list|(
name|unsigned
name|long
name|secs
parameter_list|)
block|{
name|qt_nanosleep
argument_list|(
name|makeTimespec
argument_list|(
name|secs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|msleep
name|void
name|QThread
operator|::
name|msleep
parameter_list|(
name|unsigned
name|long
name|msecs
parameter_list|)
block|{
name|qt_nanosleep
argument_list|(
name|makeTimespec
argument_list|(
name|msecs
operator|/
literal|1000
argument_list|,
name|msecs
operator|%
literal|1000
operator|*
literal|1000
operator|*
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|usleep
name|void
name|QThread
operator|::
name|usleep
parameter_list|(
name|unsigned
name|long
name|usecs
parameter_list|)
block|{
name|qt_nanosleep
argument_list|(
name|makeTimespec
argument_list|(
name|usecs
operator|/
literal|1000
operator|/
literal|1000
argument_list|,
name|usecs
operator|%
operator|(
literal|1000
operator|*
literal|1000
operator|)
operator|*
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_HAS_THREAD_PRIORITY_SCHEDULING
end_ifdef
begin_comment
comment|// Does some magic and calculate the Unix scheduler priorities
end_comment
begin_comment
comment|// sched_policy is IN/OUT: it must be set to a valid policy before calling this function
end_comment
begin_comment
comment|// sched_priority is OUT only
end_comment
begin_function
DECL|function|calculateUnixPriority
specifier|static
name|bool
name|calculateUnixPriority
parameter_list|(
name|int
name|priority
parameter_list|,
name|int
modifier|*
name|sched_policy
parameter_list|,
name|int
modifier|*
name|sched_priority
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SCHED_IDLE
if|if
condition|(
name|priority
operator|==
name|QThread
operator|::
name|IdlePriority
condition|)
block|{
operator|*
name|sched_policy
operator|=
name|SCHED_IDLE
expr_stmt|;
operator|*
name|sched_priority
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|const
name|int
name|lowestPriority
init|=
name|QThread
operator|::
name|LowestPriority
decl_stmt|;
else|#
directive|else
specifier|const
name|int
name|lowestPriority
init|=
name|QThread
operator|::
name|IdlePriority
decl_stmt|;
endif|#
directive|endif
specifier|const
name|int
name|highestPriority
init|=
name|QThread
operator|::
name|TimeCriticalPriority
decl_stmt|;
name|int
name|prio_min
init|=
name|sched_get_priority_min
argument_list|(
operator|*
name|sched_policy
argument_list|)
decl_stmt|;
name|int
name|prio_max
init|=
name|sched_get_priority_max
argument_list|(
operator|*
name|sched_policy
argument_list|)
decl_stmt|;
if|if
condition|(
name|prio_min
operator|==
operator|-
literal|1
operator|||
name|prio_max
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
name|int
name|prio
decl_stmt|;
comment|// crudely scale our priority enum values to the prio_min/prio_max
name|prio
operator|=
operator|(
operator|(
name|priority
operator|-
name|lowestPriority
operator|)
operator|*
operator|(
name|prio_max
operator|-
name|prio_min
operator|)
operator|/
name|highestPriority
operator|)
operator|+
name|prio_min
expr_stmt|;
name|prio
operator|=
name|qMax
argument_list|(
name|prio_min
argument_list|,
name|qMin
argument_list|(
name|prio_max
argument_list|,
name|prio
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|sched_priority
operator|=
name|prio
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|start
name|void
name|QThread
operator|::
name|start
parameter_list|(
name|Priority
name|priority
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QThread
argument_list|)
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|isInFinish
condition|)
name|d
operator|->
name|thread_done
operator|.
name|wait
argument_list|(
name|locker
operator|.
name|mutex
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|running
condition|)
return|return;
name|d
operator|->
name|running
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|finished
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|returnCode
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|exited
operator|=
literal|false
expr_stmt|;
name|pthread_attr_t
name|attr
decl_stmt|;
name|pthread_attr_init
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
name|pthread_attr_setdetachstate
argument_list|(
operator|&
name|attr
argument_list|,
name|PTHREAD_CREATE_DETACHED
argument_list|)
expr_stmt|;
name|d
operator|->
name|priority
operator|=
name|priority
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_HAS_THREAD_PRIORITY_SCHEDULING
argument_list|)
switch|switch
condition|(
name|priority
condition|)
block|{
case|case
name|InheritPriority
case|:
block|{
name|pthread_attr_setinheritsched
argument_list|(
operator|&
name|attr
argument_list|,
name|PTHREAD_INHERIT_SCHED
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|int
name|sched_policy
decl_stmt|;
if|if
condition|(
name|pthread_attr_getschedpolicy
argument_list|(
operator|&
name|attr
argument_list|,
operator|&
name|sched_policy
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|// failed to get the scheduling policy, don't bother
comment|// setting the priority
name|qWarning
argument_list|(
literal|"QThread::start: Cannot determine default scheduler policy"
argument_list|)
expr_stmt|;
break|break;
block|}
name|int
name|prio
decl_stmt|;
if|if
condition|(
operator|!
name|calculateUnixPriority
argument_list|(
name|priority
argument_list|,
operator|&
name|sched_policy
argument_list|,
operator|&
name|prio
argument_list|)
condition|)
block|{
comment|// failed to get the scheduling parameters, don't
comment|// bother setting the priority
name|qWarning
argument_list|(
literal|"QThread::start: Cannot determine scheduler priority range"
argument_list|)
expr_stmt|;
break|break;
block|}
name|sched_param
name|sp
decl_stmt|;
name|sp
operator|.
name|sched_priority
operator|=
name|prio
expr_stmt|;
if|if
condition|(
name|pthread_attr_setinheritsched
argument_list|(
operator|&
name|attr
argument_list|,
name|PTHREAD_EXPLICIT_SCHED
argument_list|)
operator|!=
literal|0
operator|||
name|pthread_attr_setschedpolicy
argument_list|(
operator|&
name|attr
argument_list|,
name|sched_policy
argument_list|)
operator|!=
literal|0
operator|||
name|pthread_attr_setschedparam
argument_list|(
operator|&
name|attr
argument_list|,
operator|&
name|sp
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|// could not set scheduling hints, fallback to inheriting them
comment|// we'll try again from inside the thread
name|pthread_attr_setinheritsched
argument_list|(
operator|&
name|attr
argument_list|,
name|PTHREAD_INHERIT_SCHED
argument_list|)
expr_stmt|;
name|d
operator|->
name|priority
operator|=
name|Priority
argument_list|(
name|priority
operator||
name|ThreadPriorityResetFlag
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
endif|#
directive|endif
comment|// QT_HAS_THREAD_PRIORITY_SCHEDULING
if|if
condition|(
name|d
operator|->
name|stackSize
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_THREAD_ATTR_STACKSIZE
argument_list|)
operator|&&
operator|(
name|_POSIX_THREAD_ATTR_STACKSIZE
operator|-
literal|0
operator|>
literal|0
operator|)
name|int
name|code
init|=
name|pthread_attr_setstacksize
argument_list|(
operator|&
name|attr
argument_list|,
name|d
operator|->
name|stackSize
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|code
init|=
name|ENOSYS
decl_stmt|;
comment|// stack size not supported, automatically fail
endif|#
directive|endif
comment|// _POSIX_THREAD_ATTR_STACKSIZE
if|if
condition|(
name|code
condition|)
block|{
name|qWarning
argument_list|(
literal|"QThread::start: Thread stack size error: %s"
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
name|code
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// we failed to set the stacksize, and as the documentation states,
comment|// the thread will fail to run...
name|d
operator|->
name|running
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|finished
operator|=
literal|false
expr_stmt|;
return|return;
block|}
block|}
name|int
name|code
init|=
name|pthread_create
argument_list|(
operator|&
name|d
operator|->
name|thread_id
argument_list|,
operator|&
name|attr
argument_list|,
name|QThreadPrivate
operator|::
name|start
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|EPERM
condition|)
block|{
comment|// caller does not have permission to set the scheduling
comment|// parameters/policy
if|#
directive|if
name|defined
argument_list|(
name|QT_HAS_THREAD_PRIORITY_SCHEDULING
argument_list|)
name|pthread_attr_setinheritsched
argument_list|(
operator|&
name|attr
argument_list|,
name|PTHREAD_INHERIT_SCHED
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|code
operator|=
name|pthread_create
argument_list|(
operator|&
name|d
operator|->
name|thread_id
argument_list|,
operator|&
name|attr
argument_list|,
name|QThreadPrivate
operator|::
name|start
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|pthread_attr_destroy
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
block|{
name|qWarning
argument_list|(
literal|"QThread::start: Thread creation error: %s"
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
name|code
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|running
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|finished
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|thread_id
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|terminate
name|void
name|QThread
operator|::
name|terminate
parameter_list|()
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_LINUX_ANDROID
argument_list|)
name|Q_D
argument_list|(
name|QThread
argument_list|)
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|thread_id
condition|)
return|return;
name|int
name|code
init|=
name|pthread_cancel
argument_list|(
name|d
operator|->
name|thread_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
condition|)
block|{
name|qWarning
argument_list|(
literal|"QThread::start: Thread termination error: %s"
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
operator|(
name|code
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|wait
name|bool
name|QThread
operator|::
name|wait
parameter_list|(
name|unsigned
name|long
name|time
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QThread
argument_list|)
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|thread_id
operator|==
name|pthread_self
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QThread::wait: Thread tried to wait on itself"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|finished
operator|||
operator|!
name|d
operator|->
name|running
condition|)
return|return
literal|true
return|;
while|while
condition|(
name|d
operator|->
name|running
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|thread_done
operator|.
name|wait
argument_list|(
name|locker
operator|.
name|mutex
argument_list|()
argument_list|,
name|time
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setTerminationEnabled
name|void
name|QThread
operator|::
name|setTerminationEnabled
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|QThread
modifier|*
name|thr
init|=
name|currentThread
argument_list|()
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
name|thr
operator|!=
literal|0
argument_list|,
literal|"QThread::setTerminationEnabled()"
argument_list|,
literal|"Current thread was not started with QThread."
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
argument|thr
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX_ANDROID
argument_list|)
name|Q_UNUSED
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
else|#
directive|else
name|pthread_setcancelstate
argument_list|(
name|enabled
condition|?
name|PTHREAD_CANCEL_ENABLE
else|:
name|PTHREAD_CANCEL_DISABLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabled
condition|)
name|pthread_testcancel
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|setPriority
name|void
name|QThread
operator|::
name|setPriority
parameter_list|(
name|Priority
name|priority
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QThread
argument_list|)
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|running
condition|)
block|{
name|qWarning
argument_list|(
literal|"QThread::setPriority: Cannot set priority, thread is not running"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|priority
operator|=
name|priority
expr_stmt|;
comment|// copied from start() with a few modifications:
ifdef|#
directive|ifdef
name|QT_HAS_THREAD_PRIORITY_SCHEDULING
name|int
name|sched_policy
decl_stmt|;
name|sched_param
name|param
decl_stmt|;
if|if
condition|(
name|pthread_getschedparam
argument_list|(
name|d
operator|->
name|thread_id
argument_list|,
operator|&
name|sched_policy
argument_list|,
operator|&
name|param
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|// failed to get the scheduling policy, don't bother setting
comment|// the priority
name|qWarning
argument_list|(
literal|"QThread::setPriority: Cannot get scheduler parameters"
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|prio
decl_stmt|;
if|if
condition|(
operator|!
name|calculateUnixPriority
argument_list|(
name|priority
argument_list|,
operator|&
name|sched_policy
argument_list|,
operator|&
name|prio
argument_list|)
condition|)
block|{
comment|// failed to get the scheduling parameters, don't
comment|// bother setting the priority
name|qWarning
argument_list|(
literal|"QThread::setPriority: Cannot determine scheduler priority range"
argument_list|)
expr_stmt|;
return|return;
block|}
name|param
operator|.
name|sched_priority
operator|=
name|prio
expr_stmt|;
name|int
name|status
init|=
name|pthread_setschedparam
argument_list|(
name|d
operator|->
name|thread_id
argument_list|,
name|sched_policy
argument_list|,
operator|&
name|param
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SCHED_IDLE
comment|// were we trying to set to idle priority and failed?
if|if
condition|(
name|status
operator|==
operator|-
literal|1
operator|&&
name|sched_policy
operator|==
name|SCHED_IDLE
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
block|{
comment|// reset to lowest priority possible
name|pthread_getschedparam
argument_list|(
name|d
operator|->
name|thread_id
argument_list|,
operator|&
name|sched_policy
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
name|param
operator|.
name|sched_priority
operator|=
name|sched_get_priority_min
argument_list|(
name|sched_policy
argument_list|)
expr_stmt|;
name|pthread_setschedparam
argument_list|(
name|d
operator|->
name|thread_id
argument_list|,
name|sched_policy
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// SCHED_IDLE
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_THREAD
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
