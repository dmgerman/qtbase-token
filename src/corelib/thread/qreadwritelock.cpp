begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Copyright (C) 2016 Intel Corporation. ** Copyright (C) 2016 Olivier Goffart<ogoffart@woboq.com> ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qreadwritelock.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_THREAD
end_ifndef
begin_include
include|#
directive|include
file|"qmutex.h"
end_include
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_include
include|#
directive|include
file|"qwaitcondition.h"
end_include
begin_include
include|#
directive|include
file|"qreadwritelock_p.h"
end_include
begin_include
include|#
directive|include
file|"qelapsedtimer.h"
end_include
begin_include
include|#
directive|include
file|"private/qfreelist_p.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*  * Implementation details of QReadWriteLock:  *  * Depending on the valued of d_ptr, the lock is in the following state:  *  - when d_ptr == 0x0: Unlocked (no readers, no writers) and non-recursive.  *  - when d_ptr& 0x1: If the least significant bit is set, we are locked for read.  *    In that case, d_ptr>>4 represents the number of reading threads minus 1. No writers  *    are waiting, and the lock is not recursive.  *  - when d_ptr == 0x2: We are locked for write and nobody is waiting. (no contention)  *  - In any other case, d_ptr points to an actual QReadWriteLockPrivate.  */
end_comment
begin_namespace
namespace|namespace
block|{
enum|enum
block|{
DECL|enumerator|StateMask
name|StateMask
init|=
literal|0x3
block|,
DECL|enumerator|StateLockedForRead
name|StateLockedForRead
init|=
literal|0x1
block|,
DECL|enumerator|StateLockedForWrite
name|StateLockedForWrite
init|=
literal|0x2
block|, }
enum|;
DECL|member|dummyLockedForRead
specifier|const
specifier|auto
name|dummyLockedForRead
init|=
cast|reinterpret_cast
argument_list|<
name|QReadWriteLockPrivate
operator|*
argument_list|>
argument_list|(
name|quintptr
argument_list|(
name|StateLockedForRead
argument_list|)
argument_list|)
decl_stmt|;
DECL|member|dummyLockedForWrite
specifier|const
specifier|auto
name|dummyLockedForWrite
init|=
cast|reinterpret_cast
argument_list|<
name|QReadWriteLockPrivate
operator|*
argument_list|>
argument_list|(
name|quintptr
argument_list|(
name|StateLockedForWrite
argument_list|)
argument_list|)
decl_stmt|;
DECL|function|isUncontendedLocked
specifier|inline
name|bool
name|isUncontendedLocked
parameter_list|(
specifier|const
name|QReadWriteLockPrivate
modifier|*
name|d
parameter_list|)
block|{
return|return
name|quintptr
argument_list|(
name|d
argument_list|)
operator|&
name|StateMask
return|;
block|}
block|}
end_namespace
begin_comment
comment|/*! \class QReadWriteLock     \inmodule QtCore     \brief The QReadWriteLock class provides read-write locking.      \threadsafe      \ingroup thread      A read-write lock is a synchronization tool for protecting     resources that can be accessed for reading and writing. This type     of lock is useful if you want to allow multiple threads to have     simultaneous read-only access, but as soon as one thread wants to     write to the resource, all other threads must be blocked until     the writing is complete.      In many cases, QReadWriteLock is a direct competitor to QMutex.     QReadWriteLock is a good choice if there are many concurrent     reads and writing occurs infrequently.      Example:      \snippet code/src_corelib_thread_qreadwritelock.cpp 0      To ensure that writers aren't blocked forever by readers, readers     attempting to obtain a lock will not succeed if there is a blocked     writer waiting for access, even if the lock is currently only     accessed by other readers. Also, if the lock is accessed by a     writer and another writer comes in, that writer will have     priority over any readers that might also be waiting.      Like QMutex, a QReadWriteLock can be recursively locked by the     same thread when constructed with \l{QReadWriteLock::Recursive} as     \l{QReadWriteLock::RecursionMode}. In such cases,     unlock() must be called the same number of times lockForWrite() or     lockForRead() was called. Note that the lock type cannot be     changed when trying to lock recursively, i.e. it is not possible     to lock for reading in a thread that already has locked for     writing (and vice versa).      \sa QReadLocker, QWriteLocker, QMutex, QSemaphore */
end_comment
begin_comment
comment|/*!     \enum QReadWriteLock::RecursionMode     \since 4.4      \value Recursive In this mode, a thread can lock the same     QReadWriteLock multiple times. The QReadWriteLock won't be unlocked     until a corresponding number of unlock() calls have been made.      \value NonRecursive In this mode, a thread may only lock a     QReadWriteLock once.      \sa QReadWriteLock() */
end_comment
begin_comment
comment|/*!     \since 4.4      Constructs a QReadWriteLock object in the given \a recursionMode.      The default recursion mode is NonRecursive.      \sa lockForRead(), lockForWrite(), RecursionMode */
end_comment
begin_constructor
DECL|function|QReadWriteLock
name|QReadWriteLock
operator|::
name|QReadWriteLock
parameter_list|(
name|RecursionMode
name|recursionMode
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
name|recursionMode
operator|==
name|Recursive
condition|?
operator|new
name|QReadWriteLockPrivate
argument_list|(
literal|true
argument_list|)
else|:
literal|nullptr
argument_list|)
block|{
name|Q_ASSERT_X
argument_list|(
operator|!
operator|(
name|quintptr
argument_list|(
name|d_ptr
operator|.
name|load
argument_list|()
argument_list|)
operator|&
name|StateMask
operator|)
argument_list|,
literal|"QReadWriteLock::QReadWriteLock"
argument_list|,
literal|"bad d_ptr alignment"
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the QReadWriteLock object.      \warning Destroying a read-write lock that is in use may result     in undefined behavior. */
end_comment
begin_destructor
DECL|function|~QReadWriteLock
name|QReadWriteLock
operator|::
name|~
name|QReadWriteLock
parameter_list|()
block|{
name|auto
name|d
init|=
name|d_ptr
operator|.
name|load
argument_list|()
decl_stmt|;
if|if
condition|(
name|isUncontendedLocked
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QReadWriteLock: destroying locked QReadWriteLock"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Locks the lock for reading. This function will block the current     thread if another thread has locked for writing.      It is not possible to lock for read if the thread already has     locked for write.      \sa unlock(), lockForWrite(), tryLockForRead() */
end_comment
begin_function
DECL|function|lockForRead
name|void
name|QReadWriteLock
operator|::
name|lockForRead
parameter_list|()
block|{
if|if
condition|(
name|d_ptr
operator|.
name|testAndSetAcquire
argument_list|(
literal|nullptr
argument_list|,
name|dummyLockedForRead
argument_list|)
condition|)
return|return;
name|tryLockForRead
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Attempts to lock for reading. If the lock was obtained, this     function returns \c true, otherwise it returns \c false instead of     waiting for the lock to become available, i.e. it does not block.      The lock attempt will fail if another thread has locked for     writing.      If the lock was obtained, the lock must be unlocked with unlock()     before another thread can successfully lock it for writing.      It is not possible to lock for read if the thread already has     locked for write.      \sa unlock(), lockForRead() */
end_comment
begin_function
DECL|function|tryLockForRead
name|bool
name|QReadWriteLock
operator|::
name|tryLockForRead
parameter_list|()
block|{
return|return
name|tryLockForRead
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \overload      Attempts to lock for reading. This function returns \c true if the     lock was obtained; otherwise it returns \c false. If another thread     has locked for writing, this function will wait for at most \a     timeout milliseconds for the lock to become available.      Note: Passing a negative number as the \a timeout is equivalent to     calling lockForRead(), i.e. this function will wait forever until     lock can be locked for reading when \a timeout is negative.      If the lock was obtained, the lock must be unlocked with unlock()     before another thread can successfully lock it for writing.      It is not possible to lock for read if the thread already has     locked for write.      \sa unlock(), lockForRead() */
end_comment
begin_function
DECL|function|tryLockForRead
name|bool
name|QReadWriteLock
operator|::
name|tryLockForRead
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
comment|// Fast case: non contended:
name|QReadWriteLockPrivate
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|d_ptr
operator|.
name|testAndSetAcquire
argument_list|(
literal|nullptr
argument_list|,
name|dummyLockedForRead
argument_list|,
name|d
argument_list|)
condition|)
return|return
literal|true
return|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|.
name|testAndSetAcquire
argument_list|(
literal|nullptr
argument_list|,
name|dummyLockedForRead
argument_list|,
name|d
argument_list|)
condition|)
continue|continue;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|(
name|quintptr
argument_list|(
name|d
argument_list|)
operator|&
name|StateMask
operator|)
operator|==
name|StateLockedForRead
condition|)
block|{
comment|// locked for read, increase the counter
specifier|const
specifier|auto
name|val
init|=
cast|reinterpret_cast
argument_list|<
name|QReadWriteLockPrivate
operator|*
argument_list|>
argument_list|(
name|quintptr
argument_list|(
name|d
argument_list|)
operator|+
operator|(
literal|1U
operator|<<
literal|4
operator|)
argument_list|)
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
name|quintptr
argument_list|(
name|val
argument_list|)
operator|>
operator|(
literal|1U
operator|<<
literal|4
operator|)
argument_list|,
literal|"QReadWriteLock::tryLockForRead()"
argument_list|,
literal|"Overflow in lock counter"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d_ptr
operator|.
name|testAndSetAcquire
argument_list|(
name|d
argument_list|,
name|val
argument_list|,
name|d
argument_list|)
condition|)
continue|continue;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|d
operator|==
name|dummyLockedForWrite
condition|)
block|{
comment|// locked for write, assign a d_ptr and wait.
name|auto
name|val
init|=
name|QReadWriteLockPrivate
operator|::
name|allocate
argument_list|()
decl_stmt|;
name|val
operator|->
name|writerCount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|d_ptr
operator|.
name|testAndSetOrdered
argument_list|(
name|d
argument_list|,
name|val
argument_list|,
name|d
argument_list|)
condition|)
block|{
name|val
operator|->
name|writerCount
operator|=
literal|0
expr_stmt|;
name|val
operator|->
name|release
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|d
operator|=
name|val
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
operator|!
name|isUncontendedLocked
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
comment|// d is an actual pointer;
if|if
condition|(
name|d
operator|->
name|recursive
condition|)
return|return
name|d
operator|->
name|recursiveLockForRead
argument_list|(
name|timeout
argument_list|)
return|;
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|!=
name|d_ptr
operator|.
name|load
argument_list|()
condition|)
block|{
comment|// d_ptr has changed: this QReadWriteLock was unlocked before we had
comment|// time to lock d->mutex.
comment|// We are holding a lock to a mutex within a QReadWriteLockPrivate
comment|// that is already released (or even is already re-used). That's ok
comment|// because the QFreeList never frees them.
comment|// Just unlock d->mutex (at the end of the scope) and retry.
name|d
operator|=
name|d_ptr
operator|.
name|loadAcquire
argument_list|()
expr_stmt|;
continue|continue;
block|}
return|return
name|d
operator|->
name|lockForRead
argument_list|(
name|timeout
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Locks the lock for writing. This function will block the current     thread if another thread (including the current) has locked for     reading or writing (unless the lock has been created using the     \l{QReadWriteLock::Recursive} mode).      It is not possible to lock for write if the thread already has     locked for read.      \sa unlock(), lockForRead(), tryLockForWrite() */
end_comment
begin_function
DECL|function|lockForWrite
name|void
name|QReadWriteLock
operator|::
name|lockForWrite
parameter_list|()
block|{
name|tryLockForWrite
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Attempts to lock for writing. If the lock was obtained, this     function returns \c true; otherwise, it returns \c false immediately.      The lock attempt will fail if another thread has locked for     reading or writing.      If the lock was obtained, the lock must be unlocked with unlock()     before another thread can successfully lock it.      It is not possible to lock for write if the thread already has     locked for read.      \sa unlock(), lockForWrite() */
end_comment
begin_function
DECL|function|tryLockForWrite
name|bool
name|QReadWriteLock
operator|::
name|tryLockForWrite
parameter_list|()
block|{
return|return
name|tryLockForWrite
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \overload      Attempts to lock for writing. This function returns \c true if the     lock was obtained; otherwise it returns \c false. If another thread     has locked for reading or writing, this function will wait for at     most \a timeout milliseconds for the lock to become available.      Note: Passing a negative number as the \a timeout is equivalent to     calling lockForWrite(), i.e. this function will wait forever until     lock can be locked for writing when \a timeout is negative.      If the lock was obtained, the lock must be unlocked with unlock()     before another thread can successfully lock it.      It is not possible to lock for write if the thread already has     locked for read.      \sa unlock(), lockForWrite() */
end_comment
begin_function
DECL|function|tryLockForWrite
name|bool
name|QReadWriteLock
operator|::
name|tryLockForWrite
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
comment|// Fast case: non contended:
name|QReadWriteLockPrivate
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|d_ptr
operator|.
name|testAndSetAcquire
argument_list|(
literal|nullptr
argument_list|,
name|dummyLockedForWrite
argument_list|,
name|d
argument_list|)
condition|)
return|return
literal|true
return|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|.
name|testAndSetAcquire
argument_list|(
name|d
argument_list|,
name|dummyLockedForWrite
argument_list|,
name|d
argument_list|)
condition|)
continue|continue;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|isUncontendedLocked
argument_list|(
name|d
argument_list|)
condition|)
block|{
comment|// locked for either read or write, assign a d_ptr and wait.
name|auto
name|val
init|=
name|QReadWriteLockPrivate
operator|::
name|allocate
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|==
name|dummyLockedForWrite
condition|)
name|val
operator|->
name|writerCount
operator|=
literal|1
expr_stmt|;
else|else
name|val
operator|->
name|readerCount
operator|=
operator|(
name|quintptr
argument_list|(
name|d
argument_list|)
operator|>>
literal|4
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|d_ptr
operator|.
name|testAndSetOrdered
argument_list|(
name|d
argument_list|,
name|val
argument_list|,
name|d
argument_list|)
condition|)
block|{
name|val
operator|->
name|writerCount
operator|=
name|val
operator|->
name|readerCount
operator|=
literal|0
expr_stmt|;
name|val
operator|->
name|release
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|d
operator|=
name|val
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
operator|!
name|isUncontendedLocked
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
comment|// d is an actual pointer;
if|if
condition|(
name|d
operator|->
name|recursive
condition|)
return|return
name|d
operator|->
name|recursiveLockForWrite
argument_list|(
name|timeout
argument_list|)
return|;
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|!=
name|d_ptr
operator|.
name|load
argument_list|()
condition|)
block|{
comment|// The mutex was unlocked before we had time to lock the mutex.
comment|// We are holding to a mutex within a QReadWriteLockPrivate that is already released
comment|// (or even is already re-used) but that's ok because the QFreeList never frees them.
name|d
operator|=
name|d_ptr
operator|.
name|loadAcquire
argument_list|()
expr_stmt|;
continue|continue;
block|}
return|return
name|d
operator|->
name|lockForWrite
argument_list|(
name|timeout
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Unlocks the lock.      Attempting to unlock a lock that is not locked is an error, and will result     in program termination.      \sa lockForRead(), lockForWrite(), tryLockForRead(), tryLockForWrite() */
end_comment
begin_function
DECL|function|unlock
name|void
name|QReadWriteLock
operator|::
name|unlock
parameter_list|()
block|{
name|QReadWriteLockPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|load
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Q_ASSERT_X
argument_list|(
name|d
argument_list|,
literal|"QReadWriteLock::unlock()"
argument_list|,
literal|"Cannot unlock an unlocked lock"
argument_list|)
expr_stmt|;
comment|// Fast case: no contention: (no waiters, no other readers)
if|if
condition|(
name|quintptr
argument_list|(
name|d
argument_list|)
operator|<=
literal|2
condition|)
block|{
comment|// 1 or 2 (StateLockedForRead or StateLockedForWrite)
if|if
condition|(
operator|!
name|d_ptr
operator|.
name|testAndSetRelease
argument_list|(
name|d
argument_list|,
literal|nullptr
argument_list|,
name|d
argument_list|)
condition|)
continue|continue;
return|return;
block|}
if|if
condition|(
operator|(
name|quintptr
argument_list|(
name|d
argument_list|)
operator|&
name|StateMask
operator|)
operator|==
name|StateLockedForRead
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|quintptr
argument_list|(
name|d
argument_list|)
operator|>
operator|(
literal|1U
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
comment|//otherwise that would be the fast case
comment|// Just decrease the reader's count.
name|auto
name|val
init|=
cast|reinterpret_cast
argument_list|<
name|QReadWriteLockPrivate
operator|*
argument_list|>
argument_list|(
name|quintptr
argument_list|(
name|d
argument_list|)
operator|-
operator|(
literal|1U
operator|<<
literal|4
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d_ptr
operator|.
name|testAndSetRelease
argument_list|(
name|d
argument_list|,
name|val
argument_list|,
name|d
argument_list|)
condition|)
continue|continue;
return|return;
block|}
name|Q_ASSERT
argument_list|(
operator|!
name|isUncontendedLocked
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|recursive
condition|)
block|{
name|d
operator|->
name|recursiveUnlock
argument_list|()
expr_stmt|;
return|return;
block|}
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|writerCount
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|writerCount
operator|==
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|readerCount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|writerCount
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|readerCount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|readerCount
operator|--
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|readerCount
operator|>
literal|0
condition|)
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|waitingReaders
operator|||
name|d
operator|->
name|waitingWriters
condition|)
block|{
name|d
operator|->
name|unlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|d_ptr
operator|.
name|load
argument_list|()
operator|==
name|d
argument_list|)
expr_stmt|;
comment|// should not change when we still hold the mutex
name|d_ptr
operator|.
name|storeRelease
argument_list|(
literal|nullptr
argument_list|)
expr_stmt|;
name|d
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
block|}
end_function
begin_comment
comment|/*! \internal  Helper for QWaitCondition::wait */
end_comment
begin_function
DECL|function|stateForWaitCondition
name|QReadWriteLock
operator|::
name|StateForWaitCondition
name|QReadWriteLock
operator|::
name|stateForWaitCondition
parameter_list|()
specifier|const
block|{
name|QReadWriteLockPrivate
modifier|*
name|d
init|=
name|d_ptr
operator|.
name|load
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|quintptr
argument_list|(
name|d
argument_list|)
operator|&
name|StateMask
condition|)
block|{
case|case
name|StateLockedForRead
case|:
return|return
name|LockedForRead
return|;
case|case
name|StateLockedForWrite
case|:
return|return
name|LockedForWrite
return|;
block|}
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|Unlocked
return|;
if|if
condition|(
name|d
operator|->
name|writerCount
operator|>
literal|1
condition|)
return|return
name|RecursivelyLocked
return|;
elseif|else
if|if
condition|(
name|d
operator|->
name|writerCount
operator|==
literal|1
condition|)
return|return
name|LockedForWrite
return|;
return|return
name|LockedForRead
return|;
block|}
end_function
begin_function
DECL|function|lockForRead
name|bool
name|QReadWriteLockPrivate
operator|::
name|lockForRead
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|mutex
operator|.
name|tryLock
argument_list|()
argument_list|)
expr_stmt|;
comment|// mutex must be locked when entering this function
name|QElapsedTimer
name|t
decl_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|waitingWriters
operator|||
name|writerCount
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|auto
name|elapsed
init|=
name|t
operator|.
name|elapsed
argument_list|()
decl_stmt|;
if|if
condition|(
name|elapsed
operator|>
name|timeout
condition|)
return|return
literal|false
return|;
name|waitingReaders
operator|++
expr_stmt|;
name|readerCond
operator|.
name|wait
argument_list|(
operator|&
name|mutex
argument_list|,
name|timeout
operator|-
name|elapsed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|waitingReaders
operator|++
expr_stmt|;
name|readerCond
operator|.
name|wait
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
block|}
name|waitingReaders
operator|--
expr_stmt|;
block|}
name|readerCount
operator|++
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|writerCount
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|lockForWrite
name|bool
name|QReadWriteLockPrivate
operator|::
name|lockForWrite
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|mutex
operator|.
name|tryLock
argument_list|()
argument_list|)
expr_stmt|;
comment|// mutex must be locked when entering this function
name|QElapsedTimer
name|t
decl_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|readerCount
operator|||
name|writerCount
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|auto
name|elapsed
init|=
name|t
operator|.
name|elapsed
argument_list|()
decl_stmt|;
if|if
condition|(
name|elapsed
operator|>
name|timeout
condition|)
block|{
if|if
condition|(
name|waitingReaders
operator|&&
operator|!
name|waitingWriters
operator|&&
operator|!
name|writerCount
condition|)
block|{
comment|// We timed out and now there is no more writers or waiting writers, but some
comment|// readers were queueud (probably because of us). Wake the waiting readers.
name|readerCond
operator|.
name|wakeAll
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
name|waitingWriters
operator|++
expr_stmt|;
name|writerCond
operator|.
name|wait
argument_list|(
operator|&
name|mutex
argument_list|,
name|timeout
operator|-
name|elapsed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|waitingWriters
operator|++
expr_stmt|;
name|writerCond
operator|.
name|wait
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
block|}
name|waitingWriters
operator|--
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|writerCount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|readerCount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|writerCount
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|unlock
name|void
name|QReadWriteLockPrivate
operator|::
name|unlock
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|mutex
operator|.
name|tryLock
argument_list|()
argument_list|)
expr_stmt|;
comment|// mutex must be locked when entering this function
if|if
condition|(
name|waitingWriters
condition|)
name|writerCond
operator|.
name|wakeOne
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|waitingReaders
condition|)
name|readerCond
operator|.
name|wakeAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|recursiveLockForRead
name|bool
name|QReadWriteLockPrivate
operator|::
name|recursiveLockForRead
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|recursive
argument_list|)
expr_stmt|;
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|HANDLE
name|self
init|=
name|QThread
operator|::
name|currentThreadId
argument_list|()
decl_stmt|;
name|auto
name|it
init|=
name|currentReaders
operator|.
name|find
argument_list|(
name|self
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|currentReaders
operator|.
name|end
argument_list|()
condition|)
block|{
operator|++
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|lockForRead
argument_list|(
name|timeout
argument_list|)
condition|)
return|return
literal|false
return|;
name|currentReaders
operator|.
name|insert
argument_list|(
name|self
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|recursiveLockForWrite
name|bool
name|QReadWriteLockPrivate
operator|::
name|recursiveLockForWrite
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|recursive
argument_list|)
expr_stmt|;
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|HANDLE
name|self
init|=
name|QThread
operator|::
name|currentThreadId
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentWriter
operator|==
name|self
condition|)
block|{
name|writerCount
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|lockForWrite
argument_list|(
name|timeout
argument_list|)
condition|)
return|return
literal|false
return|;
name|currentWriter
operator|=
name|self
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|recursiveUnlock
name|void
name|QReadWriteLockPrivate
operator|::
name|recursiveUnlock
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|recursive
argument_list|)
expr_stmt|;
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|HANDLE
name|self
init|=
name|QThread
operator|::
name|currentThreadId
argument_list|()
decl_stmt|;
if|if
condition|(
name|self
operator|==
name|currentWriter
condition|)
block|{
if|if
condition|(
operator|--
name|writerCount
operator|>
literal|0
condition|)
return|return;
name|currentWriter
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|auto
name|it
init|=
name|currentReaders
operator|.
name|find
argument_list|(
name|self
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|currentReaders
operator|.
name|end
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QReadWriteLock::unlock: unlocking from a thread that did not lock"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|--
name|it
operator|.
name|value
argument_list|()
operator|<=
literal|0
condition|)
block|{
name|currentReaders
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|readerCount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|readerCount
condition|)
return|return;
block|}
block|}
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// The freelist management
end_comment
begin_namespace
namespace|namespace
block|{
DECL|struct|FreeListConstants
struct|struct
name|FreeListConstants
super|:
name|QFreeListDefaultConstants
block|{
DECL|enumerator|BlockCount
DECL|enumerator|MaxIndex
enum|enum
block|{
name|BlockCount
init|=
literal|4
block|,
name|MaxIndex
init|=
literal|0xffff
block|}
enum|;
DECL|member|Sizes
specifier|static
specifier|const
name|int
name|Sizes
index|[
name|BlockCount
index|]
decl_stmt|;
block|}
struct|;
DECL|member|Sizes
specifier|const
name|int
name|FreeListConstants
operator|::
name|Sizes
index|[
name|FreeListConstants
operator|::
name|BlockCount
index|]
init|=
block|{
literal|16
block|,
literal|128
block|,
literal|1024
block|,
name|FreeListConstants
operator|::
name|MaxIndex
operator|-
operator|(
literal|16
operator|+
literal|128
operator|+
literal|1024
operator|)
block|}
decl_stmt|;
DECL|typedef|FreeList
typedef|typedef
name|QFreeList
argument_list|<
name|QReadWriteLockPrivate
argument_list|,
name|FreeListConstants
argument_list|>
name|FreeList
typedef|;
name|Q_GLOBAL_STATIC
argument_list|(
name|FreeList
argument_list|,
name|freelist
argument_list|)
expr_stmt|;
block|}
end_namespace
begin_function
DECL|function|allocate
name|QReadWriteLockPrivate
modifier|*
name|QReadWriteLockPrivate
operator|::
name|allocate
parameter_list|()
block|{
name|int
name|i
init|=
name|freelist
operator|->
name|next
argument_list|()
decl_stmt|;
name|QReadWriteLockPrivate
modifier|*
name|d
init|=
operator|&
operator|(
operator|*
name|freelist
operator|)
index|[
name|i
index|]
decl_stmt|;
name|d
operator|->
name|id
operator|=
name|i
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|d
operator|->
name|recursive
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|d
operator|->
name|waitingReaders
operator|&&
operator|!
name|d
operator|->
name|waitingReaders
operator|&&
operator|!
name|d
operator|->
name|readerCount
operator|&&
operator|!
name|d
operator|->
name|writerCount
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|release
name|void
name|QReadWriteLockPrivate
operator|::
name|release
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|recursive
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|waitingReaders
operator|&&
operator|!
name|waitingReaders
operator|&&
operator|!
name|readerCount
operator|&&
operator|!
name|writerCount
argument_list|)
expr_stmt|;
name|freelist
operator|->
name|release
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QReadLocker     \inmodule QtCore     \brief The QReadLocker class is a convenience class that     simplifies locking and unlocking read-write locks for read access.      \threadsafe      \ingroup thread      The purpose of QReadLocker (and QWriteLocker) is to simplify     QReadWriteLock locking and unlocking. Locking and unlocking     statements or in exception handling code is error-prone and     difficult to debug. QReadLocker can be used in such situations     to ensure that the state of the lock is always well-defined.      Here's an example that uses QReadLocker to lock and unlock a     read-write lock for reading:      \snippet code/src_corelib_thread_qreadwritelock.cpp 1      It is equivalent to the following code:      \snippet code/src_corelib_thread_qreadwritelock.cpp 2      The QMutexLocker documentation shows examples where the use of a     locker object greatly simplifies programming.      \sa QWriteLocker, QReadWriteLock */
end_comment
begin_comment
comment|/*!     \fn QReadLocker::QReadLocker(QReadWriteLock *lock)      Constructs a QReadLocker and locks \a lock for reading. The lock     will be unlocked when the QReadLocker is destroyed. If \c lock is     zero, QReadLocker does nothing.      \sa QReadWriteLock::lockForRead() */
end_comment
begin_comment
comment|/*!     \fn QReadLocker::~QReadLocker()      Destroys the QReadLocker and unlocks the lock that was passed to     the constructor.      \sa QReadWriteLock::unlock() */
end_comment
begin_comment
comment|/*!     \fn void QReadLocker::unlock()      Unlocks the lock associated with this locker.      \sa QReadWriteLock::unlock() */
end_comment
begin_comment
comment|/*!     \fn void QReadLocker::relock()      Relocks an unlocked lock.      \sa unlock() */
end_comment
begin_comment
comment|/*!     \fn QReadWriteLock *QReadLocker::readWriteLock() const      Returns a pointer to the read-write lock that was passed     to the constructor. */
end_comment
begin_comment
comment|/*!     \class QWriteLocker     \inmodule QtCore     \brief The QWriteLocker class is a convenience class that     simplifies locking and unlocking read-write locks for write access.      \threadsafe      \ingroup thread      The purpose of QWriteLocker (and QReadLocker) is to simplify     QReadWriteLock locking and unlocking. Locking and unlocking     statements or in exception handling code is error-prone and     difficult to debug. QWriteLocker can be used in such situations     to ensure that the state of the lock is always well-defined.      Here's an example that uses QWriteLocker to lock and unlock a     read-write lock for writing:      \snippet code/src_corelib_thread_qreadwritelock.cpp 3      It is equivalent to the following code:      \snippet code/src_corelib_thread_qreadwritelock.cpp 4      The QMutexLocker documentation shows examples where the use of a     locker object greatly simplifies programming.      \sa QReadLocker, QReadWriteLock */
end_comment
begin_comment
comment|/*!     \fn QWriteLocker::QWriteLocker(QReadWriteLock *lock)      Constructs a QWriteLocker and locks \a lock for writing. The lock     will be unlocked when the QWriteLocker is destroyed. If \c lock is     zero, QWriteLocker does nothing.      \sa QReadWriteLock::lockForWrite() */
end_comment
begin_comment
comment|/*!     \fn QWriteLocker::~QWriteLocker()      Destroys the QWriteLocker and unlocks the lock that was passed to     the constructor.      \sa QReadWriteLock::unlock() */
end_comment
begin_comment
comment|/*!     \fn void QWriteLocker::unlock()      Unlocks the lock associated with this locker.      \sa QReadWriteLock::unlock() */
end_comment
begin_comment
comment|/*!     \fn void QWriteLocker::relock()      Relocks an unlocked lock.      \sa unlock() */
end_comment
begin_comment
comment|/*!     \fn QReadWriteLock *QWriteLocker::readWriteLock() const      Returns a pointer to the read-write lock that was passed     to the constructor. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_THREAD
end_comment
end_unit
