begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QSequentialAnimationGroup     \inmodule QtCore     \brief The QSequentialAnimationGroup class provides a sequential group of animations.     \since 4.6     \ingroup animation      QSequentialAnimationGroup is a QAnimationGroup that runs its     animations in sequence, i.e., it starts one animation after     another has finished playing. The animations are played in the     order they are added to the group (using     \l{QAnimationGroup::}{addAnimation()} or     \l{QAnimationGroup::}{insertAnimation()}). The animation group     finishes when its last animation has finished.      At each moment there is at most one animation that is active in     the group; it is returned by currentAnimation(). An empty group     has no current animation.      A sequential animation group can be treated as any other     animation, i.e., it can be started, stopped, and added to other     groups. You can also call addPause() or insertPause() to add a     pause to a sequential animation group.      \code         QSequentialAnimationGroup *group = new QSequentialAnimationGroup;          group->addAnimation(anim1);         group->addAnimation(anim2);          group->start();     \endcode      In this example, \c anim1 and \c anim2 are two already set up     \l{QPropertyAnimation}s.      \sa QAnimationGroup, QAbstractAnimation, {The Animation Framework} */
end_comment
begin_include
include|#
directive|include
file|"qsequentialanimationgroup.h"
end_include
begin_include
include|#
directive|include
file|"qsequentialanimationgroup_p.h"
end_include
begin_include
include|#
directive|include
file|"qpauseanimation.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
end_ifndef
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|atEnd
name|bool
name|QSequentialAnimationGroupPrivate
operator|::
name|atEnd
parameter_list|()
specifier|const
block|{
comment|// we try to detect if we're at the end of the group
comment|//this is true if the following conditions are true:
comment|// 1. we're in the last loop
comment|// 2. the direction is forward
comment|// 3. the current animation is the last one
comment|// 4. the current animation has reached its end
specifier|const
name|int
name|animTotalCurrentTime
init|=
name|QAbstractAnimationPrivate
operator|::
name|get
argument_list|(
name|currentAnimation
argument_list|)
operator|->
name|totalCurrentTime
decl_stmt|;
return|return
operator|(
name|currentLoop
operator|==
name|loopCount
operator|-
literal|1
operator|&&
name|direction
operator|==
name|QAbstractAnimation
operator|::
name|Forward
operator|&&
name|currentAnimation
operator|==
name|animations
operator|.
name|last
argument_list|()
operator|&&
name|animTotalCurrentTime
operator|==
name|animationActualTotalDuration
argument_list|(
name|currentAnimationIndex
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|animationActualTotalDuration
name|int
name|QSequentialAnimationGroupPrivate
operator|::
name|animationActualTotalDuration
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|QAbstractAnimation
modifier|*
name|anim
init|=
name|animations
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
name|anim
operator|->
name|totalDuration
argument_list|()
decl_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|actualDuration
operator|.
name|size
argument_list|()
operator|>
name|index
condition|)
name|ret
operator|=
name|actualDuration
operator|.
name|at
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|//we can try the actual duration there
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|indexForCurrentTime
name|QSequentialAnimationGroupPrivate
operator|::
name|AnimationIndex
name|QSequentialAnimationGroupPrivate
operator|::
name|indexForCurrentTime
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|animations
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|AnimationIndex
name|ret
decl_stmt|;
name|int
name|duration
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|animations
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|duration
operator|=
name|animationActualTotalDuration
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// 'animation' is the current animation if one of these reasons is true:
comment|// 1. it's duration is undefined
comment|// 2. it ends after msecs
comment|// 3. it is the last animation (this can happen in case there is at least 1 uncontrolled animation)
comment|// 4. it ends exactly in msecs and the direction is backwards
if|if
condition|(
name|duration
operator|==
operator|-
literal|1
operator|||
name|currentTime
operator|<
operator|(
name|ret
operator|.
name|timeOffset
operator|+
name|duration
operator|)
operator|||
operator|(
name|currentTime
operator|==
operator|(
name|ret
operator|.
name|timeOffset
operator|+
name|duration
operator|)
operator|&&
name|direction
operator|==
name|QAbstractAnimation
operator|::
name|Backward
operator|)
condition|)
block|{
name|ret
operator|.
name|index
operator|=
name|i
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|// 'animation' has a non-null defined duration and is not the one at time 'msecs'.
name|ret
operator|.
name|timeOffset
operator|+=
name|duration
expr_stmt|;
block|}
comment|// this can only happen when one of those conditions is true:
comment|// 1. the duration of the group is undefined and we passed its actual duration
comment|// 2. there are only 0-duration animations in the group
name|ret
operator|.
name|timeOffset
operator|-=
name|duration
expr_stmt|;
name|ret
operator|.
name|index
operator|=
name|animations
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|restart
name|void
name|QSequentialAnimationGroupPrivate
operator|::
name|restart
parameter_list|()
block|{
comment|// restarting the group by making the first/last animation the current one
if|if
condition|(
name|direction
operator|==
name|QAbstractAnimation
operator|::
name|Forward
condition|)
block|{
name|lastLoop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|currentAnimationIndex
operator|==
literal|0
condition|)
name|activateCurrentAnimation
argument_list|()
expr_stmt|;
else|else
name|setCurrentAnimation
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// direction == QAbstractAnimation::Backward
name|lastLoop
operator|=
name|loopCount
operator|-
literal|1
expr_stmt|;
name|int
name|index
init|=
name|animations
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|currentAnimationIndex
operator|==
name|index
condition|)
name|activateCurrentAnimation
argument_list|()
expr_stmt|;
else|else
name|setCurrentAnimation
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     This manages advancing the execution of a group running forwards (time has gone forward),     which is the same behaviour for rewinding the execution of a group running backwards     (time has gone backward). */
end_comment
begin_function
DECL|function|advanceForwards
name|void
name|QSequentialAnimationGroupPrivate
operator|::
name|advanceForwards
parameter_list|(
specifier|const
name|AnimationIndex
modifier|&
name|newAnimationIndex
parameter_list|)
block|{
if|if
condition|(
name|lastLoop
operator|<
name|currentLoop
condition|)
block|{
comment|// we need to fast forward to the end
for|for
control|(
name|int
name|i
init|=
name|currentAnimationIndex
init|;
name|i
operator|<
name|animations
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractAnimation
modifier|*
name|anim
init|=
name|animations
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|setCurrentAnimation
argument_list|(
name|i
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|anim
operator|->
name|setCurrentTime
argument_list|(
name|animationActualTotalDuration
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// this will make sure the current animation is reset to the beginning
if|if
condition|(
name|animations
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
comment|// we need to force activation because setCurrentAnimation will have no effect
name|activateCurrentAnimation
argument_list|()
expr_stmt|;
else|else
name|setCurrentAnimation
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// and now we need to fast forward from the current position to
for|for
control|(
name|int
name|i
init|=
name|currentAnimationIndex
init|;
name|i
operator|<
name|newAnimationIndex
operator|.
name|index
condition|;
operator|++
name|i
control|)
block|{
comment|//### WRONG,
name|QAbstractAnimation
modifier|*
name|anim
init|=
name|animations
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|setCurrentAnimation
argument_list|(
name|i
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|anim
operator|->
name|setCurrentTime
argument_list|(
name|animationActualTotalDuration
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// setting the new current animation will happen later
block|}
end_function
begin_comment
comment|/*!     \internal     This manages rewinding the execution of a group running forwards (time has gone forward),     which is the same behaviour for advancing the execution of a group running backwards     (time has gone backward). */
end_comment
begin_function
DECL|function|rewindForwards
name|void
name|QSequentialAnimationGroupPrivate
operator|::
name|rewindForwards
parameter_list|(
specifier|const
name|AnimationIndex
modifier|&
name|newAnimationIndex
parameter_list|)
block|{
if|if
condition|(
name|lastLoop
operator|>
name|currentLoop
condition|)
block|{
comment|// we need to fast rewind to the beginning
for|for
control|(
name|int
name|i
init|=
name|currentAnimationIndex
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QAbstractAnimation
modifier|*
name|anim
init|=
name|animations
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|setCurrentAnimation
argument_list|(
name|i
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|anim
operator|->
name|setCurrentTime
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// this will make sure the current animation is reset to the end
if|if
condition|(
name|animations
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
comment|// we need to force activation because setCurrentAnimation will have no effect
name|activateCurrentAnimation
argument_list|()
expr_stmt|;
else|else
name|setCurrentAnimation
argument_list|(
name|animations
operator|.
name|count
argument_list|()
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// and now we need to fast rewind from the current position to
for|for
control|(
name|int
name|i
init|=
name|currentAnimationIndex
init|;
name|i
operator|>
name|newAnimationIndex
operator|.
name|index
condition|;
operator|--
name|i
control|)
block|{
name|QAbstractAnimation
modifier|*
name|anim
init|=
name|animations
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|setCurrentAnimation
argument_list|(
name|i
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|anim
operator|->
name|setCurrentTime
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// setting the new current animation will happen later
block|}
end_function
begin_comment
comment|/*!     \fn QSequentialAnimationGroup::currentAnimationChanged(QAbstractAnimation *current)      QSequentialAnimationGroup emits this signal when currentAnimation     has been changed. \a current is the current animation.      \sa currentAnimation() */
end_comment
begin_comment
comment|/*!     Constructs a QSequentialAnimationGroup.     \a parent is passed to QObject's constructor. */
end_comment
begin_constructor
DECL|function|QSequentialAnimationGroup
name|QSequentialAnimationGroup
operator|::
name|QSequentialAnimationGroup
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAnimationGroup
argument_list|(
operator|*
operator|new
name|QSequentialAnimationGroupPrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QSequentialAnimationGroup
name|QSequentialAnimationGroup
operator|::
name|QSequentialAnimationGroup
parameter_list|(
name|QSequentialAnimationGroupPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAnimationGroup
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the animation group. It will also destroy all its animations. */
end_comment
begin_destructor
DECL|function|~QSequentialAnimationGroup
name|QSequentialAnimationGroup
operator|::
name|~
name|QSequentialAnimationGroup
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Adds a pause of \a msecs to this animation group.     The pause is considered as a special type of animation, thus      \l{QAnimationGroup::animationCount()}{animationCount} will be      increased by one.      \sa insertPause(), QAnimationGroup::addAnimation() */
end_comment
begin_function
DECL|function|addPause
name|QPauseAnimation
modifier|*
name|QSequentialAnimationGroup
operator|::
name|addPause
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|QPauseAnimation
modifier|*
name|pause
init|=
operator|new
name|QPauseAnimation
argument_list|(
name|msecs
argument_list|)
decl_stmt|;
name|addAnimation
argument_list|(
name|pause
argument_list|)
expr_stmt|;
return|return
name|pause
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts a pause of \a msecs milliseconds at \a index in this animation     group.      \sa addPause(), QAnimationGroup::insertAnimation() */
end_comment
begin_function
DECL|function|insertPause
name|QPauseAnimation
modifier|*
name|QSequentialAnimationGroup
operator|::
name|insertPause
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
specifier|const
name|QSequentialAnimationGroup
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|<
literal|0
operator|||
name|index
argument_list|>
name|d
operator|->
name|animations
operator|.
name|size
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSequentialAnimationGroup::insertPause: index is out of bounds"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|QPauseAnimation
modifier|*
name|pause
init|=
operator|new
name|QPauseAnimation
argument_list|(
name|msecs
argument_list|)
decl_stmt|;
name|insertAnimation
argument_list|(
name|index
argument_list|,
name|pause
argument_list|)
expr_stmt|;
return|return
name|pause
return|;
block|}
end_function
begin_comment
comment|/*!     \property QSequentialAnimationGroup::currentAnimation     Returns the animation in the current time.      \sa currentAnimationChanged() */
end_comment
begin_function
DECL|function|currentAnimation
name|QAbstractAnimation
modifier|*
name|QSequentialAnimationGroup
operator|::
name|currentAnimation
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSequentialAnimationGroup
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|currentAnimation
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|duration
name|int
name|QSequentialAnimationGroup
operator|::
name|duration
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSequentialAnimationGroup
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|animations
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractAnimation
modifier|*
name|animation
init|=
name|d
operator|->
name|animations
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|int
name|currentDuration
init|=
name|animation
operator|->
name|totalDuration
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentDuration
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|// Undetermined length
name|ret
operator|+=
name|currentDuration
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|updateCurrentTime
name|void
name|QSequentialAnimationGroup
operator|::
name|updateCurrentTime
parameter_list|(
name|int
name|currentTime
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSequentialAnimationGroup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|currentAnimation
condition|)
return|return;
specifier|const
name|QSequentialAnimationGroupPrivate
operator|::
name|AnimationIndex
name|newAnimationIndex
init|=
name|d
operator|->
name|indexForCurrentTime
argument_list|()
decl_stmt|;
comment|// remove unneeded animations from actualDuration list
while|while
condition|(
name|newAnimationIndex
operator|.
name|index
operator|<
name|d
operator|->
name|actualDuration
operator|.
name|size
argument_list|()
condition|)
name|d
operator|->
name|actualDuration
operator|.
name|removeLast
argument_list|()
expr_stmt|;
comment|// newAnimationIndex.index is the new current animation
if|if
condition|(
name|d
operator|->
name|lastLoop
operator|<
name|d
operator|->
name|currentLoop
operator|||
operator|(
name|d
operator|->
name|lastLoop
operator|==
name|d
operator|->
name|currentLoop
operator|&&
name|d
operator|->
name|currentAnimationIndex
operator|<
name|newAnimationIndex
operator|.
name|index
operator|)
condition|)
block|{
comment|// advancing with forward direction is the same as rewinding with backwards direction
name|d
operator|->
name|advanceForwards
argument_list|(
name|newAnimationIndex
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|lastLoop
operator|>
name|d
operator|->
name|currentLoop
operator|||
operator|(
name|d
operator|->
name|lastLoop
operator|==
name|d
operator|->
name|currentLoop
operator|&&
name|d
operator|->
name|currentAnimationIndex
operator|>
name|newAnimationIndex
operator|.
name|index
operator|)
condition|)
block|{
comment|// rewinding with forward direction is the same as advancing with backwards direction
name|d
operator|->
name|rewindForwards
argument_list|(
name|newAnimationIndex
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|setCurrentAnimation
argument_list|(
name|newAnimationIndex
operator|.
name|index
argument_list|)
expr_stmt|;
specifier|const
name|int
name|newCurrentTime
init|=
name|currentTime
operator|-
name|newAnimationIndex
operator|.
name|timeOffset
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|currentAnimation
condition|)
block|{
name|d
operator|->
name|currentAnimation
operator|->
name|setCurrentTime
argument_list|(
name|newCurrentTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|atEnd
argument_list|()
condition|)
block|{
comment|//we make sure that we don't exceed the duration here
name|d
operator|->
name|currentTime
operator|+=
name|QAbstractAnimationPrivate
operator|::
name|get
argument_list|(
name|d
operator|->
name|currentAnimation
argument_list|)
operator|->
name|totalCurrentTime
operator|-
name|newCurrentTime
expr_stmt|;
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//the only case where currentAnimation could be null
comment|//is when all animations have been removed
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|animations
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|currentTime
operator|=
literal|0
expr_stmt|;
name|stop
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|lastLoop
operator|=
name|d
operator|->
name|currentLoop
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|updateState
name|void
name|QSequentialAnimationGroup
operator|::
name|updateState
parameter_list|(
name|QAbstractAnimation
operator|::
name|State
name|newState
parameter_list|,
name|QAbstractAnimation
operator|::
name|State
name|oldState
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSequentialAnimationGroup
argument_list|)
expr_stmt|;
name|QAnimationGroup
operator|::
name|updateState
argument_list|(
name|newState
argument_list|,
name|oldState
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|currentAnimation
condition|)
return|return;
switch|switch
condition|(
name|newState
condition|)
block|{
case|case
name|Stopped
case|:
name|d
operator|->
name|currentAnimation
operator|->
name|stop
argument_list|()
expr_stmt|;
break|break;
case|case
name|Paused
case|:
if|if
condition|(
name|oldState
operator|==
name|d
operator|->
name|currentAnimation
operator|->
name|state
argument_list|()
operator|&&
name|oldState
operator|==
name|QSequentialAnimationGroup
operator|::
name|Running
condition|)
block|{
name|d
operator|->
name|currentAnimation
operator|->
name|pause
argument_list|()
expr_stmt|;
block|}
else|else
name|d
operator|->
name|restart
argument_list|()
expr_stmt|;
break|break;
case|case
name|Running
case|:
if|if
condition|(
name|oldState
operator|==
name|d
operator|->
name|currentAnimation
operator|->
name|state
argument_list|()
operator|&&
name|oldState
operator|==
name|QSequentialAnimationGroup
operator|::
name|Paused
condition|)
name|d
operator|->
name|currentAnimation
operator|->
name|start
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|restart
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|updateDirection
name|void
name|QSequentialAnimationGroup
operator|::
name|updateDirection
parameter_list|(
name|QAbstractAnimation
operator|::
name|Direction
name|direction
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSequentialAnimationGroup
argument_list|)
expr_stmt|;
comment|// we need to update the direction of the current animation
if|if
condition|(
name|state
argument_list|()
operator|!=
name|Stopped
operator|&&
name|d
operator|->
name|currentAnimation
condition|)
name|d
operator|->
name|currentAnimation
operator|->
name|setDirection
argument_list|(
name|direction
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QSequentialAnimationGroup
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
return|return
name|QAnimationGroup
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setCurrentAnimation
name|void
name|QSequentialAnimationGroupPrivate
operator|::
name|setCurrentAnimation
parameter_list|(
name|int
name|index
parameter_list|,
name|bool
name|intermediate
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSequentialAnimationGroup
argument_list|)
expr_stmt|;
name|index
operator|=
name|qMin
argument_list|(
name|index
argument_list|,
name|animations
operator|.
name|count
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|animations
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|currentAnimationIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|currentAnimation
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|// need these two checks below because this func can be called after the current animation
comment|// has been removed
if|if
condition|(
name|index
operator|==
name|currentAnimationIndex
operator|&&
name|animations
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|==
name|currentAnimation
condition|)
return|return;
comment|// stop the old current animation
if|if
condition|(
name|currentAnimation
condition|)
name|currentAnimation
operator|->
name|stop
argument_list|()
expr_stmt|;
name|currentAnimation
operator|=
name|animations
operator|.
name|at
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|currentAnimationIndex
operator|=
name|index
expr_stmt|;
emit|emit
name|q
operator|->
name|currentAnimationChanged
argument_list|(
name|currentAnimation
argument_list|)
emit|;
name|activateCurrentAnimation
argument_list|(
name|intermediate
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|activateCurrentAnimation
name|void
name|QSequentialAnimationGroupPrivate
operator|::
name|activateCurrentAnimation
parameter_list|(
name|bool
name|intermediate
parameter_list|)
block|{
if|if
condition|(
operator|!
name|currentAnimation
operator|||
name|state
operator|==
name|QSequentialAnimationGroup
operator|::
name|Stopped
condition|)
return|return;
name|currentAnimation
operator|->
name|stop
argument_list|()
expr_stmt|;
comment|// we ensure the direction is consistent with the group's direction
name|currentAnimation
operator|->
name|setDirection
argument_list|(
name|direction
argument_list|)
expr_stmt|;
comment|// connects to the finish signal of uncontrolled animations
if|if
condition|(
name|currentAnimation
operator|->
name|totalDuration
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|connectUncontrolledAnimation
argument_list|(
name|currentAnimation
argument_list|)
expr_stmt|;
name|currentAnimation
operator|->
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|intermediate
operator|&&
name|state
operator|==
name|QSequentialAnimationGroup
operator|::
name|Paused
condition|)
name|currentAnimation
operator|->
name|pause
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_uncontrolledAnimationFinished
name|void
name|QSequentialAnimationGroupPrivate
operator|::
name|_q_uncontrolledAnimationFinished
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSequentialAnimationGroup
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|qobject_cast
argument_list|<
name|QAbstractAnimation
operator|*
argument_list|>
argument_list|(
name|q
operator|->
name|sender
argument_list|()
argument_list|)
operator|==
name|currentAnimation
argument_list|)
expr_stmt|;
comment|// we trust the duration returned by the animation
while|while
condition|(
name|actualDuration
operator|.
name|size
argument_list|()
operator|<
operator|(
name|currentAnimationIndex
operator|+
literal|1
operator|)
condition|)
name|actualDuration
operator|.
name|append
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|actualDuration
index|[
name|currentAnimationIndex
index|]
operator|=
name|currentAnimation
operator|->
name|currentTime
argument_list|()
expr_stmt|;
name|disconnectUncontrolledAnimation
argument_list|(
name|currentAnimation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|direction
operator|==
name|QAbstractAnimation
operator|::
name|Forward
operator|&&
name|currentAnimation
operator|==
name|animations
operator|.
name|last
argument_list|()
operator|)
operator|||
operator|(
name|direction
operator|==
name|QAbstractAnimation
operator|::
name|Backward
operator|&&
name|currentAnimationIndex
operator|==
literal|0
operator|)
condition|)
block|{
comment|// we don't handle looping of a group with undefined duration
name|q
operator|->
name|stop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|direction
operator|==
name|QAbstractAnimation
operator|::
name|Forward
condition|)
block|{
comment|// set the current animation to be the next one
name|setCurrentAnimation
argument_list|(
name|currentAnimationIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// set the current animation to be the previous one
name|setCurrentAnimation
argument_list|(
name|currentAnimationIndex
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     This method is called whenever an animation is added to     the group at index \a index.     Note: We only support insertion after the current animation */
end_comment
begin_function
DECL|function|animationInsertedAt
name|void
name|QSequentialAnimationGroupPrivate
operator|::
name|animationInsertedAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|currentAnimation
operator|==
literal|0
condition|)
name|setCurrentAnimation
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// initialize the current animation
if|if
condition|(
name|currentAnimationIndex
operator|==
name|index
operator|&&
name|currentAnimation
operator|->
name|currentTime
argument_list|()
operator|==
literal|0
operator|&&
name|currentAnimation
operator|->
name|currentLoop
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|//in this case we simply insert an animation before the current one has actually started
name|setCurrentAnimation
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
comment|//we update currentAnimationIndex in case it has changed (the animation pointer is still valid)
name|currentAnimationIndex
operator|=
name|animations
operator|.
name|indexOf
argument_list|(
name|currentAnimation
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|currentAnimationIndex
operator|||
name|currentLoop
operator|!=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSequentialGroup::insertAnimation only supports to add animations after the current one."
argument_list|)
expr_stmt|;
return|return;
comment|//we're not affected because it is added after the current one
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     This method is called whenever an animation is removed from     the group at index \a index. The animation is no more listed when this     method is called. */
end_comment
begin_function
DECL|function|animationRemoved
name|void
name|QSequentialAnimationGroupPrivate
operator|::
name|animationRemoved
parameter_list|(
name|int
name|index
parameter_list|,
name|QAbstractAnimation
modifier|*
name|anim
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSequentialAnimationGroup
argument_list|)
expr_stmt|;
name|QAnimationGroupPrivate
operator|::
name|animationRemoved
argument_list|(
name|index
argument_list|,
name|anim
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|currentAnimation
argument_list|)
expr_stmt|;
comment|// currentAnimation should always be set
if|if
condition|(
name|actualDuration
operator|.
name|size
argument_list|()
operator|>
name|index
condition|)
name|actualDuration
operator|.
name|removeAt
argument_list|(
name|index
argument_list|)
expr_stmt|;
specifier|const
name|int
name|currentIndex
init|=
name|animations
operator|.
name|indexOf
argument_list|(
name|currentAnimation
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentIndex
operator|==
operator|-
literal|1
condition|)
block|{
comment|//we're removing the current animation
name|disconnectUncontrolledAnimation
argument_list|(
name|currentAnimation
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|animations
operator|.
name|count
argument_list|()
condition|)
name|setCurrentAnimation
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|//let's try to take the next one
elseif|else
if|if
condition|(
name|index
operator|>
literal|0
condition|)
name|setCurrentAnimation
argument_list|(
name|index
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
comment|// case all animations were removed
name|setCurrentAnimation
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentAnimationIndex
operator|>
name|index
condition|)
block|{
name|currentAnimationIndex
operator|--
expr_stmt|;
block|}
comment|// duration of the previous animations up to the current animation
name|currentTime
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|currentAnimationIndex
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|current
init|=
name|animationActualTotalDuration
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|currentTime
operator|+=
name|current
expr_stmt|;
block|}
if|if
condition|(
name|currentIndex
operator|!=
operator|-
literal|1
condition|)
block|{
comment|//the current animation is not the one being removed
comment|//so we add its current time to the current time of this group
name|currentTime
operator|+=
name|QAbstractAnimationPrivate
operator|::
name|get
argument_list|(
name|currentAnimation
argument_list|)
operator|->
name|totalCurrentTime
expr_stmt|;
block|}
comment|//let's also update the total current time
name|totalCurrentTime
operator|=
name|currentTime
operator|+
name|loopCount
operator|*
name|q
operator|->
name|duration
argument_list|()
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qsequentialanimationgroup.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_ANIMATION
end_comment
end_unit
