begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qvariantanimation.h"
end_include
begin_include
include|#
directive|include
file|"qvariantanimation_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qrect.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qline.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmutex.h>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
end_ifndef
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QVariantAnimation     \inmodule QtCore     \ingroup animation     \brief The QVariantAnimation class provides an abstract base class for animations.     \since 4.6      This class is part of \l{The Animation Framework}. It serves as a     base class for property and item animations, with functions for     shared functionality.      QVariantAnimation cannot be used directly as it is an abstract     class; it has a pure virtual method called updateCurrentValue().     The class performs interpolation over     \l{QVariant}s, but leaves using the interpolated values to its     subclasses. Currently, Qt provides QPropertyAnimation, which     animates Qt \l{Qt's Property System}{properties}. See the     QPropertyAnimation class description if you wish to animate such     properties.      You can then set start and end values for the property by calling     setStartValue() and setEndValue(), and finally call start() to     start the animation. QVariantAnimation will interpolate the     property of the target object and emit valueChanged(). To react to     a change in the current value you have to reimplement the     updateCurrentValue() virtual function.      It is also possible to set values at specified steps situated     between the start and end value. The interpolation will then     touch these points at the specified steps. Note that the start and     end values are defined as the key values at 0.0 and 1.0.      There are two ways to affect how QVariantAnimation interpolates     the values. You can set an easing curve by calling     setEasingCurve(), and configure the duration by calling     setDuration(). You can change how the QVariants are interpolated     by creating a subclass of QVariantAnimation, and reimplementing     the virtual interpolated() function.      Subclassing QVariantAnimation can be an alternative if you have     \l{QVariant}s that you do not wish to declare as Qt properties.     Note, however, that you in most cases will be better off declaring     your QVariant as a property.      Not all QVariant types are supported. Below is a list of currently     supported QVariant types:      \list         \li \l{QMetaType::}{Int}         \li \l{QMetaType::}{Double}         \li \l{QMetaType::}{Float}         \li \l{QMetaType::}{QLine}         \li \l{QMetaType::}{QLineF}         \li \l{QMetaType::}{QPoint}         \li \l{QMetaType::}{QPointF}         \li \l{QMetaType::}{QSize}         \li \l{QMetaType::}{QSizeF}         \li \l{QMetaType::}{QRect}         \li \l{QMetaType::}{QRectF}         \li \l{QMetaType::}{QColor}     \endlist      If you need to interpolate other variant types, including custom     types, you have to implement interpolation for these yourself.     To do this, you can register an interpolator function for a given     type. This function takes 3 parameters: the start value, the end value     and the current progress.      Example:     \code         QVariant myColorInterpolator(const QColor&start, const QColor&end, qreal progress)         {             ...             return QColor(...);         }         ...         qRegisterAnimationInterpolator<QColor>(myColorInterpolator);     \endcode      Another option is to reimplement interpolated(), which returns     interpolation values for the value being interpolated.      \omit We need some snippets around here. \endomit      \sa QPropertyAnimation, QAbstractAnimation, {The Animation Framework} */
comment|/*!     \fn void QVariantAnimation::valueChanged(const QVariant&value)      QVariantAnimation emits this signal whenever the current \a value changes.      \sa currentValue, startValue, endValue */
comment|/*!     This virtual function is called every time the animation's current     value changes. The \a value argument is the new current value.      The base class implementation does nothing.      \sa currentValue */
DECL|function|updateCurrentValue
name|void
name|QVariantAnimation
operator|::
name|updateCurrentValue
parameter_list|(
specifier|const
name|QVariant
modifier|&
parameter_list|)
block|{}
end_function
begin_function
DECL|function|animationValueLessThan
specifier|static
name|bool
name|animationValueLessThan
parameter_list|(
specifier|const
name|QVariantAnimation
operator|::
name|KeyValue
modifier|&
name|p1
parameter_list|,
specifier|const
name|QVariantAnimation
operator|::
name|KeyValue
modifier|&
name|p2
parameter_list|)
block|{
return|return
name|p1
operator|.
name|first
operator|<
name|p2
operator|.
name|first
return|;
block|}
end_function
begin_function
DECL|function|defaultInterpolator
specifier|static
name|QVariant
name|defaultInterpolator
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|qreal
parameter_list|)
block|{
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|_q_interpolate
template|template
parameter_list|<>
name|Q_INLINE_TEMPLATE
name|QRect
name|_q_interpolate
parameter_list|(
specifier|const
name|QRect
modifier|&
name|f
parameter_list|,
specifier|const
name|QRect
modifier|&
name|t
parameter_list|,
name|qreal
name|progress
parameter_list|)
block|{
name|QRect
name|ret
decl_stmt|;
name|ret
operator|.
name|setCoords
argument_list|(
name|_q_interpolate
argument_list|(
name|f
operator|.
name|left
argument_list|()
argument_list|,
name|t
operator|.
name|left
argument_list|()
argument_list|,
name|progress
argument_list|)
argument_list|,
name|_q_interpolate
argument_list|(
name|f
operator|.
name|top
argument_list|()
argument_list|,
name|t
operator|.
name|top
argument_list|()
argument_list|,
name|progress
argument_list|)
argument_list|,
name|_q_interpolate
argument_list|(
name|f
operator|.
name|right
argument_list|()
argument_list|,
name|t
operator|.
name|right
argument_list|()
argument_list|,
name|progress
argument_list|)
argument_list|,
name|_q_interpolate
argument_list|(
name|f
operator|.
name|bottom
argument_list|()
argument_list|,
name|t
operator|.
name|bottom
argument_list|()
argument_list|,
name|progress
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|_q_interpolate
template|template
parameter_list|<>
name|Q_INLINE_TEMPLATE
name|QRectF
name|_q_interpolate
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|f
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|t
parameter_list|,
name|qreal
name|progress
parameter_list|)
block|{
name|qreal
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|w1
decl_stmt|,
name|h1
decl_stmt|;
name|f
operator|.
name|getRect
argument_list|(
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|w1
argument_list|,
operator|&
name|h1
argument_list|)
expr_stmt|;
name|qreal
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|w2
decl_stmt|,
name|h2
decl_stmt|;
name|t
operator|.
name|getRect
argument_list|(
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|,
operator|&
name|w2
argument_list|,
operator|&
name|h2
argument_list|)
expr_stmt|;
return|return
name|QRectF
argument_list|(
name|_q_interpolate
argument_list|(
name|x1
argument_list|,
name|x2
argument_list|,
name|progress
argument_list|)
argument_list|,
name|_q_interpolate
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|,
name|progress
argument_list|)
argument_list|,
name|_q_interpolate
argument_list|(
name|w1
argument_list|,
name|w2
argument_list|,
name|progress
argument_list|)
argument_list|,
name|_q_interpolate
argument_list|(
name|h1
argument_list|,
name|h2
argument_list|,
name|progress
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|_q_interpolate
template|template
parameter_list|<>
name|Q_INLINE_TEMPLATE
name|QLine
name|_q_interpolate
parameter_list|(
specifier|const
name|QLine
modifier|&
name|f
parameter_list|,
specifier|const
name|QLine
modifier|&
name|t
parameter_list|,
name|qreal
name|progress
parameter_list|)
block|{
return|return
name|QLine
argument_list|(
name|_q_interpolate
argument_list|(
name|f
operator|.
name|p1
argument_list|()
argument_list|,
name|t
operator|.
name|p1
argument_list|()
argument_list|,
name|progress
argument_list|)
argument_list|,
name|_q_interpolate
argument_list|(
name|f
operator|.
name|p2
argument_list|()
argument_list|,
name|t
operator|.
name|p2
argument_list|()
argument_list|,
name|progress
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|_q_interpolate
template|template
parameter_list|<>
name|Q_INLINE_TEMPLATE
name|QLineF
name|_q_interpolate
parameter_list|(
specifier|const
name|QLineF
modifier|&
name|f
parameter_list|,
specifier|const
name|QLineF
modifier|&
name|t
parameter_list|,
name|qreal
name|progress
parameter_list|)
block|{
return|return
name|QLineF
argument_list|(
name|_q_interpolate
argument_list|(
name|f
operator|.
name|p1
argument_list|()
argument_list|,
name|t
operator|.
name|p1
argument_list|()
argument_list|,
name|progress
argument_list|)
argument_list|,
name|_q_interpolate
argument_list|(
name|f
operator|.
name|p2
argument_list|()
argument_list|,
name|t
operator|.
name|p2
argument_list|()
argument_list|,
name|progress
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_constructor
DECL|function|QVariantAnimationPrivate
name|QVariantAnimationPrivate
operator|::
name|QVariantAnimationPrivate
parameter_list|()
member_init_list|:
name|duration
argument_list|(
literal|250
argument_list|)
member_init_list|,
name|interpolator
argument_list|(
operator|&
name|defaultInterpolator
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|convertValues
name|void
name|QVariantAnimationPrivate
operator|::
name|convertValues
parameter_list|(
name|int
name|t
parameter_list|)
block|{
comment|//this ensures that all the keyValues are of type t
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyValues
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QVariantAnimation
operator|::
name|KeyValue
modifier|&
name|pair
init|=
name|keyValues
index|[
name|i
index|]
decl_stmt|;
name|pair
operator|.
name|second
operator|.
name|convert
argument_list|(
cast|static_cast
argument_list|<
name|QVariant
operator|::
name|Type
argument_list|>
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//we also need update to the current interval if needed
name|currentInterval
operator|.
name|start
operator|.
name|second
operator|.
name|convert
argument_list|(
cast|static_cast
argument_list|<
name|QVariant
operator|::
name|Type
argument_list|>
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|currentInterval
operator|.
name|end
operator|.
name|second
operator|.
name|convert
argument_list|(
cast|static_cast
argument_list|<
name|QVariant
operator|::
name|Type
argument_list|>
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|//... and the interpolator
name|updateInterpolator
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateInterpolator
name|void
name|QVariantAnimationPrivate
operator|::
name|updateInterpolator
parameter_list|()
block|{
name|int
name|type
init|=
name|currentInterval
operator|.
name|start
operator|.
name|second
operator|.
name|userType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|currentInterval
operator|.
name|end
operator|.
name|second
operator|.
name|userType
argument_list|()
condition|)
name|interpolator
operator|=
name|getInterpolator
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|interpolator
operator|=
literal|0
expr_stmt|;
comment|//we make sure that the interpolator is always set to something
if|if
condition|(
operator|!
name|interpolator
condition|)
name|interpolator
operator|=
operator|&
name|defaultInterpolator
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     The goal of this function is to update the currentInterval member. As a consequence, we also     need to update the currentValue.     Set \a force to true to always recalculate the interval. */
end_comment
begin_function
DECL|function|recalculateCurrentInterval
name|void
name|QVariantAnimationPrivate
operator|::
name|recalculateCurrentInterval
parameter_list|(
name|bool
name|force
comment|/*=false*/
parameter_list|)
block|{
comment|// can't interpolate if we don't have at least 2 values
if|if
condition|(
operator|(
name|keyValues
operator|.
name|count
argument_list|()
operator|+
operator|(
name|defaultStartEndValue
operator|.
name|isValid
argument_list|()
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
operator|<
literal|2
condition|)
return|return;
specifier|const
name|qreal
name|endProgress
init|=
operator|(
name|direction
operator|==
name|QAbstractAnimation
operator|::
name|Forward
operator|)
condition|?
name|qreal
argument_list|(
literal|1
argument_list|)
else|:
name|qreal
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|progress
init|=
name|easing
operator|.
name|valueForProgress
argument_list|(
operator|(
operator|(
name|duration
operator|==
literal|0
operator|)
condition|?
name|endProgress
else|:
name|qreal
argument_list|(
name|currentTime
argument_list|)
operator|/
name|qreal
argument_list|(
name|duration
argument_list|)
operator|)
argument_list|)
decl_stmt|;
comment|//0 and 1 are still the boundaries
if|if
condition|(
name|force
operator|||
operator|(
name|currentInterval
operator|.
name|start
operator|.
name|first
operator|>
literal|0
operator|&&
name|progress
operator|<
name|currentInterval
operator|.
name|start
operator|.
name|first
operator|)
operator|||
operator|(
name|currentInterval
operator|.
name|end
operator|.
name|first
argument_list|<
literal|1
operator|&&
name|progress
argument_list|>
name|currentInterval
operator|.
name|end
operator|.
name|first
operator|)
condition|)
block|{
comment|//let's update currentInterval
name|QVariantAnimation
operator|::
name|KeyValues
operator|::
name|const_iterator
name|it
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|keyValues
operator|.
name|constBegin
argument_list|()
argument_list|,
name|keyValues
operator|.
name|constEnd
argument_list|()
argument_list|,
name|qMakePair
argument_list|(
name|progress
argument_list|,
name|QVariant
argument_list|()
argument_list|)
argument_list|,
name|animationValueLessThan
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|keyValues
operator|.
name|constBegin
argument_list|()
condition|)
block|{
comment|//the item pointed to by it is the start element in the range
if|if
condition|(
name|it
operator|->
name|first
operator|==
literal|0
operator|&&
name|keyValues
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
block|{
name|currentInterval
operator|.
name|start
operator|=
operator|*
name|it
expr_stmt|;
name|currentInterval
operator|.
name|end
operator|=
operator|*
operator|(
name|it
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|currentInterval
operator|.
name|start
operator|=
name|qMakePair
argument_list|(
name|qreal
argument_list|(
literal|0
argument_list|)
argument_list|,
name|defaultStartEndValue
argument_list|)
expr_stmt|;
name|currentInterval
operator|.
name|end
operator|=
operator|*
name|it
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|keyValues
operator|.
name|constEnd
argument_list|()
condition|)
block|{
operator|--
name|it
expr_stmt|;
comment|//position the iterator on the last item
if|if
condition|(
name|it
operator|->
name|first
operator|==
literal|1
operator|&&
name|keyValues
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|//we have an end value (item with progress = 1)
name|currentInterval
operator|.
name|start
operator|=
operator|*
operator|(
name|it
operator|-
literal|1
operator|)
expr_stmt|;
name|currentInterval
operator|.
name|end
operator|=
operator|*
name|it
expr_stmt|;
block|}
else|else
block|{
comment|//we use the default end value here
name|currentInterval
operator|.
name|start
operator|=
operator|*
name|it
expr_stmt|;
name|currentInterval
operator|.
name|end
operator|=
name|qMakePair
argument_list|(
name|qreal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|defaultStartEndValue
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|currentInterval
operator|.
name|start
operator|=
operator|*
operator|(
name|it
operator|-
literal|1
operator|)
expr_stmt|;
name|currentInterval
operator|.
name|end
operator|=
operator|*
name|it
expr_stmt|;
block|}
comment|// update all the values of the currentInterval
name|updateInterpolator
argument_list|()
expr_stmt|;
block|}
name|setCurrentValueForProgress
argument_list|(
name|progress
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setCurrentValueForProgress
name|void
name|QVariantAnimationPrivate
operator|::
name|setCurrentValueForProgress
parameter_list|(
specifier|const
name|qreal
name|progress
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QVariantAnimation
argument_list|)
expr_stmt|;
specifier|const
name|qreal
name|startProgress
init|=
name|currentInterval
operator|.
name|start
operator|.
name|first
decl_stmt|;
specifier|const
name|qreal
name|endProgress
init|=
name|currentInterval
operator|.
name|end
operator|.
name|first
decl_stmt|;
specifier|const
name|qreal
name|localProgress
init|=
operator|(
name|progress
operator|-
name|startProgress
operator|)
operator|/
operator|(
name|endProgress
operator|-
name|startProgress
operator|)
decl_stmt|;
name|QVariant
name|ret
init|=
name|q
operator|->
name|interpolated
argument_list|(
name|currentInterval
operator|.
name|start
operator|.
name|second
argument_list|,
name|currentInterval
operator|.
name|end
operator|.
name|second
argument_list|,
name|localProgress
argument_list|)
decl_stmt|;
name|qSwap
argument_list|(
name|currentValue
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|q
operator|->
name|updateCurrentValue
argument_list|(
name|currentValue
argument_list|)
expr_stmt|;
specifier|static
name|QBasicAtomicInt
name|changedSignalIndex
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changedSignalIndex
operator|.
name|load
argument_list|()
condition|)
block|{
comment|//we keep the mask so that we emit valueChanged only when needed (for performance reasons)
name|changedSignalIndex
operator|.
name|testAndSetRelaxed
argument_list|(
literal|0
argument_list|,
name|signalIndex
argument_list|(
literal|"valueChanged(QVariant)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isSignalConnected
argument_list|(
name|changedSignalIndex
operator|.
name|load
argument_list|()
argument_list|)
operator|&&
name|currentValue
operator|!=
name|ret
condition|)
block|{
comment|//the value has changed
emit|emit
name|q
operator|->
name|valueChanged
argument_list|(
name|currentValue
argument_list|)
emit|;
block|}
block|}
end_function
begin_function
DECL|function|valueAt
name|QVariant
name|QVariantAnimationPrivate
operator|::
name|valueAt
parameter_list|(
name|qreal
name|step
parameter_list|)
specifier|const
block|{
name|QVariantAnimation
operator|::
name|KeyValues
operator|::
name|const_iterator
name|result
init|=
name|qBinaryFind
argument_list|(
name|keyValues
operator|.
name|begin
argument_list|()
argument_list|,
name|keyValues
operator|.
name|end
argument_list|()
argument_list|,
name|qMakePair
argument_list|(
name|step
argument_list|,
name|QVariant
argument_list|()
argument_list|)
argument_list|,
name|animationValueLessThan
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|keyValues
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|result
operator|->
name|second
return|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setValueAt
name|void
name|QVariantAnimationPrivate
operator|::
name|setValueAt
parameter_list|(
name|qreal
name|step
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
name|step
argument_list|<
name|qreal
operator|(
literal|0.0
operator|)
operator|||
name|step
argument_list|>
name|qreal
argument_list|(
literal|1.0
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QVariantAnimation::setValueAt: invalid step = %f"
argument_list|,
name|step
argument_list|)
expr_stmt|;
return|return;
block|}
name|QVariantAnimation
operator|::
name|KeyValue
name|pair
argument_list|(
name|step
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|QVariantAnimation
operator|::
name|KeyValues
operator|::
name|iterator
name|result
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|keyValues
operator|.
name|begin
argument_list|()
argument_list|,
name|keyValues
operator|.
name|end
argument_list|()
argument_list|,
name|pair
argument_list|,
name|animationValueLessThan
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|keyValues
operator|.
name|end
argument_list|()
operator|||
name|result
operator|->
name|first
operator|!=
name|step
condition|)
block|{
name|keyValues
operator|.
name|insert
argument_list|(
name|result
argument_list|,
name|pair
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|.
name|isValid
argument_list|()
condition|)
name|result
operator|->
name|second
operator|=
name|value
expr_stmt|;
comment|// replaces the previous value
else|else
name|keyValues
operator|.
name|erase
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|// removes the previous value
block|}
name|recalculateCurrentInterval
argument_list|(
comment|/*force=*/
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setDefaultStartEndValue
name|void
name|QVariantAnimationPrivate
operator|::
name|setDefaultStartEndValue
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|defaultStartEndValue
operator|=
name|value
expr_stmt|;
name|recalculateCurrentInterval
argument_list|(
comment|/*force=*/
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Construct a QVariantAnimation object. \a parent is passed to QAbstractAnimation's     constructor. */
end_comment
begin_constructor
DECL|function|QVariantAnimation
name|QVariantAnimation
operator|::
name|QVariantAnimation
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractAnimation
argument_list|(
operator|*
operator|new
name|QVariantAnimationPrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QVariantAnimation
name|QVariantAnimation
operator|::
name|QVariantAnimation
parameter_list|(
name|QVariantAnimationPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractAnimation
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the animation. */
end_comment
begin_destructor
DECL|function|~QVariantAnimation
name|QVariantAnimation
operator|::
name|~
name|QVariantAnimation
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \property QVariantAnimation::easingCurve     \brief the easing curve of the animation      This property defines the easing curve of the animation. By     default, a linear easing curve is used, resulting in linear     interpolation. Other curves are provided, for instance,     QEasingCurve::InCirc, which provides a circular entry curve.     Another example is QEasingCurve::InOutElastic, which provides an     elastic effect on the values of the interpolated variant.      QVariantAnimation will use the QEasingCurve::valueForProgress() to     transform the "normalized progress" (currentTime / totalDuration)     of the animation into the effective progress actually     used by the animation. It is this effective progress that will be     the progress when interpolated() is called. Also, the steps in the     keyValues are referring to this effective progress.      The easing curve is used with the interpolator, the interpolated()     virtual function, the animation's duration, and iterationCount, to     control how the current value changes as the animation progresses. */
end_comment
begin_function
DECL|function|easingCurve
name|QEasingCurve
name|QVariantAnimation
operator|::
name|easingCurve
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QVariantAnimation
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|easing
return|;
block|}
end_function
begin_function
DECL|function|setEasingCurve
name|void
name|QVariantAnimation
operator|::
name|setEasingCurve
parameter_list|(
specifier|const
name|QEasingCurve
modifier|&
name|easing
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVariantAnimation
argument_list|)
expr_stmt|;
name|d
operator|->
name|easing
operator|=
name|easing
expr_stmt|;
name|d
operator|->
name|recalculateCurrentInterval
argument_list|()
expr_stmt|;
block|}
end_function
begin_typedef
DECL|typedef|QInterpolatorVector
typedef|typedef
name|QVector
argument_list|<
name|QVariantAnimation
operator|::
name|Interpolator
argument_list|>
name|QInterpolatorVector
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QInterpolatorVector
argument_list|,
argument|registeredInterpolators
argument_list|)
end_macro
begin_decl_stmt
DECL|variable|registeredInterpolatorsMutex
specifier|static
name|QBasicMutex
name|registeredInterpolatorsMutex
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     \fn void qRegisterAnimationInterpolator(QVariant (*func)(const T&from, const T&to, qreal progress))     \relates QVariantAnimation     \threadsafe      Registers a custom interpolator \a func for the template type \c{T}.     The interpolator has to be registered before the animation is constructed.     To unregister (and use the default interpolator) set \a func to 0.  */
end_comment
begin_comment
comment|/*!     \internal     \typedef QVariantAnimation::Interpolator      This is a typedef for a pointer to a function with the following     signature:     \code     QVariant myInterpolator(const QVariant&from, const QVariant&to, qreal progress);     \endcode  */
end_comment
begin_comment
comment|/*!  * \internal  * Registers a custom interpolator \a func for the specific \a interpolationType.  * The interpolator has to be registered before the animation is constructed.  * To unregister (and use the default interpolator) set \a func to 0.  */
end_comment
begin_function
DECL|function|registerInterpolator
name|void
name|QVariantAnimation
operator|::
name|registerInterpolator
parameter_list|(
name|QVariantAnimation
operator|::
name|Interpolator
name|func
parameter_list|,
name|int
name|interpolationType
parameter_list|)
block|{
comment|// will override any existing interpolators
name|QInterpolatorVector
modifier|*
name|interpolators
init|=
name|registeredInterpolators
argument_list|()
decl_stmt|;
comment|// When built on solaris with GCC, the destructors can be called
comment|// in such an order that we get here with interpolators == NULL,
comment|// to continue causes the app to crash on exit with a SEGV
if|if
condition|(
name|interpolators
condition|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|registeredInterpolatorsMutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|int
argument_list|(
name|interpolationType
argument_list|)
operator|>=
name|interpolators
operator|->
name|count
argument_list|()
condition|)
name|interpolators
operator|->
name|resize
argument_list|(
name|int
argument_list|(
name|interpolationType
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|interpolators
operator|->
name|replace
argument_list|(
name|interpolationType
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|castToInterpolator
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
specifier|static
specifier|inline
name|QVariantAnimation
operator|::
name|Interpolator
name|castToInterpolator
parameter_list|(
name|QVariant
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
specifier|const
name|T
modifier|&
name|from
parameter_list|,
specifier|const
name|T
modifier|&
name|to
parameter_list|,
name|qreal
name|progress
parameter_list|)
parameter_list|)
block|{
return|return
cast|reinterpret_cast
argument_list|<
name|QVariantAnimation
operator|::
name|Interpolator
argument_list|>
argument_list|(
name|func
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getInterpolator
name|QVariantAnimation
operator|::
name|Interpolator
name|QVariantAnimationPrivate
operator|::
name|getInterpolator
parameter_list|(
name|int
name|interpolationType
parameter_list|)
block|{
block|{
name|QInterpolatorVector
modifier|*
name|interpolators
init|=
name|registeredInterpolators
argument_list|()
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|registeredInterpolatorsMutex
argument_list|)
decl_stmt|;
name|QVariantAnimation
operator|::
name|Interpolator
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|interpolationType
operator|<
name|interpolators
operator|->
name|count
argument_list|()
condition|)
block|{
name|ret
operator|=
name|interpolators
operator|->
name|at
argument_list|(
name|interpolationType
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
block|}
switch|switch
condition|(
name|interpolationType
condition|)
block|{
case|case
name|QMetaType
operator|::
name|Int
case|:
return|return
name|castToInterpolator
argument_list|(
name|_q_interpolateVariant
argument_list|<
name|int
argument_list|>
argument_list|)
return|;
case|case
name|QMetaType
operator|::
name|Double
case|:
return|return
name|castToInterpolator
argument_list|(
name|_q_interpolateVariant
argument_list|<
name|double
argument_list|>
argument_list|)
return|;
case|case
name|QMetaType
operator|::
name|Float
case|:
return|return
name|castToInterpolator
argument_list|(
name|_q_interpolateVariant
argument_list|<
name|float
argument_list|>
argument_list|)
return|;
case|case
name|QMetaType
operator|::
name|QLine
case|:
return|return
name|castToInterpolator
argument_list|(
name|_q_interpolateVariant
argument_list|<
name|QLine
argument_list|>
argument_list|)
return|;
case|case
name|QMetaType
operator|::
name|QLineF
case|:
return|return
name|castToInterpolator
argument_list|(
name|_q_interpolateVariant
argument_list|<
name|QLineF
argument_list|>
argument_list|)
return|;
case|case
name|QMetaType
operator|::
name|QPoint
case|:
return|return
name|castToInterpolator
argument_list|(
name|_q_interpolateVariant
argument_list|<
name|QPoint
argument_list|>
argument_list|)
return|;
case|case
name|QMetaType
operator|::
name|QPointF
case|:
return|return
name|castToInterpolator
argument_list|(
name|_q_interpolateVariant
argument_list|<
name|QPointF
argument_list|>
argument_list|)
return|;
case|case
name|QMetaType
operator|::
name|QSize
case|:
return|return
name|castToInterpolator
argument_list|(
name|_q_interpolateVariant
argument_list|<
name|QSize
argument_list|>
argument_list|)
return|;
case|case
name|QMetaType
operator|::
name|QSizeF
case|:
return|return
name|castToInterpolator
argument_list|(
name|_q_interpolateVariant
argument_list|<
name|QSizeF
argument_list|>
argument_list|)
return|;
case|case
name|QMetaType
operator|::
name|QRect
case|:
return|return
name|castToInterpolator
argument_list|(
name|_q_interpolateVariant
argument_list|<
name|QRect
argument_list|>
argument_list|)
return|;
case|case
name|QMetaType
operator|::
name|QRectF
case|:
return|return
name|castToInterpolator
argument_list|(
name|_q_interpolateVariant
argument_list|<
name|QRectF
argument_list|>
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
comment|//this type is not handled
block|}
block|}
end_function
begin_comment
comment|/*!     \property QVariantAnimation::duration     \brief the duration of the animation      This property describes the duration in milliseconds of the     animation. The default duration is 250 milliseconds.      \sa QAbstractAnimation::duration()  */
end_comment
begin_function
DECL|function|duration
name|int
name|QVariantAnimation
operator|::
name|duration
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QVariantAnimation
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|duration
return|;
block|}
end_function
begin_function
DECL|function|setDuration
name|void
name|QVariantAnimation
operator|::
name|setDuration
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVariantAnimation
argument_list|)
expr_stmt|;
if|if
condition|(
name|msecs
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QVariantAnimation::setDuration: cannot set a negative duration"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|duration
operator|==
name|msecs
condition|)
return|return;
name|d
operator|->
name|duration
operator|=
name|msecs
expr_stmt|;
name|d
operator|->
name|recalculateCurrentInterval
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QVariantAnimation::startValue     \brief the optional start value of the animation      This property describes the optional start value of the animation. If     omitted, or if a null QVariant is assigned as the start value, the     animation will use the current position of the end when the animation     is started.      \sa endValue */
end_comment
begin_function
DECL|function|startValue
name|QVariant
name|QVariantAnimation
operator|::
name|startValue
parameter_list|()
specifier|const
block|{
return|return
name|keyValueAt
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setStartValue
name|void
name|QVariantAnimation
operator|::
name|setStartValue
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|setKeyValueAt
argument_list|(
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QVariantAnimation::endValue     \brief the end value of the animation      This property describes the end value of the animation.      \sa startValue  */
end_comment
begin_function
DECL|function|endValue
name|QVariant
name|QVariantAnimation
operator|::
name|endValue
parameter_list|()
specifier|const
block|{
return|return
name|keyValueAt
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setEndValue
name|void
name|QVariantAnimation
operator|::
name|setEndValue
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|setKeyValueAt
argument_list|(
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the key frame value for the given \a step. The given \a step     must be in the range 0 to 1. If there is no KeyValue for \a step,     it returns an invalid QVariant.      \sa keyValues(), setKeyValueAt() */
end_comment
begin_function
DECL|function|keyValueAt
name|QVariant
name|QVariantAnimation
operator|::
name|keyValueAt
parameter_list|(
name|qreal
name|step
parameter_list|)
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|valueAt
argument_list|(
name|step
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \typedef QVariantAnimation::KeyValue      This is a typedef for QPair<qreal, QVariant>. */
end_comment
begin_comment
comment|/*!     \typedef QVariantAnimation::KeyValues      This is a typedef for QVector<KeyValue> */
end_comment
begin_comment
comment|/*!     Creates a key frame at the given \a step with the given \a value.     The given \a step must be in the range 0 to 1.      \sa setKeyValues(), keyValueAt() */
end_comment
begin_function
DECL|function|setKeyValueAt
name|void
name|QVariantAnimation
operator|::
name|setKeyValueAt
parameter_list|(
name|qreal
name|step
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|setValueAt
argument_list|(
name|step
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the key frames of this animation.      \sa keyValueAt(), setKeyValues() */
end_comment
begin_function
DECL|function|keyValues
name|QVariantAnimation
operator|::
name|KeyValues
name|QVariantAnimation
operator|::
name|keyValues
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|keyValues
return|;
block|}
end_function
begin_comment
comment|/*!     Replaces the current set of key frames with the given \a keyValues.     the step of the key frames must be in the range 0 to 1.      \sa keyValues(), keyValueAt() */
end_comment
begin_function
DECL|function|setKeyValues
name|void
name|QVariantAnimation
operator|::
name|setKeyValues
parameter_list|(
specifier|const
name|KeyValues
modifier|&
name|keyValues
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVariantAnimation
argument_list|)
expr_stmt|;
name|d
operator|->
name|keyValues
operator|=
name|keyValues
expr_stmt|;
name|qSort
argument_list|(
name|d
operator|->
name|keyValues
operator|.
name|begin
argument_list|()
argument_list|,
name|d
operator|->
name|keyValues
operator|.
name|end
argument_list|()
argument_list|,
name|animationValueLessThan
argument_list|)
expr_stmt|;
name|d
operator|->
name|recalculateCurrentInterval
argument_list|(
comment|/*force=*/
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QVariantAnimation::currentValue     \brief the current value of the animation.      This property describes the current value; an interpolated value     between the \l{startValue}{start value} and the \l{endValue}{end     value}, using the current time for progress. The value itself is     obtained from interpolated(), which is called repeatedly as the     animation is running.      QVariantAnimation calls the virtual updateCurrentValue() function     when the current value changes. This is particularly useful for     subclasses that need to track updates. For example,     QPropertyAnimation uses this function to animate Qt \l{Qt's     Property System}{properties}.      \sa startValue, endValue */
end_comment
begin_function
DECL|function|currentValue
name|QVariant
name|QVariantAnimation
operator|::
name|currentValue
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QVariantAnimation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|currentValue
operator|.
name|isValid
argument_list|()
condition|)
cast|const_cast
argument_list|<
name|QVariantAnimationPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|recalculateCurrentInterval
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|currentValue
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp  */
end_comment
begin_function
DECL|function|event
name|bool
name|QVariantAnimation
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
return|return
name|QAbstractAnimation
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|updateState
name|void
name|QVariantAnimation
operator|::
name|updateState
parameter_list|(
name|QAbstractAnimation
operator|::
name|State
name|newState
parameter_list|,
name|QAbstractAnimation
operator|::
name|State
name|oldState
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|oldState
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|newState
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!      This virtual function returns the linear interpolation between     variants \a from and \a to, at \a progress, usually a value     between 0 and 1. You can reimplement this function in a subclass     of QVariantAnimation to provide your own interpolation algorithm.      Note that in order for the interpolation to work with a     QEasingCurve that return a value smaller than 0 or larger than 1     (such as QEasingCurve::InBack) you should make sure that it can     extrapolate. If the semantic of the datatype does not allow     extrapolation this function should handle that gracefully.      You should call the QVariantAnimation implementation of this     function if you want your class to handle the types already     supported by Qt (see class QVariantAnimation description for a     list of supported types).      \sa QEasingCurve  */
end_comment
begin_function
DECL|function|interpolated
name|QVariant
name|QVariantAnimation
operator|::
name|interpolated
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|from
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|to
parameter_list|,
name|qreal
name|progress
parameter_list|)
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|interpolator
argument_list|(
name|from
operator|.
name|constData
argument_list|()
argument_list|,
name|to
operator|.
name|constData
argument_list|()
argument_list|,
name|progress
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp  */
end_comment
begin_function
DECL|function|updateCurrentTime
name|void
name|QVariantAnimation
operator|::
name|updateCurrentTime
parameter_list|(
name|int
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|recalculateCurrentInterval
argument_list|()
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qvariantanimation.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_ANIMATION
end_comment
end_unit
