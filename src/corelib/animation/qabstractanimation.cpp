begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QAbstractAnimation     \inmodule QtCore     \ingroup animation     \brief The QAbstractAnimation class is the base of all animations.     \since 4.6      The class defines the functions for the functionality shared by     all animations. By inheriting this class, you can create custom     animations that plug into the rest of the animation framework.      The progress of an animation is given by its current time     (currentLoopTime()), which is measured in milliseconds from the start     of the animation (0) to its end (duration()). The value is updated     automatically while the animation is running. It can also be set     directly with setCurrentTime().      At any point an animation is in one of three states:     \l{QAbstractAnimation::}{Running},     \l{QAbstractAnimation::}{Stopped}, or     \l{QAbstractAnimation::}{Paused}--as defined by the     \l{QAbstractAnimation::}{State} enum. The current state can be     changed by calling start(), stop(), pause(), or resume(). An     animation will always reset its \l{currentTime()}{current time}     when it is started. If paused, it will continue with the same     current time when resumed. When an animation is stopped, it cannot     be resumed, but will keep its current time (until started again).     QAbstractAnimation will emit stateChanged() whenever its state     changes.      An animation can loop any number of times by setting the loopCount     property. When an animation's current time reaches its duration(),     it will reset the current time and keep running. A loop count of 1     (the default value) means that the animation will run one time.     Note that a duration of -1 means that the animation will run until     stopped; the current time will increase indefinitely. When the     current time equals duration() and the animation is in its     final loop, the \l{QAbstractAnimation::}{Stopped} state is     entered, and the finished() signal is emitted.      QAbstractAnimation provides pure virtual functions used by     subclasses to track the progress of the animation: duration() and     updateCurrentTime(). The duration() function lets you report a     duration for the animation (as discussed above). The animation     framework calls updateCurrentTime() when current time has changed.     By reimplementing this function, you can track the animation     progress. Note that neither the interval between calls nor the     number of calls to this function are defined; though, it will     normally be 60 updates per second.      By reimplementing updateState(), you can track the animation's     state changes, which is particularly useful for animations that     are not driven by time.      \sa QVariantAnimation, QPropertyAnimation, QAnimationGroup, {The Animation Framework} */
end_comment
begin_comment
comment|/*!     \enum QAbstractAnimation::DeletionPolicy      \value KeepWhenStopped The animation will not be deleted when stopped.     \value DeleteWhenStopped The animation will be automatically deleted when     stopped. */
end_comment
begin_comment
comment|/*!     \fn QAbstractAnimation::finished()      QAbstractAnimation emits this signal after the animation has stopped and     has reached the end.      This signal is emitted after stateChanged().      \sa stateChanged() */
end_comment
begin_comment
comment|/*!     \fn QAbstractAnimation::stateChanged(QAbstractAnimation::State newState, QAbstractAnimation::State oldState)      QAbstractAnimation emits this signal whenever the state of the animation has     changed from \a oldState to \a newState. This signal is emitted after the virtual     updateState() function is called.      \sa updateState() */
end_comment
begin_comment
comment|/*!     \fn QAbstractAnimation::currentLoopChanged(int currentLoop)      QAbstractAnimation emits this signal whenever the current loop     changes. \a currentLoop is the current loop.      \sa currentLoop(), loopCount() */
end_comment
begin_comment
comment|/*!     \fn QAbstractAnimation::directionChanged(QAbstractAnimation::Direction newDirection);      QAbstractAnimation emits this signal whenever the direction has been     changed. \a newDirection is the new direction.      \sa direction */
end_comment
begin_include
include|#
directive|include
file|"qabstractanimation.h"
end_include
begin_include
include|#
directive|include
file|"qanimationgroup.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_include
include|#
directive|include
file|"qabstractanimation_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qmath.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qthreadstorage.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qcoreevent.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qpointer.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
end_ifndef
begin_define
DECL|macro|DEFAULT_TIMER_INTERVAL
define|#
directive|define
name|DEFAULT_TIMER_INTERVAL
value|16
end_define
begin_define
DECL|macro|PAUSE_TIMER_COARSE_THRESHOLD
define|#
directive|define
name|PAUSE_TIMER_COARSE_THRESHOLD
value|2000
end_define
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|/*!   \class QAbstractAnimationTimer   \inmodule QtCore   \brief QAbstractAnimationTimer is the base class for animation timers.   \internal    Subclass QAbstractAnimationTimer to provide an animation timer that is run by   QUnifiedTimer and can in turn be used to run any number of animations.    Currently two subclasses have been implemented: QAnimationTimer to drive the Qt C++   animation framework (QAbstractAnimation and subclasses) and QDeclarativeAnimationTimer   to drive the Qt QML animation framework. */
comment|/*!     \fn virtual void QAbstractAnimationTimer::updateAnimationsTime(qint64 delta) = 0;     \internal      This pure virtual function is called when the animation timer needs to update     the current time for all animations it is running. */
comment|/*!     \fn virtual void QAbstractAnimationTimer::restartAnimationTimer() = 0;     \internal      This pure virtual function restarts the animation timer as needed.      Classes implementing this function may choose to pause or resume the timer     as appropriate, or conditionally restart it. */
comment|/*!     \fn virtual int QAbstractAnimationTimer::runningAnimationCount() = 0;     \internal      This pure virtual function returns the number of animations the timer is running.     This information is useful for profiling. */
comment|/*!     \class QUnifiedTimer     \inmodule QtCore     \brief QUnifiedTimer provides a unified timing mechanism for animations in Qt C++ and QML.     \internal      QUnifiedTimer allows animations run by Qt to share a single timer. This keeps animations     visually in sync, as well as being more efficient than running numerous timers.      QUnifiedTimer drives animations indirectly, via QAbstractAnimationTimer. */
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|Q_GLOBAL_STATIC
argument_list|(
name|QThreadStorage
argument_list|<
name|QUnifiedTimer
operator|*
argument_list|>
argument_list|,
name|unifiedTimer
argument_list|)
endif|#
directive|endif
DECL|function|QUnifiedTimer
name|QUnifiedTimer
operator|::
name|QUnifiedTimer
argument_list|()
range|:
name|QObject
argument_list|()
decl_stmt|,
name|defaultDriver
argument_list|(
name|this
argument_list|)
decl_stmt|,
name|lastTick
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|timingInterval
argument_list|(
name|DEFAULT_TIMER_INTERVAL
argument_list|)
decl_stmt|,
name|currentAnimationIdx
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|insideTick
argument_list|(
literal|false
argument_list|)
decl_stmt|,
name|insideRestart
argument_list|(
literal|false
argument_list|)
decl_stmt|,
name|consistentTiming
argument_list|(
literal|false
argument_list|)
decl_stmt|,
name|slowMode
argument_list|(
literal|false
argument_list|)
decl_stmt|,
name|startTimersPending
argument_list|(
literal|false
argument_list|)
decl_stmt|,
name|stopTimerPending
argument_list|(
literal|false
argument_list|)
decl_stmt|,
name|slowdownFactor
argument_list|(
literal|5.0f
argument_list|)
decl_stmt|,
name|profilerCallback
argument_list|(
literal|0
argument_list|)
argument_list|{
name|time
operator|.
name|invalidate
argument_list|()
argument_list|;
name|driver
operator|=
operator|&
name|defaultDriver
argument_list|; }
DECL|function|instance
name|QUnifiedTimer
modifier|*
name|QUnifiedTimer
operator|::
name|instance
argument_list|(
name|bool
name|create
argument_list|)
argument_list|{
name|QUnifiedTimer
operator|*
name|inst
argument_list|;
ifndef|#
directive|ifndef
name|QT_NO_THREAD
argument_list|if
operator|(
name|create
operator|&&
operator|!
name|unifiedTimer
argument_list|()
operator|->
name|hasLocalData
argument_list|()
operator|)
block|{
name|inst
operator|=
operator|new
name|QUnifiedTimer
block|;
name|unifiedTimer
argument_list|()
operator|->
name|setLocalData
argument_list|(
name|inst
argument_list|)
block|;     }
else|else
block|{
name|inst
operator|=
name|unifiedTimer
argument_list|()
operator|?
name|unifiedTimer
argument_list|()
operator|->
name|localData
argument_list|()
operator|:
literal|0
block|;     }
else|#
directive|else
specifier|static
name|QUnifiedTimer
name|unifiedTimer
expr_stmt|;
name|inst
operator|=
operator|&
name|unifiedTimer
argument_list|;
endif|#
directive|endif
argument_list|return
name|inst
argument_list|; }
DECL|function|instance
name|QUnifiedTimer
modifier|*
name|QUnifiedTimer
operator|::
name|instance
argument_list|()
argument_list|{     return
name|instance
argument_list|(
literal|true
argument_list|)
argument_list|; }
DECL|function|maybeUpdateAnimationsToCurrentTime
name|void
name|QUnifiedTimer
operator|::
name|maybeUpdateAnimationsToCurrentTime
argument_list|()
argument_list|{     if
operator|(
name|time
operator|.
name|elapsed
argument_list|()
operator|-
name|lastTick
operator|>
literal|50
operator|)
name|updateAnimationTimers
argument_list|(
name|driver
operator|->
name|elapsed
argument_list|()
argument_list|)
argument_list|; }
DECL|function|updateAnimationTimers
name|void
name|QUnifiedTimer
operator|::
name|updateAnimationTimers
argument_list|(
name|qint64
name|currentTick
argument_list|)
argument_list|{
comment|//setCurrentTime can get this called again while we're the for loop. At least with pauseAnimations
argument_list|if
operator|(
name|insideTick
operator|)
return|return;
end_decl_stmt
begin_decl_stmt
name|qint64
name|totalElapsed
init|=
name|currentTick
operator|>=
literal|0
condition|?
name|currentTick
else|:
name|time
operator|.
name|elapsed
argument_list|()
decl_stmt|;
end_decl_stmt
begin_comment
comment|// ignore consistentTiming in case the pause timer is active
end_comment
begin_decl_stmt
name|qint64
name|delta
init|=
operator|(
name|consistentTiming
operator|&&
operator|!
name|pauseTimer
operator|.
name|isActive
argument_list|()
operator|)
condition|?
name|timingInterval
else|:
name|totalElapsed
operator|-
name|lastTick
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|slowMode
condition|)
block|{
if|if
condition|(
name|slowdownFactor
operator|>
literal|0
condition|)
name|delta
operator|=
name|qRound
argument_list|(
name|delta
operator|/
name|slowdownFactor
argument_list|)
expr_stmt|;
else|else
name|delta
operator|=
literal|0
expr_stmt|;
block|}
end_if
begin_expr_stmt
name|lastTick
operator|=
name|totalElapsed
expr_stmt|;
end_expr_stmt
begin_comment
comment|//we make sure we only call update time if the time has actually changed
end_comment
begin_comment
comment|//it might happen in some cases that the time doesn't change because events are delayed
end_comment
begin_comment
comment|//when the CPU load is high
end_comment
begin_if
if|if
condition|(
name|delta
condition|)
block|{
name|insideTick
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|profilerCallback
condition|)
name|profilerCallback
argument_list|(
name|delta
argument_list|)
expr_stmt|;
for|for
control|(
name|currentAnimationIdx
operator|=
literal|0
init|;
name|currentAnimationIdx
operator|<
name|animationTimers
operator|.
name|count
argument_list|()
condition|;
operator|++
name|currentAnimationIdx
control|)
block|{
name|QAbstractAnimationTimer
modifier|*
name|animation
init|=
name|animationTimers
operator|.
name|at
argument_list|(
name|currentAnimationIdx
argument_list|)
decl_stmt|;
name|animation
operator|->
name|updateAnimationsTime
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
name|insideTick
operator|=
literal|false
expr_stmt|;
name|currentAnimationIdx
operator|=
literal|0
expr_stmt|;
block|}
end_if
begin_macro
unit|}  int
DECL|function|runningAnimationCount
name|QUnifiedTimer
end_macro
begin_expr_stmt
DECL|function|runningAnimationCount
operator|::
name|runningAnimationCount
operator|(
operator|)
block|{
name|int
name|count
operator|=
literal|0
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|animationTimers
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|count
operator|+=
name|animationTimers
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|runningAnimationCount
argument_list|()
expr_stmt|;
end_expr_stmt
begin_return
return|return
name|count
return|;
end_return
begin_macro
unit|}  void
DECL|function|registerProfilerCallback
name|QUnifiedTimer
end_macro
begin_expr_stmt
DECL|function|registerProfilerCallback
operator|::
name|registerProfilerCallback
operator|(
name|void
argument_list|(
operator|*
name|cb
argument_list|)
argument_list|(
name|qint64
argument_list|)
operator|)
block|{
name|profilerCallback
operator|=
name|cb
block|; }
DECL|function|localRestart
name|void
name|QUnifiedTimer
operator|::
name|localRestart
operator|(
operator|)
block|{
if|if
condition|(
name|insideRestart
condition|)
return|return;
end_expr_stmt
begin_if
if|if
condition|(
operator|!
name|pausedAnimationTimers
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|animationTimers
operator|.
name|count
argument_list|()
operator|+
name|animationTimersToStart
operator|.
name|count
argument_list|()
operator|==
name|pausedAnimationTimers
operator|.
name|count
argument_list|()
operator|)
condition|)
block|{
name|driver
operator|->
name|stop
argument_list|()
expr_stmt|;
name|int
name|closestTimeToFinish
init|=
name|closestPausedAnimationTimerTimeToFinish
argument_list|()
decl_stmt|;
comment|// use a precise timer if the pause will be short
name|Qt
operator|::
name|TimerType
name|timerType
init|=
name|closestTimeToFinish
operator|<
name|PAUSE_TIMER_COARSE_THRESHOLD
condition|?
name|Qt
operator|::
name|PreciseTimer
else|:
name|Qt
operator|::
name|CoarseTimer
decl_stmt|;
name|pauseTimer
operator|.
name|start
argument_list|(
name|closestTimeToFinish
argument_list|,
name|timerType
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|driver
operator|->
name|isRunning
argument_list|()
condition|)
block|{
if|if
condition|(
name|pauseTimer
operator|.
name|isActive
argument_list|()
condition|)
name|pauseTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|driver
operator|->
name|setStartTime
argument_list|(
name|time
operator|.
name|isValid
argument_list|()
condition|?
name|time
operator|.
name|elapsed
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
name|driver
operator|->
name|start
argument_list|()
expr_stmt|;
block|}
end_if
begin_macro
unit|}  void
DECL|function|restart
name|QUnifiedTimer
end_macro
begin_expr_stmt
DECL|function|restart
operator|::
name|restart
operator|(
operator|)
block|{
name|insideRestart
operator|=
literal|true
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|animationTimers
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|animationTimers
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|restartAnimationTimer
argument_list|()
expr_stmt|;
name|insideRestart
operator|=
literal|false
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|localRestart
argument_list|()
expr_stmt|;
end_expr_stmt
begin_macro
unit|}  void
DECL|function|setTimingInterval
name|QUnifiedTimer
end_macro
begin_expr_stmt
DECL|function|setTimingInterval
operator|::
name|setTimingInterval
operator|(
name|int
name|interval
operator|)
block|{
name|timingInterval
operator|=
name|interval
block|;
if|if
condition|(
name|driver
operator|->
name|isRunning
argument_list|()
operator|&&
operator|!
name|pauseTimer
operator|.
name|isActive
argument_list|()
condition|)
block|{
comment|//we changed the timing interval
name|driver
operator|->
name|stop
argument_list|()
expr_stmt|;
name|driver
operator|->
name|setStartTime
argument_list|(
name|time
operator|.
name|isValid
argument_list|()
condition|?
name|time
operator|.
name|elapsed
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
name|driver
operator|->
name|start
argument_list|()
expr_stmt|;
block|}
end_expr_stmt
begin_macro
unit|}  void
DECL|function|startTimers
name|QUnifiedTimer
end_macro
begin_expr_stmt
DECL|function|startTimers
operator|::
name|startTimers
operator|(
operator|)
block|{
name|startTimersPending
operator|=
literal|false
block|;
if|if
condition|(
operator|!
name|animationTimers
operator|.
name|isEmpty
argument_list|()
condition|)
name|updateAnimationTimers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//we transfer the waiting animations into the "really running" state
name|animationTimers
operator|+=
name|animationTimersToStart
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|animationTimersToStart
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
operator|!
name|animationTimers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|localRestart
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|time
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|lastTick
operator|=
literal|0
expr_stmt|;
name|time
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
end_if
begin_macro
unit|}  void
DECL|function|stopTimer
name|QUnifiedTimer
end_macro
begin_expr_stmt
DECL|function|stopTimer
operator|::
name|stopTimer
operator|(
operator|)
block|{
name|stopTimerPending
operator|=
literal|false
block|;
if|if
condition|(
name|animationTimers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|driver
operator|->
name|stop
argument_list|()
expr_stmt|;
name|pauseTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// invalidate the start reference time
name|time
operator|.
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_expr_stmt
begin_macro
unit|}  void
DECL|function|timerEvent
name|QUnifiedTimer
end_macro
begin_expr_stmt
DECL|function|timerEvent
operator|::
name|timerEvent
operator|(
name|QTimerEvent
operator|*
name|event
operator|)
block|{
comment|//in the case of consistent timing we make sure the order in which events come is always the same
comment|//for that purpose we do as if the startstoptimer would always fire before the animation timer
if|if
condition|(
name|consistentTiming
condition|)
block|{
if|if
condition|(
name|stopTimerPending
condition|)
name|stopTimer
argument_list|()
expr_stmt|;
if|if
condition|(
name|startTimersPending
condition|)
name|startTimers
argument_list|()
expr_stmt|;
block|}
end_expr_stmt
begin_if
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|pauseTimer
operator|.
name|timerId
argument_list|()
condition|)
block|{
comment|// update current time on all timers
name|updateAnimationTimers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|restart
argument_list|()
expr_stmt|;
block|}
end_if
begin_macro
unit|}  void
DECL|function|startAnimationTimer
name|QUnifiedTimer
end_macro
begin_expr_stmt
DECL|function|startAnimationTimer
operator|::
name|startAnimationTimer
operator|(
name|QAbstractAnimationTimer
operator|*
name|timer
operator|)
block|{
if|if
condition|(
name|timer
operator|->
name|isRegistered
condition|)
return|return;
name|timer
operator|->
name|isRegistered
operator|=
literal|true
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|QUnifiedTimer
modifier|*
name|inst
init|=
name|instance
argument_list|(
literal|true
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
comment|//we create the instance if needed
end_comment
begin_expr_stmt
name|inst
operator|->
name|animationTimersToStart
operator|<<
name|timer
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
operator|!
name|inst
operator|->
name|startTimersPending
condition|)
block|{
name|inst
operator|->
name|startTimersPending
operator|=
literal|true
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|inst
argument_list|,
literal|"startTimers"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_if
begin_macro
unit|}  void
DECL|function|stopAnimationTimer
name|QUnifiedTimer
end_macro
begin_expr_stmt
DECL|function|stopAnimationTimer
operator|::
name|stopAnimationTimer
operator|(
name|QAbstractAnimationTimer
operator|*
name|timer
operator|)
block|{
name|QUnifiedTimer
operator|*
name|inst
operator|=
name|QUnifiedTimer
operator|::
name|instance
argument_list|(
literal|false
argument_list|)
block|;
if|if
condition|(
name|inst
condition|)
block|{
comment|//at this point the unified timer should have been created
comment|//but it might also have been already destroyed in case the application is shutting down
if|if
condition|(
operator|!
name|timer
operator|->
name|isRegistered
condition|)
return|return;
name|timer
operator|->
name|isRegistered
operator|=
literal|false
expr_stmt|;
name|int
name|idx
init|=
name|inst
operator|->
name|animationTimers
operator|.
name|indexOf
argument_list|(
name|timer
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|inst
operator|->
name|animationTimers
operator|.
name|removeAt
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|// this is needed if we unregister an animation while its running
if|if
condition|(
name|idx
operator|<=
name|inst
operator|->
name|currentAnimationIdx
condition|)
operator|--
name|inst
operator|->
name|currentAnimationIdx
expr_stmt|;
if|if
condition|(
name|inst
operator|->
name|animationTimers
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|inst
operator|->
name|stopTimerPending
condition|)
block|{
name|inst
operator|->
name|stopTimerPending
operator|=
literal|true
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|inst
argument_list|,
literal|"stopTimer"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_expr_stmt
begin_block
unit|} else
block|{
name|inst
operator|->
name|animationTimersToStart
operator|.
name|removeOne
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
end_block
begin_function
unit|} }
DECL|function|pauseAnimationTimer
name|void
name|QUnifiedTimer
operator|::
name|pauseAnimationTimer
parameter_list|(
name|QAbstractAnimationTimer
modifier|*
name|timer
parameter_list|,
name|int
name|duration
parameter_list|)
block|{
name|QUnifiedTimer
modifier|*
name|inst
init|=
name|QUnifiedTimer
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|timer
operator|->
name|isRegistered
condition|)
name|inst
operator|->
name|startAnimationTimer
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|bool
name|timerWasPaused
init|=
name|timer
operator|->
name|isPaused
decl_stmt|;
name|timer
operator|->
name|isPaused
operator|=
literal|true
expr_stmt|;
name|timer
operator|->
name|pauseDuration
operator|=
name|duration
expr_stmt|;
if|if
condition|(
operator|!
name|timerWasPaused
condition|)
name|inst
operator|->
name|pausedAnimationTimers
operator|<<
name|timer
expr_stmt|;
name|inst
operator|->
name|localRestart
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resumeAnimationTimer
name|void
name|QUnifiedTimer
operator|::
name|resumeAnimationTimer
parameter_list|(
name|QAbstractAnimationTimer
modifier|*
name|timer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|timer
operator|->
name|isPaused
condition|)
return|return;
name|timer
operator|->
name|isPaused
operator|=
literal|false
expr_stmt|;
name|QUnifiedTimer
modifier|*
name|inst
init|=
name|QUnifiedTimer
operator|::
name|instance
argument_list|()
decl_stmt|;
name|inst
operator|->
name|pausedAnimationTimers
operator|.
name|removeOne
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|inst
operator|->
name|localRestart
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|closestPausedAnimationTimerTimeToFinish
name|int
name|QUnifiedTimer
operator|::
name|closestPausedAnimationTimerTimeToFinish
parameter_list|()
block|{
name|int
name|closestTimeToFinish
init|=
name|INT_MAX
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pausedAnimationTimers
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|timeToFinish
init|=
name|pausedAnimationTimers
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|pauseDuration
decl_stmt|;
if|if
condition|(
name|timeToFinish
operator|<
name|closestTimeToFinish
condition|)
name|closestTimeToFinish
operator|=
name|timeToFinish
expr_stmt|;
block|}
return|return
name|closestTimeToFinish
return|;
block|}
end_function
begin_function
DECL|function|installAnimationDriver
name|void
name|QUnifiedTimer
operator|::
name|installAnimationDriver
parameter_list|(
name|QAnimationDriver
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|driver
operator|!=
operator|&
name|defaultDriver
condition|)
block|{
name|qWarning
argument_list|(
literal|"QUnifiedTimer: animation driver already installed..."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|driver
operator|->
name|isRunning
argument_list|()
condition|)
block|{
name|driver
operator|->
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|setStartTime
argument_list|(
name|time
operator|.
name|isValid
argument_list|()
condition|?
name|time
operator|.
name|elapsed
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|start
argument_list|()
expr_stmt|;
block|}
name|driver
operator|=
name|d
expr_stmt|;
block|}
end_function
begin_function
DECL|function|uninstallAnimationDriver
name|void
name|QUnifiedTimer
operator|::
name|uninstallAnimationDriver
parameter_list|(
name|QAnimationDriver
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|driver
operator|!=
name|d
condition|)
block|{
name|qWarning
argument_list|(
literal|"QUnifiedTimer: trying to uninstall a driver that is not installed..."
argument_list|)
expr_stmt|;
return|return;
block|}
name|driver
operator|=
operator|&
name|defaultDriver
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isRunning
argument_list|()
condition|)
block|{
name|d
operator|->
name|stop
argument_list|()
expr_stmt|;
name|driver
operator|->
name|setStartTime
argument_list|(
name|time
operator|.
name|isValid
argument_list|()
condition|?
name|time
operator|.
name|elapsed
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
name|driver
operator|->
name|start
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns true if \a d is the currently installed animation driver     and is not the default animation driver (which can never be uninstalled). */
end_comment
begin_function
DECL|function|canUninstallAnimationDriver
name|bool
name|QUnifiedTimer
operator|::
name|canUninstallAnimationDriver
parameter_list|(
name|QAnimationDriver
modifier|*
name|d
parameter_list|)
block|{
return|return
name|d
operator|==
name|driver
operator|&&
name|driver
operator|!=
operator|&
name|defaultDriver
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_THREAD
end_ifndef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QThreadStorage<QAnimationTimer *>
argument_list|,
argument|animationTimer
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|QAnimationTimer
name|QAnimationTimer
operator|::
name|QAnimationTimer
parameter_list|()
member_init_list|:
name|QAbstractAnimationTimer
argument_list|()
member_init_list|,
name|lastTick
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|currentAnimationIdx
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|insideTick
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|startAnimationPending
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|stopTimerPending
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|runningLeafAnimations
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|instance
name|QAnimationTimer
modifier|*
name|QAnimationTimer
operator|::
name|instance
parameter_list|(
name|bool
name|create
parameter_list|)
block|{
name|QAnimationTimer
modifier|*
name|inst
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_THREAD
if|if
condition|(
name|create
operator|&&
operator|!
name|animationTimer
argument_list|()
operator|->
name|hasLocalData
argument_list|()
condition|)
block|{
name|inst
operator|=
operator|new
name|QAnimationTimer
expr_stmt|;
name|animationTimer
argument_list|()
operator|->
name|setLocalData
argument_list|(
name|inst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
name|animationTimer
argument_list|()
condition|?
name|animationTimer
argument_list|()
operator|->
name|localData
argument_list|()
else|:
literal|0
expr_stmt|;
block|}
else|#
directive|else
specifier|static
name|QAnimationTimer
name|animationTimer
decl_stmt|;
name|inst
operator|=
operator|&
name|animationTimer
expr_stmt|;
endif|#
directive|endif
return|return
name|inst
return|;
block|}
end_function
begin_function
DECL|function|instance
name|QAnimationTimer
modifier|*
name|QAnimationTimer
operator|::
name|instance
parameter_list|()
block|{
return|return
name|instance
argument_list|(
literal|true
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ensureTimerUpdate
name|void
name|QAnimationTimer
operator|::
name|ensureTimerUpdate
parameter_list|()
block|{
name|QAnimationTimer
modifier|*
name|inst
init|=
name|QAnimationTimer
operator|::
name|instance
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|QUnifiedTimer
modifier|*
name|instU
init|=
name|QUnifiedTimer
operator|::
name|instance
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|instU
operator|&&
name|inst
operator|&&
name|inst
operator|->
name|isPaused
condition|)
name|instU
operator|->
name|updateAnimationTimers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateAnimationsTime
name|void
name|QAnimationTimer
operator|::
name|updateAnimationsTime
parameter_list|(
name|qint64
name|delta
parameter_list|)
block|{
comment|//setCurrentTime can get this called again while we're the for loop. At least with pauseAnimations
if|if
condition|(
name|insideTick
condition|)
return|return;
name|lastTick
operator|+=
name|delta
expr_stmt|;
comment|//we make sure we only call update time if the time has actually changed
comment|//it might happen in some cases that the time doesn't change because events are delayed
comment|//when the CPU load is high
if|if
condition|(
name|delta
condition|)
block|{
name|insideTick
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|currentAnimationIdx
operator|=
literal|0
init|;
name|currentAnimationIdx
operator|<
name|animations
operator|.
name|count
argument_list|()
condition|;
operator|++
name|currentAnimationIdx
control|)
block|{
name|QAbstractAnimation
modifier|*
name|animation
init|=
name|animations
operator|.
name|at
argument_list|(
name|currentAnimationIdx
argument_list|)
decl_stmt|;
name|int
name|elapsed
init|=
name|QAbstractAnimationPrivate
operator|::
name|get
argument_list|(
name|animation
argument_list|)
operator|->
name|totalCurrentTime
operator|+
operator|(
name|animation
operator|->
name|direction
argument_list|()
operator|==
name|QAbstractAnimation
operator|::
name|Forward
condition|?
name|delta
else|:
operator|-
name|delta
operator|)
decl_stmt|;
name|animation
operator|->
name|setCurrentTime
argument_list|(
name|elapsed
argument_list|)
expr_stmt|;
block|}
name|insideTick
operator|=
literal|false
expr_stmt|;
name|currentAnimationIdx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|updateAnimationTimer
name|void
name|QAnimationTimer
operator|::
name|updateAnimationTimer
parameter_list|()
block|{
name|QAnimationTimer
modifier|*
name|inst
init|=
name|QAnimationTimer
operator|::
name|instance
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|inst
condition|)
name|inst
operator|->
name|restartAnimationTimer
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|restartAnimationTimer
name|void
name|QAnimationTimer
operator|::
name|restartAnimationTimer
parameter_list|()
block|{
if|if
condition|(
name|runningLeafAnimations
operator|==
literal|0
operator|&&
operator|!
name|runningPauseAnimations
operator|.
name|isEmpty
argument_list|()
condition|)
name|QUnifiedTimer
operator|::
name|pauseAnimationTimer
argument_list|(
name|this
argument_list|,
name|closestPauseAnimationTimeToFinish
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isPaused
condition|)
name|QUnifiedTimer
operator|::
name|resumeAnimationTimer
argument_list|(
name|this
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isRegistered
condition|)
name|QUnifiedTimer
operator|::
name|startAnimationTimer
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|startAnimations
name|void
name|QAnimationTimer
operator|::
name|startAnimations
parameter_list|()
block|{
name|startAnimationPending
operator|=
literal|false
expr_stmt|;
comment|//force timer to update, which prevents large deltas for our newly added animations
if|if
condition|(
operator|!
name|animations
operator|.
name|isEmpty
argument_list|()
condition|)
name|QUnifiedTimer
operator|::
name|instance
argument_list|()
operator|->
name|maybeUpdateAnimationsToCurrentTime
argument_list|()
expr_stmt|;
comment|//we transfer the waiting animations into the "really running" state
name|animations
operator|+=
name|animationsToStart
expr_stmt|;
name|animationsToStart
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|animations
operator|.
name|isEmpty
argument_list|()
condition|)
name|restartAnimationTimer
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stopTimer
name|void
name|QAnimationTimer
operator|::
name|stopTimer
parameter_list|()
block|{
name|stopTimerPending
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|animations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QUnifiedTimer
operator|::
name|resumeAnimationTimer
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QUnifiedTimer
operator|::
name|stopAnimationTimer
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// invalidate the start reference time
name|lastTick
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|registerAnimation
name|void
name|QAnimationTimer
operator|::
name|registerAnimation
parameter_list|(
name|QAbstractAnimation
modifier|*
name|animation
parameter_list|,
name|bool
name|isTopLevel
parameter_list|)
block|{
name|QAnimationTimer
modifier|*
name|inst
init|=
name|instance
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|//we create the instance if needed
name|inst
operator|->
name|registerRunningAnimation
argument_list|(
name|animation
argument_list|)
expr_stmt|;
if|if
condition|(
name|isTopLevel
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|QAbstractAnimationPrivate
operator|::
name|get
argument_list|(
name|animation
argument_list|)
operator|->
name|hasRegisteredTimer
argument_list|)
expr_stmt|;
name|QAbstractAnimationPrivate
operator|::
name|get
argument_list|(
name|animation
argument_list|)
operator|->
name|hasRegisteredTimer
operator|=
literal|true
expr_stmt|;
name|inst
operator|->
name|animationsToStart
operator|<<
name|animation
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|->
name|startAnimationPending
condition|)
block|{
name|inst
operator|->
name|startAnimationPending
operator|=
literal|true
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|inst
argument_list|,
literal|"startAnimations"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|unregisterAnimation
name|void
name|QAnimationTimer
operator|::
name|unregisterAnimation
parameter_list|(
name|QAbstractAnimation
modifier|*
name|animation
parameter_list|)
block|{
name|QAnimationTimer
modifier|*
name|inst
init|=
name|QAnimationTimer
operator|::
name|instance
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|inst
condition|)
block|{
comment|//at this point the unified timer should have been created
comment|//but it might also have been already destroyed in case the application is shutting down
name|inst
operator|->
name|unregisterRunningAnimation
argument_list|(
name|animation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QAbstractAnimationPrivate
operator|::
name|get
argument_list|(
name|animation
argument_list|)
operator|->
name|hasRegisteredTimer
condition|)
return|return;
name|int
name|idx
init|=
name|inst
operator|->
name|animations
operator|.
name|indexOf
argument_list|(
name|animation
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|inst
operator|->
name|animations
operator|.
name|removeAt
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|// this is needed if we unregister an animation while its running
if|if
condition|(
name|idx
operator|<=
name|inst
operator|->
name|currentAnimationIdx
condition|)
operator|--
name|inst
operator|->
name|currentAnimationIdx
expr_stmt|;
if|if
condition|(
name|inst
operator|->
name|animations
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|inst
operator|->
name|stopTimerPending
condition|)
block|{
name|inst
operator|->
name|stopTimerPending
operator|=
literal|true
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|inst
argument_list|,
literal|"stopTimer"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|->
name|animationsToStart
operator|.
name|removeOne
argument_list|(
name|animation
argument_list|)
expr_stmt|;
block|}
block|}
name|QAbstractAnimationPrivate
operator|::
name|get
argument_list|(
name|animation
argument_list|)
operator|->
name|hasRegisteredTimer
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|registerRunningAnimation
name|void
name|QAnimationTimer
operator|::
name|registerRunningAnimation
parameter_list|(
name|QAbstractAnimation
modifier|*
name|animation
parameter_list|)
block|{
if|if
condition|(
name|QAbstractAnimationPrivate
operator|::
name|get
argument_list|(
name|animation
argument_list|)
operator|->
name|isGroup
condition|)
return|return;
if|if
condition|(
name|QAbstractAnimationPrivate
operator|::
name|get
argument_list|(
name|animation
argument_list|)
operator|->
name|isPause
condition|)
block|{
name|runningPauseAnimations
operator|<<
name|animation
expr_stmt|;
block|}
else|else
name|runningLeafAnimations
operator|++
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unregisterRunningAnimation
name|void
name|QAnimationTimer
operator|::
name|unregisterRunningAnimation
parameter_list|(
name|QAbstractAnimation
modifier|*
name|animation
parameter_list|)
block|{
if|if
condition|(
name|QAbstractAnimationPrivate
operator|::
name|get
argument_list|(
name|animation
argument_list|)
operator|->
name|isGroup
condition|)
return|return;
if|if
condition|(
name|QAbstractAnimationPrivate
operator|::
name|get
argument_list|(
name|animation
argument_list|)
operator|->
name|isPause
condition|)
name|runningPauseAnimations
operator|.
name|removeOne
argument_list|(
name|animation
argument_list|)
expr_stmt|;
else|else
name|runningLeafAnimations
operator|--
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|runningLeafAnimations
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|closestPauseAnimationTimeToFinish
name|int
name|QAnimationTimer
operator|::
name|closestPauseAnimationTimeToFinish
parameter_list|()
block|{
name|int
name|closestTimeToFinish
init|=
name|INT_MAX
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|runningPauseAnimations
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractAnimation
modifier|*
name|animation
init|=
name|runningPauseAnimations
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|timeToFinish
decl_stmt|;
if|if
condition|(
name|animation
operator|->
name|direction
argument_list|()
operator|==
name|QAbstractAnimation
operator|::
name|Forward
condition|)
name|timeToFinish
operator|=
name|animation
operator|->
name|duration
argument_list|()
operator|-
name|animation
operator|->
name|currentLoopTime
argument_list|()
expr_stmt|;
else|else
name|timeToFinish
operator|=
name|animation
operator|->
name|currentLoopTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|timeToFinish
operator|<
name|closestTimeToFinish
condition|)
name|closestTimeToFinish
operator|=
name|timeToFinish
expr_stmt|;
block|}
return|return
name|closestTimeToFinish
return|;
block|}
end_function
begin_comment
comment|/*!    \class QAnimationDriver    \inmodule QtCore     \brief The QAnimationDriver class is used to exchange the mechanism that drives animations.     The default animation system is driven by a timer that fires at regular intervals.    In some scenarios, it is better to drive the animation based on other synchronization    mechanisms, such as the vertical refresh rate of the screen.     \internal  */
end_comment
begin_constructor
DECL|function|QAnimationDriver
name|QAnimationDriver
operator|::
name|QAnimationDriver
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|(
operator|new
name|QAnimationDriverPrivate
operator|)
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QAnimationDriver
name|QAnimationDriver
operator|::
name|QAnimationDriver
parameter_list|(
name|QAnimationDriverPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QAnimationDriver
name|QAnimationDriver
operator|::
name|~
name|QAnimationDriver
parameter_list|()
block|{
name|QUnifiedTimer
modifier|*
name|timer
init|=
name|QUnifiedTimer
operator|::
name|instance
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|timer
operator|&&
name|timer
operator|->
name|canUninstallAnimationDriver
argument_list|(
name|this
argument_list|)
condition|)
name|uninstall
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Sets the time at which an animation driver should start at.      This is to take into account that pauses can occur in running     animations which will stop the driver, but the time still     increases.  */
end_comment
begin_function
DECL|function|setStartTime
name|void
name|QAnimationDriver
operator|::
name|setStartTime
parameter_list|(
name|qint64
name|startTime
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAnimationDriver
argument_list|)
expr_stmt|;
name|d
operator|->
name|startTime
operator|=
name|startTime
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the start time of the animation.  */
end_comment
begin_function
DECL|function|startTime
name|qint64
name|QAnimationDriver
operator|::
name|startTime
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAnimationDriver
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|startTime
return|;
block|}
end_function
begin_comment
comment|/*!     Advances the animation based to the specified \a timeStep. This function should     be continuously called by the driver subclasses while the animation is running.      If \a timeStep is positive, it will be used as the current time in the     calculations; otherwise, the current clock time will be used.  */
end_comment
begin_function
DECL|function|advanceAnimation
name|void
name|QAnimationDriver
operator|::
name|advanceAnimation
parameter_list|(
name|qint64
name|timeStep
parameter_list|)
block|{
name|QUnifiedTimer
modifier|*
name|instance
init|=
name|QUnifiedTimer
operator|::
name|instance
argument_list|()
decl_stmt|;
comment|// update current time on all top level animations
name|instance
operator|->
name|updateAnimationTimers
argument_list|(
name|timeStep
argument_list|)
expr_stmt|;
name|instance
operator|->
name|restart
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Advances the animation. This function should be continously called     by the driver while the animation is running.  */
end_comment
begin_function
DECL|function|advance
name|void
name|QAnimationDriver
operator|::
name|advance
parameter_list|()
block|{
name|advanceAnimation
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Installs this animation driver. The animation driver is thread local and     will only apply for the thread its installed in.  */
end_comment
begin_function
DECL|function|install
name|void
name|QAnimationDriver
operator|::
name|install
parameter_list|()
block|{
name|QUnifiedTimer
modifier|*
name|timer
init|=
name|QUnifiedTimer
operator|::
name|instance
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|timer
operator|->
name|installAnimationDriver
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Uninstalls this animation driver.  */
end_comment
begin_function
DECL|function|uninstall
name|void
name|QAnimationDriver
operator|::
name|uninstall
parameter_list|()
block|{
name|QUnifiedTimer
modifier|*
name|timer
init|=
name|QUnifiedTimer
operator|::
name|instance
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|timer
operator|->
name|uninstallAnimationDriver
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isRunning
name|bool
name|QAnimationDriver
operator|::
name|isRunning
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|running
return|;
block|}
end_function
begin_function
DECL|function|start
name|void
name|QAnimationDriver
operator|::
name|start
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAnimationDriver
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|running
condition|)
block|{
emit|emit
name|started
argument_list|()
emit|;
name|d
operator|->
name|running
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|stop
name|void
name|QAnimationDriver
operator|::
name|stop
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAnimationDriver
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|running
condition|)
block|{
emit|emit
name|stopped
argument_list|()
emit|;
name|d
operator|->
name|running
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn qint64 QAnimationDriver::elapsed() const      Returns the number of milliseconds since the animations was started.  */
end_comment
begin_function
DECL|function|elapsed
name|qint64
name|QAnimationDriver
operator|::
name|elapsed
parameter_list|()
specifier|const
block|{
comment|// The default implementation picks up the elapsed time from the
comment|// unified timer and can ignore the time offset.
return|return
name|QUnifiedTimer
operator|::
name|instance
argument_list|()
operator|->
name|time
operator|.
name|elapsed
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QAnimationDriver::started()      This signal is emitted by the animation framework to notify the driver     that continuous animation has started.      \internal  */
end_comment
begin_comment
comment|/*!     \fn QAnimationDriver::stopped()      This signal is emitted by the animation framework to notify the driver     that continuous animation has stopped.      \internal  */
end_comment
begin_comment
comment|/*!    The default animation driver just spins the timer...  */
end_comment
begin_constructor
DECL|function|QDefaultAnimationDriver
name|QDefaultAnimationDriver
operator|::
name|QDefaultAnimationDriver
parameter_list|(
name|QUnifiedTimer
modifier|*
name|timer
parameter_list|)
member_init_list|:
name|QAnimationDriver
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_unified_timer
argument_list|(
name|timer
argument_list|)
block|{
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|started
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|startTimer
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|stopped
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|stopTimer
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|timerEvent
name|void
name|QDefaultAnimationDriver
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|e
operator|->
name|timerId
argument_list|()
operator|==
name|m_timer
operator|.
name|timerId
argument_list|()
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// if the assertions are disabled
name|advance
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|startTimer
name|void
name|QDefaultAnimationDriver
operator|::
name|startTimer
parameter_list|()
block|{
comment|// always use a precise timer to drive animations
name|m_timer
operator|.
name|start
argument_list|(
name|m_unified_timer
operator|->
name|timingInterval
argument_list|,
name|Qt
operator|::
name|PreciseTimer
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stopTimer
name|void
name|QDefaultAnimationDriver
operator|::
name|stopTimer
parameter_list|()
block|{
name|m_timer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setState
name|void
name|QAbstractAnimationPrivate
operator|::
name|setState
parameter_list|(
name|QAbstractAnimation
operator|::
name|State
name|newState
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractAnimation
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|newState
condition|)
return|return;
if|if
condition|(
name|loopCount
operator|==
literal|0
condition|)
return|return;
name|QAbstractAnimation
operator|::
name|State
name|oldState
init|=
name|state
decl_stmt|;
name|int
name|oldCurrentTime
init|=
name|currentTime
decl_stmt|;
name|int
name|oldCurrentLoop
init|=
name|currentLoop
decl_stmt|;
name|QAbstractAnimation
operator|::
name|Direction
name|oldDirection
init|=
name|direction
decl_stmt|;
comment|// check if we should Rewind
if|if
condition|(
operator|(
name|newState
operator|==
name|QAbstractAnimation
operator|::
name|Paused
operator|||
name|newState
operator|==
name|QAbstractAnimation
operator|::
name|Running
operator|)
operator|&&
name|oldState
operator|==
name|QAbstractAnimation
operator|::
name|Stopped
condition|)
block|{
comment|//here we reset the time if needed
comment|//we don't call setCurrentTime because this might change the way the animation
comment|//behaves: changing the state or changing the current value
name|totalCurrentTime
operator|=
name|currentTime
operator|=
operator|(
name|direction
operator|==
name|QAbstractAnimation
operator|::
name|Forward
operator|)
condition|?
literal|0
else|:
operator|(
name|loopCount
operator|==
operator|-
literal|1
condition|?
name|q
operator|->
name|duration
argument_list|()
else|:
name|q
operator|->
name|totalDuration
argument_list|()
operator|)
expr_stmt|;
block|}
name|state
operator|=
name|newState
expr_stmt|;
name|QPointer
argument_list|<
name|QAbstractAnimation
argument_list|>
name|guard
argument_list|(
name|q
argument_list|)
decl_stmt|;
comment|//(un)registration of the animation must always happen before calls to
comment|//virtual function (updateState) to ensure a correct state of the timer
name|bool
name|isTopLevel
init|=
operator|!
name|group
operator|||
name|group
operator|->
name|state
argument_list|()
operator|==
name|QAbstractAnimation
operator|::
name|Stopped
decl_stmt|;
if|if
condition|(
name|oldState
operator|==
name|QAbstractAnimation
operator|::
name|Running
condition|)
block|{
if|if
condition|(
name|newState
operator|==
name|QAbstractAnimation
operator|::
name|Paused
operator|&&
name|hasRegisteredTimer
condition|)
name|QAnimationTimer
operator|::
name|ensureTimerUpdate
argument_list|()
expr_stmt|;
comment|//the animation, is not running any more
name|QAnimationTimer
operator|::
name|unregisterAnimation
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newState
operator|==
name|QAbstractAnimation
operator|::
name|Running
condition|)
block|{
name|QAnimationTimer
operator|::
name|registerAnimation
argument_list|(
name|q
argument_list|,
name|isTopLevel
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|updateState
argument_list|(
name|newState
argument_list|,
name|oldState
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|guard
operator|||
name|newState
operator|!=
name|state
condition|)
comment|//this is to be safe if updateState changes the state
return|return;
comment|// Notify state change
emit|emit
name|q
operator|->
name|stateChanged
argument_list|(
name|newState
argument_list|,
name|oldState
argument_list|)
emit|;
if|if
condition|(
operator|!
name|guard
operator|||
name|newState
operator|!=
name|state
condition|)
comment|//this is to be safe if updateState changes the state
return|return;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|QAbstractAnimation
operator|::
name|Paused
case|:
break|break;
case|case
name|QAbstractAnimation
operator|::
name|Running
case|:
block|{
comment|// this ensures that the value is updated now that the animation is running
if|if
condition|(
name|oldState
operator|==
name|QAbstractAnimation
operator|::
name|Stopped
condition|)
block|{
if|if
condition|(
name|isTopLevel
condition|)
block|{
comment|// currentTime needs to be updated if pauseTimer is active
name|QAnimationTimer
operator|::
name|ensureTimerUpdate
argument_list|()
expr_stmt|;
name|q
operator|->
name|setCurrentTime
argument_list|(
name|totalCurrentTime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|QAbstractAnimation
operator|::
name|Stopped
case|:
comment|// Leave running state.
name|int
name|dura
init|=
name|q
operator|->
name|duration
argument_list|()
decl_stmt|;
if|if
condition|(
name|deleteWhenStopped
condition|)
name|q
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
if|if
condition|(
name|dura
operator|==
operator|-
literal|1
operator|||
name|loopCount
operator|<
literal|0
operator|||
operator|(
name|oldDirection
operator|==
name|QAbstractAnimation
operator|::
name|Forward
operator|&&
operator|(
name|oldCurrentTime
operator|*
operator|(
name|oldCurrentLoop
operator|+
literal|1
operator|)
operator|)
operator|==
operator|(
name|dura
operator|*
name|loopCount
operator|)
operator|)
operator|||
operator|(
name|oldDirection
operator|==
name|QAbstractAnimation
operator|::
name|Backward
operator|&&
name|oldCurrentTime
operator|==
literal|0
operator|)
condition|)
block|{
emit|emit
name|q
operator|->
name|finished
argument_list|()
emit|;
block|}
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     Constructs the QAbstractAnimation base class, and passes \a parent to     QObject's constructor.      \sa QVariantAnimation, QAnimationGroup */
end_comment
begin_constructor
DECL|function|QAbstractAnimation
name|QAbstractAnimation
operator|::
name|QAbstractAnimation
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QAbstractAnimationPrivate
argument_list|,
literal|0
argument_list|)
block|{
comment|// Allow auto-add on reparent
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QAbstractAnimation
name|QAbstractAnimation
operator|::
name|QAbstractAnimation
parameter_list|(
name|QAbstractAnimationPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|)
block|{
comment|// Allow auto-add on reparent
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Stops the animation if it's running, then destroys the     QAbstractAnimation. If the animation is part of a QAnimationGroup, it is     automatically removed before it's destroyed. */
end_comment
begin_destructor
DECL|function|~QAbstractAnimation
name|QAbstractAnimation
operator|::
name|~
name|QAbstractAnimation
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractAnimation
argument_list|)
expr_stmt|;
comment|//we can't call stop here. Otherwise we get pure virtual calls
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|Stopped
condition|)
block|{
name|QAbstractAnimation
operator|::
name|State
name|oldState
init|=
name|d
operator|->
name|state
decl_stmt|;
name|d
operator|->
name|state
operator|=
name|Stopped
expr_stmt|;
emit|emit
name|stateChanged
argument_list|(
name|oldState
argument_list|,
name|d
operator|->
name|state
argument_list|)
emit|;
if|if
condition|(
name|oldState
operator|==
name|QAbstractAnimation
operator|::
name|Running
condition|)
name|QAnimationTimer
operator|::
name|unregisterAnimation
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_destructor
begin_comment
comment|/*!     \property QAbstractAnimation::state     \brief state of the animation.      This property describes the current state of the animation. When the     animation state changes, QAbstractAnimation emits the stateChanged()     signal. */
end_comment
begin_function
DECL|function|state
name|QAbstractAnimation
operator|::
name|State
name|QAbstractAnimation
operator|::
name|state
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractAnimation
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|state
return|;
block|}
end_function
begin_comment
comment|/*!     If this animation is part of a QAnimationGroup, this function returns a     pointer to the group; otherwise, it returns 0.      \sa QAnimationGroup::addAnimation() */
end_comment
begin_function
DECL|function|group
name|QAnimationGroup
modifier|*
name|QAbstractAnimation
operator|::
name|group
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractAnimation
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|group
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QAbstractAnimation::State      This enum describes the state of the animation.      \value Stopped The animation is not running. This is the initial state     of QAbstractAnimation, and the state QAbstractAnimation reenters when finished. The current     time remain unchanged until either setCurrentTime() is     called, or the animation is started by calling start().      \value Paused The animation is paused (i.e., temporarily     suspended). Calling resume() will resume animation activity.      \value Running The animation is running. While control is in the event     loop, QAbstractAnimation will update its current time at regular intervals,     calling updateCurrentTime() when appropriate.      \sa state(), stateChanged() */
end_comment
begin_comment
comment|/*!     \enum QAbstractAnimation::Direction      This enum describes the direction of the animation when in \l Running state.      \value Forward The current time of the animation increases with time (i.e.,     moves from 0 and towards the end / duration).      \value Backward The current time of the animation decreases with time (i.e.,     moves from the end / duration and towards 0).      \sa direction */
end_comment
begin_comment
comment|/*!     \property QAbstractAnimation::direction     \brief the direction of the animation when it is in \l Running     state.      This direction indicates whether the time moves from 0 towards the     animation duration, or from the value of the duration and towards 0 after     start() has been called.      By default, this property is set to \l Forward. */
end_comment
begin_function
DECL|function|direction
name|QAbstractAnimation
operator|::
name|Direction
name|QAbstractAnimation
operator|::
name|direction
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractAnimation
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|direction
return|;
block|}
end_function
begin_function
DECL|function|setDirection
name|void
name|QAbstractAnimation
operator|::
name|setDirection
parameter_list|(
name|Direction
name|direction
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractAnimation
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|direction
operator|==
name|direction
condition|)
return|return;
if|if
condition|(
name|state
argument_list|()
operator|==
name|Stopped
condition|)
block|{
if|if
condition|(
name|direction
operator|==
name|Backward
condition|)
block|{
name|d
operator|->
name|currentTime
operator|=
name|duration
argument_list|()
expr_stmt|;
name|d
operator|->
name|currentLoop
operator|=
name|d
operator|->
name|loopCount
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|currentTime
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|currentLoop
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// the commands order below is important: first we need to setCurrentTime with the old direction,
comment|// then update the direction on this and all children and finally restart the pauseTimer if needed
if|if
condition|(
name|d
operator|->
name|hasRegisteredTimer
condition|)
name|QAnimationTimer
operator|::
name|ensureTimerUpdate
argument_list|()
expr_stmt|;
name|d
operator|->
name|direction
operator|=
name|direction
expr_stmt|;
name|updateDirection
argument_list|(
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasRegisteredTimer
condition|)
comment|// needed to update the timer interval in case of a pause animation
name|QAnimationTimer
operator|::
name|updateAnimationTimer
argument_list|()
expr_stmt|;
emit|emit
name|directionChanged
argument_list|(
name|direction
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \property QAbstractAnimation::duration     \brief the duration of the animation.      If the duration is -1, it means that the duration is undefined.     In this case, loopCount is ignored. */
end_comment
begin_comment
comment|/*!     \property QAbstractAnimation::loopCount     \brief the loop count of the animation      This property describes the loop count of the animation as an integer.     By default this value is 1, indicating that the animation     should run once only, and then stop. By changing it you can let the     animation loop several times. With a value of 0, the animation will not     run at all, and with a value of -1, the animation will loop forever     until stopped.     It is not supported to have loop on an animation that has an undefined     duration. It will only run once. */
end_comment
begin_function
DECL|function|loopCount
name|int
name|QAbstractAnimation
operator|::
name|loopCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractAnimation
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|loopCount
return|;
block|}
end_function
begin_function
DECL|function|setLoopCount
name|void
name|QAbstractAnimation
operator|::
name|setLoopCount
parameter_list|(
name|int
name|loopCount
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractAnimation
argument_list|)
expr_stmt|;
name|d
operator|->
name|loopCount
operator|=
name|loopCount
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QAbstractAnimation::currentLoop     \brief the current loop of the animation      This property describes the current loop of the animation. By default,     the animation's loop count is 1, and so the current loop will     always be 0. If the loop count is 2 and the animation runs past its     duration, it will automatically rewind and restart at current time 0, and     current loop 1, and so on.      When the current loop changes, QAbstractAnimation emits the     currentLoopChanged() signal. */
end_comment
begin_function
DECL|function|currentLoop
name|int
name|QAbstractAnimation
operator|::
name|currentLoop
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractAnimation
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|currentLoop
return|;
block|}
end_function
begin_comment
comment|/*!     \fn virtual int QAbstractAnimation::duration() const = 0      This pure virtual function returns the duration of the animation, and     defines for how long QAbstractAnimation should update the current     time. This duration is local, and does not include the loop count.      A return value of -1 indicates that the animation has no defined duration;     the animation should run forever until stopped. This is useful for     animations that are not time driven, or where you cannot easily predict     its duration (e.g., event driven audio playback in a game).      If the animation is a parallel QAnimationGroup, the duration will be the longest     duration of all its animations. If the animation is a sequential QAnimationGroup,     the duration will be the sum of the duration of all its animations.     \sa loopCount */
end_comment
begin_comment
comment|/*!     Returns the total and effective duration of the animation, including the     loop count.      \sa duration(), currentTime */
end_comment
begin_function
DECL|function|totalDuration
name|int
name|QAbstractAnimation
operator|::
name|totalDuration
parameter_list|()
specifier|const
block|{
name|int
name|dura
init|=
name|duration
argument_list|()
decl_stmt|;
if|if
condition|(
name|dura
operator|<=
literal|0
condition|)
return|return
name|dura
return|;
name|int
name|loopcount
init|=
name|loopCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|loopcount
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|dura
operator|*
name|loopcount
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current time inside the current loop. It can go from 0 to duration().      \sa duration(), currentTime */
end_comment
begin_function
DECL|function|currentLoopTime
name|int
name|QAbstractAnimation
operator|::
name|currentLoopTime
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractAnimation
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|currentTime
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAbstractAnimation::currentTime     \brief the current time and progress of the animation      This property describes the animation's current time. You can change the     current time by calling setCurrentTime, or you can call start() and let     the animation run, setting the current time automatically as the animation     progresses.      The animation's current time starts at 0, and ends at totalDuration().      \sa loopCount, currentLoopTime()  */
end_comment
begin_function
DECL|function|currentTime
name|int
name|QAbstractAnimation
operator|::
name|currentTime
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractAnimation
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|totalCurrentTime
return|;
block|}
end_function
begin_function
DECL|function|setCurrentTime
name|void
name|QAbstractAnimation
operator|::
name|setCurrentTime
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractAnimation
argument_list|)
expr_stmt|;
name|msecs
operator|=
name|qMax
argument_list|(
name|msecs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Calculate new time and loop.
name|int
name|dura
init|=
name|duration
argument_list|()
decl_stmt|;
name|int
name|totalDura
init|=
name|dura
operator|<=
literal|0
condition|?
name|dura
else|:
operator|(
operator|(
name|d
operator|->
name|loopCount
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
name|dura
operator|*
name|d
operator|->
name|loopCount
operator|)
decl_stmt|;
if|if
condition|(
name|totalDura
operator|!=
operator|-
literal|1
condition|)
name|msecs
operator|=
name|qMin
argument_list|(
name|totalDura
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
name|d
operator|->
name|totalCurrentTime
operator|=
name|msecs
expr_stmt|;
comment|// Update new values.
name|int
name|oldLoop
init|=
name|d
operator|->
name|currentLoop
decl_stmt|;
name|d
operator|->
name|currentLoop
operator|=
operator|(
operator|(
name|dura
operator|<=
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|msecs
operator|/
name|dura
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|currentLoop
operator|==
name|d
operator|->
name|loopCount
condition|)
block|{
comment|//we're at the end
name|d
operator|->
name|currentTime
operator|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|dura
argument_list|)
expr_stmt|;
name|d
operator|->
name|currentLoop
operator|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|d
operator|->
name|loopCount
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|direction
operator|==
name|Forward
condition|)
block|{
name|d
operator|->
name|currentTime
operator|=
operator|(
name|dura
operator|<=
literal|0
operator|)
condition|?
name|msecs
else|:
operator|(
name|msecs
operator|%
name|dura
operator|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|currentTime
operator|=
operator|(
name|dura
operator|<=
literal|0
operator|)
condition|?
name|msecs
else|:
operator|(
operator|(
name|msecs
operator|-
literal|1
operator|)
operator|%
name|dura
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|currentTime
operator|==
name|dura
condition|)
operator|--
name|d
operator|->
name|currentLoop
expr_stmt|;
block|}
block|}
name|updateCurrentTime
argument_list|(
name|d
operator|->
name|currentTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|currentLoop
operator|!=
name|oldLoop
condition|)
emit|emit
name|currentLoopChanged
argument_list|(
name|d
operator|->
name|currentLoop
argument_list|)
emit|;
comment|// All animations are responsible for stopping the animation when their
comment|// own end state is reached; in this case the animation is time driven,
comment|// and has reached the end.
if|if
condition|(
operator|(
name|d
operator|->
name|direction
operator|==
name|Forward
operator|&&
name|d
operator|->
name|totalCurrentTime
operator|==
name|totalDura
operator|)
operator|||
operator|(
name|d
operator|->
name|direction
operator|==
name|Backward
operator|&&
name|d
operator|->
name|totalCurrentTime
operator|==
literal|0
operator|)
condition|)
block|{
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Starts the animation. The \a policy argument says whether or not the     animation should be deleted when it's done. When the animation starts, the     stateChanged() signal is emitted, and state() returns Running. When control     reaches the event loop, the animation will run by itself, periodically     calling updateCurrentTime() as the animation progresses.      If the animation is currently stopped or has already reached the end,     calling start() will rewind the animation and start again from the beginning.     When the animation reaches the end, the animation will either stop, or     if the loop level is more than 1, it will rewind and continue from the beginning.      If the animation is already running, this function does nothing.      \sa stop(), state() */
end_comment
begin_function
DECL|function|start
name|void
name|QAbstractAnimation
operator|::
name|start
parameter_list|(
name|DeletionPolicy
name|policy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractAnimation
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Running
condition|)
return|return;
name|d
operator|->
name|deleteWhenStopped
operator|=
name|policy
expr_stmt|;
name|d
operator|->
name|setState
argument_list|(
name|Running
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Stops the animation. When the animation is stopped, it emits the stateChanged()     signal, and state() returns Stopped. The current time is not changed.      If the animation stops by itself after reaching the end (i.e.,     currentLoopTime() == duration() and currentLoop()> loopCount() - 1), the     finished() signal is emitted.      \sa start(), state()  */
end_comment
begin_function
DECL|function|stop
name|void
name|QAbstractAnimation
operator|::
name|stop
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractAnimation
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Stopped
condition|)
return|return;
name|d
operator|->
name|setState
argument_list|(
name|Stopped
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Pauses the animation. When the animation is paused, state() returns Paused.     The value of currentTime will remain unchanged until resume() or start()     is called. If you want to continue from the current time, call resume().      \sa start(), state(), resume()  */
end_comment
begin_function
DECL|function|pause
name|void
name|QAbstractAnimation
operator|::
name|pause
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractAnimation
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Stopped
condition|)
block|{
name|qWarning
argument_list|(
literal|"QAbstractAnimation::pause: Cannot pause a stopped animation"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|setState
argument_list|(
name|Paused
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resumes the animation after it was paused. When the animation is resumed,     it emits the resumed() and stateChanged() signals. The currenttime is not     changed.      \sa start(), pause(), state()  */
end_comment
begin_function
DECL|function|resume
name|void
name|QAbstractAnimation
operator|::
name|resume
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractAnimation
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|Paused
condition|)
block|{
name|qWarning
argument_list|(
literal|"QAbstractAnimation::resume: "
literal|"Cannot resume an animation that is not paused"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|setState
argument_list|(
name|Running
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If \a paused is true, the animation is paused.     If \a paused is false, the animation is resumed.      \sa state(), pause(), resume() */
end_comment
begin_function
DECL|function|setPaused
name|void
name|QAbstractAnimation
operator|::
name|setPaused
parameter_list|(
name|bool
name|paused
parameter_list|)
block|{
if|if
condition|(
name|paused
condition|)
name|pause
argument_list|()
expr_stmt|;
else|else
name|resume
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QAbstractAnimation
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
return|return
name|QObject
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn virtual void QAbstractAnimation::updateCurrentTime(int currentTime) = 0;      This pure virtual function is called every time the animation's     \a currentTime changes.      \sa updateState() */
end_comment
begin_comment
comment|/*!     This virtual function is called by QAbstractAnimation when the state     of the animation is changed from \a oldState to \a newState.      \sa start(), stop(), pause(), resume() */
end_comment
begin_function
DECL|function|updateState
name|void
name|QAbstractAnimation
operator|::
name|updateState
parameter_list|(
name|QAbstractAnimation
operator|::
name|State
name|newState
parameter_list|,
name|QAbstractAnimation
operator|::
name|State
name|oldState
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|oldState
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|newState
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This virtual function is called by QAbstractAnimation when the direction     of the animation is changed. The \a direction argument is the new direction.      \sa setDirection(), direction() */
end_comment
begin_function
DECL|function|updateDirection
name|void
name|QAbstractAnimation
operator|::
name|updateDirection
parameter_list|(
name|QAbstractAnimation
operator|::
name|Direction
name|direction
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|direction
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qabstractanimation.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_ANIMATION
end_comment
end_unit
