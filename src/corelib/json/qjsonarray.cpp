begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qjsonobject.h>
end_include
begin_include
include|#
directive|include
file|<qjsonvalue.h>
end_include
begin_include
include|#
directive|include
file|<qjsonarray.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qvariant.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"qjsonwriter_p.h"
end_include
begin_include
include|#
directive|include
file|"qjson_p.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QJsonArray     \inmodule QtCore     \ingroup json     \reentrant     \since 5.0      \brief The QJsonArray class encapsulates a JSON array.      A JSON array is a list of values. The list can be manipulated by inserting and     removing QJsonValue's from the array.      A QJsonArray can be converted to and from a QVariantList. You can query the     number of entries with size(), insert(), and remove() entries from it     and iterate over its content using the standard C++ iterator pattern.      QJsonArray is an implicitly shared class and shares the data with the document     it has been created from as long as it is not being modified.      You can convert the array to and from text based JSON through QJsonDocument. */
end_comment
begin_comment
comment|/*!     \typedef QJsonArray::Iterator      Qt-style synonym for QJsonArray::iterator. */
end_comment
begin_comment
comment|/*!     \typedef QJsonArray::ConstIterator      Qt-style synonym for QJsonArray::const_iterator. */
end_comment
begin_comment
comment|/*!     \typedef QJsonArray::size_type      Typedef for int. Provided for STL compatibility. */
end_comment
begin_comment
comment|/*!     \typedef QJsonArray::value_type      Typedef for QJsonValue. Provided for STL compatibility. */
end_comment
begin_comment
comment|/*!     \typedef QJsonArray::difference_type      Typedef for int. Provided for STL compatibility. */
end_comment
begin_comment
comment|/*!     \typedef QJsonArray::pointer      Typedef for QJsonValue *. Provided for STL compatibility. */
end_comment
begin_comment
comment|/*!     \typedef QJsonArray::const_pointer      Typedef for const QJsonValue *. Provided for STL compatibility. */
end_comment
begin_comment
comment|/*!     \typedef QJsonArray::reference      Typedef for QJsonValue&. Provided for STL compatibility. */
end_comment
begin_comment
comment|/*!     \typedef QJsonArray::const_reference      Typedef for const QJsonValue&. Provided for STL compatibility. */
end_comment
begin_comment
comment|/*!     Creates an empty array.  */
end_comment
begin_constructor
DECL|function|QJsonArray
name|QJsonArray
operator|::
name|QJsonArray
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|a
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal  */
end_comment
begin_constructor
DECL|function|QJsonArray
name|QJsonArray
operator|::
name|QJsonArray
parameter_list|(
name|QJsonPrivate
operator|::
name|Data
modifier|*
name|data
parameter_list|,
name|QJsonPrivate
operator|::
name|Array
modifier|*
name|array
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|data
argument_list|)
member_init_list|,
name|a
argument_list|(
name|array
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Deletes the array.  */
end_comment
begin_destructor
DECL|function|~QJsonArray
name|QJsonArray
operator|::
name|~
name|QJsonArray
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Creates a copy of \a other.      Since QJsonArray is implicitly shared, the copy is shallow     as long as the object doesn't get modified.  */
end_comment
begin_constructor
DECL|function|QJsonArray
name|QJsonArray
operator|::
name|QJsonArray
parameter_list|(
specifier|const
name|QJsonArray
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
name|a
operator|=
name|other
operator|.
name|a
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns \a other to this array.  */
end_comment
begin_function
DECL|function|operator =
name|QJsonArray
modifier|&
name|QJsonArray
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QJsonArray
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|d
operator|!=
name|other
operator|.
name|d
condition|)
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
name|a
operator|=
name|other
operator|.
name|a
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Converts the string list \a list to a QJsonArray.      The values in \a list will be converted to JSON values.      \sa toVariantList(), QJsonValue::fromVariant()  */
end_comment
begin_function
DECL|function|fromStringList
name|QJsonArray
name|QJsonArray
operator|::
name|fromStringList
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|list
parameter_list|)
block|{
name|QJsonArray
name|array
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|const_iterator
name|it
init|=
name|list
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|list
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|array
operator|.
name|append
argument_list|(
name|QJsonValue
argument_list|(
operator|*
name|it
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
end_function
begin_comment
comment|/*!     Converts the variant list \a list to a QJsonArray.      The QVariant values in \a list will be converted to JSON values.      \sa toVariantList(), QJsonValue::fromVariant()  */
end_comment
begin_function
DECL|function|fromVariantList
name|QJsonArray
name|QJsonArray
operator|::
name|fromVariantList
parameter_list|(
specifier|const
name|QVariantList
modifier|&
name|list
parameter_list|)
block|{
name|QJsonArray
name|array
decl_stmt|;
for|for
control|(
name|QVariantList
operator|::
name|const_iterator
name|it
init|=
name|list
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|list
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|array
operator|.
name|append
argument_list|(
name|QJsonValue
operator|::
name|fromVariant
argument_list|(
operator|*
name|it
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
end_function
begin_comment
comment|/*!     Converts this object to a QVariantList.      Returns the created map.  */
end_comment
begin_function
DECL|function|toVariantList
name|QVariantList
name|QJsonArray
operator|::
name|toVariantList
parameter_list|()
specifier|const
block|{
name|QVariantList
name|list
decl_stmt|;
if|if
condition|(
name|a
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|a
operator|->
name|length
condition|;
operator|++
name|i
control|)
name|list
operator|.
name|append
argument_list|(
name|QJsonValue
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|a
operator|->
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|toVariant
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of values stored in the array.  */
end_comment
begin_function
DECL|function|size
name|int
name|QJsonArray
operator|::
name|size
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|int
operator|)
name|a
operator|->
name|length
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QJsonArray::count() const      Same as size().      \sa size() */
end_comment
begin_comment
comment|/*!     Returns \c true if the object is empty. This is the same as size() == 0.      \sa size()  */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QJsonArray
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|true
return|;
return|return
operator|!
name|a
operator|->
name|length
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QJsonValue representing the value for index \a i.      The returned QJsonValue is \c Undefined, if \a i is out of bounds.   */
end_comment
begin_function
DECL|function|at
name|QJsonValue
name|QJsonArray
operator|::
name|at
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|a
operator|||
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
operator|(
name|int
operator|)
name|a
operator|->
name|length
condition|)
return|return
name|QJsonValue
argument_list|(
name|QJsonValue
operator|::
name|Undefined
argument_list|)
return|;
return|return
name|QJsonValue
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|a
operator|->
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the first value stored in the array.      Same as \c at(0).      \sa at()  */
end_comment
begin_function
DECL|function|first
name|QJsonValue
name|QJsonArray
operator|::
name|first
parameter_list|()
specifier|const
block|{
return|return
name|at
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the last value stored in the array.      Same as \c{at(size() - 1)}.      \sa at()  */
end_comment
begin_function
DECL|function|last
name|QJsonValue
name|QJsonArray
operator|::
name|last
parameter_list|()
specifier|const
block|{
return|return
name|at
argument_list|(
name|a
condition|?
operator|(
name|a
operator|->
name|length
operator|-
literal|1
operator|)
else|:
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts \a value at the beginning of the array.      This is the same as \c{insert(0, value)} and will prepend \a value to the array.      \sa append(), insert()  */
end_comment
begin_function
DECL|function|prepend
name|void
name|QJsonArray
operator|::
name|prepend
parameter_list|(
specifier|const
name|QJsonValue
modifier|&
name|value
parameter_list|)
block|{
name|insert
argument_list|(
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Inserts \a value at the end of the array.      \sa prepend(), insert()  */
end_comment
begin_function
DECL|function|append
name|void
name|QJsonArray
operator|::
name|append
parameter_list|(
specifier|const
name|QJsonValue
modifier|&
name|value
parameter_list|)
block|{
name|insert
argument_list|(
name|a
condition|?
operator|(
name|int
operator|)
name|a
operator|->
name|length
else|:
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes the value at index position \a i. \a i must be a valid     index position in the array (i.e., \c{0<= i< size()}).      \sa insert(), replace()  */
end_comment
begin_function
DECL|function|removeAt
name|void
name|QJsonArray
operator|::
name|removeAt
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
operator|||
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
operator|(
name|int
operator|)
name|a
operator|->
name|length
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|a
operator|->
name|removeItems
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|++
name|d
operator|->
name|compactionCounter
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|compactionCounter
operator|>
literal|32u
operator|&&
name|d
operator|->
name|compactionCounter
operator|>=
name|unsigned
argument_list|(
name|a
operator|->
name|length
argument_list|)
operator|/
literal|2u
condition|)
name|compact
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn void QJsonArray::removeFirst()      Removes the first item in the array. Calling this function is     equivalent to calling \c{removeAt(0)}. The array must not be empty. If     the array can be empty, call isEmpty() before calling this     function.      \sa removeAt(), removeLast() */
end_comment
begin_comment
comment|/*! \fn void QJsonArray::removeLast()      Removes the last item in the array. Calling this function is     equivalent to calling \c{removeAt(size() - 1)}. The array must not be     empty. If the array can be empty, call isEmpty() before calling     this function.      \sa removeAt(), removeFirst() */
end_comment
begin_comment
comment|/*!     Removes the item at index position \a i and returns it. \a i must     be a valid index position in the array (i.e., \c{0<= i< size()}).      If you don't use the return value, removeAt() is more efficient.      \sa removeAt()  */
end_comment
begin_function
DECL|function|takeAt
name|QJsonValue
name|QJsonArray
operator|::
name|takeAt
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
operator|||
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
operator|(
name|int
operator|)
name|a
operator|->
name|length
condition|)
return|return
name|QJsonValue
argument_list|(
name|QJsonValue
operator|::
name|Undefined
argument_list|)
return|;
name|QJsonValue
name|v
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|a
operator|->
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// detaches
return|return
name|v
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts \a value at index position \a i in the array. If \a i     is \c 0, the value is prepended to the array. If \a i is size(), the     value is appended to the array.      \sa append(), prepend(), replace(), removeAt()  */
end_comment
begin_function
DECL|function|insert
name|void
name|QJsonArray
operator|::
name|insert
parameter_list|(
name|int
name|i
parameter_list|,
specifier|const
name|QJsonValue
modifier|&
name|value
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<=
operator|(
name|a
condition|?
operator|(
name|int
operator|)
name|a
operator|->
name|length
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|QJsonValue
name|val
init|=
name|value
decl_stmt|;
name|bool
name|compressed
decl_stmt|;
name|int
name|valueSize
init|=
name|QJsonPrivate
operator|::
name|Value
operator|::
name|requiredStorage
argument_list|(
name|val
argument_list|,
operator|&
name|compressed
argument_list|)
decl_stmt|;
name|detach
argument_list|(
name|valueSize
operator|+
sizeof|sizeof
argument_list|(
name|QJsonPrivate
operator|::
name|Value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|->
name|length
condition|)
name|a
operator|->
name|tableOffset
operator|=
sizeof|sizeof
argument_list|(
name|QJsonPrivate
operator|::
name|Array
argument_list|)
expr_stmt|;
name|int
name|valueOffset
init|=
name|a
operator|->
name|reserveSpace
argument_list|(
name|valueSize
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|valueOffset
condition|)
return|return;
name|QJsonPrivate
operator|::
name|Value
modifier|&
name|v
init|=
operator|(
operator|*
name|a
operator|)
index|[
name|i
index|]
decl_stmt|;
name|v
operator|.
name|type
operator|=
operator|(
name|val
operator|.
name|t
operator|==
name|QJsonValue
operator|::
name|Undefined
condition|?
name|QJsonValue
operator|::
name|Null
else|:
name|val
operator|.
name|t
operator|)
expr_stmt|;
name|v
operator|.
name|latinOrIntValue
operator|=
name|compressed
expr_stmt|;
name|v
operator|.
name|latinKey
operator|=
literal|false
expr_stmt|;
name|v
operator|.
name|value
operator|=
name|QJsonPrivate
operator|::
name|Value
operator|::
name|valueToStore
argument_list|(
name|val
argument_list|,
name|valueOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|valueSize
condition|)
name|QJsonPrivate
operator|::
name|Value
operator|::
name|copyData
argument_list|(
name|val
argument_list|,
operator|(
name|char
operator|*
operator|)
name|a
operator|+
name|valueOffset
argument_list|,
name|compressed
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QJsonArray::iterator QJsonArray::insert(iterator before, const QJsonValue&value)      Inserts \a value before the position pointed to by \a before, and returns an iterator     pointing to the newly inserted item.      \sa erase(), insert() */
end_comment
begin_comment
comment|/*!     \fn QJsonArray::iterator QJsonArray::erase(iterator it)      Removes the item pointed to by \a it, and returns an iterator pointing to the     next item.      \sa removeAt() */
end_comment
begin_comment
comment|/*!     Replaces the item at index position \a i with \a value. \a i must     be a valid index position in the array (i.e., \c{0<= i< size()}).      \sa operator[](), removeAt()  */
end_comment
begin_function
DECL|function|replace
name|void
name|QJsonArray
operator|::
name|replace
parameter_list|(
name|int
name|i
parameter_list|,
specifier|const
name|QJsonValue
modifier|&
name|value
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|a
operator|&&
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
call|(
name|int
call|)
argument_list|(
name|a
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|QJsonValue
name|val
init|=
name|value
decl_stmt|;
name|bool
name|compressed
decl_stmt|;
name|int
name|valueSize
init|=
name|QJsonPrivate
operator|::
name|Value
operator|::
name|requiredStorage
argument_list|(
name|val
argument_list|,
operator|&
name|compressed
argument_list|)
decl_stmt|;
name|detach
argument_list|(
name|valueSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|->
name|length
condition|)
name|a
operator|->
name|tableOffset
operator|=
sizeof|sizeof
argument_list|(
name|QJsonPrivate
operator|::
name|Array
argument_list|)
expr_stmt|;
name|int
name|valueOffset
init|=
name|a
operator|->
name|reserveSpace
argument_list|(
name|valueSize
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|valueOffset
condition|)
return|return;
name|QJsonPrivate
operator|::
name|Value
modifier|&
name|v
init|=
operator|(
operator|*
name|a
operator|)
index|[
name|i
index|]
decl_stmt|;
name|v
operator|.
name|type
operator|=
operator|(
name|val
operator|.
name|t
operator|==
name|QJsonValue
operator|::
name|Undefined
condition|?
name|QJsonValue
operator|::
name|Null
else|:
name|val
operator|.
name|t
operator|)
expr_stmt|;
name|v
operator|.
name|latinOrIntValue
operator|=
name|compressed
expr_stmt|;
name|v
operator|.
name|latinKey
operator|=
literal|false
expr_stmt|;
name|v
operator|.
name|value
operator|=
name|QJsonPrivate
operator|::
name|Value
operator|::
name|valueToStore
argument_list|(
name|val
argument_list|,
name|valueOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|valueSize
condition|)
name|QJsonPrivate
operator|::
name|Value
operator|::
name|copyData
argument_list|(
name|val
argument_list|,
operator|(
name|char
operator|*
operator|)
name|a
operator|+
name|valueOffset
argument_list|,
name|compressed
argument_list|)
expr_stmt|;
operator|++
name|d
operator|->
name|compactionCounter
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|compactionCounter
operator|>
literal|32u
operator|&&
name|d
operator|->
name|compactionCounter
operator|>=
name|unsigned
argument_list|(
name|a
operator|->
name|length
argument_list|)
operator|/
literal|2u
condition|)
name|compact
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the array contains an occurrence of \a value, otherwise \c false.      \sa count()  */
end_comment
begin_function
DECL|function|contains
name|bool
name|QJsonArray
operator|::
name|contains
parameter_list|(
specifier|const
name|QJsonValue
modifier|&
name|value
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|value
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the value at index position \a i as a modifiable reference.     \a i must be a valid index position in the array (i.e., \c{0<= i<     size()}).      The return value is of type QJsonValueRef, a helper class for QJsonArray     and QJsonObject. When you get an object of type QJsonValueRef, you can     use it as if it were a reference to a QJsonValue. If you assign to it,     the assignment will apply to the character in the QJsonArray of QJsonObject     from which you got the reference.      \sa at()  */
end_comment
begin_function
DECL|function|operator []
name|QJsonValueRef
name|QJsonArray
operator|::
name|operator
name|[]
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|a
operator|&&
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
operator|(
name|int
operator|)
name|a
operator|->
name|length
argument_list|)
expr_stmt|;
return|return
name|QJsonValueRef
argument_list|(
name|this
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Same as at().  */
end_comment
begin_function
DECL|function|operator []
name|QJsonValue
name|QJsonArray
operator|::
name|operator
name|[]
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
return|return
name|at
argument_list|(
name|i
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this array is equal to \a other.  */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QJsonArray
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QJsonArray
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|a
operator|==
name|other
operator|.
name|a
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|a
condition|)
return|return
operator|!
name|other
operator|.
name|a
operator|->
name|length
return|;
if|if
condition|(
operator|!
name|other
operator|.
name|a
condition|)
return|return
operator|!
name|a
operator|->
name|length
return|;
if|if
condition|(
name|a
operator|->
name|length
operator|!=
name|other
operator|.
name|a
operator|->
name|length
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|a
operator|->
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|QJsonValue
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|a
operator|->
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
name|QJsonValue
argument_list|(
name|other
operator|.
name|d
argument_list|,
name|other
operator|.
name|a
argument_list|,
name|other
operator|.
name|a
operator|->
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this array is not equal to \a other.  */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QJsonArray
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QJsonArray
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|other
operator|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn QJsonArray::iterator QJsonArray::begin()      Returns an \l{STL-style iterators}{STL-style iterator} pointing to the first item in     the array.      \sa constBegin(), end() */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator QJsonArray::begin() const      \overload */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator QJsonArray::constBegin() const      Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first item     in the array.      \sa begin(), constEnd() */
end_comment
begin_comment
comment|/*! \fn QJsonArray::iterator QJsonArray::end()      Returns an \l{STL-style iterators}{STL-style iterator} pointing to the imaginary item     after the last item in the array.      \sa begin(), constEnd() */
end_comment
begin_comment
comment|/*! \fn const_iterator QJsonArray::end() const      \overload */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator QJsonArray::constEnd() const      Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary     item after the last item in the array.      \sa constBegin(), end() */
end_comment
begin_comment
comment|/*! \fn void QJsonArray::push_back(const QJsonValue&value)      This function is provided for STL compatibility. It is equivalent     to \l{QJsonArray::append()}{append(value)} and will append \a value to the array. */
end_comment
begin_comment
comment|/*! \fn void QJsonArray::push_front(const QJsonValue&value)      This function is provided for STL compatibility. It is equivalent     to \l{QJsonArray::prepend()}{prepend(value)} and will prepend \a value to the array. */
end_comment
begin_comment
comment|/*! \fn void QJsonArray::pop_front()      This function is provided for STL compatibility. It is equivalent     to removeFirst(). The array must not be empty. If the array can be     empty, call isEmpty() before calling this function. */
end_comment
begin_comment
comment|/*! \fn void QJsonArray::pop_back()      This function is provided for STL compatibility. It is equivalent     to removeLast(). The array must not be empty. If the array can be     empty, call isEmpty() before calling this function. */
end_comment
begin_comment
comment|/*! \fn bool QJsonArray::empty() const      This function is provided for STL compatibility. It is equivalent     to isEmpty() and returns \c true if the array is empty. */
end_comment
begin_comment
comment|/*! \class QJsonArray::iterator     \inmodule QtCore     \brief The QJsonArray::iterator class provides an STL-style non-const iterator for QJsonArray.      QJsonArray::iterator allows you to iterate over a QJsonArray     and to modify the array item associated with the     iterator. If you want to iterate over a const QJsonArray, use     QJsonArray::const_iterator instead. It is generally a good practice to     use QJsonArray::const_iterator on a non-const QJsonArray as well, unless     you need to change the QJsonArray through the iterator. Const     iterators are slightly faster and improves code readability.      The default QJsonArray::iterator constructor creates an uninitialized     iterator. You must initialize it using a QJsonArray function like     QJsonArray::begin(), QJsonArray::end(), or QJsonArray::insert() before you can     start iterating.      Most QJsonArray functions accept an integer index rather than an     iterator. For that reason, iterators are rarely useful in     connection with QJsonArray. One place where STL-style iterators do     make sense is as arguments to \l{generic algorithms}.      Multiple iterators can be used on the same array. However, be     aware that any non-const function call performed on the QJsonArray     will render all existing iterators undefined.      \sa QJsonArray::const_iterator */
end_comment
begin_comment
comment|/*! \typedef QJsonArray::iterator::iterator_category    A synonym for \e {std::random_access_iterator_tag} indicating   this iterator is a random access iterator. */
end_comment
begin_comment
comment|/*! \typedef QJsonArray::iterator::difference_type      \internal */
end_comment
begin_comment
comment|/*! \typedef QJsonArray::iterator::value_type      \internal */
end_comment
begin_comment
comment|/*! \typedef QJsonArray::iterator::reference      \internal */
end_comment
begin_comment
comment|/*! \fn QJsonArray::iterator::iterator()      Constructs an uninitialized iterator.      Functions like operator*() and operator++() should not be called     on an uninitialized iterator. Use operator=() to assign a value     to it before using it.      \sa QJsonArray::begin(), QJsonArray::end() */
end_comment
begin_comment
comment|/*! \fn QJsonArray::iterator::iterator(QJsonArray *array, int index)     \internal */
end_comment
begin_comment
comment|/*! \fn QJsonValueRef QJsonArray::iterator::operator*() const      Returns a modifiable reference to the current item.      You can change the value of an item by using operator*() on the     left side of an assignment.      The return value is of type QJsonValueRef, a helper class for QJsonArray     and QJsonObject. When you get an object of type QJsonValueRef, you can     use it as if it were a reference to a QJsonValue. If you assign to it,     the assignment will apply to the character in the QJsonArray of QJsonObject     from which you got the reference. */
end_comment
begin_comment
comment|/*! \fn QJsonValueRef QJsonArray::iterator::operator[](int j) const      Returns a modifiable reference to the item at offset \a j from the     item pointed to by this iterator (the item at position \c{*this + j}).      This function is provided to make QJsonArray iterators behave like C++     pointers.      The return value is of type QJsonValueRef, a helper class for QJsonArray     and QJsonObject. When you get an object of type QJsonValueRef, you can     use it as if it were a reference to a QJsonValue. If you assign to it,     the assignment will apply to the character in the QJsonArray of QJsonObject     from which you got the reference.      \sa operator+() */
end_comment
begin_comment
comment|/*!     \fn bool QJsonArray::iterator::operator==(const iterator&other) const     \fn bool QJsonArray::iterator::operator==(const const_iterator&other) const      Returns \c true if \a other points to the same item as this     iterator; otherwise returns \c false.      \sa operator!=() */
end_comment
begin_comment
comment|/*!     \fn bool QJsonArray::iterator::operator!=(const iterator&other) const     \fn bool QJsonArray::iterator::operator!=(const const_iterator&other) const      Returns \c true if \a other points to a different item than this     iterator; otherwise returns \c false.      \sa operator==() */
end_comment
begin_comment
comment|/*!     \fn bool QJsonArray::iterator::operator<(const iterator& other) const     \fn bool QJsonArray::iterator::operator<(const const_iterator& other) const      Returns \c true if the item pointed to by this iterator is less than     the item pointed to by the \a other iterator. */
end_comment
begin_comment
comment|/*!     \fn bool QJsonArray::iterator::operator<=(const iterator& other) const     \fn bool QJsonArray::iterator::operator<=(const const_iterator& other) const      Returns \c true if the item pointed to by this iterator is less than     or equal to the item pointed to by the \a other iterator. */
end_comment
begin_comment
comment|/*!     \fn bool QJsonArray::iterator::operator>(const iterator& other) const     \fn bool QJsonArray::iterator::operator>(const const_iterator& other) const      Returns \c true if the item pointed to by this iterator is greater     than the item pointed to by the \a other iterator. */
end_comment
begin_comment
comment|/*!     \fn bool QJsonArray::iterator::operator>=(const iterator& other) const     \fn bool QJsonArray::iterator::operator>=(const const_iterator& other) const      Returns \c true if the item pointed to by this iterator is greater     than or equal to the item pointed to by the \a other iterator. */
end_comment
begin_comment
comment|/*! \fn QJsonArray::iterator&QJsonArray::iterator::operator++()      The prefix ++ operator, \c{++it}, advances the iterator to the     next item in the array and returns an iterator to the new current     item.      Calling this function on QJsonArray::end() leads to undefined results.      \sa operator--() */
end_comment
begin_comment
comment|/*! \fn QJsonArray::iterator QJsonArray::iterator::operator++(int)      \overload      The postfix ++ operator, \c{it++}, advances the iterator to the     next item in the array and returns an iterator to the previously     current item. */
end_comment
begin_comment
comment|/*! \fn QJsonArray::iterator&QJsonArray::iterator::operator--()      The prefix -- operator, \c{--it}, makes the preceding item     current and returns an iterator to the new current item.      Calling this function on QJsonArray::begin() leads to undefined results.      \sa operator++() */
end_comment
begin_comment
comment|/*! \fn QJsonArray::iterator QJsonArray::iterator::operator--(int)      \overload      The postfix -- operator, \c{it--}, makes the preceding item     current and returns an iterator to the previously current item. */
end_comment
begin_comment
comment|/*! \fn QJsonArray::iterator&QJsonArray::iterator::operator+=(int j)      Advances the iterator by \a j items. If \a j is negative, the     iterator goes backward.      \sa operator-=(), operator+() */
end_comment
begin_comment
comment|/*! \fn QJsonArray::iterator&QJsonArray::iterator::operator-=(int j)      Makes the iterator go back by \a j items. If \a j is negative,     the iterator goes forward.      \sa operator+=(), operator-() */
end_comment
begin_comment
comment|/*! \fn QJsonArray::iterator QJsonArray::iterator::operator+(int j) const      Returns an iterator to the item at \a j positions forward from     this iterator. If \a j is negative, the iterator goes backward.      \sa operator-(), operator+=() */
end_comment
begin_comment
comment|/*! \fn QJsonArray::iterator QJsonArray::iterator::operator-(int j) const      Returns an iterator to the item at \a j positions backward from     this iterator. If \a j is negative, the iterator goes forward.      \sa operator+(), operator-=() */
end_comment
begin_comment
comment|/*! \fn int QJsonArray::iterator::operator-(iterator other) const      Returns the number of items between the item pointed to by \a     other and the item pointed to by this iterator. */
end_comment
begin_comment
comment|/*! \class QJsonArray::const_iterator     \inmodule QtCore     \brief The QJsonArray::const_iterator class provides an STL-style const iterator for QJsonArray.      QJsonArray::const_iterator allows you to iterate over a     QJsonArray. If you want to modify the QJsonArray as     you iterate over it, use QJsonArray::iterator instead. It is generally a     good practice to use QJsonArray::const_iterator on a non-const QJsonArray     as well, unless you need to change the QJsonArray through the     iterator. Const iterators are slightly faster and improves     code readability.      The default QJsonArray::const_iterator constructor creates an     uninitialized iterator. You must initialize it using a QJsonArray     function like QJsonArray::constBegin(), QJsonArray::constEnd(), or     QJsonArray::insert() before you can start iterating.      Most QJsonArray functions accept an integer index rather than an     iterator. For that reason, iterators are rarely useful in     connection with QJsonArray. One place where STL-style iterators do     make sense is as arguments to \l{generic algorithms}.      Multiple iterators can be used on the same array. However, be     aware that any non-const function call performed on the QJsonArray     will render all existing iterators undefined.      \sa QJsonArray::iterator */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator::const_iterator()      Constructs an uninitialized iterator.      Functions like operator*() and operator++() should not be called     on an uninitialized iterator. Use operator=() to assign a value     to it before using it.      \sa QJsonArray::constBegin(), QJsonArray::constEnd() */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator::const_iterator(const QJsonArray *array, int index)     \internal */
end_comment
begin_comment
comment|/*! \typedef QJsonArray::const_iterator::iterator_category    A synonym for \e {std::random_access_iterator_tag} indicating   this iterator is a random access iterator. */
end_comment
begin_comment
comment|/*! \typedef QJsonArray::const_iterator::difference_type      \internal */
end_comment
begin_comment
comment|/*! \typedef QJsonArray::const_iterator::value_type      \internal */
end_comment
begin_comment
comment|/*! \typedef QJsonArray::const_iterator::reference      \internal */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator::const_iterator(const const_iterator&other)      Constructs a copy of \a other. */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator::const_iterator(const iterator&other)      Constructs a copy of \a other. */
end_comment
begin_comment
comment|/*! \fn QJsonValue QJsonArray::const_iterator::operator*() const      Returns the current item. */
end_comment
begin_comment
comment|/*! \fn QJsonValue QJsonArray::const_iterator::operator[](int j) const      Returns the item at offset \a j from the item pointed to by this iterator (the item at     position \c{*this + j}).      This function is provided to make QJsonArray iterators behave like C++     pointers.      \sa operator+() */
end_comment
begin_comment
comment|/*! \fn bool QJsonArray::const_iterator::operator==(const const_iterator&other) const      Returns \c true if \a other points to the same item as this     iterator; otherwise returns \c false.      \sa operator!=() */
end_comment
begin_comment
comment|/*! \fn bool QJsonArray::const_iterator::operator!=(const const_iterator&other) const      Returns \c true if \a other points to a different item than this     iterator; otherwise returns \c false.      \sa operator==() */
end_comment
begin_comment
comment|/*!     \fn bool QJsonArray::const_iterator::operator<(const const_iterator& other) const      Returns \c true if the item pointed to by this iterator is less than     the item pointed to by the \a other iterator. */
end_comment
begin_comment
comment|/*!     \fn bool QJsonArray::const_iterator::operator<=(const const_iterator& other) const      Returns \c true if the item pointed to by this iterator is less than     or equal to the item pointed to by the \a other iterator. */
end_comment
begin_comment
comment|/*!     \fn bool QJsonArray::const_iterator::operator>(const const_iterator& other) const      Returns \c true if the item pointed to by this iterator is greater     than the item pointed to by the \a other iterator. */
end_comment
begin_comment
comment|/*!     \fn bool QJsonArray::const_iterator::operator>=(const const_iterator& other) const      Returns \c true if the item pointed to by this iterator is greater     than or equal to the item pointed to by the \a other iterator. */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator&QJsonArray::const_iterator::operator++()      The prefix ++ operator, \c{++it}, advances the iterator to the     next item in the array and returns an iterator to the new current     item.      Calling this function on QJsonArray::end() leads to undefined results.      \sa operator--() */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator QJsonArray::const_iterator::operator++(int)      \overload      The postfix ++ operator, \c{it++}, advances the iterator to the     next item in the array and returns an iterator to the previously     current item. */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator&QJsonArray::const_iterator::operator--()      The prefix -- operator, \c{--it}, makes the preceding item     current and returns an iterator to the new current item.      Calling this function on QJsonArray::begin() leads to undefined results.      \sa operator++() */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator QJsonArray::const_iterator::operator--(int)      \overload      The postfix -- operator, \c{it--}, makes the preceding item     current and returns an iterator to the previously current item. */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator&QJsonArray::const_iterator::operator+=(int j)      Advances the iterator by \a j items. If \a j is negative, the     iterator goes backward.      \sa operator-=(), operator+() */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator&QJsonArray::const_iterator::operator-=(int j)      Makes the iterator go back by \a j items. If \a j is negative,     the iterator goes forward.      \sa operator+=(), operator-() */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator QJsonArray::const_iterator::operator+(int j) const      Returns an iterator to the item at \a j positions forward from     this iterator. If \a j is negative, the iterator goes backward.      \sa operator-(), operator+=() */
end_comment
begin_comment
comment|/*! \fn QJsonArray::const_iterator QJsonArray::const_iterator::operator-(int j) const      Returns an iterator to the item at \a j positions backward from     this iterator. If \a j is negative, the iterator goes forward.      \sa operator+(), operator-=() */
end_comment
begin_comment
comment|/*! \fn int QJsonArray::const_iterator::operator-(const_iterator other) const      Returns the number of items between the item pointed to by \a     other and the item pointed to by this iterator. */
end_comment
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|detach
name|void
name|QJsonArray
operator|::
name|detach
parameter_list|(
name|uint
name|reserve
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|d
operator|=
operator|new
name|QJsonPrivate
operator|::
name|Data
argument_list|(
name|reserve
argument_list|,
name|QJsonValue
operator|::
name|Array
argument_list|)
expr_stmt|;
name|a
operator|=
cast|static_cast
argument_list|<
name|QJsonPrivate
operator|::
name|Array
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|header
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
return|return;
block|}
if|if
condition|(
name|reserve
operator|==
literal|0
operator|&&
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
condition|)
return|return;
name|QJsonPrivate
operator|::
name|Data
modifier|*
name|x
init|=
name|d
operator|->
name|clone
argument_list|(
name|a
argument_list|,
name|reserve
argument_list|)
decl_stmt|;
name|x
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|x
expr_stmt|;
name|a
operator|=
cast|static_cast
argument_list|<
name|QJsonPrivate
operator|::
name|Array
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|header
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|compact
name|void
name|QJsonArray
operator|::
name|compact
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|compactionCounter
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|compact
argument_list|()
expr_stmt|;
name|a
operator|=
cast|static_cast
argument_list|<
name|QJsonPrivate
operator|::
name|Array
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|header
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QJsonArray
modifier|&
name|a
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
operator|.
name|a
condition|)
block|{
name|dbg
operator|<<
literal|"QJsonArray()"
expr_stmt|;
return|return
name|dbg
return|;
block|}
name|QByteArray
name|json
decl_stmt|;
name|QJsonPrivate
operator|::
name|Writer
operator|::
name|arrayToJson
argument_list|(
name|a
operator|.
name|a
argument_list|,
name|json
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QJsonArray("
operator|<<
name|json
operator|.
name|constData
argument_list|()
comment|// print as utf-8 string without extra quotation marks
operator|<<
literal|")"
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
